<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h", "content": "//===--- ASTMatchersMacros.h - Structural query framework -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Defines macros that enable us to define new matchers in a single place.\n//  Since a matcher is a function which returns a Matcher<T> object, where\n//  T is the type of the actual implementation of the matcher, the macros allow\n//  us to write matchers like functions and take care of the definition of the\n//  class boilerplate.\n//\n//  Note that when you define a matcher with an AST_MATCHER* macro, only the\n//  function which creates the matcher goes into the current namespace - the\n//  class that implements the actual matcher, which gets returned by the\n//  generator function, is put into the 'internal' namespace. This allows us\n//  to only have the functions (which is all the user cares about) in the\n//  'ast_matchers' namespace and hide the boilerplate.\n//\n//  To define a matcher in user code, put it into your own namespace. This would\n//  help to prevent ODR violations in case a matcher with the same name is\n//  defined in multiple translation units:\n//\n//  namespace my_matchers {\n//  AST_MATCHER_P(clang::MemberExpr, Member,\n//                clang::ast_matchers::internal::Matcher<clang::ValueDecl>,\n//                InnerMatcher) {\n//    return InnerMatcher.matches(*Node.getMemberDecl(), Finder, Builder);\n//  }\n//  } // namespace my_matchers\n//\n//  Alternatively, an unnamed namespace may be used:\n//\n//  namespace clang {\n//  namespace ast_matchers {\n//  namespace {\n//  AST_MATCHER_P(MemberExpr, Member,\n//                internal::Matcher<ValueDecl>, InnerMatcher) {\n//    return InnerMatcher.matches(*Node.getMemberDecl(), Finder, Builder);\n//  }\n//  } // namespace\n//  } // namespace ast_matchers\n//  } // namespace clang\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H\n#define LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H\n\n/// AST_MATCHER_FUNCTION(ReturnType, DefineMatcher) { ... }\n/// defines a zero parameter function named DefineMatcher() that returns a\n/// ReturnType object.\n#define AST_MATCHER_FUNCTION(ReturnType, DefineMatcher)                        \\\n  inline ReturnType DefineMatcher##_getInstance();                             \\\n  inline ReturnType DefineMatcher() {                                          \\\n    return ::clang::ast_matchers::internal::MemoizedMatcher<                   \\\n        ReturnType, DefineMatcher##_getInstance>::getInstance();               \\\n  }                                                                            \\\n  inline ReturnType DefineMatcher##_getInstance()\n\n/// AST_MATCHER_FUNCTION_P(ReturnType, DefineMatcher, ParamType, Param) {\n/// ... }\n/// defines a single-parameter function named DefineMatcher() that returns a\n/// ReturnType object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Param:                 the parameter passed to the function; its type\n///                          is ParamType.\n///\n/// The code should return an instance of ReturnType.\n#define AST_MATCHER_FUNCTION_P(ReturnType, DefineMatcher, ParamType, Param)    \\\n  AST_MATCHER_FUNCTION_P_OVERLOAD(ReturnType, DefineMatcher, ParamType, Param, \\\n                                  0)\n#define AST_MATCHER_FUNCTION_P_OVERLOAD(ReturnType, DefineMatcher, ParamType,  \\\n                                        Param, OverloadId)                     \\\n  inline ReturnType DefineMatcher(ParamType const &Param);                     \\\n  typedef ReturnType (&DefineMatcher##_Type##OverloadId)(ParamType const &);   \\\n  inline ReturnType DefineMatcher(ParamType const &Param)\n\n/// AST_MATCHER(Type, DefineMatcher) { ... }\n/// defines a zero parameter function named DefineMatcher() that returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER(Type, DefineMatcher)                                       \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##Matcher                                       \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##Matcher() = default;                     \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher() {      \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##Matcher());                     \\\n  }                                                                            \\\n  inline bool internal::matcher_##DefineMatcher##Matcher::matches(             \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... }\n/// defines a single-parameter function named DefineMatcher() that returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Param:                 the parameter passed to the function; its type\n///                          is ParamType.\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER_P(Type, DefineMatcher, ParamType, Param)                   \\\n  AST_MATCHER_P_OVERLOAD(Type, DefineMatcher, ParamType, Param, 0)\n\n#define AST_MATCHER_P_OVERLOAD(Type, DefineMatcher, ParamType, Param,          \\\n                               OverloadId)                                     \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        ParamType const &A##Param)                                             \\\n        : Param(A##Param) {}                                                   \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType const Param;                                                     \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      ParamType const &Param) {                                                \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##OverloadId##Matcher(Param));    \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type>(                      \\\n      &DefineMatcher##_Type##OverloadId)(ParamType const &Param);              \\\n  inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_MATCHER_P2(\n///     Type, DefineMatcher, ParamType1, Param1, ParamType2, Param2) { ... }\n/// defines a two-parameter function named DefineMatcher() that returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Param1, Param2:        the parameters passed to the function; their types\n///                          are ParamType1 and ParamType2.\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER_P2(Type, DefineMatcher, ParamType1, Param1, ParamType2,    \\\n                       Param2)                                                 \\\n  AST_MATCHER_P2_OVERLOAD(Type, DefineMatcher, ParamType1, Param1, ParamType2, \\\n                          Param2, 0)\n\n#define AST_MATCHER_P2_OVERLOAD(Type, DefineMatcher, ParamType1, Param1,       \\\n                                ParamType2, Param2, OverloadId)                \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    matcher_##DefineMatcher##OverloadId##Matcher(ParamType1 const &A##Param1,  \\\n                                                 ParamType2 const &A##Param2)  \\\n        : Param1(A##Param1), Param2(A##Param2) {}                              \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType1 const Param1;                                                   \\\n    ParamType2 const Param2;                                                   \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      ParamType1 const &Param1, ParamType2 const &Param2) {                    \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##OverloadId##Matcher(Param1,     \\\n                                                                   Param2));   \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type>(                      \\\n      &DefineMatcher##_Type##OverloadId)(ParamType1 const &Param1,             \\\n                                         ParamType2 const &Param2);            \\\n  inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// Construct a type-list to be passed to the AST_POLYMORPHIC_MATCHER*\n///   macros.\n///\n/// You can't pass something like \\c TypeList<Foo, Bar> to a macro, because it\n/// will look at that as two arguments. However, you can pass\n/// \\c void(TypeList<Foo, Bar>), which works thanks to the parenthesis.\n/// The \\c PolymorphicMatcherWithParam* classes will unpack the function type to\n/// extract the TypeList object.\n#define AST_POLYMORPHIC_SUPPORTED_TYPES(...)                                   \\\n  void(::clang::ast_matchers::internal::TypeList<__VA_ARGS__>)\n\n/// AST_POLYMORPHIC_MATCHER(DefineMatcher) { ... }\n/// defines a single-parameter function named DefineMatcher() that is\n/// polymorphic in the return type.\n///\n/// The variables are the same as for AST_MATCHER, but NodeType will be deduced\n/// from the calling context.\n#define AST_POLYMORPHIC_MATCHER(DefineMatcher, ReturnTypesF)                   \\\n  namespace internal {                                                         \\\n  template <typename NodeType>                                                 \\\n  class matcher_##DefineMatcher##Matcher                                       \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##Matcher, ReturnTypesF>                \\\n  DefineMatcher() {                                                            \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##Matcher, ReturnTypesF>();           \\\n  }                                                                            \\\n  template <typename NodeType>                                                 \\\n  bool internal::matcher_##DefineMatcher##Matcher<NodeType>::matches(          \\\n      const NodeType &Node,                                                    \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_POLYMORPHIC_MATCHER_P(DefineMatcher, ParamType, Param) { ... }\n/// defines a single-parameter function named DefineMatcher() that is\n/// polymorphic in the return type.\n///\n/// The variables are the same as for\n/// AST_MATCHER_P, with the addition of NodeType, which specifies the node type\n/// of the matcher Matcher<NodeType> returned by the function matcher().\n///\n/// FIXME: Pull out common code with above macro?\n#define AST_POLYMORPHIC_MATCHER_P(DefineMatcher, ReturnTypesF, ParamType,      \\\n                                  Param)                                       \\\n  AST_POLYMORPHIC_MATCHER_P_OVERLOAD(DefineMatcher, ReturnTypesF, ParamType,   \\\n                                     Param, 0)\n\n#define AST_POLYMORPHIC_MATCHER_P_OVERLOAD(DefineMatcher, ReturnTypesF,        \\\n                                           ParamType, Param, OverloadId)       \\\n  namespace internal {                                                         \\\n  template <typename NodeType, typename ParamT>                                \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        ParamType const &A##Param)                                             \\\n        : Param(A##Param) {}                                                   \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType const Param;                                                     \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType>                                                               \\\n  DefineMatcher(ParamType const &Param) {                                      \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,  \\\n        ParamType>(Param);                                                     \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType> (&DefineMatcher##_Type##OverloadId)(ParamType const &Param);  \\\n  template <typename NodeType, typename ParamT>                                \\\n  bool internal::                                                              \\\n      matcher_##DefineMatcher##OverloadId##Matcher<NodeType, ParamT>::matches( \\\n          const NodeType &Node,                                                \\\n          ::clang::ast_matchers::internal::ASTMatchFinder *Finder,             \\\n          ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder)     \\\n          const\n\n/// AST_POLYMORPHIC_MATCHER_P2(\n///     DefineMatcher, ParamType1, Param1, ParamType2, Param2) { ... }\n/// defines a two-parameter function named matcher() that is polymorphic in\n/// the return type.\n///\n/// The variables are the same as for AST_MATCHER_P2, with the\n/// addition of NodeType, which specifies the node type of the matcher\n/// Matcher<NodeType> returned by the function DefineMatcher().\n#define AST_POLYMORPHIC_MATCHER_P2(DefineMatcher, ReturnTypesF, ParamType1,    \\\n                                   Param1, ParamType2, Param2)                 \\\n  AST_POLYMORPHIC_MATCHER_P2_OVERLOAD(DefineMatcher, ReturnTypesF, ParamType1, \\\n                                      Param1, ParamType2, Param2, 0)\n\n#define AST_POLYMORPHIC_MATCHER_P2_OVERLOAD(DefineMatcher, ReturnTypesF,       \\\n                                            ParamType1, Param1, ParamType2,    \\\n                                            Param2, OverloadId)                \\\n  namespace internal {                                                         \\\n  template <typename NodeType, typename ParamT1, typename ParamT2>             \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    matcher_##DefineMatcher##OverloadId##Matcher(ParamType1 const &A##Param1,  \\\n                                                 ParamType2 const &A##Param2)  \\\n        : Param1(A##Param1), Param2(A##Param2) {}                              \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType1 const Param1;                                                   \\\n    ParamType2 const Param2;                                                   \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType1, ParamType2>                                                  \\\n  DefineMatcher(ParamType1 const &Param1, ParamType2 const &Param2) {          \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,  \\\n        ParamType1, ParamType2>(Param1, Param2);                               \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType1, ParamType2> (&DefineMatcher##_Type##OverloadId)(             \\\n      ParamType1 const &Param1, ParamType2 const &Param2);                     \\\n  template <typename NodeType, typename ParamT1, typename ParamT2>             \\\n  bool internal::matcher_##DefineMatcher##OverloadId##Matcher<                 \\\n      NodeType, ParamT1, ParamT2>::                                            \\\n      matches(const NodeType &Node,                                            \\\n              ::clang::ast_matchers::internal::ASTMatchFinder *Finder,         \\\n              ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) \\\n          const\n\n// FIXME: add a matcher for TypeLoc derived classes using its custom casting\n// API (no longer dyn_cast) if/when we need such matching\n\n#define AST_TYPE_TRAVERSE_MATCHER_DECL(MatcherName, FunctionName,              \\\n                                       ReturnTypesF)                           \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeMatcher##MatcherName##Getter {              \\\n    static QualType (T::*value())() const { return &T::FunctionName; }         \\\n  };                                                                           \\\n  }                                                                            \\\n  extern const ::clang::ast_matchers::internal::                               \\\n      TypeTraversePolymorphicMatcher<                                          \\\n          QualType,                                                            \\\n          ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter,   \\\n          ::clang::ast_matchers::internal::TypeTraverseMatcher,                \\\n          ReturnTypesF>::Func MatcherName\n\n#define AST_TYPE_TRAVERSE_MATCHER_DEF(MatcherName, ReturnTypesF)               \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      QualType,                                                                \\\n      ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter,       \\\n      ::clang::ast_matchers::internal::TypeTraverseMatcher,                    \\\n      ReturnTypesF>::Func MatcherName\n\n/// AST_TYPE_TRAVERSE_MATCHER(MatcherName, FunctionName) defines\n/// the matcher \\c MatcherName that can be used to traverse from one \\c Type\n/// to another.\n///\n/// For a specific \\c SpecificType, the traversal is done using\n/// \\c SpecificType::FunctionName. The existence of such a function determines\n/// whether a corresponding matcher can be used on \\c SpecificType.\n#define AST_TYPE_TRAVERSE_MATCHER(MatcherName, FunctionName, ReturnTypesF)     \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeMatcher##MatcherName##Getter {              \\\n    static QualType (T::*value())() const { return &T::FunctionName; }         \\\n  };                                                                           \\\n  }                                                                            \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      QualType,                                                                \\\n      ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter,       \\\n      ::clang::ast_matchers::internal::TypeTraverseMatcher,                    \\\n      ReturnTypesF>::Func MatcherName\n\n#define AST_TYPELOC_TRAVERSE_MATCHER_DECL(MatcherName, FunctionName,           \\\n                                          ReturnTypesF)                        \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeLocMatcher##MatcherName##Getter {           \\\n    static TypeLoc (T::*value())() const { return &T::FunctionName##Loc; }     \\\n  };                                                                           \\\n  }                                                                            \\\n  extern const ::clang::ast_matchers::internal::                               \\\n      TypeTraversePolymorphicMatcher<                                          \\\n          TypeLoc,                                                             \\\n          ::clang::ast_matchers::internal::                                    \\\n              TypeLocMatcher##MatcherName##Getter,                             \\\n          ::clang::ast_matchers::internal::TypeLocTraverseMatcher,             \\\n          ReturnTypesF>::Func MatcherName##Loc;                                \\\n  AST_TYPE_TRAVERSE_MATCHER_DECL(MatcherName, FunctionName##Type, ReturnTypesF)\n\n#define AST_TYPELOC_TRAVERSE_MATCHER_DEF(MatcherName, ReturnTypesF)            \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      TypeLoc,                                                                 \\\n      ::clang::ast_matchers::internal::TypeLocMatcher##MatcherName##Getter,    \\\n      ::clang::ast_matchers::internal::TypeLocTraverseMatcher,                 \\\n      ReturnTypesF>::Func MatcherName##Loc;                                    \\\n  AST_TYPE_TRAVERSE_MATCHER_DEF(MatcherName, ReturnTypesF)\n\n/// AST_TYPELOC_TRAVERSE_MATCHER(MatcherName, FunctionName) works\n/// identical to \\c AST_TYPE_TRAVERSE_MATCHER but operates on \\c TypeLocs.\n#define AST_TYPELOC_TRAVERSE_MATCHER(MatcherName, FunctionName, ReturnTypesF)  \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeLocMatcher##MatcherName##Getter {           \\\n    static TypeLoc (T::*value())() const { return &T::FunctionName##Loc; }     \\\n  };                                                                           \\\n  }                                                                            \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      TypeLoc,                                                                 \\\n      ::clang::ast_matchers::internal::TypeLocMatcher##MatcherName##Getter,    \\\n      ::clang::ast_matchers::internal::TypeLocTraverseMatcher,                 \\\n      ReturnTypesF>::Func MatcherName##Loc;                                    \\\n  AST_TYPE_TRAVERSE_MATCHER(MatcherName, FunctionName##Type, ReturnTypesF)\n\n/// AST_MATCHER_REGEX(Type, DefineMatcher, Param) { ... }\n/// defines a function named DefineMatcher() that takes a regular expression\n/// string paramater and an optional RegexFlags parameter and returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Param:                 a pointer to an \\ref llvm::Regex object\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER_REGEX(Type, DefineMatcher, Param)                          \\\n  AST_MATCHER_REGEX_OVERLOAD(Type, DefineMatcher, Param, 0)\n\n#define AST_MATCHER_REGEX_OVERLOAD(Type, DefineMatcher, Param, OverloadId)     \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        std::shared_ptr<llvm::Regex> RE)                                       \\\n        : Param(std::move(RE)) {}                                              \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    std::shared_ptr<llvm::Regex> const Param;                                  \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags) {             \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##OverloadId##Matcher(            \\\n            ::clang::ast_matchers::internal::createAndVerifyRegex(             \\\n                Param, RegexFlags, #DefineMatcher)));                          \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      llvm::StringRef Param) {                                                 \\\n    return DefineMatcher(Param, llvm::Regex::NoFlags);                         \\\n  }                                                                            \\\n                                                                               \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type> (                     \\\n      &DefineMatcher##_Type##OverloadId##Flags)(llvm::StringRef,               \\\n                                                llvm::Regex::RegexFlags);      \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type> (                     \\\n      &DefineMatcher##_Type##OverloadId)(llvm::StringRef);                     \\\n  inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_POLYMORPHIC_MATCHER_REGEX(DefineMatcher, ReturnTypesF, Param) { ... }\n/// defines a function named DefineMatcher() that takes a regular expression\n/// string paramater and an optional RegexFlags parameter that is polymorphic in\n/// the return type.\n///\n/// The variables are the same as for\n/// AST_MATCHER_REGEX, with the addition of NodeType, which specifies the node\n/// type of the matcher Matcher<NodeType> returned by the function matcher().\n#define AST_POLYMORPHIC_MATCHER_REGEX(DefineMatcher, ReturnTypesF, Param)      \\\n  AST_POLYMORPHIC_MATCHER_REGEX_OVERLOAD(DefineMatcher, ReturnTypesF, Param, 0)\n\n#define AST_POLYMORPHIC_MATCHER_REGEX_OVERLOAD(DefineMatcher, ReturnTypesF,    \\\n                                               Param, OverloadId)              \\\n  namespace internal {                                                         \\\n  template <typename NodeType, typename ParamT>                                \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        std::shared_ptr<llvm::Regex> RE)                                       \\\n        : Param(std::move(RE)) {}                                              \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    std::shared_ptr<llvm::Regex> const Param;                                  \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>>                                            \\\n  DefineMatcher(llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags) {   \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,  \\\n        std::shared_ptr<llvm::Regex>>(                                         \\\n        ::clang::ast_matchers::internal::createAndVerifyRegex(                 \\\n            Param, RegexFlags, #DefineMatcher));                               \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>>                                            \\\n  DefineMatcher(llvm::StringRef Param) {                                       \\\n    return DefineMatcher(Param, llvm::Regex::NoFlags);                         \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>> (                                          \\\n      &DefineMatcher##_Type##OverloadId##Flags)(                               \\\n      llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags);              \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>> (&DefineMatcher##_Type##OverloadId)(       \\\n      llvm::StringRef Param);                                                  \\\n  template <typename NodeType, typename ParamT>                                \\\n  bool internal::                                                              \\\n      matcher_##DefineMatcher##OverloadId##Matcher<NodeType, ParamT>::matches( \\\n          const NodeType &Node,                                                \\\n          ::clang::ast_matchers::internal::ASTMatchFinder *Finder,             \\\n          ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder)     \\\n          const\n\n#endif // LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "content": "//===- ASTMatchers.h - Structural query framework ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements matchers to be used together with the MatchFinder to\n//  match AST nodes.\n//\n//  Matchers are created by generator functions, which can be combined in\n//  a functional in-language DSL to express queries over the C++ AST.\n//\n//  For example, to match a class with a certain name, one would call:\n//    cxxRecordDecl(hasName(\"MyClass\"))\n//  which returns a matcher that can be used to find all AST nodes that declare\n//  a class named 'MyClass'.\n//\n//  For more complicated match expressions we're often interested in accessing\n//  multiple parts of the matched AST nodes once a match is found. In that case,\n//  call `.bind(\"name\")` on match expressions that match the nodes you want to\n//  access.\n//\n//  For example, when we're interested in child classes of a certain class, we\n//  would write:\n//    cxxRecordDecl(hasName(\"MyClass\"), has(recordDecl().bind(\"child\")))\n//  When the match is found via the MatchFinder, a user provided callback will\n//  be called with a BoundNodes instance that contains a mapping from the\n//  strings that we provided for the `.bind()` calls to the nodes that were\n//  matched.\n//  In the given example, each time our matcher finds a match we get a callback\n//  where \"child\" is bound to the RecordDecl node of the matching child\n//  class declaration.\n//\n//  See ASTMatchersInternal.h for a more in-depth explanation of the\n//  implementation details of the matcher framework.\n//\n//  See ASTMatchFinder.h for how to use the generated matchers to run over\n//  an AST.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ASTMATCHERS_ASTMATCHERS_H\n#define LLVM_CLANG_ASTMATCHERS_ASTMATCHERS_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTTypeTraits.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclFriend.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/LambdaCapture.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/ParentMapContext.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/StmtObjC.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/ASTMatchers/ASTMatchersInternal.h\"\n#include \"clang/ASTMatchers/ASTMatchersMacros.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Regex.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <limits>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\nnamespace ast_matchers {\n\n/// Maps string IDs to AST nodes matched by parts of a matcher.\n///\n/// The bound nodes are generated by calling \\c bind(\"id\") on the node matchers\n/// of the nodes we want to access later.\n///\n/// The instances of BoundNodes are created by \\c MatchFinder when the user's\n/// callbacks are executed every time a match is found.\nclass BoundNodes {\npublic:\n  /// Returns the AST node bound to \\c ID.\n  ///\n  /// Returns NULL if there was no node bound to \\c ID or if there is a node but\n  /// it cannot be converted to the specified type.\n  template <typename T>\n  const T *getNodeAs(StringRef ID) const {\n    return MyBoundNodes.getNodeAs<T>(ID);\n  }\n\n  /// Type of mapping from binding identifiers to bound nodes. This type\n  /// is an associative container with a key type of \\c std::string and a value\n  /// type of \\c clang::DynTypedNode\n  using IDToNodeMap = internal::BoundNodesMap::IDToNodeMap;\n\n  /// Retrieve mapping from binding identifiers to bound nodes.\n  const IDToNodeMap &getMap() const {\n    return MyBoundNodes.getMap();\n  }\n\nprivate:\n  friend class internal::BoundNodesTreeBuilder;\n\n  /// Create BoundNodes from a pre-filled map of bindings.\n  BoundNodes(internal::BoundNodesMap &MyBoundNodes)\n      : MyBoundNodes(MyBoundNodes) {}\n\n  internal::BoundNodesMap MyBoundNodes;\n};\n\n/// Types of matchers for the top-level classes in the AST class\n/// hierarchy.\n/// @{\nusing DeclarationMatcher = internal::Matcher<Decl>;\nusing StatementMatcher = internal::Matcher<Stmt>;\nusing TypeMatcher = internal::Matcher<QualType>;\nusing TypeLocMatcher = internal::Matcher<TypeLoc>;\nusing NestedNameSpecifierMatcher = internal::Matcher<NestedNameSpecifier>;\nusing NestedNameSpecifierLocMatcher = internal::Matcher<NestedNameSpecifierLoc>;\nusing CXXCtorInitializerMatcher = internal::Matcher<CXXCtorInitializer>;\nusing TemplateArgumentMatcher = internal::Matcher<TemplateArgument>;\nusing TemplateArgumentLocMatcher = internal::Matcher<TemplateArgumentLoc>;\n/// @}\n\n/// Matches any node.\n///\n/// Useful when another matcher requires a child matcher, but there's no\n/// additional constraint. This will often be used with an explicit conversion\n/// to an \\c internal::Matcher<> type such as \\c TypeMatcher.\n///\n/// Example: \\c DeclarationMatcher(anything()) matches all declarations, e.g.,\n/// \\code\n/// \"int* p\" and \"void f()\" in\n///   int* p;\n///   void f();\n/// \\endcode\n///\n/// Usable as: Any Matcher\ninline internal::TrueMatcher anything() { return internal::TrueMatcher(); }\n\n/// Matches the top declaration context.\n///\n/// Given\n/// \\code\n///   int X;\n///   namespace NS {\n///   int Y;\n///   }  // namespace NS\n/// \\endcode\n/// decl(hasDeclContext(translationUnitDecl()))\n///   matches \"int X\", but not \"int Y\".\nextern const internal::VariadicDynCastAllOfMatcher<Decl, TranslationUnitDecl>\n    translationUnitDecl;\n\n/// Matches typedef declarations.\n///\n/// Given\n/// \\code\n///   typedef int X;\n///   using Y = int;\n/// \\endcode\n/// typedefDecl()\n///   matches \"typedef int X\", but not \"using Y = int\"\nextern const internal::VariadicDynCastAllOfMatcher<Decl, TypedefDecl>\n    typedefDecl;\n\n/// Matches typedef name declarations.\n///\n/// Given\n/// \\code\n///   typedef int X;\n///   using Y = int;\n/// \\endcode\n/// typedefNameDecl()\n///   matches \"typedef int X\" and \"using Y = int\"\nextern const internal::VariadicDynCastAllOfMatcher<Decl, TypedefNameDecl>\n    typedefNameDecl;\n\n/// Matches type alias declarations.\n///\n/// Given\n/// \\code\n///   typedef int X;\n///   using Y = int;\n/// \\endcode\n/// typeAliasDecl()\n///   matches \"using Y = int\", but not \"typedef int X\"\nextern const internal::VariadicDynCastAllOfMatcher<Decl, TypeAliasDecl>\n    typeAliasDecl;\n\n/// Matches type alias template declarations.\n///\n/// typeAliasTemplateDecl() matches\n/// \\code\n///   template <typename T>\n///   using Y = X<T>;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, TypeAliasTemplateDecl>\n    typeAliasTemplateDecl;\n\n/// Matches AST nodes that were expanded within the main-file.\n///\n/// Example matches X but not Y\n///   (matcher = cxxRecordDecl(isExpansionInMainFile())\n/// \\code\n///   #include <Y.h>\n///   class X {};\n/// \\endcode\n/// Y.h:\n/// \\code\n///   class Y {};\n/// \\endcode\n///\n/// Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>\nAST_POLYMORPHIC_MATCHER(isExpansionInMainFile,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)) {\n  auto &SourceManager = Finder->getASTContext().getSourceManager();\n  return SourceManager.isInMainFile(\n      SourceManager.getExpansionLoc(Node.getBeginLoc()));\n}\n\n/// Matches AST nodes that were expanded within system-header-files.\n///\n/// Example matches Y but not X\n///     (matcher = cxxRecordDecl(isExpansionInSystemHeader())\n/// \\code\n///   #include <SystemHeader.h>\n///   class X {};\n/// \\endcode\n/// SystemHeader.h:\n/// \\code\n///   class Y {};\n/// \\endcode\n///\n/// Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>\nAST_POLYMORPHIC_MATCHER(isExpansionInSystemHeader,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)) {\n  auto &SourceManager = Finder->getASTContext().getSourceManager();\n  auto ExpansionLoc = SourceManager.getExpansionLoc(Node.getBeginLoc());\n  if (ExpansionLoc.isInvalid()) {\n    return false;\n  }\n  return SourceManager.isInSystemHeader(ExpansionLoc);\n}\n\n/// Matches AST nodes that were expanded within files whose name is\n/// partially matching a given regex.\n///\n/// Example matches Y but not X\n///     (matcher = cxxRecordDecl(isExpansionInFileMatching(\"AST.*\"))\n/// \\code\n///   #include \"ASTMatcher.h\"\n///   class X {};\n/// \\endcode\n/// ASTMatcher.h:\n/// \\code\n///   class Y {};\n/// \\endcode\n///\n/// Usable as: Matcher<Decl>, Matcher<Stmt>, Matcher<TypeLoc>\nAST_POLYMORPHIC_MATCHER_REGEX(isExpansionInFileMatching,\n                              AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt,\n                                                              TypeLoc),\n                              RegExp) {\n  auto &SourceManager = Finder->getASTContext().getSourceManager();\n  auto ExpansionLoc = SourceManager.getExpansionLoc(Node.getBeginLoc());\n  if (ExpansionLoc.isInvalid()) {\n    return false;\n  }\n  auto FileEntry =\n      SourceManager.getFileEntryForID(SourceManager.getFileID(ExpansionLoc));\n  if (!FileEntry) {\n    return false;\n  }\n\n  auto Filename = FileEntry->getName();\n  return RegExp->match(Filename);\n}\n\n/// Matches statements that are (transitively) expanded from the named macro.\n/// Does not match if only part of the statement is expanded from that macro or\n/// if different parts of the the statement are expanded from different\n/// appearances of the macro.\nAST_POLYMORPHIC_MATCHER_P(isExpandedFromMacro,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc),\n                          std::string, MacroName) {\n  // Verifies that the statement' beginning and ending are both expanded from\n  // the same instance of the given macro.\n  auto& Context = Finder->getASTContext();\n  llvm::Optional<SourceLocation> B =\n      internal::getExpansionLocOfMacro(MacroName, Node.getBeginLoc(), Context);\n  if (!B) return false;\n  llvm::Optional<SourceLocation> E =\n      internal::getExpansionLocOfMacro(MacroName, Node.getEndLoc(), Context);\n  if (!E) return false;\n  return *B == *E;\n}\n\n/// Matches declarations.\n///\n/// Examples matches \\c X, \\c C, and the friend declaration inside \\c C;\n/// \\code\n///   void X();\n///   class C {\n///     friend X;\n///   };\n/// \\endcode\nextern const internal::VariadicAllOfMatcher<Decl> decl;\n\n/// Matches decomposition-declarations.\n///\n/// Examples matches the declaration node with \\c foo and \\c bar, but not\n/// \\c number.\n/// (matcher = declStmt(has(decompositionDecl())))\n///\n/// \\code\n///   int number = 42;\n///   auto [foo, bar] = std::make_pair{42, 42};\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, DecompositionDecl>\n    decompositionDecl;\n\n/// Matches binding declarations\n/// Example matches \\c foo and \\c bar\n/// (matcher = bindingDecl()\n///\n/// \\code\n///   auto [foo, bar] = std::make_pair{42, 42};\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, BindingDecl>\n    bindingDecl;\n\n/// Matches a declaration of a linkage specification.\n///\n/// Given\n/// \\code\n///   extern \"C\" {}\n/// \\endcode\n/// linkageSpecDecl()\n///   matches \"extern \"C\" {}\"\nextern const internal::VariadicDynCastAllOfMatcher<Decl, LinkageSpecDecl>\n    linkageSpecDecl;\n\n/// Matches a declaration of anything that could have a name.\n///\n/// Example matches \\c X, \\c S, the anonymous union type, \\c i, and \\c U;\n/// \\code\n///   typedef int X;\n///   struct S {\n///     union {\n///       int i;\n///     } U;\n///   };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, NamedDecl> namedDecl;\n\n/// Matches a declaration of label.\n///\n/// Given\n/// \\code\n///   goto FOO;\n///   FOO: bar();\n/// \\endcode\n/// labelDecl()\n///   matches 'FOO:'\nextern const internal::VariadicDynCastAllOfMatcher<Decl, LabelDecl> labelDecl;\n\n/// Matches a declaration of a namespace.\n///\n/// Given\n/// \\code\n///   namespace {}\n///   namespace test {}\n/// \\endcode\n/// namespaceDecl()\n///   matches \"namespace {}\" and \"namespace test {}\"\nextern const internal::VariadicDynCastAllOfMatcher<Decl, NamespaceDecl>\n    namespaceDecl;\n\n/// Matches a declaration of a namespace alias.\n///\n/// Given\n/// \\code\n///   namespace test {}\n///   namespace alias = ::test;\n/// \\endcode\n/// namespaceAliasDecl()\n///   matches \"namespace alias\" but not \"namespace test\"\nextern const internal::VariadicDynCastAllOfMatcher<Decl, NamespaceAliasDecl>\n    namespaceAliasDecl;\n\n/// Matches class, struct, and union declarations.\n///\n/// Example matches \\c X, \\c Z, \\c U, and \\c S\n/// \\code\n///   class X;\n///   template<class T> class Z {};\n///   struct S {};\n///   union U {};\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, RecordDecl> recordDecl;\n\n/// Matches C++ class declarations.\n///\n/// Example matches \\c X, \\c Z\n/// \\code\n///   class X;\n///   template<class T> class Z {};\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, CXXRecordDecl>\n    cxxRecordDecl;\n\n/// Matches C++ class template declarations.\n///\n/// Example matches \\c Z\n/// \\code\n///   template<class T> class Z {};\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ClassTemplateDecl>\n    classTemplateDecl;\n\n/// Matches C++ class template specializations.\n///\n/// Given\n/// \\code\n///   template<typename T> class A {};\n///   template<> class A<double> {};\n///   A<int> a;\n/// \\endcode\n/// classTemplateSpecializationDecl()\n///   matches the specializations \\c A<int> and \\c A<double>\nextern const internal::VariadicDynCastAllOfMatcher<\n    Decl, ClassTemplateSpecializationDecl>\n    classTemplateSpecializationDecl;\n\n/// Matches C++ class template partial specializations.\n///\n/// Given\n/// \\code\n///   template<class T1, class T2, int I>\n///   class A {};\n///\n///   template<class T, int I>\n///   class A<T, T*, I> {};\n///\n///   template<>\n///   class A<int, int, 1> {};\n/// \\endcode\n/// classTemplatePartialSpecializationDecl()\n///   matches the specialization \\c A<T,T*,I> but not \\c A<int,int,1>\nextern const internal::VariadicDynCastAllOfMatcher<\n    Decl, ClassTemplatePartialSpecializationDecl>\n    classTemplatePartialSpecializationDecl;\n\n/// Matches declarator declarations (field, variable, function\n/// and non-type template parameter declarations).\n///\n/// Given\n/// \\code\n///   class X { int y; };\n/// \\endcode\n/// declaratorDecl()\n///   matches \\c int y.\nextern const internal::VariadicDynCastAllOfMatcher<Decl, DeclaratorDecl>\n    declaratorDecl;\n\n/// Matches parameter variable declarations.\n///\n/// Given\n/// \\code\n///   void f(int x);\n/// \\endcode\n/// parmVarDecl()\n///   matches \\c int x.\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ParmVarDecl>\n    parmVarDecl;\n\n/// Matches C++ access specifier declarations.\n///\n/// Given\n/// \\code\n///   class C {\n///   public:\n///     int a;\n///   };\n/// \\endcode\n/// accessSpecDecl()\n///   matches 'public:'\nextern const internal::VariadicDynCastAllOfMatcher<Decl, AccessSpecDecl>\n    accessSpecDecl;\n\n/// Matches constructor initializers.\n///\n/// Examples matches \\c i(42).\n/// \\code\n///   class C {\n///     C() : i(42) {}\n///     int i;\n///   };\n/// \\endcode\nextern const internal::VariadicAllOfMatcher<CXXCtorInitializer>\n    cxxCtorInitializer;\n\n/// Matches template arguments.\n///\n/// Given\n/// \\code\n///   template <typename T> struct C {};\n///   C<int> c;\n/// \\endcode\n/// templateArgument()\n///   matches 'int' in C<int>.\nextern const internal::VariadicAllOfMatcher<TemplateArgument> templateArgument;\n\n/// Matches template arguments (with location info).\n///\n/// Given\n/// \\code\n///   template <typename T> struct C {};\n///   C<int> c;\n/// \\endcode\n/// templateArgumentLoc()\n///   matches 'int' in C<int>.\nextern const internal::VariadicAllOfMatcher<TemplateArgumentLoc>\n    templateArgumentLoc;\n\n/// Matches template name.\n///\n/// Given\n/// \\code\n///   template <typename T> class X { };\n///   X<int> xi;\n/// \\endcode\n/// templateName()\n///   matches 'X' in X<int>.\nextern const internal::VariadicAllOfMatcher<TemplateName> templateName;\n\n/// Matches non-type template parameter declarations.\n///\n/// Given\n/// \\code\n///   template <typename T, int N> struct C {};\n/// \\endcode\n/// nonTypeTemplateParmDecl()\n///   matches 'N', but not 'T'.\nextern const internal::VariadicDynCastAllOfMatcher<Decl,\n                                                   NonTypeTemplateParmDecl>\n    nonTypeTemplateParmDecl;\n\n/// Matches template type parameter declarations.\n///\n/// Given\n/// \\code\n///   template <typename T, int N> struct C {};\n/// \\endcode\n/// templateTypeParmDecl()\n///   matches 'T', but not 'N'.\nextern const internal::VariadicDynCastAllOfMatcher<Decl, TemplateTypeParmDecl>\n    templateTypeParmDecl;\n\n/// Matches template template parameter declarations.\n///\n/// Given\n/// \\code\n///   template <template <typename> class Z, int N> struct C {};\n/// \\endcode\n/// templateTypeParmDecl()\n///   matches 'Z', but not 'N'.\nextern const internal::VariadicDynCastAllOfMatcher<Decl,\n                                                   TemplateTemplateParmDecl>\n    templateTemplateParmDecl;\n\n/// Matches public C++ declarations and C++ base specifers that specify public\n/// inheritance.\n///\n/// Examples:\n/// \\code\n///   class C {\n///   public:    int a; // fieldDecl(isPublic()) matches 'a'\n///   protected: int b;\n///   private:   int c;\n///   };\n/// \\endcode\n///\n/// \\code\n///   class Base {};\n///   class Derived1 : public Base {}; // matches 'Base'\n///   struct Derived2 : Base {}; // matches 'Base'\n/// \\endcode\nAST_POLYMORPHIC_MATCHER(isPublic,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(Decl,\n                                                        CXXBaseSpecifier)) {\n  return getAccessSpecifier(Node) == AS_public;\n}\n\n/// Matches protected C++ declarations and C++ base specifers that specify\n/// protected inheritance.\n///\n/// Examples:\n/// \\code\n///   class C {\n///   public:    int a;\n///   protected: int b; // fieldDecl(isProtected()) matches 'b'\n///   private:   int c;\n///   };\n/// \\endcode\n///\n/// \\code\n///   class Base {};\n///   class Derived : protected Base {}; // matches 'Base'\n/// \\endcode\nAST_POLYMORPHIC_MATCHER(isProtected,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(Decl,\n                                                        CXXBaseSpecifier)) {\n  return getAccessSpecifier(Node) == AS_protected;\n}\n\n/// Matches private C++ declarations and C++ base specifers that specify private\n/// inheritance.\n///\n/// Examples:\n/// \\code\n///   class C {\n///   public:    int a;\n///   protected: int b;\n///   private:   int c; // fieldDecl(isPrivate()) matches 'c'\n///   };\n/// \\endcode\n///\n/// \\code\n///   struct Base {};\n///   struct Derived1 : private Base {}; // matches 'Base'\n///   class Derived2 : Base {}; // matches 'Base'\n/// \\endcode\nAST_POLYMORPHIC_MATCHER(isPrivate,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(Decl,\n                                                        CXXBaseSpecifier)) {\n  return getAccessSpecifier(Node) == AS_private;\n}\n\n/// Matches non-static data members that are bit-fields.\n///\n/// Given\n/// \\code\n///   class C {\n///     int a : 2;\n///     int b;\n///   };\n/// \\endcode\n/// fieldDecl(isBitField())\n///   matches 'int a;' but not 'int b;'.\nAST_MATCHER(FieldDecl, isBitField) {\n  return Node.isBitField();\n}\n\n/// Matches non-static data members that are bit-fields of the specified\n/// bit width.\n///\n/// Given\n/// \\code\n///   class C {\n///     int a : 2;\n///     int b : 4;\n///     int c : 2;\n///   };\n/// \\endcode\n/// fieldDecl(hasBitWidth(2))\n///   matches 'int a;' and 'int c;' but not 'int b;'.\nAST_MATCHER_P(FieldDecl, hasBitWidth, unsigned, Width) {\n  return Node.isBitField() &&\n         Node.getBitWidthValue(Finder->getASTContext()) == Width;\n}\n\n/// Matches non-static data members that have an in-class initializer.\n///\n/// Given\n/// \\code\n///   class C {\n///     int a = 2;\n///     int b = 3;\n///     int c;\n///   };\n/// \\endcode\n/// fieldDecl(hasInClassInitializer(integerLiteral(equals(2))))\n///   matches 'int a;' but not 'int b;'.\n/// fieldDecl(hasInClassInitializer(anything()))\n///   matches 'int a;' and 'int b;' but not 'int c;'.\nAST_MATCHER_P(FieldDecl, hasInClassInitializer, internal::Matcher<Expr>,\n              InnerMatcher) {\n  const Expr *Initializer = Node.getInClassInitializer();\n  return (Initializer != nullptr &&\n          InnerMatcher.matches(*Initializer, Finder, Builder));\n}\n\n/// Determines whether the function is \"main\", which is the entry point\n/// into an executable program.\nAST_MATCHER(FunctionDecl, isMain) {\n  return Node.isMain();\n}\n\n/// Matches the specialized template of a specialization declaration.\n///\n/// Given\n/// \\code\n///   template<typename T> class A {}; #1\n///   template<> class A<int> {}; #2\n/// \\endcode\n/// classTemplateSpecializationDecl(hasSpecializedTemplate(classTemplateDecl()))\n///   matches '#2' with classTemplateDecl() matching the class template\n///   declaration of 'A' at #1.\nAST_MATCHER_P(ClassTemplateSpecializationDecl, hasSpecializedTemplate,\n              internal::Matcher<ClassTemplateDecl>, InnerMatcher) {\n  const ClassTemplateDecl* Decl = Node.getSpecializedTemplate();\n  return (Decl != nullptr &&\n          InnerMatcher.matches(*Decl, Finder, Builder));\n}\n\n/// Matches a declaration that has been implicitly added\n/// by the compiler (eg. implicit default/copy constructors).\nAST_MATCHER(Decl, isImplicit) {\n  return Node.isImplicit();\n}\n\n/// Matches classTemplateSpecializations, templateSpecializationType and\n/// functionDecl that have at least one TemplateArgument matching the given\n/// InnerMatcher.\n///\n/// Given\n/// \\code\n///   template<typename T> class A {};\n///   template<> class A<double> {};\n///   A<int> a;\n///\n///   template<typename T> f() {};\n///   void func() { f<int>(); };\n/// \\endcode\n///\n/// \\endcode\n/// classTemplateSpecializationDecl(hasAnyTemplateArgument(\n///     refersToType(asString(\"int\"))))\n///   matches the specialization \\c A<int>\n///\n/// functionDecl(hasAnyTemplateArgument(refersToType(asString(\"int\"))))\n///   matches the specialization \\c f<int>\nAST_POLYMORPHIC_MATCHER_P(\n    hasAnyTemplateArgument,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,\n                                    TemplateSpecializationType,\n                                    FunctionDecl),\n    internal::Matcher<TemplateArgument>, InnerMatcher) {\n  ArrayRef<TemplateArgument> List =\n      internal::getTemplateSpecializationArgs(Node);\n  return matchesFirstInRange(InnerMatcher, List.begin(), List.end(), Finder,\n                             Builder) != List.end();\n}\n\n/// Causes all nested matchers to be matched with the specified traversal kind.\n///\n/// Given\n/// \\code\n///   void foo()\n///   {\n///       int i = 3.0;\n///   }\n/// \\endcode\n/// The matcher\n/// \\code\n///   traverse(TK_IgnoreUnlessSpelledInSource,\n///     varDecl(hasInitializer(floatLiteral().bind(\"init\")))\n///   )\n/// \\endcode\n/// matches the variable declaration with \"init\" bound to the \"3.0\".\ntemplate <typename T>\ninternal::Matcher<T> traverse(TraversalKind TK,\n                              const internal::Matcher<T> &InnerMatcher) {\n  return internal::DynTypedMatcher::constructRestrictedWrapper(\n             new internal::TraversalMatcher<T>(TK, InnerMatcher),\n             InnerMatcher.getID().first)\n      .template unconditionalConvertTo<T>();\n}\n\ntemplate <typename T>\ninternal::BindableMatcher<T>\ntraverse(TraversalKind TK, const internal::BindableMatcher<T> &InnerMatcher) {\n  return internal::BindableMatcher<T>(\n      internal::DynTypedMatcher::constructRestrictedWrapper(\n          new internal::TraversalMatcher<T>(TK, InnerMatcher),\n          InnerMatcher.getID().first)\n          .template unconditionalConvertTo<T>());\n}\n\ntemplate <typename... T>\ninternal::TraversalWrapper<internal::VariadicOperatorMatcher<T...>>\ntraverse(TraversalKind TK,\n         const internal::VariadicOperatorMatcher<T...> &InnerMatcher) {\n  return internal::TraversalWrapper<internal::VariadicOperatorMatcher<T...>>(\n      TK, InnerMatcher);\n}\n\ntemplate <template <typename ToArg, typename FromArg> class ArgumentAdapterT,\n          typename T, typename ToTypes>\ninternal::TraversalWrapper<\n    internal::ArgumentAdaptingMatcherFuncAdaptor<ArgumentAdapterT, T, ToTypes>>\ntraverse(TraversalKind TK, const internal::ArgumentAdaptingMatcherFuncAdaptor<\n                               ArgumentAdapterT, T, ToTypes> &InnerMatcher) {\n  return internal::TraversalWrapper<\n      internal::ArgumentAdaptingMatcherFuncAdaptor<ArgumentAdapterT, T,\n                                                   ToTypes>>(TK, InnerMatcher);\n}\n\ntemplate <template <typename T, typename... P> class MatcherT, typename... P,\n          typename ReturnTypesF>\ninternal::TraversalWrapper<\n    internal::PolymorphicMatcher<MatcherT, ReturnTypesF, P...>>\ntraverse(TraversalKind TK,\n         const internal::PolymorphicMatcher<MatcherT, ReturnTypesF, P...>\n             &InnerMatcher) {\n  return internal::TraversalWrapper<\n      internal::PolymorphicMatcher<MatcherT, ReturnTypesF, P...>>(TK,\n                                                                  InnerMatcher);\n}\n\ntemplate <typename... T>\ninternal::Matcher<typename internal::GetClade<T...>::Type>\ntraverse(TraversalKind TK, const internal::MapAnyOfHelper<T...> &InnerMatcher) {\n  return traverse(TK, InnerMatcher.with());\n}\n\n/// Matches expressions that match InnerMatcher after any implicit AST\n/// nodes are stripped off.\n///\n/// Parentheses and explicit casts are not discarded.\n/// Given\n/// \\code\n///   class C {};\n///   C a = C();\n///   C b;\n///   C c = b;\n/// \\endcode\n/// The matchers\n/// \\code\n///    varDecl(hasInitializer(ignoringImplicit(cxxConstructExpr())))\n/// \\endcode\n/// would match the declarations for a, b, and c.\n/// While\n/// \\code\n///    varDecl(hasInitializer(cxxConstructExpr()))\n/// \\endcode\n/// only match the declarations for b and c.\nAST_MATCHER_P(Expr, ignoringImplicit, internal::Matcher<Expr>,\n              InnerMatcher) {\n  return InnerMatcher.matches(*Node.IgnoreImplicit(), Finder, Builder);\n}\n\n/// Matches expressions that match InnerMatcher after any implicit casts\n/// are stripped off.\n///\n/// Parentheses and explicit casts are not discarded.\n/// Given\n/// \\code\n///   int arr[5];\n///   int a = 0;\n///   char b = 0;\n///   const int c = a;\n///   int *d = arr;\n///   long e = (long) 0l;\n/// \\endcode\n/// The matchers\n/// \\code\n///    varDecl(hasInitializer(ignoringImpCasts(integerLiteral())))\n///    varDecl(hasInitializer(ignoringImpCasts(declRefExpr())))\n/// \\endcode\n/// would match the declarations for a, b, c, and d, but not e.\n/// While\n/// \\code\n///    varDecl(hasInitializer(integerLiteral()))\n///    varDecl(hasInitializer(declRefExpr()))\n/// \\endcode\n/// only match the declarations for b, c, and d.\nAST_MATCHER_P(Expr, ignoringImpCasts,\n              internal::Matcher<Expr>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.IgnoreImpCasts(), Finder, Builder);\n}\n\n/// Matches expressions that match InnerMatcher after parentheses and\n/// casts are stripped off.\n///\n/// Implicit and non-C Style casts are also discarded.\n/// Given\n/// \\code\n///   int a = 0;\n///   char b = (0);\n///   void* c = reinterpret_cast<char*>(0);\n///   char d = char(0);\n/// \\endcode\n/// The matcher\n///    varDecl(hasInitializer(ignoringParenCasts(integerLiteral())))\n/// would match the declarations for a, b, c, and d.\n/// while\n///    varDecl(hasInitializer(integerLiteral()))\n/// only match the declaration for a.\nAST_MATCHER_P(Expr, ignoringParenCasts, internal::Matcher<Expr>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.IgnoreParenCasts(), Finder, Builder);\n}\n\n/// Matches expressions that match InnerMatcher after implicit casts and\n/// parentheses are stripped off.\n///\n/// Explicit casts are not discarded.\n/// Given\n/// \\code\n///   int arr[5];\n///   int a = 0;\n///   char b = (0);\n///   const int c = a;\n///   int *d = (arr);\n///   long e = ((long) 0l);\n/// \\endcode\n/// The matchers\n///    varDecl(hasInitializer(ignoringParenImpCasts(integerLiteral())))\n///    varDecl(hasInitializer(ignoringParenImpCasts(declRefExpr())))\n/// would match the declarations for a, b, c, and d, but not e.\n/// while\n///    varDecl(hasInitializer(integerLiteral()))\n///    varDecl(hasInitializer(declRefExpr()))\n/// would only match the declaration for a.\nAST_MATCHER_P(Expr, ignoringParenImpCasts,\n              internal::Matcher<Expr>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.IgnoreParenImpCasts(), Finder, Builder);\n}\n\n/// Matches types that match InnerMatcher after any parens are stripped.\n///\n/// Given\n/// \\code\n///   void (*fp)(void);\n/// \\endcode\n/// The matcher\n/// \\code\n///   varDecl(hasType(pointerType(pointee(ignoringParens(functionType())))))\n/// \\endcode\n/// would match the declaration for fp.\nAST_MATCHER_P_OVERLOAD(QualType, ignoringParens, internal::Matcher<QualType>,\n                       InnerMatcher, 0) {\n  return InnerMatcher.matches(Node.IgnoreParens(), Finder, Builder);\n}\n\n/// Overload \\c ignoringParens for \\c Expr.\n///\n/// Given\n/// \\code\n///   const char* str = (\"my-string\");\n/// \\endcode\n/// The matcher\n/// \\code\n///   implicitCastExpr(hasSourceExpression(ignoringParens(stringLiteral())))\n/// \\endcode\n/// would match the implicit cast resulting from the assignment.\nAST_MATCHER_P_OVERLOAD(Expr, ignoringParens, internal::Matcher<Expr>,\n                       InnerMatcher, 1) {\n  const Expr *E = Node.IgnoreParens();\n  return InnerMatcher.matches(*E, Finder, Builder);\n}\n\n/// Matches expressions that are instantiation-dependent even if it is\n/// neither type- nor value-dependent.\n///\n/// In the following example, the expression sizeof(sizeof(T() + T()))\n/// is instantiation-dependent (since it involves a template parameter T),\n/// but is neither type- nor value-dependent, since the type of the inner\n/// sizeof is known (std::size_t) and therefore the size of the outer\n/// sizeof is known.\n/// \\code\n///   template<typename T>\n///   void f(T x, T y) { sizeof(sizeof(T() + T()); }\n/// \\endcode\n/// expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T())\nAST_MATCHER(Expr, isInstantiationDependent) {\n  return Node.isInstantiationDependent();\n}\n\n/// Matches expressions that are type-dependent because the template type\n/// is not yet instantiated.\n///\n/// For example, the expressions \"x\" and \"x + y\" are type-dependent in\n/// the following code, but \"y\" is not type-dependent:\n/// \\code\n///   template<typename T>\n///   void add(T x, int y) {\n///     x + y;\n///   }\n/// \\endcode\n/// expr(isTypeDependent()) matches x + y\nAST_MATCHER(Expr, isTypeDependent) { return Node.isTypeDependent(); }\n\n/// Matches expression that are value-dependent because they contain a\n/// non-type template parameter.\n///\n/// For example, the array bound of \"Chars\" in the following example is\n/// value-dependent.\n/// \\code\n///   template<int Size> int f() { return Size; }\n/// \\endcode\n/// expr(isValueDependent()) matches return Size\nAST_MATCHER(Expr, isValueDependent) { return Node.isValueDependent(); }\n\n/// Matches classTemplateSpecializations, templateSpecializationType and\n/// functionDecl where the n'th TemplateArgument matches the given InnerMatcher.\n///\n/// Given\n/// \\code\n///   template<typename T, typename U> class A {};\n///   A<bool, int> b;\n///   A<int, bool> c;\n///\n///   template<typename T> void f() {}\n///   void func() { f<int>(); };\n/// \\endcode\n/// classTemplateSpecializationDecl(hasTemplateArgument(\n///     1, refersToType(asString(\"int\"))))\n///   matches the specialization \\c A<bool, int>\n///\n/// functionDecl(hasTemplateArgument(0, refersToType(asString(\"int\"))))\n///   matches the specialization \\c f<int>\nAST_POLYMORPHIC_MATCHER_P2(\n    hasTemplateArgument,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,\n                                    TemplateSpecializationType,\n                                    FunctionDecl),\n    unsigned, N, internal::Matcher<TemplateArgument>, InnerMatcher) {\n  ArrayRef<TemplateArgument> List =\n      internal::getTemplateSpecializationArgs(Node);\n  if (List.size() <= N)\n    return false;\n  return InnerMatcher.matches(List[N], Finder, Builder);\n}\n\n/// Matches if the number of template arguments equals \\p N.\n///\n/// Given\n/// \\code\n///   template<typename T> struct C {};\n///   C<int> c;\n/// \\endcode\n/// classTemplateSpecializationDecl(templateArgumentCountIs(1))\n///   matches C<int>.\nAST_POLYMORPHIC_MATCHER_P(\n    templateArgumentCountIs,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,\n                                    TemplateSpecializationType),\n    unsigned, N) {\n  return internal::getTemplateSpecializationArgs(Node).size() == N;\n}\n\n/// Matches a TemplateArgument that refers to a certain type.\n///\n/// Given\n/// \\code\n///   struct X {};\n///   template<typename T> struct A {};\n///   A<X> a;\n/// \\endcode\n/// classTemplateSpecializationDecl(hasAnyTemplateArgument(\n///     refersToType(class(hasName(\"X\")))))\n///   matches the specialization \\c A<X>\nAST_MATCHER_P(TemplateArgument, refersToType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  if (Node.getKind() != TemplateArgument::Type)\n    return false;\n  return InnerMatcher.matches(Node.getAsType(), Finder, Builder);\n}\n\n/// Matches a TemplateArgument that refers to a certain template.\n///\n/// Given\n/// \\code\n///   template<template <typename> class S> class X {};\n///   template<typename T> class Y {};\n///   X<Y> xi;\n/// \\endcode\n/// classTemplateSpecializationDecl(hasAnyTemplateArgument(\n///     refersToTemplate(templateName())))\n///   matches the specialization \\c X<Y>\nAST_MATCHER_P(TemplateArgument, refersToTemplate,\n              internal::Matcher<TemplateName>, InnerMatcher) {\n  if (Node.getKind() != TemplateArgument::Template)\n    return false;\n  return InnerMatcher.matches(Node.getAsTemplate(), Finder, Builder);\n}\n\n/// Matches a canonical TemplateArgument that refers to a certain\n/// declaration.\n///\n/// Given\n/// \\code\n///   struct B { int next; };\n///   template<int(B::*next_ptr)> struct A {};\n///   A<&B::next> a;\n/// \\endcode\n/// classTemplateSpecializationDecl(hasAnyTemplateArgument(\n///     refersToDeclaration(fieldDecl(hasName(\"next\")))))\n///   matches the specialization \\c A<&B::next> with \\c fieldDecl(...) matching\n///     \\c B::next\nAST_MATCHER_P(TemplateArgument, refersToDeclaration,\n              internal::Matcher<Decl>, InnerMatcher) {\n  if (Node.getKind() == TemplateArgument::Declaration)\n    return InnerMatcher.matches(*Node.getAsDecl(), Finder, Builder);\n  return false;\n}\n\n/// Matches a sugar TemplateArgument that refers to a certain expression.\n///\n/// Given\n/// \\code\n///   struct B { int next; };\n///   template<int(B::*next_ptr)> struct A {};\n///   A<&B::next> a;\n/// \\endcode\n/// templateSpecializationType(hasAnyTemplateArgument(\n///   isExpr(hasDescendant(declRefExpr(to(fieldDecl(hasName(\"next\"))))))))\n///   matches the specialization \\c A<&B::next> with \\c fieldDecl(...) matching\n///     \\c B::next\nAST_MATCHER_P(TemplateArgument, isExpr, internal::Matcher<Expr>, InnerMatcher) {\n  if (Node.getKind() == TemplateArgument::Expression)\n    return InnerMatcher.matches(*Node.getAsExpr(), Finder, Builder);\n  return false;\n}\n\n/// Matches a TemplateArgument that is an integral value.\n///\n/// Given\n/// \\code\n///   template<int T> struct C {};\n///   C<42> c;\n/// \\endcode\n/// classTemplateSpecializationDecl(\n///   hasAnyTemplateArgument(isIntegral()))\n///   matches the implicit instantiation of C in C<42>\n///   with isIntegral() matching 42.\nAST_MATCHER(TemplateArgument, isIntegral) {\n  return Node.getKind() == TemplateArgument::Integral;\n}\n\n/// Matches a TemplateArgument that refers to an integral type.\n///\n/// Given\n/// \\code\n///   template<int T> struct C {};\n///   C<42> c;\n/// \\endcode\n/// classTemplateSpecializationDecl(\n///   hasAnyTemplateArgument(refersToIntegralType(asString(\"int\"))))\n///   matches the implicit instantiation of C in C<42>.\nAST_MATCHER_P(TemplateArgument, refersToIntegralType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  if (Node.getKind() != TemplateArgument::Integral)\n    return false;\n  return InnerMatcher.matches(Node.getIntegralType(), Finder, Builder);\n}\n\n/// Matches a TemplateArgument of integral type with a given value.\n///\n/// Note that 'Value' is a string as the template argument's value is\n/// an arbitrary precision integer. 'Value' must be euqal to the canonical\n/// representation of that integral value in base 10.\n///\n/// Given\n/// \\code\n///   template<int T> struct C {};\n///   C<42> c;\n/// \\endcode\n/// classTemplateSpecializationDecl(\n///   hasAnyTemplateArgument(equalsIntegralValue(\"42\")))\n///   matches the implicit instantiation of C in C<42>.\nAST_MATCHER_P(TemplateArgument, equalsIntegralValue,\n              std::string, Value) {\n  if (Node.getKind() != TemplateArgument::Integral)\n    return false;\n  return Node.getAsIntegral().toString(10) == Value;\n}\n\n/// Matches an Objective-C autorelease pool statement.\n///\n/// Given\n/// \\code\n///   @autoreleasepool {\n///     int x = 0;\n///   }\n/// \\endcode\n/// autoreleasePoolStmt(stmt()) matches the declaration of \"x\"\n/// inside the autorelease pool.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n       ObjCAutoreleasePoolStmt> autoreleasePoolStmt;\n\n/// Matches any value declaration.\n///\n/// Example matches A, B, C and F\n/// \\code\n///   enum X { A, B, C };\n///   void F();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ValueDecl> valueDecl;\n\n/// Matches C++ constructor declarations.\n///\n/// Example matches Foo::Foo() and Foo::Foo(int)\n/// \\code\n///   class Foo {\n///    public:\n///     Foo();\n///     Foo(int);\n///     int DoSomething();\n///   };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, CXXConstructorDecl>\n    cxxConstructorDecl;\n\n/// Matches explicit C++ destructor declarations.\n///\n/// Example matches Foo::~Foo()\n/// \\code\n///   class Foo {\n///    public:\n///     virtual ~Foo();\n///   };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, CXXDestructorDecl>\n    cxxDestructorDecl;\n\n/// Matches enum declarations.\n///\n/// Example matches X\n/// \\code\n///   enum X {\n///     A, B, C\n///   };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, EnumDecl> enumDecl;\n\n/// Matches enum constants.\n///\n/// Example matches A, B, C\n/// \\code\n///   enum X {\n///     A, B, C\n///   };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, EnumConstantDecl>\n    enumConstantDecl;\n\n/// Matches tag declarations.\n///\n/// Example matches X, Z, U, S, E\n/// \\code\n///   class X;\n///   template<class T> class Z {};\n///   struct S {};\n///   union U {};\n///   enum E {\n///     A, B, C\n///   };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, TagDecl> tagDecl;\n\n/// Matches method declarations.\n///\n/// Example matches y\n/// \\code\n///   class X { void y(); };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, CXXMethodDecl>\n    cxxMethodDecl;\n\n/// Matches conversion operator declarations.\n///\n/// Example matches the operator.\n/// \\code\n///   class X { operator int() const; };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, CXXConversionDecl>\n    cxxConversionDecl;\n\n/// Matches user-defined and implicitly generated deduction guide.\n///\n/// Example matches the deduction guide.\n/// \\code\n///   template<typename T>\n///   class X { X(int) };\n///   X(int) -> X<int>;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, CXXDeductionGuideDecl>\n    cxxDeductionGuideDecl;\n\n/// Matches variable declarations.\n///\n/// Note: this does not match declarations of member variables, which are\n/// \"field\" declarations in Clang parlance.\n///\n/// Example matches a\n/// \\code\n///   int a;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, VarDecl> varDecl;\n\n/// Matches field declarations.\n///\n/// Given\n/// \\code\n///   class X { int m; };\n/// \\endcode\n/// fieldDecl()\n///   matches 'm'.\nextern const internal::VariadicDynCastAllOfMatcher<Decl, FieldDecl> fieldDecl;\n\n/// Matches indirect field declarations.\n///\n/// Given\n/// \\code\n///   struct X { struct { int a; }; };\n/// \\endcode\n/// indirectFieldDecl()\n///   matches 'a'.\nextern const internal::VariadicDynCastAllOfMatcher<Decl, IndirectFieldDecl>\n    indirectFieldDecl;\n\n/// Matches function declarations.\n///\n/// Example matches f\n/// \\code\n///   void f();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, FunctionDecl>\n    functionDecl;\n\n/// Matches C++ function template declarations.\n///\n/// Example matches f\n/// \\code\n///   template<class T> void f(T t) {}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, FunctionTemplateDecl>\n    functionTemplateDecl;\n\n/// Matches friend declarations.\n///\n/// Given\n/// \\code\n///   class X { friend void foo(); };\n/// \\endcode\n/// friendDecl()\n///   matches 'friend void foo()'.\nextern const internal::VariadicDynCastAllOfMatcher<Decl, FriendDecl> friendDecl;\n\n/// Matches statements.\n///\n/// Given\n/// \\code\n///   { ++a; }\n/// \\endcode\n/// stmt()\n///   matches both the compound statement '{ ++a; }' and '++a'.\nextern const internal::VariadicAllOfMatcher<Stmt> stmt;\n\n/// Matches declaration statements.\n///\n/// Given\n/// \\code\n///   int a;\n/// \\endcode\n/// declStmt()\n///   matches 'int a'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, DeclStmt> declStmt;\n\n/// Matches member expressions.\n///\n/// Given\n/// \\code\n///   class Y {\n///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }\n///     int a; static int b;\n///   };\n/// \\endcode\n/// memberExpr()\n///   matches this->x, x, y.x, a, this->b\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, MemberExpr> memberExpr;\n\n/// Matches unresolved member expressions.\n///\n/// Given\n/// \\code\n///   struct X {\n///     template <class T> void f();\n///     void g();\n///   };\n///   template <class T> void h() { X x; x.f<T>(); x.g(); }\n/// \\endcode\n/// unresolvedMemberExpr()\n///   matches x.f<T>\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, UnresolvedMemberExpr>\n    unresolvedMemberExpr;\n\n/// Matches member expressions where the actual member referenced could not be\n/// resolved because the base expression or the member name was dependent.\n///\n/// Given\n/// \\code\n///   template <class T> void f() { T t; t.g(); }\n/// \\endcode\n/// cxxDependentScopeMemberExpr()\n///   matches t.g\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   CXXDependentScopeMemberExpr>\n    cxxDependentScopeMemberExpr;\n\n/// Matches call expressions.\n///\n/// Example matches x.y() and y()\n/// \\code\n///   X x;\n///   x.y();\n///   y();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CallExpr> callExpr;\n\n/// Matches call expressions which were resolved using ADL.\n///\n/// Example matches y(x) but not y(42) or NS::y(x).\n/// \\code\n///   namespace NS {\n///     struct X {};\n///     void y(X);\n///   }\n///\n///   void y(...);\n///\n///   void test() {\n///     NS::X x;\n///     y(x); // Matches\n///     NS::y(x); // Doesn't match\n///     y(42); // Doesn't match\n///     using NS::y;\n///     y(x); // Found by both unqualified lookup and ADL, doesn't match\n//    }\n/// \\endcode\nAST_MATCHER(CallExpr, usesADL) { return Node.usesADL(); }\n\n/// Matches lambda expressions.\n///\n/// Example matches [&](){return 5;}\n/// \\code\n///   [&](){return 5;}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, LambdaExpr> lambdaExpr;\n\n/// Matches member call expressions.\n///\n/// Example matches x.y()\n/// \\code\n///   X x;\n///   x.y();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXMemberCallExpr>\n    cxxMemberCallExpr;\n\n/// Matches ObjectiveC Message invocation expressions.\n///\n/// The innermost message send invokes the \"alloc\" class method on the\n/// NSString class, while the outermost message send invokes the\n/// \"initWithString\" instance method on the object returned from\n/// NSString's \"alloc\". This matcher should match both message sends.\n/// \\code\n///   [[NSString alloc] initWithString:@\"Hello\"]\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ObjCMessageExpr>\n    objcMessageExpr;\n\n/// Matches Objective-C interface declarations.\n///\n/// Example matches Foo\n/// \\code\n///   @interface Foo\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCInterfaceDecl>\n    objcInterfaceDecl;\n\n/// Matches Objective-C implementation declarations.\n///\n/// Example matches Foo\n/// \\code\n///   @implementation Foo\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCImplementationDecl>\n    objcImplementationDecl;\n\n/// Matches Objective-C protocol declarations.\n///\n/// Example matches FooDelegate\n/// \\code\n///   @protocol FooDelegate\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCProtocolDecl>\n    objcProtocolDecl;\n\n/// Matches Objective-C category declarations.\n///\n/// Example matches Foo (Additions)\n/// \\code\n///   @interface Foo (Additions)\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCCategoryDecl>\n    objcCategoryDecl;\n\n/// Matches Objective-C category definitions.\n///\n/// Example matches Foo (Additions)\n/// \\code\n///   @implementation Foo (Additions)\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCCategoryImplDecl>\n    objcCategoryImplDecl;\n\n/// Matches Objective-C method declarations.\n///\n/// Example matches both declaration and definition of -[Foo method]\n/// \\code\n///   @interface Foo\n///   - (void)method;\n///   @end\n///\n///   @implementation Foo\n///   - (void)method {}\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCMethodDecl>\n    objcMethodDecl;\n\n/// Matches block declarations.\n///\n/// Example matches the declaration of the nameless block printing an input\n/// integer.\n///\n/// \\code\n///   myFunc(^(int p) {\n///     printf(\"%d\", p);\n///   })\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, BlockDecl>\n    blockDecl;\n\n/// Matches Objective-C instance variable declarations.\n///\n/// Example matches _enabled\n/// \\code\n///   @implementation Foo {\n///     BOOL _enabled;\n///   }\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCIvarDecl>\n    objcIvarDecl;\n\n/// Matches Objective-C property declarations.\n///\n/// Example matches enabled\n/// \\code\n///   @interface Foo\n///   @property BOOL enabled;\n///   @end\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, ObjCPropertyDecl>\n    objcPropertyDecl;\n\n/// Matches Objective-C \\@throw statements.\n///\n/// Example matches \\@throw\n/// \\code\n///   @throw obj;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ObjCAtThrowStmt>\n    objcThrowStmt;\n\n/// Matches Objective-C @try statements.\n///\n/// Example matches @try\n/// \\code\n///   @try {}\n///   @catch (...) {}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ObjCAtTryStmt>\n    objcTryStmt;\n\n/// Matches Objective-C @catch statements.\n///\n/// Example matches @catch\n/// \\code\n///   @try {}\n///   @catch (...) {}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ObjCAtCatchStmt>\n    objcCatchStmt;\n\n/// Matches Objective-C @finally statements.\n///\n/// Example matches @finally\n/// \\code\n///   @try {}\n///   @finally {}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ObjCAtFinallyStmt>\n    objcFinallyStmt;\n\n/// Matches expressions that introduce cleanups to be run at the end\n/// of the sub-expression's evaluation.\n///\n/// Example matches std::string()\n/// \\code\n///   const std::string str = std::string();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ExprWithCleanups>\n    exprWithCleanups;\n\n/// Matches init list expressions.\n///\n/// Given\n/// \\code\n///   int a[] = { 1, 2 };\n///   struct B { int x, y; };\n///   B b = { 5, 6 };\n/// \\endcode\n/// initListExpr()\n///   matches \"{ 1, 2 }\" and \"{ 5, 6 }\"\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, InitListExpr>\n    initListExpr;\n\n/// Matches the syntactic form of init list expressions\n/// (if expression have it).\nAST_MATCHER_P(InitListExpr, hasSyntacticForm,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *SyntForm = Node.getSyntacticForm();\n  return (SyntForm != nullptr &&\n          InnerMatcher.matches(*SyntForm, Finder, Builder));\n}\n\n/// Matches C++ initializer list expressions.\n///\n/// Given\n/// \\code\n///   std::vector<int> a({ 1, 2, 3 });\n///   std::vector<int> b = { 4, 5 };\n///   int c[] = { 6, 7 };\n///   std::pair<int, int> d = { 8, 9 };\n/// \\endcode\n/// cxxStdInitializerListExpr()\n///   matches \"{ 1, 2, 3 }\" and \"{ 4, 5 }\"\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   CXXStdInitializerListExpr>\n    cxxStdInitializerListExpr;\n\n/// Matches implicit initializers of init list expressions.\n///\n/// Given\n/// \\code\n///   point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };\n/// \\endcode\n/// implicitValueInitExpr()\n///   matches \"[0].y\" (implicitly)\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ImplicitValueInitExpr>\n    implicitValueInitExpr;\n\n/// Matches paren list expressions.\n/// ParenListExprs don't have a predefined type and are used for late parsing.\n/// In the final AST, they can be met in template declarations.\n///\n/// Given\n/// \\code\n///   template<typename T> class X {\n///     void f() {\n///       X x(*this);\n///       int a = 0, b = 1; int i = (a, b);\n///     }\n///   };\n/// \\endcode\n/// parenListExpr() matches \"*this\" but NOT matches (a, b) because (a, b)\n/// has a predefined type and is a ParenExpr, not a ParenListExpr.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ParenListExpr>\n    parenListExpr;\n\n/// Matches substitutions of non-type template parameters.\n///\n/// Given\n/// \\code\n///   template <int N>\n///   struct A { static const int n = N; };\n///   struct B : public A<42> {};\n/// \\endcode\n/// substNonTypeTemplateParmExpr()\n///   matches \"N\" in the right-hand side of \"static const int n = N;\"\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   SubstNonTypeTemplateParmExpr>\n    substNonTypeTemplateParmExpr;\n\n/// Matches using declarations.\n///\n/// Given\n/// \\code\n///   namespace X { int x; }\n///   using X::x;\n/// \\endcode\n/// usingDecl()\n///   matches \\code using X::x \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, UsingDecl> usingDecl;\n\n/// Matches using namespace declarations.\n///\n/// Given\n/// \\code\n///   namespace X { int x; }\n///   using namespace X;\n/// \\endcode\n/// usingDirectiveDecl()\n///   matches \\code using namespace X \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, UsingDirectiveDecl>\n    usingDirectiveDecl;\n\n/// Matches reference to a name that can be looked up during parsing\n/// but could not be resolved to a specific declaration.\n///\n/// Given\n/// \\code\n///   template<typename T>\n///   T foo() { T a; return a; }\n///   template<typename T>\n///   void bar() {\n///     foo<T>();\n///   }\n/// \\endcode\n/// unresolvedLookupExpr()\n///   matches \\code foo<T>() \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, UnresolvedLookupExpr>\n    unresolvedLookupExpr;\n\n/// Matches unresolved using value declarations.\n///\n/// Given\n/// \\code\n///   template<typename X>\n///   class C : private X {\n///     using X::x;\n///   };\n/// \\endcode\n/// unresolvedUsingValueDecl()\n///   matches \\code using X::x \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl,\n                                                   UnresolvedUsingValueDecl>\n    unresolvedUsingValueDecl;\n\n/// Matches unresolved using value declarations that involve the\n/// typename.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   struct Base { typedef T Foo; };\n///\n///   template<typename T>\n///   struct S : private Base<T> {\n///     using typename Base<T>::Foo;\n///   };\n/// \\endcode\n/// unresolvedUsingTypenameDecl()\n///   matches \\code using Base<T>::Foo \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl,\n                                                   UnresolvedUsingTypenameDecl>\n    unresolvedUsingTypenameDecl;\n\n/// Matches a constant expression wrapper.\n///\n/// Example matches the constant in the case statement:\n///     (matcher = constantExpr())\n/// \\code\n///   switch (a) {\n///   case 37: break;\n///   }\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ConstantExpr>\n    constantExpr;\n\n/// Matches parentheses used in expressions.\n///\n/// Example matches (foo() + 1)\n/// \\code\n///   int foo() { return 1; }\n///   int a = (foo() + 1);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ParenExpr> parenExpr;\n\n/// Matches constructor call expressions (including implicit ones).\n///\n/// Example matches string(ptr, n) and ptr within arguments of f\n///     (matcher = cxxConstructExpr())\n/// \\code\n///   void f(const string &a, const string &b);\n///   char *ptr;\n///   int n;\n///   f(string(ptr, n), ptr);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXConstructExpr>\n    cxxConstructExpr;\n\n/// Matches unresolved constructor call expressions.\n///\n/// Example matches T(t) in return statement of f\n///     (matcher = cxxUnresolvedConstructExpr())\n/// \\code\n///   template <typename T>\n///   void f(const T& t) { return T(t); }\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   CXXUnresolvedConstructExpr>\n    cxxUnresolvedConstructExpr;\n\n/// Matches implicit and explicit this expressions.\n///\n/// Example matches the implicit this expression in \"return i\".\n///     (matcher = cxxThisExpr())\n/// \\code\n/// struct foo {\n///   int i;\n///   int f() { return i; }\n/// };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXThisExpr>\n    cxxThisExpr;\n\n/// Matches nodes where temporaries are created.\n///\n/// Example matches FunctionTakesString(GetStringByValue())\n///     (matcher = cxxBindTemporaryExpr())\n/// \\code\n///   FunctionTakesString(GetStringByValue());\n///   FunctionTakesStringByPointer(GetStringPointer());\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXBindTemporaryExpr>\n    cxxBindTemporaryExpr;\n\n/// Matches nodes where temporaries are materialized.\n///\n/// Example: Given\n/// \\code\n///   struct T {void func();};\n///   T f();\n///   void g(T);\n/// \\endcode\n/// materializeTemporaryExpr() matches 'f()' in these statements\n/// \\code\n///   T u(f());\n///   g(f());\n///   f().func();\n/// \\endcode\n/// but does not match\n/// \\code\n///   f();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   MaterializeTemporaryExpr>\n    materializeTemporaryExpr;\n\n/// Matches new expressions.\n///\n/// Given\n/// \\code\n///   new X;\n/// \\endcode\n/// cxxNewExpr()\n///   matches 'new X'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXNewExpr> cxxNewExpr;\n\n/// Matches delete expressions.\n///\n/// Given\n/// \\code\n///   delete X;\n/// \\endcode\n/// cxxDeleteExpr()\n///   matches 'delete X'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXDeleteExpr>\n    cxxDeleteExpr;\n\n/// Matches noexcept expressions.\n///\n/// Given\n/// \\code\n///   bool a() noexcept;\n///   bool b() noexcept(true);\n///   bool c() noexcept(false);\n///   bool d() noexcept(noexcept(a()));\n///   bool e = noexcept(b()) || noexcept(c());\n/// \\endcode\n/// cxxNoexceptExpr()\n///   matches `noexcept(a())`, `noexcept(b())` and `noexcept(c())`.\n///   doesn't match the noexcept specifier in the declarations a, b, c or d.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXNoexceptExpr>\n    cxxNoexceptExpr;\n\n/// Matches array subscript expressions.\n///\n/// Given\n/// \\code\n///   int i = a[1];\n/// \\endcode\n/// arraySubscriptExpr()\n///   matches \"a[1]\"\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ArraySubscriptExpr>\n    arraySubscriptExpr;\n\n/// Matches the value of a default argument at the call site.\n///\n/// Example matches the CXXDefaultArgExpr placeholder inserted for the\n///     default value of the second parameter in the call expression f(42)\n///     (matcher = cxxDefaultArgExpr())\n/// \\code\n///   void f(int x, int y = 0);\n///   f(42);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXDefaultArgExpr>\n    cxxDefaultArgExpr;\n\n/// Matches overloaded operator calls.\n///\n/// Note that if an operator isn't overloaded, it won't match. Instead, use\n/// binaryOperator matcher.\n/// Currently it does not match operators such as new delete.\n/// FIXME: figure out why these do not match?\n///\n/// Example matches both operator<<((o << b), c) and operator<<(o, b)\n///     (matcher = cxxOperatorCallExpr())\n/// \\code\n///   ostream &operator<< (ostream &out, int i) { };\n///   ostream &o; int b = 1, c = 1;\n///   o << b << c;\n/// \\endcode\n/// See also the binaryOperation() matcher for more-general matching of binary\n/// uses of this AST node.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXOperatorCallExpr>\n    cxxOperatorCallExpr;\n\n/// Matches rewritten binary operators\n///\n/// Example matches use of \"<\":\n/// \\code\n///   #include <compare>\n///   struct HasSpaceshipMem {\n///     int a;\n///     constexpr auto operator<=>(const HasSpaceshipMem&) const = default;\n///   };\n///   void compare() {\n///     HasSpaceshipMem hs1, hs2;\n///     if (hs1 < hs2)\n///         return;\n///   }\n/// \\endcode\n/// See also the binaryOperation() matcher for more-general matching\n/// of this AST node.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   CXXRewrittenBinaryOperator>\n    cxxRewrittenBinaryOperator;\n\n/// Matches expressions.\n///\n/// Example matches x()\n/// \\code\n///   void f() { x(); }\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, Expr> expr;\n\n/// Matches expressions that refer to declarations.\n///\n/// Example matches x in if (x)\n/// \\code\n///   bool x;\n///   if (x) {}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, DeclRefExpr>\n    declRefExpr;\n\n/// Matches a reference to an ObjCIvar.\n///\n/// Example: matches \"a\" in \"init\" method:\n/// \\code\n/// @implementation A {\n///   NSString *a;\n/// }\n/// - (void) init {\n///   a = @\"hello\";\n/// }\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ObjCIvarRefExpr>\n    objcIvarRefExpr;\n\n/// Matches a reference to a block.\n///\n/// Example: matches \"^{}\":\n/// \\code\n///   void f() { ^{}(); }\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, BlockExpr> blockExpr;\n\n/// Matches if statements.\n///\n/// Example matches 'if (x) {}'\n/// \\code\n///   if (x) {}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, IfStmt> ifStmt;\n\n/// Matches for statements.\n///\n/// Example matches 'for (;;) {}'\n/// \\code\n///   for (;;) {}\n///   int i[] =  {1, 2, 3}; for (auto a : i);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ForStmt> forStmt;\n\n/// Matches the increment statement of a for loop.\n///\n/// Example:\n///     forStmt(hasIncrement(unaryOperator(hasOperatorName(\"++\"))))\n/// matches '++x' in\n/// \\code\n///     for (x; x < N; ++x) { }\n/// \\endcode\nAST_MATCHER_P(ForStmt, hasIncrement, internal::Matcher<Stmt>,\n              InnerMatcher) {\n  const Stmt *const Increment = Node.getInc();\n  return (Increment != nullptr &&\n          InnerMatcher.matches(*Increment, Finder, Builder));\n}\n\n/// Matches the initialization statement of a for loop.\n///\n/// Example:\n///     forStmt(hasLoopInit(declStmt()))\n/// matches 'int x = 0' in\n/// \\code\n///     for (int x = 0; x < N; ++x) { }\n/// \\endcode\nAST_MATCHER_P(ForStmt, hasLoopInit, internal::Matcher<Stmt>,\n              InnerMatcher) {\n  const Stmt *const Init = Node.getInit();\n  return (Init != nullptr && InnerMatcher.matches(*Init, Finder, Builder));\n}\n\n/// Matches range-based for statements.\n///\n/// cxxForRangeStmt() matches 'for (auto a : i)'\n/// \\code\n///   int i[] =  {1, 2, 3}; for (auto a : i);\n///   for(int j = 0; j < 5; ++j);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXForRangeStmt>\n    cxxForRangeStmt;\n\n/// Matches the initialization statement of a for loop.\n///\n/// Example:\n///     forStmt(hasLoopVariable(anything()))\n/// matches 'int x' in\n/// \\code\n///     for (int x : a) { }\n/// \\endcode\nAST_MATCHER_P(CXXForRangeStmt, hasLoopVariable, internal::Matcher<VarDecl>,\n              InnerMatcher) {\n  const VarDecl *const Var = Node.getLoopVariable();\n  return (Var != nullptr && InnerMatcher.matches(*Var, Finder, Builder));\n}\n\n/// Matches the range initialization statement of a for loop.\n///\n/// Example:\n///     forStmt(hasRangeInit(anything()))\n/// matches 'a' in\n/// \\code\n///     for (int x : a) { }\n/// \\endcode\nAST_MATCHER_P(CXXForRangeStmt, hasRangeInit, internal::Matcher<Expr>,\n              InnerMatcher) {\n  const Expr *const Init = Node.getRangeInit();\n  return (Init != nullptr && InnerMatcher.matches(*Init, Finder, Builder));\n}\n\n/// Matches while statements.\n///\n/// Given\n/// \\code\n///   while (true) {}\n/// \\endcode\n/// whileStmt()\n///   matches 'while (true) {}'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, WhileStmt> whileStmt;\n\n/// Matches do statements.\n///\n/// Given\n/// \\code\n///   do {} while (true);\n/// \\endcode\n/// doStmt()\n///   matches 'do {} while(true)'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, DoStmt> doStmt;\n\n/// Matches break statements.\n///\n/// Given\n/// \\code\n///   while (true) { break; }\n/// \\endcode\n/// breakStmt()\n///   matches 'break'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, BreakStmt> breakStmt;\n\n/// Matches continue statements.\n///\n/// Given\n/// \\code\n///   while (true) { continue; }\n/// \\endcode\n/// continueStmt()\n///   matches 'continue'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ContinueStmt>\n    continueStmt;\n\n/// Matches return statements.\n///\n/// Given\n/// \\code\n///   return 1;\n/// \\endcode\n/// returnStmt()\n///   matches 'return 1'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ReturnStmt> returnStmt;\n\n/// Matches goto statements.\n///\n/// Given\n/// \\code\n///   goto FOO;\n///   FOO: bar();\n/// \\endcode\n/// gotoStmt()\n///   matches 'goto FOO'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, GotoStmt> gotoStmt;\n\n/// Matches label statements.\n///\n/// Given\n/// \\code\n///   goto FOO;\n///   FOO: bar();\n/// \\endcode\n/// labelStmt()\n///   matches 'FOO:'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, LabelStmt> labelStmt;\n\n/// Matches address of label statements (GNU extension).\n///\n/// Given\n/// \\code\n///   FOO: bar();\n///   void *ptr = &&FOO;\n///   goto *bar;\n/// \\endcode\n/// addrLabelExpr()\n///   matches '&&FOO'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, AddrLabelExpr>\n    addrLabelExpr;\n\n/// Matches switch statements.\n///\n/// Given\n/// \\code\n///   switch(a) { case 42: break; default: break; }\n/// \\endcode\n/// switchStmt()\n///   matches 'switch(a)'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, SwitchStmt> switchStmt;\n\n/// Matches case and default statements inside switch statements.\n///\n/// Given\n/// \\code\n///   switch(a) { case 42: break; default: break; }\n/// \\endcode\n/// switchCase()\n///   matches 'case 42:' and 'default:'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, SwitchCase> switchCase;\n\n/// Matches case statements inside switch statements.\n///\n/// Given\n/// \\code\n///   switch(a) { case 42: break; default: break; }\n/// \\endcode\n/// caseStmt()\n///   matches 'case 42:'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CaseStmt> caseStmt;\n\n/// Matches default statements inside switch statements.\n///\n/// Given\n/// \\code\n///   switch(a) { case 42: break; default: break; }\n/// \\endcode\n/// defaultStmt()\n///   matches 'default:'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, DefaultStmt>\n    defaultStmt;\n\n/// Matches compound statements.\n///\n/// Example matches '{}' and '{{}}' in 'for (;;) {{}}'\n/// \\code\n///   for (;;) {{}}\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CompoundStmt>\n    compoundStmt;\n\n/// Matches catch statements.\n///\n/// \\code\n///   try {} catch(int i) {}\n/// \\endcode\n/// cxxCatchStmt()\n///   matches 'catch(int i)'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXCatchStmt>\n    cxxCatchStmt;\n\n/// Matches try statements.\n///\n/// \\code\n///   try {} catch(int i) {}\n/// \\endcode\n/// cxxTryStmt()\n///   matches 'try {}'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXTryStmt> cxxTryStmt;\n\n/// Matches throw expressions.\n///\n/// \\code\n///   try { throw 5; } catch(int i) {}\n/// \\endcode\n/// cxxThrowExpr()\n///   matches 'throw 5'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXThrowExpr>\n    cxxThrowExpr;\n\n/// Matches null statements.\n///\n/// \\code\n///   foo();;\n/// \\endcode\n/// nullStmt()\n///   matches the second ';'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, NullStmt> nullStmt;\n\n/// Matches asm statements.\n///\n/// \\code\n///  int i = 100;\n///   __asm(\"mov al, 2\");\n/// \\endcode\n/// asmStmt()\n///   matches '__asm(\"mov al, 2\")'\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, AsmStmt> asmStmt;\n\n/// Matches bool literals.\n///\n/// Example matches true\n/// \\code\n///   true\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXBoolLiteralExpr>\n    cxxBoolLiteral;\n\n/// Matches string literals (also matches wide string literals).\n///\n/// Example matches \"abcd\", L\"abcd\"\n/// \\code\n///   char *s = \"abcd\";\n///   wchar_t *ws = L\"abcd\";\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, StringLiteral>\n    stringLiteral;\n\n/// Matches character literals (also matches wchar_t).\n///\n/// Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),\n/// though.\n///\n/// Example matches 'a', L'a'\n/// \\code\n///   char ch = 'a';\n///   wchar_t chw = L'a';\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CharacterLiteral>\n    characterLiteral;\n\n/// Matches integer literals of all sizes / encodings, e.g.\n/// 1, 1L, 0x1 and 1U.\n///\n/// Does not match character-encoded integers such as L'a'.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, IntegerLiteral>\n    integerLiteral;\n\n/// Matches float literals of all sizes / encodings, e.g.\n/// 1.0, 1.0f, 1.0L and 1e10.\n///\n/// Does not match implicit conversions such as\n/// \\code\n///   float a = 10;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, FloatingLiteral>\n    floatLiteral;\n\n/// Matches imaginary literals, which are based on integer and floating\n/// point literals e.g.: 1i, 1.0i\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ImaginaryLiteral>\n    imaginaryLiteral;\n\n/// Matches fixed point literals\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, FixedPointLiteral>\n    fixedPointLiteral;\n\n/// Matches user defined literal operator call.\n///\n/// Example match: \"foo\"_suffix\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, UserDefinedLiteral>\n    userDefinedLiteral;\n\n/// Matches compound (i.e. non-scalar) literals\n///\n/// Example match: {1}, (1, 2)\n/// \\code\n///   int array[4] = {1};\n///   vector int myvec = (vector int)(1, 2);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CompoundLiteralExpr>\n    compoundLiteralExpr;\n\n/// Matches nullptr literal.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXNullPtrLiteralExpr>\n    cxxNullPtrLiteralExpr;\n\n/// Matches GNU __builtin_choose_expr.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ChooseExpr>\n    chooseExpr;\n\n/// Matches GNU __null expression.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, GNUNullExpr>\n    gnuNullExpr;\n\n/// Matches C11 _Generic expression.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, GenericSelectionExpr>\n    genericSelectionExpr;\n\n/// Matches atomic builtins.\n/// Example matches __atomic_load_n(ptr, 1)\n/// \\code\n///   void foo() { int *ptr; __atomic_load_n(ptr, 1); }\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, AtomicExpr> atomicExpr;\n\n/// Matches statement expression (GNU extension).\n///\n/// Example match: ({ int X = 4; X; })\n/// \\code\n///   int C = ({ int X = 4; X; });\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, StmtExpr> stmtExpr;\n\n/// Matches binary operator expressions.\n///\n/// Example matches a || b\n/// \\code\n///   !(a || b)\n/// \\endcode\n/// See also the binaryOperation() matcher for more-general matching.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, BinaryOperator>\n    binaryOperator;\n\n/// Matches unary operator expressions.\n///\n/// Example matches !a\n/// \\code\n///   !a || b\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, UnaryOperator>\n    unaryOperator;\n\n/// Matches conditional operator expressions.\n///\n/// Example matches a ? b : c\n/// \\code\n///   (a ? b : c) + 42\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ConditionalOperator>\n    conditionalOperator;\n\n/// Matches binary conditional operator expressions (GNU extension).\n///\n/// Example matches a ?: b\n/// \\code\n///   (a ?: b) + 42;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   BinaryConditionalOperator>\n    binaryConditionalOperator;\n\n/// Matches opaque value expressions. They are used as helpers\n/// to reference another expressions and can be met\n/// in BinaryConditionalOperators, for example.\n///\n/// Example matches 'a'\n/// \\code\n///   (a ?: c) + 42;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, OpaqueValueExpr>\n    opaqueValueExpr;\n\n/// Matches a C++ static_assert declaration.\n///\n/// Example:\n///   staticAssertExpr()\n/// matches\n///   static_assert(sizeof(S) == sizeof(int))\n/// in\n/// \\code\n///   struct S {\n///     int x;\n///   };\n///   static_assert(sizeof(S) == sizeof(int));\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Decl, StaticAssertDecl>\n    staticAssertDecl;\n\n/// Matches a reinterpret_cast expression.\n///\n/// Either the source expression or the destination type can be matched\n/// using has(), but hasDestinationType() is more specific and can be\n/// more readable.\n///\n/// Example matches reinterpret_cast<char*>(&p) in\n/// \\code\n///   void* p = reinterpret_cast<char*>(&p);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXReinterpretCastExpr>\n    cxxReinterpretCastExpr;\n\n/// Matches a C++ static_cast expression.\n///\n/// \\see hasDestinationType\n/// \\see reinterpretCast\n///\n/// Example:\n///   cxxStaticCastExpr()\n/// matches\n///   static_cast<long>(8)\n/// in\n/// \\code\n///   long eight(static_cast<long>(8));\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXStaticCastExpr>\n    cxxStaticCastExpr;\n\n/// Matches a dynamic_cast expression.\n///\n/// Example:\n///   cxxDynamicCastExpr()\n/// matches\n///   dynamic_cast<D*>(&b);\n/// in\n/// \\code\n///   struct B { virtual ~B() {} }; struct D : B {};\n///   B b;\n///   D* p = dynamic_cast<D*>(&b);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXDynamicCastExpr>\n    cxxDynamicCastExpr;\n\n/// Matches a const_cast expression.\n///\n/// Example: Matches const_cast<int*>(&r) in\n/// \\code\n///   int n = 42;\n///   const int &r(n);\n///   int* p = const_cast<int*>(&r);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXConstCastExpr>\n    cxxConstCastExpr;\n\n/// Matches a C-style cast expression.\n///\n/// Example: Matches (int) 2.2f in\n/// \\code\n///   int i = (int) 2.2f;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CStyleCastExpr>\n    cStyleCastExpr;\n\n/// Matches explicit cast expressions.\n///\n/// Matches any cast expression written in user code, whether it be a\n/// C-style cast, a functional-style cast, or a keyword cast.\n///\n/// Does not match implicit conversions.\n///\n/// Note: the name \"explicitCast\" is chosen to match Clang's terminology, as\n/// Clang uses the term \"cast\" to apply to implicit conversions as well as to\n/// actual cast expressions.\n///\n/// \\see hasDestinationType.\n///\n/// Example: matches all five of the casts in\n/// \\code\n///   int((int)(reinterpret_cast<int>(static_cast<int>(const_cast<int>(42)))))\n/// \\endcode\n/// but does not match the implicit conversion in\n/// \\code\n///   long ell = 42;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ExplicitCastExpr>\n    explicitCastExpr;\n\n/// Matches the implicit cast nodes of Clang's AST.\n///\n/// This matches many different places, including function call return value\n/// eliding, as well as any type conversions.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, ImplicitCastExpr>\n    implicitCastExpr;\n\n/// Matches any cast nodes of Clang's AST.\n///\n/// Example: castExpr() matches each of the following:\n/// \\code\n///   (int) 3;\n///   const_cast<Expr *>(SubExpr);\n///   char c = 0;\n/// \\endcode\n/// but does not match\n/// \\code\n///   int i = (0);\n///   int k = 0;\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CastExpr> castExpr;\n\n/// Matches functional cast expressions\n///\n/// Example: Matches Foo(bar);\n/// \\code\n///   Foo f = bar;\n///   Foo g = (Foo) bar;\n///   Foo h = Foo(bar);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXFunctionalCastExpr>\n    cxxFunctionalCastExpr;\n\n/// Matches functional cast expressions having N != 1 arguments\n///\n/// Example: Matches Foo(bar, bar)\n/// \\code\n///   Foo h = Foo(bar, bar);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CXXTemporaryObjectExpr>\n    cxxTemporaryObjectExpr;\n\n/// Matches predefined identifier expressions [C99 6.4.2.2].\n///\n/// Example: Matches __func__\n/// \\code\n///   printf(\"%s\", __func__);\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, PredefinedExpr>\n    predefinedExpr;\n\n/// Matches C99 designated initializer expressions [C99 6.7.8].\n///\n/// Example: Matches { [2].y = 1.0, [0].x = 1.0 }\n/// \\code\n///   point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, DesignatedInitExpr>\n    designatedInitExpr;\n\n/// Matches designated initializer expressions that contain\n/// a specific number of designators.\n///\n/// Example: Given\n/// \\code\n///   point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };\n///   point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };\n/// \\endcode\n/// designatorCountIs(2)\n///   matches '{ [2].y = 1.0, [0].x = 1.0 }',\n///   but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'.\nAST_MATCHER_P(DesignatedInitExpr, designatorCountIs, unsigned, N) {\n  return Node.size() == N;\n}\n\n/// Matches \\c QualTypes in the clang AST.\nextern const internal::VariadicAllOfMatcher<QualType> qualType;\n\n/// Matches \\c Types in the clang AST.\nextern const internal::VariadicAllOfMatcher<Type> type;\n\n/// Matches \\c TypeLocs in the clang AST.\nextern const internal::VariadicAllOfMatcher<TypeLoc> typeLoc;\n\n/// Matches if any of the given matchers matches.\n///\n/// Unlike \\c anyOf, \\c eachOf will generate a match result for each\n/// matching submatcher.\n///\n/// For example, in:\n/// \\code\n///   class A { int a; int b; };\n/// \\endcode\n/// The matcher:\n/// \\code\n///   cxxRecordDecl(eachOf(has(fieldDecl(hasName(\"a\")).bind(\"v\")),\n///                        has(fieldDecl(hasName(\"b\")).bind(\"v\"))))\n/// \\endcode\n/// will generate two results binding \"v\", the first of which binds\n/// the field declaration of \\c a, the second the field declaration of\n/// \\c b.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<\n    2, std::numeric_limits<unsigned>::max()>\n    eachOf;\n\n/// Matches if any of the given matchers matches.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<\n    2, std::numeric_limits<unsigned>::max()>\n    anyOf;\n\n/// Matches if all given matchers match.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<\n    2, std::numeric_limits<unsigned>::max()>\n    allOf;\n\n/// Matches any node regardless of the submatcher.\n///\n/// However, \\c optionally will retain any bindings generated by the submatcher.\n/// Useful when additional information which may or may not present about a main\n/// matching node is desired.\n///\n/// For example, in:\n/// \\code\n///   class Foo {\n///     int bar;\n///   }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   cxxRecordDecl(\n///     optionally(has(\n///       fieldDecl(hasName(\"bar\")).bind(\"var\")\n///   ))).bind(\"record\")\n/// \\endcode\n/// will produce a result binding for both \"record\" and \"var\".\n/// The matcher will produce a \"record\" binding for even if there is no data\n/// member named \"bar\" in that class.\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<1, 1> optionally;\n\n/// Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)\n///\n/// Given\n/// \\code\n///   Foo x = bar;\n///   int y = sizeof(x) + alignof(x);\n/// \\endcode\n/// unaryExprOrTypeTraitExpr()\n///   matches \\c sizeof(x) and \\c alignof(x)\nextern const internal::VariadicDynCastAllOfMatcher<Stmt,\n                                                   UnaryExprOrTypeTraitExpr>\n    unaryExprOrTypeTraitExpr;\n\n/// Matches any of the \\p NodeMatchers with InnerMatchers nested within\n///\n/// Given\n/// \\code\n///   if (true);\n///   for (; true; );\n/// \\endcode\n/// with the matcher\n/// \\code\n///   mapAnyOf(ifStmt, forStmt).with(\n///     hasCondition(cxxBoolLiteralExpr(equals(true)))\n///     ).bind(\"trueCond\")\n/// \\endcode\n/// matches the \\c if and the \\c for. It is equivalent to:\n/// \\code\n///   auto trueCond = hasCondition(cxxBoolLiteralExpr(equals(true)));\n///   anyOf(\n///     ifStmt(trueCond).bind(\"trueCond\"),\n///     forStmt(trueCond).bind(\"trueCond\")\n///     );\n/// \\endcode\n///\n/// The with() chain-call accepts zero or more matchers which are combined\n/// as-if with allOf() in each of the node matchers.\n/// Usable as: Any Matcher\ntemplate <typename T, typename... U>\nauto mapAnyOf(internal::VariadicDynCastAllOfMatcher<T, U> const &...) {\n  return internal::MapAnyOfHelper<U...>();\n}\n\n/// Matches nodes which can be used with binary operators.\n///\n/// The code\n/// \\code\n///   var1 != var2;\n/// \\endcode\n/// might be represented in the clang AST as a binaryOperator, a\n/// cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on\n///\n/// * whether the types of var1 and var2 are fundamental (binaryOperator) or at\n///   least one is a class type (cxxOperatorCallExpr)\n/// * whether the code appears in a template declaration, if at least one of the\n///   vars is a dependent-type (binaryOperator)\n/// * whether the code relies on a rewritten binary operator, such as a\n/// spaceship operator or an inverted equality operator\n/// (cxxRewrittenBinaryOperator)\n///\n/// This matcher elides details in places where the matchers for the nodes are\n/// compatible.\n///\n/// Given\n/// \\code\n///   binaryOperation(\n///     hasOperatorName(\"!=\"),\n///     hasLHS(expr().bind(\"lhs\")),\n///     hasRHS(expr().bind(\"rhs\"))\n///   )\n/// \\endcode\n/// matches each use of \"!=\" in:\n/// \\code\n///   struct S{\n///       bool operator!=(const S&) const;\n///   };\n///\n///   void foo()\n///   {\n///      1 != 2;\n///      S() != S();\n///   }\n///\n///   template<typename T>\n///   void templ()\n///   {\n///      1 != 2;\n///      T() != S();\n///   }\n///   struct HasOpEq\n///   {\n///       bool operator==(const HasOpEq &) const;\n///   };\n///\n///   void inverse()\n///   {\n///       HasOpEq s1;\n///       HasOpEq s2;\n///       if (s1 != s2)\n///           return;\n///   }\n///\n///   struct HasSpaceship\n///   {\n///       bool operator<=>(const HasOpEq &) const;\n///   };\n///\n///   void use_spaceship()\n///   {\n///       HasSpaceship s1;\n///       HasSpaceship s2;\n///       if (s1 != s2)\n///           return;\n///   }\n/// \\endcode\nextern const internal::MapAnyOfMatcher<BinaryOperator, CXXOperatorCallExpr,\n                                       CXXRewrittenBinaryOperator>\n    binaryOperation;\n\n/// Matches function calls and constructor calls\n///\n/// Because CallExpr and CXXConstructExpr do not share a common\n/// base class with API accessing arguments etc, AST Matchers for code\n/// which should match both are typically duplicated. This matcher\n/// removes the need for duplication.\n///\n/// Given code\n/// \\code\n/// struct ConstructorTakesInt\n/// {\n///   ConstructorTakesInt(int i) {}\n/// };\n///\n/// void callTakesInt(int i)\n/// {\n/// }\n///\n/// void doCall()\n/// {\n///   callTakesInt(42);\n/// }\n///\n/// void doConstruct()\n/// {\n///   ConstructorTakesInt cti(42);\n/// }\n/// \\endcode\n///\n/// The matcher\n/// \\code\n/// invocation(hasArgument(0, integerLiteral(equals(42))))\n/// \\endcode\n/// matches the expression in both doCall and doConstruct\nextern const internal::MapAnyOfMatcher<CallExpr, CXXConstructExpr> invocation;\n\n/// Matches unary expressions that have a specific type of argument.\n///\n/// Given\n/// \\code\n///   int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);\n/// \\endcode\n/// unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(\"int\"))\n///   matches \\c sizeof(a) and \\c alignof(c)\nAST_MATCHER_P(UnaryExprOrTypeTraitExpr, hasArgumentOfType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  const QualType ArgumentType = Node.getTypeOfArgument();\n  return InnerMatcher.matches(ArgumentType, Finder, Builder);\n}\n\n/// Matches unary expressions of a certain kind.\n///\n/// Given\n/// \\code\n///   int x;\n///   int s = sizeof(x) + alignof(x)\n/// \\endcode\n/// unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf))\n///   matches \\c sizeof(x)\n///\n/// If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter\n/// should be passed as a quoted string. e.g., ofKind(\"UETT_SizeOf\").\nAST_MATCHER_P(UnaryExprOrTypeTraitExpr, ofKind, UnaryExprOrTypeTrait, Kind) {\n  return Node.getKind() == Kind;\n}\n\n/// Same as unaryExprOrTypeTraitExpr, but only matching\n/// alignof.\ninline internal::BindableMatcher<Stmt> alignOfExpr(\n    const internal::Matcher<UnaryExprOrTypeTraitExpr> &InnerMatcher) {\n  return stmt(unaryExprOrTypeTraitExpr(\n      allOf(anyOf(ofKind(UETT_AlignOf), ofKind(UETT_PreferredAlignOf)),\n            InnerMatcher)));\n}\n\n/// Same as unaryExprOrTypeTraitExpr, but only matching\n/// sizeof.\ninline internal::BindableMatcher<Stmt> sizeOfExpr(\n    const internal::Matcher<UnaryExprOrTypeTraitExpr> &InnerMatcher) {\n  return stmt(unaryExprOrTypeTraitExpr(\n      allOf(ofKind(UETT_SizeOf), InnerMatcher)));\n}\n\n/// Matches NamedDecl nodes that have the specified name.\n///\n/// Supports specifying enclosing namespaces or classes by prefixing the name\n/// with '<enclosing>::'.\n/// Does not match typedefs of an underlying type with the given name.\n///\n/// Example matches X (Name == \"X\")\n/// \\code\n///   class X;\n/// \\endcode\n///\n/// Example matches X (Name is one of \"::a::b::X\", \"a::b::X\", \"b::X\", \"X\")\n/// \\code\n///   namespace a { namespace b { class X; } }\n/// \\endcode\ninline internal::Matcher<NamedDecl> hasName(StringRef Name) {\n  return internal::Matcher<NamedDecl>(\n      new internal::HasNameMatcher({std::string(Name)}));\n}\n\n/// Matches NamedDecl nodes that have any of the specified names.\n///\n/// This matcher is only provided as a performance optimization of hasName.\n/// \\code\n///     hasAnyName(a, b, c)\n/// \\endcode\n///  is equivalent to, but faster than\n/// \\code\n///     anyOf(hasName(a), hasName(b), hasName(c))\n/// \\endcode\nextern const internal::VariadicFunction<internal::Matcher<NamedDecl>, StringRef,\n                                        internal::hasAnyNameFunc>\n    hasAnyName;\n\n/// Matches NamedDecl nodes whose fully qualified names contain\n/// a substring matched by the given RegExp.\n///\n/// Supports specifying enclosing namespaces or classes by\n/// prefixing the name with '<enclosing>::'.  Does not match typedefs\n/// of an underlying type with the given name.\n///\n/// Example matches X (regexp == \"::X\")\n/// \\code\n///   class X;\n/// \\endcode\n///\n/// Example matches X (regexp is one of \"::X\", \"^foo::.*X\", among others)\n/// \\code\n///   namespace foo { namespace bar { class X; } }\n/// \\endcode\nAST_MATCHER_REGEX(NamedDecl, matchesName, RegExp) {\n  std::string FullNameString = \"::\" + Node.getQualifiedNameAsString();\n  return RegExp->match(FullNameString);\n}\n\n/// Matches overloaded operator names.\n///\n/// Matches overloaded operator names specified in strings without the\n/// \"operator\" prefix: e.g. \"<<\".\n///\n/// Given:\n/// \\code\n///   class A { int operator*(); };\n///   const A &operator<<(const A &a, const A &b);\n///   A a;\n///   a << a;   // <-- This matches\n/// \\endcode\n///\n/// \\c cxxOperatorCallExpr(hasOverloadedOperatorName(\"<<\"))) matches the\n/// specified line and\n/// \\c cxxRecordDecl(hasMethod(hasOverloadedOperatorName(\"*\")))\n/// matches the declaration of \\c A.\n///\n/// Usable as: Matcher<CXXOperatorCallExpr>, Matcher<FunctionDecl>\ninline internal::PolymorphicMatcher<\n    internal::HasOverloadedOperatorNameMatcher,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXOperatorCallExpr, FunctionDecl),\n    std::vector<std::string>>\nhasOverloadedOperatorName(StringRef Name) {\n  return internal::PolymorphicMatcher<\n      internal::HasOverloadedOperatorNameMatcher,\n      AST_POLYMORPHIC_SUPPORTED_TYPES(CXXOperatorCallExpr, FunctionDecl),\n      std::vector<std::string>>({std::string(Name)});\n}\n\n/// Matches overloaded operator names.\n///\n/// Matches overloaded operator names specified in strings without the\n/// \"operator\" prefix: e.g. \"<<\".\n///\n///   hasAnyOverloadedOperatorName(\"+\", \"-\")\n/// Is equivalent to\n///   anyOf(hasOverloadedOperatorName(\"+\"), hasOverloadedOperatorName(\"-\"))\nextern const internal::VariadicFunction<\n    internal::PolymorphicMatcher<internal::HasOverloadedOperatorNameMatcher,\n                                 AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                     CXXOperatorCallExpr, FunctionDecl),\n                                 std::vector<std::string>>,\n    StringRef, internal::hasAnyOverloadedOperatorNameFunc>\n    hasAnyOverloadedOperatorName;\n\n/// Matches template-dependent, but known, member names.\n///\n/// In template declarations, dependent members are not resolved and so can\n/// not be matched to particular named declarations.\n///\n/// This matcher allows to match on the known name of members.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   struct S {\n///       void mem();\n///   };\n///   template <typename T>\n///   void x() {\n///       S<T> s;\n///       s.mem();\n///   }\n/// \\endcode\n/// \\c cxxDependentScopeMemberExpr(hasMemberName(\"mem\")) matches `s.mem()`\nAST_MATCHER_P(CXXDependentScopeMemberExpr, hasMemberName, std::string, N) {\n  return Node.getMember().getAsString() == N;\n}\n\n/// Matches template-dependent, but known, member names against an already-bound\n/// node\n///\n/// In template declarations, dependent members are not resolved and so can\n/// not be matched to particular named declarations.\n///\n/// This matcher allows to match on the name of already-bound VarDecl, FieldDecl\n/// and CXXMethodDecl nodes.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   struct S {\n///       void mem();\n///   };\n///   template <typename T>\n///   void x() {\n///       S<T> s;\n///       s.mem();\n///   }\n/// \\endcode\n/// The matcher\n/// @code\n/// \\c cxxDependentScopeMemberExpr(\n///   hasObjectExpression(declRefExpr(hasType(templateSpecializationType(\n///       hasDeclaration(classTemplateDecl(has(cxxRecordDecl(has(\n///           cxxMethodDecl(hasName(\"mem\")).bind(\"templMem\")\n///           )))))\n///       )))),\n///   memberHasSameNameAsBoundNode(\"templMem\")\n///   )\n/// @endcode\n/// first matches and binds the @c mem member of the @c S template, then\n/// compares its name to the usage in @c s.mem() in the @c x function template\nAST_MATCHER_P(CXXDependentScopeMemberExpr, memberHasSameNameAsBoundNode,\n              std::string, BindingID) {\n  auto MemberName = Node.getMember().getAsString();\n\n  return Builder->removeBindings(\n      [this, MemberName](const BoundNodesMap &Nodes) {\n        const auto &BN = Nodes.getNode(this->BindingID);\n        if (const auto *ND = BN.get<NamedDecl>()) {\n          if (!isa<FieldDecl, CXXMethodDecl, VarDecl>(ND))\n            return true;\n          return ND->getName() != MemberName;\n        }\n        return true;\n      });\n}\n\n/// Matches C++ classes that are directly or indirectly derived from a class\n/// matching \\c Base, or Objective-C classes that directly or indirectly\n/// subclass a class matching \\c Base.\n///\n/// Note that a class is not considered to be derived from itself.\n///\n/// Example matches Y, Z, C (Base == hasName(\"X\"))\n/// \\code\n///   class X;\n///   class Y : public X {};  // directly derived\n///   class Z : public Y {};  // indirectly derived\n///   typedef X A;\n///   typedef A B;\n///   class C : public B {};  // derived from a typedef of X\n/// \\endcode\n///\n/// In the following example, Bar matches isDerivedFrom(hasName(\"X\")):\n/// \\code\n///   class Foo;\n///   typedef Foo X;\n///   class Bar : public Foo {};  // derived from a type that X is a typedef of\n/// \\endcode\n///\n/// In the following example, Bar matches isDerivedFrom(hasName(\"NSObject\"))\n/// \\code\n///   @interface NSObject @end\n///   @interface Bar : NSObject @end\n/// \\endcode\n///\n/// Usable as: Matcher<CXXRecordDecl>, Matcher<ObjCInterfaceDecl>\nAST_POLYMORPHIC_MATCHER_P(\n    isDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    internal::Matcher<NamedDecl>, Base) {\n  // Check if the node is a C++ struct/union/class.\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Finder->classIsDerivedFrom(RD, Base, Builder, /*Directly=*/false);\n\n  // The node must be an Objective-C class.\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Finder->objcClassIsDerivedFrom(InterfaceDecl, Base, Builder,\n                                        /*Directly=*/false);\n}\n\n/// Overloaded method as shortcut for \\c isDerivedFrom(hasName(...)).\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    std::string, BaseName, 1) {\n  if (BaseName.empty())\n    return false;\n\n  const auto M = isDerivedFrom(hasName(BaseName));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n\n/// Matches C++ classes that have a direct or indirect base matching \\p\n/// BaseSpecMatcher.\n///\n/// Example:\n/// matcher hasAnyBase(hasType(cxxRecordDecl(hasName(\"SpecialBase\"))))\n/// \\code\n///   class Foo;\n///   class Bar : Foo {};\n///   class Baz : Bar {};\n///   class SpecialBase;\n///   class Proxy : SpecialBase {};  // matches Proxy\n///   class IndirectlyDerived : Proxy {};  //matches IndirectlyDerived\n/// \\endcode\n///\n// FIXME: Refactor this and isDerivedFrom to reuse implementation.\nAST_MATCHER_P(CXXRecordDecl, hasAnyBase, internal::Matcher<CXXBaseSpecifier>,\n              BaseSpecMatcher) {\n  return internal::matchesAnyBase(Node, BaseSpecMatcher, Finder, Builder);\n}\n\n/// Matches C++ classes that have a direct base matching \\p BaseSpecMatcher.\n///\n/// Example:\n/// matcher hasDirectBase(hasType(cxxRecordDecl(hasName(\"SpecialBase\"))))\n/// \\code\n///   class Foo;\n///   class Bar : Foo {};\n///   class Baz : Bar {};\n///   class SpecialBase;\n///   class Proxy : SpecialBase {};  // matches Proxy\n///   class IndirectlyDerived : Proxy {};  // doesn't match\n/// \\endcode\nAST_MATCHER_P(CXXRecordDecl, hasDirectBase, internal::Matcher<CXXBaseSpecifier>,\n              BaseSpecMatcher) {\n  return Node.hasDefinition() &&\n         llvm::any_of(Node.bases(), [&](const CXXBaseSpecifier &Base) {\n           return BaseSpecMatcher.matches(Base, Finder, Builder);\n         });\n}\n\n/// Similar to \\c isDerivedFrom(), but also matches classes that directly\n/// match \\c Base.\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isSameOrDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    internal::Matcher<NamedDecl>, Base, 0) {\n  const auto M = anyOf(Base, isDerivedFrom(Base));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n\n/// Overloaded method as shortcut for\n/// \\c isSameOrDerivedFrom(hasName(...)).\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isSameOrDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    std::string, BaseName, 1) {\n  if (BaseName.empty())\n    return false;\n\n  const auto M = isSameOrDerivedFrom(hasName(BaseName));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n\n/// Matches C++ or Objective-C classes that are directly derived from a class\n/// matching \\c Base.\n///\n/// Note that a class is not considered to be derived from itself.\n///\n/// Example matches Y, C (Base == hasName(\"X\"))\n/// \\code\n///   class X;\n///   class Y : public X {};  // directly derived\n///   class Z : public Y {};  // indirectly derived\n///   typedef X A;\n///   typedef A B;\n///   class C : public B {};  // derived from a typedef of X\n/// \\endcode\n///\n/// In the following example, Bar matches isDerivedFrom(hasName(\"X\")):\n/// \\code\n///   class Foo;\n///   typedef Foo X;\n///   class Bar : public Foo {};  // derived from a type that X is a typedef of\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isDirectlyDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    internal::Matcher<NamedDecl>, Base, 0) {\n  // Check if the node is a C++ struct/union/class.\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Finder->classIsDerivedFrom(RD, Base, Builder, /*Directly=*/true);\n\n  // The node must be an Objective-C class.\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Finder->objcClassIsDerivedFrom(InterfaceDecl, Base, Builder,\n                                        /*Directly=*/true);\n}\n\n/// Overloaded method as shortcut for \\c isDirectlyDerivedFrom(hasName(...)).\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    isDirectlyDerivedFrom,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl, ObjCInterfaceDecl),\n    std::string, BaseName, 1) {\n  if (BaseName.empty())\n    return false;\n  const auto M = isDirectlyDerivedFrom(hasName(BaseName));\n\n  if (const auto *RD = dyn_cast<CXXRecordDecl>(&Node))\n    return Matcher<CXXRecordDecl>(M).matches(*RD, Finder, Builder);\n\n  const auto *InterfaceDecl = cast<ObjCInterfaceDecl>(&Node);\n  return Matcher<ObjCInterfaceDecl>(M).matches(*InterfaceDecl, Finder, Builder);\n}\n/// Matches the first method of a class or struct that satisfies \\c\n/// InnerMatcher.\n///\n/// Given:\n/// \\code\n///   class A { void func(); };\n///   class B { void member(); };\n/// \\endcode\n///\n/// \\c cxxRecordDecl(hasMethod(hasName(\"func\"))) matches the declaration of\n/// \\c A but not \\c B.\nAST_MATCHER_P(CXXRecordDecl, hasMethod, internal::Matcher<CXXMethodDecl>,\n              InnerMatcher) {\n  BoundNodesTreeBuilder Result(*Builder);\n  auto MatchIt = matchesFirstInPointerRange(InnerMatcher, Node.method_begin(),\n                                            Node.method_end(), Finder, &Result);\n  if (MatchIt == Node.method_end())\n    return false;\n\n  if (Finder->isTraversalIgnoringImplicitNodes() && (*MatchIt)->isImplicit())\n    return false;\n  *Builder = std::move(Result);\n  return true;\n}\n\n/// Matches the generated class of lambda expressions.\n///\n/// Given:\n/// \\code\n///   auto x = []{};\n/// \\endcode\n///\n/// \\c cxxRecordDecl(isLambda()) matches the implicit class declaration of\n/// \\c decltype(x)\nAST_MATCHER(CXXRecordDecl, isLambda) {\n  return Node.isLambda();\n}\n\n/// Matches AST nodes that have child AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, Y\n///   (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(\"X\")))\n/// \\code\n///   class X {};  // Matches X, because X::X is a class of name X inside X.\n///   class Y { class X {}; };\n///   class Z { class Y { class X {}; }; };  // Does not match Z.\n/// \\endcode\n///\n/// ChildT must be an AST base type.\n///\n/// Usable as: Any Matcher\n/// Note that has is direct matcher, so it also matches things like implicit\n/// casts and paren casts. If you are matching with expr then you should\n/// probably consider using ignoringParenImpCasts like:\n/// has(ignoringParenImpCasts(expr())).\nextern const internal::ArgumentAdaptingMatcherFunc<internal::HasMatcher> has;\n\n/// Matches AST nodes that have descendant AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, Y, Z\n///     (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName(\"X\")))))\n/// \\code\n///   class X {};  // Matches X, because X::X is a class of name X inside X.\n///   class Y { class X {}; };\n///   class Z { class Y { class X {}; }; };\n/// \\endcode\n///\n/// DescendantT must be an AST base type.\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::HasDescendantMatcher>\n    hasDescendant;\n\n/// Matches AST nodes that have child AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, Y, Y::X, Z::Y, Z::Y::X\n///   (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName(\"X\")))\n/// \\code\n///   class X {};\n///   class Y { class X {}; };  // Matches Y, because Y::X is a class of name X\n///                             // inside Y.\n///   class Z { class Y { class X {}; }; };  // Does not match Z.\n/// \\endcode\n///\n/// ChildT must be an AST base type.\n///\n/// As opposed to 'has', 'forEach' will cause a match for each result that\n/// matches instead of only on the first one.\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<internal::ForEachMatcher>\n    forEach;\n\n/// Matches AST nodes that have descendant AST nodes that match the\n/// provided matcher.\n///\n/// Example matches X, A, A::X, B, B::C, B::C::X\n///   (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName(\"X\")))))\n/// \\code\n///   class X {};\n///   class A { class X {}; };  // Matches A, because A::X is a class of name\n///                             // X inside A.\n///   class B { class C { class X {}; }; };\n/// \\endcode\n///\n/// DescendantT must be an AST base type.\n///\n/// As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for\n/// each result that matches instead of only on the first one.\n///\n/// Note: Recursively combined ForEachDescendant can cause many matches:\n///   cxxRecordDecl(forEachDescendant(cxxRecordDecl(\n///     forEachDescendant(cxxRecordDecl())\n///   )))\n/// will match 10 times (plus injected class name matches) on:\n/// \\code\n///   class A { class B { class C { class D { class E {}; }; }; }; };\n/// \\endcode\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::ForEachDescendantMatcher>\n    forEachDescendant;\n\n/// Matches if the node or any descendant matches.\n///\n/// Generates results for each match.\n///\n/// For example, in:\n/// \\code\n///   class A { class B {}; class C {}; };\n/// \\endcode\n/// The matcher:\n/// \\code\n///   cxxRecordDecl(hasName(\"::A\"),\n///                 findAll(cxxRecordDecl(isDefinition()).bind(\"m\")))\n/// \\endcode\n/// will generate results for \\c A, \\c B and \\c C.\n///\n/// Usable as: Any Matcher\ntemplate <typename T>\ninternal::Matcher<T> findAll(const internal::Matcher<T> &Matcher) {\n  return eachOf(Matcher, forEachDescendant(Matcher));\n}\n\n/// Matches AST nodes that have a parent that matches the provided\n/// matcher.\n///\n/// Given\n/// \\code\n/// void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }\n/// \\endcode\n/// \\c compoundStmt(hasParent(ifStmt())) matches \"{ int x = 43; }\".\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::HasParentMatcher,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc>,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc>>\n    hasParent;\n\n/// Matches AST nodes that have an ancestor that matches the provided\n/// matcher.\n///\n/// Given\n/// \\code\n/// void f() { if (true) { int x = 42; } }\n/// void g() { for (;;) { int x = 43; } }\n/// \\endcode\n/// \\c expr(integerLiteral(hasAncestor(ifStmt()))) matches \\c 42, but not 43.\n///\n/// Usable as: Any Matcher\nextern const internal::ArgumentAdaptingMatcherFunc<\n    internal::HasAncestorMatcher,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc>,\n    internal::TypeList<Decl, NestedNameSpecifierLoc, Stmt, TypeLoc>>\n    hasAncestor;\n\n/// Matches if the provided matcher does not match.\n///\n/// Example matches Y (matcher = cxxRecordDecl(unless(hasName(\"X\"))))\n/// \\code\n///   class X {};\n///   class Y {};\n/// \\endcode\n///\n/// Usable as: Any Matcher\nextern const internal::VariadicOperatorMatcherFunc<1, 1> unless;\n\n/// Matches a node if the declaration associated with that node\n/// matches the given matcher.\n///\n/// The associated declaration is:\n/// - for type nodes, the declaration of the underlying type\n/// - for CallExpr, the declaration of the callee\n/// - for MemberExpr, the declaration of the referenced member\n/// - for CXXConstructExpr, the declaration of the constructor\n/// - for CXXNewExpr, the declaration of the operator new\n/// - for ObjCIvarExpr, the declaration of the ivar\n///\n/// For type nodes, hasDeclaration will generally match the declaration of the\n/// sugared type. Given\n/// \\code\n///   class X {};\n///   typedef X Y;\n///   Y y;\n/// \\endcode\n/// in varDecl(hasType(hasDeclaration(decl()))) the decl will match the\n/// typedefDecl. A common use case is to match the underlying, desugared type.\n/// This can be achieved by using the hasUnqualifiedDesugaredType matcher:\n/// \\code\n///   varDecl(hasType(hasUnqualifiedDesugaredType(\n///       recordType(hasDeclaration(decl())))))\n/// \\endcode\n/// In this matcher, the decl will match the CXXRecordDecl of class X.\n///\n/// Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,\n///   Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,\n///   Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,\n///   Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,\n///   Matcher<TagType>, Matcher<TemplateSpecializationType>,\n///   Matcher<TemplateTypeParmType>, Matcher<TypedefType>,\n///   Matcher<UnresolvedUsingType>\ninline internal::PolymorphicMatcher<\n    internal::HasDeclarationMatcher,\n    void(internal::HasDeclarationSupportedTypes), internal::Matcher<Decl>>\nhasDeclaration(const internal::Matcher<Decl> &InnerMatcher) {\n  return internal::PolymorphicMatcher<\n      internal::HasDeclarationMatcher,\n      void(internal::HasDeclarationSupportedTypes), internal::Matcher<Decl>>(\n      InnerMatcher);\n}\n\n/// Matches a \\c NamedDecl whose underlying declaration matches the given\n/// matcher.\n///\n/// Given\n/// \\code\n///   namespace N { template<class T> void f(T t); }\n///   template <class T> void g() { using N::f; f(T()); }\n/// \\endcode\n/// \\c unresolvedLookupExpr(hasAnyDeclaration(\n///     namedDecl(hasUnderlyingDecl(hasName(\"::N::f\")))))\n///   matches the use of \\c f in \\c g() .\nAST_MATCHER_P(NamedDecl, hasUnderlyingDecl, internal::Matcher<NamedDecl>,\n              InnerMatcher) {\n  const NamedDecl *UnderlyingDecl = Node.getUnderlyingDecl();\n\n  return UnderlyingDecl != nullptr &&\n         InnerMatcher.matches(*UnderlyingDecl, Finder, Builder);\n}\n\n/// Matches on the implicit object argument of a member call expression, after\n/// stripping off any parentheses or implicit casts.\n///\n/// Given\n/// \\code\n///   class Y { public: void m(); };\n///   Y g();\n///   class X : public Y {};\n///   void z(Y y, X x) { y.m(); (g()).m(); x.m(); }\n/// \\endcode\n/// cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName(\"Y\")))))\n///   matches `y.m()` and `(g()).m()`.\n/// cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName(\"X\")))))\n///   matches `x.m()`.\n/// cxxMemberCallExpr(on(callExpr()))\n///   matches `(g()).m()`.\n///\n/// FIXME: Overload to allow directly matching types?\nAST_MATCHER_P(CXXMemberCallExpr, on, internal::Matcher<Expr>,\n              InnerMatcher) {\n  const Expr *ExprNode = Node.getImplicitObjectArgument()\n                            ->IgnoreParenImpCasts();\n  return (ExprNode != nullptr &&\n          InnerMatcher.matches(*ExprNode, Finder, Builder));\n}\n\n\n/// Matches on the receiver of an ObjectiveC Message expression.\n///\n/// Example\n/// matcher = objCMessageExpr(hasReceiverType(asString(\"UIWebView *\")));\n/// matches the [webView ...] message invocation.\n/// \\code\n///   NSString *webViewJavaScript = ...\n///   UIWebView *webView = ...\n///   [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];\n/// \\endcode\nAST_MATCHER_P(ObjCMessageExpr, hasReceiverType, internal::Matcher<QualType>,\n              InnerMatcher) {\n  const QualType TypeDecl = Node.getReceiverType();\n  return InnerMatcher.matches(TypeDecl, Finder, Builder);\n}\n\n/// Returns true when the Objective-C method declaration is a class method.\n///\n/// Example\n/// matcher = objcMethodDecl(isClassMethod())\n/// matches\n/// \\code\n/// @interface I + (void)foo; @end\n/// \\endcode\n/// but not\n/// \\code\n/// @interface I - (void)bar; @end\n/// \\endcode\nAST_MATCHER(ObjCMethodDecl, isClassMethod) {\n  return Node.isClassMethod();\n}\n\n/// Returns true when the Objective-C method declaration is an instance method.\n///\n/// Example\n/// matcher = objcMethodDecl(isInstanceMethod())\n/// matches\n/// \\code\n/// @interface I - (void)bar; @end\n/// \\endcode\n/// but not\n/// \\code\n/// @interface I + (void)foo; @end\n/// \\endcode\nAST_MATCHER(ObjCMethodDecl, isInstanceMethod) {\n  return Node.isInstanceMethod();\n}\n\n/// Returns true when the Objective-C message is sent to a class.\n///\n/// Example\n/// matcher = objcMessageExpr(isClassMessage())\n/// matches\n/// \\code\n///   [NSString stringWithFormat:@\"format\"];\n/// \\endcode\n/// but not\n/// \\code\n///   NSString *x = @\"hello\";\n///   [x containsString:@\"h\"];\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, isClassMessage) {\n  return Node.isClassMessage();\n}\n\n/// Returns true when the Objective-C message is sent to an instance.\n///\n/// Example\n/// matcher = objcMessageExpr(isInstanceMessage())\n/// matches\n/// \\code\n///   NSString *x = @\"hello\";\n///   [x containsString:@\"h\"];\n/// \\endcode\n/// but not\n/// \\code\n///   [NSString stringWithFormat:@\"format\"];\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, isInstanceMessage) {\n  return Node.isInstanceMessage();\n}\n\n/// Matches if the Objective-C message is sent to an instance,\n/// and the inner matcher matches on that instance.\n///\n/// For example the method call in\n/// \\code\n///   NSString *x = @\"hello\";\n///   [x containsString:@\"h\"];\n/// \\endcode\n/// is matched by\n/// objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(\"x\"))))))\nAST_MATCHER_P(ObjCMessageExpr, hasReceiver, internal::Matcher<Expr>,\n              InnerMatcher) {\n  const Expr *ReceiverNode = Node.getInstanceReceiver();\n  return (ReceiverNode != nullptr &&\n          InnerMatcher.matches(*ReceiverNode->IgnoreParenImpCasts(), Finder,\n                               Builder));\n}\n\n/// Matches when BaseName == Selector.getAsString()\n///\n///  matcher = objCMessageExpr(hasSelector(\"loadHTMLString:baseURL:\"));\n///  matches the outer message expr in the code below, but NOT the message\n///  invocation for self.bodyView.\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER_P(ObjCMessageExpr, hasSelector, std::string, BaseName) {\n  Selector Sel = Node.getSelector();\n  return BaseName.compare(Sel.getAsString()) == 0;\n}\n\n\n/// Matches when at least one of the supplied string equals to the\n/// Selector.getAsString()\n///\n///  matcher = objCMessageExpr(hasSelector(\"methodA:\", \"methodB:\"));\n///  matches both of the expressions below:\n/// \\code\n///     [myObj methodA:argA];\n///     [myObj methodB:argB];\n/// \\endcode\nextern const internal::VariadicFunction<internal::Matcher<ObjCMessageExpr>,\n                                        StringRef,\n                                        internal::hasAnySelectorFunc>\n                                        hasAnySelector;\n\n/// Matches ObjC selectors whose name contains\n/// a substring matched by the given RegExp.\n///  matcher = objCMessageExpr(matchesSelector(\"loadHTMLString\\:baseURL?\"));\n///  matches the outer message expr in the code below, but NOT the message\n///  invocation for self.bodyView.\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER_REGEX(ObjCMessageExpr, matchesSelector, RegExp) {\n  std::string SelectorString = Node.getSelector().getAsString();\n  return RegExp->match(SelectorString);\n}\n\n/// Matches when the selector is the empty selector\n///\n/// Matches only when the selector of the objCMessageExpr is NULL. This may\n/// represent an error condition in the tree!\nAST_MATCHER(ObjCMessageExpr, hasNullSelector) {\n  return Node.getSelector().isNull();\n}\n\n/// Matches when the selector is a Unary Selector\n///\n///  matcher = objCMessageExpr(matchesSelector(hasUnarySelector());\n///  matches self.bodyView in the code below, but NOT the outer message\n///  invocation of \"loadHTMLString:baseURL:\".\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, hasUnarySelector) {\n  return Node.getSelector().isUnarySelector();\n}\n\n/// Matches when the selector is a keyword selector\n///\n/// objCMessageExpr(hasKeywordSelector()) matches the generated setFrame\n/// message expression in\n///\n/// \\code\n///   UIWebView *webView = ...;\n///   CGRect bodyFrame = webView.frame;\n///   bodyFrame.size.height = self.bodyContentHeight;\n///   webView.frame = bodyFrame;\n///   //     ^---- matches here\n/// \\endcode\nAST_MATCHER(ObjCMessageExpr, hasKeywordSelector) {\n  return Node.getSelector().isKeywordSelector();\n}\n\n/// Matches when the selector has the specified number of arguments\n///\n///  matcher = objCMessageExpr(numSelectorArgs(0));\n///  matches self.bodyView in the code below\n///\n///  matcher = objCMessageExpr(numSelectorArgs(2));\n///  matches the invocation of \"loadHTMLString:baseURL:\" but not that\n///  of self.bodyView\n/// \\code\n///     [self.bodyView loadHTMLString:html baseURL:NULL];\n/// \\endcode\nAST_MATCHER_P(ObjCMessageExpr, numSelectorArgs, unsigned, N) {\n  return Node.getSelector().getNumArgs() == N;\n}\n\n/// Matches if the call expression's callee expression matches.\n///\n/// Given\n/// \\code\n///   class Y { void x() { this->x(); x(); Y y; y.x(); } };\n///   void f() { f(); }\n/// \\endcode\n/// callExpr(callee(expr()))\n///   matches this->x(), x(), y.x(), f()\n/// with callee(...)\n///   matching this->x, x, y.x, f respectively\n///\n/// Note: Callee cannot take the more general internal::Matcher<Expr>\n/// because this introduces ambiguous overloads with calls to Callee taking a\n/// internal::Matcher<Decl>, as the matcher hierarchy is purely\n/// implemented in terms of implicit casts.\nAST_MATCHER_P(CallExpr, callee, internal::Matcher<Stmt>,\n              InnerMatcher) {\n  const Expr *ExprNode = Node.getCallee();\n  return (ExprNode != nullptr &&\n          InnerMatcher.matches(*ExprNode, Finder, Builder));\n}\n\n/// Matches if the call expression's callee's declaration matches the\n/// given matcher.\n///\n/// Example matches y.x() (matcher = callExpr(callee(\n///                                    cxxMethodDecl(hasName(\"x\")))))\n/// \\code\n///   class Y { public: void x(); };\n///   void z() { Y y; y.x(); }\n/// \\endcode\nAST_MATCHER_P_OVERLOAD(CallExpr, callee, internal::Matcher<Decl>, InnerMatcher,\n                       1) {\n  return callExpr(hasDeclaration(InnerMatcher)).matches(Node, Finder, Builder);\n}\n\n/// Matches if the expression's or declaration's type matches a type\n/// matcher.\n///\n/// Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and U (matcher = typedefDecl(hasType(asString(\"int\")))\n///             and friend class X (matcher = friendDecl(hasType(\"X\"))\n/// \\code\n///  class X {};\n///  void y(X &x) { x; X z; }\n///  typedef int U;\n///  class Y { friend class X; };\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    hasType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(Expr, FriendDecl, TypedefNameDecl,\n                                    ValueDecl),\n    internal::Matcher<QualType>, InnerMatcher, 0) {\n  QualType QT = internal::getUnderlyingType(Node);\n  if (!QT.isNull())\n    return InnerMatcher.matches(QT, Finder, Builder);\n  return false;\n}\n\n/// Overloaded to match the declaration of the expression's or value\n/// declaration's type.\n///\n/// In case of a value declaration (for example a variable declaration),\n/// this resolves one layer of indirection. For example, in the value\n/// declaration \"X x;\", cxxRecordDecl(hasName(\"X\")) matches the declaration of\n/// X, while varDecl(hasType(cxxRecordDecl(hasName(\"X\")))) matches the\n/// declaration of x.\n///\n/// Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and z (matcher = varDecl(hasType(cxxRecordDecl(hasName(\"X\")))))\n///             and friend class X (matcher = friendDecl(hasType(\"X\"))\n/// \\code\n///  class X {};\n///  void y(X &x) { x; X z; }\n///  class Y { friend class X; };\n/// \\endcode\n///\n/// Example matches class Derived\n/// (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName(\"Base\"))))))\n/// \\code\n/// class Base {};\n/// class Derived : Base {};\n/// \\endcode\n///\n/// Usable as: Matcher<Expr>, Matcher<FriendDecl>, Matcher<ValueDecl>,\n/// Matcher<CXXBaseSpecifier>\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(\n    hasType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(Expr, FriendDecl, ValueDecl,\n                                    CXXBaseSpecifier),\n    internal::Matcher<Decl>, InnerMatcher, 1) {\n  QualType QT = internal::getUnderlyingType(Node);\n  if (!QT.isNull())\n    return qualType(hasDeclaration(InnerMatcher)).matches(QT, Finder, Builder);\n  return false;\n}\n\n/// Matches if the type location of the declarator decl's type matches\n/// the inner matcher.\n///\n/// Given\n/// \\code\n///   int x;\n/// \\endcode\n/// declaratorDecl(hasTypeLoc(loc(asString(\"int\"))))\n///   matches int x\nAST_MATCHER_P(DeclaratorDecl, hasTypeLoc, internal::Matcher<TypeLoc>, Inner) {\n  if (!Node.getTypeSourceInfo())\n    // This happens for example for implicit destructors.\n    return false;\n  return Inner.matches(Node.getTypeSourceInfo()->getTypeLoc(), Finder, Builder);\n}\n\n/// Matches if the matched type is represented by the given string.\n///\n/// Given\n/// \\code\n///   class Y { public: void x(); };\n///   void z() { Y* y; y->x(); }\n/// \\endcode\n/// cxxMemberCallExpr(on(hasType(asString(\"class Y *\"))))\n///   matches y->x()\nAST_MATCHER_P(QualType, asString, std::string, Name) {\n  return Name == Node.getAsString();\n}\n\n/// Matches if the matched type is a pointer type and the pointee type\n/// matches the specified matcher.\n///\n/// Example matches y->x()\n///   (matcher = cxxMemberCallExpr(on(hasType(pointsTo\n///      cxxRecordDecl(hasName(\"Y\")))))))\n/// \\code\n///   class Y { public: void x(); };\n///   void z() { Y *y; y->x(); }\n/// \\endcode\nAST_MATCHER_P(\n    QualType, pointsTo, internal::Matcher<QualType>,\n    InnerMatcher) {\n  return (!Node.isNull() && Node->isAnyPointerType() &&\n          InnerMatcher.matches(Node->getPointeeType(), Finder, Builder));\n}\n\n/// Overloaded to match the pointee type's declaration.\nAST_MATCHER_P_OVERLOAD(QualType, pointsTo, internal::Matcher<Decl>,\n                       InnerMatcher, 1) {\n  return pointsTo(qualType(hasDeclaration(InnerMatcher)))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches if the matched type matches the unqualified desugared\n/// type of the matched node.\n///\n/// For example, in:\n/// \\code\n///   class A {};\n///   using B = A;\n/// \\endcode\n/// The matcher type(hasUnqualifiedDesugaredType(recordType())) matches\n/// both B and A.\nAST_MATCHER_P(Type, hasUnqualifiedDesugaredType, internal::Matcher<Type>,\n              InnerMatcher) {\n  return InnerMatcher.matches(*Node.getUnqualifiedDesugaredType(), Finder,\n                              Builder);\n}\n\n/// Matches if the matched type is a reference type and the referenced\n/// type matches the specified matcher.\n///\n/// Example matches X &x and const X &y\n///     (matcher = varDecl(hasType(references(cxxRecordDecl(hasName(\"X\"))))))\n/// \\code\n///   class X {\n///     void a(X b) {\n///       X &x = b;\n///       const X &y = b;\n///     }\n///   };\n/// \\endcode\nAST_MATCHER_P(QualType, references, internal::Matcher<QualType>,\n              InnerMatcher) {\n  return (!Node.isNull() && Node->isReferenceType() &&\n          InnerMatcher.matches(Node->getPointeeType(), Finder, Builder));\n}\n\n/// Matches QualTypes whose canonical type matches InnerMatcher.\n///\n/// Given:\n/// \\code\n///   typedef int &int_ref;\n///   int a;\n///   int_ref b = a;\n/// \\endcode\n///\n/// \\c varDecl(hasType(qualType(referenceType()))))) will not match the\n/// declaration of b but \\c\n/// varDecl(hasType(qualType(hasCanonicalType(referenceType())))))) does.\nAST_MATCHER_P(QualType, hasCanonicalType, internal::Matcher<QualType>,\n              InnerMatcher) {\n  if (Node.isNull())\n    return false;\n  return InnerMatcher.matches(Node.getCanonicalType(), Finder, Builder);\n}\n\n/// Overloaded to match the referenced type's declaration.\nAST_MATCHER_P_OVERLOAD(QualType, references, internal::Matcher<Decl>,\n                       InnerMatcher, 1) {\n  return references(qualType(hasDeclaration(InnerMatcher)))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches on the implicit object argument of a member call expression. Unlike\n/// `on`, matches the argument directly without stripping away anything.\n///\n/// Given\n/// \\code\n///   class Y { public: void m(); };\n///   Y g();\n///   class X : public Y { void g(); };\n///   void z(Y y, X x) { y.m(); x.m(); x.g(); (g()).m(); }\n/// \\endcode\n/// cxxMemberCallExpr(onImplicitObjectArgument(hasType(\n///     cxxRecordDecl(hasName(\"Y\")))))\n///   matches `y.m()`, `x.m()` and (g()).m(), but not `x.g()`.\n/// cxxMemberCallExpr(on(callExpr()))\n///   does not match `(g()).m()`, because the parens are not ignored.\n///\n/// FIXME: Overload to allow directly matching types?\nAST_MATCHER_P(CXXMemberCallExpr, onImplicitObjectArgument,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *ExprNode = Node.getImplicitObjectArgument();\n  return (ExprNode != nullptr &&\n          InnerMatcher.matches(*ExprNode, Finder, Builder));\n}\n\n/// Matches if the type of the expression's implicit object argument either\n/// matches the InnerMatcher, or is a pointer to a type that matches the\n/// InnerMatcher.\n///\n/// Given\n/// \\code\n///   class Y { public: void m(); };\n///   class X : public Y { void g(); };\n///   void z() { Y y; y.m(); Y *p; p->m(); X x; x.m(); x.g(); }\n/// \\endcode\n/// cxxMemberCallExpr(thisPointerType(hasDeclaration(\n///     cxxRecordDecl(hasName(\"Y\")))))\n///   matches `y.m()`, `p->m()` and `x.m()`.\n/// cxxMemberCallExpr(thisPointerType(hasDeclaration(\n///     cxxRecordDecl(hasName(\"X\")))))\n///   matches `x.g()`.\nAST_MATCHER_P_OVERLOAD(CXXMemberCallExpr, thisPointerType,\n                       internal::Matcher<QualType>, InnerMatcher, 0) {\n  return onImplicitObjectArgument(\n      anyOf(hasType(InnerMatcher), hasType(pointsTo(InnerMatcher))))\n      .matches(Node, Finder, Builder);\n}\n\n/// Overloaded to match the type's declaration.\nAST_MATCHER_P_OVERLOAD(CXXMemberCallExpr, thisPointerType,\n                       internal::Matcher<Decl>, InnerMatcher, 1) {\n  return onImplicitObjectArgument(\n      anyOf(hasType(InnerMatcher), hasType(pointsTo(InnerMatcher))))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches a DeclRefExpr that refers to a declaration that matches the\n/// specified matcher.\n///\n/// Example matches x in if(x)\n///     (matcher = declRefExpr(to(varDecl(hasName(\"x\")))))\n/// \\code\n///   bool x;\n///   if (x) {}\n/// \\endcode\nAST_MATCHER_P(DeclRefExpr, to, internal::Matcher<Decl>,\n              InnerMatcher) {\n  const Decl *DeclNode = Node.getDecl();\n  return (DeclNode != nullptr &&\n          InnerMatcher.matches(*DeclNode, Finder, Builder));\n}\n\n/// Matches a \\c DeclRefExpr that refers to a declaration through a\n/// specific using shadow declaration.\n///\n/// Given\n/// \\code\n///   namespace a { void f() {} }\n///   using a::f;\n///   void g() {\n///     f();     // Matches this ..\n///     a::f();  // .. but not this.\n///   }\n/// \\endcode\n/// declRefExpr(throughUsingDecl(anything()))\n///   matches \\c f()\nAST_MATCHER_P(DeclRefExpr, throughUsingDecl,\n              internal::Matcher<UsingShadowDecl>, InnerMatcher) {\n  const NamedDecl *FoundDecl = Node.getFoundDecl();\n  if (const UsingShadowDecl *UsingDecl = dyn_cast<UsingShadowDecl>(FoundDecl))\n    return InnerMatcher.matches(*UsingDecl, Finder, Builder);\n  return false;\n}\n\n/// Matches an \\c OverloadExpr if any of the declarations in the set of\n/// overloads matches the given matcher.\n///\n/// Given\n/// \\code\n///   template <typename T> void foo(T);\n///   template <typename T> void bar(T);\n///   template <typename T> void baz(T t) {\n///     foo(t);\n///     bar(t);\n///   }\n/// \\endcode\n/// unresolvedLookupExpr(hasAnyDeclaration(\n///     functionTemplateDecl(hasName(\"foo\"))))\n///   matches \\c foo in \\c foo(t); but not \\c bar in \\c bar(t);\nAST_MATCHER_P(OverloadExpr, hasAnyDeclaration, internal::Matcher<Decl>,\n              InnerMatcher) {\n  return matchesFirstInPointerRange(InnerMatcher, Node.decls_begin(),\n                                    Node.decls_end(), Finder,\n                                    Builder) != Node.decls_end();\n}\n\n/// Matches the Decl of a DeclStmt which has a single declaration.\n///\n/// Given\n/// \\code\n///   int a, b;\n///   int c;\n/// \\endcode\n/// declStmt(hasSingleDecl(anything()))\n///   matches 'int c;' but not 'int a, b;'.\nAST_MATCHER_P(DeclStmt, hasSingleDecl, internal::Matcher<Decl>, InnerMatcher) {\n  if (Node.isSingleDecl()) {\n    const Decl *FoundDecl = Node.getSingleDecl();\n    return InnerMatcher.matches(*FoundDecl, Finder, Builder);\n  }\n  return false;\n}\n\n/// Matches a variable declaration that has an initializer expression\n/// that matches the given matcher.\n///\n/// Example matches x (matcher = varDecl(hasInitializer(callExpr())))\n/// \\code\n///   bool y() { return true; }\n///   bool x = y();\n/// \\endcode\nAST_MATCHER_P(\n    VarDecl, hasInitializer, internal::Matcher<Expr>,\n    InnerMatcher) {\n  const Expr *Initializer = Node.getAnyInitializer();\n  return (Initializer != nullptr &&\n          InnerMatcher.matches(*Initializer, Finder, Builder));\n}\n\n/// \\brief Matches a static variable with local scope.\n///\n/// Example matches y (matcher = varDecl(isStaticLocal()))\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// static int z;\n/// \\endcode\nAST_MATCHER(VarDecl, isStaticLocal) {\n  return Node.isStaticLocal();\n}\n\n/// Matches a variable declaration that has function scope and is a\n/// non-static local variable.\n///\n/// Example matches x (matcher = varDecl(hasLocalStorage())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\nAST_MATCHER(VarDecl, hasLocalStorage) {\n  return Node.hasLocalStorage();\n}\n\n/// Matches a variable declaration that does not have local storage.\n///\n/// Example matches y and z (matcher = varDecl(hasGlobalStorage())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\nAST_MATCHER(VarDecl, hasGlobalStorage) {\n  return Node.hasGlobalStorage();\n}\n\n/// Matches a variable declaration that has automatic storage duration.\n///\n/// Example matches x, but not y, z, or a.\n/// (matcher = varDecl(hasAutomaticStorageDuration())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n///   thread_local int z;\n/// }\n/// int a;\n/// \\endcode\nAST_MATCHER(VarDecl, hasAutomaticStorageDuration) {\n  return Node.getStorageDuration() == SD_Automatic;\n}\n\n/// Matches a variable declaration that has static storage duration.\n/// It includes the variable declared at namespace scope and those declared\n/// with \"static\" and \"extern\" storage class specifiers.\n///\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n///   thread_local int z;\n/// }\n/// int a;\n/// static int b;\n/// extern int c;\n/// varDecl(hasStaticStorageDuration())\n///   matches the function declaration y, a, b and c.\n/// \\endcode\nAST_MATCHER(VarDecl, hasStaticStorageDuration) {\n  return Node.getStorageDuration() == SD_Static;\n}\n\n/// Matches a variable declaration that has thread storage duration.\n///\n/// Example matches z, but not x, z, or a.\n/// (matcher = varDecl(hasThreadStorageDuration())\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n///   thread_local int z;\n/// }\n/// int a;\n/// \\endcode\nAST_MATCHER(VarDecl, hasThreadStorageDuration) {\n  return Node.getStorageDuration() == SD_Thread;\n}\n\n/// Matches a variable declaration that is an exception variable from\n/// a C++ catch block, or an Objective-C \\@catch statement.\n///\n/// Example matches x (matcher = varDecl(isExceptionVariable())\n/// \\code\n/// void f(int y) {\n///   try {\n///   } catch (int x) {\n///   }\n/// }\n/// \\endcode\nAST_MATCHER(VarDecl, isExceptionVariable) {\n  return Node.isExceptionVariable();\n}\n\n/// Checks that a call expression or a constructor call expression has\n/// a specific number of arguments (including absent default arguments).\n///\n/// Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2)))\n/// \\code\n///   void f(int x, int y);\n///   f(0, 0);\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(argumentCountIs,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              CallExpr, CXXConstructExpr,\n                              CXXUnresolvedConstructExpr, ObjCMessageExpr),\n                          unsigned, N) {\n  unsigned NumArgs = Node.getNumArgs();\n  if (!Finder->isTraversalIgnoringImplicitNodes())\n    return NumArgs == N;\n  while (NumArgs) {\n    if (!isa<CXXDefaultArgExpr>(Node.getArg(NumArgs - 1)))\n      break;\n    --NumArgs;\n  }\n  return NumArgs == N;\n}\n\n/// Matches the n'th argument of a call expression or a constructor\n/// call expression.\n///\n/// Example matches y in x(y)\n///     (matcher = callExpr(hasArgument(0, declRefExpr())))\n/// \\code\n///   void x(int) { int y; x(y); }\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P2(hasArgument,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(\n                               CallExpr, CXXConstructExpr,\n                               CXXUnresolvedConstructExpr, ObjCMessageExpr),\n                           unsigned, N, internal::Matcher<Expr>, InnerMatcher) {\n  if (N >= Node.getNumArgs())\n    return false;\n  const Expr *Arg = Node.getArg(N);\n  if (Finder->isTraversalIgnoringImplicitNodes() && isa<CXXDefaultArgExpr>(Arg))\n    return false;\n  return InnerMatcher.matches(*Arg->IgnoreParenImpCasts(), Finder, Builder);\n}\n\n/// Matches the n'th item of an initializer list expression.\n///\n/// Example matches y.\n///     (matcher = initListExpr(hasInit(0, expr())))\n/// \\code\n///   int x{y}.\n/// \\endcode\nAST_MATCHER_P2(InitListExpr, hasInit, unsigned, N,\n               ast_matchers::internal::Matcher<Expr>, InnerMatcher) {\n  return N < Node.getNumInits() &&\n          InnerMatcher.matches(*Node.getInit(N), Finder, Builder);\n}\n\n/// Matches declaration statements that contain a specific number of\n/// declarations.\n///\n/// Example: Given\n/// \\code\n///   int a, b;\n///   int c;\n///   int d = 2, e;\n/// \\endcode\n/// declCountIs(2)\n///   matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'.\nAST_MATCHER_P(DeclStmt, declCountIs, unsigned, N) {\n  return std::distance(Node.decl_begin(), Node.decl_end()) == (ptrdiff_t)N;\n}\n\n/// Matches the n'th declaration of a declaration statement.\n///\n/// Note that this does not work for global declarations because the AST\n/// breaks up multiple-declaration DeclStmt's into multiple single-declaration\n/// DeclStmt's.\n/// Example: Given non-global declarations\n/// \\code\n///   int a, b = 0;\n///   int c;\n///   int d = 2, e;\n/// \\endcode\n/// declStmt(containsDeclaration(\n///       0, varDecl(hasInitializer(anything()))))\n///   matches only 'int d = 2, e;', and\n/// declStmt(containsDeclaration(1, varDecl()))\n/// \\code\n///   matches 'int a, b = 0' as well as 'int d = 2, e;'\n///   but 'int c;' is not matched.\n/// \\endcode\nAST_MATCHER_P2(DeclStmt, containsDeclaration, unsigned, N,\n               internal::Matcher<Decl>, InnerMatcher) {\n  const unsigned NumDecls = std::distance(Node.decl_begin(), Node.decl_end());\n  if (N >= NumDecls)\n    return false;\n  DeclStmt::const_decl_iterator Iterator = Node.decl_begin();\n  std::advance(Iterator, N);\n  return InnerMatcher.matches(**Iterator, Finder, Builder);\n}\n\n/// Matches a C++ catch statement that has a catch-all handler.\n///\n/// Given\n/// \\code\n///   try {\n///     // ...\n///   } catch (int) {\n///     // ...\n///   } catch (...) {\n///     // ...\n///   }\n/// \\endcode\n/// cxxCatchStmt(isCatchAll()) matches catch(...) but not catch(int).\nAST_MATCHER(CXXCatchStmt, isCatchAll) {\n  return Node.getExceptionDecl() == nullptr;\n}\n\n/// Matches a constructor initializer.\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() : foo_(1) { }\n///     int foo_;\n///   };\n/// \\endcode\n/// cxxRecordDecl(has(cxxConstructorDecl(\n///   hasAnyConstructorInitializer(anything())\n/// )))\n///   record matches Foo, hasAnyConstructorInitializer matches foo_(1)\nAST_MATCHER_P(CXXConstructorDecl, hasAnyConstructorInitializer,\n              internal::Matcher<CXXCtorInitializer>, InnerMatcher) {\n  auto MatchIt = matchesFirstInPointerRange(InnerMatcher, Node.init_begin(),\n                                            Node.init_end(), Finder, Builder);\n  if (MatchIt == Node.init_end())\n    return false;\n  return (*MatchIt)->isWritten() || !Finder->isTraversalIgnoringImplicitNodes();\n}\n\n/// Matches the field declaration of a constructor initializer.\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() : foo_(1) { }\n///     int foo_;\n///   };\n/// \\endcode\n/// cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(\n///     forField(hasName(\"foo_\"))))))\n///   matches Foo\n/// with forField matching foo_\nAST_MATCHER_P(CXXCtorInitializer, forField,\n              internal::Matcher<FieldDecl>, InnerMatcher) {\n  const FieldDecl *NodeAsDecl = Node.getAnyMember();\n  return (NodeAsDecl != nullptr &&\n      InnerMatcher.matches(*NodeAsDecl, Finder, Builder));\n}\n\n/// Matches the initializer expression of a constructor initializer.\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() : foo_(1) { }\n///     int foo_;\n///   };\n/// \\endcode\n/// cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer(\n///     withInitializer(integerLiteral(equals(1)))))))\n///   matches Foo\n/// with withInitializer matching (1)\nAST_MATCHER_P(CXXCtorInitializer, withInitializer,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr* NodeAsExpr = Node.getInit();\n  return (NodeAsExpr != nullptr &&\n      InnerMatcher.matches(*NodeAsExpr, Finder, Builder));\n}\n\n/// Matches a constructor initializer if it is explicitly written in\n/// code (as opposed to implicitly added by the compiler).\n///\n/// Given\n/// \\code\n///   struct Foo {\n///     Foo() { }\n///     Foo(int) : foo_(\"A\") { }\n///     string foo_;\n///   };\n/// \\endcode\n/// cxxConstructorDecl(hasAnyConstructorInitializer(isWritten()))\n///   will match Foo(int), but not Foo()\nAST_MATCHER(CXXCtorInitializer, isWritten) {\n  return Node.isWritten();\n}\n\n/// Matches a constructor initializer if it is initializing a base, as\n/// opposed to a member.\n///\n/// Given\n/// \\code\n///   struct B {};\n///   struct D : B {\n///     int I;\n///     D(int i) : I(i) {}\n///   };\n///   struct E : B {\n///     E() : B() {}\n///   };\n/// \\endcode\n/// cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer()))\n///   will match E(), but not match D(int).\nAST_MATCHER(CXXCtorInitializer, isBaseInitializer) {\n  return Node.isBaseInitializer();\n}\n\n/// Matches a constructor initializer if it is initializing a member, as\n/// opposed to a base.\n///\n/// Given\n/// \\code\n///   struct B {};\n///   struct D : B {\n///     int I;\n///     D(int i) : I(i) {}\n///   };\n///   struct E : B {\n///     E() : B() {}\n///   };\n/// \\endcode\n/// cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer()))\n///   will match D(int), but not match E().\nAST_MATCHER(CXXCtorInitializer, isMemberInitializer) {\n  return Node.isMemberInitializer();\n}\n\n/// Matches any argument of a call expression or a constructor call\n/// expression, or an ObjC-message-send expression.\n///\n/// Given\n/// \\code\n///   void x(int, int, int) { int y; x(1, y, 42); }\n/// \\endcode\n/// callExpr(hasAnyArgument(declRefExpr()))\n///   matches x(1, y, 42)\n/// with hasAnyArgument(...)\n///   matching y\n///\n/// For ObjectiveC, given\n/// \\code\n///   @interface I - (void) f:(int) y; @end\n///   void foo(I *i) { [i f:12]; }\n/// \\endcode\n/// objcMessageExpr(hasAnyArgument(integerLiteral(equals(12))))\n///   matches [i f:12]\nAST_POLYMORPHIC_MATCHER_P(hasAnyArgument,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              CallExpr, CXXConstructExpr,\n                              CXXUnresolvedConstructExpr, ObjCMessageExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  for (const Expr *Arg : Node.arguments()) {\n    if (Finder->isTraversalIgnoringImplicitNodes() &&\n        isa<CXXDefaultArgExpr>(Arg))\n      break;\n    BoundNodesTreeBuilder Result(*Builder);\n    if (InnerMatcher.matches(*Arg, Finder, &Result)) {\n      *Builder = std::move(Result);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Matches any capture of a lambda expression.\n///\n/// Given\n/// \\code\n///   void foo() {\n///     int x;\n///     auto f = [x](){};\n///   }\n/// \\endcode\n/// lambdaExpr(hasAnyCapture(anything()))\n///   matches [x](){};\nAST_MATCHER_P_OVERLOAD(LambdaExpr, hasAnyCapture, internal::Matcher<VarDecl>,\n                       InnerMatcher, 0) {\n  for (const LambdaCapture &Capture : Node.captures()) {\n    if (Capture.capturesVariable()) {\n      BoundNodesTreeBuilder Result(*Builder);\n      if (InnerMatcher.matches(*Capture.getCapturedVar(), Finder, &Result)) {\n        *Builder = std::move(Result);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/// Matches any capture of 'this' in a lambda expression.\n///\n/// Given\n/// \\code\n///   struct foo {\n///     void bar() {\n///       auto f = [this](){};\n///     }\n///   }\n/// \\endcode\n/// lambdaExpr(hasAnyCapture(cxxThisExpr()))\n///   matches [this](){};\nAST_MATCHER_P_OVERLOAD(LambdaExpr, hasAnyCapture,\n                       internal::Matcher<CXXThisExpr>, InnerMatcher, 1) {\n  return llvm::any_of(Node.captures(), [](const LambdaCapture &LC) {\n    return LC.capturesThis();\n  });\n}\n\n/// Matches a constructor call expression which uses list initialization.\nAST_MATCHER(CXXConstructExpr, isListInitialization) {\n  return Node.isListInitialization();\n}\n\n/// Matches a constructor call expression which requires\n/// zero initialization.\n///\n/// Given\n/// \\code\n/// void foo() {\n///   struct point { double x; double y; };\n///   point pt[2] = { { 1.0, 2.0 } };\n/// }\n/// \\endcode\n/// initListExpr(has(cxxConstructExpr(requiresZeroInitialization()))\n/// will match the implicit array filler for pt[1].\nAST_MATCHER(CXXConstructExpr, requiresZeroInitialization) {\n  return Node.requiresZeroInitialization();\n}\n\n/// Matches the n'th parameter of a function or an ObjC method\n/// declaration or a block.\n///\n/// Given\n/// \\code\n///   class X { void f(int x) {} };\n/// \\endcode\n/// cxxMethodDecl(hasParameter(0, hasType(varDecl())))\n///   matches f(int x) {}\n/// with hasParameter(...)\n///   matching int x\n///\n/// For ObjectiveC, given\n/// \\code\n///   @interface I - (void) f:(int) y; @end\n/// \\endcode\n//\n/// the matcher objcMethodDecl(hasParameter(0, hasName(\"y\")))\n/// matches the declaration of method f with hasParameter\n/// matching y.\nAST_POLYMORPHIC_MATCHER_P2(hasParameter,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                           ObjCMethodDecl,\n                                                           BlockDecl),\n                           unsigned, N, internal::Matcher<ParmVarDecl>,\n                           InnerMatcher) {\n  return (N < Node.parameters().size()\n          && InnerMatcher.matches(*Node.parameters()[N], Finder, Builder));\n}\n\n/// Matches all arguments and their respective ParmVarDecl.\n///\n/// Given\n/// \\code\n///   void f(int i);\n///   int y;\n///   f(y);\n/// \\endcode\n/// callExpr(\n///   forEachArgumentWithParam(\n///     declRefExpr(to(varDecl(hasName(\"y\")))),\n///     parmVarDecl(hasType(isInteger()))\n/// ))\n///   matches f(y);\n/// with declRefExpr(...)\n///   matching int y\n/// and parmVarDecl(...)\n///   matching int i\nAST_POLYMORPHIC_MATCHER_P2(forEachArgumentWithParam,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,\n                                                           CXXConstructExpr),\n                           internal::Matcher<Expr>, ArgMatcher,\n                           internal::Matcher<ParmVarDecl>, ParamMatcher) {\n  BoundNodesTreeBuilder Result;\n  // The first argument of an overloaded member operator is the implicit object\n  // argument of the method which should not be matched against a parameter, so\n  // we skip over it here.\n  BoundNodesTreeBuilder Matches;\n  unsigned ArgIndex = cxxOperatorCallExpr(callee(cxxMethodDecl()))\n                              .matches(Node, Finder, &Matches)\n                          ? 1\n                          : 0;\n  int ParamIndex = 0;\n  bool Matched = false;\n  for (; ArgIndex < Node.getNumArgs(); ++ArgIndex) {\n    BoundNodesTreeBuilder ArgMatches(*Builder);\n    if (ArgMatcher.matches(*(Node.getArg(ArgIndex)->IgnoreParenCasts()),\n                           Finder, &ArgMatches)) {\n      BoundNodesTreeBuilder ParamMatches(ArgMatches);\n      if (expr(anyOf(cxxConstructExpr(hasDeclaration(cxxConstructorDecl(\n                         hasParameter(ParamIndex, ParamMatcher)))),\n                     callExpr(callee(functionDecl(\n                         hasParameter(ParamIndex, ParamMatcher))))))\n              .matches(Node, Finder, &ParamMatches)) {\n        Result.addMatch(ParamMatches);\n        Matched = true;\n      }\n    }\n    ++ParamIndex;\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches all arguments and their respective types for a \\c CallExpr or\n/// \\c CXXConstructExpr. It is very similar to \\c forEachArgumentWithParam but\n/// it works on calls through function pointers as well.\n///\n/// The difference is, that function pointers do not provide access to a\n/// \\c ParmVarDecl, but only the \\c QualType for each argument.\n///\n/// Given\n/// \\code\n///   void f(int i);\n///   int y;\n///   f(y);\n///   void (*f_ptr)(int) = f;\n///   f_ptr(y);\n/// \\endcode\n/// callExpr(\n///   forEachArgumentWithParamType(\n///     declRefExpr(to(varDecl(hasName(\"y\")))),\n///     qualType(isInteger()).bind(\"type)\n/// ))\n///   matches f(y) and f_ptr(y)\n/// with declRefExpr(...)\n///   matching int y\n/// and qualType(...)\n///   matching int\nAST_POLYMORPHIC_MATCHER_P2(forEachArgumentWithParamType,\n                           AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,\n                                                           CXXConstructExpr),\n                           internal::Matcher<Expr>, ArgMatcher,\n                           internal::Matcher<QualType>, ParamMatcher) {\n  BoundNodesTreeBuilder Result;\n  // The first argument of an overloaded member operator is the implicit object\n  // argument of the method which should not be matched against a parameter, so\n  // we skip over it here.\n  BoundNodesTreeBuilder Matches;\n  unsigned ArgIndex = cxxOperatorCallExpr(callee(cxxMethodDecl()))\n                              .matches(Node, Finder, &Matches)\n                          ? 1\n                          : 0;\n\n  const FunctionProtoType *FProto = nullptr;\n\n  if (const auto *Call = dyn_cast<CallExpr>(&Node)) {\n    if (const auto *Value =\n            dyn_cast_or_null<ValueDecl>(Call->getCalleeDecl())) {\n      QualType QT = Value->getType().getCanonicalType();\n\n      // This does not necessarily lead to a `FunctionProtoType`,\n      // e.g. K&R functions do not have a function prototype.\n      if (QT->isFunctionPointerType())\n        FProto = QT->getPointeeType()->getAs<FunctionProtoType>();\n\n      if (QT->isMemberFunctionPointerType()) {\n        const auto *MP = QT->getAs<MemberPointerType>();\n        assert(MP && \"Must be member-pointer if its a memberfunctionpointer\");\n        FProto = MP->getPointeeType()->getAs<FunctionProtoType>();\n        assert(FProto &&\n               \"The call must have happened through a member function \"\n               \"pointer\");\n      }\n    }\n  }\n\n  int ParamIndex = 0;\n  bool Matched = false;\n\n  for (; ArgIndex < Node.getNumArgs(); ++ArgIndex, ++ParamIndex) {\n    BoundNodesTreeBuilder ArgMatches(*Builder);\n    if (ArgMatcher.matches(*(Node.getArg(ArgIndex)->IgnoreParenCasts()), Finder,\n                           &ArgMatches)) {\n      BoundNodesTreeBuilder ParamMatches(ArgMatches);\n\n      // This test is cheaper compared to the big matcher in the next if.\n      // Therefore, please keep this order.\n      if (FProto) {\n        QualType ParamType = FProto->getParamType(ParamIndex);\n        if (ParamMatcher.matches(ParamType, Finder, &ParamMatches)) {\n          Result.addMatch(ParamMatches);\n          Matched = true;\n          continue;\n        }\n      }\n      if (expr(anyOf(cxxConstructExpr(hasDeclaration(cxxConstructorDecl(\n                         hasParameter(ParamIndex, hasType(ParamMatcher))))),\n                     callExpr(callee(functionDecl(\n                         hasParameter(ParamIndex, hasType(ParamMatcher)))))))\n              .matches(Node, Finder, &ParamMatches)) {\n        Result.addMatch(ParamMatches);\n        Matched = true;\n        continue;\n      }\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches the ParmVarDecl nodes that are at the N'th position in the parameter\n/// list. The parameter list could be that of either a block, function, or\n/// objc-method.\n///\n///\n/// Given\n///\n/// \\code\n/// void f(int a, int b, int c) {\n/// }\n/// \\endcode\n///\n/// ``parmVarDecl(isAtPosition(0))`` matches ``int a``.\n///\n/// ``parmVarDecl(isAtPosition(1))`` matches ``int b``.\nAST_MATCHER_P(ParmVarDecl, isAtPosition, unsigned, N) {\n  const clang::DeclContext *Context = Node.getParentFunctionOrMethod();\n\n  if (const auto *Decl = dyn_cast_or_null<FunctionDecl>(Context))\n    return N < Decl->param_size() && Decl->getParamDecl(N) == &Node;\n  if (const auto *Decl = dyn_cast_or_null<BlockDecl>(Context))\n    return N < Decl->param_size() && Decl->getParamDecl(N) == &Node;\n  if (const auto *Decl = dyn_cast_or_null<ObjCMethodDecl>(Context))\n    return N < Decl->param_size() && Decl->getParamDecl(N) == &Node;\n\n  return false;\n}\n\n/// Matches any parameter of a function or an ObjC method declaration or a\n/// block.\n///\n/// Does not match the 'this' parameter of a method.\n///\n/// Given\n/// \\code\n///   class X { void f(int x, int y, int z) {} };\n/// \\endcode\n/// cxxMethodDecl(hasAnyParameter(hasName(\"y\")))\n///   matches f(int x, int y, int z) {}\n/// with hasAnyParameter(...)\n///   matching int y\n///\n/// For ObjectiveC, given\n/// \\code\n///   @interface I - (void) f:(int) y; @end\n/// \\endcode\n//\n/// the matcher objcMethodDecl(hasAnyParameter(hasName(\"y\")))\n/// matches the declaration of method f with hasParameter\n/// matching y.\n///\n/// For blocks, given\n/// \\code\n///   b = ^(int y) { printf(\"%d\", y) };\n/// \\endcode\n///\n/// the matcher blockDecl(hasAnyParameter(hasName(\"y\")))\n/// matches the declaration of the block b with hasParameter\n/// matching y.\nAST_POLYMORPHIC_MATCHER_P(hasAnyParameter,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                          ObjCMethodDecl,\n                                                          BlockDecl),\n                          internal::Matcher<ParmVarDecl>,\n                          InnerMatcher) {\n  return matchesFirstInPointerRange(InnerMatcher, Node.param_begin(),\n                                    Node.param_end(), Finder,\n                                    Builder) != Node.param_end();\n}\n\n/// Matches \\c FunctionDecls and \\c FunctionProtoTypes that have a\n/// specific parameter count.\n///\n/// Given\n/// \\code\n///   void f(int i) {}\n///   void g(int i, int j) {}\n///   void h(int i, int j);\n///   void j(int i);\n///   void k(int x, int y, int z, ...);\n/// \\endcode\n/// functionDecl(parameterCountIs(2))\n///   matches \\c g and \\c h\n/// functionProtoType(parameterCountIs(2))\n///   matches \\c g and \\c h\n/// functionProtoType(parameterCountIs(3))\n///   matches \\c k\nAST_POLYMORPHIC_MATCHER_P(parameterCountIs,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                          FunctionProtoType),\n                          unsigned, N) {\n  return Node.getNumParams() == N;\n}\n\n/// Matches \\c FunctionDecls that have a noreturn attribute.\n///\n/// Given\n/// \\code\n///   void nope();\n///   [[noreturn]] void a();\n///   __attribute__((noreturn)) void b();\n///   struct c { [[noreturn]] c(); };\n/// \\endcode\n/// functionDecl(isNoReturn())\n///   matches all of those except\n/// \\code\n///   void nope();\n/// \\endcode\nAST_MATCHER(FunctionDecl, isNoReturn) { return Node.isNoReturn(); }\n\n/// Matches the return type of a function declaration.\n///\n/// Given:\n/// \\code\n///   class X { int f() { return 1; } };\n/// \\endcode\n/// cxxMethodDecl(returns(asString(\"int\")))\n///   matches int f() { return 1; }\nAST_MATCHER_P(FunctionDecl, returns,\n              internal::Matcher<QualType>, InnerMatcher) {\n  return InnerMatcher.matches(Node.getReturnType(), Finder, Builder);\n}\n\n/// Matches extern \"C\" function or variable declarations.\n///\n/// Given:\n/// \\code\n///   extern \"C\" void f() {}\n///   extern \"C\" { void g() {} }\n///   void h() {}\n///   extern \"C\" int x = 1;\n///   extern \"C\" int y = 2;\n///   int z = 3;\n/// \\endcode\n/// functionDecl(isExternC())\n///   matches the declaration of f and g, but not the declaration of h.\n/// varDecl(isExternC())\n///   matches the declaration of x and y, but not the declaration of z.\nAST_POLYMORPHIC_MATCHER(isExternC, AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                                   VarDecl)) {\n  return Node.isExternC();\n}\n\n/// Matches variable/function declarations that have \"static\" storage\n/// class specifier (\"static\" keyword) written in the source.\n///\n/// Given:\n/// \\code\n///   static void f() {}\n///   static int i = 0;\n///   extern int j;\n///   int k;\n/// \\endcode\n/// functionDecl(isStaticStorageClass())\n///   matches the function declaration f.\n/// varDecl(isStaticStorageClass())\n///   matches the variable declaration i.\nAST_POLYMORPHIC_MATCHER(isStaticStorageClass,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                        VarDecl)) {\n  return Node.getStorageClass() == SC_Static;\n}\n\n/// Matches deleted function declarations.\n///\n/// Given:\n/// \\code\n///   void Func();\n///   void DeletedFunc() = delete;\n/// \\endcode\n/// functionDecl(isDeleted())\n///   matches the declaration of DeletedFunc, but not Func.\nAST_MATCHER(FunctionDecl, isDeleted) {\n  return Node.isDeleted();\n}\n\n/// Matches defaulted function declarations.\n///\n/// Given:\n/// \\code\n///   class A { ~A(); };\n///   class B { ~B() = default; };\n/// \\endcode\n/// functionDecl(isDefaulted())\n///   matches the declaration of ~B, but not ~A.\nAST_MATCHER(FunctionDecl, isDefaulted) {\n  return Node.isDefaulted();\n}\n\n/// Matches weak function declarations.\n///\n/// Given:\n/// \\code\n///   void foo() __attribute__((__weakref__(\"__foo\")));\n///   void bar();\n/// \\endcode\n/// functionDecl(isWeak())\n///   matches the weak declaration \"foo\", but not \"bar\".\nAST_MATCHER(FunctionDecl, isWeak) { return Node.isWeak(); }\n\n/// Matches functions that have a dynamic exception specification.\n///\n/// Given:\n/// \\code\n///   void f();\n///   void g() noexcept;\n///   void h() noexcept(true);\n///   void i() noexcept(false);\n///   void j() throw();\n///   void k() throw(int);\n///   void l() throw(...);\n/// \\endcode\n/// functionDecl(hasDynamicExceptionSpec()) and\n///   functionProtoType(hasDynamicExceptionSpec())\n///   match the declarations of j, k, and l, but not f, g, h, or i.\nAST_POLYMORPHIC_MATCHER(hasDynamicExceptionSpec,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                        FunctionProtoType)) {\n  if (const FunctionProtoType *FnTy = internal::getFunctionProtoType(Node))\n    return FnTy->hasDynamicExceptionSpec();\n  return false;\n}\n\n/// Matches functions that have a non-throwing exception specification.\n///\n/// Given:\n/// \\code\n///   void f();\n///   void g() noexcept;\n///   void h() throw();\n///   void i() throw(int);\n///   void j() noexcept(false);\n/// \\endcode\n/// functionDecl(isNoThrow()) and functionProtoType(isNoThrow())\n///   match the declarations of g, and h, but not f, i or j.\nAST_POLYMORPHIC_MATCHER(isNoThrow,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,\n                                                        FunctionProtoType)) {\n  const FunctionProtoType *FnTy = internal::getFunctionProtoType(Node);\n\n  // If the function does not have a prototype, then it is assumed to be a\n  // throwing function (as it would if the function did not have any exception\n  // specification).\n  if (!FnTy)\n    return false;\n\n  // Assume the best for any unresolved exception specification.\n  if (isUnresolvedExceptionSpec(FnTy->getExceptionSpecType()))\n    return true;\n\n  return FnTy->isNothrow();\n}\n\n/// Matches constexpr variable and function declarations,\n///        and if constexpr.\n///\n/// Given:\n/// \\code\n///   constexpr int foo = 42;\n///   constexpr int bar();\n///   void baz() { if constexpr(1 > 0) {} }\n/// \\endcode\n/// varDecl(isConstexpr())\n///   matches the declaration of foo.\n/// functionDecl(isConstexpr())\n///   matches the declaration of bar.\n/// ifStmt(isConstexpr())\n///   matches the if statement in baz.\nAST_POLYMORPHIC_MATCHER(isConstexpr,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(VarDecl,\n                                                        FunctionDecl,\n                                                        IfStmt)) {\n  return Node.isConstexpr();\n}\n\n/// Matches selection statements with initializer.\n///\n/// Given:\n/// \\code\n///  void foo() {\n///    if (int i = foobar(); i > 0) {}\n///    switch (int i = foobar(); i) {}\n///    for (auto& a = get_range(); auto& x : a) {}\n///  }\n///  void bar() {\n///    if (foobar() > 0) {}\n///    switch (foobar()) {}\n///    for (auto& x : get_range()) {}\n///  }\n/// \\endcode\n/// ifStmt(hasInitStatement(anything()))\n///   matches the if statement in foo but not in bar.\n/// switchStmt(hasInitStatement(anything()))\n///   matches the switch statement in foo but not in bar.\n/// cxxForRangeStmt(hasInitStatement(anything()))\n///   matches the range for statement in foo but not in bar.\nAST_POLYMORPHIC_MATCHER_P(hasInitStatement,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(IfStmt, SwitchStmt,\n                                                          CXXForRangeStmt),\n                          internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *Init = Node.getInit();\n  return Init != nullptr && InnerMatcher.matches(*Init, Finder, Builder);\n}\n\n/// Matches the condition expression of an if statement, for loop,\n/// switch statement or conditional operator.\n///\n/// Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true))))\n/// \\code\n///   if (true) {}\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(\n    hasCondition,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(IfStmt, ForStmt, WhileStmt, DoStmt,\n                                    SwitchStmt, AbstractConditionalOperator),\n    internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *const Condition = Node.getCond();\n  return (Condition != nullptr &&\n          InnerMatcher.matches(*Condition, Finder, Builder));\n}\n\n/// Matches the then-statement of an if statement.\n///\n/// Examples matches the if statement\n///   (matcher = ifStmt(hasThen(cxxBoolLiteral(equals(true)))))\n/// \\code\n///   if (false) true; else false;\n/// \\endcode\nAST_MATCHER_P(IfStmt, hasThen, internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *const Then = Node.getThen();\n  return (Then != nullptr && InnerMatcher.matches(*Then, Finder, Builder));\n}\n\n/// Matches the else-statement of an if statement.\n///\n/// Examples matches the if statement\n///   (matcher = ifStmt(hasElse(cxxBoolLiteral(equals(true)))))\n/// \\code\n///   if (false) false; else true;\n/// \\endcode\nAST_MATCHER_P(IfStmt, hasElse, internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *const Else = Node.getElse();\n  return (Else != nullptr && InnerMatcher.matches(*Else, Finder, Builder));\n}\n\n/// Matches if a node equals a previously bound node.\n///\n/// Matches a node if it equals the node previously bound to \\p ID.\n///\n/// Given\n/// \\code\n///   class X { int a; int b; };\n/// \\endcode\n/// cxxRecordDecl(\n///     has(fieldDecl(hasName(\"a\"), hasType(type().bind(\"t\")))),\n///     has(fieldDecl(hasName(\"b\"), hasType(type(equalsBoundNode(\"t\"))))))\n///   matches the class \\c X, as \\c a and \\c b have the same type.\n///\n/// Note that when multiple matches are involved via \\c forEach* matchers,\n/// \\c equalsBoundNodes acts as a filter.\n/// For example:\n/// compoundStmt(\n///     forEachDescendant(varDecl().bind(\"d\")),\n///     forEachDescendant(declRefExpr(to(decl(equalsBoundNode(\"d\"))))))\n/// will trigger a match for each combination of variable declaration\n/// and reference to that variable declaration within a compound statement.\nAST_POLYMORPHIC_MATCHER_P(equalsBoundNode,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(Stmt, Decl, Type,\n                                                          QualType),\n                          std::string, ID) {\n  // FIXME: Figure out whether it makes sense to allow this\n  // on any other node types.\n  // For *Loc it probably does not make sense, as those seem\n  // unique. For NestedNameSepcifier it might make sense, as\n  // those also have pointer identity, but I'm not sure whether\n  // they're ever reused.\n  internal::NotEqualsBoundNodePredicate Predicate;\n  Predicate.ID = ID;\n  Predicate.Node = DynTypedNode::create(Node);\n  return Builder->removeBindings(Predicate);\n}\n\n/// Matches the condition variable statement in an if statement.\n///\n/// Given\n/// \\code\n///   if (A* a = GetAPointer()) {}\n/// \\endcode\n/// hasConditionVariableStatement(...)\n///   matches 'A* a = GetAPointer()'.\nAST_MATCHER_P(IfStmt, hasConditionVariableStatement,\n              internal::Matcher<DeclStmt>, InnerMatcher) {\n  const DeclStmt* const DeclarationStatement =\n    Node.getConditionVariableDeclStmt();\n  return DeclarationStatement != nullptr &&\n         InnerMatcher.matches(*DeclarationStatement, Finder, Builder);\n}\n\n/// Matches the index expression of an array subscript expression.\n///\n/// Given\n/// \\code\n///   int i[5];\n///   void f() { i[1] = 42; }\n/// \\endcode\n/// arraySubscriptExpression(hasIndex(integerLiteral()))\n///   matches \\c i[1] with the \\c integerLiteral() matching \\c 1\nAST_MATCHER_P(ArraySubscriptExpr, hasIndex,\n              internal::Matcher<Expr>, InnerMatcher) {\n  if (const Expr* Expression = Node.getIdx())\n    return InnerMatcher.matches(*Expression, Finder, Builder);\n  return false;\n}\n\n/// Matches the base expression of an array subscript expression.\n///\n/// Given\n/// \\code\n///   int i[5];\n///   void f() { i[1] = 42; }\n/// \\endcode\n/// arraySubscriptExpression(hasBase(implicitCastExpr(\n///     hasSourceExpression(declRefExpr()))))\n///   matches \\c i[1] with the \\c declRefExpr() matching \\c i\nAST_MATCHER_P(ArraySubscriptExpr, hasBase,\n              internal::Matcher<Expr>, InnerMatcher) {\n  if (const Expr* Expression = Node.getBase())\n    return InnerMatcher.matches(*Expression, Finder, Builder);\n  return false;\n}\n\n/// Matches a 'for', 'while', 'do while' statement or a function\n/// definition that has a given body. Note that in case of functions\n/// this matcher only matches the definition itself and not the other\n/// declarations of the same function.\n///\n/// Given\n/// \\code\n///   for (;;) {}\n/// \\endcode\n/// hasBody(compoundStmt())\n///   matches 'for (;;) {}'\n/// with compoundStmt()\n///   matching '{}'\n///\n/// Given\n/// \\code\n///   void f();\n///   void f() {}\n/// \\endcode\n/// hasBody(functionDecl())\n///   matches 'void f() {}'\n/// with compoundStmt()\n///   matching '{}'\n///   but does not match 'void f();'\n\nAST_POLYMORPHIC_MATCHER_P(hasBody,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(DoStmt, ForStmt,\n                                                          WhileStmt,\n                                                          CXXForRangeStmt,\n                                                          FunctionDecl),\n                          internal::Matcher<Stmt>, InnerMatcher) {\n  if (Finder->isTraversalIgnoringImplicitNodes() && isDefaultedHelper(&Node))\n    return false;\n  const Stmt *const Statement = internal::GetBodyMatcher<NodeType>::get(Node);\n  return (Statement != nullptr &&\n          InnerMatcher.matches(*Statement, Finder, Builder));\n}\n\n/// Matches a function declaration that has a given body present in the AST.\n/// Note that this matcher matches all the declarations of a function whose\n/// body is present in the AST.\n///\n/// Given\n/// \\code\n///   void f();\n///   void f() {}\n///   void g();\n/// \\endcode\n/// hasAnyBody(functionDecl())\n///   matches both 'void f();'\n///   and 'void f() {}'\n/// with compoundStmt()\n///   matching '{}'\n///   but does not match 'void g();'\nAST_MATCHER_P(FunctionDecl, hasAnyBody,\n              internal::Matcher<Stmt>, InnerMatcher) {\n  const Stmt *const Statement = Node.getBody();\n  return (Statement != nullptr &&\n          InnerMatcher.matches(*Statement, Finder, Builder));\n}\n\n\n/// Matches compound statements where at least one substatement matches\n/// a given matcher. Also matches StmtExprs that have CompoundStmt as children.\n///\n/// Given\n/// \\code\n///   { {}; 1+2; }\n/// \\endcode\n/// hasAnySubstatement(compoundStmt())\n///   matches '{ {}; 1+2; }'\n/// with compoundStmt()\n///   matching '{}'\nAST_POLYMORPHIC_MATCHER_P(hasAnySubstatement,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CompoundStmt,\n                                                          StmtExpr),\n                          internal::Matcher<Stmt>, InnerMatcher) {\n  const CompoundStmt *CS = CompoundStmtMatcher<NodeType>::get(Node);\n  return CS && matchesFirstInPointerRange(InnerMatcher, CS->body_begin(),\n                                          CS->body_end(), Finder,\n                                          Builder) != CS->body_end();\n}\n\n/// Checks that a compound statement contains a specific number of\n/// child statements.\n///\n/// Example: Given\n/// \\code\n///   { for (;;) {} }\n/// \\endcode\n/// compoundStmt(statementCountIs(0)))\n///   matches '{}'\n///   but does not match the outer compound statement.\nAST_MATCHER_P(CompoundStmt, statementCountIs, unsigned, N) {\n  return Node.size() == N;\n}\n\n/// Matches literals that are equal to the given value of type ValueT.\n///\n/// Given\n/// \\code\n///   f('\\0', false, 3.14, 42);\n/// \\endcode\n/// characterLiteral(equals(0))\n///   matches '\\0'\n/// cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0))\n///   match false\n/// floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2))\n///   match 3.14\n/// integerLiteral(equals(42))\n///   matches 42\n///\n/// Note that you cannot directly match a negative numeric literal because the\n/// minus sign is not part of the literal: It is a unary operator whose operand\n/// is the positive numeric literal. Instead, you must use a unaryOperator()\n/// matcher to match the minus sign:\n///\n/// unaryOperator(hasOperatorName(\"-\"),\n///               hasUnaryOperand(integerLiteral(equals(13))))\n///\n/// Usable as: Matcher<CharacterLiteral>, Matcher<CXXBoolLiteralExpr>,\n///            Matcher<FloatingLiteral>, Matcher<IntegerLiteral>\ntemplate <typename ValueT>\ninternal::PolymorphicMatcher<internal::ValueEqualsMatcher,\n                             void(internal::AllNodeBaseTypes), ValueT>\nequals(const ValueT &Value) {\n  return internal::PolymorphicMatcher<internal::ValueEqualsMatcher,\n                                      void(internal::AllNodeBaseTypes), ValueT>(\n      Value);\n}\n\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(equals,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,\n                                                          CXXBoolLiteralExpr,\n                                                          IntegerLiteral),\n                          bool, Value, 0) {\n  return internal::ValueEqualsMatcher<NodeType, ParamT>(Value)\n    .matchesNode(Node);\n}\n\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(equals,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,\n                                                          CXXBoolLiteralExpr,\n                                                          IntegerLiteral),\n                          unsigned, Value, 1) {\n  return internal::ValueEqualsMatcher<NodeType, ParamT>(Value)\n    .matchesNode(Node);\n}\n\nAST_POLYMORPHIC_MATCHER_P_OVERLOAD(equals,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,\n                                                          CXXBoolLiteralExpr,\n                                                          FloatingLiteral,\n                                                          IntegerLiteral),\n                          double, Value, 2) {\n  return internal::ValueEqualsMatcher<NodeType, ParamT>(Value)\n    .matchesNode(Node);\n}\n\n/// Matches the operator Name of operator expressions (binary or\n/// unary).\n///\n/// Example matches a || b (matcher = binaryOperator(hasOperatorName(\"||\")))\n/// \\code\n///   !(a || b)\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(\n    hasOperatorName,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator, UnaryOperator),\n    std::string, Name) {\n  if (Optional<StringRef> OpName = internal::getOpName(Node))\n    return *OpName == Name;\n  return false;\n}\n\n/// Matches operator expressions (binary or unary) that have any of the\n/// specified names.\n///\n///    hasAnyOperatorName(\"+\", \"-\")\n///  Is equivalent to\n///    anyOf(hasOperatorName(\"+\"), hasOperatorName(\"-\"))\nextern const internal::VariadicFunction<\n    internal::PolymorphicMatcher<internal::HasAnyOperatorNameMatcher,\n                                 AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                     BinaryOperator, CXXOperatorCallExpr,\n                                     CXXRewrittenBinaryOperator, UnaryOperator),\n                                 std::vector<std::string>>,\n    StringRef, internal::hasAnyOperatorNameFunc>\n    hasAnyOperatorName;\n\n/// Matches all kinds of assignment operators.\n///\n/// Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator()))\n/// \\code\n///   if (a == b)\n///     a += b;\n/// \\endcode\n///\n/// Example 2: matches s1 = s2\n///            (matcher = cxxOperatorCallExpr(isAssignmentOperator()))\n/// \\code\n///   struct S { S& operator=(const S&); };\n///   void x() { S s1, s2; s1 = s2; }\n/// \\endcode\nAST_POLYMORPHIC_MATCHER(\n    isAssignmentOperator,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator)) {\n  return Node.isAssignmentOp();\n}\n\n/// Matches comparison operators.\n///\n/// Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator()))\n/// \\code\n///   if (a == b)\n///     a += b;\n/// \\endcode\n///\n/// Example 2: matches s1 < s2\n///            (matcher = cxxOperatorCallExpr(isComparisonOperator()))\n/// \\code\n///   struct S { bool operator<(const S& other); };\n///   void x(S s1, S s2) { bool b1 = s1 < s2; }\n/// \\endcode\nAST_POLYMORPHIC_MATCHER(\n    isComparisonOperator,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator)) {\n  return Node.isComparisonOp();\n}\n\n/// Matches the left hand side of binary operator expressions.\n///\n/// Example matches a (matcher = binaryOperator(hasLHS()))\n/// \\code\n///   a || b\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasLHS,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              BinaryOperator, CXXOperatorCallExpr,\n                              CXXRewrittenBinaryOperator, ArraySubscriptExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *LeftHandSide = internal::getLHS(Node);\n  return (LeftHandSide != nullptr &&\n          InnerMatcher.matches(*LeftHandSide, Finder, Builder));\n}\n\n/// Matches the right hand side of binary operator expressions.\n///\n/// Example matches b (matcher = binaryOperator(hasRHS()))\n/// \\code\n///   a || b\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasRHS,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(\n                              BinaryOperator, CXXOperatorCallExpr,\n                              CXXRewrittenBinaryOperator, ArraySubscriptExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *RightHandSide = internal::getRHS(Node);\n  return (RightHandSide != nullptr &&\n          InnerMatcher.matches(*RightHandSide, Finder, Builder));\n}\n\n/// Matches if either the left hand side or the right hand side of a\n/// binary operator matches.\nAST_POLYMORPHIC_MATCHER_P(\n    hasEitherOperand,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator),\n    internal::Matcher<Expr>, InnerMatcher) {\n  return internal::VariadicDynCastAllOfMatcher<Stmt, NodeType>()(\n             anyOf(hasLHS(InnerMatcher), hasRHS(InnerMatcher)))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches if both matchers match with opposite sides of the binary operator.\n///\n/// Example matcher = binaryOperator(hasOperands(integerLiteral(equals(1),\n///                                              integerLiteral(equals(2)))\n/// \\code\n///   1 + 2 // Match\n///   2 + 1 // Match\n///   1 + 1 // No match\n///   2 + 2 // No match\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P2(\n    hasOperands,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator),\n    internal::Matcher<Expr>, Matcher1, internal::Matcher<Expr>, Matcher2) {\n  return internal::VariadicDynCastAllOfMatcher<Stmt, NodeType>()(\n             anyOf(allOf(hasLHS(Matcher1), hasRHS(Matcher2)),\n                   allOf(hasLHS(Matcher2), hasRHS(Matcher1))))\n      .matches(Node, Finder, Builder);\n}\n\n/// Matches if the operand of a unary operator matches.\n///\n/// Example matches true (matcher = hasUnaryOperand(\n///                                   cxxBoolLiteral(equals(true))))\n/// \\code\n///   !true\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasUnaryOperand,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(UnaryOperator,\n                                                          CXXOperatorCallExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *const Operand = internal::getSubExpr(Node);\n  return (Operand != nullptr &&\n          InnerMatcher.matches(*Operand, Finder, Builder));\n}\n\n/// Matches if the cast's source expression\n/// or opaque value's source expression matches the given matcher.\n///\n/// Example 1: matches \"a string\"\n/// (matcher = castExpr(hasSourceExpression(cxxConstructExpr())))\n/// \\code\n/// class URL { URL(string); };\n/// URL url = \"a string\";\n/// \\endcode\n///\n/// Example 2: matches 'b' (matcher =\n/// opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr())))\n/// \\code\n/// int a = b ?: 1;\n/// \\endcode\nAST_POLYMORPHIC_MATCHER_P(hasSourceExpression,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(CastExpr,\n                                                          OpaqueValueExpr),\n                          internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *const SubExpression =\n      internal::GetSourceExpressionMatcher<NodeType>::get(Node);\n  return (SubExpression != nullptr &&\n          InnerMatcher.matches(*SubExpression, Finder, Builder));\n}\n\n/// Matches casts that has a given cast kind.\n///\n/// Example: matches the implicit cast around \\c 0\n/// (matcher = castExpr(hasCastKind(CK_NullToPointer)))\n/// \\code\n///   int *p = 0;\n/// \\endcode\n///\n/// If the matcher is use from clang-query, CastKind parameter\n/// should be passed as a quoted string. e.g., hasCastKind(\"CK_NullToPointer\").\nAST_MATCHER_P(CastExpr, hasCastKind, CastKind, Kind) {\n  return Node.getCastKind() == Kind;\n}\n\n/// Matches casts whose destination type matches a given matcher.\n///\n/// (Note: Clang's AST refers to other conversions as \"casts\" too, and calls\n/// actual casts \"explicit\" casts.)\nAST_MATCHER_P(ExplicitCastExpr, hasDestinationType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  const QualType NodeType = Node.getTypeAsWritten();\n  return InnerMatcher.matches(NodeType, Finder, Builder);\n}\n\n/// Matches implicit casts whose destination type matches a given\n/// matcher.\n///\n/// FIXME: Unit test this matcher\nAST_MATCHER_P(ImplicitCastExpr, hasImplicitDestinationType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  return InnerMatcher.matches(Node.getType(), Finder, Builder);\n}\n\n/// Matches TagDecl object that are spelled with \"struct.\"\n///\n/// Example matches S, but not C, U or E.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isStruct) {\n  return Node.isStruct();\n}\n\n/// Matches TagDecl object that are spelled with \"union.\"\n///\n/// Example matches U, but not C, S or E.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isUnion) {\n  return Node.isUnion();\n}\n\n/// Matches TagDecl object that are spelled with \"class.\"\n///\n/// Example matches C, but not S, U or E.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isClass) {\n  return Node.isClass();\n}\n\n/// Matches TagDecl object that are spelled with \"enum.\"\n///\n/// Example matches E, but not C, S or U.\n/// \\code\n///   struct S {};\n///   class C {};\n///   union U {};\n///   enum E {};\n/// \\endcode\nAST_MATCHER(TagDecl, isEnum) {\n  return Node.isEnum();\n}\n\n/// Matches the true branch expression of a conditional operator.\n///\n/// Example 1 (conditional ternary operator): matches a\n/// \\code\n///   condition ? a : b\n/// \\endcode\n///\n/// Example 2 (conditional binary operator): matches opaqueValueExpr(condition)\n/// \\code\n///   condition ?: b\n/// \\endcode\nAST_MATCHER_P(AbstractConditionalOperator, hasTrueExpression,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *Expression = Node.getTrueExpr();\n  return (Expression != nullptr &&\n          InnerMatcher.matches(*Expression, Finder, Builder));\n}\n\n/// Matches the false branch expression of a conditional operator\n/// (binary or ternary).\n///\n/// Example matches b\n/// \\code\n///   condition ? a : b\n///   condition ?: b\n/// \\endcode\nAST_MATCHER_P(AbstractConditionalOperator, hasFalseExpression,\n              internal::Matcher<Expr>, InnerMatcher) {\n  const Expr *Expression = Node.getFalseExpr();\n  return (Expression != nullptr &&\n          InnerMatcher.matches(*Expression, Finder, Builder));\n}\n\n/// Matches if a declaration has a body attached.\n///\n/// Example matches A, va, fa\n/// \\code\n///   class A {};\n///   class B;  // Doesn't match, as it has no body.\n///   int va;\n///   extern int vb;  // Doesn't match, as it doesn't define the variable.\n///   void fa() {}\n///   void fb();  // Doesn't match, as it has no body.\n///   @interface X\n///   - (void)ma; // Doesn't match, interface is declaration.\n///   @end\n///   @implementation X\n///   - (void)ma {}\n///   @end\n/// \\endcode\n///\n/// Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,\n///   Matcher<ObjCMethodDecl>\nAST_POLYMORPHIC_MATCHER(isDefinition,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(TagDecl, VarDecl,\n                                                        ObjCMethodDecl,\n                                                        FunctionDecl)) {\n  return Node.isThisDeclarationADefinition();\n}\n\n/// Matches if a function declaration is variadic.\n///\n/// Example matches f, but not g or h. The function i will not match, even when\n/// compiled in C mode.\n/// \\code\n///   void f(...);\n///   void g(int);\n///   template <typename... Ts> void h(Ts...);\n///   void i();\n/// \\endcode\nAST_MATCHER(FunctionDecl, isVariadic) {\n  return Node.isVariadic();\n}\n\n/// Matches the class declaration that the given method declaration\n/// belongs to.\n///\n/// FIXME: Generalize this for other kinds of declarations.\n/// FIXME: What other kind of declarations would we need to generalize\n/// this to?\n///\n/// Example matches A() in the last line\n///     (matcher = cxxConstructExpr(hasDeclaration(cxxMethodDecl(\n///         ofClass(hasName(\"A\"))))))\n/// \\code\n///   class A {\n///    public:\n///     A();\n///   };\n///   A a = A();\n/// \\endcode\nAST_MATCHER_P(CXXMethodDecl, ofClass,\n              internal::Matcher<CXXRecordDecl>, InnerMatcher) {\n\n  ASTChildrenNotSpelledInSourceScope RAII(Finder, false);\n\n  const CXXRecordDecl *Parent = Node.getParent();\n  return (Parent != nullptr &&\n          InnerMatcher.matches(*Parent, Finder, Builder));\n}\n\n/// Matches each method overridden by the given method. This matcher may\n/// produce multiple matches.\n///\n/// Given\n/// \\code\n///   class A { virtual void f(); };\n///   class B : public A { void f(); };\n///   class C : public B { void f(); };\n/// \\endcode\n/// cxxMethodDecl(ofClass(hasName(\"C\")),\n///               forEachOverridden(cxxMethodDecl().bind(\"b\"))).bind(\"d\")\n///   matches once, with \"b\" binding \"A::f\" and \"d\" binding \"C::f\" (Note\n///   that B::f is not overridden by C::f).\n///\n/// The check can produce multiple matches in case of multiple inheritance, e.g.\n/// \\code\n///   class A1 { virtual void f(); };\n///   class A2 { virtual void f(); };\n///   class C : public A1, public A2 { void f(); };\n/// \\endcode\n/// cxxMethodDecl(ofClass(hasName(\"C\")),\n///               forEachOverridden(cxxMethodDecl().bind(\"b\"))).bind(\"d\")\n///   matches twice, once with \"b\" binding \"A1::f\" and \"d\" binding \"C::f\", and\n///   once with \"b\" binding \"A2::f\" and \"d\" binding \"C::f\".\nAST_MATCHER_P(CXXMethodDecl, forEachOverridden,\n              internal::Matcher<CXXMethodDecl>, InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto *Overridden : Node.overridden_methods()) {\n    BoundNodesTreeBuilder OverriddenBuilder(*Builder);\n    const bool OverriddenMatched =\n        InnerMatcher.matches(*Overridden, Finder, &OverriddenBuilder);\n    if (OverriddenMatched) {\n      Matched = true;\n      Result.addMatch(OverriddenBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches declarations of virtual methods and C++ base specifers that specify\n/// virtual inheritance.\n///\n/// Example:\n/// \\code\n///   class A {\n///    public:\n///     virtual void x(); // matches x\n///   };\n/// \\endcode\n///\n/// Example:\n/// \\code\n///   class Base {};\n///   class DirectlyDerived : virtual Base {}; // matches Base\n///   class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base\n/// \\endcode\n///\n/// Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>\nAST_POLYMORPHIC_MATCHER(isVirtual,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(CXXMethodDecl,\n                                                        CXXBaseSpecifier)) {\n  return Node.isVirtual();\n}\n\n/// Matches if the given method declaration has an explicit \"virtual\".\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x();\n///   };\n///   class B : public A {\n///    public:\n///     void x();\n///   };\n/// \\endcode\n///   matches A::x but not B::x\nAST_MATCHER(CXXMethodDecl, isVirtualAsWritten) {\n  return Node.isVirtualAsWritten();\n}\n\n/// Matches if the given method or class declaration is final.\n///\n/// Given:\n/// \\code\n///   class A final {};\n///\n///   struct B {\n///     virtual void f();\n///   };\n///\n///   struct C : B {\n///     void f() final;\n///   };\n/// \\endcode\n/// matches A and C::f, but not B, C, or B::f\nAST_POLYMORPHIC_MATCHER(isFinal,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl,\n                                                        CXXMethodDecl)) {\n  return Node.template hasAttr<FinalAttr>();\n}\n\n/// Matches if the given method declaration is pure.\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x() = 0;\n///   };\n/// \\endcode\n///   matches A::x\nAST_MATCHER(CXXMethodDecl, isPure) {\n  return Node.isPure();\n}\n\n/// Matches if the given method declaration is const.\n///\n/// Given\n/// \\code\n/// struct A {\n///   void foo() const;\n///   void bar();\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isConst()) matches A::foo() but not A::bar()\nAST_MATCHER(CXXMethodDecl, isConst) {\n  return Node.isConst();\n}\n\n/// Matches if the given method declaration declares a copy assignment\n/// operator.\n///\n/// Given\n/// \\code\n/// struct A {\n///   A &operator=(const A &);\n///   A &operator=(A &&);\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isCopyAssignmentOperator()) matches the first method but not\n/// the second one.\nAST_MATCHER(CXXMethodDecl, isCopyAssignmentOperator) {\n  return Node.isCopyAssignmentOperator();\n}\n\n/// Matches if the given method declaration declares a move assignment\n/// operator.\n///\n/// Given\n/// \\code\n/// struct A {\n///   A &operator=(const A &);\n///   A &operator=(A &&);\n/// };\n/// \\endcode\n///\n/// cxxMethodDecl(isMoveAssignmentOperator()) matches the second method but not\n/// the first one.\nAST_MATCHER(CXXMethodDecl, isMoveAssignmentOperator) {\n  return Node.isMoveAssignmentOperator();\n}\n\n/// Matches if the given method declaration overrides another method.\n///\n/// Given\n/// \\code\n///   class A {\n///    public:\n///     virtual void x();\n///   };\n///   class B : public A {\n///    public:\n///     virtual void x();\n///   };\n/// \\endcode\n///   matches B::x\nAST_MATCHER(CXXMethodDecl, isOverride) {\n  return Node.size_overridden_methods() > 0 || Node.hasAttr<OverrideAttr>();\n}\n\n/// Matches method declarations that are user-provided.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &) = default; // #2\n///     S(S &&) = delete; // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3.\nAST_MATCHER(CXXMethodDecl, isUserProvided) {\n  return Node.isUserProvided();\n}\n\n/// Matches member expressions that are called with '->' as opposed\n/// to '.'.\n///\n/// Member calls on the implicit this pointer match as called with '->'.\n///\n/// Given\n/// \\code\n///   class Y {\n///     void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }\n///     template <class T> void f() { this->f<T>(); f<T>(); }\n///     int a;\n///     static int b;\n///   };\n///   template <class T>\n///   class Z {\n///     void x() { this->m; }\n///   };\n/// \\endcode\n/// memberExpr(isArrow())\n///   matches this->x, x, y.x, a, this->b\n/// cxxDependentScopeMemberExpr(isArrow())\n///   matches this->m\n/// unresolvedMemberExpr(isArrow())\n///   matches this->f<T>, f<T>\nAST_POLYMORPHIC_MATCHER(\n    isArrow, AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,\n                                             CXXDependentScopeMemberExpr)) {\n  return Node.isArrow();\n}\n\n/// Matches QualType nodes that are of integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isInteger())))\n/// matches \"a(int)\", \"b(long)\", but not \"c(double)\".\nAST_MATCHER(QualType, isInteger) {\n    return Node->isIntegerType();\n}\n\n/// Matches QualType nodes that are of unsigned integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(unsigned long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isUnsignedInteger())))\n/// matches \"b(unsigned long)\", but not \"a(int)\" and \"c(double)\".\nAST_MATCHER(QualType, isUnsignedInteger) {\n    return Node->isUnsignedIntegerType();\n}\n\n/// Matches QualType nodes that are of signed integer type.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(unsigned long);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isSignedInteger())))\n/// matches \"a(int)\", but not \"b(unsigned long)\" and \"c(double)\".\nAST_MATCHER(QualType, isSignedInteger) {\n    return Node->isSignedIntegerType();\n}\n\n/// Matches QualType nodes that are of character type.\n///\n/// Given\n/// \\code\n///   void a(char);\n///   void b(wchar_t);\n///   void c(double);\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isAnyCharacter())))\n/// matches \"a(char)\", \"b(wchar_t)\", but not \"c(double)\".\nAST_MATCHER(QualType, isAnyCharacter) {\n    return Node->isAnyCharacterType();\n}\n\n/// Matches QualType nodes that are of any pointer type; this includes\n/// the Objective-C object pointer type, which is different despite being\n/// syntactically similar.\n///\n/// Given\n/// \\code\n///   int *i = nullptr;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n///\n///   int j;\n/// \\endcode\n/// varDecl(hasType(isAnyPointer()))\n///   matches \"int *i\" and \"Foo *f\", but not \"int j\".\nAST_MATCHER(QualType, isAnyPointer) {\n  return Node->isAnyPointerType();\n}\n\n/// Matches QualType nodes that are const-qualified, i.e., that\n/// include \"top-level\" const.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(int const);\n///   void c(const int);\n///   void d(const int*);\n///   void e(int const) {};\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isConstQualified())))\n///   matches \"void b(int const)\", \"void c(const int)\" and\n///   \"void e(int const) {}\". It does not match d as there\n///   is no top-level const on the parameter type \"const int *\".\nAST_MATCHER(QualType, isConstQualified) {\n  return Node.isConstQualified();\n}\n\n/// Matches QualType nodes that are volatile-qualified, i.e., that\n/// include \"top-level\" volatile.\n///\n/// Given\n/// \\code\n///   void a(int);\n///   void b(int volatile);\n///   void c(volatile int);\n///   void d(volatile int*);\n///   void e(int volatile) {};\n/// \\endcode\n/// functionDecl(hasAnyParameter(hasType(isVolatileQualified())))\n///   matches \"void b(int volatile)\", \"void c(volatile int)\" and\n///   \"void e(int volatile) {}\". It does not match d as there\n///   is no top-level volatile on the parameter type \"volatile int *\".\nAST_MATCHER(QualType, isVolatileQualified) {\n  return Node.isVolatileQualified();\n}\n\n/// Matches QualType nodes that have local CV-qualifiers attached to\n/// the node, not hidden within a typedef.\n///\n/// Given\n/// \\code\n///   typedef const int const_int;\n///   const_int i;\n///   int *const j;\n///   int *volatile k;\n///   int m;\n/// \\endcode\n/// \\c varDecl(hasType(hasLocalQualifiers())) matches only \\c j and \\c k.\n/// \\c i is const-qualified but the qualifier is not local.\nAST_MATCHER(QualType, hasLocalQualifiers) {\n  return Node.hasLocalQualifiers();\n}\n\n/// Matches a member expression where the member is matched by a\n/// given matcher.\n///\n/// Given\n/// \\code\n///   struct { int first, second; } first, second;\n///   int i(second.first);\n///   int j(first.second);\n/// \\endcode\n/// memberExpr(member(hasName(\"first\")))\n///   matches second.first\n///   but not first.second (because the member name there is \"second\").\nAST_MATCHER_P(MemberExpr, member,\n              internal::Matcher<ValueDecl>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getMemberDecl(), Finder, Builder);\n}\n\n/// Matches a member expression where the object expression is matched by a\n/// given matcher. Implicit object expressions are included; that is, it matches\n/// use of implicit `this`.\n///\n/// Given\n/// \\code\n///   struct X {\n///     int m;\n///     int f(X x) { x.m; return m; }\n///   };\n/// \\endcode\n/// memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(\"X\")))))\n///   matches `x.m`, but not `m`; however,\n/// memberExpr(hasObjectExpression(hasType(pointsTo(\n//      cxxRecordDecl(hasName(\"X\"))))))\n///   matches `m` (aka. `this->m`), but not `x.m`.\nAST_POLYMORPHIC_MATCHER_P(\n    hasObjectExpression,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,\n                                    CXXDependentScopeMemberExpr),\n    internal::Matcher<Expr>, InnerMatcher) {\n  if (const auto *E = dyn_cast<UnresolvedMemberExpr>(&Node))\n    if (E->isImplicitAccess())\n      return false;\n  if (const auto *E = dyn_cast<CXXDependentScopeMemberExpr>(&Node))\n    if (E->isImplicitAccess())\n      return false;\n  return InnerMatcher.matches(*Node.getBase(), Finder, Builder);\n}\n\n/// Matches any using shadow declaration.\n///\n/// Given\n/// \\code\n///   namespace X { void b(); }\n///   using X::b;\n/// \\endcode\n/// usingDecl(hasAnyUsingShadowDecl(hasName(\"b\"))))\n///   matches \\code using X::b \\endcode\nAST_MATCHER_P(UsingDecl, hasAnyUsingShadowDecl,\n              internal::Matcher<UsingShadowDecl>, InnerMatcher) {\n  return matchesFirstInPointerRange(InnerMatcher, Node.shadow_begin(),\n                                    Node.shadow_end(), Finder,\n                                    Builder) != Node.shadow_end();\n}\n\n/// Matches a using shadow declaration where the target declaration is\n/// matched by the given matcher.\n///\n/// Given\n/// \\code\n///   namespace X { int a; void b(); }\n///   using X::a;\n///   using X::b;\n/// \\endcode\n/// usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl())))\n///   matches \\code using X::b \\endcode\n///   but not \\code using X::a \\endcode\nAST_MATCHER_P(UsingShadowDecl, hasTargetDecl,\n              internal::Matcher<NamedDecl>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getTargetDecl(), Finder, Builder);\n}\n\n/// Matches template instantiations of function, class, or static\n/// member variable template instantiations.\n///\n/// Given\n/// \\code\n///   template <typename T> class X {}; class A {}; X<A> x;\n/// \\endcode\n/// or\n/// \\code\n///   template <typename T> class X {}; class A {}; template class X<A>;\n/// \\endcode\n/// or\n/// \\code\n///   template <typename T> class X {}; class A {}; extern template class X<A>;\n/// \\endcode\n/// cxxRecordDecl(hasName(\"::X\"), isTemplateInstantiation())\n///   matches the template instantiation of X<A>.\n///\n/// But given\n/// \\code\n///   template <typename T>  class X {}; class A {};\n///   template <> class X<A> {}; X<A> x;\n/// \\endcode\n/// cxxRecordDecl(hasName(\"::X\"), isTemplateInstantiation())\n///   does not match, as X<A> is an explicit template specialization.\n///\n/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>\nAST_POLYMORPHIC_MATCHER(isTemplateInstantiation,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,\n                                                        CXXRecordDecl)) {\n  return (Node.getTemplateSpecializationKind() == TSK_ImplicitInstantiation ||\n          Node.getTemplateSpecializationKind() ==\n              TSK_ExplicitInstantiationDefinition ||\n          Node.getTemplateSpecializationKind() ==\n              TSK_ExplicitInstantiationDeclaration);\n}\n\n/// Matches declarations that are template instantiations or are inside\n/// template instantiations.\n///\n/// Given\n/// \\code\n///   template<typename T> void A(T t) { T i; }\n///   A(0);\n///   A(0U);\n/// \\endcode\n/// functionDecl(isInstantiated())\n///   matches 'A(int) {...};' and 'A(unsigned) {...}'.\nAST_MATCHER_FUNCTION(internal::Matcher<Decl>, isInstantiated) {\n  auto IsInstantiation = decl(anyOf(cxxRecordDecl(isTemplateInstantiation()),\n                                    functionDecl(isTemplateInstantiation())));\n  return decl(anyOf(IsInstantiation, hasAncestor(IsInstantiation)));\n}\n\n/// Matches statements inside of a template instantiation.\n///\n/// Given\n/// \\code\n///   int j;\n///   template<typename T> void A(T t) { T i; j += 42;}\n///   A(0);\n///   A(0U);\n/// \\endcode\n/// declStmt(isInTemplateInstantiation())\n///   matches 'int i;' and 'unsigned i'.\n/// unless(stmt(isInTemplateInstantiation()))\n///   will NOT match j += 42; as it's shared between the template definition and\n///   instantiation.\nAST_MATCHER_FUNCTION(internal::Matcher<Stmt>, isInTemplateInstantiation) {\n  return stmt(\n      hasAncestor(decl(anyOf(cxxRecordDecl(isTemplateInstantiation()),\n                             functionDecl(isTemplateInstantiation())))));\n}\n\n/// Matches explicit template specializations of function, class, or\n/// static member variable template instantiations.\n///\n/// Given\n/// \\code\n///   template<typename T> void A(T t) { }\n///   template<> void A(int N) { }\n/// \\endcode\n/// functionDecl(isExplicitTemplateSpecialization())\n///   matches the specialization A<int>().\n///\n/// Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>\nAST_POLYMORPHIC_MATCHER(isExplicitTemplateSpecialization,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,\n                                                        CXXRecordDecl)) {\n  return (Node.getTemplateSpecializationKind() == TSK_ExplicitSpecialization);\n}\n\n/// Matches \\c TypeLocs for which the given inner\n/// QualType-matcher matches.\nAST_MATCHER_FUNCTION_P_OVERLOAD(internal::BindableMatcher<TypeLoc>, loc,\n                                internal::Matcher<QualType>, InnerMatcher, 0) {\n  return internal::BindableMatcher<TypeLoc>(\n      new internal::TypeLocTypeMatcher(InnerMatcher));\n}\n\n/// Matches type \\c bool.\n///\n/// Given\n/// \\code\n///  struct S { bool func(); };\n/// \\endcode\n/// functionDecl(returns(booleanType()))\n///   matches \"bool func();\"\nAST_MATCHER(Type, booleanType) {\n  return Node.isBooleanType();\n}\n\n/// Matches type \\c void.\n///\n/// Given\n/// \\code\n///  struct S { void func(); };\n/// \\endcode\n/// functionDecl(returns(voidType()))\n///   matches \"void func();\"\nAST_MATCHER(Type, voidType) {\n  return Node.isVoidType();\n}\n\ntemplate <typename NodeType>\nusing AstTypeMatcher = internal::VariadicDynCastAllOfMatcher<Type, NodeType>;\n\n/// Matches builtin Types.\n///\n/// Given\n/// \\code\n///   struct A {};\n///   A a;\n///   int b;\n///   float c;\n///   bool d;\n/// \\endcode\n/// builtinType()\n///   matches \"int b\", \"float c\" and \"bool d\"\nextern const AstTypeMatcher<BuiltinType> builtinType;\n\n/// Matches all kinds of arrays.\n///\n/// Given\n/// \\code\n///   int a[] = { 2, 3 };\n///   int b[4];\n///   void f() { int c[a[0]]; }\n/// \\endcode\n/// arrayType()\n///   matches \"int a[]\", \"int b[4]\" and \"int c[a[0]]\";\nextern const AstTypeMatcher<ArrayType> arrayType;\n\n/// Matches C99 complex types.\n///\n/// Given\n/// \\code\n///   _Complex float f;\n/// \\endcode\n/// complexType()\n///   matches \"_Complex float f\"\nextern const AstTypeMatcher<ComplexType> complexType;\n\n/// Matches any real floating-point type (float, double, long double).\n///\n/// Given\n/// \\code\n///   int i;\n///   float f;\n/// \\endcode\n/// realFloatingPointType()\n///   matches \"float f\" but not \"int i\"\nAST_MATCHER(Type, realFloatingPointType) {\n  return Node.isRealFloatingType();\n}\n\n/// Matches arrays and C99 complex types that have a specific element\n/// type.\n///\n/// Given\n/// \\code\n///   struct A {};\n///   A a[7];\n///   int b[7];\n/// \\endcode\n/// arrayType(hasElementType(builtinType()))\n///   matches \"int b[7]\"\n///\n/// Usable as: Matcher<ArrayType>, Matcher<ComplexType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(hasElementType, getElement,\n                                  AST_POLYMORPHIC_SUPPORTED_TYPES(ArrayType,\n                                                                  ComplexType));\n\n/// Matches C arrays with a specified constant size.\n///\n/// Given\n/// \\code\n///   void() {\n///     int a[2];\n///     int b[] = { 2, 3 };\n///     int c[b[0]];\n///   }\n/// \\endcode\n/// constantArrayType()\n///   matches \"int a[2]\"\nextern const AstTypeMatcher<ConstantArrayType> constantArrayType;\n\n/// Matches nodes that have the specified size.\n///\n/// Given\n/// \\code\n///   int a[42];\n///   int b[2 * 21];\n///   int c[41], d[43];\n///   char *s = \"abcd\";\n///   wchar_t *ws = L\"abcd\";\n///   char *w = \"a\";\n/// \\endcode\n/// constantArrayType(hasSize(42))\n///   matches \"int a[42]\" and \"int b[2 * 21]\"\n/// stringLiteral(hasSize(4))\n///   matches \"abcd\", L\"abcd\"\nAST_POLYMORPHIC_MATCHER_P(hasSize,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(ConstantArrayType,\n                                                          StringLiteral),\n                          unsigned, N) {\n  return internal::HasSizeMatcher<NodeType>::hasSize(Node, N);\n}\n\n/// Matches C++ arrays whose size is a value-dependent expression.\n///\n/// Given\n/// \\code\n///   template<typename T, int Size>\n///   class array {\n///     T data[Size];\n///   };\n/// \\endcode\n/// dependentSizedArrayType\n///   matches \"T data[Size]\"\nextern const AstTypeMatcher<DependentSizedArrayType> dependentSizedArrayType;\n\n/// Matches C arrays with unspecified size.\n///\n/// Given\n/// \\code\n///   int a[] = { 2, 3 };\n///   int b[42];\n///   void f(int c[]) { int d[a[0]]; };\n/// \\endcode\n/// incompleteArrayType()\n///   matches \"int a[]\" and \"int c[]\"\nextern const AstTypeMatcher<IncompleteArrayType> incompleteArrayType;\n\n/// Matches C arrays with a specified size that is not an\n/// integer-constant-expression.\n///\n/// Given\n/// \\code\n///   void f() {\n///     int a[] = { 2, 3 }\n///     int b[42];\n///     int c[a[0]];\n///   }\n/// \\endcode\n/// variableArrayType()\n///   matches \"int c[a[0]]\"\nextern const AstTypeMatcher<VariableArrayType> variableArrayType;\n\n/// Matches \\c VariableArrayType nodes that have a specific size\n/// expression.\n///\n/// Given\n/// \\code\n///   void f(int b) {\n///     int a[b];\n///   }\n/// \\endcode\n/// variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to(\n///   varDecl(hasName(\"b\")))))))\n///   matches \"int a[b]\"\nAST_MATCHER_P(VariableArrayType, hasSizeExpr,\n              internal::Matcher<Expr>, InnerMatcher) {\n  return InnerMatcher.matches(*Node.getSizeExpr(), Finder, Builder);\n}\n\n/// Matches atomic types.\n///\n/// Given\n/// \\code\n///   _Atomic(int) i;\n/// \\endcode\n/// atomicType()\n///   matches \"_Atomic(int) i\"\nextern const AstTypeMatcher<AtomicType> atomicType;\n\n/// Matches atomic types with a specific value type.\n///\n/// Given\n/// \\code\n///   _Atomic(int) i;\n///   _Atomic(float) f;\n/// \\endcode\n/// atomicType(hasValueType(isInteger()))\n///  matches \"_Atomic(int) i\"\n///\n/// Usable as: Matcher<AtomicType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(hasValueType, getValue,\n                                  AST_POLYMORPHIC_SUPPORTED_TYPES(AtomicType));\n\n/// Matches types nodes representing C++11 auto types.\n///\n/// Given:\n/// \\code\n///   auto n = 4;\n///   int v[] = { 2, 3 }\n///   for (auto i : v) { }\n/// \\endcode\n/// autoType()\n///   matches \"auto n\" and \"auto i\"\nextern const AstTypeMatcher<AutoType> autoType;\n\n/// Matches types nodes representing C++11 decltype(<expr>) types.\n///\n/// Given:\n/// \\code\n///   short i = 1;\n///   int j = 42;\n///   decltype(i + j) result = i + j;\n/// \\endcode\n/// decltypeType()\n///   matches \"decltype(i + j)\"\nextern const AstTypeMatcher<DecltypeType> decltypeType;\n\n/// Matches \\c AutoType nodes where the deduced type is a specific type.\n///\n/// Note: There is no \\c TypeLoc for the deduced type and thus no\n/// \\c getDeducedLoc() matcher.\n///\n/// Given\n/// \\code\n///   auto a = 1;\n///   auto b = 2.0;\n/// \\endcode\n/// autoType(hasDeducedType(isInteger()))\n///   matches \"auto a\"\n///\n/// Usable as: Matcher<AutoType>\nAST_TYPE_TRAVERSE_MATCHER(hasDeducedType, getDeducedType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(AutoType));\n\n/// Matches \\c DecltypeType nodes to find out the underlying type.\n///\n/// Given\n/// \\code\n///   decltype(1) a = 1;\n///   decltype(2.0) b = 2.0;\n/// \\endcode\n/// decltypeType(hasUnderlyingType(isInteger()))\n///   matches the type of \"a\"\n///\n/// Usable as: Matcher<DecltypeType>\nAST_TYPE_TRAVERSE_MATCHER(hasUnderlyingType, getUnderlyingType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(DecltypeType));\n\n/// Matches \\c FunctionType nodes.\n///\n/// Given\n/// \\code\n///   int (*f)(int);\n///   void g();\n/// \\endcode\n/// functionType()\n///   matches \"int (*f)(int)\" and the type of \"g\".\nextern const AstTypeMatcher<FunctionType> functionType;\n\n/// Matches \\c FunctionProtoType nodes.\n///\n/// Given\n/// \\code\n///   int (*f)(int);\n///   void g();\n/// \\endcode\n/// functionProtoType()\n///   matches \"int (*f)(int)\" and the type of \"g\" in C++ mode.\n///   In C mode, \"g\" is not matched because it does not contain a prototype.\nextern const AstTypeMatcher<FunctionProtoType> functionProtoType;\n\n/// Matches \\c ParenType nodes.\n///\n/// Given\n/// \\code\n///   int (*ptr_to_array)[4];\n///   int *array_of_ptrs[4];\n/// \\endcode\n///\n/// \\c varDecl(hasType(pointsTo(parenType()))) matches \\c ptr_to_array but not\n/// \\c array_of_ptrs.\nextern const AstTypeMatcher<ParenType> parenType;\n\n/// Matches \\c ParenType nodes where the inner type is a specific type.\n///\n/// Given\n/// \\code\n///   int (*ptr_to_array)[4];\n///   int (*ptr_to_func)(int);\n/// \\endcode\n///\n/// \\c varDecl(hasType(pointsTo(parenType(innerType(functionType()))))) matches\n/// \\c ptr_to_func but not \\c ptr_to_array.\n///\n/// Usable as: Matcher<ParenType>\nAST_TYPE_TRAVERSE_MATCHER(innerType, getInnerType,\n                          AST_POLYMORPHIC_SUPPORTED_TYPES(ParenType));\n\n/// Matches block pointer types, i.e. types syntactically represented as\n/// \"void (^)(int)\".\n///\n/// The \\c pointee is always required to be a \\c FunctionType.\nextern const AstTypeMatcher<BlockPointerType> blockPointerType;\n\n/// Matches member pointer types.\n/// Given\n/// \\code\n///   struct A { int i; }\n///   A::* ptr = A::i;\n/// \\endcode\n/// memberPointerType()\n///   matches \"A::* ptr\"\nextern const AstTypeMatcher<MemberPointerType> memberPointerType;\n\n/// Matches pointer types, but does not match Objective-C object pointer\n/// types.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int c = 5;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n/// \\endcode\n/// pointerType()\n///   matches \"int *a\", but does not match \"Foo *f\".\nextern const AstTypeMatcher<PointerType> pointerType;\n\n/// Matches an Objective-C object pointer type, which is different from\n/// a pointer type, despite being syntactically similar.\n///\n/// Given\n/// \\code\n///   int *a;\n///\n///   @interface Foo\n///   @end\n///   Foo *f;\n/// \\endcode\n/// pointerType()\n///   matches \"Foo *f\", but does not match \"int *a\".\nextern const AstTypeMatcher<ObjCObjectPointerType> objcObjectPointerType;\n\n/// Matches both lvalue and rvalue reference types.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c referenceType() matches the types of \\c b, \\c c, \\c d, \\c e, and \\c f.\nextern const AstTypeMatcher<ReferenceType> referenceType;\n\n/// Matches lvalue reference types.\n///\n/// Given:\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c lValueReferenceType() matches the types of \\c b, \\c d, and \\c e. \\c e is\n/// matched since the type is deduced as int& by reference collapsing rules.\nextern const AstTypeMatcher<LValueReferenceType> lValueReferenceType;\n\n/// Matches rvalue reference types.\n///\n/// Given:\n/// \\code\n///   int *a;\n///   int &b = *a;\n///   int &&c = 1;\n///   auto &d = b;\n///   auto &&e = c;\n///   auto &&f = 2;\n///   int g = 5;\n/// \\endcode\n///\n/// \\c rValueReferenceType() matches the types of \\c c and \\c f. \\c e is not\n/// matched as it is deduced to int& by reference collapsing rules.\nextern const AstTypeMatcher<RValueReferenceType> rValueReferenceType;\n\n/// Narrows PointerType (and similar) matchers to those where the\n/// \\c pointee matches a given matcher.\n///\n/// Given\n/// \\code\n///   int *a;\n///   int const *b;\n///   float const *f;\n/// \\endcode\n/// pointerType(pointee(isConstQualified(), isInteger()))\n///   matches \"int const *b\"\n///\n/// Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,\n///   Matcher<PointerType>, Matcher<ReferenceType>\nAST_TYPELOC_TRAVERSE_MATCHER_DECL(\n    pointee, getPointee,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(BlockPointerType, MemberPointerType,\n                                    PointerType, ReferenceType));\n\n/// Matches typedef types.\n///\n/// Given\n/// \\code\n///   typedef int X;\n/// \\endcode\n/// typedefType()\n///   matches \"typedef int X\"\nextern const AstTypeMatcher<TypedefType> typedefType;\n\n/// Matches enum types.\n///\n/// Given\n/// \\code\n///   enum C { Green };\n///   enum class S { Red };\n///\n///   C c;\n///   S s;\n/// \\endcode\n//\n/// \\c enumType() matches the type of the variable declarations of both \\c c and\n/// \\c s.\nextern const AstTypeMatcher<EnumType> enumType;\n\n/// Matches template specialization types.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C { };\n///\n///   template class C<int>;  // A\n///   C<char> var;            // B\n/// \\endcode\n///\n/// \\c templateSpecializationType() matches the type of the explicit\n/// instantiation in \\c A and the type of the variable declaration in \\c B.\nextern const AstTypeMatcher<TemplateSpecializationType>\n    templateSpecializationType;\n\n/// Matches C++17 deduced template specialization types, e.g. deduced class\n/// template types.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   class C { public: C(T); };\n///\n///   C c(123);\n/// \\endcode\n/// \\c deducedTemplateSpecializationType() matches the type in the declaration\n/// of the variable \\c c.\nextern const AstTypeMatcher<DeducedTemplateSpecializationType>\n    deducedTemplateSpecializationType;\n\n/// Matches types nodes representing unary type transformations.\n///\n/// Given:\n/// \\code\n///   typedef __underlying_type(T) type;\n/// \\endcode\n/// unaryTransformType()\n///   matches \"__underlying_type(T)\"\nextern const AstTypeMatcher<UnaryTransformType> unaryTransformType;\n\n/// Matches record types (e.g. structs, classes).\n///\n/// Given\n/// \\code\n///   class C {};\n///   struct S {};\n///\n///   C c;\n///   S s;\n/// \\endcode\n///\n/// \\c recordType() matches the type of the variable declarations of both \\c c\n/// and \\c s.\nextern const AstTypeMatcher<RecordType> recordType;\n\n/// Matches tag types (record and enum types).\n///\n/// Given\n/// \\code\n///   enum E {};\n///   class C {};\n///\n///   E e;\n///   C c;\n/// \\endcode\n///\n/// \\c tagType() matches the type of the variable declarations of both \\c e\n/// and \\c c.\nextern const AstTypeMatcher<TagType> tagType;\n\n/// Matches types specified with an elaborated type keyword or with a\n/// qualified name.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   class C {};\n///\n///   class C c;\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType() matches the type of the variable declarations of both\n/// \\c c and \\c d.\nextern const AstTypeMatcher<ElaboratedType> elaboratedType;\n\n/// Matches ElaboratedTypes whose qualifier, a NestedNameSpecifier,\n/// matches \\c InnerMatcher if the qualifier exists.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType(hasQualifier(hasPrefix(specifiesNamespace(hasName(\"N\"))))\n/// matches the type of the variable declaration of \\c d.\nAST_MATCHER_P(ElaboratedType, hasQualifier,\n              internal::Matcher<NestedNameSpecifier>, InnerMatcher) {\n  if (const NestedNameSpecifier *Qualifier = Node.getQualifier())\n    return InnerMatcher.matches(*Qualifier, Finder, Builder);\n\n  return false;\n}\n\n/// Matches ElaboratedTypes whose named type matches \\c InnerMatcher.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n///   N::M::D d;\n/// \\endcode\n///\n/// \\c elaboratedType(namesType(recordType(\n/// hasDeclaration(namedDecl(hasName(\"D\")))))) matches the type of the variable\n/// declaration of \\c d.\nAST_MATCHER_P(ElaboratedType, namesType, internal::Matcher<QualType>,\n              InnerMatcher) {\n  return InnerMatcher.matches(Node.getNamedType(), Finder, Builder);\n}\n\n/// Matches types that represent the result of substituting a type for a\n/// template type parameter.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   void F(T t) {\n///     int i = 1 + t;\n///   }\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType() matches the type of 't' but not '1'\nextern const AstTypeMatcher<SubstTemplateTypeParmType>\n    substTemplateTypeParmType;\n\n/// Matches template type parameter substitutions that have a replacement\n/// type that matches the provided matcher.\n///\n/// Given\n/// \\code\n///   template <typename T>\n///   double F(T t);\n///   int i;\n///   double j = F(i);\n/// \\endcode\n///\n/// \\c substTemplateTypeParmType(hasReplacementType(type())) matches int\nAST_TYPE_TRAVERSE_MATCHER(\n    hasReplacementType, getReplacementType,\n    AST_POLYMORPHIC_SUPPORTED_TYPES(SubstTemplateTypeParmType));\n\n/// Matches template type parameter types.\n///\n/// Example matches T, but not int.\n///     (matcher = templateTypeParmType())\n/// \\code\n///   template <typename T> void f(int i);\n/// \\endcode\nextern const AstTypeMatcher<TemplateTypeParmType> templateTypeParmType;\n\n/// Matches injected class name types.\n///\n/// Example matches S s, but not S<T> s.\n///     (matcher = parmVarDecl(hasType(injectedClassNameType())))\n/// \\code\n///   template <typename T> struct S {\n///     void f(S s);\n///     void g(S<T> s);\n///   };\n/// \\endcode\nextern const AstTypeMatcher<InjectedClassNameType> injectedClassNameType;\n\n/// Matches decayed type\n/// Example matches i[] in declaration of f.\n///     (matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType())))))\n/// Example matches i[1].\n///     (matcher = expr(hasType(decayedType(hasDecayedType(pointerType())))))\n/// \\code\n///   void f(int i[]) {\n///     i[1] = 0;\n///   }\n/// \\endcode\nextern const AstTypeMatcher<DecayedType> decayedType;\n\n/// Matches the decayed type, whoes decayed type matches \\c InnerMatcher\nAST_MATCHER_P(DecayedType, hasDecayedType, internal::Matcher<QualType>,\n              InnerType) {\n  return InnerType.matches(Node.getDecayedType(), Finder, Builder);\n}\n\n/// Matches declarations whose declaration context, interpreted as a\n/// Decl, matches \\c InnerMatcher.\n///\n/// Given\n/// \\code\n///   namespace N {\n///     namespace M {\n///       class D {};\n///     }\n///   }\n/// \\endcode\n///\n/// \\c cxxRcordDecl(hasDeclContext(namedDecl(hasName(\"M\")))) matches the\n/// declaration of \\c class \\c D.\nAST_MATCHER_P(Decl, hasDeclContext, internal::Matcher<Decl>, InnerMatcher) {\n  const DeclContext *DC = Node.getDeclContext();\n  if (!DC) return false;\n  return InnerMatcher.matches(*Decl::castFromDeclContext(DC), Finder, Builder);\n}\n\n/// Matches nested name specifiers.\n///\n/// Given\n/// \\code\n///   namespace ns {\n///     struct A { static void f(); };\n///     void A::f() {}\n///     void g() { A::f(); }\n///   }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier()\n///   matches \"ns::\" and both \"A::\"\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifier>\n    nestedNameSpecifier;\n\n/// Same as \\c nestedNameSpecifier but matches \\c NestedNameSpecifierLoc.\nextern const internal::VariadicAllOfMatcher<NestedNameSpecifierLoc>\n    nestedNameSpecifierLoc;\n\n/// Matches \\c NestedNameSpecifierLocs for which the given inner\n/// NestedNameSpecifier-matcher matches.\nAST_MATCHER_FUNCTION_P_OVERLOAD(\n    internal::BindableMatcher<NestedNameSpecifierLoc>, loc,\n    internal::Matcher<NestedNameSpecifier>, InnerMatcher, 1) {\n  return internal::BindableMatcher<NestedNameSpecifierLoc>(\n      new internal::LocMatcher<NestedNameSpecifierLoc, NestedNameSpecifier>(\n          InnerMatcher));\n}\n\n/// Matches nested name specifiers that specify a type matching the\n/// given \\c QualType matcher without qualifiers.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(specifiesType(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))\n/// ))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesType,\n              internal::Matcher<QualType>, InnerMatcher) {\n  if (!Node.getAsType())\n    return false;\n  return InnerMatcher.matches(QualType(Node.getAsType(), 0), Finder, Builder);\n}\n\n/// Matches nested name specifier locs that specify a type matching the\n/// given \\c TypeLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(specifiesTypeLoc(loc(type(\n///   hasDeclaration(cxxRecordDecl(hasName(\"A\")))))))\n///   matches \"A::\"\nAST_MATCHER_P(NestedNameSpecifierLoc, specifiesTypeLoc,\n              internal::Matcher<TypeLoc>, InnerMatcher) {\n  return Node && Node.getNestedNameSpecifier()->getAsType() &&\n         InnerMatcher.matches(Node.getTypeLoc(), Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifier.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifier(hasPrefix(specifiesType(asString(\"struct A\")))) and\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifier, hasPrefix,\n                       internal::Matcher<NestedNameSpecifier>, InnerMatcher,\n                       0) {\n  const NestedNameSpecifier *NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(*NextNode, Finder, Builder);\n}\n\n/// Matches on the prefix of a \\c NestedNameSpecifierLoc.\n///\n/// Given\n/// \\code\n///   struct A { struct B { struct C {}; }; };\n///   A::B::C c;\n/// \\endcode\n/// nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString(\"struct A\")))))\n///   matches \"A::\"\nAST_MATCHER_P_OVERLOAD(NestedNameSpecifierLoc, hasPrefix,\n                       internal::Matcher<NestedNameSpecifierLoc>, InnerMatcher,\n                       1) {\n  NestedNameSpecifierLoc NextNode = Node.getPrefix();\n  if (!NextNode)\n    return false;\n  return InnerMatcher.matches(NextNode, Finder, Builder);\n}\n\n/// Matches nested name specifiers that specify a namespace matching the\n/// given namespace matcher.\n///\n/// Given\n/// \\code\n///   namespace ns { struct A {}; }\n///   ns::A a;\n/// \\endcode\n/// nestedNameSpecifier(specifiesNamespace(hasName(\"ns\")))\n///   matches \"ns::\"\nAST_MATCHER_P(NestedNameSpecifier, specifiesNamespace,\n              internal::Matcher<NamespaceDecl>, InnerMatcher) {\n  if (!Node.getAsNamespace())\n    return false;\n  return InnerMatcher.matches(*Node.getAsNamespace(), Finder, Builder);\n}\n\n/// Overloads for the \\c equalsNode matcher.\n/// FIXME: Implement for other node types.\n/// @{\n\n/// Matches if a node equals another node.\n///\n/// \\c Decl has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Decl, equalsNode, const Decl*, Other, 0) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Stmt has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Stmt, equalsNode, const Stmt*, Other, 1) {\n  return &Node == Other;\n}\n/// Matches if a node equals another node.\n///\n/// \\c Type has pointer identity in the AST.\nAST_MATCHER_P_OVERLOAD(Type, equalsNode, const Type*, Other, 2) {\n    return &Node == Other;\n}\n\n/// @}\n\n/// Matches each case or default statement belonging to the given switch\n/// statement. This matcher may produce multiple matches.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 2: default: switch (2) { case 3: case 4: ; } }\n/// \\endcode\n/// switchStmt(forEachSwitchCase(caseStmt().bind(\"c\"))).bind(\"s\")\n///   matches four times, with \"c\" binding each of \"case 1:\", \"case 2:\",\n/// \"case 3:\" and \"case 4:\", and \"s\" respectively binding \"switch (1)\",\n/// \"switch (1)\", \"switch (2)\" and \"switch (2)\".\nAST_MATCHER_P(SwitchStmt, forEachSwitchCase, internal::Matcher<SwitchCase>,\n              InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  // FIXME: getSwitchCaseList() does not necessarily guarantee a stable\n  // iteration order. We should use the more general iterating matchers once\n  // they are capable of expressing this matcher (for example, it should ignore\n  // case statements belonging to nested switch statements).\n  bool Matched = false;\n  for (const SwitchCase *SC = Node.getSwitchCaseList(); SC;\n       SC = SC->getNextSwitchCase()) {\n    BoundNodesTreeBuilder CaseBuilder(*Builder);\n    bool CaseMatched = InnerMatcher.matches(*SC, Finder, &CaseBuilder);\n    if (CaseMatched) {\n      Matched = true;\n      Result.addMatch(CaseBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches each constructor initializer in a constructor definition.\n///\n/// Given\n/// \\code\n///   class A { A() : i(42), j(42) {} int i; int j; };\n/// \\endcode\n/// cxxConstructorDecl(forEachConstructorInitializer(\n///   forField(decl().bind(\"x\"))\n/// ))\n///   will trigger two matches, binding for 'i' and 'j' respectively.\nAST_MATCHER_P(CXXConstructorDecl, forEachConstructorInitializer,\n              internal::Matcher<CXXCtorInitializer>, InnerMatcher) {\n  BoundNodesTreeBuilder Result;\n  bool Matched = false;\n  for (const auto *I : Node.inits()) {\n    if (Finder->isTraversalIgnoringImplicitNodes() && !I->isWritten())\n      continue;\n    BoundNodesTreeBuilder InitBuilder(*Builder);\n    if (InnerMatcher.matches(*I, Finder, &InitBuilder)) {\n      Matched = true;\n      Result.addMatch(InitBuilder);\n    }\n  }\n  *Builder = std::move(Result);\n  return Matched;\n}\n\n/// Matches constructor declarations that are copy constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3.\nAST_MATCHER(CXXConstructorDecl, isCopyConstructor) {\n  return Node.isCopyConstructor();\n}\n\n/// Matches constructor declarations that are move constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isMoveConstructor) {\n  return Node.isMoveConstructor();\n}\n\n/// Matches constructor declarations that are default constructors.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(const S &); // #2\n///     S(S &&); // #3\n///   };\n/// \\endcode\n/// cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3.\nAST_MATCHER(CXXConstructorDecl, isDefaultConstructor) {\n  return Node.isDefaultConstructor();\n}\n\n/// Matches constructors that delegate to another constructor.\n///\n/// Given\n/// \\code\n///   struct S {\n///     S(); // #1\n///     S(int) {} // #2\n///     S(S &&) : S() {} // #3\n///   };\n///   S::S() : S(0) {} // #4\n/// \\endcode\n/// cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not\n/// #1 or #2.\nAST_MATCHER(CXXConstructorDecl, isDelegatingConstructor) {\n  return Node.isDelegatingConstructor();\n}\n\n/// Matches constructor, conversion function, and deduction guide declarations\n/// that have an explicit specifier if this explicit specifier is resolved to\n/// true.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.\n/// cxxConversionDecl(isExplicit()) will match #4, but not #3.\n/// cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5.\nAST_POLYMORPHIC_MATCHER(isExplicit, AST_POLYMORPHIC_SUPPORTED_TYPES(\n                                        CXXConstructorDecl, CXXConversionDecl,\n                                        CXXDeductionGuideDecl)) {\n  return Node.isExplicit();\n}\n\n/// Matches the expression in an explicit specifier if present in the given\n/// declaration.\n///\n/// Given\n/// \\code\n///   template<bool b>\n///   struct S {\n///     S(int); // #1\n///     explicit S(double); // #2\n///     operator int(); // #3\n///     explicit operator bool(); // #4\n///     explicit(false) S(bool) // # 7\n///     explicit(true) S(char) // # 8\n///     explicit(b) S(S) // # 9\n///   };\n///   S(int) -> S<true> // #5\n///   explicit S(double) -> S<false> // #6\n/// \\endcode\n/// cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2.\n/// cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4.\n/// cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6.\nAST_MATCHER_P(FunctionDecl, hasExplicitSpecifier, internal::Matcher<Expr>,\n              InnerMatcher) {\n  ExplicitSpecifier ES = ExplicitSpecifier::getFromDecl(&Node);\n  if (!ES.getExpr())\n    return false;\n\n  ASTChildrenNotSpelledInSourceScope RAII(Finder, false);\n\n  return InnerMatcher.matches(*ES.getExpr(), Finder, Builder);\n}\n\n/// Matches function and namespace declarations that are marked with\n/// the inline keyword.\n///\n/// Given\n/// \\code\n///   inline void f();\n///   void g();\n///   namespace n {\n///   inline namespace m {}\n///   }\n/// \\endcode\n/// functionDecl(isInline()) will match ::f().\n/// namespaceDecl(isInline()) will match n::m.\nAST_POLYMORPHIC_MATCHER(isInline,\n                        AST_POLYMORPHIC_SUPPORTED_TYPES(NamespaceDecl,\n                                                        FunctionDecl)) {\n  // This is required because the spelling of the function used to determine\n  // whether inline is specified or not differs between the polymorphic types.\n  if (const auto *FD = dyn_cast<FunctionDecl>(&Node))\n    return FD->isInlineSpecified();\n  else if (const auto *NSD = dyn_cast<NamespaceDecl>(&Node))\n    return NSD->isInline();\n  llvm_unreachable(\"Not a valid polymorphic type\");\n}\n\n/// Matches anonymous namespace declarations.\n///\n/// Given\n/// \\code\n///   namespace n {\n///   namespace {} // #1\n///   }\n/// \\endcode\n/// namespaceDecl(isAnonymous()) will match #1 but not ::n.\nAST_MATCHER(NamespaceDecl, isAnonymous) {\n  return Node.isAnonymousNamespace();\n}\n\n/// Matches declarations in the namespace `std`, but not in nested namespaces.\n///\n/// Given\n/// \\code\n///   class vector {};\n///   namespace foo {\n///     class vector {};\n///     namespace std {\n///       class vector {};\n///     }\n///   }\n///   namespace std {\n///     inline namespace __1 {\n///       class vector {}; // #1\n///       namespace experimental {\n///         class vector {};\n///       }\n///     }\n///   }\n/// \\endcode\n/// cxxRecordDecl(hasName(\"vector\"), isInStdNamespace()) will match only #1.\nAST_MATCHER(Decl, isInStdNamespace) { return Node.isInStdNamespace(); }\n\n/// If the given case statement does not use the GNU case range\n/// extension, matches the constant given in the statement.\n///\n/// Given\n/// \\code\n///   switch (1) { case 1: case 1+1: case 3 ... 4: ; }\n/// \\endcode\n/// caseStmt(hasCaseConstant(integerLiteral()))\n///   matches \"case 1:\"\nAST_MATCHER_P(CaseStmt, hasCaseConstant, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (Node.getRHS())\n    return false;\n\n  return InnerMatcher.matches(*Node.getLHS(), Finder, Builder);\n}\n\n/// Matches declaration that has a given attribute.\n///\n/// Given\n/// \\code\n///   __attribute__((device)) void f() { ... }\n/// \\endcode\n/// decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of\n/// f. If the matcher is used from clang-query, attr::Kind parameter should be\n/// passed as a quoted string. e.g., hasAttr(\"attr::CUDADevice\").\nAST_MATCHER_P(Decl, hasAttr, attr::Kind, AttrKind) {\n  for (const auto *Attr : Node.attrs()) {\n    if (Attr->getKind() == AttrKind)\n      return true;\n  }\n  return false;\n}\n\n/// Matches the return value expression of a return statement\n///\n/// Given\n/// \\code\n///   return a + b;\n/// \\endcode\n/// hasReturnValue(binaryOperator())\n///   matches 'return a + b'\n/// with binaryOperator()\n///   matching 'a + b'\nAST_MATCHER_P(ReturnStmt, hasReturnValue, internal::Matcher<Expr>,\n              InnerMatcher) {\n  if (const auto *RetValue = Node.getRetValue())\n    return InnerMatcher.matches(*RetValue, Finder, Builder);\n  return false;\n}\n\n/// Matches CUDA kernel call expression.\n///\n/// Example matches,\n/// \\code\n///   kernel<<<i,j>>>();\n/// \\endcode\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, CUDAKernelCallExpr>\n    cudaKernelCallExpr;\n\n/// Matches expressions that resolve to a null pointer constant, such as\n/// GNU's __null, C++11's nullptr, or C's NULL macro.\n///\n/// Given:\n/// \\code\n///   void *v1 = NULL;\n///   void *v2 = nullptr;\n///   void *v3 = __null; // GNU extension\n///   char *cp = (char *)0;\n///   int *ip = 0;\n///   int i = 0;\n/// \\endcode\n/// expr(nullPointerConstant())\n///   matches the initializer for v1, v2, v3, cp, and ip. Does not match the\n///   initializer for i.\nAST_MATCHER_FUNCTION(internal::Matcher<Expr>, nullPointerConstant) {\n  return anyOf(\n      gnuNullExpr(), cxxNullPtrLiteralExpr(),\n      integerLiteral(equals(0), hasParent(expr(hasType(pointerType())))));\n}\n\n/// Matches the DecompositionDecl the binding belongs to.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   bindingDecl(hasName(\"f\"),\n///                 forDecomposition(decompositionDecl())\n/// \\endcode\n/// matches 'f' in 'auto &[f, s, t]'.\nAST_MATCHER_P(BindingDecl, forDecomposition, internal::Matcher<ValueDecl>,\n              InnerMatcher) {\n  if (const ValueDecl *VD = Node.getDecomposedDecl())\n    return InnerMatcher.matches(*VD, Finder, Builder);\n  return false;\n}\n\n/// Matches the Nth binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasBinding(0,\n///   bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P2(DecompositionDecl, hasBinding, unsigned, N,\n               internal::Matcher<BindingDecl>, InnerMatcher) {\n  if (Node.bindings().size() <= N)\n    return false;\n  return InnerMatcher.matches(*Node.bindings()[N], Finder, Builder);\n}\n\n/// Matches any binding of a DecompositionDecl.\n///\n/// For example, in:\n/// \\code\n/// void foo()\n/// {\n///     int arr[3];\n///     auto &[f, s, t] = arr;\n///\n///     f = 42;\n/// }\n/// \\endcode\n/// The matcher:\n/// \\code\n///   decompositionDecl(hasAnyBinding(bindingDecl(hasName(\"f\").bind(\"fBinding\"))))\n/// \\endcode\n/// matches the decomposition decl with 'f' bound to \"fBinding\".\nAST_MATCHER_P(DecompositionDecl, hasAnyBinding, internal::Matcher<BindingDecl>,\n              InnerMatcher) {\n  return llvm::any_of(Node.bindings(), [&](const auto *Binding) {\n    return InnerMatcher.matches(*Binding, Finder, Builder);\n  });\n}\n\n/// Matches declaration of the function the statement belongs to\n///\n/// Given:\n/// \\code\n/// F& operator=(const F& o) {\n///   std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });\n///   return *this;\n/// }\n/// \\endcode\n/// returnStmt(forFunction(hasName(\"operator=\")))\n///   matches 'return *this'\n///   but does not match 'return v > 0'\nAST_MATCHER_P(Stmt, forFunction, internal::Matcher<FunctionDecl>,\n              InnerMatcher) {\n  const auto &Parents = Finder->getASTContext().getParents(Node);\n\n  llvm::SmallVector<DynTypedNode, 8> Stack(Parents.begin(), Parents.end());\n  while(!Stack.empty()) {\n    const auto &CurNode = Stack.back();\n    Stack.pop_back();\n    if(const auto *FuncDeclNode = CurNode.get<FunctionDecl>()) {\n      if(InnerMatcher.matches(*FuncDeclNode, Finder, Builder)) {\n        return true;\n      }\n    } else if(const auto *LambdaExprNode = CurNode.get<LambdaExpr>()) {\n      if(InnerMatcher.matches(*LambdaExprNode->getCallOperator(),\n                              Finder, Builder)) {\n        return true;\n      }\n    } else {\n      for(const auto &Parent: Finder->getASTContext().getParents(CurNode))\n        Stack.push_back(Parent);\n    }\n  }\n  return false;\n}\n\n/// Matches a declaration that has external formal linkage.\n///\n/// Example matches only z (matcher = varDecl(hasExternalFormalLinkage()))\n/// \\code\n/// void f() {\n///   int x;\n///   static int y;\n/// }\n/// int z;\n/// \\endcode\n///\n/// Example matches f() because it has external formal linkage despite being\n/// unique to the translation unit as though it has internal likage\n/// (matcher = functionDecl(hasExternalFormalLinkage()))\n///\n/// \\code\n/// namespace {\n/// void f() {}\n/// }\n/// \\endcode\nAST_MATCHER(NamedDecl, hasExternalFormalLinkage) {\n  return Node.hasExternalFormalLinkage();\n}\n\n/// Matches a declaration that has default arguments.\n///\n/// Example matches y (matcher = parmVarDecl(hasDefaultArgument()))\n/// \\code\n/// void x(int val) {}\n/// void y(int val = 0) {}\n/// \\endcode\n///\n/// Deprecated. Use hasInitializer() instead to be able to\n/// match on the contents of the default argument.  For example:\n///\n/// \\code\n/// void x(int val = 7) {}\n/// void y(int val = 42) {}\n/// \\endcode\n/// parmVarDecl(hasInitializer(integerLiteral(equals(42))))\n///   matches the parameter of y\n///\n/// A matcher such as\n///   parmVarDecl(hasInitializer(anything()))\n/// is equivalent to parmVarDecl(hasDefaultArgument()).\nAST_MATCHER(ParmVarDecl, hasDefaultArgument) {\n  return Node.hasDefaultArg();\n}\n\n/// Matches array new expressions.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(isArray())\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER(CXXNewExpr, isArray) {\n  return Node.isArray();\n}\n\n/// Matches placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage, 16) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16))))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P2(CXXNewExpr, hasPlacementArg, unsigned, Index,\n               internal::Matcher<Expr>, InnerMatcher) {\n  return Node.getNumPlacementArgs() > Index &&\n         InnerMatcher.matches(*Node.getPlacementArg(Index), Finder, Builder);\n}\n\n/// Matches any placement new expression arguments.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new (Storage) MyClass();\n/// \\endcode\n/// cxxNewExpr(hasAnyPlacementArg(anything()))\n///   matches the expression 'new (Storage, 16) MyClass()'.\nAST_MATCHER_P(CXXNewExpr, hasAnyPlacementArg, internal::Matcher<Expr>,\n              InnerMatcher) {\n  return llvm::any_of(Node.placement_arguments(), [&](const Expr *Arg) {\n    return InnerMatcher.matches(*Arg, Finder, Builder);\n  });\n}\n\n/// Matches array new expressions with a given array size.\n///\n/// Given:\n/// \\code\n///   MyClass *p1 = new MyClass[10];\n/// \\endcode\n/// cxxNewExpr(hasArraySize(integerLiteral(equals(10))))\n///   matches the expression 'new MyClass[10]'.\nAST_MATCHER_P(CXXNewExpr, hasArraySize, internal::Matcher<Expr>, InnerMatcher) {\n  return Node.isArray() && *Node.getArraySize() &&\n         InnerMatcher.matches(**Node.getArraySize(), Finder, Builder);\n}\n\n/// Matches a class declaration that is defined.\n///\n/// Example matches x (matcher = cxxRecordDecl(hasDefinition()))\n/// \\code\n/// class x {};\n/// class y;\n/// \\endcode\nAST_MATCHER(CXXRecordDecl, hasDefinition) {\n  return Node.hasDefinition();\n}\n\n/// Matches C++11 scoped enum declaration.\n///\n/// Example matches Y (matcher = enumDecl(isScoped()))\n/// \\code\n/// enum X {};\n/// enum class Y {};\n/// \\endcode\nAST_MATCHER(EnumDecl, isScoped) {\n  return Node.isScoped();\n}\n\n/// Matches a function declared with a trailing return type.\n///\n/// Example matches Y (matcher = functionDecl(hasTrailingReturn()))\n/// \\code\n/// int X() {}\n/// auto Y() -> int {}\n/// \\endcode\nAST_MATCHER(FunctionDecl, hasTrailingReturn) {\n  if (const auto *F = Node.getType()->getAs<FunctionProtoType>())\n    return F->hasTrailingReturn();\n  return false;\n}\n\n/// Matches expressions that match InnerMatcher that are possibly wrapped in an\n/// elidable constructor and other corresponding bookkeeping nodes.\n///\n/// In C++17, elidable copy constructors are no longer being generated in the\n/// AST as it is not permitted by the standard. They are, however, part of the\n/// AST in C++14 and earlier. So, a matcher must abstract over these differences\n/// to work in all language modes. This matcher skips elidable constructor-call\n/// AST nodes, `ExprWithCleanups` nodes wrapping elidable constructor-calls and\n/// various implicit nodes inside the constructor calls, all of which will not\n/// appear in the C++17 AST.\n///\n/// Given\n///\n/// \\code\n/// struct H {};\n/// H G();\n/// void f() {\n///   H D = G();\n/// }\n/// \\endcode\n///\n/// ``varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))``\n/// matches ``H D = G()`` in C++11 through C++17 (and beyond).\nAST_MATCHER_P(Expr, ignoringElidableConstructorCall,\n              ast_matchers::internal::Matcher<Expr>, InnerMatcher) {\n  // E tracks the node that we are examining.\n  const Expr *E = &Node;\n  // If present, remove an outer `ExprWithCleanups` corresponding to the\n  // underlying `CXXConstructExpr`. This check won't cover all cases of added\n  // `ExprWithCleanups` corresponding to `CXXConstructExpr` nodes (because the\n  // EWC is placed on the outermost node of the expression, which this may not\n  // be), but, it still improves the coverage of this matcher.\n  if (const auto *CleanupsExpr = dyn_cast<ExprWithCleanups>(&Node))\n    E = CleanupsExpr->getSubExpr();\n  if (const auto *CtorExpr = dyn_cast<CXXConstructExpr>(E)) {\n    if (CtorExpr->isElidable()) {\n      if (const auto *MaterializeTemp =\n              dyn_cast<MaterializeTemporaryExpr>(CtorExpr->getArg(0))) {\n        return InnerMatcher.matches(*MaterializeTemp->getSubExpr(), Finder,\n                                    Builder);\n      }\n    }\n  }\n  return InnerMatcher.matches(Node, Finder, Builder);\n}\n\n//----------------------------------------------------------------------------//\n// OpenMP handling.\n//----------------------------------------------------------------------------//\n\n/// Matches any ``#pragma omp`` executable directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective()`` matches ``omp parallel``,\n/// ``omp parallel default(none)`` and ``omp taskyield``.\nextern const internal::VariadicDynCastAllOfMatcher<Stmt, OMPExecutableDirective>\n    ompExecutableDirective;\n\n/// Matches standalone OpenMP directives,\n/// i.e., directives that can't have a structured block.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   {}\n///   #pragma omp taskyield\n/// \\endcode\n///\n/// ``ompExecutableDirective(isStandaloneDirective()))`` matches\n/// ``omp taskyield``.\nAST_MATCHER(OMPExecutableDirective, isStandaloneDirective) {\n  return Node.isStandaloneDirective();\n}\n\n/// Matches the structured-block of the OpenMP executable directive\n///\n/// Prerequisite: the executable directive must not be standalone directive.\n/// If it is, it will never match.\n///\n/// Given\n///\n/// \\code\n///    #pragma omp parallel\n///    ;\n///    #pragma omp parallel\n///    {}\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasStructuredBlock(nullStmt()))`` will match ``;``\nAST_MATCHER_P(OMPExecutableDirective, hasStructuredBlock,\n              internal::Matcher<Stmt>, InnerMatcher) {\n  if (Node.isStandaloneDirective())\n    return false; // Standalone directives have no structured blocks.\n  return InnerMatcher.matches(*Node.getStructuredBlock(), Finder, Builder);\n}\n\n/// Matches any clause in an OpenMP directive.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n/// \\endcode\n///\n/// ``ompExecutableDirective(hasAnyClause(anything()))`` matches\n/// ``omp parallel default(none)``.\nAST_MATCHER_P(OMPExecutableDirective, hasAnyClause,\n              internal::Matcher<OMPClause>, InnerMatcher) {\n  ArrayRef<OMPClause *> Clauses = Node.clauses();\n  return matchesFirstInPointerRange(InnerMatcher, Clauses.begin(),\n                                    Clauses.end(), Finder,\n                                    Builder) != Clauses.end();\n}\n\n/// Matches OpenMP ``default`` clause.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(firstprivate)\n///   #pragma omp parallel\n/// \\endcode\n///\n/// ``ompDefaultClause()`` matches ``default(none)``, ``default(shared)``, and\n/// ``default(firstprivate)``\nextern const internal::VariadicDynCastAllOfMatcher<OMPClause, OMPDefaultClause>\n    ompDefaultClause;\n\n/// Matches if the OpenMP ``default`` clause has ``none`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isNoneKind())`` matches only ``default(none)``.\nAST_MATCHER(OMPDefaultClause, isNoneKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_none;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``shared`` kind specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isSharedKind())`` matches only ``default(shared)``.\nAST_MATCHER(OMPDefaultClause, isSharedKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_shared;\n}\n\n/// Matches if the OpenMP ``default`` clause has ``firstprivate`` kind\n/// specified.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel default(none)\n///   #pragma omp parallel default(shared)\n///   #pragma omp parallel default(firstprivate)\n/// \\endcode\n///\n/// ``ompDefaultClause(isFirstPrivateKind())`` matches only\n/// ``default(firstprivate)``.\nAST_MATCHER(OMPDefaultClause, isFirstPrivateKind) {\n  return Node.getDefaultKind() == llvm::omp::OMP_DEFAULT_firstprivate;\n}\n\n/// Matches if the OpenMP directive is allowed to contain the specified OpenMP\n/// clause kind.\n///\n/// Given\n///\n/// \\code\n///   #pragma omp parallel\n///   #pragma omp parallel for\n///   #pragma omp          for\n/// \\endcode\n///\n/// `ompExecutableDirective(isAllowedToContainClause(OMPC_default))`` matches\n/// ``omp parallel`` and ``omp parallel for``.\n///\n/// If the matcher is use from clang-query, ``OpenMPClauseKind`` parameter\n/// should be passed as a quoted string. e.g.,\n/// ``isAllowedToContainClauseKind(\"OMPC_default\").``\nAST_MATCHER_P(OMPExecutableDirective, isAllowedToContainClauseKind,\n              OpenMPClauseKind, CKind) {\n  return llvm::omp::isAllowedClauseForDirective(\n      Node.getDirectiveKind(), CKind,\n      Finder->getASTContext().getLangOpts().OpenMP);\n}\n\n//----------------------------------------------------------------------------//\n// End OpenMP handling.\n//----------------------------------------------------------------------------//\n\n} // namespace ast_matchers\n} // namespace clang\n\n#endif // LLVM_CLANG_ASTMATCHERS_ASTMATCHERS_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h", "content": "//===- ASTMatchersInternal.h - Structural query framework -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Implements the base layer of the matcher framework.\n//\n//  Matchers are methods that return a Matcher<T> which provides a method\n//  Matches(...) which is a predicate on an AST node. The Matches method's\n//  parameters define the context of the match, which allows matchers to recurse\n//  or store the current node as bound to a specific string, so that it can be\n//  retrieved later.\n//\n//  In general, matchers have two parts:\n//  1. A function Matcher<T> MatcherName(<arguments>) which returns a Matcher<T>\n//     based on the arguments and optionally on template type deduction based\n//     on the arguments. Matcher<T>s form an implicit reverse hierarchy\n//     to clang's AST class hierarchy, meaning that you can use a Matcher<Base>\n//     everywhere a Matcher<Derived> is required.\n//  2. An implementation of a class derived from MatcherInterface<T>.\n//\n//  The matcher functions are defined in ASTMatchers.h. To make it possible\n//  to implement both the matcher function and the implementation of the matcher\n//  interface in one place, ASTMatcherMacros.h defines macros that allow\n//  implementing a matcher in a single place.\n//\n//  This file contains the base classes needed to construct the actual matchers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ASTMATCHERS_ASTMATCHERSINTERNAL_H\n#define LLVM_CLANG_ASTMATCHERS_ASTMATCHERSINTERNAL_H\n\n#include \"clang/AST/ASTTypeTraits.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclFriend.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/Regex.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\n\nnamespace ast_matchers {\n\nclass BoundNodes;\n\nnamespace internal {\n\n/// Variadic function object.\n///\n/// Most of the functions below that use VariadicFunction could be implemented\n/// using plain C++11 variadic functions, but the function object allows us to\n/// capture it on the dynamic matcher registry.\ntemplate <typename ResultT, typename ArgT,\n          ResultT (*Func)(ArrayRef<const ArgT *>)>\nstruct VariadicFunction {\n  ResultT operator()() const { return Func(None); }\n\n  template <typename... ArgsT>\n  ResultT operator()(const ArgT &Arg1, const ArgsT &... Args) const {\n    return Execute(Arg1, static_cast<const ArgT &>(Args)...);\n  }\n\n  // We also allow calls with an already created array, in case the caller\n  // already had it.\n  ResultT operator()(ArrayRef<ArgT> Args) const {\n    SmallVector<const ArgT*, 8> InnerArgs;\n    for (const ArgT &Arg : Args)\n      InnerArgs.push_back(&Arg);\n    return Func(InnerArgs);\n  }\n\nprivate:\n  // Trampoline function to allow for implicit conversions to take place\n  // before we make the array.\n  template <typename... ArgsT> ResultT Execute(const ArgsT &... Args) const {\n    const ArgT *const ArgsArray[] = {&Args...};\n    return Func(ArrayRef<const ArgT *>(ArgsArray, sizeof...(ArgsT)));\n  }\n};\n\n/// Unifies obtaining the underlying type of a regular node through\n/// `getType` and a TypedefNameDecl node through `getUnderlyingType`.\ninline QualType getUnderlyingType(const Expr &Node) { return Node.getType(); }\n\ninline QualType getUnderlyingType(const ValueDecl &Node) {\n  return Node.getType();\n}\ninline QualType getUnderlyingType(const TypedefNameDecl &Node) {\n  return Node.getUnderlyingType();\n}\ninline QualType getUnderlyingType(const FriendDecl &Node) {\n  if (const TypeSourceInfo *TSI = Node.getFriendType())\n    return TSI->getType();\n  return QualType();\n}\ninline QualType getUnderlyingType(const CXXBaseSpecifier &Node) {\n  return Node.getType();\n}\n\n/// Unifies obtaining the FunctionProtoType pointer from both\n/// FunctionProtoType and FunctionDecl nodes..\ninline const FunctionProtoType *\ngetFunctionProtoType(const FunctionProtoType &Node) {\n  return &Node;\n}\n\ninline const FunctionProtoType *getFunctionProtoType(const FunctionDecl &Node) {\n  return Node.getType()->getAs<FunctionProtoType>();\n}\n\n/// Unifies obtaining the access specifier from Decl and CXXBaseSpecifier nodes.\ninline clang::AccessSpecifier getAccessSpecifier(const Decl &Node) {\n  return Node.getAccess();\n}\n\ninline clang::AccessSpecifier getAccessSpecifier(const CXXBaseSpecifier &Node) {\n  return Node.getAccessSpecifier();\n}\n\n/// Internal version of BoundNodes. Holds all the bound nodes.\nclass BoundNodesMap {\npublic:\n  /// Adds \\c Node to the map with key \\c ID.\n  ///\n  /// The node's base type should be in NodeBaseType or it will be unaccessible.\n  void addNode(StringRef ID, const DynTypedNode &DynNode) {\n    NodeMap[std::string(ID)] = DynNode;\n  }\n\n  /// Returns the AST node bound to \\c ID.\n  ///\n  /// Returns NULL if there was no node bound to \\c ID or if there is a node but\n  /// it cannot be converted to the specified type.\n  template <typename T>\n  const T *getNodeAs(StringRef ID) const {\n    IDToNodeMap::const_iterator It = NodeMap.find(ID);\n    if (It == NodeMap.end()) {\n      return nullptr;\n    }\n    return It->second.get<T>();\n  }\n\n  DynTypedNode getNode(StringRef ID) const {\n    IDToNodeMap::const_iterator It = NodeMap.find(ID);\n    if (It == NodeMap.end()) {\n      return DynTypedNode();\n    }\n    return It->second;\n  }\n\n  /// Imposes an order on BoundNodesMaps.\n  bool operator<(const BoundNodesMap &Other) const {\n    return NodeMap < Other.NodeMap;\n  }\n\n  /// A map from IDs to the bound nodes.\n  ///\n  /// Note that we're using std::map here, as for memoization:\n  /// - we need a comparison operator\n  /// - we need an assignment operator\n  using IDToNodeMap = std::map<std::string, DynTypedNode, std::less<>>;\n\n  const IDToNodeMap &getMap() const {\n    return NodeMap;\n  }\n\n  /// Returns \\c true if this \\c BoundNodesMap can be compared, i.e. all\n  /// stored nodes have memoization data.\n  bool isComparable() const {\n    for (const auto &IDAndNode : NodeMap) {\n      if (!IDAndNode.second.getMemoizationData())\n        return false;\n    }\n    return true;\n  }\n\nprivate:\n  IDToNodeMap NodeMap;\n};\n\n/// Creates BoundNodesTree objects.\n///\n/// The tree builder is used during the matching process to insert the bound\n/// nodes from the Id matcher.\nclass BoundNodesTreeBuilder {\npublic:\n  /// A visitor interface to visit all BoundNodes results for a\n  /// BoundNodesTree.\n  class Visitor {\n  public:\n    virtual ~Visitor() = default;\n\n    /// Called multiple times during a single call to VisitMatches(...).\n    ///\n    /// 'BoundNodesView' contains the bound nodes for a single match.\n    virtual void visitMatch(const BoundNodes& BoundNodesView) = 0;\n  };\n\n  /// Add a binding from an id to a node.\n  void setBinding(StringRef Id, const DynTypedNode &DynNode) {\n    if (Bindings.empty())\n      Bindings.emplace_back();\n    for (BoundNodesMap &Binding : Bindings)\n      Binding.addNode(Id, DynNode);\n  }\n\n  /// Adds a branch in the tree.\n  void addMatch(const BoundNodesTreeBuilder &Bindings);\n\n  /// Visits all matches that this BoundNodesTree represents.\n  ///\n  /// The ownership of 'ResultVisitor' remains at the caller.\n  void visitMatches(Visitor* ResultVisitor);\n\n  template <typename ExcludePredicate>\n  bool removeBindings(const ExcludePredicate &Predicate) {\n    Bindings.erase(std::remove_if(Bindings.begin(), Bindings.end(), Predicate),\n                   Bindings.end());\n    return !Bindings.empty();\n  }\n\n  /// Imposes an order on BoundNodesTreeBuilders.\n  bool operator<(const BoundNodesTreeBuilder &Other) const {\n    return Bindings < Other.Bindings;\n  }\n\n  /// Returns \\c true if this \\c BoundNodesTreeBuilder can be compared,\n  /// i.e. all stored node maps have memoization data.\n  bool isComparable() const {\n    for (const BoundNodesMap &NodesMap : Bindings) {\n      if (!NodesMap.isComparable())\n        return false;\n    }\n    return true;\n  }\n\nprivate:\n  SmallVector<BoundNodesMap, 1> Bindings;\n};\n\nclass ASTMatchFinder;\n\n/// Generic interface for all matchers.\n///\n/// Used by the implementation of Matcher<T> and DynTypedMatcher.\n/// In general, implement MatcherInterface<T> or SingleNodeMatcherInterface<T>\n/// instead.\nclass DynMatcherInterface\n    : public llvm::ThreadSafeRefCountedBase<DynMatcherInterface> {\npublic:\n  virtual ~DynMatcherInterface() = default;\n\n  /// Returns true if \\p DynNode can be matched.\n  ///\n  /// May bind \\p DynNode to an ID via \\p Builder, or recurse into\n  /// the AST via \\p Finder.\n  virtual bool dynMatches(const DynTypedNode &DynNode, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const = 0;\n\n  virtual llvm::Optional<clang::TraversalKind> TraversalKind() const {\n    return llvm::None;\n  }\n};\n\n/// Generic interface for matchers on an AST node of type T.\n///\n/// Implement this if your matcher may need to inspect the children or\n/// descendants of the node or bind matched nodes to names. If you are\n/// writing a simple matcher that only inspects properties of the\n/// current node and doesn't care about its children or descendants,\n/// implement SingleNodeMatcherInterface instead.\ntemplate <typename T>\nclass MatcherInterface : public DynMatcherInterface {\npublic:\n  /// Returns true if 'Node' can be matched.\n  ///\n  /// May bind 'Node' to an ID via 'Builder', or recurse into\n  /// the AST via 'Finder'.\n  virtual bool matches(const T &Node,\n                       ASTMatchFinder *Finder,\n                       BoundNodesTreeBuilder *Builder) const = 0;\n\n  bool dynMatches(const DynTypedNode &DynNode, ASTMatchFinder *Finder,\n                  BoundNodesTreeBuilder *Builder) const override {\n    return matches(DynNode.getUnchecked<T>(), Finder, Builder);\n  }\n};\n\n/// Interface for matchers that only evaluate properties on a single\n/// node.\ntemplate <typename T>\nclass SingleNodeMatcherInterface : public MatcherInterface<T> {\npublic:\n  /// Returns true if the matcher matches the provided node.\n  ///\n  /// A subclass must implement this instead of Matches().\n  virtual bool matchesNode(const T &Node) const = 0;\n\nprivate:\n  /// Implements MatcherInterface::Matches.\n  bool matches(const T &Node,\n               ASTMatchFinder * /* Finder */,\n               BoundNodesTreeBuilder * /*  Builder */) const override {\n    return matchesNode(Node);\n  }\n};\n\ntemplate <typename> class Matcher;\n\n/// Matcher that works on a \\c DynTypedNode.\n///\n/// It is constructed from a \\c Matcher<T> object and redirects most calls to\n/// underlying matcher.\n/// It checks whether the \\c DynTypedNode is convertible into the type of the\n/// underlying matcher and then do the actual match on the actual node, or\n/// return false if it is not convertible.\nclass DynTypedMatcher {\npublic:\n  /// Takes ownership of the provided implementation pointer.\n  template <typename T>\n  DynTypedMatcher(MatcherInterface<T> *Implementation)\n      : SupportedKind(ASTNodeKind::getFromNodeKind<T>()),\n        RestrictKind(SupportedKind), Implementation(Implementation) {}\n\n  /// Construct from a variadic function.\n  enum VariadicOperator {\n    /// Matches nodes for which all provided matchers match.\n    VO_AllOf,\n\n    /// Matches nodes for which at least one of the provided matchers\n    /// matches.\n    VO_AnyOf,\n\n    /// Matches nodes for which at least one of the provided matchers\n    /// matches, but doesn't stop at the first match.\n    VO_EachOf,\n\n    /// Matches any node but executes all inner matchers to find result\n    /// bindings.\n    VO_Optionally,\n\n    /// Matches nodes that do not match the provided matcher.\n    ///\n    /// Uses the variadic matcher interface, but fails if\n    /// InnerMatchers.size() != 1.\n    VO_UnaryNot\n  };\n\n  static DynTypedMatcher\n  constructVariadic(VariadicOperator Op, ASTNodeKind SupportedKind,\n                    std::vector<DynTypedMatcher> InnerMatchers);\n\n  static DynTypedMatcher\n  constructRestrictedWrapper(const DynTypedMatcher &InnerMatcher,\n                             ASTNodeKind RestrictKind);\n\n  /// Get a \"true\" matcher for \\p NodeKind.\n  ///\n  /// It only checks that the node is of the right kind.\n  static DynTypedMatcher trueMatcher(ASTNodeKind NodeKind);\n\n  void setAllowBind(bool AB) { AllowBind = AB; }\n\n  /// Check whether this matcher could ever match a node of kind \\p Kind.\n  /// \\return \\c false if this matcher will never match such a node. Otherwise,\n  /// return \\c true.\n  bool canMatchNodesOfKind(ASTNodeKind Kind) const;\n\n  /// Return a matcher that points to the same implementation, but\n  ///   restricts the node types for \\p Kind.\n  DynTypedMatcher dynCastTo(const ASTNodeKind Kind) const;\n\n  /// Return a matcher that that points to the same implementation, but sets the\n  ///   traversal kind.\n  ///\n  /// If the traversal kind is already set, then \\c TK overrides it.\n  DynTypedMatcher withTraversalKind(TraversalKind TK);\n\n  /// Returns true if the matcher matches the given \\c DynNode.\n  bool matches(const DynTypedNode &DynNode, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const;\n\n  /// Same as matches(), but skips the kind check.\n  ///\n  /// It is faster, but the caller must ensure the node is valid for the\n  /// kind of this matcher.\n  bool matchesNoKindCheck(const DynTypedNode &DynNode, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const;\n\n  /// Bind the specified \\p ID to the matcher.\n  /// \\return A new matcher with the \\p ID bound to it if this matcher supports\n  ///   binding. Otherwise, returns an empty \\c Optional<>.\n  llvm::Optional<DynTypedMatcher> tryBind(StringRef ID) const;\n\n  /// Returns a unique \\p ID for the matcher.\n  ///\n  /// Casting a Matcher<T> to Matcher<U> creates a matcher that has the\n  /// same \\c Implementation pointer, but different \\c RestrictKind. We need to\n  /// include both in the ID to make it unique.\n  ///\n  /// \\c MatcherIDType supports operator< and provides strict weak ordering.\n  using MatcherIDType = std::pair<ASTNodeKind, uint64_t>;\n  MatcherIDType getID() const {\n    /// FIXME: Document the requirements this imposes on matcher\n    /// implementations (no new() implementation_ during a Matches()).\n    return std::make_pair(RestrictKind,\n                          reinterpret_cast<uint64_t>(Implementation.get()));\n  }\n\n  /// Returns the type this matcher works on.\n  ///\n  /// \\c matches() will always return false unless the node passed is of this\n  /// or a derived type.\n  ASTNodeKind getSupportedKind() const { return SupportedKind; }\n\n  /// Returns \\c true if the passed \\c DynTypedMatcher can be converted\n  ///   to a \\c Matcher<T>.\n  ///\n  /// This method verifies that the underlying matcher in \\c Other can process\n  /// nodes of types T.\n  template <typename T> bool canConvertTo() const {\n    return canConvertTo(ASTNodeKind::getFromNodeKind<T>());\n  }\n  bool canConvertTo(ASTNodeKind To) const;\n\n  /// Construct a \\c Matcher<T> interface around the dynamic matcher.\n  ///\n  /// This method asserts that \\c canConvertTo() is \\c true. Callers\n  /// should call \\c canConvertTo() first to make sure that \\c this is\n  /// compatible with T.\n  template <typename T> Matcher<T> convertTo() const {\n    assert(canConvertTo<T>());\n    return unconditionalConvertTo<T>();\n  }\n\n  /// Same as \\c convertTo(), but does not check that the underlying\n  ///   matcher can handle a value of T.\n  ///\n  /// If it is not compatible, then this matcher will never match anything.\n  template <typename T> Matcher<T> unconditionalConvertTo() const;\n\n  /// Returns the \\c TraversalKind respected by calls to `match()`, if any.\n  ///\n  /// Most matchers will not have a traversal kind set, instead relying on the\n  /// surrounding context. For those, \\c llvm::None is returned.\n  llvm::Optional<clang::TraversalKind> getTraversalKind() const {\n    return Implementation->TraversalKind();\n  }\n\nprivate:\n  DynTypedMatcher(ASTNodeKind SupportedKind, ASTNodeKind RestrictKind,\n                  IntrusiveRefCntPtr<DynMatcherInterface> Implementation)\n      : SupportedKind(SupportedKind), RestrictKind(RestrictKind),\n        Implementation(std::move(Implementation)) {}\n\n  bool AllowBind = false;\n  ASTNodeKind SupportedKind;\n\n  /// A potentially stricter node kind.\n  ///\n  /// It allows to perform implicit and dynamic cast of matchers without\n  /// needing to change \\c Implementation.\n  ASTNodeKind RestrictKind;\n  IntrusiveRefCntPtr<DynMatcherInterface> Implementation;\n};\n\n/// Wrapper of a MatcherInterface<T> *that allows copying.\n///\n/// A Matcher<Base> can be used anywhere a Matcher<Derived> is\n/// required. This establishes an is-a relationship which is reverse\n/// to the AST hierarchy. In other words, Matcher<T> is contravariant\n/// with respect to T. The relationship is built via a type conversion\n/// operator rather than a type hierarchy to be able to templatize the\n/// type hierarchy instead of spelling it out.\ntemplate <typename T>\nclass Matcher {\npublic:\n  /// Takes ownership of the provided implementation pointer.\n  explicit Matcher(MatcherInterface<T> *Implementation)\n      : Implementation(Implementation) {}\n\n  /// Implicitly converts \\c Other to a Matcher<T>.\n  ///\n  /// Requires \\c T to be derived from \\c From.\n  template <typename From>\n  Matcher(const Matcher<From> &Other,\n          std::enable_if_t<std::is_base_of<From, T>::value &&\n                           !std::is_same<From, T>::value> * = nullptr)\n      : Implementation(restrictMatcher(Other.Implementation)) {\n    assert(Implementation.getSupportedKind().isSame(\n        ASTNodeKind::getFromNodeKind<T>()));\n  }\n\n  /// Implicitly converts \\c Matcher<Type> to \\c Matcher<QualType>.\n  ///\n  /// The resulting matcher is not strict, i.e. ignores qualifiers.\n  template <typename TypeT>\n  Matcher(const Matcher<TypeT> &Other,\n          std::enable_if_t<std::is_same<T, QualType>::value &&\n                           std::is_same<TypeT, Type>::value> * = nullptr)\n      : Implementation(new TypeToQualType<TypeT>(Other)) {}\n\n  /// Convert \\c this into a \\c Matcher<T> by applying dyn_cast<> to the\n  /// argument.\n  /// \\c To must be a base class of \\c T.\n  template <typename To>\n  Matcher<To> dynCastTo() const {\n    static_assert(std::is_base_of<To, T>::value, \"Invalid dynCast call.\");\n    return Matcher<To>(Implementation);\n  }\n\n  /// Forwards the call to the underlying MatcherInterface<T> pointer.\n  bool matches(const T &Node,\n               ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const {\n    return Implementation.matches(DynTypedNode::create(Node), Finder, Builder);\n  }\n\n  /// Returns an ID that uniquely identifies the matcher.\n  DynTypedMatcher::MatcherIDType getID() const {\n    return Implementation.getID();\n  }\n\n  /// Extract the dynamic matcher.\n  ///\n  /// The returned matcher keeps the same restrictions as \\c this and remembers\n  /// that it is meant to support nodes of type \\c T.\n  operator DynTypedMatcher() const { return Implementation; }\n\n  /// Allows the conversion of a \\c Matcher<Type> to a \\c\n  /// Matcher<QualType>.\n  ///\n  /// Depending on the constructor argument, the matcher is either strict, i.e.\n  /// does only matches in the absence of qualifiers, or not, i.e. simply\n  /// ignores any qualifiers.\n  template <typename TypeT>\n  class TypeToQualType : public MatcherInterface<QualType> {\n    const DynTypedMatcher InnerMatcher;\n\n  public:\n    TypeToQualType(const Matcher<TypeT> &InnerMatcher)\n        : InnerMatcher(InnerMatcher) {}\n\n    bool matches(const QualType &Node, ASTMatchFinder *Finder,\n                 BoundNodesTreeBuilder *Builder) const override {\n      if (Node.isNull())\n        return false;\n      return this->InnerMatcher.matches(DynTypedNode::create(*Node), Finder,\n                                        Builder);\n    }\n\n    llvm::Optional<clang::TraversalKind> TraversalKind() const override {\n      return this->InnerMatcher.getTraversalKind();\n    }\n  };\n\nprivate:\n  // For Matcher<T> <=> Matcher<U> conversions.\n  template <typename U> friend class Matcher;\n\n  // For DynTypedMatcher::unconditionalConvertTo<T>.\n  friend class DynTypedMatcher;\n\n  static DynTypedMatcher restrictMatcher(const DynTypedMatcher &Other) {\n    return Other.dynCastTo(ASTNodeKind::getFromNodeKind<T>());\n  }\n\n  explicit Matcher(const DynTypedMatcher &Implementation)\n      : Implementation(restrictMatcher(Implementation)) {\n    assert(this->Implementation.getSupportedKind().isSame(\n        ASTNodeKind::getFromNodeKind<T>()));\n  }\n\n  DynTypedMatcher Implementation;\n};  // class Matcher\n\n/// A convenient helper for creating a Matcher<T> without specifying\n/// the template type argument.\ntemplate <typename T>\ninline Matcher<T> makeMatcher(MatcherInterface<T> *Implementation) {\n  return Matcher<T>(Implementation);\n}\n\n/// Interface that allows matchers to traverse the AST.\n/// FIXME: Find a better name.\n///\n/// This provides three entry methods for each base node type in the AST:\n/// - \\c matchesChildOf:\n///   Matches a matcher on every child node of the given node. Returns true\n///   if at least one child node could be matched.\n/// - \\c matchesDescendantOf:\n///   Matches a matcher on all descendant nodes of the given node. Returns true\n///   if at least one descendant matched.\n/// - \\c matchesAncestorOf:\n///   Matches a matcher on all ancestors of the given node. Returns true if\n///   at least one ancestor matched.\n///\n/// FIXME: Currently we only allow Stmt and Decl nodes to start a traversal.\n/// In the future, we want to implement this for all nodes for which it makes\n/// sense. In the case of matchesAncestorOf, we'll want to implement it for\n/// all nodes, as all nodes have ancestors.\nclass ASTMatchFinder {\npublic:\n  /// Defines how bindings are processed on recursive matches.\n  enum BindKind {\n    /// Stop at the first match and only bind the first match.\n    BK_First,\n\n    /// Create results for all combinations of bindings that match.\n    BK_All\n  };\n\n  /// Defines which ancestors are considered for a match.\n  enum AncestorMatchMode {\n    /// All ancestors.\n    AMM_All,\n\n    /// Direct parent only.\n    AMM_ParentOnly\n  };\n\n  virtual ~ASTMatchFinder() = default;\n\n  /// Returns true if the given C++ class is directly or indirectly derived\n  /// from a base type matching \\c base.\n  ///\n  /// A class is not considered to be derived from itself.\n  virtual bool classIsDerivedFrom(const CXXRecordDecl *Declaration,\n                                  const Matcher<NamedDecl> &Base,\n                                  BoundNodesTreeBuilder *Builder,\n                                  bool Directly) = 0;\n\n  /// Returns true if the given Objective-C class is directly or indirectly\n  /// derived from a base class matching \\c base.\n  ///\n  /// A class is not considered to be derived from itself.\n  virtual bool objcClassIsDerivedFrom(const ObjCInterfaceDecl *Declaration,\n                                      const Matcher<NamedDecl> &Base,\n                                      BoundNodesTreeBuilder *Builder,\n                                      bool Directly) = 0;\n\n  template <typename T>\n  bool matchesChildOf(const T &Node, const DynTypedMatcher &Matcher,\n                      BoundNodesTreeBuilder *Builder, BindKind Bind) {\n    static_assert(std::is_base_of<Decl, T>::value ||\n                      std::is_base_of<Stmt, T>::value ||\n                      std::is_base_of<NestedNameSpecifier, T>::value ||\n                      std::is_base_of<NestedNameSpecifierLoc, T>::value ||\n                      std::is_base_of<TypeLoc, T>::value ||\n                      std::is_base_of<QualType, T>::value,\n                  \"unsupported type for recursive matching\");\n    return matchesChildOf(DynTypedNode::create(Node), getASTContext(), Matcher,\n                          Builder, Bind);\n  }\n\n  template <typename T>\n  bool matchesDescendantOf(const T &Node, const DynTypedMatcher &Matcher,\n                           BoundNodesTreeBuilder *Builder, BindKind Bind) {\n    static_assert(std::is_base_of<Decl, T>::value ||\n                      std::is_base_of<Stmt, T>::value ||\n                      std::is_base_of<NestedNameSpecifier, T>::value ||\n                      std::is_base_of<NestedNameSpecifierLoc, T>::value ||\n                      std::is_base_of<TypeLoc, T>::value ||\n                      std::is_base_of<QualType, T>::value,\n                  \"unsupported type for recursive matching\");\n    return matchesDescendantOf(DynTypedNode::create(Node), getASTContext(),\n                               Matcher, Builder, Bind);\n  }\n\n  // FIXME: Implement support for BindKind.\n  template <typename T>\n  bool matchesAncestorOf(const T &Node, const DynTypedMatcher &Matcher,\n                         BoundNodesTreeBuilder *Builder,\n                         AncestorMatchMode MatchMode) {\n    static_assert(std::is_base_of<Decl, T>::value ||\n                      std::is_base_of<NestedNameSpecifierLoc, T>::value ||\n                      std::is_base_of<Stmt, T>::value ||\n                      std::is_base_of<TypeLoc, T>::value,\n                  \"type not allowed for recursive matching\");\n    return matchesAncestorOf(DynTypedNode::create(Node), getASTContext(),\n                             Matcher, Builder, MatchMode);\n  }\n\n  virtual ASTContext &getASTContext() const = 0;\n\n  virtual bool IsMatchingInASTNodeNotSpelledInSource() const = 0;\n\n  virtual bool IsMatchingInASTNodeNotAsIs() const = 0;\n\n  bool isTraversalIgnoringImplicitNodes() const;\n\nprotected:\n  virtual bool matchesChildOf(const DynTypedNode &Node, ASTContext &Ctx,\n                              const DynTypedMatcher &Matcher,\n                              BoundNodesTreeBuilder *Builder,\n                              BindKind Bind) = 0;\n\n  virtual bool matchesDescendantOf(const DynTypedNode &Node, ASTContext &Ctx,\n                                   const DynTypedMatcher &Matcher,\n                                   BoundNodesTreeBuilder *Builder,\n                                   BindKind Bind) = 0;\n\n  virtual bool matchesAncestorOf(const DynTypedNode &Node, ASTContext &Ctx,\n                                 const DynTypedMatcher &Matcher,\n                                 BoundNodesTreeBuilder *Builder,\n                                 AncestorMatchMode MatchMode) = 0;\nprivate:\n  friend struct ASTChildrenNotSpelledInSourceScope;\n  virtual bool isMatchingChildrenNotSpelledInSource() const = 0;\n  virtual void setMatchingChildrenNotSpelledInSource(bool Set) = 0;\n};\n\nstruct ASTChildrenNotSpelledInSourceScope {\n  ASTChildrenNotSpelledInSourceScope(ASTMatchFinder *V, bool B)\n      : MV(V), MB(V->isMatchingChildrenNotSpelledInSource()) {\n    V->setMatchingChildrenNotSpelledInSource(B);\n  }\n  ~ASTChildrenNotSpelledInSourceScope() {\n    MV->setMatchingChildrenNotSpelledInSource(MB);\n  }\n\nprivate:\n  ASTMatchFinder *MV;\n  bool MB;\n};\n\n/// Specialization of the conversion functions for QualType.\n///\n/// This specialization provides the Matcher<Type>->Matcher<QualType>\n/// conversion that the static API does.\ntemplate <>\ninline Matcher<QualType> DynTypedMatcher::convertTo<QualType>() const {\n  assert(canConvertTo<QualType>());\n  const ASTNodeKind SourceKind = getSupportedKind();\n  if (SourceKind.isSame(ASTNodeKind::getFromNodeKind<Type>())) {\n    // We support implicit conversion from Matcher<Type> to Matcher<QualType>\n    return unconditionalConvertTo<Type>();\n  }\n  return unconditionalConvertTo<QualType>();\n}\n\n/// Finds the first node in a range that matches the given matcher.\ntemplate <typename MatcherT, typename IteratorT>\nIteratorT matchesFirstInRange(const MatcherT &Matcher, IteratorT Start,\n                              IteratorT End, ASTMatchFinder *Finder,\n                              BoundNodesTreeBuilder *Builder) {\n  for (IteratorT I = Start; I != End; ++I) {\n    BoundNodesTreeBuilder Result(*Builder);\n    if (Matcher.matches(*I, Finder, &Result)) {\n      *Builder = std::move(Result);\n      return I;\n    }\n  }\n  return End;\n}\n\n/// Finds the first node in a pointer range that matches the given\n/// matcher.\ntemplate <typename MatcherT, typename IteratorT>\nIteratorT matchesFirstInPointerRange(const MatcherT &Matcher, IteratorT Start,\n                                     IteratorT End, ASTMatchFinder *Finder,\n                                     BoundNodesTreeBuilder *Builder) {\n  for (IteratorT I = Start; I != End; ++I) {\n    BoundNodesTreeBuilder Result(*Builder);\n    if (Matcher.matches(**I, Finder, &Result)) {\n      *Builder = std::move(Result);\n      return I;\n    }\n  }\n  return End;\n}\n\ntemplate <typename T, std::enable_if_t<!std::is_base_of<FunctionDecl, T>::value>\n                          * = nullptr>\ninline bool isDefaultedHelper(const T *) {\n  return false;\n}\ninline bool isDefaultedHelper(const FunctionDecl *FD) {\n  return FD->isDefaulted();\n}\n\n// Metafunction to determine if type T has a member called getDecl.\ntemplate <typename Ty>\nclass has_getDecl {\n  using yes = char[1];\n  using no = char[2];\n\n  template <typename Inner>\n  static yes& test(Inner *I, decltype(I->getDecl()) * = nullptr);\n\n  template <typename>\n  static no& test(...);\n\npublic:\n  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);\n};\n\n/// Matches overloaded operators with a specific name.\n///\n/// The type argument ArgT is not used by this matcher but is used by\n/// PolymorphicMatcher and should be StringRef.\ntemplate <typename T, typename ArgT>\nclass HasOverloadedOperatorNameMatcher : public SingleNodeMatcherInterface<T> {\n  static_assert(std::is_same<T, CXXOperatorCallExpr>::value ||\n                std::is_base_of<FunctionDecl, T>::value,\n                \"unsupported class for matcher\");\n  static_assert(std::is_same<ArgT, std::vector<std::string>>::value,\n                \"argument type must be std::vector<std::string>\");\n\npublic:\n  explicit HasOverloadedOperatorNameMatcher(std::vector<std::string> Names)\n      : SingleNodeMatcherInterface<T>(), Names(std::move(Names)) {}\n\n  bool matchesNode(const T &Node) const override {\n    return matchesSpecialized(Node);\n  }\n\nprivate:\n\n  /// CXXOperatorCallExpr exist only for calls to overloaded operators\n  /// so this function returns true if the call is to an operator of the given\n  /// name.\n  bool matchesSpecialized(const CXXOperatorCallExpr &Node) const {\n    return llvm::is_contained(Names, getOperatorSpelling(Node.getOperator()));\n  }\n\n  /// Returns true only if CXXMethodDecl represents an overloaded\n  /// operator and has the given operator name.\n  bool matchesSpecialized(const FunctionDecl &Node) const {\n    return Node.isOverloadedOperator() &&\n           llvm::is_contained(\n               Names, getOperatorSpelling(Node.getOverloadedOperator()));\n  }\n\n  const std::vector<std::string> Names;\n};\n\n/// Matches named declarations with a specific name.\n///\n/// See \\c hasName() and \\c hasAnyName() in ASTMatchers.h for details.\nclass HasNameMatcher : public SingleNodeMatcherInterface<NamedDecl> {\n public:\n  explicit HasNameMatcher(std::vector<std::string> Names);\n\n  bool matchesNode(const NamedDecl &Node) const override;\n\n private:\n  /// Unqualified match routine.\n  ///\n  /// It is much faster than the full match, but it only works for unqualified\n  /// matches.\n  bool matchesNodeUnqualified(const NamedDecl &Node) const;\n\n  /// Full match routine\n  ///\n  /// Fast implementation for the simple case of a named declaration at\n  /// namespace or RecordDecl scope.\n  /// It is slower than matchesNodeUnqualified, but faster than\n  /// matchesNodeFullSlow.\n  bool matchesNodeFullFast(const NamedDecl &Node) const;\n\n  /// Full match routine\n  ///\n  /// It generates the fully qualified name of the declaration (which is\n  /// expensive) before trying to match.\n  /// It is slower but simple and works on all cases.\n  bool matchesNodeFullSlow(const NamedDecl &Node) const;\n\n  const bool UseUnqualifiedMatch;\n  const std::vector<std::string> Names;\n};\n\n/// Trampoline function to use VariadicFunction<> to construct a\n///        HasNameMatcher.\nMatcher<NamedDecl> hasAnyNameFunc(ArrayRef<const StringRef *> NameRefs);\n\n/// Trampoline function to use VariadicFunction<> to construct a\n///        hasAnySelector matcher.\nMatcher<ObjCMessageExpr> hasAnySelectorFunc(\n    ArrayRef<const StringRef *> NameRefs);\n\n/// Matches declarations for QualType and CallExpr.\n///\n/// Type argument DeclMatcherT is required by PolymorphicMatcher but\n/// not actually used.\ntemplate <typename T, typename DeclMatcherT>\nclass HasDeclarationMatcher : public MatcherInterface<T> {\n  static_assert(std::is_same<DeclMatcherT, Matcher<Decl>>::value,\n                \"instantiated with wrong types\");\n\n  const DynTypedMatcher InnerMatcher;\n\npublic:\n  explicit HasDeclarationMatcher(const Matcher<Decl> &InnerMatcher)\n      : InnerMatcher(InnerMatcher) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return matchesSpecialized(Node, Finder, Builder);\n  }\n\nprivate:\n  /// Forwards to matching on the underlying type of the QualType.\n  bool matchesSpecialized(const QualType &Node, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    if (Node.isNull())\n      return false;\n\n    return matchesSpecialized(*Node, Finder, Builder);\n  }\n\n  /// Finds the best declaration for a type and returns whether the inner\n  /// matcher matches on it.\n  bool matchesSpecialized(const Type &Node, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    // DeducedType does not have declarations of its own, so\n    // match the deduced type instead.\n    const Type *EffectiveType = &Node;\n    if (const auto *S = dyn_cast<DeducedType>(&Node)) {\n      EffectiveType = S->getDeducedType().getTypePtrOrNull();\n      if (!EffectiveType)\n        return false;\n    }\n\n    // First, for any types that have a declaration, extract the declaration and\n    // match on it.\n    if (const auto *S = dyn_cast<TagType>(EffectiveType)) {\n      return matchesDecl(S->getDecl(), Finder, Builder);\n    }\n    if (const auto *S = dyn_cast<InjectedClassNameType>(EffectiveType)) {\n      return matchesDecl(S->getDecl(), Finder, Builder);\n    }\n    if (const auto *S = dyn_cast<TemplateTypeParmType>(EffectiveType)) {\n      return matchesDecl(S->getDecl(), Finder, Builder);\n    }\n    if (const auto *S = dyn_cast<TypedefType>(EffectiveType)) {\n      return matchesDecl(S->getDecl(), Finder, Builder);\n    }\n    if (const auto *S = dyn_cast<UnresolvedUsingType>(EffectiveType)) {\n      return matchesDecl(S->getDecl(), Finder, Builder);\n    }\n    if (const auto *S = dyn_cast<ObjCObjectType>(EffectiveType)) {\n      return matchesDecl(S->getInterface(), Finder, Builder);\n    }\n\n    // A SubstTemplateTypeParmType exists solely to mark a type substitution\n    // on the instantiated template. As users usually want to match the\n    // template parameter on the uninitialized template, we can always desugar\n    // one level without loss of expressivness.\n    // For example, given:\n    //   template<typename T> struct X { T t; } class A {}; X<A> a;\n    // The following matcher will match, which otherwise would not:\n    //   fieldDecl(hasType(pointerType())).\n    if (const auto *S = dyn_cast<SubstTemplateTypeParmType>(EffectiveType)) {\n      return matchesSpecialized(S->getReplacementType(), Finder, Builder);\n    }\n\n    // For template specialization types, we want to match the template\n    // declaration, as long as the type is still dependent, and otherwise the\n    // declaration of the instantiated tag type.\n    if (const auto *S = dyn_cast<TemplateSpecializationType>(EffectiveType)) {\n      if (!S->isTypeAlias() && S->isSugared()) {\n        // If the template is non-dependent, we want to match the instantiated\n        // tag type.\n        // For example, given:\n        //   template<typename T> struct X {}; X<int> a;\n        // The following matcher will match, which otherwise would not:\n        //   templateSpecializationType(hasDeclaration(cxxRecordDecl())).\n        return matchesSpecialized(*S->desugar(), Finder, Builder);\n      }\n      // If the template is dependent or an alias, match the template\n      // declaration.\n      return matchesDecl(S->getTemplateName().getAsTemplateDecl(), Finder,\n                         Builder);\n    }\n\n    // FIXME: We desugar elaborated types. This makes the assumption that users\n    // do never want to match on whether a type is elaborated - there are\n    // arguments for both sides; for now, continue desugaring.\n    if (const auto *S = dyn_cast<ElaboratedType>(EffectiveType)) {\n      return matchesSpecialized(S->desugar(), Finder, Builder);\n    }\n    return false;\n  }\n\n  /// Extracts the Decl the DeclRefExpr references and returns whether\n  /// the inner matcher matches on it.\n  bool matchesSpecialized(const DeclRefExpr &Node, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getDecl(), Finder, Builder);\n  }\n\n  /// Extracts the Decl of the callee of a CallExpr and returns whether\n  /// the inner matcher matches on it.\n  bool matchesSpecialized(const CallExpr &Node, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getCalleeDecl(), Finder, Builder);\n  }\n\n  /// Extracts the Decl of the constructor call and returns whether the\n  /// inner matcher matches on it.\n  bool matchesSpecialized(const CXXConstructExpr &Node,\n                          ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getConstructor(), Finder, Builder);\n  }\n\n  bool matchesSpecialized(const ObjCIvarRefExpr &Node,\n                          ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getDecl(), Finder, Builder);\n  }\n\n  /// Extracts the operator new of the new call and returns whether the\n  /// inner matcher matches on it.\n  bool matchesSpecialized(const CXXNewExpr &Node,\n                          ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getOperatorNew(), Finder, Builder);\n  }\n\n  /// Extracts the \\c ValueDecl a \\c MemberExpr refers to and returns\n  /// whether the inner matcher matches on it.\n  bool matchesSpecialized(const MemberExpr &Node,\n                          ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getMemberDecl(), Finder, Builder);\n  }\n\n  /// Extracts the \\c LabelDecl a \\c AddrLabelExpr refers to and returns\n  /// whether the inner matcher matches on it.\n  bool matchesSpecialized(const AddrLabelExpr &Node,\n                          ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getLabel(), Finder, Builder);\n  }\n\n  /// Extracts the declaration of a LabelStmt and returns whether the\n  /// inner matcher matches on it.\n  bool matchesSpecialized(const LabelStmt &Node, ASTMatchFinder *Finder,\n                          BoundNodesTreeBuilder *Builder) const {\n    return matchesDecl(Node.getDecl(), Finder, Builder);\n  }\n\n  /// Returns whether the inner matcher \\c Node. Returns false if \\c Node\n  /// is \\c NULL.\n  bool matchesDecl(const Decl *Node, ASTMatchFinder *Finder,\n                   BoundNodesTreeBuilder *Builder) const {\n    return Node != nullptr &&\n           !(Finder->isTraversalIgnoringImplicitNodes() &&\n             Node->isImplicit()) &&\n           this->InnerMatcher.matches(DynTypedNode::create(*Node), Finder,\n                                      Builder);\n  }\n};\n\n/// IsBaseType<T>::value is true if T is a \"base\" type in the AST\n/// node class hierarchies.\ntemplate <typename T>\nstruct IsBaseType {\n  static const bool value =\n      std::is_same<T, Decl>::value || std::is_same<T, Stmt>::value ||\n      std::is_same<T, QualType>::value || std::is_same<T, Type>::value ||\n      std::is_same<T, TypeLoc>::value ||\n      std::is_same<T, NestedNameSpecifier>::value ||\n      std::is_same<T, NestedNameSpecifierLoc>::value ||\n      std::is_same<T, CXXCtorInitializer>::value ||\n      std::is_same<T, TemplateArgumentLoc>::value;\n};\ntemplate <typename T>\nconst bool IsBaseType<T>::value;\n\n/// A type-list implementation.\n///\n/// A \"linked list\" of types, accessible by using the ::head and ::tail\n/// typedefs.\ntemplate <typename... Ts> struct TypeList {}; // Empty sentinel type list.\n\ntemplate <typename T1, typename... Ts> struct TypeList<T1, Ts...> {\n  /// The first type on the list.\n  using head = T1;\n\n  /// A sublist with the tail. ie everything but the head.\n  ///\n  /// This type is used to do recursion. TypeList<>/EmptyTypeList indicates the\n  /// end of the list.\n  using tail = TypeList<Ts...>;\n};\n\n/// The empty type list.\nusing EmptyTypeList = TypeList<>;\n\n/// Helper meta-function to determine if some type \\c T is present or\n///   a parent type in the list.\ntemplate <typename AnyTypeList, typename T>\nstruct TypeListContainsSuperOf {\n  static const bool value =\n      std::is_base_of<typename AnyTypeList::head, T>::value ||\n      TypeListContainsSuperOf<typename AnyTypeList::tail, T>::value;\n};\ntemplate <typename T>\nstruct TypeListContainsSuperOf<EmptyTypeList, T> {\n  static const bool value = false;\n};\n\n/// A \"type list\" that contains all types.\n///\n/// Useful for matchers like \\c anything and \\c unless.\nusing AllNodeBaseTypes =\n    TypeList<Decl, Stmt, NestedNameSpecifier, NestedNameSpecifierLoc, QualType,\n             Type, TypeLoc, CXXCtorInitializer>;\n\n/// Helper meta-function to extract the argument out of a function of\n///   type void(Arg).\n///\n/// See AST_POLYMORPHIC_SUPPORTED_TYPES for details.\ntemplate <class T> struct ExtractFunctionArgMeta;\ntemplate <class T> struct ExtractFunctionArgMeta<void(T)> {\n  using type = T;\n};\n\ntemplate <class T, class Tuple, std::size_t... I>\nconstexpr T *new_from_tuple_impl(Tuple &&t, std::index_sequence<I...>) {\n  return new T(std::get<I>(std::forward<Tuple>(t))...);\n}\n\ntemplate <class T, class Tuple> constexpr T *new_from_tuple(Tuple &&t) {\n  return new_from_tuple_impl<T>(\n      std::forward<Tuple>(t),\n      std::make_index_sequence<\n          std::tuple_size<std::remove_reference_t<Tuple>>::value>{});\n}\n\n/// Default type lists for ArgumentAdaptingMatcher matchers.\nusing AdaptativeDefaultFromTypes = AllNodeBaseTypes;\nusing AdaptativeDefaultToTypes =\n    TypeList<Decl, Stmt, NestedNameSpecifier, NestedNameSpecifierLoc, TypeLoc,\n             QualType>;\n\n/// All types that are supported by HasDeclarationMatcher above.\nusing HasDeclarationSupportedTypes =\n    TypeList<CallExpr, CXXConstructExpr, CXXNewExpr, DeclRefExpr, EnumType,\n             ElaboratedType, InjectedClassNameType, LabelStmt, AddrLabelExpr,\n             MemberExpr, QualType, RecordType, TagType,\n             TemplateSpecializationType, TemplateTypeParmType, TypedefType,\n             UnresolvedUsingType, ObjCIvarRefExpr>;\n\n/// A Matcher that allows binding the node it matches to an id.\n///\n/// BindableMatcher provides a \\a bind() method that allows binding the\n/// matched node to an id if the match was successful.\ntemplate <typename T> class BindableMatcher : public Matcher<T> {\npublic:\n  explicit BindableMatcher(const Matcher<T> &M) : Matcher<T>(M) {}\n  explicit BindableMatcher(MatcherInterface<T> *Implementation)\n      : Matcher<T>(Implementation) {}\n\n  /// Returns a matcher that will bind the matched node on a match.\n  ///\n  /// The returned matcher is equivalent to this matcher, but will\n  /// bind the matched node on a match.\n  Matcher<T> bind(StringRef ID) const {\n    return DynTypedMatcher(*this)\n        .tryBind(ID)\n        ->template unconditionalConvertTo<T>();\n  }\n\n  /// Same as Matcher<T>'s conversion operator, but enables binding on\n  /// the returned matcher.\n  operator DynTypedMatcher() const {\n    DynTypedMatcher Result = static_cast<const Matcher<T> &>(*this);\n    Result.setAllowBind(true);\n    return Result;\n  }\n};\n\n/// Matches any instance of the given NodeType.\n///\n/// This is useful when a matcher syntactically requires a child matcher,\n/// but the context doesn't care. See for example: anything().\nclass TrueMatcher {\npublic:\n  using ReturnTypes = AllNodeBaseTypes;\n\n  template <typename T> operator Matcher<T>() const {\n    return DynTypedMatcher::trueMatcher(ASTNodeKind::getFromNodeKind<T>())\n        .template unconditionalConvertTo<T>();\n  }\n};\n\n/// Creates a Matcher<T> that matches if all inner matchers match.\ntemplate <typename T>\nBindableMatcher<T>\nmakeAllOfComposite(ArrayRef<const Matcher<T> *> InnerMatchers) {\n  // For the size() == 0 case, we return a \"true\" matcher.\n  if (InnerMatchers.empty()) {\n    return BindableMatcher<T>(TrueMatcher());\n  }\n  // For the size() == 1 case, we simply return that one matcher.\n  // No need to wrap it in a variadic operation.\n  if (InnerMatchers.size() == 1) {\n    return BindableMatcher<T>(*InnerMatchers[0]);\n  }\n\n  using PI = llvm::pointee_iterator<const Matcher<T> *const *>;\n\n  std::vector<DynTypedMatcher> DynMatchers(PI(InnerMatchers.begin()),\n                                           PI(InnerMatchers.end()));\n  return BindableMatcher<T>(\n      DynTypedMatcher::constructVariadic(DynTypedMatcher::VO_AllOf,\n                                         ASTNodeKind::getFromNodeKind<T>(),\n                                         std::move(DynMatchers))\n          .template unconditionalConvertTo<T>());\n}\n\n/// Creates a Matcher<T> that matches if\n/// T is dyn_cast'able into InnerT and all inner matchers match.\n///\n/// Returns BindableMatcher, as matchers that use dyn_cast have\n/// the same object both to match on and to run submatchers on,\n/// so there is no ambiguity with what gets bound.\ntemplate <typename T, typename InnerT>\nBindableMatcher<T>\nmakeDynCastAllOfComposite(ArrayRef<const Matcher<InnerT> *> InnerMatchers) {\n  return BindableMatcher<T>(\n      makeAllOfComposite(InnerMatchers).template dynCastTo<T>());\n}\n\n/// A VariadicDynCastAllOfMatcher<SourceT, TargetT> object is a\n/// variadic functor that takes a number of Matcher<TargetT> and returns a\n/// Matcher<SourceT> that matches TargetT nodes that are matched by all of the\n/// given matchers, if SourceT can be dynamically casted into TargetT.\n///\n/// For example:\n///   const VariadicDynCastAllOfMatcher<Decl, CXXRecordDecl> record;\n/// Creates a functor record(...) that creates a Matcher<Decl> given\n/// a variable number of arguments of type Matcher<CXXRecordDecl>.\n/// The returned matcher matches if the given Decl can by dynamically\n/// casted to CXXRecordDecl and all given matchers match.\ntemplate <typename SourceT, typename TargetT>\nclass VariadicDynCastAllOfMatcher\n    : public VariadicFunction<BindableMatcher<SourceT>, Matcher<TargetT>,\n                              makeDynCastAllOfComposite<SourceT, TargetT>> {\npublic:\n  VariadicDynCastAllOfMatcher() {}\n};\n\n/// A \\c VariadicAllOfMatcher<T> object is a variadic functor that takes\n/// a number of \\c Matcher<T> and returns a \\c Matcher<T> that matches \\c T\n/// nodes that are matched by all of the given matchers.\n///\n/// For example:\n///   const VariadicAllOfMatcher<NestedNameSpecifier> nestedNameSpecifier;\n/// Creates a functor nestedNameSpecifier(...) that creates a\n/// \\c Matcher<NestedNameSpecifier> given a variable number of arguments of type\n/// \\c Matcher<NestedNameSpecifier>.\n/// The returned matcher matches if all given matchers match.\ntemplate <typename T>\nclass VariadicAllOfMatcher\n    : public VariadicFunction<BindableMatcher<T>, Matcher<T>,\n                              makeAllOfComposite<T>> {\npublic:\n  VariadicAllOfMatcher() {}\n};\n\n/// VariadicOperatorMatcher related types.\n/// @{\n\n/// Polymorphic matcher object that uses a \\c\n/// DynTypedMatcher::VariadicOperator operator.\n///\n/// Input matchers can have any type (including other polymorphic matcher\n/// types), and the actual Matcher<T> is generated on demand with an implicit\n/// conversion operator.\ntemplate <typename... Ps> class VariadicOperatorMatcher {\npublic:\n  VariadicOperatorMatcher(DynTypedMatcher::VariadicOperator Op, Ps &&... Params)\n      : Op(Op), Params(std::forward<Ps>(Params)...) {}\n\n  template <typename T> operator Matcher<T>() const {\n    return DynTypedMatcher::constructVariadic(\n               Op, ASTNodeKind::getFromNodeKind<T>(),\n               getMatchers<T>(std::index_sequence_for<Ps...>()))\n        .template unconditionalConvertTo<T>();\n  }\n\nprivate:\n  // Helper method to unpack the tuple into a vector.\n  template <typename T, std::size_t... Is>\n  std::vector<DynTypedMatcher> getMatchers(std::index_sequence<Is...>) const {\n    return {Matcher<T>(std::get<Is>(Params))...};\n  }\n\n  const DynTypedMatcher::VariadicOperator Op;\n  std::tuple<Ps...> Params;\n};\n\n/// Overloaded function object to generate VariadicOperatorMatcher\n///   objects from arbitrary matchers.\ntemplate <unsigned MinCount, unsigned MaxCount>\nstruct VariadicOperatorMatcherFunc {\n  DynTypedMatcher::VariadicOperator Op;\n\n  template <typename... Ms>\n  VariadicOperatorMatcher<Ms...> operator()(Ms &&... Ps) const {\n    static_assert(MinCount <= sizeof...(Ms) && sizeof...(Ms) <= MaxCount,\n                  \"invalid number of parameters for variadic matcher\");\n    return VariadicOperatorMatcher<Ms...>(Op, std::forward<Ms>(Ps)...);\n  }\n};\n\ntemplate <typename F, typename Tuple, std::size_t... I>\nconstexpr auto applyMatcherImpl(F &&f, Tuple &&args,\n                                std::index_sequence<I...>) {\n  return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(args))...);\n}\n\ntemplate <typename F, typename Tuple>\nconstexpr auto applyMatcher(F &&f, Tuple &&args) {\n  return applyMatcherImpl(\n      std::forward<F>(f), std::forward<Tuple>(args),\n      std::make_index_sequence<\n          std::tuple_size<typename std::decay<Tuple>::type>::value>());\n}\n\ntemplate <typename T, bool IsBaseOf, typename Head, typename Tail>\nstruct GetCladeImpl {\n  using Type = Head;\n};\ntemplate <typename T, typename Head, typename Tail>\nstruct GetCladeImpl<T, false, Head, Tail>\n    : GetCladeImpl<T, std::is_base_of<typename Tail::head, T>::value,\n                   typename Tail::head, typename Tail::tail> {};\n\ntemplate <typename T, typename... U>\nstruct GetClade : GetCladeImpl<T, false, T, AllNodeBaseTypes> {};\n\ntemplate <typename CladeType, typename... MatcherTypes>\nstruct MapAnyOfMatcherImpl {\n\n  template <typename... InnerMatchers>\n  BindableMatcher<CladeType>\n  operator()(InnerMatchers &&... InnerMatcher) const {\n    // TODO: Use std::apply from c++17\n    return VariadicAllOfMatcher<CladeType>()(applyMatcher(\n        internal::VariadicOperatorMatcherFunc<\n            0, std::numeric_limits<unsigned>::max()>{\n            internal::DynTypedMatcher::VO_AnyOf},\n        applyMatcher(\n            [&](auto... Matcher) {\n              return std::make_tuple(Matcher(\n                  std::forward<decltype(InnerMatcher)>(InnerMatcher)...)...);\n            },\n            std::tuple<\n                VariadicDynCastAllOfMatcher<CladeType, MatcherTypes>...>())));\n  }\n};\n\ntemplate <typename... MatcherTypes>\nusing MapAnyOfMatcher =\n    MapAnyOfMatcherImpl<typename GetClade<MatcherTypes...>::Type,\n                        MatcherTypes...>;\n\ntemplate <typename... MatcherTypes> struct MapAnyOfHelper {\n  using CladeType = typename GetClade<MatcherTypes...>::Type;\n\n  MapAnyOfMatcher<MatcherTypes...> with;\n\n  operator BindableMatcher<CladeType>() const { return with(); }\n\n  Matcher<CladeType> bind(StringRef ID) const { return with().bind(ID); }\n};\n\ntemplate <template <typename ToArg, typename FromArg> class ArgumentAdapterT,\n          typename T, typename ToTypes>\nclass ArgumentAdaptingMatcherFuncAdaptor {\npublic:\n  explicit ArgumentAdaptingMatcherFuncAdaptor(const Matcher<T> &InnerMatcher)\n      : InnerMatcher(InnerMatcher) {}\n\n  using ReturnTypes = ToTypes;\n\n  template <typename To> operator Matcher<To>() const {\n    return Matcher<To>(new ArgumentAdapterT<To, T>(InnerMatcher));\n  }\n\nprivate:\n  const Matcher<T> InnerMatcher;\n};\n\n/// Converts a \\c Matcher<T> to a matcher of desired type \\c To by\n/// \"adapting\" a \\c To into a \\c T.\n///\n/// The \\c ArgumentAdapterT argument specifies how the adaptation is done.\n///\n/// For example:\n///   \\c ArgumentAdaptingMatcher<HasMatcher, T>(InnerMatcher);\n/// Given that \\c InnerMatcher is of type \\c Matcher<T>, this returns a matcher\n/// that is convertible into any matcher of type \\c To by constructing\n/// \\c HasMatcher<To, T>(InnerMatcher).\n///\n/// If a matcher does not need knowledge about the inner type, prefer to use\n/// PolymorphicMatcher.\ntemplate <template <typename ToArg, typename FromArg> class ArgumentAdapterT,\n          typename FromTypes = AdaptativeDefaultFromTypes,\n          typename ToTypes = AdaptativeDefaultToTypes>\nstruct ArgumentAdaptingMatcherFunc {\n  template <typename T>\n  static ArgumentAdaptingMatcherFuncAdaptor<ArgumentAdapterT, T, ToTypes>\n  create(const Matcher<T> &InnerMatcher) {\n    return ArgumentAdaptingMatcherFuncAdaptor<ArgumentAdapterT, T, ToTypes>(\n        InnerMatcher);\n  }\n\n  template <typename T>\n  ArgumentAdaptingMatcherFuncAdaptor<ArgumentAdapterT, T, ToTypes>\n  operator()(const Matcher<T> &InnerMatcher) const {\n    return create(InnerMatcher);\n  }\n\n  template <typename... T>\n  ArgumentAdaptingMatcherFuncAdaptor<ArgumentAdapterT,\n                                     typename GetClade<T...>::Type, ToTypes>\n  operator()(const MapAnyOfHelper<T...> &InnerMatcher) const {\n    return create(InnerMatcher.with());\n  }\n};\n\ntemplate <typename T> class TraversalMatcher : public MatcherInterface<T> {\n  const DynTypedMatcher InnerMatcher;\n  clang::TraversalKind Traversal;\n\npublic:\n  explicit TraversalMatcher(clang::TraversalKind TK,\n                            const Matcher<T> &InnerMatcher)\n      : InnerMatcher(InnerMatcher), Traversal(TK) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return this->InnerMatcher.matches(DynTypedNode::create(Node), Finder,\n                                      Builder);\n  }\n\n  llvm::Optional<clang::TraversalKind> TraversalKind() const override {\n    if (auto NestedKind = this->InnerMatcher.getTraversalKind())\n      return NestedKind;\n    return Traversal;\n  }\n};\n\ntemplate <typename MatcherType> class TraversalWrapper {\npublic:\n  TraversalWrapper(TraversalKind TK, const MatcherType &InnerMatcher)\n      : TK(TK), InnerMatcher(InnerMatcher) {}\n\n  template <typename T> operator Matcher<T>() const {\n    return internal::DynTypedMatcher::constructRestrictedWrapper(\n               new internal::TraversalMatcher<T>(TK, InnerMatcher),\n               ASTNodeKind::getFromNodeKind<T>())\n        .template unconditionalConvertTo<T>();\n  }\n\nprivate:\n  TraversalKind TK;\n  MatcherType InnerMatcher;\n};\n\n/// A PolymorphicMatcher<MatcherT, P1, ..., PN> object can be\n/// created from N parameters p1, ..., pN (of type P1, ..., PN) and\n/// used as a Matcher<T> where a MatcherT<T, P1, ..., PN>(p1, ..., pN)\n/// can be constructed.\n///\n/// For example:\n/// - PolymorphicMatcher<IsDefinitionMatcher>()\n///   creates an object that can be used as a Matcher<T> for any type T\n///   where an IsDefinitionMatcher<T>() can be constructed.\n/// - PolymorphicMatcher<ValueEqualsMatcher, int>(42)\n///   creates an object that can be used as a Matcher<T> for any type T\n///   where a ValueEqualsMatcher<T, int>(42) can be constructed.\ntemplate <template <typename T, typename... Params> class MatcherT,\n          typename ReturnTypesF, typename... ParamTypes>\nclass PolymorphicMatcher {\npublic:\n  PolymorphicMatcher(const ParamTypes &... Params) : Params(Params...) {}\n\n  using ReturnTypes = typename ExtractFunctionArgMeta<ReturnTypesF>::type;\n\n  template <typename T>\n  operator Matcher<T>() const {\n    static_assert(TypeListContainsSuperOf<ReturnTypes, T>::value,\n                  \"right polymorphic conversion\");\n    return Matcher<T>(new_from_tuple<MatcherT<T, ParamTypes...>>(Params));\n  }\n\nprivate:\n  const std::tuple<ParamTypes...> Params;\n};\n\n/// Matches nodes of type T that have child nodes of type ChildT for\n/// which a specified child matcher matches.\n///\n/// ChildT must be an AST base type.\ntemplate <typename T, typename ChildT>\nclass HasMatcher : public MatcherInterface<T> {\n  const DynTypedMatcher InnerMatcher;\n\npublic:\n  explicit HasMatcher(const Matcher<ChildT> &InnerMatcher)\n      : InnerMatcher(InnerMatcher) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return Finder->matchesChildOf(Node, this->InnerMatcher, Builder,\n                                  ASTMatchFinder::BK_First);\n  }\n};\n\n/// Matches nodes of type T that have child nodes of type ChildT for\n/// which a specified child matcher matches. ChildT must be an AST base\n/// type.\n/// As opposed to the HasMatcher, the ForEachMatcher will produce a match\n/// for each child that matches.\ntemplate <typename T, typename ChildT>\nclass ForEachMatcher : public MatcherInterface<T> {\n  static_assert(IsBaseType<ChildT>::value,\n                \"for each only accepts base type matcher\");\n\n  const DynTypedMatcher InnerMatcher;\n\npublic:\n  explicit ForEachMatcher(const Matcher<ChildT> &InnerMatcher)\n      : InnerMatcher(InnerMatcher) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return Finder->matchesChildOf(\n        Node, this->InnerMatcher, Builder,\n        ASTMatchFinder::BK_All);\n  }\n};\n\n/// @}\n\ntemplate <typename T>\ninline Matcher<T> DynTypedMatcher::unconditionalConvertTo() const {\n  return Matcher<T>(*this);\n}\n\n/// Matches nodes of type T that have at least one descendant node of\n/// type DescendantT for which the given inner matcher matches.\n///\n/// DescendantT must be an AST base type.\ntemplate <typename T, typename DescendantT>\nclass HasDescendantMatcher : public MatcherInterface<T> {\n  static_assert(IsBaseType<DescendantT>::value,\n                \"has descendant only accepts base type matcher\");\n\n  const DynTypedMatcher DescendantMatcher;\n\npublic:\n  explicit HasDescendantMatcher(const Matcher<DescendantT> &DescendantMatcher)\n      : DescendantMatcher(DescendantMatcher) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return Finder->matchesDescendantOf(Node, this->DescendantMatcher, Builder,\n                                       ASTMatchFinder::BK_First);\n  }\n};\n\n/// Matches nodes of type \\c T that have a parent node of type \\c ParentT\n/// for which the given inner matcher matches.\n///\n/// \\c ParentT must be an AST base type.\ntemplate <typename T, typename ParentT>\nclass HasParentMatcher : public MatcherInterface<T> {\n  static_assert(IsBaseType<ParentT>::value,\n                \"has parent only accepts base type matcher\");\n\n  const DynTypedMatcher ParentMatcher;\n\npublic:\n  explicit HasParentMatcher(const Matcher<ParentT> &ParentMatcher)\n      : ParentMatcher(ParentMatcher) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return Finder->matchesAncestorOf(Node, this->ParentMatcher, Builder,\n                                     ASTMatchFinder::AMM_ParentOnly);\n  }\n};\n\n/// Matches nodes of type \\c T that have at least one ancestor node of\n/// type \\c AncestorT for which the given inner matcher matches.\n///\n/// \\c AncestorT must be an AST base type.\ntemplate <typename T, typename AncestorT>\nclass HasAncestorMatcher : public MatcherInterface<T> {\n  static_assert(IsBaseType<AncestorT>::value,\n                \"has ancestor only accepts base type matcher\");\n\n  const DynTypedMatcher AncestorMatcher;\n\npublic:\n  explicit HasAncestorMatcher(const Matcher<AncestorT> &AncestorMatcher)\n      : AncestorMatcher(AncestorMatcher) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return Finder->matchesAncestorOf(Node, this->AncestorMatcher, Builder,\n                                     ASTMatchFinder::AMM_All);\n  }\n};\n\n/// Matches nodes of type T that have at least one descendant node of\n/// type DescendantT for which the given inner matcher matches.\n///\n/// DescendantT must be an AST base type.\n/// As opposed to HasDescendantMatcher, ForEachDescendantMatcher will match\n/// for each descendant node that matches instead of only for the first.\ntemplate <typename T, typename DescendantT>\nclass ForEachDescendantMatcher : public MatcherInterface<T> {\n  static_assert(IsBaseType<DescendantT>::value,\n                \"for each descendant only accepts base type matcher\");\n\n  const DynTypedMatcher DescendantMatcher;\n\npublic:\n  explicit ForEachDescendantMatcher(\n      const Matcher<DescendantT> &DescendantMatcher)\n      : DescendantMatcher(DescendantMatcher) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    return Finder->matchesDescendantOf(Node, this->DescendantMatcher, Builder,\n                                       ASTMatchFinder::BK_All);\n  }\n};\n\n/// Matches on nodes that have a getValue() method if getValue() equals\n/// the value the ValueEqualsMatcher was constructed with.\ntemplate <typename T, typename ValueT>\nclass ValueEqualsMatcher : public SingleNodeMatcherInterface<T> {\n  static_assert(std::is_base_of<CharacterLiteral, T>::value ||\n                std::is_base_of<CXXBoolLiteralExpr, T>::value ||\n                std::is_base_of<FloatingLiteral, T>::value ||\n                std::is_base_of<IntegerLiteral, T>::value,\n                \"the node must have a getValue method\");\n\npublic:\n  explicit ValueEqualsMatcher(const ValueT &ExpectedValue)\n      : ExpectedValue(ExpectedValue) {}\n\n  bool matchesNode(const T &Node) const override {\n    return Node.getValue() == ExpectedValue;\n  }\n\nprivate:\n  const ValueT ExpectedValue;\n};\n\n/// Template specializations to easily write matchers for floating point\n/// literals.\ntemplate <>\ninline bool ValueEqualsMatcher<FloatingLiteral, double>::matchesNode(\n    const FloatingLiteral &Node) const {\n  if ((&Node.getSemantics()) == &llvm::APFloat::IEEEsingle())\n    return Node.getValue().convertToFloat() == ExpectedValue;\n  if ((&Node.getSemantics()) == &llvm::APFloat::IEEEdouble())\n    return Node.getValue().convertToDouble() == ExpectedValue;\n  return false;\n}\ntemplate <>\ninline bool ValueEqualsMatcher<FloatingLiteral, float>::matchesNode(\n    const FloatingLiteral &Node) const {\n  if ((&Node.getSemantics()) == &llvm::APFloat::IEEEsingle())\n    return Node.getValue().convertToFloat() == ExpectedValue;\n  if ((&Node.getSemantics()) == &llvm::APFloat::IEEEdouble())\n    return Node.getValue().convertToDouble() == ExpectedValue;\n  return false;\n}\ntemplate <>\ninline bool ValueEqualsMatcher<FloatingLiteral, llvm::APFloat>::matchesNode(\n    const FloatingLiteral &Node) const {\n  return ExpectedValue.compare(Node.getValue()) == llvm::APFloat::cmpEqual;\n}\n\n/// Matches nodes of type \\c TLoc for which the inner\n/// \\c Matcher<T> matches.\ntemplate <typename TLoc, typename T>\nclass LocMatcher : public MatcherInterface<TLoc> {\n  const DynTypedMatcher InnerMatcher;\n\npublic:\n  explicit LocMatcher(const Matcher<T> &InnerMatcher)\n      : InnerMatcher(InnerMatcher) {}\n\n  bool matches(const TLoc &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    if (!Node)\n      return false;\n    return this->InnerMatcher.matches(extract(Node), Finder, Builder);\n  }\n\nprivate:\n  static DynTypedNode extract(const NestedNameSpecifierLoc &Loc) {\n    return DynTypedNode::create(*Loc.getNestedNameSpecifier());\n  }\n};\n\n/// Matches \\c TypeLocs based on an inner matcher matching a certain\n/// \\c QualType.\n///\n/// Used to implement the \\c loc() matcher.\nclass TypeLocTypeMatcher : public MatcherInterface<TypeLoc> {\n  const DynTypedMatcher InnerMatcher;\n\npublic:\n  explicit TypeLocTypeMatcher(const Matcher<QualType> &InnerMatcher)\n      : InnerMatcher(InnerMatcher) {}\n\n  bool matches(const TypeLoc &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    if (!Node)\n      return false;\n    return this->InnerMatcher.matches(DynTypedNode::create(Node.getType()),\n                                      Finder, Builder);\n  }\n};\n\n/// Matches nodes of type \\c T for which the inner matcher matches on a\n/// another node of type \\c T that can be reached using a given traverse\n/// function.\ntemplate <typename T> class TypeTraverseMatcher : public MatcherInterface<T> {\n  const DynTypedMatcher InnerMatcher;\n\npublic:\n  explicit TypeTraverseMatcher(const Matcher<QualType> &InnerMatcher,\n                               QualType (T::*TraverseFunction)() const)\n      : InnerMatcher(InnerMatcher), TraverseFunction(TraverseFunction) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    QualType NextNode = (Node.*TraverseFunction)();\n    if (NextNode.isNull())\n      return false;\n    return this->InnerMatcher.matches(DynTypedNode::create(NextNode), Finder,\n                                      Builder);\n  }\n\nprivate:\n  QualType (T::*TraverseFunction)() const;\n};\n\n/// Matches nodes of type \\c T in a ..Loc hierarchy, for which the inner\n/// matcher matches on a another node of type \\c T that can be reached using a\n/// given traverse function.\ntemplate <typename T>\nclass TypeLocTraverseMatcher : public MatcherInterface<T> {\n  const DynTypedMatcher InnerMatcher;\n\npublic:\n  explicit TypeLocTraverseMatcher(const Matcher<TypeLoc> &InnerMatcher,\n                                  TypeLoc (T::*TraverseFunction)() const)\n      : InnerMatcher(InnerMatcher), TraverseFunction(TraverseFunction) {}\n\n  bool matches(const T &Node, ASTMatchFinder *Finder,\n               BoundNodesTreeBuilder *Builder) const override {\n    TypeLoc NextNode = (Node.*TraverseFunction)();\n    if (!NextNode)\n      return false;\n    return this->InnerMatcher.matches(DynTypedNode::create(NextNode), Finder,\n                                      Builder);\n  }\n\nprivate:\n  TypeLoc (T::*TraverseFunction)() const;\n};\n\n/// Converts a \\c Matcher<InnerT> to a \\c Matcher<OuterT>, where\n/// \\c OuterT is any type that is supported by \\c Getter.\n///\n/// \\code Getter<OuterT>::value() \\endcode returns a\n/// \\code InnerTBase (OuterT::*)() \\endcode, which is used to adapt a \\c OuterT\n/// object into a \\c InnerT\ntemplate <typename InnerTBase,\n          template <typename OuterT> class Getter,\n          template <typename OuterT> class MatcherImpl,\n          typename ReturnTypesF>\nclass TypeTraversePolymorphicMatcher {\nprivate:\n  using Self = TypeTraversePolymorphicMatcher<InnerTBase, Getter, MatcherImpl,\n                                              ReturnTypesF>;\n\n  static Self create(ArrayRef<const Matcher<InnerTBase> *> InnerMatchers);\n\npublic:\n  using ReturnTypes = typename ExtractFunctionArgMeta<ReturnTypesF>::type;\n\n  explicit TypeTraversePolymorphicMatcher(\n      ArrayRef<const Matcher<InnerTBase> *> InnerMatchers)\n      : InnerMatcher(makeAllOfComposite(InnerMatchers)) {}\n\n  template <typename OuterT> operator Matcher<OuterT>() const {\n    return Matcher<OuterT>(\n        new MatcherImpl<OuterT>(InnerMatcher, Getter<OuterT>::value()));\n  }\n\n  struct Func\n      : public VariadicFunction<Self, Matcher<InnerTBase>, &Self::create> {\n    Func() {}\n  };\n\nprivate:\n  const Matcher<InnerTBase> InnerMatcher;\n};\n\n/// A simple memoizer of T(*)() functions.\n///\n/// It will call the passed 'Func' template parameter at most once.\n/// Used to support AST_MATCHER_FUNCTION() macro.\ntemplate <typename Matcher, Matcher (*Func)()> class MemoizedMatcher {\n  struct Wrapper {\n    Wrapper() : M(Func()) {}\n\n    Matcher M;\n  };\n\npublic:\n  static const Matcher &getInstance() {\n    static llvm::ManagedStatic<Wrapper> Instance;\n    return Instance->M;\n  }\n};\n\n// Define the create() method out of line to silence a GCC warning about\n// the struct \"Func\" having greater visibility than its base, which comes from\n// using the flag -fvisibility-inlines-hidden.\ntemplate <typename InnerTBase, template <typename OuterT> class Getter,\n          template <typename OuterT> class MatcherImpl, typename ReturnTypesF>\nTypeTraversePolymorphicMatcher<InnerTBase, Getter, MatcherImpl, ReturnTypesF>\nTypeTraversePolymorphicMatcher<\n    InnerTBase, Getter, MatcherImpl,\n    ReturnTypesF>::create(ArrayRef<const Matcher<InnerTBase> *> InnerMatchers) {\n  return Self(InnerMatchers);\n}\n\n// FIXME: unify ClassTemplateSpecializationDecl and TemplateSpecializationType's\n// APIs for accessing the template argument list.\ninline ArrayRef<TemplateArgument>\ngetTemplateSpecializationArgs(const ClassTemplateSpecializationDecl &D) {\n  return D.getTemplateArgs().asArray();\n}\n\ninline ArrayRef<TemplateArgument>\ngetTemplateSpecializationArgs(const TemplateSpecializationType &T) {\n  return llvm::makeArrayRef(T.getArgs(), T.getNumArgs());\n}\n\ninline ArrayRef<TemplateArgument>\ngetTemplateSpecializationArgs(const FunctionDecl &FD) {\n  if (const auto* TemplateArgs = FD.getTemplateSpecializationArgs())\n    return TemplateArgs->asArray();\n  return ArrayRef<TemplateArgument>();\n}\n\nstruct NotEqualsBoundNodePredicate {\n  bool operator()(const internal::BoundNodesMap &Nodes) const {\n    return Nodes.getNode(ID) != Node;\n  }\n\n  std::string ID;\n  DynTypedNode Node;\n};\n\ntemplate <typename Ty, typename Enable = void> struct GetBodyMatcher {\n  static const Stmt *get(const Ty &Node) { return Node.getBody(); }\n};\n\ntemplate <typename Ty>\nstruct GetBodyMatcher<Ty, typename std::enable_if<\n                              std::is_base_of<FunctionDecl, Ty>::value>::type> {\n  static const Stmt *get(const Ty &Node) {\n    return Node.doesThisDeclarationHaveABody() ? Node.getBody() : nullptr;\n  }\n};\n\ntemplate <typename NodeType>\ninline Optional<BinaryOperatorKind>\nequivalentBinaryOperator(const NodeType &Node) {\n  return Node.getOpcode();\n}\n\ntemplate <>\ninline Optional<BinaryOperatorKind>\nequivalentBinaryOperator<CXXOperatorCallExpr>(const CXXOperatorCallExpr &Node) {\n  if (Node.getNumArgs() != 2)\n    return None;\n  switch (Node.getOperator()) {\n  default:\n    return None;\n  case OO_ArrowStar:\n    return BO_PtrMemI;\n  case OO_Star:\n    return BO_Mul;\n  case OO_Slash:\n    return BO_Div;\n  case OO_Percent:\n    return BO_Rem;\n  case OO_Plus:\n    return BO_Add;\n  case OO_Minus:\n    return BO_Sub;\n  case OO_LessLess:\n    return BO_Shl;\n  case OO_GreaterGreater:\n    return BO_Shr;\n  case OO_Spaceship:\n    return BO_Cmp;\n  case OO_Less:\n    return BO_LT;\n  case OO_Greater:\n    return BO_GT;\n  case OO_LessEqual:\n    return BO_LE;\n  case OO_GreaterEqual:\n    return BO_GE;\n  case OO_EqualEqual:\n    return BO_EQ;\n  case OO_ExclaimEqual:\n    return BO_NE;\n  case OO_Amp:\n    return BO_And;\n  case OO_Caret:\n    return BO_Xor;\n  case OO_Pipe:\n    return BO_Or;\n  case OO_AmpAmp:\n    return BO_LAnd;\n  case OO_PipePipe:\n    return BO_LOr;\n  case OO_Equal:\n    return BO_Assign;\n  case OO_StarEqual:\n    return BO_MulAssign;\n  case OO_SlashEqual:\n    return BO_DivAssign;\n  case OO_PercentEqual:\n    return BO_RemAssign;\n  case OO_PlusEqual:\n    return BO_AddAssign;\n  case OO_MinusEqual:\n    return BO_SubAssign;\n  case OO_LessLessEqual:\n    return BO_ShlAssign;\n  case OO_GreaterGreaterEqual:\n    return BO_ShrAssign;\n  case OO_AmpEqual:\n    return BO_AndAssign;\n  case OO_CaretEqual:\n    return BO_XorAssign;\n  case OO_PipeEqual:\n    return BO_OrAssign;\n  case OO_Comma:\n    return BO_Comma;\n  }\n}\n\ntemplate <typename NodeType>\ninline Optional<UnaryOperatorKind>\nequivalentUnaryOperator(const NodeType &Node) {\n  return Node.getOpcode();\n}\n\ntemplate <>\ninline Optional<UnaryOperatorKind>\nequivalentUnaryOperator<CXXOperatorCallExpr>(const CXXOperatorCallExpr &Node) {\n  if (Node.getNumArgs() != 1 && Node.getOperator() != OO_PlusPlus &&\n      Node.getOperator() != OO_MinusMinus)\n    return None;\n  switch (Node.getOperator()) {\n  default:\n    return None;\n  case OO_Plus:\n    return UO_Plus;\n  case OO_Minus:\n    return UO_Minus;\n  case OO_Amp:\n    return UO_AddrOf;\n  case OO_Tilde:\n    return UO_Not;\n  case OO_Exclaim:\n    return UO_LNot;\n  case OO_PlusPlus: {\n    const auto *FD = Node.getDirectCallee();\n    if (!FD)\n      return None;\n    return FD->getNumParams() > 0 ? UO_PostInc : UO_PreInc;\n  }\n  case OO_MinusMinus: {\n    const auto *FD = Node.getDirectCallee();\n    if (!FD)\n      return None;\n    return FD->getNumParams() > 0 ? UO_PostDec : UO_PreDec;\n  }\n  case OO_Coawait:\n    return UO_Coawait;\n  }\n}\n\ntemplate <typename NodeType> inline const Expr *getLHS(const NodeType &Node) {\n  return Node.getLHS();\n}\ntemplate <>\ninline const Expr *\ngetLHS<CXXOperatorCallExpr>(const CXXOperatorCallExpr &Node) {\n  if (!internal::equivalentBinaryOperator(Node))\n    return nullptr;\n  return Node.getArg(0);\n}\ntemplate <typename NodeType> inline const Expr *getRHS(const NodeType &Node) {\n  return Node.getRHS();\n}\ntemplate <>\ninline const Expr *\ngetRHS<CXXOperatorCallExpr>(const CXXOperatorCallExpr &Node) {\n  if (!internal::equivalentBinaryOperator(Node))\n    return nullptr;\n  return Node.getArg(1);\n}\ntemplate <typename NodeType>\ninline const Expr *getSubExpr(const NodeType &Node) {\n  return Node.getSubExpr();\n}\ntemplate <>\ninline const Expr *\ngetSubExpr<CXXOperatorCallExpr>(const CXXOperatorCallExpr &Node) {\n  if (!internal::equivalentUnaryOperator(Node))\n    return nullptr;\n  return Node.getArg(0);\n}\n\ntemplate <typename Ty>\nstruct HasSizeMatcher {\n  static bool hasSize(const Ty &Node, unsigned int N) {\n    return Node.getSize() == N;\n  }\n};\n\ntemplate <>\ninline bool HasSizeMatcher<StringLiteral>::hasSize(\n    const StringLiteral &Node, unsigned int N) {\n  return Node.getLength() == N;\n}\n\ntemplate <typename Ty>\nstruct GetSourceExpressionMatcher {\n  static const Expr *get(const Ty &Node) {\n    return Node.getSubExpr();\n  }\n};\n\ntemplate <>\ninline const Expr *GetSourceExpressionMatcher<OpaqueValueExpr>::get(\n    const OpaqueValueExpr &Node) {\n  return Node.getSourceExpr();\n}\n\ntemplate <typename Ty>\nstruct CompoundStmtMatcher {\n  static const CompoundStmt *get(const Ty &Node) {\n    return &Node;\n  }\n};\n\ntemplate <>\ninline const CompoundStmt *\nCompoundStmtMatcher<StmtExpr>::get(const StmtExpr &Node) {\n  return Node.getSubStmt();\n}\n\n/// If \\p Loc is (transitively) expanded from macro \\p MacroName, returns the\n/// location (in the chain of expansions) at which \\p MacroName was\n/// expanded. Since the macro may have been expanded inside a series of\n/// expansions, that location may itself be a MacroID.\nllvm::Optional<SourceLocation>\ngetExpansionLocOfMacro(StringRef MacroName, SourceLocation Loc,\n                       const ASTContext &Context);\n\ninline Optional<StringRef> getOpName(const UnaryOperator &Node) {\n  return Node.getOpcodeStr(Node.getOpcode());\n}\ninline Optional<StringRef> getOpName(const BinaryOperator &Node) {\n  return Node.getOpcodeStr();\n}\ninline StringRef getOpName(const CXXRewrittenBinaryOperator &Node) {\n  return Node.getOpcodeStr();\n}\ninline Optional<StringRef> getOpName(const CXXOperatorCallExpr &Node) {\n  auto optBinaryOpcode = equivalentBinaryOperator(Node);\n  if (!optBinaryOpcode) {\n    auto optUnaryOpcode = equivalentUnaryOperator(Node);\n    if (!optUnaryOpcode)\n      return None;\n    return UnaryOperator::getOpcodeStr(*optUnaryOpcode);\n  }\n  return BinaryOperator::getOpcodeStr(*optBinaryOpcode);\n}\n\n/// Matches overloaded operators with a specific name.\n///\n/// The type argument ArgT is not used by this matcher but is used by\n/// PolymorphicMatcher and should be std::vector<std::string>>.\ntemplate <typename T, typename ArgT = std::vector<std::string>>\nclass HasAnyOperatorNameMatcher : public SingleNodeMatcherInterface<T> {\n  static_assert(std::is_same<T, BinaryOperator>::value ||\n                    std::is_same<T, CXXOperatorCallExpr>::value ||\n                    std::is_same<T, CXXRewrittenBinaryOperator>::value ||\n                    std::is_same<T, UnaryOperator>::value,\n                \"Matcher only supports `BinaryOperator`, `UnaryOperator`, \"\n                \"`CXXOperatorCallExpr` and `CXXRewrittenBinaryOperator`\");\n  static_assert(std::is_same<ArgT, std::vector<std::string>>::value,\n                \"Matcher ArgT must be std::vector<std::string>\");\n\npublic:\n  explicit HasAnyOperatorNameMatcher(std::vector<std::string> Names)\n      : SingleNodeMatcherInterface<T>(), Names(std::move(Names)) {}\n\n  bool matchesNode(const T &Node) const override {\n    Optional<StringRef> OptOpName = getOpName(Node);\n    if (!OptOpName)\n      return false;\n    return llvm::any_of(Names, [OpName = *OptOpName](const std::string &Name) {\n      return Name == OpName;\n    });\n  }\n\nprivate:\n  static Optional<StringRef> getOpName(const UnaryOperator &Node) {\n    return Node.getOpcodeStr(Node.getOpcode());\n  }\n  static Optional<StringRef> getOpName(const BinaryOperator &Node) {\n    return Node.getOpcodeStr();\n  }\n  static StringRef getOpName(const CXXRewrittenBinaryOperator &Node) {\n    return Node.getOpcodeStr();\n  }\n  static Optional<StringRef> getOpName(const CXXOperatorCallExpr &Node) {\n    auto optBinaryOpcode = equivalentBinaryOperator(Node);\n    if (!optBinaryOpcode) {\n      auto optUnaryOpcode = equivalentUnaryOperator(Node);\n      if (!optUnaryOpcode)\n        return None;\n      return UnaryOperator::getOpcodeStr(*optUnaryOpcode);\n    }\n    return BinaryOperator::getOpcodeStr(*optBinaryOpcode);\n  }\n\n  const std::vector<std::string> Names;\n};\n\nusing HasOpNameMatcher =\n    PolymorphicMatcher<HasAnyOperatorNameMatcher,\n                       void(\n                           TypeList<BinaryOperator, CXXOperatorCallExpr,\n                                    CXXRewrittenBinaryOperator, UnaryOperator>),\n                       std::vector<std::string>>;\n\nHasOpNameMatcher hasAnyOperatorNameFunc(ArrayRef<const StringRef *> NameRefs);\n\nusing HasOverloadOpNameMatcher =\n    PolymorphicMatcher<HasOverloadedOperatorNameMatcher,\n                       void(TypeList<CXXOperatorCallExpr, FunctionDecl>),\n                       std::vector<std::string>>;\n\nHasOverloadOpNameMatcher\nhasAnyOverloadedOperatorNameFunc(ArrayRef<const StringRef *> NameRefs);\n\n/// Returns true if \\p Node has a base specifier matching \\p BaseSpec.\n///\n/// A class is not considered to be derived from itself.\nbool matchesAnyBase(const CXXRecordDecl &Node,\n                    const Matcher<CXXBaseSpecifier> &BaseSpecMatcher,\n                    ASTMatchFinder *Finder, BoundNodesTreeBuilder *Builder);\n\nstd::shared_ptr<llvm::Regex> createAndVerifyRegex(StringRef Regex,\n                                                  llvm::Regex::RegexFlags Flags,\n                                                  StringRef MatcherID);\n\n} // namespace internal\n\n} // namespace ast_matchers\n\n} // namespace clang\n\n#endif // LLVM_CLANG_ASTMATCHERS_ASTMATCHERSINTERNAL_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h", "content": "//=== RetainSummaryManager.h - Summaries for reference counting ---*- C++ -*--//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines summaries implementation for retain counting, which\n//  implements a reference count checker for Core Foundation and Cocoa\n//  on (Mac OS X).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_RETAINSUMMARY_MANAGER_H\n#define LLVM_CLANG_ANALYSIS_RETAINSUMMARY_MANAGER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableMap.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/ParentMap.h\"\n#include \"clang/Analysis/AnyCall.h\"\n#include \"clang/Analysis/SelectorExtras.h\"\n#include \"llvm/ADT/STLExtras.h\"\n\nusing namespace clang;\n\nnamespace clang {\nnamespace ento {\n\n/// Determines the object kind of a tracked object.\nenum class ObjKind {\n  /// Indicates that the tracked object is a CF object.\n  CF,\n\n  /// Indicates that the tracked object is an Objective-C object.\n  ObjC,\n\n  /// Indicates that the tracked object could be a CF or Objective-C object.\n  AnyObj,\n\n  /// Indicates that the tracked object is a generalized object.\n  Generalized,\n\n  /// Indicates that the tracking object is a descendant of a\n  /// referenced-counted OSObject, used in the Darwin kernel.\n  OS\n};\n\nenum ArgEffectKind {\n  /// There is no effect.\n  DoNothing,\n\n  /// The argument is treated as if an -autorelease message had been sent to\n  /// the referenced object.\n  Autorelease,\n\n  /// The argument is treated as if the referenced object was deallocated.\n  Dealloc,\n\n  /// The argument has its reference count decreased by 1.\n  DecRef,\n\n  /// The argument has its reference count decreased by 1 to model\n  /// a transferred bridge cast under ARC.\n  DecRefBridgedTransferred,\n\n  /// The argument has its reference count increased by 1.\n  IncRef,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +0 value.\n  UnretainedOutParameter,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +1 value.\n  RetainedOutParameter,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +1 value iff the return code is zero.\n  RetainedOutParameterOnZero,\n\n  /// The argument is a pointer to a retain-counted object; on exit, the new\n  /// value of the pointer is a +1 value iff the return code is non-zero.\n  RetainedOutParameterOnNonZero,\n\n  /// The argument is treated as potentially escaping, meaning that\n  /// even when its reference count hits 0 it should be treated as still\n  /// possibly being alive as someone else *may* be holding onto the object.\n  MayEscape,\n\n  /// All typestate tracking of the object ceases.  This is usually employed\n  /// when the effect of the call is completely unknown.\n  StopTracking,\n\n  /// All typestate tracking of the object ceases.  Unlike StopTracking,\n  /// this is also enforced when the method body is inlined.\n  ///\n  /// In some cases, we obtain a better summary for this checker\n  /// by looking at the call site than by inlining the function.\n  /// Signifies that we should stop tracking the symbol even if\n  /// the function is inlined.\n  StopTrackingHard,\n\n  /// Performs the combined functionality of DecRef and StopTrackingHard.\n  ///\n  /// The models the effect that the called function decrements the reference\n  /// count of the argument and all typestate tracking on that argument\n  /// should cease.\n  DecRefAndStopTrackingHard,\n};\n\n/// An ArgEffect summarizes the retain count behavior on an argument or receiver\n/// to a function or method.\nclass ArgEffect {\n  ArgEffectKind K;\n  ObjKind O;\npublic:\n  explicit ArgEffect(ArgEffectKind K = DoNothing, ObjKind O = ObjKind::AnyObj)\n      : K(K), O(O) {}\n\n  ArgEffectKind getKind() const { return K; }\n  ObjKind getObjKind() const { return O; }\n\n  ArgEffect withKind(ArgEffectKind NewK) {\n    return ArgEffect(NewK, O);\n  }\n\n  bool operator==(const ArgEffect &Other) const {\n    return K == Other.K && O == Other.O;\n  }\n};\n\n/// RetEffect summarizes a call's retain/release behavior with respect\n/// to its return value.\nclass RetEffect {\npublic:\n  enum Kind {\n    /// Indicates that no retain count information is tracked for\n    /// the return value.\n    NoRet,\n\n    /// Indicates that the returned value is an owned (+1) symbol.\n    OwnedSymbol,\n\n    /// Indicates that the returned value is an object with retain count\n    /// semantics but that it is not owned (+0).  This is the default\n    /// for getters, etc.\n    NotOwnedSymbol,\n\n    /// Indicates that the return value is an owned object when the\n    /// receiver is also a tracked object.\n    OwnedWhenTrackedReceiver,\n\n    // Treat this function as returning a non-tracked symbol even if\n    // the function has been inlined. This is used where the call\n    // site summary is more precise than the summary indirectly produced\n    // by inlining the function\n    NoRetHard\n  };\n\nprivate:\n  Kind K;\n  ObjKind O;\n\n  RetEffect(Kind k, ObjKind o = ObjKind::AnyObj) : K(k), O(o) {}\n\npublic:\n  Kind getKind() const { return K; }\n\n  ObjKind getObjKind() const { return O; }\n\n  bool isOwned() const {\n    return K == OwnedSymbol || K == OwnedWhenTrackedReceiver;\n  }\n\n  bool notOwned() const {\n    return K == NotOwnedSymbol;\n  }\n\n  bool operator==(const RetEffect &Other) const {\n    return K == Other.K && O == Other.O;\n  }\n\n  static RetEffect MakeOwnedWhenTrackedReceiver() {\n    return RetEffect(OwnedWhenTrackedReceiver, ObjKind::ObjC);\n  }\n\n  static RetEffect MakeOwned(ObjKind o) {\n    return RetEffect(OwnedSymbol, o);\n  }\n  static RetEffect MakeNotOwned(ObjKind o) {\n    return RetEffect(NotOwnedSymbol, o);\n  }\n  static RetEffect MakeNoRet() {\n    return RetEffect(NoRet);\n  }\n  static RetEffect MakeNoRetHard() {\n    return RetEffect(NoRetHard);\n  }\n};\n\n/// A key identifying a summary.\nclass ObjCSummaryKey {\n  IdentifierInfo* II;\n  Selector S;\npublic:\n  ObjCSummaryKey(IdentifierInfo* ii, Selector s)\n    : II(ii), S(s) {}\n\n  ObjCSummaryKey(const ObjCInterfaceDecl *d, Selector s)\n    : II(d ? d->getIdentifier() : nullptr), S(s) {}\n\n  ObjCSummaryKey(Selector s)\n    : II(nullptr), S(s) {}\n\n  IdentifierInfo *getIdentifier() const { return II; }\n  Selector getSelector() const { return S; }\n};\n\n} // end namespace ento\n} // end namespace clang\n\nusing namespace ento;\n\nnamespace llvm {\n\n//===----------------------------------------------------------------------===//\n// Adapters for FoldingSet.\n//===----------------------------------------------------------------------===//\ntemplate <> struct FoldingSetTrait<ArgEffect> {\nstatic inline void Profile(const ArgEffect X, FoldingSetNodeID &ID) {\n  ID.AddInteger((unsigned) X.getKind());\n  ID.AddInteger((unsigned) X.getObjKind());\n}\n};\ntemplate <> struct FoldingSetTrait<RetEffect> {\n  static inline void Profile(const RetEffect &X, FoldingSetNodeID &ID) {\n    ID.AddInteger((unsigned) X.getKind());\n    ID.AddInteger((unsigned) X.getObjKind());\n}\n};\n\ntemplate <> struct DenseMapInfo<ObjCSummaryKey> {\n  static inline ObjCSummaryKey getEmptyKey() {\n    return ObjCSummaryKey(DenseMapInfo<IdentifierInfo*>::getEmptyKey(),\n                          DenseMapInfo<Selector>::getEmptyKey());\n  }\n\n  static inline ObjCSummaryKey getTombstoneKey() {\n    return ObjCSummaryKey(DenseMapInfo<IdentifierInfo*>::getTombstoneKey(),\n                          DenseMapInfo<Selector>::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const ObjCSummaryKey &V) {\n    typedef std::pair<IdentifierInfo*, Selector> PairTy;\n    return DenseMapInfo<PairTy>::getHashValue(PairTy(V.getIdentifier(),\n                                                     V.getSelector()));\n  }\n\n  static bool isEqual(const ObjCSummaryKey& LHS, const ObjCSummaryKey& RHS) {\n    return LHS.getIdentifier() == RHS.getIdentifier() &&\n           LHS.getSelector() == RHS.getSelector();\n  }\n\n};\n\n} // end llvm namespace\n\n\nnamespace clang {\nnamespace ento {\n\n/// ArgEffects summarizes the effects of a function/method call on all of\n/// its arguments.\ntypedef llvm::ImmutableMap<unsigned, ArgEffect> ArgEffects;\n\n/// Summary for a function with respect to ownership changes.\nclass RetainSummary {\n  /// Args - a map of (index, ArgEffect) pairs, where index\n  ///  specifies the argument (starting from 0).  This can be sparsely\n  ///  populated; arguments with no entry in Args use 'DefaultArgEffect'.\n  ArgEffects Args;\n\n  /// DefaultArgEffect - The default ArgEffect to apply to arguments that\n  ///  do not have an entry in Args.\n  ArgEffect DefaultArgEffect;\n\n  /// Receiver - If this summary applies to an Objective-C message expression,\n  ///  this is the effect applied to the state of the receiver.\n  ArgEffect Receiver;\n\n  /// Effect on \"this\" pointer - applicable only to C++ method calls.\n  ArgEffect This;\n\n  /// Ret - The effect on the return value.  Used to indicate if the\n  ///  function/method call returns a new tracked symbol.\n  RetEffect Ret;\n\npublic:\n  RetainSummary(ArgEffects A,\n                RetEffect R,\n                ArgEffect defaultEff,\n                ArgEffect ReceiverEff,\n                ArgEffect ThisEff)\n    : Args(A), DefaultArgEffect(defaultEff), Receiver(ReceiverEff),\n      This(ThisEff), Ret(R) {}\n\n  /// getArg - Return the argument effect on the argument specified by\n  ///  idx (starting from 0).\n  ArgEffect getArg(unsigned idx) const {\n    if (const ArgEffect *AE = Args.lookup(idx))\n      return *AE;\n\n    return DefaultArgEffect;\n  }\n\n  void addArg(ArgEffects::Factory &af, unsigned idx, ArgEffect e) {\n    Args = af.add(Args, idx, e);\n  }\n\n  /// setDefaultArgEffect - Set the default argument effect.\n  void setDefaultArgEffect(ArgEffect E) {\n    DefaultArgEffect = E;\n  }\n\n  /// getRetEffect - Returns the effect on the return value of the call.\n  RetEffect getRetEffect() const { return Ret; }\n\n  /// setRetEffect - Set the effect of the return value of the call.\n  void setRetEffect(RetEffect E) { Ret = E; }\n\n\n  /// Sets the effect on the receiver of the message.\n  void setReceiverEffect(ArgEffect e) { Receiver = e; }\n\n  /// getReceiverEffect - Returns the effect on the receiver of the call.\n  ///  This is only meaningful if the summary applies to an ObjCMessageExpr*.\n  ArgEffect getReceiverEffect() const { return Receiver; }\n\n  /// \\return the effect on the \"this\" receiver of the method call.\n  /// This is only meaningful if the summary applies to CXXMethodDecl*.\n  ArgEffect getThisEffect() const { return This; }\n\n  ArgEffect getDefaultEffect() const { return DefaultArgEffect; }\n\n  /// Set the effect of the method on \"this\".\n  void setThisEffect(ArgEffect e) { This = e; }\n\n  bool isNoop() const {\n    return Ret == RetEffect::MakeNoRet() && Receiver.getKind() == DoNothing\n      && DefaultArgEffect.getKind() == MayEscape && This.getKind() == DoNothing\n      && Args.isEmpty();\n  }\n\n  /// Test if two retain summaries are identical. Note that merely equivalent\n  /// summaries are not necessarily identical (for example, if an explicit\n  /// argument effect matches the default effect).\n  bool operator==(const RetainSummary &Other) const {\n    return Args == Other.Args && DefaultArgEffect == Other.DefaultArgEffect &&\n           Receiver == Other.Receiver && This == Other.This && Ret == Other.Ret;\n  }\n\n  /// Profile this summary for inclusion in a FoldingSet.\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.Add(Args);\n    ID.Add(DefaultArgEffect);\n    ID.Add(Receiver);\n    ID.Add(This);\n    ID.Add(Ret);\n  }\n\n  /// A retain summary is simple if it has no ArgEffects other than the default.\n  bool isSimple() const {\n    return Args.isEmpty();\n  }\n\n  ArgEffects getArgEffects() const { return Args; }\n\nprivate:\n  ArgEffect getDefaultArgEffect() const { return DefaultArgEffect; }\n\n  friend class RetainSummaryManager;\n};\n\nclass ObjCSummaryCache {\n  typedef llvm::DenseMap<ObjCSummaryKey, const RetainSummary *> MapTy;\n  MapTy M;\npublic:\n  ObjCSummaryCache() {}\n\n  const RetainSummary * find(const ObjCInterfaceDecl *D, Selector S) {\n    // Do a lookup with the (D,S) pair.  If we find a match return\n    // the iterator.\n    ObjCSummaryKey K(D, S);\n    MapTy::iterator I = M.find(K);\n\n    if (I != M.end())\n      return I->second;\n    if (!D)\n      return nullptr;\n\n    // Walk the super chain.  If we find a hit with a parent, we'll end\n    // up returning that summary.  We actually allow that key (null,S), as\n    // we cache summaries for the null ObjCInterfaceDecl* to allow us to\n    // generate initial summaries without having to worry about NSObject\n    // being declared.\n    // FIXME: We may change this at some point.\n    for (ObjCInterfaceDecl *C=D->getSuperClass() ;; C=C->getSuperClass()) {\n      if ((I = M.find(ObjCSummaryKey(C, S))) != M.end())\n        break;\n\n      if (!C)\n        return nullptr;\n    }\n\n    // Cache the summary with original key to make the next lookup faster\n    // and return the iterator.\n    const RetainSummary *Summ = I->second;\n    M[K] = Summ;\n    return Summ;\n  }\n\n  const RetainSummary *find(IdentifierInfo* II, Selector S) {\n    // FIXME: Class method lookup.  Right now we don't have a good way\n    // of going between IdentifierInfo* and the class hierarchy.\n    MapTy::iterator I = M.find(ObjCSummaryKey(II, S));\n\n    if (I == M.end())\n      I = M.find(ObjCSummaryKey(S));\n\n    return I == M.end() ? nullptr : I->second;\n  }\n\n  const RetainSummary *& operator[](ObjCSummaryKey K) {\n    return M[K];\n  }\n\n  const RetainSummary *& operator[](Selector S) {\n    return M[ ObjCSummaryKey(S) ];\n  }\n};\n\nclass RetainSummaryTemplate;\n\nclass RetainSummaryManager {\n  typedef llvm::DenseMap<const FunctionDecl*, const RetainSummary *>\n          FuncSummariesTy;\n\n  typedef ObjCSummaryCache ObjCMethodSummariesTy;\n\n  typedef llvm::FoldingSetNodeWrapper<RetainSummary> CachedSummaryNode;\n\n  /// Ctx - The ASTContext object for the analyzed ASTs.\n  ASTContext &Ctx;\n\n  /// Records whether or not the analyzed code runs in ARC mode.\n  const bool ARCEnabled;\n\n  /// Track Objective-C and CoreFoundation objects.\n  const bool TrackObjCAndCFObjects;\n\n  /// Track sublcasses of OSObject.\n  const bool TrackOSObjects;\n\n  /// FuncSummaries - A map from FunctionDecls to summaries.\n  FuncSummariesTy FuncSummaries;\n\n  /// ObjCClassMethodSummaries - A map from selectors (for instance methods)\n  ///  to summaries.\n  ObjCMethodSummariesTy ObjCClassMethodSummaries;\n\n  /// ObjCMethodSummaries - A map from selectors to summaries.\n  ObjCMethodSummariesTy ObjCMethodSummaries;\n\n  /// BPAlloc - A BumpPtrAllocator used for allocating summaries, ArgEffects,\n  ///  and all other data used by the checker.\n  llvm::BumpPtrAllocator BPAlloc;\n\n  /// AF - A factory for ArgEffects objects.\n  ArgEffects::Factory AF;\n\n  /// ObjCAllocRetE - Default return effect for methods returning Objective-C\n  ///  objects.\n  RetEffect ObjCAllocRetE;\n\n  /// ObjCInitRetE - Default return effect for init methods returning\n  ///   Objective-C objects.\n  RetEffect ObjCInitRetE;\n\n  /// SimpleSummaries - Used for uniquing summaries that don't have special\n  /// effects.\n  llvm::FoldingSet<CachedSummaryNode> SimpleSummaries;\n\n  /// Create an OS object at +1.\n  const RetainSummary *getOSSummaryCreateRule(const FunctionDecl *FD);\n\n  /// Get an OS object at +0.\n  const RetainSummary *getOSSummaryGetRule(const FunctionDecl *FD);\n\n  /// Increment the reference count on OS object.\n  const RetainSummary *getOSSummaryRetainRule(const FunctionDecl *FD);\n\n  /// Decrement the reference count on OS object.\n  const RetainSummary *getOSSummaryReleaseRule(const FunctionDecl *FD);\n\n  /// Free the OS object.\n  const RetainSummary *getOSSummaryFreeRule(const FunctionDecl *FD);\n\n  const RetainSummary *getUnarySummary(const FunctionType* FT,\n                                       ArgEffectKind AE);\n\n  const RetainSummary *getCFSummaryCreateRule(const FunctionDecl *FD);\n  const RetainSummary *getCFSummaryGetRule(const FunctionDecl *FD);\n  const RetainSummary *getCFCreateGetRuleSummary(const FunctionDecl *FD);\n\n  const RetainSummary *getPersistentSummary(const RetainSummary &OldSumm);\n\n  const RetainSummary *\n  getPersistentSummary(RetEffect RetEff, ArgEffects ScratchArgs,\n                       ArgEffect ReceiverEff = ArgEffect(DoNothing),\n                       ArgEffect DefaultEff = ArgEffect(MayEscape),\n                       ArgEffect ThisEff = ArgEffect(DoNothing)) {\n    RetainSummary Summ(ScratchArgs, RetEff, DefaultEff, ReceiverEff, ThisEff);\n    return getPersistentSummary(Summ);\n  }\n\n  const RetainSummary *getDoNothingSummary() {\n    return getPersistentSummary(RetEffect::MakeNoRet(),\n                                ArgEffects(AF.getEmptyMap()),\n                                ArgEffect(DoNothing), ArgEffect(DoNothing));\n  }\n\n  const RetainSummary *getDefaultSummary() {\n    return getPersistentSummary(RetEffect::MakeNoRet(),\n                                ArgEffects(AF.getEmptyMap()),\n                                ArgEffect(DoNothing), ArgEffect(MayEscape));\n  }\n\n  const RetainSummary *getPersistentStopSummary() {\n    return getPersistentSummary(\n        RetEffect::MakeNoRet(), ArgEffects(AF.getEmptyMap()),\n        ArgEffect(StopTracking), ArgEffect(StopTracking));\n  }\n\n  void InitializeClassMethodSummaries();\n  void InitializeMethodSummaries();\n\n  void addNSObjectClsMethSummary(Selector S, const RetainSummary *Summ) {\n    ObjCClassMethodSummaries[S] = Summ;\n  }\n\n  void addNSObjectMethSummary(Selector S, const RetainSummary *Summ) {\n    ObjCMethodSummaries[S] = Summ;\n  }\n\n  void addClassMethSummary(const char* Cls, const char* name,\n                           const RetainSummary *Summ, bool isNullary = true) {\n    IdentifierInfo* ClsII = &Ctx.Idents.get(Cls);\n    Selector S = isNullary ? GetNullarySelector(name, Ctx)\n                           : GetUnarySelector(name, Ctx);\n    ObjCClassMethodSummaries[ObjCSummaryKey(ClsII, S)]  = Summ;\n  }\n\n  void addInstMethSummary(const char* Cls, const char* nullaryName,\n                          const RetainSummary *Summ) {\n    IdentifierInfo* ClsII = &Ctx.Idents.get(Cls);\n    Selector S = GetNullarySelector(nullaryName, Ctx);\n    ObjCMethodSummaries[ObjCSummaryKey(ClsII, S)]  = Summ;\n  }\n\n  template <typename... Keywords>\n  void addMethodSummary(IdentifierInfo *ClsII, ObjCMethodSummariesTy &Summaries,\n                        const RetainSummary *Summ, Keywords *... Kws) {\n    Selector S = getKeywordSelector(Ctx, Kws...);\n    Summaries[ObjCSummaryKey(ClsII, S)] = Summ;\n  }\n\n  template <typename... Keywords>\n  void addInstMethSummary(const char *Cls, const RetainSummary *Summ,\n                          Keywords *... Kws) {\n    addMethodSummary(&Ctx.Idents.get(Cls), ObjCMethodSummaries, Summ, Kws...);\n  }\n\n  template <typename... Keywords>\n  void addClsMethSummary(const char *Cls, const RetainSummary *Summ,\n                         Keywords *... Kws) {\n    addMethodSummary(&Ctx.Idents.get(Cls), ObjCClassMethodSummaries, Summ,\n                     Kws...);\n  }\n\n  template <typename... Keywords>\n  void addClsMethSummary(IdentifierInfo *II, const RetainSummary *Summ,\n                         Keywords *... Kws) {\n    addMethodSummary(II, ObjCClassMethodSummaries, Summ, Kws...);\n  }\n\n  const RetainSummary * generateSummary(const FunctionDecl *FD,\n                                        bool &AllowAnnotations);\n\n  /// Return a summary for OSObject, or nullptr if not found.\n  const RetainSummary *getSummaryForOSObject(const FunctionDecl *FD,\n                                             StringRef FName, QualType RetTy);\n\n  /// Return a summary for Objective-C or CF object, or nullptr if not found.\n  const RetainSummary *getSummaryForObjCOrCFObject(\n    const FunctionDecl *FD,\n    StringRef FName,\n    QualType RetTy,\n    const FunctionType *FT,\n    bool &AllowAnnotations);\n\n  /// Apply the annotation of {@code pd} in function {@code FD}\n  /// to the resulting summary stored in out-parameter {@code Template}.\n  /// \\return whether an annotation was applied.\n  bool applyParamAnnotationEffect(const ParmVarDecl *pd, unsigned parm_idx,\n                                  const NamedDecl *FD,\n                                  RetainSummaryTemplate &Template);\n\npublic:\n  RetainSummaryManager(ASTContext &ctx, bool trackObjCAndCFObjects,\n                       bool trackOSObjects)\n      : Ctx(ctx), ARCEnabled((bool)Ctx.getLangOpts().ObjCAutoRefCount),\n        TrackObjCAndCFObjects(trackObjCAndCFObjects),\n        TrackOSObjects(trackOSObjects), AF(BPAlloc),\n        ObjCAllocRetE(ARCEnabled ? RetEffect::MakeNotOwned(ObjKind::ObjC)\n                                 : RetEffect::MakeOwned(ObjKind::ObjC)),\n        ObjCInitRetE(ARCEnabled ? RetEffect::MakeNotOwned(ObjKind::ObjC)\n                                : RetEffect::MakeOwnedWhenTrackedReceiver()) {\n    InitializeClassMethodSummaries();\n    InitializeMethodSummaries();\n  }\n\n  enum class BehaviorSummary {\n    // Function does not return.\n    NoOp,\n\n    // Function returns the first argument.\n    Identity,\n\n    // Function returns \"this\" argument.\n    IdentityThis,\n\n    // Function either returns zero, or the input parameter.\n    IdentityOrZero\n  };\n\n  Optional<BehaviorSummary> canEval(const CallExpr *CE, const FunctionDecl *FD,\n                                    bool &hasTrustedImplementationAnnotation);\n\n  /// \\return Whether the type corresponds to a known smart pointer\n  /// implementation (that is, everything about it is inlineable).\n  static bool isKnownSmartPointer(QualType QT);\n\n  bool isTrustedReferenceCountImplementation(const Decl *FD);\n\n  const RetainSummary *getSummary(AnyCall C,\n                                  bool HasNonZeroCallbackArg=false,\n                                  bool IsReceiverUnconsumedSelf=false,\n                                  QualType ReceiverType={});\n\n  RetEffect getObjAllocRetEffect() const { return ObjCAllocRetE; }\n\nprivate:\n\n  /// getMethodSummary - This version of getMethodSummary is used to query\n  ///  the summary for the current method being analyzed.\n  const RetainSummary *getMethodSummary(const ObjCMethodDecl *MD);\n\n  const RetainSummary *getFunctionSummary(const FunctionDecl *FD);\n\n  const RetainSummary *getMethodSummary(Selector S, const ObjCInterfaceDecl *ID,\n                                        const ObjCMethodDecl *MD,\n                                        QualType RetTy,\n                                        ObjCMethodSummariesTy &CachedSummaries);\n\n  const RetainSummary *\n  getInstanceMethodSummary(const ObjCMessageExpr *ME, QualType ReceiverType);\n\n  const RetainSummary *getClassMethodSummary(const ObjCMessageExpr *ME);\n\n  const RetainSummary *getStandardMethodSummary(const ObjCMethodDecl *MD,\n                                                Selector S, QualType RetTy);\n\n  /// Determine if there is a special return effect for this function or method.\n  Optional<RetEffect> getRetEffectFromAnnotations(QualType RetTy,\n                                                  const Decl *D);\n\n  void updateSummaryFromAnnotations(const RetainSummary *&Summ,\n                                    const ObjCMethodDecl *MD);\n\n  void updateSummaryFromAnnotations(const RetainSummary *&Summ,\n                                    const FunctionDecl *FD);\n\n  const RetainSummary *updateSummaryForNonZeroCallbackArg(const RetainSummary *S,\n                                                          AnyCall &C);\n\n  /// Special case '[super init];' and '[self init];'\n  ///\n  /// Even though calling '[super init]' without assigning the result to self\n  /// and checking if the parent returns 'nil' is a bad pattern, it is common.\n  /// Additionally, our Self Init checker already warns about it. To avoid\n  /// overwhelming the user with messages from both checkers, we model the case\n  /// of '[super init]' in cases when it is not consumed by another expression\n  /// as if the call preserves the value of 'self'; essentially, assuming it can\n  /// never fail and return 'nil'.\n  /// Note, we don't want to just stop tracking the value since we want the\n  /// RetainCount checker to report leaks and use-after-free if SelfInit checker\n  /// is turned off.\n  void updateSummaryForReceiverUnconsumedSelf(const RetainSummary *&S);\n\n  /// Set argument types for arguments which are not doing anything.\n  void updateSummaryForArgumentTypes(const AnyCall &C, const RetainSummary *&RS);\n\n  /// Determine whether a declaration {@code D} of correspondent type (return\n  /// type for functions/methods) {@code QT} has any of the given attributes,\n  /// provided they pass necessary validation checks AND tracking the given\n  /// attribute is enabled.\n  /// Returns the object kind corresponding to the present attribute, or None,\n  /// if none of the specified attributes are present.\n  /// Crashes if passed an attribute which is not explicitly handled.\n  template <class T>\n  Optional<ObjKind> hasAnyEnabledAttrOf(const Decl *D, QualType QT);\n\n  template <class T1, class T2, class... Others>\n  Optional<ObjKind> hasAnyEnabledAttrOf(const Decl *D, QualType QT);\n\n  friend class RetainSummaryTemplate;\n};\n\n\n// Used to avoid allocating long-term (BPAlloc'd) memory for default retain\n// summaries. If a function or method looks like it has a default summary, but\n// it has annotations, the annotations are added to the stack-based template\n// and then copied into managed memory.\nclass RetainSummaryTemplate {\n  RetainSummaryManager &Manager;\n  const RetainSummary *&RealSummary;\n  RetainSummary ScratchSummary;\n  bool Accessed;\npublic:\n  RetainSummaryTemplate(const RetainSummary *&real, RetainSummaryManager &mgr)\n    : Manager(mgr), RealSummary(real), ScratchSummary(*real), Accessed(false) {}\n\n  ~RetainSummaryTemplate() {\n    if (Accessed)\n      RealSummary = Manager.getPersistentSummary(ScratchSummary);\n  }\n\n  RetainSummary &operator*() {\n    Accessed = true;\n    return ScratchSummary;\n  }\n\n  RetainSummary *operator->() {\n    Accessed = true;\n    return &ScratchSummary;\n  }\n};\n\n} // end namespace ento\n} // end namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 679}, "message": "'matcher_isBitFieldMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a64d5cabdcef94d1b2b364f5096de6b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 696}, "message": "'matcher_hasBitWidth0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "7a559807a1dea1fc77910ee64d88cedf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 715}, "message": "'matcher_hasInClassInitializer0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "e52043c6855ba84d5e0c24b58919d827", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 724}, "message": "'matcher_isMainMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "107e2568e04081216b65bc05df24bbf1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 738}, "message": "'matcher_hasSpecializedTemplate0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "7de7eb530c40a60511f8a97400db818b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 747}, "message": "'matcher_isImplicitMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "47e796f3c189e7f92779a2a5005b60dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 877}, "message": "'matcher_ignoringImplicit0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "9f51c83cdf611a25d04ecf59d0d1e35f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 907}, "message": "'matcher_ignoringImpCasts0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "7cf987daf39f28a5c38b5c7e059603e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 929}, "message": "'matcher_ignoringParenCasts0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "37aafbd17d2dc3898ed35b4933239669", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 954}, "message": "'matcher_ignoringParenImpCasts0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "23ea3d438d0c5a7c007ca23705d1feee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 970}, "message": "'matcher_ignoringParens0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "530b05854e68f50685db7225ac5a99be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 986}, "message": "'matcher_ignoringParens1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "514eae51291a4ecdd93fe36d5c52786f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 1005}, "message": "'matcher_isInstantiationDependentMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "b28c2b2ab83dedf2e22ab27dbfb2fefb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 1021}, "message": "'matcher_isTypeDependentMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "497a6dc31f0a13c41f56cd7bbfa69b4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 1032}, "message": "'matcher_isValueDependentMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "c53e543c755265c17bd00130d52223d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 1093}, "message": "'matcher_refersToType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "f5e060412ac5072ab3a5ab5777bb1fbb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 1111}, "message": "'matcher_refersToTemplate0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1312356e7e516540ec9ac821776f997e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 1131}, "message": "'matcher_refersToDeclaration0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1222843b20c892a00e4231e18afda623", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 1150}, "message": "'matcher_isExpr0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "af3c52617a5009a2fda8ff55d6b653d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 1167}, "message": "'matcher_isIntegralMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ce5e31c412df503b2c5b1ab1d1d620b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 1181}, "message": "'matcher_refersToIntegralType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "9030fbec9535a7437479ed7dfd8eef1f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 1202}, "message": "'matcher_equalsIntegralValue0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "68701cb55d1c7b4f23bab74dd9fa947f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 1472}, "message": "'matcher_usesADLMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "9cd5342cb6c44e7200b143a92afeaef8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 1669}, "message": "'matcher_hasSyntacticForm0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "5d80f33f836f1b323dcea00a34cbeebb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 2065}, "message": "'matcher_hasIncrement0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "290aa3348fa8fc75878580c4f4ed3a75", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 2080}, "message": "'matcher_hasLoopInit0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1e762dd1c1d7b17fe2ee4d9bd34619eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 2104}, "message": "'matcher_hasLoopVariable0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d22f904db397446c7bf810524cc3e9f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 2118}, "message": "'matcher_hasRangeInit0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "55857a4ac41497c84e1ce8b71d8843e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 2637}, "message": "'matcher_designatorCountIs0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d5138828d92a17993cf89bcdf7d32a53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 2876}, "message": "'matcher_hasArgumentOfType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ac5f5640f9b99249ac164059bf25c0fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 2894}, "message": "'matcher_ofKind0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "e91fd2bb455a0ec114a32916ed7f691e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3036}, "message": "'matcher_hasMemberName0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "22541ca5c95fd45159a091b0457ecb43", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3074}, "message": "'matcher_memberHasSameNameAsBoundNode0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "035c64e9a54872c81b9e148fba536c09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 26, "line": 3079}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "0900e14bc32efa4e75c3c14706500f8f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3166}, "message": "'matcher_hasAnyBase0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "925b1d64ecbd27f9d741bd666459dda5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3183}, "message": "'matcher_hasDirectBase0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "7612dd7c8745b59c521271481b4d9829", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3285}, "message": "'matcher_hasMethod0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "706b0dab45fe116011e3023c5fd421a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3308}, "message": "'matcher_isLambdaMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "649c2b90aae5948d1eb8cef80665c9de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3522}, "message": "'matcher_hasUnderlyingDecl0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "73c57bfe53be5ccd6c73bf1d323dcaec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3548}, "message": "'matcher_on0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "104880018553fd2697aed62209ef2147", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3567}, "message": "'matcher_hasReceiverType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "bdd70ca08491799a1394be8ea46e6fcc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3585}, "message": "'matcher_isClassMethodMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "e88b1dffd9c0fbbfedb6b6cd3199027b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3601}, "message": "'matcher_isInstanceMethodMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "9047783f5538626fe1420ab1b25c726f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3618}, "message": "'matcher_isClassMessageMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "42f4e6198d9cee8b3030def4e60f438c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3635}, "message": "'matcher_isInstanceMessageMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a9a52563a418f71e74857dfecf8244d7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3649}, "message": "'matcher_hasReceiver0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "4951cdc10bd3e9b804b2950d6a5b5811", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3665}, "message": "'matcher_hasSelector0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "877abde848fb96f6e2a3c88b4968b6a8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3702}, "message": "'matcher_hasNullSelectorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "3aab94026e17dab5e117bc0a62525178", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3714}, "message": "'matcher_hasUnarySelectorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1b8c176a994ce315a4b5e2749b60dec7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 3730}, "message": "'matcher_hasKeywordSelectorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "2bbfc6f748929c422034d0d25e19b924", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3745}, "message": "'matcher_numSelectorArgs0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "b2527648464bf6fff3be325726e6b100", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3765}, "message": "'matcher_callee0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6d936fe6456757514afefb81766e255d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3781}, "message": "'matcher_callee1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "0d27b60ba93fd41a772a44485ec521cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3857}, "message": "'matcher_hasTypeLoc0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "88e9f082bc2080d572558b643ba483ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3873}, "message": "'matcher_asString0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a3bf37012e098d90867db0b330c687ff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3887}, "message": "'matcher_pointsTo0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "26060f99255ec4781d5fdbf69fb6da72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3895}, "message": "'matcher_pointsTo1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ace403f251767db0d7ba09e369c0784c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3911}, "message": "'matcher_hasUnqualifiedDesugaredType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "2d1b2ca198bc912a65b93da41a696fb4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3930}, "message": "'matcher_references0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "3fcb672d12a29531a40004e6c5909617", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3948}, "message": "'matcher_hasCanonicalType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d0b64c980d43e89e799517ec09d79085", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3956}, "message": "'matcher_references1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6a9ad708fe492c77ac5f8898b0713f2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 3979}, "message": "'matcher_onImplicitObjectArgument0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "c42bd2838461dbdc37c3d854231fe2ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4002}, "message": "'matcher_thisPointerType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "8a274109ea47b0c701126b572c4dd908", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4010}, "message": "'matcher_thisPointerType1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "5fc63d991b533b302e49c00d516d758f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4026}, "message": "'matcher_to0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "3d04f9f0289460fc7c8a286d38a1019b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4047}, "message": "'matcher_throughUsingDecl0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6c87b3db13492db256c9e5d666116b87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4070}, "message": "'matcher_hasAnyDeclaration0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "204bf1af9a0dbb8ecd796a7306d7c298", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4086}, "message": "'matcher_hasSingleDecl0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "f38d4870d6d6b755e80e86190441a8b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4102}, "message": "'matcher_hasInitializer0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "983953b917a88e0ae26b88f235405caa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4120}, "message": "'matcher_isStaticLocalMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ca005f2d69aaecaab43a645e0a1b0bf3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4135}, "message": "'matcher_hasLocalStorageMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "bf11d5ff2405e9d529ff08f8e6b41a9d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4149}, "message": "'matcher_hasGlobalStorageMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "4ebab2e6af0a009f934fca7b39172b6b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4165}, "message": "'matcher_hasAutomaticStorageDurationMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d2ea3fd821558bf2c8e270378157a276", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4185}, "message": "'matcher_hasStaticStorageDurationMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "802c2e340eb27605396b3b1406194050", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4201}, "message": "'matcher_hasThreadStorageDurationMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "0853f7abad59a906708bf1a4664198ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4216}, "message": "'matcher_isExceptionVariableMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "fa7e913a22c2faf06b13bef6d5edf5cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 177}, "message": "expanded from macro 'AST_MATCHER_P2'"}, {"location": {"col": 9, "file": 27, "line": 183}, "message": "expanded from macro 'AST_MATCHER_P2_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4272}, "message": "'matcher_hasInit0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "68840935b6b2d9b8a4e1fece597a2cef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4289}, "message": "'matcher_declCountIs0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "415bd337d05b5ac974bc04caee7f68a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 177}, "message": "expanded from macro 'AST_MATCHER_P2'"}, {"location": {"col": 9, "file": 27, "line": 183}, "message": "expanded from macro 'AST_MATCHER_P2_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4312}, "message": "'matcher_containsDeclaration0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "162590520326a499b4e2960e0a86bf0d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4335}, "message": "'matcher_isCatchAllMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "52deeccac95418172381df65194af5a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4352}, "message": "'matcher_hasAnyConstructorInitializer0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a7e726b0d9fe70c27878629b1314ba16", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4374}, "message": "'matcher_forField0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "53c10fa51fa90445ea3b848723ae476c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4394}, "message": "'matcher_withInitializer0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "cff0cb538d0369a82e11013517358558", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4414}, "message": "'matcher_isWrittenMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "17c7ef566c379f95b6fb9aaa27bc259b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4434}, "message": "'matcher_isBaseInitializerMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d25553de1fa0f5d61dda0d67bf47cd5d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4454}, "message": "'matcher_isMemberInitializerMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "af273dc7db388a8e270ddbaa89e5728e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4506}, "message": "'matcher_hasAnyCapture0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "2d6c0dc677a2484985e278bd5d488b57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4532}, "message": "'matcher_hasAnyCapture1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "f92912356f99dc1a32d07c4dd4de7976", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4540}, "message": "'matcher_isListInitializationMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "80395df3d0b0f1352ae0cdb779f54447", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4556}, "message": "'matcher_requiresZeroInitializationMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "28996251d52f1121a98f22940b56974c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4756}, "message": "'matcher_isAtPosition0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "956ae100df599362a91644c94dd96c4c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4849}, "message": "'matcher_isNoReturnMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "930049e2f4bf2ec86d34e381dc50d3dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 4859}, "message": "'matcher_returns0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6839fb31b650b91692aaa14e6114a62e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4913}, "message": "'matcher_isDeletedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "2ad6bb47806205ac9cc1a7d2aefdcdfb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4926}, "message": "'matcher_isDefaultedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "804607d001d4b0e8ac82b2c54eddfbb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 4939}, "message": "'matcher_isWeakMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ef4fbba46eba9fb2d8b3a1f8cfd28317", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5069}, "message": "'matcher_hasThen0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "8459e4de997622fda5d992898938ce2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5081}, "message": "'matcher_hasElse0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "467218eb1205cd2260f511f98e125263", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5131}, "message": "'matcher_hasConditionVariableStatement0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "317ec5235dc8b0051885ba26aaf4bd47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5148}, "message": "'matcher_hasIndex0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6cbc67d60dff666215f467449762df53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5165}, "message": "'matcher_hasBase0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "4d30d2a254eece348bcee3666ae7a8ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5226}, "message": "'matcher_hasAnyBody0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "34d35438caa27e3f9ee9715745513886", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5265}, "message": "'matcher_statementCountIs0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "4c2e2710441326cce65277c2395ac61b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5521}, "message": "'matcher_hasCastKind0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "043752493223de9969f890341d8372d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5529}, "message": "'matcher_hasDestinationType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1ade74f803672208a685493bd3711b0f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5539}, "message": "'matcher_hasImplicitDestinationType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d1c3327c5edd2e6821838a0ebacd8b47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5553}, "message": "'matcher_isStructMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "7be042c45c36a05f6acb24ce9ba392bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5566}, "message": "'matcher_isUnionMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "931499c2aee64720102f74369d97b255", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5579}, "message": "'matcher_isClassMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "c0a9ad3cb427db3f610fa4ba919292de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5592}, "message": "'matcher_isEnumMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "31e286fb9edc4fa576fa4addc2d357e3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5607}, "message": "'matcher_hasTrueExpression0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "dd86051f9f3b3dd20f7393b93608ccf3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5622}, "message": "'matcher_hasFalseExpression0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d2a4c263e76b938e2292ce9bf4b348dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5666}, "message": "'matcher_isVariadicMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "8fcb442d93dabcdb12a9dffa6f4a4a99", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5687}, "message": "'matcher_ofClass0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1525221cbcb1faf79018522d0ab41d04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 5721}, "message": "'matcher_forEachOverridden0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "84bebb24c7505f59517d5ebb554c65e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5777}, "message": "'matcher_isVirtualAsWrittenMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "94e0387aa93fdb26dc17253cf36d5564", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5812}, "message": "'matcher_isPureMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "287d5796440537f9aff28c5347a0c332", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5827}, "message": "'matcher_isConstMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "c9af3e2e1ccee2c971c10588f7078359", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5844}, "message": "'matcher_isCopyAssignmentOperatorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a6cb23812c65a4f77248b1fd832cd846", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5861}, "message": "'matcher_isMoveAssignmentOperatorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "b9b3225d7e3cecad0f22b7b85636712e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5879}, "message": "'matcher_isOverrideMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "977c2ac3b9ae928e120ef71c5ee70e22", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5894}, "message": "'matcher_isUserProvidedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "819558628bf862689ac66d635e963f52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5938}, "message": "'matcher_isIntegerMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ac7376590bc2d4d54644e545e64367aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5952}, "message": "'matcher_isUnsignedIntegerMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "4397a6c8f2c35c5549faeb9ef1281e0b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5966}, "message": "'matcher_isSignedIntegerMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "20c3ea3a2b4c5139fec504ccc041a18e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 5980}, "message": "'matcher_isAnyCharacterMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "aa61cf20198ce17dc49b540db71e1b48", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 6000}, "message": "'matcher_isAnyPointerMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "789fd43911c8c4660059bc44f48f20c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 6019}, "message": "'matcher_isConstQualifiedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ae67b0879ed53f13a6c923c6e24799c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 6038}, "message": "'matcher_isVolatileQualifiedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "2023f6bfa5d612370c345b150a500799", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 6055}, "message": "'matcher_hasLocalQualifiersMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a1cc07230cc1054410f9e5cc07efb239", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6071}, "message": "'matcher_member0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "9b250edc665417c8ce57a3b6e8661e19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6115}, "message": "'matcher_hasAnyUsingShadowDecl0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6aa6b91888265652fa717f817cc904b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6134}, "message": "'matcher_hasTargetDecl0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a1f42fd137cea748ee4d054204294d22", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 6247}, "message": "'matcher_booleanTypeMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1fb54578b6e3afc429fcd1414c67538a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 6259}, "message": "'matcher_voidTypeMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "417c57d39561230b99e0e3b085bf2fc4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 6311}, "message": "'matcher_realFloatingPointTypeMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "f97124daac2a62a4504e73aaf940df08", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6420}, "message": "'matcher_hasSizeExpr0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "0f2f094a825688d33772677d11dd60ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6802}, "message": "'matcher_hasQualifier0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ad3c34dcc1b61a8fbeb8563cc58de4fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6825}, "message": "'matcher_namesType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d990e9fc608133edc13f3fdfcc167ab2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6895}, "message": "'matcher_hasDecayedType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "0173bee15dd5235e31024d5c205c429e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6914}, "message": "'matcher_hasDeclContext0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "4af921dbad26c1cb30316dbe0da165fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6962}, "message": "'matcher_specifiesType0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "bf28c6f38a0f0f907c3152a1b063f151", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6980}, "message": "'matcher_specifiesTypeLoc0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "552247ed2b3175e499e6313171b051b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 6995}, "message": "'matcher_hasPrefix0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "cbb9d30e381a1651856daf290259c591", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7013}, "message": "'matcher_hasPrefix1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a724bd7f97df4b32d929a0667032ceb4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7032}, "message": "'matcher_specifiesNamespace0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "3fa3b8e3c7089a5133441fd4224078fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7046}, "message": "'matcher_equalsNode0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "7217dabbc8d4498fa1c6599de7d64757", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7052}, "message": "'matcher_equalsNode1Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "f22bea3488df27784c33c7355db0707a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7058}, "message": "'matcher_equalsNode2Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6718da27070c69d21259a6a1300688d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7075}, "message": "'matcher_forEachSwitchCase0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "935f65cdca1530c23cc285a565b26485", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7106}, "message": "'matcher_forEachConstructorInitializer0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "98b949d997911f9f906dd74dfd282484", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7134}, "message": "'matcher_isCopyConstructorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "6d4e476766ac21fd6d44d3d9d8984d9a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7149}, "message": "'matcher_isMoveConstructorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "622cc4619e8e1515213dc5fbff89eb39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7164}, "message": "'matcher_isDefaultConstructorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "93d7bc62b443d2262d8c1589f4d6f88c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7181}, "message": "'matcher_isDelegatingConstructorMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "e077f41f3b4f618c96025520f65c1358", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7234}, "message": "'matcher_hasExplicitSpecifier0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "49131c49108df2ca205e9c896a853a92", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7279}, "message": "'matcher_isAnonymousMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "8f0febd894a4ee79585f518db7608b45", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7304}, "message": "'matcher_isInStdNamespaceMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "016e1f209cbd4ebcf0589c8e2d69ca0f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7315}, "message": "'matcher_hasCaseConstant0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "235a82793e9a13bd4c6917de207aee25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7332}, "message": "'matcher_hasAttr0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "023ba909bc11ce7e7a3cd726be855937", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7350}, "message": "'matcher_hasReturnValue0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "c8b6251defa002f60ba44610d981f297", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7405}, "message": "'matcher_forDecomposition0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "64a80297717a986fa9865aa49debfdc7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 177}, "message": "expanded from macro 'AST_MATCHER_P2'"}, {"location": {"col": 9, "file": 27, "line": 183}, "message": "expanded from macro 'AST_MATCHER_P2_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7430}, "message": "'matcher_hasBinding0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ce62644a55a343df057ac7f5a15a8dd2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7454}, "message": "'matcher_hasAnyBinding0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "11c771d3a2379bdd4a51f16cb139b58c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7473}, "message": "'matcher_forFunction0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a3dda2f72b286852aeef53c853a0c5c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7518}, "message": "'matcher_hasExternalFormalLinkageMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "1a7aae21bc967acd8d2b3a00cc0a5359", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7543}, "message": "'matcher_hasDefaultArgumentMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "9568bd1c75499805b36a0168be9b93b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7555}, "message": "'matcher_isArrayMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "5f784b055b6139639d79aa770b2f9c7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 177}, "message": "expanded from macro 'AST_MATCHER_P2'"}, {"location": {"col": 9, "file": 27, "line": 183}, "message": "expanded from macro 'AST_MATCHER_P2_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7567}, "message": "'matcher_hasPlacementArg0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a49b00bd4bc194ce3ce7fbc3043c012c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7581}, "message": "'matcher_hasAnyPlacementArg0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "ba8fb500888000590a91d9f59c74f76c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7596}, "message": "'matcher_hasArraySize0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "07b61e6056f5ac0f4fb8c5c9a90482e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7608}, "message": "'matcher_hasDefinitionMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "5577bab81680984a3fc0193aff2b4d97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7619}, "message": "'matcher_isScopedMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "8e36e66178e68acf9563b054c9b38d2c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7630}, "message": "'matcher_hasTrailingReturnMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "38ddef5a7c730ddecd48034746f838e7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7659}, "message": "'matcher_ignoringElidableConstructorCall0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "29d1e8661d73caae1b1e6d25f91ffe3e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7714}, "message": "'matcher_isStandaloneDirectiveMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "49caaf020d80ef46e7cf93557fbb0bbc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7733}, "message": "'matcher_hasStructuredBlock0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "b78e5c2196f532a800290a02ce475b4f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 129}, "message": "expanded from macro 'AST_MATCHER_P'"}, {"location": {"col": 9, "file": 27, "line": 134}, "message": "expanded from macro 'AST_MATCHER_P_OVERLOAD'"}, {"location": {"col": 1, "file": 26, "line": 7751}, "message": "'matcher_hasAnyClause0Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "a3cbdfcac6ecb56b66c1b45472af6bca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7787}, "message": "'matcher_isNoneKindMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "766a8ff5cd9b1617e989cd181e229c20", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7803}, "message": "'matcher_isSharedKindMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "08af16c5a2ca6e9119dbacd9c99127db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 27, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 26, "line": 7821}, "message": "'matcher_isFirstPrivateKindMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h", "reportHash": "d97c3e5b7059914906fd57636d1afdad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 879}, "message": "'HasNameMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h", "reportHash": "936c250703eff9f7c5b9143f49154086", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 1753}, "message": "'TypeLocTypeMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h", "reportHash": "94022aa4c3a8ae88824057d65ef2520b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 282}, "message": "'RetainSummary' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h", "reportHash": "a6263eecd46382ec0073974dd51d59b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 389}, "message": "'ObjCSummaryCache' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h", "reportHash": "7cfbadfbc8ad7e60d7c5bd3fca93f127", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 449}, "message": "'RetainSummaryManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h", "reportHash": "2ab1431a6f23ff9fe1574baf3f424cfb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
