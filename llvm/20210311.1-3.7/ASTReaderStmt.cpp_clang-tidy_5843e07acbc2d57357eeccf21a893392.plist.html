<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "content": "//===--- Expr.h - Classes for representing expressions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Expr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPR_H\n#define LLVM_CLANG_AST_EXPR_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTVector.h\"\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SyncScope.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n  class APValue;\n  class ASTContext;\n  class BlockDecl;\n  class CXXBaseSpecifier;\n  class CXXMemberCallExpr;\n  class CXXOperatorCallExpr;\n  class CastExpr;\n  class Decl;\n  class IdentifierInfo;\n  class MaterializeTemporaryExpr;\n  class NamedDecl;\n  class ObjCPropertyRefExpr;\n  class OpaqueValueExpr;\n  class ParmVarDecl;\n  class StringLiteral;\n  class TargetInfo;\n  class ValueDecl;\n\n/// A simple array of base specifiers.\ntypedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n\n/// An adjustment to be made to the temporary created when emitting a\n/// reference binding, which accesses a particular subobject of that temporary.\nstruct SubobjectAdjustment {\n  enum {\n    DerivedToBaseAdjustment,\n    FieldAdjustment,\n    MemberPointerAdjustment\n  } Kind;\n\n  struct DTB {\n    const CastExpr *BasePath;\n    const CXXRecordDecl *DerivedClass;\n  };\n\n  struct P {\n    const MemberPointerType *MPT;\n    Expr *RHS;\n  };\n\n  union {\n    struct DTB DerivedToBase;\n    FieldDecl *Field;\n    struct P Ptr;\n  };\n\n  SubobjectAdjustment(const CastExpr *BasePath,\n                      const CXXRecordDecl *DerivedClass)\n    : Kind(DerivedToBaseAdjustment) {\n    DerivedToBase.BasePath = BasePath;\n    DerivedToBase.DerivedClass = DerivedClass;\n  }\n\n  SubobjectAdjustment(FieldDecl *Field)\n    : Kind(FieldAdjustment) {\n    this->Field = Field;\n  }\n\n  SubobjectAdjustment(const MemberPointerType *MPT, Expr *RHS)\n    : Kind(MemberPointerAdjustment) {\n    this->Ptr.MPT = MPT;\n    this->Ptr.RHS = RHS;\n  }\n};\n\n/// This represents one expression.  Note that Expr's are subclasses of Stmt.\n/// This allows an expression to be transparently used any place a Stmt is\n/// required.\nclass Expr : public ValueStmt {\n  QualType TR;\n\npublic:\n  Expr() = delete;\n  Expr(const Expr&) = delete;\n  Expr(Expr &&) = delete;\n  Expr &operator=(const Expr&) = delete;\n  Expr &operator=(Expr&&) = delete;\n\nprotected:\n  Expr(StmtClass SC, QualType T, ExprValueKind VK, ExprObjectKind OK)\n      : ValueStmt(SC) {\n    ExprBits.Dependent = 0;\n    ExprBits.ValueKind = VK;\n    ExprBits.ObjectKind = OK;\n    assert(ExprBits.ObjectKind == OK && \"truncated kind\");\n    setType(T);\n  }\n\n  /// Construct an empty expression.\n  explicit Expr(StmtClass SC, EmptyShell) : ValueStmt(SC) { }\n\n  /// Each concrete expr subclass is expected to compute its dependence and call\n  /// this in the constructor.\n  void setDependence(ExprDependence Deps) {\n    ExprBits.Dependent = static_cast<unsigned>(Deps);\n  }\n  friend class ASTImporter; // Sets dependence dircetly.\n  friend class ASTStmtReader; // Sets dependence dircetly.\n\npublic:\n  QualType getType() const { return TR; }\n  void setType(QualType t) {\n    // In C++, the type of an expression is always adjusted so that it\n    // will not have reference type (C++ [expr]p6). Use\n    // QualType::getNonReferenceType() to retrieve the non-reference\n    // type. Additionally, inspect Expr::isLvalue to determine whether\n    // an expression that is adjusted in this manner should be\n    // considered an lvalue.\n    assert((t.isNull() || !t->isReferenceType()) &&\n           \"Expressions can't have reference type\");\n\n    TR = t;\n  }\n\n  ExprDependence getDependence() const {\n    return static_cast<ExprDependence>(ExprBits.Dependent);\n  }\n\n  /// Determines whether the value of this expression depends on\n  ///   - a template parameter (C++ [temp.dep.constexpr])\n  ///   - or an error, whose resolution is unknown\n  ///\n  /// For example, the array bound of \"Chars\" in the following example is\n  /// value-dependent.\n  /// @code\n  /// template<int Size, char (&Chars)[Size]> struct meta_string;\n  /// @endcode\n  bool isValueDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Value);\n  }\n\n  /// Determines whether the type of this expression depends on\n  ///   - a template paramter (C++ [temp.dep.expr], which means that its type\n  ///     could change from one template instantiation to the next)\n  ///   - or an error\n  ///\n  /// For example, the expressions \"x\" and \"x + y\" are type-dependent in\n  /// the following code, but \"y\" is not type-dependent:\n  /// @code\n  /// template<typename T>\n  /// void add(T x, int y) {\n  ///   x + y;\n  /// }\n  /// @endcode\n  bool isTypeDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Type);\n  }\n\n  /// Whether this expression is instantiation-dependent, meaning that\n  /// it depends in some way on\n  ///    - a template parameter (even if neither its type nor (constant) value\n  ///      can change due to the template instantiation)\n  ///    - or an error\n  ///\n  /// In the following example, the expression \\c sizeof(sizeof(T() + T())) is\n  /// instantiation-dependent (since it involves a template parameter \\c T), but\n  /// is neither type- nor value-dependent, since the type of the inner\n  /// \\c sizeof is known (\\c std::size_t) and therefore the size of the outer\n  /// \\c sizeof is known.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// void f(T x, T y) {\n  ///   sizeof(sizeof(T() + T());\n  /// }\n  /// \\endcode\n  ///\n  /// \\code\n  /// void func(int) {\n  ///   func(); // the expression is instantiation-dependent, because it depends\n  ///           // on an error.\n  /// }\n  /// \\endcode\n  bool isInstantiationDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Instantiation);\n  }\n\n  /// Whether this expression contains an unexpanded parameter\n  /// pack (for C++11 variadic templates).\n  ///\n  /// Given the following function template:\n  ///\n  /// \\code\n  /// template<typename F, typename ...Types>\n  /// void forward(const F &f, Types &&...args) {\n  ///   f(static_cast<Types&&>(args)...);\n  /// }\n  /// \\endcode\n  ///\n  /// The expressions \\c args and \\c static_cast<Types&&>(args) both\n  /// contain parameter packs.\n  bool containsUnexpandedParameterPack() const {\n    return static_cast<bool>(getDependence() & ExprDependence::UnexpandedPack);\n  }\n\n  /// Whether this expression contains subexpressions which had errors, e.g. a\n  /// TypoExpr.\n  bool containsErrors() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Error);\n  }\n\n  /// getExprLoc - Return the preferred location for the arrow when diagnosing\n  /// a problem with a generic expression.\n  SourceLocation getExprLoc() const LLVM_READONLY;\n\n  /// Determine whether an lvalue-to-rvalue conversion should implicitly be\n  /// applied to this expression if it appears as a discarded-value expression\n  /// in C++11 onwards. This applies to certain forms of volatile glvalues.\n  bool isReadIfDiscardedInCPlusPlus11() const;\n\n  /// isUnusedResultAWarning - Return true if this immediate expression should\n  /// be warned about if the result is unused.  If so, fill in expr, location,\n  /// and ranges with expr to warn on and source locations/ranges appropriate\n  /// for a warning.\n  bool isUnusedResultAWarning(const Expr *&WarnExpr, SourceLocation &Loc,\n                              SourceRange &R1, SourceRange &R2,\n                              ASTContext &Ctx) const;\n\n  /// isLValue - True if this expression is an \"l-value\" according to\n  /// the rules of the current language.  C and C++ give somewhat\n  /// different rules for this concept, but in general, the result of\n  /// an l-value expression identifies a specific object whereas the\n  /// result of an r-value expression is a value detached from any\n  /// specific storage.\n  ///\n  /// C++11 divides the concept of \"r-value\" into pure r-values\n  /// (\"pr-values\") and so-called expiring values (\"x-values\"), which\n  /// identify specific objects that can be safely cannibalized for\n  /// their resources.  This is an unfortunate abuse of terminology on\n  /// the part of the C++ committee.  In Clang, when we say \"r-value\",\n  /// we generally mean a pr-value.\n  bool isLValue() const { return getValueKind() == VK_LValue; }\n  bool isRValue() const { return getValueKind() == VK_RValue; }\n  bool isXValue() const { return getValueKind() == VK_XValue; }\n  bool isGLValue() const { return getValueKind() != VK_RValue; }\n\n  enum LValueClassification {\n    LV_Valid,\n    LV_NotObjectType,\n    LV_IncompleteVoidType,\n    LV_DuplicateVectorComponents,\n    LV_InvalidExpression,\n    LV_InvalidMessageExpression,\n    LV_MemberFunction,\n    LV_SubObjCPropertySetting,\n    LV_ClassTemporary,\n    LV_ArrayTemporary\n  };\n  /// Reasons why an expression might not be an l-value.\n  LValueClassification ClassifyLValue(ASTContext &Ctx) const;\n\n  enum isModifiableLvalueResult {\n    MLV_Valid,\n    MLV_NotObjectType,\n    MLV_IncompleteVoidType,\n    MLV_DuplicateVectorComponents,\n    MLV_InvalidExpression,\n    MLV_LValueCast,           // Specialized form of MLV_InvalidExpression.\n    MLV_IncompleteType,\n    MLV_ConstQualified,\n    MLV_ConstQualifiedField,\n    MLV_ConstAddrSpace,\n    MLV_ArrayType,\n    MLV_NoSetterProperty,\n    MLV_MemberFunction,\n    MLV_SubObjCPropertySetting,\n    MLV_InvalidMessageExpression,\n    MLV_ClassTemporary,\n    MLV_ArrayTemporary\n  };\n  /// isModifiableLvalue - C99 6.3.2.1: an lvalue that does not have array type,\n  /// does not have an incomplete type, does not have a const-qualified type,\n  /// and if it is a structure or union, does not have any member (including,\n  /// recursively, any member or element of all contained aggregates or unions)\n  /// with a const-qualified type.\n  ///\n  /// \\param Loc [in,out] - A source location which *may* be filled\n  /// in with the location of the expression making this a\n  /// non-modifiable lvalue, if specified.\n  isModifiableLvalueResult\n  isModifiableLvalue(ASTContext &Ctx, SourceLocation *Loc = nullptr) const;\n\n  /// The return type of classify(). Represents the C++11 expression\n  ///        taxonomy.\n  class Classification {\n  public:\n    /// The various classification results. Most of these mean prvalue.\n    enum Kinds {\n      CL_LValue,\n      CL_XValue,\n      CL_Function, // Functions cannot be lvalues in C.\n      CL_Void, // Void cannot be an lvalue in C.\n      CL_AddressableVoid, // Void expression whose address can be taken in C.\n      CL_DuplicateVectorComponents, // A vector shuffle with dupes.\n      CL_MemberFunction, // An expression referring to a member function\n      CL_SubObjCPropertySetting,\n      CL_ClassTemporary, // A temporary of class type, or subobject thereof.\n      CL_ArrayTemporary, // A temporary of array type.\n      CL_ObjCMessageRValue, // ObjC message is an rvalue\n      CL_PRValue // A prvalue for any other reason, of any other type\n    };\n    /// The results of modification testing.\n    enum ModifiableType {\n      CM_Untested, // testModifiable was false.\n      CM_Modifiable,\n      CM_RValue, // Not modifiable because it's an rvalue\n      CM_Function, // Not modifiable because it's a function; C++ only\n      CM_LValueCast, // Same as CM_RValue, but indicates GCC cast-as-lvalue ext\n      CM_NoSetterProperty,// Implicit assignment to ObjC property without setter\n      CM_ConstQualified,\n      CM_ConstQualifiedField,\n      CM_ConstAddrSpace,\n      CM_ArrayType,\n      CM_IncompleteType\n    };\n\n  private:\n    friend class Expr;\n\n    unsigned short Kind;\n    unsigned short Modifiable;\n\n    explicit Classification(Kinds k, ModifiableType m)\n      : Kind(k), Modifiable(m)\n    {}\n\n  public:\n    Classification() {}\n\n    Kinds getKind() const { return static_cast<Kinds>(Kind); }\n    ModifiableType getModifiable() const {\n      assert(Modifiable != CM_Untested && \"Did not test for modifiability.\");\n      return static_cast<ModifiableType>(Modifiable);\n    }\n    bool isLValue() const { return Kind == CL_LValue; }\n    bool isXValue() const { return Kind == CL_XValue; }\n    bool isGLValue() const { return Kind <= CL_XValue; }\n    bool isPRValue() const { return Kind >= CL_Function; }\n    bool isRValue() const { return Kind >= CL_XValue; }\n    bool isModifiable() const { return getModifiable() == CM_Modifiable; }\n\n    /// Create a simple, modifiably lvalue\n    static Classification makeSimpleLValue() {\n      return Classification(CL_LValue, CM_Modifiable);\n    }\n\n  };\n  /// Classify - Classify this expression according to the C++11\n  ///        expression taxonomy.\n  ///\n  /// C++11 defines ([basic.lval]) a new taxonomy of expressions to replace the\n  /// old lvalue vs rvalue. This function determines the type of expression this\n  /// is. There are three expression types:\n  /// - lvalues are classical lvalues as in C++03.\n  /// - prvalues are equivalent to rvalues in C++03.\n  /// - xvalues are expressions yielding unnamed rvalue references, e.g. a\n  ///   function returning an rvalue reference.\n  /// lvalues and xvalues are collectively referred to as glvalues, while\n  /// prvalues and xvalues together form rvalues.\n  Classification Classify(ASTContext &Ctx) const {\n    return ClassifyImpl(Ctx, nullptr);\n  }\n\n  /// ClassifyModifiable - Classify this expression according to the\n  ///        C++11 expression taxonomy, and see if it is valid on the left side\n  ///        of an assignment.\n  ///\n  /// This function extends classify in that it also tests whether the\n  /// expression is modifiable (C99 6.3.2.1p1).\n  /// \\param Loc A source location that might be filled with a relevant location\n  ///            if the expression is not modifiable.\n  Classification ClassifyModifiable(ASTContext &Ctx, SourceLocation &Loc) const{\n    return ClassifyImpl(Ctx, &Loc);\n  }\n\n  /// Returns the set of floating point options that apply to this expression.\n  /// Only meaningful for operations on floating point values.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const;\n\n  /// getValueKindForType - Given a formal return or parameter type,\n  /// give its value kind.\n  static ExprValueKind getValueKindForType(QualType T) {\n    if (const ReferenceType *RT = T->getAs<ReferenceType>())\n      return (isa<LValueReferenceType>(RT)\n                ? VK_LValue\n                : (RT->getPointeeType()->isFunctionType()\n                     ? VK_LValue : VK_XValue));\n    return VK_RValue;\n  }\n\n  /// getValueKind - The value kind that this expression produces.\n  ExprValueKind getValueKind() const {\n    return static_cast<ExprValueKind>(ExprBits.ValueKind);\n  }\n\n  /// getObjectKind - The object kind that this expression produces.\n  /// Object kinds are meaningful only for expressions that yield an\n  /// l-value or x-value.\n  ExprObjectKind getObjectKind() const {\n    return static_cast<ExprObjectKind>(ExprBits.ObjectKind);\n  }\n\n  bool isOrdinaryOrBitFieldObject() const {\n    ExprObjectKind OK = getObjectKind();\n    return (OK == OK_Ordinary || OK == OK_BitField);\n  }\n\n  /// setValueKind - Set the value kind produced by this expression.\n  void setValueKind(ExprValueKind Cat) { ExprBits.ValueKind = Cat; }\n\n  /// setObjectKind - Set the object kind produced by this expression.\n  void setObjectKind(ExprObjectKind Cat) { ExprBits.ObjectKind = Cat; }\n\nprivate:\n  Classification ClassifyImpl(ASTContext &Ctx, SourceLocation *Loc) const;\n\npublic:\n\n  /// Returns true if this expression is a gl-value that\n  /// potentially refers to a bit-field.\n  ///\n  /// In C++, whether a gl-value refers to a bitfield is essentially\n  /// an aspect of the value-kind type system.\n  bool refersToBitField() const { return getObjectKind() == OK_BitField; }\n\n  /// If this expression refers to a bit-field, retrieve the\n  /// declaration of that bit-field.\n  ///\n  /// Note that this returns a non-null pointer in subtly different\n  /// places than refersToBitField returns true.  In particular, this can\n  /// return a non-null pointer even for r-values loaded from\n  /// bit-fields, but it will return null for a conditional bit-field.\n  FieldDecl *getSourceBitField();\n\n  const FieldDecl *getSourceBitField() const {\n    return const_cast<Expr*>(this)->getSourceBitField();\n  }\n\n  Decl *getReferencedDeclOfCallee();\n  const Decl *getReferencedDeclOfCallee() const {\n    return const_cast<Expr*>(this)->getReferencedDeclOfCallee();\n  }\n\n  /// If this expression is an l-value for an Objective C\n  /// property, find the underlying property reference expression.\n  const ObjCPropertyRefExpr *getObjCProperty() const;\n\n  /// Check if this expression is the ObjC 'self' implicit parameter.\n  bool isObjCSelfExpr() const;\n\n  /// Returns whether this expression refers to a vector element.\n  bool refersToVectorElement() const;\n\n  /// Returns whether this expression refers to a matrix element.\n  bool refersToMatrixElement() const {\n    return getObjectKind() == OK_MatrixComponent;\n  }\n\n  /// Returns whether this expression refers to a global register\n  /// variable.\n  bool refersToGlobalRegisterVar() const;\n\n  /// Returns whether this expression has a placeholder type.\n  bool hasPlaceholderType() const {\n    return getType()->isPlaceholderType();\n  }\n\n  /// Returns whether this expression has a specific placeholder type.\n  bool hasPlaceholderType(BuiltinType::Kind K) const {\n    assert(BuiltinType::isPlaceholderTypeKind(K));\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(getType()))\n      return BT->getKind() == K;\n    return false;\n  }\n\n  /// isKnownToHaveBooleanValue - Return true if this is an integer expression\n  /// that is known to return 0 or 1.  This happens for _Bool/bool expressions\n  /// but also int expressions which are produced by things like comparisons in\n  /// C.\n  ///\n  /// \\param Semantic If true, only return true for expressions that are known\n  /// to be semantically boolean, which might not be true even for expressions\n  /// that are known to evaluate to 0/1. For instance, reading an unsigned\n  /// bit-field with width '1' will evaluate to 0/1, but doesn't necessarily\n  /// semantically correspond to a bool.\n  bool isKnownToHaveBooleanValue(bool Semantic = true) const;\n\n  /// isIntegerConstantExpr - Return the value if this expression is a valid\n  /// integer constant expression.  If not a valid i-c-e, return None and fill\n  /// in Loc (if specified) with the location of the invalid expression.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  Optional<llvm::APSInt> getIntegerConstantExpr(const ASTContext &Ctx,\n                                                SourceLocation *Loc = nullptr,\n                                                bool isEvaluated = true) const;\n  bool isIntegerConstantExpr(const ASTContext &Ctx,\n                             SourceLocation *Loc = nullptr) const;\n\n  /// isCXX98IntegralConstantExpr - Return true if this expression is an\n  /// integral constant expression in C++98. Can only be used in C++.\n  bool isCXX98IntegralConstantExpr(const ASTContext &Ctx) const;\n\n  /// isCXX11ConstantExpr - Return true if this expression is a constant\n  /// expression in C++11. Can only be used in C++.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  bool isCXX11ConstantExpr(const ASTContext &Ctx, APValue *Result = nullptr,\n                           SourceLocation *Loc = nullptr) const;\n\n  /// isPotentialConstantExpr - Return true if this function's definition\n  /// might be usable in a constant expression in C++11, if it were marked\n  /// constexpr. Return false if the function can never produce a constant\n  /// expression, along with diagnostics describing why not.\n  static bool isPotentialConstantExpr(const FunctionDecl *FD,\n                                      SmallVectorImpl<\n                                        PartialDiagnosticAt> &Diags);\n\n  /// isPotentialConstantExprUnevaluted - Return true if this expression might\n  /// be usable in a constant expression in C++11 in an unevaluated context, if\n  /// it were in function FD marked constexpr. Return false if the function can\n  /// never produce a constant expression, along with diagnostics describing\n  /// why not.\n  static bool isPotentialConstantExprUnevaluated(Expr *E,\n                                                 const FunctionDecl *FD,\n                                                 SmallVectorImpl<\n                                                   PartialDiagnosticAt> &Diags);\n\n  /// isConstantInitializer - Returns true if this expression can be emitted to\n  /// IR as a constant, and thus can be used as a constant initializer in C.\n  /// If this expression is not constant and Culprit is non-null,\n  /// it is used to store the address of first non constant expr.\n  bool isConstantInitializer(ASTContext &Ctx, bool ForRef,\n                             const Expr **Culprit = nullptr) const;\n\n  /// EvalStatus is a struct with detailed info about an evaluation in progress.\n  struct EvalStatus {\n    /// Whether the evaluated expression has side effects.\n    /// For example, (f() && 0) can be folded, but it still has side effects.\n    bool HasSideEffects;\n\n    /// Whether the evaluation hit undefined behavior.\n    /// For example, 1.0 / 0.0 can be folded to Inf, but has undefined behavior.\n    /// Likewise, INT_MAX + 1 can be folded to INT_MIN, but has UB.\n    bool HasUndefinedBehavior;\n\n    /// Diag - If this is non-null, it will be filled in with a stack of notes\n    /// indicating why evaluation failed (or why it failed to produce a constant\n    /// expression).\n    /// If the expression is unfoldable, the notes will indicate why it's not\n    /// foldable. If the expression is foldable, but not a constant expression,\n    /// the notes will describes why it isn't a constant expression. If the\n    /// expression *is* a constant expression, no notes will be produced.\n    SmallVectorImpl<PartialDiagnosticAt> *Diag;\n\n    EvalStatus()\n        : HasSideEffects(false), HasUndefinedBehavior(false), Diag(nullptr) {}\n\n    // hasSideEffects - Return true if the evaluated expression has\n    // side effects.\n    bool hasSideEffects() const {\n      return HasSideEffects;\n    }\n  };\n\n  /// EvalResult is a struct with detailed info about an evaluated expression.\n  struct EvalResult : EvalStatus {\n    /// Val - This is the value the expression can be folded to.\n    APValue Val;\n\n    // isGlobalLValue - Return true if the evaluated lvalue expression\n    // is global.\n    bool isGlobalLValue() const;\n  };\n\n  /// EvaluateAsRValue - Return true if this is a constant which we can fold to\n  /// an rvalue using any crazy technique (that has nothing to do with language\n  /// standards) that we want to, even if the expression has side-effects. If\n  /// this function returns true, it returns the folded constant in Result. If\n  /// the expression is a glvalue, an lvalue-to-rvalue conversion will be\n  /// applied.\n  bool EvaluateAsRValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsBooleanCondition - Return true if this is a constant\n  /// which we can fold and convert to a boolean condition using\n  /// any crazy technique that we want to, even if the expression has\n  /// side-effects.\n  bool EvaluateAsBooleanCondition(bool &Result, const ASTContext &Ctx,\n                                  bool InConstantContext = false) const;\n\n  enum SideEffectsKind {\n    SE_NoSideEffects,          ///< Strictly evaluate the expression.\n    SE_AllowUndefinedBehavior, ///< Allow UB that we can give a value, but not\n                               ///< arbitrary unmodeled side effects.\n    SE_AllowSideEffects        ///< Allow any unmodeled side effect.\n  };\n\n  /// EvaluateAsInt - Return true if this is a constant which we can fold and\n  /// convert to an integer, using any crazy technique that we want to.\n  bool EvaluateAsInt(EvalResult &Result, const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                     bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a floating point value, using any crazy technique that we\n  /// want to.\n  bool EvaluateAsFloat(llvm::APFloat &Result, const ASTContext &Ctx,\n                       SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                       bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a fixed point value.\n  bool EvaluateAsFixedPoint(EvalResult &Result, const ASTContext &Ctx,\n                            SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                            bool InConstantContext = false) const;\n\n  /// isEvaluatable - Call EvaluateAsRValue to see if this expression can be\n  /// constant folded without side-effects, but discard the result.\n  bool isEvaluatable(const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects) const;\n\n  /// HasSideEffects - This routine returns true for all those expressions\n  /// which have any effect other than producing a value. Example is a function\n  /// call, volatile variable read, or throwing an exception. If\n  /// IncludePossibleEffects is false, this call treats certain expressions with\n  /// potential side effects (such as function call-like expressions,\n  /// instantiation-dependent expressions, or invocations from a macro) as not\n  /// having side effects.\n  bool HasSideEffects(const ASTContext &Ctx,\n                      bool IncludePossibleEffects = true) const;\n\n  /// Determine whether this expression involves a call to any function\n  /// that is not trivial.\n  bool hasNonTrivialCall(const ASTContext &Ctx) const;\n\n  /// EvaluateKnownConstInt - Call EvaluateAsRValue and return the folded\n  /// integer. This must be called on an expression that constant folds to an\n  /// integer.\n  llvm::APSInt EvaluateKnownConstInt(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  llvm::APSInt EvaluateKnownConstIntCheckOverflow(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  void EvaluateForOverflow(const ASTContext &Ctx) const;\n\n  /// EvaluateAsLValue - Evaluate an expression to see if we can fold it to an\n  /// lvalue with link time known address, with no side-effects.\n  bool EvaluateAsLValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsInitializer - Evaluate an expression as if it were the\n  /// initializer of the given declaration. Returns true if the initializer\n  /// can be folded to a constant, and produces any relevant notes. In C++11,\n  /// notes will be produced if the expression is not a constant expression.\n  bool EvaluateAsInitializer(APValue &Result, const ASTContext &Ctx,\n                             const VarDecl *VD,\n                             SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitializer) const;\n\n  /// EvaluateWithSubstitution - Evaluate an expression as if from the context\n  /// of a call to the given function with the given arguments, inside an\n  /// unevaluated context. Returns true if the expression could be folded to a\n  /// constant.\n  bool EvaluateWithSubstitution(APValue &Value, ASTContext &Ctx,\n                                const FunctionDecl *Callee,\n                                ArrayRef<const Expr*> Args,\n                                const Expr *This = nullptr) const;\n\n  enum class ConstantExprKind {\n    /// An integer constant expression (an array bound, enumerator, case value,\n    /// bit-field width, or similar) or similar.\n    Normal,\n    /// A non-class template argument. Such a value is only used for mangling,\n    /// not for code generation, so can refer to dllimported functions.\n    NonClassTemplateArgument,\n    /// A class template argument. Such a value is used for code generation.\n    ClassTemplateArgument,\n    /// An immediate invocation. The destruction of the end result of this\n    /// evaluation is not part of the evaluation, but all other temporaries\n    /// are destroyed.\n    ImmediateInvocation,\n  };\n\n  /// Evaluate an expression that is required to be a constant expression. Does\n  /// not check the syntactic constraints for C and C++98 constant expressions.\n  bool EvaluateAsConstantExpr(\n      EvalResult &Result, const ASTContext &Ctx,\n      ConstantExprKind Kind = ConstantExprKind::Normal) const;\n\n  /// If the current Expr is a pointer, this will try to statically\n  /// determine the number of bytes available where the pointer is pointing.\n  /// Returns true if all of the above holds and we were able to figure out the\n  /// size, false otherwise.\n  ///\n  /// \\param Type - How to evaluate the size of the Expr, as defined by the\n  /// \"type\" parameter of __builtin_object_size\n  bool tryEvaluateObjectSize(uint64_t &Result, ASTContext &Ctx,\n                             unsigned Type) const;\n\n  /// Enumeration used to describe the kind of Null pointer constant\n  /// returned from \\c isNullPointerConstant().\n  enum NullPointerConstantKind {\n    /// Expression is not a Null pointer constant.\n    NPCK_NotNull = 0,\n\n    /// Expression is a Null pointer constant built from a zero integer\n    /// expression that is not a simple, possibly parenthesized, zero literal.\n    /// C++ Core Issue 903 will classify these expressions as \"not pointers\"\n    /// once it is adopted.\n    /// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\n    NPCK_ZeroExpression,\n\n    /// Expression is a Null pointer constant built from a literal zero.\n    NPCK_ZeroLiteral,\n\n    /// Expression is a C++11 nullptr.\n    NPCK_CXX11_nullptr,\n\n    /// Expression is a GNU-style __null constant.\n    NPCK_GNUNull\n  };\n\n  /// Enumeration used to describe how \\c isNullPointerConstant()\n  /// should cope with value-dependent expressions.\n  enum NullPointerConstantValueDependence {\n    /// Specifies that the expression should never be value-dependent.\n    NPC_NeverValueDependent = 0,\n\n    /// Specifies that a value-dependent expression of integral or\n    /// dependent type should be considered a null pointer constant.\n    NPC_ValueDependentIsNull,\n\n    /// Specifies that a value-dependent expression should be considered\n    /// to never be a null pointer constant.\n    NPC_ValueDependentIsNotNull\n  };\n\n  /// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to\n  /// a Null pointer constant. The return value can further distinguish the\n  /// kind of NULL pointer constant that was detected.\n  NullPointerConstantKind isNullPointerConstant(\n      ASTContext &Ctx,\n      NullPointerConstantValueDependence NPC) const;\n\n  /// isOBJCGCCandidate - Return true if this expression may be used in a read/\n  /// write barrier.\n  bool isOBJCGCCandidate(ASTContext &Ctx) const;\n\n  /// Returns true if this expression is a bound member function.\n  bool isBoundMemberFunction(ASTContext &Ctx) const;\n\n  /// Given an expression of bound-member type, find the type\n  /// of the member.  Returns null if this is an *overloaded* bound\n  /// member expression.\n  static QualType findBoundMemberType(const Expr *expr);\n\n  /// Skip past any invisble AST nodes which might surround this\n  /// statement, such as ExprWithCleanups or ImplicitCastExpr nodes,\n  /// but also injected CXXMemberExpr and CXXConstructExpr which represent\n  /// implicit conversions.\n  Expr *IgnoreUnlessSpelledInSource();\n  const Expr *IgnoreUnlessSpelledInSource() const {\n    return const_cast<Expr *>(this)->IgnoreUnlessSpelledInSource();\n  }\n\n  /// Skip past any implicit casts which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ImplicitCastExpr\n  /// * FullExpr\n  Expr *IgnoreImpCasts() LLVM_READONLY;\n  const Expr *IgnoreImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreImpCasts();\n  }\n\n  /// Skip past any casts which might surround this expression until reaching\n  /// a fixed point. Skips:\n  /// * CastExpr\n  /// * FullExpr\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreCasts() LLVM_READONLY;\n  const Expr *IgnoreCasts() const {\n    return const_cast<Expr *>(this)->IgnoreCasts();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * CXXBindTemporaryExpr\n  Expr *IgnoreImplicit() LLVM_READONLY;\n  const Expr *IgnoreImplicit() const {\n    return const_cast<Expr *>(this)->IgnoreImplicit();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Same as IgnoreImplicit, except that it\n  /// also skips over implicit calls to constructors and conversion functions.\n  ///\n  /// FIXME: Should IgnoreImplicit do this?\n  Expr *IgnoreImplicitAsWritten() LLVM_READONLY;\n  const Expr *IgnoreImplicitAsWritten() const {\n    return const_cast<Expr *>(this)->IgnoreImplicitAsWritten();\n  }\n\n  /// Skip past any parentheses which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ParenExpr\n  /// * UnaryOperator if `UO_Extension`\n  /// * GenericSelectionExpr if `!isResultDependent()`\n  /// * ChooseExpr if `!isConditionDependent()`\n  /// * ConstantExpr\n  Expr *IgnoreParens() LLVM_READONLY;\n  const Expr *IgnoreParens() const {\n    return const_cast<Expr *>(this)->IgnoreParens();\n  }\n\n  /// Skip past any parentheses and implicit casts which might surround this\n  /// expression until reaching a fixed point.\n  /// FIXME: IgnoreParenImpCasts really ought to be equivalent to\n  /// IgnoreParens() + IgnoreImpCasts() until reaching a fixed point. However\n  /// this is currently not the case. Instead IgnoreParenImpCasts() skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenImpCasts() LLVM_READONLY;\n  const Expr *IgnoreParenImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenImpCasts();\n  }\n\n  /// Skip past any parentheses and casts which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips\n  Expr *IgnoreParenCasts() LLVM_READONLY;\n  const Expr *IgnoreParenCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenCasts();\n  }\n\n  /// Skip conversion operators. If this Expr is a call to a conversion\n  /// operator, return the argument.\n  Expr *IgnoreConversionOperatorSingleStep() LLVM_READONLY;\n  const Expr *IgnoreConversionOperatorSingleStep() const {\n    return const_cast<Expr *>(this)->IgnoreConversionOperatorSingleStep();\n  }\n\n  /// Skip past any parentheses and lvalue casts which might surround this\n  /// expression until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips, except that only lvalue-to-rvalue\n  ///   casts are skipped\n  /// FIXME: This is intended purely as a temporary workaround for code\n  /// that hasn't yet been rewritten to do the right thing about those\n  /// casts, and may disappear along with the last internal use.\n  Expr *IgnoreParenLValueCasts() LLVM_READONLY;\n  const Expr *IgnoreParenLValueCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenLValueCasts();\n  }\n\n  /// Skip past any parenthese and casts which do not change the value\n  /// (including ptr->int casts of the same size) until reaching a fixed point.\n  /// Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which do not change the value\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) LLVM_READONLY;\n  const Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) const {\n    return const_cast<Expr *>(this)->IgnoreParenNoopCasts(Ctx);\n  }\n\n  /// Skip past any parentheses and derived-to-base casts until reaching a\n  /// fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which represent a derived-to-base cast (CK_DerivedToBase,\n  ///   CK_UncheckedDerivedToBase and CK_NoOp)\n  Expr *IgnoreParenBaseCasts() LLVM_READONLY;\n  const Expr *IgnoreParenBaseCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenBaseCasts();\n  }\n\n  /// Determine whether this expression is a default function argument.\n  ///\n  /// Default arguments are implicitly generated in the abstract syntax tree\n  /// by semantic analysis for function calls, object constructions, etc. in\n  /// C++. Default arguments are represented by \\c CXXDefaultArgExpr nodes;\n  /// this routine also looks through any implicit casts to determine whether\n  /// the expression is a default argument.\n  bool isDefaultArgument() const;\n\n  /// Determine whether the result of this expression is a\n  /// temporary object of the given class type.\n  bool isTemporaryObject(ASTContext &Ctx, const CXXRecordDecl *TempTy) const;\n\n  /// Whether this expression is an implicit reference to 'this' in C++.\n  bool isImplicitCXXThis() const;\n\n  static bool hasAnyTypeDependentArguments(ArrayRef<Expr *> Exprs);\n\n  /// For an expression of class type or pointer to class type,\n  /// return the most derived class decl the expression is known to refer to.\n  ///\n  /// If this expression is a cast, this method looks through it to find the\n  /// most derived decl that can be inferred from the expression.\n  /// This is valid because derived-to-base conversions have undefined\n  /// behavior if the object isn't dynamically of the derived type.\n  const CXXRecordDecl *getBestDynamicClassType() const;\n\n  /// Get the inner expression that determines the best dynamic class.\n  /// If this is a prvalue, we guarantee that it is of the most-derived type\n  /// for the object itself.\n  const Expr *getBestDynamicClassTypeExpr() const;\n\n  /// Walk outwards from an expression we want to bind a reference to and\n  /// find the expression whose lifetime needs to be extended. Record\n  /// the LHSs of comma expressions and adjustments needed along the path.\n  const Expr *skipRValueSubobjectAdjustments(\n      SmallVectorImpl<const Expr *> &CommaLHS,\n      SmallVectorImpl<SubobjectAdjustment> &Adjustments) const;\n  const Expr *skipRValueSubobjectAdjustments() const {\n    SmallVector<const Expr *, 8> CommaLHSs;\n    SmallVector<SubobjectAdjustment, 8> Adjustments;\n    return skipRValueSubobjectAdjustments(CommaLHSs, Adjustments);\n  }\n\n  /// Checks that the two Expr's will refer to the same value as a comparison\n  /// operand.  The caller must ensure that the values referenced by the Expr's\n  /// are not modified between E1 and E2 or the result my be invalid.\n  static bool isSameComparisonOperand(const Expr* E1, const Expr* E2);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstExprConstant &&\n           T->getStmtClass() <= lastExprConstant;\n  }\n};\n// PointerLikeTypeTraits is specialized so it can be used with a forward-decl of\n// Expr. Verify that we got it right.\nstatic_assert(llvm::PointerLikeTypeTraits<Expr *>::NumLowBitsAvailable <=\n                  llvm::detail::ConstantLog2<alignof(Expr)>::value,\n              \"PointerLikeTypeTraits<Expr*> assumes too much alignment.\");\n\nusing ConstantExprKind = Expr::ConstantExprKind;\n\n//===----------------------------------------------------------------------===//\n// Wrapper Expressions.\n//===----------------------------------------------------------------------===//\n\n/// FullExpr - Represents a \"full-expression\" node.\nclass FullExpr : public Expr {\nprotected:\n Stmt *SubExpr;\n\n FullExpr(StmtClass SC, Expr *subexpr)\n     : Expr(SC, subexpr->getType(), subexpr->getValueKind(),\n            subexpr->getObjectKind()),\n       SubExpr(subexpr) {\n   setDependence(computeDependence(this));\n }\n  FullExpr(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) {}\npublic:\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n\n  /// As with any mutator of the AST, be very careful when modifying an\n  /// existing AST to preserve its invariants.\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstFullExprConstant &&\n           T->getStmtClass() <= lastFullExprConstant;\n  }\n};\n\n/// ConstantExpr - An expression that occurs in a constant context and\n/// optionally the result of evaluating the expression.\nclass ConstantExpr final\n    : public FullExpr,\n      private llvm::TrailingObjects<ConstantExpr, APValue, uint64_t> {\n  static_assert(std::is_same<uint64_t, llvm::APInt::WordType>::value,\n                \"ConstantExpr assumes that llvm::APInt::WordType is uint64_t \"\n                \"for tail-allocated storage\");\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\npublic:\n  /// Describes the kind of result that can be tail-allocated.\n  enum ResultStorageKind { RSK_None, RSK_Int64, RSK_APValue };\n\nprivate:\n  size_t numTrailingObjects(OverloadToken<APValue>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue;\n  }\n  size_t numTrailingObjects(OverloadToken<uint64_t>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64;\n  }\n\n  uint64_t &Int64Result() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64 &&\n           \"invalid accessor\");\n    return *getTrailingObjects<uint64_t>();\n  }\n  const uint64_t &Int64Result() const {\n    return const_cast<ConstantExpr *>(this)->Int64Result();\n  }\n  APValue &APValueResult() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue &&\n           \"invalid accessor\");\n    return *getTrailingObjects<APValue>();\n  }\n  APValue &APValueResult() const {\n    return const_cast<ConstantExpr *>(this)->APValueResult();\n  }\n\n  ConstantExpr(Expr *SubExpr, ResultStorageKind StorageKind,\n               bool IsImmediateInvocation);\n  ConstantExpr(EmptyShell Empty, ResultStorageKind StorageKind);\n\npublic:\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              const APValue &Result);\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              ResultStorageKind Storage = RSK_None,\n                              bool IsImmediateInvocation = false);\n  static ConstantExpr *CreateEmpty(const ASTContext &Context,\n                                   ResultStorageKind StorageKind);\n\n  static ResultStorageKind getStorageKind(const APValue &Value);\n  static ResultStorageKind getStorageKind(const Type *T,\n                                          const ASTContext &Context);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConstantExprClass;\n  }\n\n  void SetResult(APValue Value, const ASTContext &Context) {\n    MoveIntoResult(Value, Context);\n  }\n  void MoveIntoResult(APValue &Value, const ASTContext &Context);\n\n  APValue::ValueKind getResultAPValueKind() const {\n    return static_cast<APValue::ValueKind>(ConstantExprBits.APValueKind);\n  }\n  ResultStorageKind getResultStorageKind() const {\n    return static_cast<ResultStorageKind>(ConstantExprBits.ResultKind);\n  }\n  bool isImmediateInvocation() const {\n    return ConstantExprBits.IsImmediateInvocation;\n  }\n  bool hasAPValueResult() const {\n    return ConstantExprBits.APValueKind != APValue::None;\n  }\n  APValue getAPValueResult() const;\n  APValue &getResultAsAPValue() const { return APValueResult(); }\n  llvm::APSInt getResultAsAPSInt() const;\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Primary Expressions.\n//===----------------------------------------------------------------------===//\n\n/// OpaqueValueExpr - An expression referring to an opaque object of a\n/// fixed type and value class.  These don't correspond to concrete\n/// syntax; instead they're used to express operations (usually copy\n/// operations) on values whose source is generally obvious from\n/// context.\nclass OpaqueValueExpr : public Expr {\n  friend class ASTStmtReader;\n  Expr *SourceExpr;\n\npublic:\n  OpaqueValueExpr(SourceLocation Loc, QualType T, ExprValueKind VK,\n                  ExprObjectKind OK = OK_Ordinary, Expr *SourceExpr = nullptr)\n      : Expr(OpaqueValueExprClass, T, VK, OK), SourceExpr(SourceExpr) {\n    setIsUnique(false);\n    OpaqueValueExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Given an expression which invokes a copy constructor --- i.e.  a\n  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups ---\n  /// find the OpaqueValueExpr that's the source of the construction.\n  static const OpaqueValueExpr *findInCopyConstruct(const Expr *expr);\n\n  explicit OpaqueValueExpr(EmptyShell Empty)\n    : Expr(OpaqueValueExprClass, Empty) {}\n\n  /// Retrieve the location of this expression.\n  SourceLocation getLocation() const { return OpaqueValueExprBits.Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getBeginLoc() : getLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getEndLoc() : getLocation();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getExprLoc() : getLocation();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// The source expression of an opaque value expression is the\n  /// expression which originally generated the value.  This is\n  /// provided as a convenience for analyses that don't wish to\n  /// precisely model the execution behavior of the program.\n  ///\n  /// The source expression is typically set when building the\n  /// expression which binds the opaque value expression in the first\n  /// place.\n  Expr *getSourceExpr() const { return SourceExpr; }\n\n  void setIsUnique(bool V) {\n    assert((!V || SourceExpr) &&\n           \"unique OVEs are expected to have source expressions\");\n    OpaqueValueExprBits.IsUnique = V;\n  }\n\n  bool isUnique() const { return OpaqueValueExprBits.IsUnique; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OpaqueValueExprClass;\n  }\n};\n\n/// A reference to a declared variable, function, enum, etc.\n/// [C99 6.5.1p2]\n///\n/// This encodes all the information about how a declaration is referenced\n/// within an expression.\n///\n/// There are several optional constructs attached to DeclRefExprs only when\n/// they apply in order to conserve memory. These are laid out past the end of\n/// the object, and flags in the DeclRefExprBitfield track whether they exist:\n///\n///   DeclRefExprBits.HasQualifier:\n///       Specifies when this declaration reference expression has a C++\n///       nested-name-specifier.\n///   DeclRefExprBits.HasFoundDecl:\n///       Specifies when this declaration reference expression has a record of\n///       a NamedDecl (different from the referenced ValueDecl) which was found\n///       during name lookup and/or overload resolution.\n///   DeclRefExprBits.HasTemplateKWAndArgsInfo:\n///       Specifies when this declaration reference expression has an explicit\n///       C++ template keyword and/or template argument list.\n///   DeclRefExprBits.RefersToEnclosingVariableOrCapture\n///       Specifies when this declaration reference expression (validly)\n///       refers to an enclosed local or a captured variable.\nclass DeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DeclRefExpr, NestedNameSpecifierLoc,\n                                    NamedDecl *, ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The declaration that we are referencing.\n  ValueDecl *D;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in D.\n  DeclarationNameLoc DNLoc;\n\n  size_t numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {\n    return hasQualifier();\n  }\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  /// Test whether there is a distinct FoundDecl attached to the end of\n  /// this DRE.\n  bool hasFoundDecl() const { return DeclRefExprBits.HasFoundDecl; }\n\n  DeclRefExpr(const ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n              SourceLocation TemplateKWLoc, ValueDecl *D,\n              bool RefersToEnlosingVariableOrCapture,\n              const DeclarationNameInfo &NameInfo, NamedDecl *FoundD,\n              const TemplateArgumentListInfo *TemplateArgs, QualType T,\n              ExprValueKind VK, NonOdrUseReason NOUR);\n\n  /// Construct an empty declaration reference expression.\n  explicit DeclRefExpr(EmptyShell Empty) : Expr(DeclRefExprClass, Empty) {}\n\npublic:\n  DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,\n              bool RefersToEnclosingVariableOrCapture, QualType T,\n              ExprValueKind VK, SourceLocation L,\n              const DeclarationNameLoc &LocInfo = DeclarationNameLoc(),\n              NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture, SourceLocation NameLoc,\n         QualType T, ExprValueKind VK, NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture,\n         const DeclarationNameInfo &NameInfo, QualType T, ExprValueKind VK,\n         NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  /// Construct an empty declaration reference expression.\n  static DeclRefExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                  bool HasFoundDecl,\n                                  bool HasTemplateKWAndArgsInfo,\n                                  unsigned NumTemplateArgs);\n\n  ValueDecl *getDecl() { return D; }\n  const ValueDecl *getDecl() const { return D; }\n  void setDecl(ValueDecl *NewD);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDecl()->getDeclName(), getLocation(), DNLoc);\n  }\n\n  SourceLocation getLocation() const { return DeclRefExprBits.Loc; }\n  void setLocation(SourceLocation L) { DeclRefExprBits.Loc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Determine whether this declaration reference was preceded by a\n  /// C++ nested-name-specifier, e.g., \\c N::foo.\n  bool hasQualifier() const { return DeclRefExprBits.HasQualifier; }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifier())\n      return NestedNameSpecifierLoc();\n    return *getTrailingObjects<NestedNameSpecifierLoc>();\n  }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name. Otherwise, returns NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  ///\n  /// This Decl may be different from the ValueDecl actually referred to in the\n  /// presence of using declarations, etc. It always returns non-NULL, and may\n  /// simple return the ValueDecl when appropriate.\n\n  NamedDecl *getFoundDecl() {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  /// See non-const variant.\n  const NamedDecl *getFoundDecl() const {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name in this declaration reference\n  /// was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this declaration reference was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Returns true if this expression refers to a function that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return DeclRefExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a function that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    DeclRefExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(DeclRefExprBits.NonOdrUseReason);\n  }\n\n  /// Does this DeclRefExpr refer to an enclosing local or a captured\n  /// variable?\n  bool refersToEnclosingVariableOrCapture() const {\n    return DeclRefExprBits.RefersToEnclosingVariableOrCapture;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclRefExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Used by IntegerLiteral/FloatingLiteral to store the numeric without\n/// leaking memory.\n///\n/// For large floats/integers, APFloat/APInt will allocate memory from the heap\n/// to represent these numbers.  Unfortunately, when we use a BumpPtrAllocator\n/// to allocate IntegerLiteral/FloatingLiteral nodes the memory associated with\n/// the APFloat/APInt values will never get freed. APNumericStorage uses\n/// ASTContext's allocator for memory allocation.\nclass APNumericStorage {\n  union {\n    uint64_t VAL;    ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal;  ///< Used to store the >64 bits integer value.\n  };\n  unsigned BitWidth;\n\n  bool hasAllocation() const { return llvm::APInt::getNumWords(BitWidth) > 1; }\n\n  APNumericStorage(const APNumericStorage &) = delete;\n  void operator=(const APNumericStorage &) = delete;\n\nprotected:\n  APNumericStorage() : VAL(0), BitWidth(0) { }\n\n  llvm::APInt getIntValue() const {\n    unsigned NumWords = llvm::APInt::getNumWords(BitWidth);\n    if (NumWords > 1)\n      return llvm::APInt(BitWidth, NumWords, pVal);\n    else\n      return llvm::APInt(BitWidth, VAL);\n  }\n  void setIntValue(const ASTContext &C, const llvm::APInt &Val);\n};\n\nclass APIntStorage : private APNumericStorage {\npublic:\n  llvm::APInt getValue() const { return getIntValue(); }\n  void setValue(const ASTContext &C, const llvm::APInt &Val) {\n    setIntValue(C, Val);\n  }\n};\n\nclass APFloatStorage : private APNumericStorage {\npublic:\n  llvm::APFloat getValue(const llvm::fltSemantics &Semantics) const {\n    return llvm::APFloat(Semantics, getIntValue());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    setIntValue(C, Val.bitcastToAPInt());\n  }\n};\n\nclass IntegerLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n\n  /// Construct an empty integer literal.\n  explicit IntegerLiteral(EmptyShell Empty)\n    : Expr(IntegerLiteralClass, Empty) { }\n\npublic:\n  // type should be IntTy, LongTy, LongLongTy, UnsignedIntTy, UnsignedLongTy,\n  // or UnsignedLongLongTy\n  IntegerLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                 SourceLocation l);\n\n  /// Returns a new integer literal with value 'V' and type 'type'.\n  /// \\param type - either IntTy, LongTy, LongLongTy, UnsignedIntTy,\n  /// UnsignedLongTy, or UnsignedLongLongTy which should match the size of V\n  /// \\param V - the value that the returned integer literal contains.\n  static IntegerLiteral *Create(const ASTContext &C, const llvm::APInt &V,\n                                QualType type, SourceLocation l);\n  /// Returns a new empty integer literal.\n  static IntegerLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IntegerLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FixedPointLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n  unsigned Scale;\n\n  /// \\brief Construct an empty fixed-point literal.\n  explicit FixedPointLiteral(EmptyShell Empty)\n      : Expr(FixedPointLiteralClass, Empty) {}\n\n public:\n  FixedPointLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                    SourceLocation l, unsigned Scale);\n\n  // Store the int as is without any bit shifting.\n  static FixedPointLiteral *CreateFromRawInt(const ASTContext &C,\n                                             const llvm::APInt &V,\n                                             QualType type, SourceLocation l,\n                                             unsigned Scale);\n\n  /// Returns an empty fixed-point literal.\n  static FixedPointLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// \\brief Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  unsigned getScale() const { return Scale; }\n  void setScale(unsigned S) { Scale = S; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FixedPointLiteralClass;\n  }\n\n  std::string getValueAsString(unsigned Radix) const;\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass CharacterLiteral : public Expr {\npublic:\n  enum CharacterKind {\n    Ascii,\n    Wide,\n    UTF8,\n    UTF16,\n    UTF32\n  };\n\nprivate:\n  unsigned Value;\n  SourceLocation Loc;\npublic:\n  // type should be IntTy\n  CharacterLiteral(unsigned value, CharacterKind kind, QualType type,\n                   SourceLocation l)\n      : Expr(CharacterLiteralClass, type, VK_RValue, OK_Ordinary), Value(value),\n        Loc(l) {\n    CharacterLiteralBits.Kind = kind;\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty character literal.\n  CharacterLiteral(EmptyShell Empty) : Expr(CharacterLiteralClass, Empty) { }\n\n  SourceLocation getLocation() const { return Loc; }\n  CharacterKind getKind() const {\n    return static_cast<CharacterKind>(CharacterLiteralBits.Kind);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  unsigned getValue() const { return Value; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n  void setKind(CharacterKind kind) { CharacterLiteralBits.Kind = kind; }\n  void setValue(unsigned Val) { Value = Val; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CharacterLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FloatingLiteral : public Expr, private APFloatStorage {\n  SourceLocation Loc;\n\n  FloatingLiteral(const ASTContext &C, const llvm::APFloat &V, bool isexact,\n                  QualType Type, SourceLocation L);\n\n  /// Construct an empty floating-point literal.\n  explicit FloatingLiteral(const ASTContext &C, EmptyShell Empty);\n\npublic:\n  static FloatingLiteral *Create(const ASTContext &C, const llvm::APFloat &V,\n                                 bool isexact, QualType Type, SourceLocation L);\n  static FloatingLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  llvm::APFloat getValue() const {\n    return APFloatStorage::getValue(getSemantics());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    assert(&getSemantics() == &Val.getSemantics() && \"Inconsistent semantics\");\n    APFloatStorage::setValue(C, Val);\n  }\n\n  /// Get a raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  llvm::APFloatBase::Semantics getRawSemantics() const {\n    return static_cast<llvm::APFloatBase::Semantics>(\n        FloatingLiteralBits.Semantics);\n  }\n\n  /// Set the raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  void setRawSemantics(llvm::APFloatBase::Semantics Sem) {\n    FloatingLiteralBits.Semantics = Sem;\n  }\n\n  /// Return the APFloat semantics this literal uses.\n  const llvm::fltSemantics &getSemantics() const {\n    return llvm::APFloatBase::EnumToSemantics(\n        static_cast<llvm::APFloatBase::Semantics>(\n            FloatingLiteralBits.Semantics));\n  }\n\n  /// Set the APFloat semantics this literal uses.\n  void setSemantics(const llvm::fltSemantics &Sem) {\n    FloatingLiteralBits.Semantics = llvm::APFloatBase::SemanticsToEnum(Sem);\n  }\n\n  bool isExact() const { return FloatingLiteralBits.IsExact; }\n  void setExact(bool E) { FloatingLiteralBits.IsExact = E; }\n\n  /// getValueAsApproximateDouble - This returns the value as an inaccurate\n  /// double.  Note that this may cause loss of precision, but is useful for\n  /// debugging dumps, etc.\n  double getValueAsApproximateDouble() const;\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FloatingLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ImaginaryLiteral - We support imaginary integer and floating point literals,\n/// like \"1.0i\".  We represent these as a wrapper around FloatingLiteral and\n/// IntegerLiteral classes.  Instances of this class always have a Complex type\n/// whose element type matches the subexpression.\n///\nclass ImaginaryLiteral : public Expr {\n  Stmt *Val;\npublic:\n  ImaginaryLiteral(Expr *val, QualType Ty)\n      : Expr(ImaginaryLiteralClass, Ty, VK_RValue, OK_Ordinary), Val(val) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty imaginary literal.\n  explicit ImaginaryLiteral(EmptyShell Empty)\n    : Expr(ImaginaryLiteralClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Val->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Val->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImaginaryLiteralClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// StringLiteral - This represents a string literal expression, e.g. \"foo\"\n/// or L\"bar\" (wide strings). The actual string data can be obtained with\n/// getBytes() and is NOT null-terminated. The length of the string data is\n/// determined by calling getByteLength().\n///\n/// The C type for a string is always a ConstantArrayType. In C++, the char\n/// type is const qualified, in C it is not.\n///\n/// Note that strings in C can be formed by concatenation of multiple string\n/// literal pptokens in translation phase #6. This keeps track of the locations\n/// of each of these pieces.\n///\n/// Strings in C can also be truncated and extended by assigning into arrays,\n/// e.g. with constructs like:\n///   char X[2] = \"foobar\";\n/// In this case, getByteLength() will return 6, but the string literal will\n/// have type \"char[2]\".\nclass StringLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<StringLiteral, unsigned, SourceLocation,\n                                    char> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// StringLiteral is followed by several trailing objects. They are in order:\n  ///\n  /// * A single unsigned storing the length in characters of this string. The\n  ///   length in bytes is this length times the width of a single character.\n  ///   Always present and stored as a trailing objects because storing it in\n  ///   StringLiteral would increase the size of StringLiteral by sizeof(void *)\n  ///   due to alignment requirements. If you add some data to StringLiteral,\n  ///   consider moving it inside StringLiteral.\n  ///\n  /// * An array of getNumConcatenated() SourceLocation, one for each of the\n  ///   token this string is made of.\n  ///\n  /// * An array of getByteLength() char used to store the string data.\n\npublic:\n  enum StringKind { Ascii, Wide, UTF8, UTF16, UTF32 };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<unsigned>) const { return 1; }\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return getNumConcatenated();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<char>) const {\n    return getByteLength();\n  }\n\n  char *getStrDataAsChar() { return getTrailingObjects<char>(); }\n  const char *getStrDataAsChar() const { return getTrailingObjects<char>(); }\n\n  const uint16_t *getStrDataAsUInt16() const {\n    return reinterpret_cast<const uint16_t *>(getTrailingObjects<char>());\n  }\n\n  const uint32_t *getStrDataAsUInt32() const {\n    return reinterpret_cast<const uint32_t *>(getTrailingObjects<char>());\n  }\n\n  /// Build a string literal.\n  StringLiteral(const ASTContext &Ctx, StringRef Str, StringKind Kind,\n                bool Pascal, QualType Ty, const SourceLocation *Loc,\n                unsigned NumConcatenated);\n\n  /// Build an empty string literal.\n  StringLiteral(EmptyShell Empty, unsigned NumConcatenated, unsigned Length,\n                unsigned CharByteWidth);\n\n  /// Map a target and string kind to the appropriate character width.\n  static unsigned mapCharByteWidth(TargetInfo const &Target, StringKind SK);\n\n  /// Set one of the string literal token.\n  void setStrTokenLoc(unsigned TokNum, SourceLocation L) {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    getTrailingObjects<SourceLocation>()[TokNum] = L;\n  }\n\npublic:\n  /// This is the \"fully general\" constructor that allows representation of\n  /// strings formed from multiple concatenated tokens.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               const SourceLocation *Loc,\n                               unsigned NumConcatenated);\n\n  /// Simple constructor for string literals made from one token.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               SourceLocation Loc) {\n    return Create(Ctx, Str, Kind, Pascal, Ty, &Loc, 1);\n  }\n\n  /// Construct an empty string literal.\n  static StringLiteral *CreateEmpty(const ASTContext &Ctx,\n                                    unsigned NumConcatenated, unsigned Length,\n                                    unsigned CharByteWidth);\n\n  StringRef getString() const {\n    assert(getCharByteWidth() == 1 &&\n           \"This function is used in places that assume strings use char\");\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  /// Allow access to clients that need the byte representation, such as\n  /// ASTWriterStmt::VisitStringLiteral().\n  StringRef getBytes() const {\n    // FIXME: StringRef may not be the right type to use as a result for this.\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  void outputString(raw_ostream &OS) const;\n\n  uint32_t getCodeUnit(size_t i) const {\n    assert(i < getLength() && \"out of bounds access\");\n    switch (getCharByteWidth()) {\n    case 1:\n      return static_cast<unsigned char>(getStrDataAsChar()[i]);\n    case 2:\n      return getStrDataAsUInt16()[i];\n    case 4:\n      return getStrDataAsUInt32()[i];\n    }\n    llvm_unreachable(\"Unsupported character width!\");\n  }\n\n  unsigned getByteLength() const { return getCharByteWidth() * getLength(); }\n  unsigned getLength() const { return *getTrailingObjects<unsigned>(); }\n  unsigned getCharByteWidth() const { return StringLiteralBits.CharByteWidth; }\n\n  StringKind getKind() const {\n    return static_cast<StringKind>(StringLiteralBits.Kind);\n  }\n\n  bool isAscii() const { return getKind() == Ascii; }\n  bool isWide() const { return getKind() == Wide; }\n  bool isUTF8() const { return getKind() == UTF8; }\n  bool isUTF16() const { return getKind() == UTF16; }\n  bool isUTF32() const { return getKind() == UTF32; }\n  bool isPascal() const { return StringLiteralBits.IsPascal; }\n\n  bool containsNonAscii() const {\n    for (auto c : getString())\n      if (!isASCII(c))\n        return true;\n    return false;\n  }\n\n  bool containsNonAsciiOrNull() const {\n    for (auto c : getString())\n      if (!isASCII(c) || !c)\n        return true;\n    return false;\n  }\n\n  /// getNumConcatenated - Get the number of string literal tokens that were\n  /// concatenated in translation phase #6 to form this string literal.\n  unsigned getNumConcatenated() const {\n    return StringLiteralBits.NumConcatenated;\n  }\n\n  /// Get one of the string literal token.\n  SourceLocation getStrTokenLoc(unsigned TokNum) const {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    return getTrailingObjects<SourceLocation>()[TokNum];\n  }\n\n  /// getLocationOfByte - Return a source location that points to the specified\n  /// byte of this string literal.\n  ///\n  /// Strings are amazingly complex.  They can be formed from multiple tokens\n  /// and can have escape sequences in them in addition to the usual trigraph\n  /// and escaped newline business.  This routine handles this complexity.\n  ///\n  SourceLocation\n  getLocationOfByte(unsigned ByteNo, const SourceManager &SM,\n                    const LangOptions &Features, const TargetInfo &Target,\n                    unsigned *StartToken = nullptr,\n                    unsigned *StartTokenByteOffset = nullptr) const;\n\n  typedef const SourceLocation *tokloc_iterator;\n\n  tokloc_iterator tokloc_begin() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  tokloc_iterator tokloc_end() const {\n    return getTrailingObjects<SourceLocation>() + getNumConcatenated();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return *tokloc_begin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return *(tokloc_end() - 1); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StringLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// [C99 6.4.2.2] - A predefined identifier such as __func__.\nclass PredefinedExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PredefinedExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  // PredefinedExpr is optionally followed by a single trailing\n  // \"Stmt *\" for the predefined identifier. It is present if and only if\n  // hasFunctionName() is true and is always a \"StringLiteral *\".\n\npublic:\n  enum IdentKind {\n    Func,\n    Function,\n    LFunction, // Same as Function, but as wide string.\n    FuncDName,\n    FuncSig,\n    LFuncSig, // Same as FuncSig, but as as wide string\n    PrettyFunction,\n    /// The same as PrettyFunction, except that the\n    /// 'virtual' keyword is omitted for virtual member functions.\n    PrettyFunctionNoVirtual\n  };\n\nprivate:\n  PredefinedExpr(SourceLocation L, QualType FNTy, IdentKind IK,\n                 StringLiteral *SL);\n\n  explicit PredefinedExpr(EmptyShell Empty, bool HasFunctionName);\n\n  /// True if this PredefinedExpr has storage for a function name.\n  bool hasFunctionName() const { return PredefinedExprBits.HasFunctionName; }\n\n  void setFunctionName(StringLiteral *SL) {\n    assert(hasFunctionName() &&\n           \"This PredefinedExpr has no storage for a function name!\");\n    *getTrailingObjects<Stmt *>() = SL;\n  }\n\npublic:\n  /// Create a PredefinedExpr.\n  static PredefinedExpr *Create(const ASTContext &Ctx, SourceLocation L,\n                                QualType FNTy, IdentKind IK, StringLiteral *SL);\n\n  /// Create an empty PredefinedExpr.\n  static PredefinedExpr *CreateEmpty(const ASTContext &Ctx,\n                                     bool HasFunctionName);\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(PredefinedExprBits.Kind);\n  }\n\n  SourceLocation getLocation() const { return PredefinedExprBits.Loc; }\n  void setLocation(SourceLocation L) { PredefinedExprBits.Loc = L; }\n\n  StringLiteral *getFunctionName() {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  const StringLiteral *getFunctionName() const {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  static StringRef getIdentKindName(IdentKind IK);\n  StringRef getIdentKindName() const {\n    return getIdentKindName(getIdentKind());\n  }\n\n  static std::string ComputeName(IdentKind IK, const Decl *CurrentDecl);\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PredefinedExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n};\n\n/// ParenExpr - This represents a parethesized expression, e.g. \"(1)\".  This\n/// AST node is only formed if full location information is requested.\nclass ParenExpr : public Expr {\n  SourceLocation L, R;\n  Stmt *Val;\npublic:\n  ParenExpr(SourceLocation l, SourceLocation r, Expr *val)\n      : Expr(ParenExprClass, val->getType(), val->getValueKind(),\n             val->getObjectKind()),\n        L(l), R(r), Val(val) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty parenthesized expression.\n  explicit ParenExpr(EmptyShell Empty)\n    : Expr(ParenExprClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return L; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return R; }\n\n  /// Get the location of the left parentheses '('.\n  SourceLocation getLParen() const { return L; }\n  void setLParen(SourceLocation Loc) { L = Loc; }\n\n  /// Get the location of the right parentheses ')'.\n  SourceLocation getRParen() const { return R; }\n  void setRParen(SourceLocation Loc) { R = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// UnaryOperator - This represents the unary-expression's (except sizeof and\n/// alignof), the postinc/postdec operators from postfix-expression, and various\n/// extensions.\n///\n/// Notes on various nodes:\n///\n/// Real/Imag - These return the real/imag part of a complex operand.  If\n///   applied to a non-complex value, the former returns its operand and the\n///   later returns zero in the type of the operand.\n///\nclass UnaryOperator final\n    : public Expr,\n      private llvm::TrailingObjects<UnaryOperator, FPOptionsOverride> {\n  Stmt *Val;\n\n  size_t numTrailingObjects(OverloadToken<FPOptionsOverride>) const {\n    return UnaryOperatorBits.HasFPFeatures ? 1 : 0;\n  }\n\n  FPOptionsOverride &getTrailingFPFeatures() {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\n  const FPOptionsOverride &getTrailingFPFeatures() const {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\npublic:\n  typedef UnaryOperatorKind Opcode;\n\nprotected:\n  UnaryOperator(const ASTContext &Ctx, Expr *input, Opcode opc, QualType type,\n                ExprValueKind VK, ExprObjectKind OK, SourceLocation l,\n                bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  /// Build an empty unary operator.\n  explicit UnaryOperator(bool HasFPFeatures, EmptyShell Empty)\n      : Expr(UnaryOperatorClass, Empty) {\n    UnaryOperatorBits.Opc = UO_AddrOf;\n    UnaryOperatorBits.HasFPFeatures = HasFPFeatures;\n  }\n\npublic:\n  static UnaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static UnaryOperator *Create(const ASTContext &C, Expr *input, Opcode opc,\n                               QualType type, ExprValueKind VK,\n                               ExprObjectKind OK, SourceLocation l,\n                               bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(UnaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { UnaryOperatorBits.Opc = Opc; }\n\n  Expr *getSubExpr() const { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return UnaryOperatorBits.Loc; }\n  void setOperatorLoc(SourceLocation L) { UnaryOperatorBits.Loc = L; }\n\n  /// Returns true if the unary operator can cause an overflow. For instance,\n  ///   signed int i = INT_MAX; i++;\n  ///   signed char c = CHAR_MAX; c++;\n  /// Due to integer promotions, c++ is promoted to an int before the postfix\n  /// increment, and the result is an int that cannot overflow. However, i++\n  /// can overflow.\n  bool canOverflow() const { return UnaryOperatorBits.CanOverflow; }\n  void setCanOverflow(bool C) { UnaryOperatorBits.CanOverflow = C; }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\n  /// isPostfix - Return true if this is a postfix operation, like x++.\n  static bool isPostfix(Opcode Op) {\n    return Op == UO_PostInc || Op == UO_PostDec;\n  }\n\n  /// isPrefix - Return true if this is a prefix operation, like --x.\n  static bool isPrefix(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PreDec;\n  }\n\n  bool isPrefix() const { return isPrefix(getOpcode()); }\n  bool isPostfix() const { return isPostfix(getOpcode()); }\n\n  static bool isIncrementOp(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PostInc;\n  }\n  bool isIncrementOp() const {\n    return isIncrementOp(getOpcode());\n  }\n\n  static bool isDecrementOp(Opcode Op) {\n    return Op == UO_PreDec || Op == UO_PostDec;\n  }\n  bool isDecrementOp() const {\n    return isDecrementOp(getOpcode());\n  }\n\n  static bool isIncrementDecrementOp(Opcode Op) { return Op <= UO_PreDec; }\n  bool isIncrementDecrementOp() const {\n    return isIncrementDecrementOp(getOpcode());\n  }\n\n  static bool isArithmeticOp(Opcode Op) {\n    return Op >= UO_Plus && Op <= UO_LNot;\n  }\n  bool isArithmeticOp() const { return isArithmeticOp(getOpcode()); }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"sizeof\" or \"[pre]++\"\n  static StringRef getOpcodeStr(Opcode Op);\n\n  /// Retrieve the unary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO, bool Postfix);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given unary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isPostfix() ? Val->getBeginLoc() : getOperatorLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return isPostfix() ? getOperatorLoc() : Val->getEndLoc();\n  }\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryOperatorClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n\n  /// Is FPFeatures in Trailing Storage?\n  bool hasStoredFPFeatures() const { return UnaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    return getTrailingFPFeatures();\n  }\n\nprotected:\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) { getTrailingFPFeatures() = F; }\n\npublic:\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n  FPOptionsOverride getFPOptionsOverride() const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  friend TrailingObjects;\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Helper class for OffsetOfExpr.\n\n// __builtin_offsetof(type, identifier(.identifier|[expr])*)\nclass OffsetOfNode {\npublic:\n  /// The kind of offsetof node we have.\n  enum Kind {\n    /// An index into an array.\n    Array = 0x00,\n    /// A field.\n    Field = 0x01,\n    /// A field in a dependent type, known only by its name.\n    Identifier = 0x02,\n    /// An implicit indirection through a C++ base class, when the\n    /// field found is in a base class.\n    Base = 0x03\n  };\n\nprivate:\n  enum { MaskBits = 2, Mask = 0x03 };\n\n  /// The source range that covers this part of the designator.\n  SourceRange Range;\n\n  /// The data describing the designator, which comes in three\n  /// different forms, depending on the lower two bits.\n  ///   - An unsigned index into the array of Expr*'s stored after this node\n  ///     in memory, for [constant-expression] designators.\n  ///   - A FieldDecl*, for references to a known field.\n  ///   - An IdentifierInfo*, for references to a field with a given name\n  ///     when the class type is dependent.\n  ///   - A CXXBaseSpecifier*, for references that look at a field in a\n  ///     base class.\n  uintptr_t Data;\n\npublic:\n  /// Create an offsetof node that refers to an array element.\n  OffsetOfNode(SourceLocation LBracketLoc, unsigned Index,\n               SourceLocation RBracketLoc)\n      : Range(LBracketLoc, RBracketLoc), Data((Index << 2) | Array) {}\n\n  /// Create an offsetof node that refers to a field.\n  OffsetOfNode(SourceLocation DotLoc, FieldDecl *Field, SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Field) | OffsetOfNode::Field) {}\n\n  /// Create an offsetof node that refers to an identifier.\n  OffsetOfNode(SourceLocation DotLoc, IdentifierInfo *Name,\n               SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Name) | Identifier) {}\n\n  /// Create an offsetof node that refers into a C++ base class.\n  explicit OffsetOfNode(const CXXBaseSpecifier *Base)\n      : Range(), Data(reinterpret_cast<uintptr_t>(Base) | OffsetOfNode::Base) {}\n\n  /// Determine what kind of offsetof node this is.\n  Kind getKind() const { return static_cast<Kind>(Data & Mask); }\n\n  /// For an array element node, returns the index into the array\n  /// of expressions.\n  unsigned getArrayExprIndex() const {\n    assert(getKind() == Array);\n    return Data >> 2;\n  }\n\n  /// For a field offsetof node, returns the field.\n  FieldDecl *getField() const {\n    assert(getKind() == Field);\n    return reinterpret_cast<FieldDecl *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// For a field or identifier offsetof node, returns the name of\n  /// the field.\n  IdentifierInfo *getFieldName() const;\n\n  /// For a base class node, returns the base specifier.\n  CXXBaseSpecifier *getBase() const {\n    assert(getKind() == Base);\n    return reinterpret_cast<CXXBaseSpecifier *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// Retrieve the source range that covers this offsetof node.\n  ///\n  /// For an array element node, the source range contains the locations of\n  /// the square brackets. For a field or identifier node, the source range\n  /// contains the location of the period (if there is one) and the\n  /// identifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n};\n\n/// OffsetOfExpr - [C99 7.17] - This represents an expression of the form\n/// offsetof(record-type, member-designator). For example, given:\n/// @code\n/// struct S {\n///   float f;\n///   double d;\n/// };\n/// struct T {\n///   int i;\n///   struct S s[10];\n/// };\n/// @endcode\n/// we can represent and evaluate the expression @c offsetof(struct T, s[2].d).\n\nclass OffsetOfExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OffsetOfExpr, OffsetOfNode, Expr *> {\n  SourceLocation OperatorLoc, RParenLoc;\n  // Base type;\n  TypeSourceInfo *TSInfo;\n  // Number of sub-components (i.e. instances of OffsetOfNode).\n  unsigned NumComps;\n  // Number of sub-expressions (i.e. array subscript expressions).\n  unsigned NumExprs;\n\n  size_t numTrailingObjects(OverloadToken<OffsetOfNode>) const {\n    return NumComps;\n  }\n\n  OffsetOfExpr(const ASTContext &C, QualType type,\n               SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n               ArrayRef<OffsetOfNode> comps, ArrayRef<Expr*> exprs,\n               SourceLocation RParenLoc);\n\n  explicit OffsetOfExpr(unsigned numComps, unsigned numExprs)\n    : Expr(OffsetOfExprClass, EmptyShell()),\n      TSInfo(nullptr), NumComps(numComps), NumExprs(numExprs) {}\n\npublic:\n\n  static OffsetOfExpr *Create(const ASTContext &C, QualType type,\n                              SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n                              ArrayRef<OffsetOfNode> comps,\n                              ArrayRef<Expr*> exprs, SourceLocation RParenLoc);\n\n  static OffsetOfExpr *CreateEmpty(const ASTContext &C,\n                                   unsigned NumComps, unsigned NumExprs);\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n  void setOperatorLoc(SourceLocation L) { OperatorLoc = L; }\n\n  /// Return the location of the right parentheses.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation R) { RParenLoc = R; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TSInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tsi) {\n    TSInfo = tsi;\n  }\n\n  const OffsetOfNode &getComponent(unsigned Idx) const {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    return getTrailingObjects<OffsetOfNode>()[Idx];\n  }\n\n  void setComponent(unsigned Idx, OffsetOfNode ON) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<OffsetOfNode>()[Idx] = ON;\n  }\n\n  unsigned getNumComponents() const {\n    return NumComps;\n  }\n\n  Expr* getIndexExpr(unsigned Idx) {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  const Expr *getIndexExpr(unsigned Idx) const {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  void setIndexExpr(unsigned Idx, Expr* E) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<Expr *>()[Idx] = E;\n  }\n\n  unsigned getNumExpressions() const {\n    return NumExprs;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OffsetOfExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(begin, begin + NumExprs);\n  }\n  const_child_range children() const {\n    Stmt *const *begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(begin, begin + NumExprs);\n  }\n  friend TrailingObjects;\n};\n\n/// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)\n/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and\n/// vec_step (OpenCL 1.1 6.11.12).\nclass UnaryExprOrTypeTraitExpr : public Expr {\n  union {\n    TypeSourceInfo *Ty;\n    Stmt *Ex;\n  } Argument;\n  SourceLocation OpLoc, RParenLoc;\n\npublic:\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, TypeSourceInfo *TInfo,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp)\n      : Expr(UnaryExprOrTypeTraitExprClass, resultType, VK_RValue, OK_Ordinary),\n        OpLoc(op), RParenLoc(rp) {\n    assert(ExprKind <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = ExprKind;\n    assert(static_cast<unsigned>(ExprKind) ==\n               UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n    Argument.Ty = TInfo;\n    setDependence(computeDependence(this));\n  }\n\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, Expr *E,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp);\n\n  /// Construct an empty sizeof/alignof expression.\n  explicit UnaryExprOrTypeTraitExpr(EmptyShell Empty)\n    : Expr(UnaryExprOrTypeTraitExprClass, Empty) { }\n\n  UnaryExprOrTypeTrait getKind() const {\n    return static_cast<UnaryExprOrTypeTrait>(UnaryExprOrTypeTraitExprBits.Kind);\n  }\n  void setKind(UnaryExprOrTypeTrait K) {\n    assert(K <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = K;\n    assert(static_cast<unsigned>(K) == UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n  }\n\n  bool isArgumentType() const { return UnaryExprOrTypeTraitExprBits.IsType; }\n  QualType getArgumentType() const {\n    return getArgumentTypeInfo()->getType();\n  }\n  TypeSourceInfo *getArgumentTypeInfo() const {\n    assert(isArgumentType() && \"calling getArgumentType() when arg is expr\");\n    return Argument.Ty;\n  }\n  Expr *getArgumentExpr() {\n    assert(!isArgumentType() && \"calling getArgumentExpr() when arg is type\");\n    return static_cast<Expr*>(Argument.Ex);\n  }\n  const Expr *getArgumentExpr() const {\n    return const_cast<UnaryExprOrTypeTraitExpr*>(this)->getArgumentExpr();\n  }\n\n  void setArgument(Expr *E) {\n    Argument.Ex = E;\n    UnaryExprOrTypeTraitExprBits.IsType = false;\n  }\n  void setArgument(TypeSourceInfo *TInfo) {\n    Argument.Ty = TInfo;\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n  }\n\n  /// Gets the argument type, or the type of the argument expression, whichever\n  /// is appropriate.\n  QualType getTypeOfArgument() const {\n    return isArgumentType() ? getArgumentType() : getArgumentExpr()->getType();\n  }\n\n  SourceLocation getOperatorLoc() const { return OpLoc; }\n  void setOperatorLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryExprOrTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children();\n  const_child_range children() const;\n};\n\n//===----------------------------------------------------------------------===//\n// Postfix Operators.\n//===----------------------------------------------------------------------===//\n\n/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.\nclass ArraySubscriptExpr : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\n  bool lhsIsBase() const { return getRHS()->getType()->isIntegerType(); }\n\npublic:\n  ArraySubscriptExpr(Expr *lhs, Expr *rhs, QualType t, ExprValueKind VK,\n                     ExprObjectKind OK, SourceLocation rbracketloc)\n      : Expr(ArraySubscriptExprClass, t, VK, OK) {\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = rbracketloc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array subscript expression.\n  explicit ArraySubscriptExpr(EmptyShell Shell)\n    : Expr(ArraySubscriptExprClass, Shell) { }\n\n  /// An array access can be written A[4] or 4[A] (both are equivalent).\n  /// - getBase() and getIdx() always present the normalized view: A[4].\n  ///    In this case getBase() returns \"A\" and getIdx() returns \"4\".\n  /// - getLHS() and getRHS() present the syntactic view. e.g. for\n  ///    4[A] getLHS() returns \"4\".\n  /// Note: Because vector element access is also written A[4] we must\n  /// predicate the format conversion in getBase and getIdx only on the\n  /// the type of the RHS, as it is possible for the LHS to be a vector of\n  /// integer type\n  Expr *getLHS() { return cast<Expr>(SubExprs[LHS]); }\n  const Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n\n  Expr *getRHS() { return cast<Expr>(SubExprs[RHS]); }\n  const Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  Expr *getBase() { return lhsIsBase() ? getLHS() : getRHS(); }\n  const Expr *getBase() const { return lhsIsBase() ? getLHS() : getRHS(); }\n\n  Expr *getIdx() { return lhsIsBase() ? getRHS() : getLHS(); }\n  const Expr *getIdx() const { return lhsIsBase() ? getRHS() : getLHS(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArraySubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// MatrixSubscriptExpr - Matrix subscript expression for the MatrixType\n/// extension.\n/// MatrixSubscriptExpr can be either incomplete (only Base and RowIdx are set\n/// so far, the type is IncompleteMatrixIdx) or complete (Base, RowIdx and\n/// ColumnIdx refer to valid expressions). Incomplete matrix expressions only\n/// exist during the initial construction of the AST.\nclass MatrixSubscriptExpr : public Expr {\n  enum { BASE, ROW_IDX, COLUMN_IDX, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  MatrixSubscriptExpr(Expr *Base, Expr *RowIdx, Expr *ColumnIdx, QualType T,\n                      SourceLocation RBracketLoc)\n      : Expr(MatrixSubscriptExprClass, T, Base->getValueKind(),\n             OK_MatrixComponent) {\n    SubExprs[BASE] = Base;\n    SubExprs[ROW_IDX] = RowIdx;\n    SubExprs[COLUMN_IDX] = ColumnIdx;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = RBracketLoc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty matrix subscript expression.\n  explicit MatrixSubscriptExpr(EmptyShell Shell)\n      : Expr(MatrixSubscriptExprClass, Shell) {}\n\n  bool isIncomplete() const {\n    bool IsIncomplete = hasPlaceholderType(BuiltinType::IncompleteMatrixIdx);\n    assert((SubExprs[COLUMN_IDX] || IsIncomplete) &&\n           \"expressions without column index must be marked as incomplete\");\n    return IsIncomplete;\n  }\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  Expr *getRowIdx() { return cast<Expr>(SubExprs[ROW_IDX]); }\n  const Expr *getRowIdx() const { return cast<Expr>(SubExprs[ROW_IDX]); }\n  void setRowIdx(Expr *E) { SubExprs[ROW_IDX] = E; }\n\n  Expr *getColumnIdx() { return cast_or_null<Expr>(SubExprs[COLUMN_IDX]); }\n  const Expr *getColumnIdx() const {\n    assert(!isIncomplete() &&\n           \"cannot get the column index of an incomplete expression\");\n    return cast<Expr>(SubExprs[COLUMN_IDX]);\n  }\n  void setColumnIdx(Expr *E) { SubExprs[COLUMN_IDX] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MatrixSubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).\n/// CallExpr itself represents a normal function call, e.g., \"f(x, 2)\",\n/// while its subclasses may represent alternative syntax that (semantically)\n/// results in a function call. For example, CXXOperatorCallExpr is\n/// a subclass for overloaded operator calls that use operator syntax, e.g.,\n/// \"str1 + str2\" to resolve to a function call.\nclass CallExpr : public Expr {\n  enum { FN = 0, PREARGS_START = 1 };\n\n  /// The number of arguments in the call expression.\n  unsigned NumArgs;\n\n  /// The location of the right parenthese. This has a different meaning for\n  /// the derived classes of CallExpr.\n  SourceLocation RParenLoc;\n\n  // CallExpr store some data in trailing objects. However since CallExpr\n  // is used a base of other expression classes we cannot use\n  // llvm::TrailingObjects. Instead we manually perform the pointer arithmetic\n  // and casts.\n  //\n  // The trailing objects are in order:\n  //\n  // * A single \"Stmt *\" for the callee expression.\n  //\n  // * An array of getNumPreArgs() \"Stmt *\" for the pre-argument expressions.\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the argument expressions.\n  //\n  // * An optional of type FPOptionsOverride.\n  //\n  // Note that we store the offset in bytes from the this pointer to the start\n  // of the trailing objects. It would be perfectly possible to compute it\n  // based on the dynamic kind of the CallExpr. However 1.) we have plenty of\n  // space in the bit-fields of Stmt. 2.) It was benchmarked to be faster to\n  // compute this once and then load the offset from the bit-fields of Stmt,\n  // instead of re-computing the offset each time the trailing objects are\n  // accessed.\n\n  /// Return a pointer to the start of the trailing array of \"Stmt *\".\n  Stmt **getTrailingStmts() {\n    return reinterpret_cast<Stmt **>(reinterpret_cast<char *>(this) +\n                                     CallExprBits.OffsetToTrailingObjects);\n  }\n  Stmt *const *getTrailingStmts() const {\n    return const_cast<CallExpr *>(this)->getTrailingStmts();\n  }\n\n  /// Map a statement class to the appropriate offset in bytes from the\n  /// this pointer to the trailing objects.\n  static unsigned offsetToTrailingObjects(StmtClass SC);\n\n  unsigned getSizeOfTrailingStmts() const {\n    return (1 + getNumPreArgs() + getNumArgs()) * sizeof(Stmt *);\n  }\n\n  size_t getOffsetOfTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts();\n  }\n\npublic:\n  enum class ADLCallKind : bool { NotADL, UsesADL };\n  static constexpr ADLCallKind NotADL = ADLCallKind::NotADL;\n  static constexpr ADLCallKind UsesADL = ADLCallKind::UsesADL;\n\nprotected:\n  /// Build a call expression, assuming that appropriate storage has been\n  /// allocated for the trailing objects.\n  CallExpr(StmtClass SC, Expr *Fn, ArrayRef<Expr *> PreArgs,\n           ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n           SourceLocation RParenLoc, FPOptionsOverride FPFeatures,\n           unsigned MinNumArgs, ADLCallKind UsesADL);\n\n  /// Build an empty call expression, for deserialization.\n  CallExpr(StmtClass SC, unsigned NumPreArgs, unsigned NumArgs,\n           bool hasFPFeatures, EmptyShell Empty);\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used by the derived classes to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumPreArgs, unsigned NumArgs,\n                                        bool HasFPFeatures) {\n    return (1 + NumPreArgs + NumArgs) * sizeof(Stmt *) +\n           HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n\n  Stmt *getPreArg(unsigned I) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  const Stmt *getPreArg(unsigned I) const {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  void setPreArg(unsigned I, Stmt *PreArg) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    getTrailingStmts()[PREARGS_START + I] = PreArg;\n  }\n\n  unsigned getNumPreArgs() const { return CallExprBits.NumPreArgs; }\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + CallExprBits.OffsetToTrailingObjects +\n        getSizeOfTrailingStmts());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) +\n        CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts());\n  }\n\npublic:\n  /// Create a call expression.\n  /// \\param Fn     The callee expression,\n  /// \\param Args   The argument array,\n  /// \\param Ty     The type of the call expression (which is *not* the return\n  ///               type in general),\n  /// \\param VK     The value kind of the call expression (lvalue, rvalue, ...),\n  /// \\param RParenLoc  The location of the right parenthesis in the call\n  ///                   expression.\n  /// \\param FPFeatures Floating-point features associated with the call,\n  /// \\param MinNumArgs Specifies the minimum number of arguments. The actual\n  ///                   number of arguments will be the greater of Args.size()\n  ///                   and MinNumArgs. This is used in a few places to allocate\n  ///                   enough storage for the default arguments.\n  /// \\param UsesADL    Specifies whether the callee was found through\n  ///                   argument-dependent lookup.\n  ///\n  /// Note that you can use CreateTemporary if you need a temporary call\n  /// expression on the stack.\n  static CallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                          ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n                          SourceLocation RParenLoc,\n                          FPOptionsOverride FPFeatures, unsigned MinNumArgs = 0,\n                          ADLCallKind UsesADL = NotADL);\n\n  /// Create a temporary call expression with no arguments in the memory\n  /// pointed to by Mem. Mem must points to at least sizeof(CallExpr)\n  /// + sizeof(Stmt *) bytes of storage, aligned to alignof(CallExpr):\n  ///\n  /// \\code{.cpp}\n  ///   alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];\n  ///   CallExpr *TheCall = CallExpr::CreateTemporary(Buffer, etc);\n  /// \\endcode\n  static CallExpr *CreateTemporary(void *Mem, Expr *Fn, QualType Ty,\n                                   ExprValueKind VK, SourceLocation RParenLoc,\n                                   ADLCallKind UsesADL = NotADL);\n\n  /// Create an empty call expression, for deserialization.\n  static CallExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs,\n                               bool HasFPFeatures, EmptyShell Empty);\n\n  Expr *getCallee() { return cast<Expr>(getTrailingStmts()[FN]); }\n  const Expr *getCallee() const { return cast<Expr>(getTrailingStmts()[FN]); }\n  void setCallee(Expr *F) { getTrailingStmts()[FN] = F; }\n\n  ADLCallKind getADLCallKind() const {\n    return static_cast<ADLCallKind>(CallExprBits.UsesADL);\n  }\n  void setADLCallKind(ADLCallKind V = UsesADL) {\n    CallExprBits.UsesADL = static_cast<bool>(V);\n  }\n  bool usesADL() const { return getADLCallKind() == UsesADL; }\n\n  bool hasStoredFPFeatures() const { return CallExprBits.HasFPFeatures; }\n\n  Decl *getCalleeDecl() { return getCallee()->getReferencedDeclOfCallee(); }\n  const Decl *getCalleeDecl() const {\n    return getCallee()->getReferencedDeclOfCallee();\n  }\n\n  /// If the callee is a FunctionDecl, return it. Otherwise return null.\n  FunctionDecl *getDirectCallee() {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n  const FunctionDecl *getDirectCallee() const {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the call arguments.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingStmts() + PREARGS_START +\n                                     getNumPreArgs());\n  }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(\n        getTrailingStmts() + PREARGS_START + getNumPreArgs());\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// Reduce the number of arguments in this call expression. This is used for\n  /// example during error recovery to drop extra arguments. There is no way\n  /// to perform the opposite because: 1.) We don't track how much storage\n  /// we have for the argument array 2.) This would potentially require growing\n  /// the argument array, something we cannot support since the arguments are\n  /// stored in a trailing array.\n  void shrinkNumArgs(unsigned NewNumArgs) {\n    assert((NewNumArgs <= getNumArgs()) &&\n           \"shrinkNumArgs cannot increase the number of arguments!\");\n    NumArgs = NewNumArgs;\n  }\n\n  /// Bluntly set a new number of arguments without doing any checks whatsoever.\n  /// Only used during construction of a CallExpr in a few places in Sema.\n  /// FIXME: Find a way to remove it.\n  void setNumArgsUnsafe(unsigned NewNumArgs) { NumArgs = NewNumArgs; }\n\n  typedef ExprIterator arg_iterator;\n  typedef ConstExprIterator const_arg_iterator;\n  typedef llvm::iterator_range<arg_iterator> arg_range;\n  typedef llvm::iterator_range<const_arg_iterator> const_arg_range;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n\n  const_arg_iterator arg_begin() const {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  /// This method provides fast access to all the subexpressions of\n  /// a CallExpr without going through the slower virtual child_iterator\n  /// interface.  This provides efficient reverse iteration of the\n  /// subexpressions.  This is currently used for CFG construction.\n  ArrayRef<Stmt *> getRawSubExprs() {\n    return llvm::makeArrayRef(getTrailingStmts(),\n                              PREARGS_START + getNumPreArgs() + getNumArgs());\n  }\n\n  /// getNumCommas - Return the number of commas that must have been present in\n  /// this function call.\n  unsigned getNumCommas() const { return getNumArgs() ? getNumArgs() - 1 : 0; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPOptionsOverride in trailing storage. Used only by Serialization.\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(hasStoredFPFeatures());\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  /// getBuiltinCallee - If this is a call to a builtin, return the builtin ID\n  /// of the callee. If not, return 0.\n  unsigned getBuiltinCallee() const;\n\n  /// Returns \\c true if this is a call to a builtin which does not\n  /// evaluate side-effects within its arguments.\n  bool isUnevaluatedBuiltinCall(const ASTContext &Ctx) const;\n\n  /// getCallReturnType - Get the return type of the call expr. This is not\n  /// always the type of the expr itself, if the return type is a reference\n  /// type.\n  QualType getCallReturnType(const ASTContext &Ctx) const;\n\n  /// Returns the WarnUnusedResultAttr that is either declared on the called\n  /// function, or its return type declaration.\n  const Attr *getUnusedResultAttr(const ASTContext &Ctx) const;\n\n  /// Returns true if this call expression should warn on unused results.\n  bool hasUnusedResultAttr(const ASTContext &Ctx) const {\n    return getUnusedResultAttr(Ctx) != nullptr;\n  }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Return true if this is a call to __assume() or __builtin_assume() with\n  /// a non-value-dependent constant parameter evaluating as false.\n  bool isBuiltinAssumeFalse(const ASTContext &Ctx) const;\n\n  /// Used by Sema to implement MSVC-compatible delayed name lookup.\n  /// (Usually Exprs themselves should set dependence).\n  void markDependentForPostponedNameLookup() {\n    setDependence(getDependence() | ExprDependence::TypeValueInstantiation);\n  }\n\n  bool isCallToStdMove() const {\n    const FunctionDecl *FD = getDirectCallee();\n    return getNumArgs() == 1 && FD && FD->isInStdNamespace() &&\n           FD->getIdentifier() && FD->getIdentifier()->isStr(\"move\");\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCallExprConstant &&\n           T->getStmtClass() <= lastCallExprConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingStmts(), getTrailingStmts() + PREARGS_START +\n                                               getNumPreArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingStmts(),\n                             getTrailingStmts() + PREARGS_START +\n                                 getNumPreArgs() + getNumArgs());\n  }\n};\n\n/// Extra data stored in some MemberExpr objects.\nstruct MemberExprNameQualifier {\n  /// The nested-name-specifier that qualifies the name, including\n  /// source-location information.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The DeclAccessPair through which the MemberDecl was found due to\n  /// name qualifiers.\n  DeclAccessPair FoundDecl;\n};\n\n/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.\n///\nclass MemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<MemberExpr, MemberExprNameQualifier,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Base - the expression for the base pointer or structure references.  In\n  /// X.F, this is \"X\".\n  Stmt *Base;\n\n  /// MemberDecl - This is the decl being referenced by the field/member name.\n  /// In X.F, this is the decl referenced by F.\n  ValueDecl *MemberDecl;\n\n  /// MemberDNLoc - Provides source/type location info for the\n  /// declaration name embedded in MemberDecl.\n  DeclarationNameLoc MemberDNLoc;\n\n  /// MemberLoc - This is the location of the member name.\n  SourceLocation MemberLoc;\n\n  size_t numTrailingObjects(OverloadToken<MemberExprNameQualifier>) const {\n    return hasQualifierOrFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasQualifierOrFoundDecl() const {\n    return MemberExprBits.HasQualifierOrFoundDecl;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return MemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  MemberExpr(Expr *Base, bool IsArrow, SourceLocation OperatorLoc,\n             ValueDecl *MemberDecl, const DeclarationNameInfo &NameInfo,\n             QualType T, ExprValueKind VK, ExprObjectKind OK,\n             NonOdrUseReason NOUR);\n  MemberExpr(EmptyShell Empty)\n      : Expr(MemberExprClass, Empty), Base(), MemberDecl() {}\n\npublic:\n  static MemberExpr *Create(const ASTContext &C, Expr *Base, bool IsArrow,\n                            SourceLocation OperatorLoc,\n                            NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc, ValueDecl *MemberDecl,\n                            DeclAccessPair FoundDecl,\n                            DeclarationNameInfo MemberNameInfo,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            QualType T, ExprValueKind VK, ExprObjectKind OK,\n                            NonOdrUseReason NOUR);\n\n  /// Create an implicit MemberExpr, with no location, qualifier, template\n  /// arguments, and so on. Suitable only for non-static member access.\n  static MemberExpr *CreateImplicit(const ASTContext &C, Expr *Base,\n                                    bool IsArrow, ValueDecl *MemberDecl,\n                                    QualType T, ExprValueKind VK,\n                                    ExprObjectKind OK) {\n    return Create(C, Base, IsArrow, SourceLocation(), NestedNameSpecifierLoc(),\n                  SourceLocation(), MemberDecl,\n                  DeclAccessPair::make(MemberDecl, MemberDecl->getAccess()),\n                  DeclarationNameInfo(), nullptr, T, VK, OK, NOUR_None);\n  }\n\n  static MemberExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                 bool HasFoundDecl,\n                                 bool HasTemplateKWAndArgsInfo,\n                                 unsigned NumTemplateArgs);\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Retrieve the member declaration to which this expression refers.\n  ///\n  /// The returned declaration will be a FieldDecl or (in C++) a VarDecl (for\n  /// static data members), a CXXMethodDecl, or an EnumConstantDecl.\n  ValueDecl *getMemberDecl() const { return MemberDecl; }\n  void setMemberDecl(ValueDecl *D);\n\n  /// Retrieves the declaration found by lookup.\n  DeclAccessPair getFoundDecl() const {\n    if (!hasQualifierOrFoundDecl())\n      return DeclAccessPair::make(getMemberDecl(),\n                                  getMemberDecl()->getAccess());\n    return getTrailingObjects<MemberExprNameQualifier>()->FoundDecl;\n  }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return getQualifier() != nullptr; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name, with source-location\n  /// information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifierOrFoundDecl())\n      return NestedNameSpecifierLoc();\n    return getTrailingObjects<MemberExprNameQualifier>()->QualifierLoc;\n  }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// the member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether the member name was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Retrieve the member declaration name info.\n  DeclarationNameInfo getMemberNameInfo() const {\n    return DeclarationNameInfo(MemberDecl->getDeclName(),\n                               MemberLoc, MemberDNLoc);\n  }\n\n  SourceLocation getOperatorLoc() const { return MemberExprBits.OperatorLoc; }\n\n  bool isArrow() const { return MemberExprBits.IsArrow; }\n  void setArrow(bool A) { MemberExprBits.IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getMemberLoc() const { return MemberLoc; }\n  void setMemberLoc(SourceLocation L) { MemberLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return MemberLoc; }\n\n  /// Determine whether the base of this explicit is implicit.\n  bool isImplicitAccess() const {\n    return getBase() && getBase()->isImplicitCXXThis();\n  }\n\n  /// Returns true if this member expression refers to a method that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return MemberExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a method that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    MemberExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Returns true if virtual dispatch is performed.\n  /// If the member access is fully qualified, (i.e. X::f()), virtual\n  /// dispatching is not performed. In -fapple-kext mode qualified\n  /// calls to virtual method will still go through the vtable.\n  bool performsVirtualDispatch(const LangOptions &LO) const {\n    return LO.AppleKext || !hasQualifier();\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  /// This is only meaningful if the named member is a static member.\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(MemberExprBits.NonOdrUseReason);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MemberExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// CompoundLiteralExpr - [C99 6.5.2.5]\n///\nclass CompoundLiteralExpr : public Expr {\n  /// LParenLoc - If non-null, this is the location of the left paren in a\n  /// compound literal like \"(int){4}\".  This can be null if this is a\n  /// synthesized compound expression.\n  SourceLocation LParenLoc;\n\n  /// The type as written.  This can be an incomplete array type, in\n  /// which case the actual expression type will be different.\n  /// The int part of the pair stores whether this expr is file scope.\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfoAndScope;\n  Stmt *Init;\npublic:\n  CompoundLiteralExpr(SourceLocation lparenloc, TypeSourceInfo *tinfo,\n                      QualType T, ExprValueKind VK, Expr *init, bool fileScope)\n      : Expr(CompoundLiteralExprClass, T, VK, OK_Ordinary),\n        LParenLoc(lparenloc), TInfoAndScope(tinfo, fileScope), Init(init) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty compound literal.\n  explicit CompoundLiteralExpr(EmptyShell Empty)\n    : Expr(CompoundLiteralExprClass, Empty) { }\n\n  const Expr *getInitializer() const { return cast<Expr>(Init); }\n  Expr *getInitializer() { return cast<Expr>(Init); }\n  void setInitializer(Expr *E) { Init = E; }\n\n  bool isFileScope() const { return TInfoAndScope.getInt(); }\n  void setFileScope(bool FS) { TInfoAndScope.setInt(FS); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfoAndScope.getPointer();\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tinfo) {\n    TInfoAndScope.setPointer(tinfo);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    if (LParenLoc.isInvalid())\n      return Init->getBeginLoc();\n    return LParenLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    return Init->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundLiteralExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Init, &Init+1); }\n  const_child_range children() const {\n    return const_child_range(&Init, &Init + 1);\n  }\n};\n\n/// CastExpr - Base class for type casts, including both implicit\n/// casts (ImplicitCastExpr) and explicit casts that have some\n/// representation in the source code (ExplicitCastExpr's derived\n/// classes).\nclass CastExpr : public Expr {\n  Stmt *Op;\n\n  bool CastConsistency() const;\n\n  const CXXBaseSpecifier * const *path_buffer() const {\n    return const_cast<CastExpr*>(this)->path_buffer();\n  }\n  CXXBaseSpecifier **path_buffer();\n\n  friend class ASTStmtReader;\n\nprotected:\n  CastExpr(StmtClass SC, QualType ty, ExprValueKind VK, const CastKind kind,\n           Expr *op, unsigned BasePathSize, bool HasFPFeatures)\n      : Expr(SC, ty, VK, OK_Ordinary), Op(op) {\n    CastExprBits.Kind = kind;\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n    setDependence(computeDependence(this));\n    assert(CastConsistency());\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n  }\n\n  /// Construct an empty cast.\n  CastExpr(StmtClass SC, EmptyShell Empty, unsigned BasePathSize,\n           bool HasFPFeatures)\n      : Expr(SC, Empty) {\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n  }\n\n  /// Return a pointer to the trailing FPOptions.\n  /// \\pre hasStoredFPFeatures() == true\n  FPOptionsOverride *getTrailingFPFeatures();\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    return const_cast<CastExpr *>(this)->getTrailingFPFeatures();\n  }\n\npublic:\n  CastKind getCastKind() const { return (CastKind) CastExprBits.Kind; }\n  void setCastKind(CastKind K) { CastExprBits.Kind = K; }\n\n  static const char *getCastKindName(CastKind CK);\n  const char *getCastKindName() const { return getCastKindName(getCastKind()); }\n\n  Expr *getSubExpr() { return cast<Expr>(Op); }\n  const Expr *getSubExpr() const { return cast<Expr>(Op); }\n  void setSubExpr(Expr *E) { Op = E; }\n\n  /// Retrieve the cast subexpression as it was written in the source\n  /// code, looking through any implicit casts or other intermediate nodes\n  /// introduced by semantic analysis.\n  Expr *getSubExprAsWritten();\n  const Expr *getSubExprAsWritten() const {\n    return const_cast<CastExpr *>(this)->getSubExprAsWritten();\n  }\n\n  /// If this cast applies a user-defined conversion, retrieve the conversion\n  /// function that it invokes.\n  NamedDecl *getConversionFunction() const;\n\n  typedef CXXBaseSpecifier **path_iterator;\n  typedef const CXXBaseSpecifier *const *path_const_iterator;\n  bool path_empty() const { return path_size() == 0; }\n  unsigned path_size() const { return CastExprBits.BasePathSize; }\n  path_iterator path_begin() { return path_buffer(); }\n  path_iterator path_end() { return path_buffer() + path_size(); }\n  path_const_iterator path_begin() const { return path_buffer(); }\n  path_const_iterator path_end() const { return path_buffer() + path_size(); }\n\n  llvm::iterator_range<path_iterator> path() {\n    return llvm::make_range(path_begin(), path_end());\n  }\n  llvm::iterator_range<path_const_iterator> path() const {\n    return llvm::make_range(path_begin(), path_end());\n  }\n\n  const FieldDecl *getTargetUnionField() const {\n    assert(getCastKind() == CK_ToUnion);\n    return getTargetFieldForToUnionCast(getType(), getSubExpr()->getType());\n  }\n\n  bool hasStoredFPFeatures() const { return CastExprBits.HasFPFeatures; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n\n  // Get the FP features status of this operation. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  static const FieldDecl *getTargetFieldForToUnionCast(QualType unionType,\n                                                       QualType opType);\n  static const FieldDecl *getTargetFieldForToUnionCast(const RecordDecl *RD,\n                                                       QualType opType);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCastExprConstant &&\n           T->getStmtClass() <= lastCastExprConstant;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Op, &Op+1); }\n  const_child_range children() const { return const_child_range(&Op, &Op + 1); }\n};\n\n/// ImplicitCastExpr - Allows us to explicitly represent implicit type\n/// conversions, which have no direct representation in the original\n/// source code. For example: converting T[]->T*, void f()->void\n/// (*f)(), float->double, short->int, etc.\n///\n/// In C, implicit casts always produce rvalues. However, in C++, an\n/// implicit cast whose result is being bound to a reference will be\n/// an lvalue or xvalue. For example:\n///\n/// @code\n/// class Base { };\n/// class Derived : public Base { };\n/// Derived &&ref();\n/// void f(Derived d) {\n///   Base& b = d; // initializer is an ImplicitCastExpr\n///                // to an lvalue of type Base\n///   Base&& r = ref(); // initializer is an ImplicitCastExpr\n///                     // to an xvalue of type Base\n/// }\n/// @endcode\nclass ImplicitCastExpr final\n    : public CastExpr,\n      private llvm::TrailingObjects<ImplicitCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n\n  ImplicitCastExpr(QualType ty, CastKind kind, Expr *op,\n                   unsigned BasePathLength, FPOptionsOverride FPO,\n                   ExprValueKind VK)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, BasePathLength,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty implicit cast.\n  explicit ImplicitCastExpr(EmptyShell Shell, unsigned PathSize,\n                            bool HasFPFeatures)\n      : CastExpr(ImplicitCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  enum OnStack_t { OnStack };\n  ImplicitCastExpr(OnStack_t _, QualType ty, CastKind kind, Expr *op,\n                   ExprValueKind VK, FPOptionsOverride FPO)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, 0,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  bool isPartOfExplicitCast() const { return CastExprBits.PartOfExplicitCast; }\n  void setIsPartOfExplicitCast(bool PartOfExplicitCast) {\n    CastExprBits.PartOfExplicitCast = PartOfExplicitCast;\n  }\n\n  static ImplicitCastExpr *Create(const ASTContext &Context, QualType T,\n                                  CastKind Kind, Expr *Operand,\n                                  const CXXCastPath *BasePath,\n                                  ExprValueKind Cat, FPOptionsOverride FPO);\n\n  static ImplicitCastExpr *CreateEmpty(const ASTContext &Context,\n                                       unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// ExplicitCastExpr - An explicit cast written in the source\n/// code.\n///\n/// This class is effectively an abstract class, because it provides\n/// the basic representation of an explicitly-written cast without\n/// specifying which kind of cast (C cast, functional cast, static\n/// cast, etc.) was written; specific derived classes represent the\n/// particular style of cast and its location information.\n///\n/// Unlike implicit casts, explicit cast nodes have two different\n/// types: the type that was written into the source code, and the\n/// actual type of the expression as determined by semantic\n/// analysis. These types may differ slightly. For example, in C++ one\n/// can cast to a reference type, which indicates that the resulting\n/// expression will be an lvalue or xvalue. The reference type, however,\n/// will not be used as the type of the expression.\nclass ExplicitCastExpr : public CastExpr {\n  /// TInfo - Source type info for the (written) type\n  /// this expression is casting to.\n  TypeSourceInfo *TInfo;\n\nprotected:\n  ExplicitCastExpr(StmtClass SC, QualType exprTy, ExprValueKind VK,\n                   CastKind kind, Expr *op, unsigned PathSize,\n                   bool HasFPFeatures, TypeSourceInfo *writtenTy)\n      : CastExpr(SC, exprTy, VK, kind, op, PathSize, HasFPFeatures),\n        TInfo(writtenTy) {}\n\n  /// Construct an empty explicit cast.\n  ExplicitCastExpr(StmtClass SC, EmptyShell Shell, unsigned PathSize,\n                   bool HasFPFeatures)\n      : CastExpr(SC, Shell, PathSize, HasFPFeatures) {}\n\npublic:\n  /// getTypeInfoAsWritten - Returns the type source info for the type\n  /// that this expression is casting to.\n  TypeSourceInfo *getTypeInfoAsWritten() const { return TInfo; }\n  void setTypeInfoAsWritten(TypeSourceInfo *writtenTy) { TInfo = writtenTy; }\n\n  /// getTypeAsWritten - Returns the type that this expression is\n  /// casting to, as written in the source code.\n  QualType getTypeAsWritten() const { return TInfo->getType(); }\n\n  static bool classof(const Stmt *T) {\n     return T->getStmtClass() >= firstExplicitCastExprConstant &&\n            T->getStmtClass() <= lastExplicitCastExprConstant;\n  }\n};\n\n/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style\n/// cast in C++ (C++ [expr.cast]), which uses the syntax\n/// (Type)expr. For example: @c (int)f.\nclass CStyleCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CStyleCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LPLoc; // the location of the left paren\n  SourceLocation RPLoc; // the location of the right paren\n\n  CStyleCastExpr(QualType exprTy, ExprValueKind vk, CastKind kind, Expr *op,\n                 unsigned PathSize, FPOptionsOverride FPO,\n                 TypeSourceInfo *writtenTy, SourceLocation l, SourceLocation r)\n      : ExplicitCastExpr(CStyleCastExprClass, exprTy, vk, kind, op, PathSize,\n                         FPO.requiresTrailingStorage(), writtenTy),\n        LPLoc(l), RPLoc(r) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty C-style explicit cast.\n  explicit CStyleCastExpr(EmptyShell Shell, unsigned PathSize,\n                          bool HasFPFeatures)\n      : ExplicitCastExpr(CStyleCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  static CStyleCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind K,\n         Expr *Op, const CXXCastPath *BasePath, FPOptionsOverride FPO,\n         TypeSourceInfo *WrittenTy, SourceLocation L, SourceLocation R);\n\n  static CStyleCastExpr *CreateEmpty(const ASTContext &Context,\n                                     unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CStyleCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// A builtin binary operation expression such as \"x + y\" or \"x <= y\".\n///\n/// This expression node kind describes a builtin binary operation,\n/// such as \"x + y\" for integer values \"x\" and \"y\". The operands will\n/// already have been converted to appropriate types (e.g., by\n/// performing promotions or conversions).\n///\n/// In C++, where operators may be overloaded, a different kind of\n/// expression node (CXXOperatorCallExpr) is used to express the\n/// invocation of an overloaded operator with operator syntax. Within\n/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is\n/// used to store an expression \"x + y\" depends on the subexpressions\n/// for x and y. If neither x or y is type-dependent, and the \"+\"\n/// operator resolves to a built-in operation, BinaryOperator will be\n/// used to express the computation (x and y may still be\n/// value-dependent). If either x or y is type-dependent, or if the\n/// \"+\" resolves to an overloaded operator, CXXOperatorCallExpr will\n/// be used to express the computation.\nclass BinaryOperator : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  typedef BinaryOperatorKind Opcode;\n\nprotected:\n  size_t offsetOfTrailingStorage() const;\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + offsetOfTrailingStorage());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) + offsetOfTrailingStorage());\n  }\n\n  /// Build a binary operator, assuming that appropriate storage has been\n  /// allocated for the trailing objects when needed.\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures);\n\n  /// Construct an empty binary operator.\n  explicit BinaryOperator(EmptyShell Empty) : Expr(BinaryOperatorClass, Empty) {\n    BinaryOperatorBits.Opc = BO_Comma;\n  }\n\npublic:\n  static BinaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static BinaryOperator *Create(const ASTContext &C, Expr *lhs, Expr *rhs,\n                                Opcode opc, QualType ResTy, ExprValueKind VK,\n                                ExprObjectKind OK, SourceLocation opLoc,\n                                FPOptionsOverride FPFeatures);\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n  SourceLocation getOperatorLoc() const { return BinaryOperatorBits.OpLoc; }\n  void setOperatorLoc(SourceLocation L) { BinaryOperatorBits.OpLoc = L; }\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(BinaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { BinaryOperatorBits.Opc = Opc; }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"<<=\".\n  static StringRef getOpcodeStr(Opcode Op);\n\n  StringRef getOpcodeStr() const { return getOpcodeStr(getOpcode()); }\n\n  /// Retrieve the binary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given binary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  /// predicates to categorize the respective opcodes.\n  static bool isPtrMemOp(Opcode Opc) {\n    return Opc == BO_PtrMemD || Opc == BO_PtrMemI;\n  }\n  bool isPtrMemOp() const { return isPtrMemOp(getOpcode()); }\n\n  static bool isMultiplicativeOp(Opcode Opc) {\n    return Opc >= BO_Mul && Opc <= BO_Rem;\n  }\n  bool isMultiplicativeOp() const { return isMultiplicativeOp(getOpcode()); }\n  static bool isAdditiveOp(Opcode Opc) { return Opc == BO_Add || Opc==BO_Sub; }\n  bool isAdditiveOp() const { return isAdditiveOp(getOpcode()); }\n  static bool isShiftOp(Opcode Opc) { return Opc == BO_Shl || Opc == BO_Shr; }\n  bool isShiftOp() const { return isShiftOp(getOpcode()); }\n\n  static bool isBitwiseOp(Opcode Opc) { return Opc >= BO_And && Opc <= BO_Or; }\n  bool isBitwiseOp() const { return isBitwiseOp(getOpcode()); }\n\n  static bool isRelationalOp(Opcode Opc) { return Opc >= BO_LT && Opc<=BO_GE; }\n  bool isRelationalOp() const { return isRelationalOp(getOpcode()); }\n\n  static bool isEqualityOp(Opcode Opc) { return Opc == BO_EQ || Opc == BO_NE; }\n  bool isEqualityOp() const { return isEqualityOp(getOpcode()); }\n\n  static bool isComparisonOp(Opcode Opc) { return Opc >= BO_Cmp && Opc<=BO_NE; }\n  bool isComparisonOp() const { return isComparisonOp(getOpcode()); }\n\n  static bool isCommaOp(Opcode Opc) { return Opc == BO_Comma; }\n  bool isCommaOp() const { return isCommaOp(getOpcode()); }\n\n  static Opcode negateComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GE;\n    case BO_GT: return BO_LE;\n    case BO_LE: return BO_GT;\n    case BO_GE: return BO_LT;\n    case BO_EQ: return BO_NE;\n    case BO_NE: return BO_EQ;\n    }\n  }\n\n  static Opcode reverseComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GT;\n    case BO_GT: return BO_LT;\n    case BO_LE: return BO_GE;\n    case BO_GE: return BO_LE;\n    case BO_EQ:\n    case BO_NE:\n      return Opc;\n    }\n  }\n\n  static bool isLogicalOp(Opcode Opc) { return Opc == BO_LAnd || Opc==BO_LOr; }\n  bool isLogicalOp() const { return isLogicalOp(getOpcode()); }\n\n  static bool isAssignmentOp(Opcode Opc) {\n    return Opc >= BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isAssignmentOp() const { return isAssignmentOp(getOpcode()); }\n\n  static bool isCompoundAssignmentOp(Opcode Opc) {\n    return Opc > BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isCompoundAssignmentOp() const {\n    return isCompoundAssignmentOp(getOpcode());\n  }\n  static Opcode getOpForCompoundAssignment(Opcode Opc) {\n    assert(isCompoundAssignmentOp(Opc));\n    if (Opc >= BO_AndAssign)\n      return Opcode(unsigned(Opc) - BO_AndAssign + BO_And);\n    else\n      return Opcode(unsigned(Opc) - BO_MulAssign + BO_Mul);\n  }\n\n  static bool isShiftAssignOp(Opcode Opc) {\n    return Opc == BO_ShlAssign || Opc == BO_ShrAssign;\n  }\n  bool isShiftAssignOp() const {\n    return isShiftAssignOp(getOpcode());\n  }\n\n  // Return true if a binary operator using the specified opcode and operands\n  // would match the 'p = (i8*)nullptr + n' idiom for casting a pointer-sized\n  // integer to a pointer.\n  static bool isNullPointerArithmeticExtension(ASTContext &Ctx, Opcode Opc,\n                                               Expr *LHS, Expr *RHS);\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstBinaryOperatorConstant &&\n           S->getStmtClass() <= lastBinaryOperatorConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  /// Set and fetch the bit that shows whether FPFeatures needs to be\n  /// allocated in Trailing Storage\n  void setHasStoredFPFeatures(bool B) { BinaryOperatorBits.HasFPFeatures = B; }\n  bool hasStoredFPFeatures() const { return BinaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  // This is used in ASTImporter\n  FPOptionsOverride getFPFeatures(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\nprotected:\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures,\n                 bool dead2);\n\n  /// Construct an empty BinaryOperator, SC is CompoundAssignOperator.\n  BinaryOperator(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    BinaryOperatorBits.Opc = BO_MulAssign;\n  }\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(bool HasFPFeatures) {\n    return HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n};\n\n/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep\n/// track of the type the operation is performed in.  Due to the semantics of\n/// these operators, the operands are promoted, the arithmetic performed, an\n/// implicit conversion back to the result type done, then the assignment takes\n/// place.  This captures the intermediate type which the computation is done\n/// in.\nclass CompoundAssignOperator : public BinaryOperator {\n  QualType ComputationLHSType;\n  QualType ComputationResultType;\n\n  /// Construct an empty CompoundAssignOperator.\n  explicit CompoundAssignOperator(const ASTContext &C, EmptyShell Empty,\n                                  bool hasFPFeatures)\n      : BinaryOperator(CompoundAssignOperatorClass, Empty) {}\n\nprotected:\n  CompoundAssignOperator(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc,\n                         QualType ResType, ExprValueKind VK, ExprObjectKind OK,\n                         SourceLocation OpLoc, FPOptionsOverride FPFeatures,\n                         QualType CompLHSType, QualType CompResultType)\n      : BinaryOperator(C, lhs, rhs, opc, ResType, VK, OK, OpLoc, FPFeatures,\n                       true),\n        ComputationLHSType(CompLHSType), ComputationResultType(CompResultType) {\n    assert(isCompoundAssignmentOp() &&\n           \"Only should be used for compound assignments\");\n  }\n\npublic:\n  static CompoundAssignOperator *CreateEmpty(const ASTContext &C,\n                                             bool hasFPFeatures);\n\n  static CompoundAssignOperator *\n  Create(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc, QualType ResTy,\n         ExprValueKind VK, ExprObjectKind OK, SourceLocation opLoc,\n         FPOptionsOverride FPFeatures, QualType CompLHSType = QualType(),\n         QualType CompResultType = QualType());\n\n  // The two computation types are the type the LHS is converted\n  // to for the computation and the type of the result; the two are\n  // distinct in a few cases (specifically, int+=ptr and ptr-=ptr).\n  QualType getComputationLHSType() const { return ComputationLHSType; }\n  void setComputationLHSType(QualType T) { ComputationLHSType = T; }\n\n  QualType getComputationResultType() const { return ComputationResultType; }\n  void setComputationResultType(QualType T) { ComputationResultType = T; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == CompoundAssignOperatorClass;\n  }\n};\n\ninline size_t BinaryOperator::offsetOfTrailingStorage() const {\n  assert(BinaryOperatorBits.HasFPFeatures);\n  return isa<CompoundAssignOperator>(this) ? sizeof(CompoundAssignOperator)\n                                           : sizeof(BinaryOperator);\n}\n\n/// AbstractConditionalOperator - An abstract base class for\n/// ConditionalOperator and BinaryConditionalOperator.\nclass AbstractConditionalOperator : public Expr {\n  SourceLocation QuestionLoc, ColonLoc;\n  friend class ASTStmtReader;\n\nprotected:\n  AbstractConditionalOperator(StmtClass SC, QualType T, ExprValueKind VK,\n                              ExprObjectKind OK, SourceLocation qloc,\n                              SourceLocation cloc)\n      : Expr(SC, T, VK, OK), QuestionLoc(qloc), ColonLoc(cloc) {}\n\n  AbstractConditionalOperator(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) { }\n\npublic:\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const;\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const;\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const;\n\n  SourceLocation getQuestionLoc() const { return QuestionLoc; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass ||\n           T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n};\n\n/// ConditionalOperator - The ?: ternary operator.  The GNU \"missing\n/// middle\" extension is a BinaryConditionalOperator.\nclass ConditionalOperator : public AbstractConditionalOperator {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n\n  friend class ASTStmtReader;\npublic:\n  ConditionalOperator(Expr *cond, SourceLocation QLoc, Expr *lhs,\n                      SourceLocation CLoc, Expr *rhs, QualType t,\n                      ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(ConditionalOperatorClass, t, VK, OK, QLoc,\n                                    CLoc) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit ConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(ConditionalOperatorClass, Empty) { }\n\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const { return cast<Expr>(SubExprs[LHS]); }\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const { return cast<Expr>(SubExprs[RHS]); }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCond()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// BinaryConditionalOperator - The GNU extension to the conditional\n/// operator which allows the middle operand to be omitted.\n///\n/// This is a different expression kind on the assumption that almost\n/// every client ends up needing to know that these are different.\nclass BinaryConditionalOperator : public AbstractConditionalOperator {\n  enum { COMMON, COND, LHS, RHS, NUM_SUBEXPRS };\n\n  /// - the common condition/left-hand-side expression, which will be\n  ///   evaluated as the opaque value\n  /// - the condition, expressed in terms of the opaque value\n  /// - the left-hand-side, expressed in terms of the opaque value\n  /// - the right-hand-side\n  Stmt *SubExprs[NUM_SUBEXPRS];\n  OpaqueValueExpr *OpaqueValue;\n\n  friend class ASTStmtReader;\npublic:\n  BinaryConditionalOperator(Expr *common, OpaqueValueExpr *opaqueValue,\n                            Expr *cond, Expr *lhs, Expr *rhs,\n                            SourceLocation qloc, SourceLocation cloc,\n                            QualType t, ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(BinaryConditionalOperatorClass, t, VK, OK,\n                                    qloc, cloc),\n        OpaqueValue(opaqueValue) {\n    SubExprs[COMMON] = common;\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    assert(OpaqueValue->getSourceExpr() == common && \"Wrong opaque value\");\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit BinaryConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(BinaryConditionalOperatorClass, Empty) { }\n\n  /// getCommon - Return the common expression, written to the\n  ///   left of the condition.  The opaque value will be bound to the\n  ///   result of this expression.\n  Expr *getCommon() const { return cast<Expr>(SubExprs[COMMON]); }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  /// getCond - Return the condition expression; this is defined\n  ///   in terms of the opaque value.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  /// getTrueExpr - Return the subexpression which will be\n  ///   evaluated if the condition evaluates to true;  this is defined\n  ///   in terms of the opaque value.\n  Expr *getTrueExpr() const {\n    return cast<Expr>(SubExprs[LHS]);\n  }\n\n  /// getFalseExpr - Return the subexpression which will be\n  ///   evaluated if the condnition evaluates to false; this is\n  ///   defined in terms of the opaque value.\n  Expr *getFalseExpr() const {\n    return cast<Expr>(SubExprs[RHS]);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommon()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getFalseExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n};\n\ninline Expr *AbstractConditionalOperator::getCond() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getCond();\n  return cast<BinaryConditionalOperator>(this)->getCond();\n}\n\ninline Expr *AbstractConditionalOperator::getTrueExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getTrueExpr();\n  return cast<BinaryConditionalOperator>(this)->getTrueExpr();\n}\n\ninline Expr *AbstractConditionalOperator::getFalseExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getFalseExpr();\n  return cast<BinaryConditionalOperator>(this)->getFalseExpr();\n}\n\n/// AddrLabelExpr - The GNU address of label extension, representing &&label.\nclass AddrLabelExpr : public Expr {\n  SourceLocation AmpAmpLoc, LabelLoc;\n  LabelDecl *Label;\npublic:\n  AddrLabelExpr(SourceLocation AALoc, SourceLocation LLoc, LabelDecl *L,\n                QualType t)\n      : Expr(AddrLabelExprClass, t, VK_RValue, OK_Ordinary), AmpAmpLoc(AALoc),\n        LabelLoc(LLoc), Label(L) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty address of a label expression.\n  explicit AddrLabelExpr(EmptyShell Empty)\n    : Expr(AddrLabelExprClass, Empty) { }\n\n  SourceLocation getAmpAmpLoc() const { return AmpAmpLoc; }\n  void setAmpAmpLoc(SourceLocation L) { AmpAmpLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AmpAmpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LabelLoc; }\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *L) { Label = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AddrLabelExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// StmtExpr - This is the GNU Statement Expression extension: ({int X=4; X;}).\n/// The StmtExpr contains a single CompoundStmt node, which it evaluates and\n/// takes the value of the last subexpression.\n///\n/// A StmtExpr is always an r-value; values \"returned\" out of a\n/// StmtExpr will be copied.\nclass StmtExpr : public Expr {\n  Stmt *SubStmt;\n  SourceLocation LParenLoc, RParenLoc;\npublic:\n  StmtExpr(CompoundStmt *SubStmt, QualType T, SourceLocation LParenLoc,\n           SourceLocation RParenLoc, unsigned TemplateDepth)\n      : Expr(StmtExprClass, T, VK_RValue, OK_Ordinary), SubStmt(SubStmt),\n        LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this, TemplateDepth));\n    // FIXME: A templated statement expression should have an associated\n    // DeclContext so that nested declarations always have a dependent context.\n    StmtExprBits.TemplateDepth = TemplateDepth;\n  }\n\n  /// Build an empty statement expression.\n  explicit StmtExpr(EmptyShell Empty) : Expr(StmtExprClass, Empty) { }\n\n  CompoundStmt *getSubStmt() { return cast<CompoundStmt>(SubStmt); }\n  const CompoundStmt *getSubStmt() const { return cast<CompoundStmt>(SubStmt); }\n  void setSubStmt(CompoundStmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  unsigned getTemplateDepth() const { return StmtExprBits.TemplateDepth; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StmtExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt+1); }\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n/// ShuffleVectorExpr - clang-specific builtin-in function\n/// __builtin_shufflevector.\n/// This AST node represents a operator that does a constant\n/// shuffle, similar to LLVM's shufflevector instruction. It takes\n/// two vectors and a variable number of constant indices,\n/// and returns the appropriately shuffled vector.\nclass ShuffleVectorExpr : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  // SubExprs - the list of values passed to the __builtin_shufflevector\n  // function. The first two are vectors, and the rest are constant\n  // indices.  The number of values in this list is always\n  // 2+the number of indices in the vector type.\n  Stmt **SubExprs;\n  unsigned NumExprs;\n\npublic:\n  ShuffleVectorExpr(const ASTContext &C, ArrayRef<Expr*> args, QualType Type,\n                    SourceLocation BLoc, SourceLocation RP);\n\n  /// Build an empty vector-shuffle expression.\n  explicit ShuffleVectorExpr(EmptyShell Empty)\n    : Expr(ShuffleVectorExprClass, Empty), SubExprs(nullptr) { }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ShuffleVectorExprClass;\n  }\n\n  /// getNumSubExprs - Return the size of the SubExprs array.  This includes the\n  /// constant expression, the actual arguments passed in, and the function\n  /// pointers.\n  unsigned getNumSubExprs() const { return NumExprs; }\n\n  /// Retrieve the array of expressions.\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n\n  /// getExpr - Return the Expr at the specified index.\n  Expr *getExpr(unsigned Index) {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n  const Expr *getExpr(unsigned Index) const {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n\n  void setExprs(const ASTContext &C, ArrayRef<Expr *> Exprs);\n\n  llvm::APSInt getShuffleMaskIdx(const ASTContext &Ctx, unsigned N) const {\n    assert((N < NumExprs - 2) && \"Shuffle idx out of range!\");\n    return getExpr(N+2)->EvaluateKnownConstInt(Ctx);\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+NumExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + NumExprs);\n  }\n};\n\n/// ConvertVectorExpr - Clang builtin function __builtin_convertvector\n/// This AST node provides support for converting a vector type to another\n/// vector type of the same arity.\nclass ConvertVectorExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  TypeSourceInfo *TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit ConvertVectorExpr(EmptyShell Empty) : Expr(ConvertVectorExprClass, Empty) {}\n\npublic:\n  ConvertVectorExpr(Expr *SrcExpr, TypeSourceInfo *TI, QualType DstType,\n                    ExprValueKind VK, ExprObjectKind OK,\n                    SourceLocation BuiltinLoc, SourceLocation RParenLoc)\n      : Expr(ConvertVectorExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        TInfo(TI), BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getTypeSourceInfo - Return the destination type.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *ti) {\n    TInfo = ti;\n  }\n\n  /// getBuiltinLoc - Return the location of the __builtin_convertvector token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConvertVectorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// ChooseExpr - GNU builtin-in function __builtin_choose_expr.\n/// This AST node is similar to the conditional operator (?:) in C, with\n/// the following exceptions:\n/// - the test expression must be a integer constant expression.\n/// - the expression returned acts like the chosen subexpression in every\n///   visible way: the type is the same as that of the chosen subexpression,\n///   and all predicates (whether it's an l-value, whether it's an integer\n///   constant expression, etc.) return the same result as for the chosen\n///   sub-expression.\nclass ChooseExpr : public Expr {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n  SourceLocation BuiltinLoc, RParenLoc;\n  bool CondIsTrue;\npublic:\n  ChooseExpr(SourceLocation BLoc, Expr *cond, Expr *lhs, Expr *rhs, QualType t,\n             ExprValueKind VK, ExprObjectKind OK, SourceLocation RP,\n             bool condIsTrue)\n      : Expr(ChooseExprClass, t, VK, OK), BuiltinLoc(BLoc), RParenLoc(RP),\n        CondIsTrue(condIsTrue) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty __builtin_choose_expr.\n  explicit ChooseExpr(EmptyShell Empty) : Expr(ChooseExprClass, Empty) { }\n\n  /// isConditionTrue - Return whether the condition is true (i.e. not\n  /// equal to zero).\n  bool isConditionTrue() const {\n    assert(!isConditionDependent() &&\n           \"Dependent condition isn't true or false\");\n    return CondIsTrue;\n  }\n  void setIsConditionTrue(bool isTrue) { CondIsTrue = isTrue; }\n\n  bool isConditionDependent() const {\n    return getCond()->isTypeDependent() || getCond()->isValueDependent();\n  }\n\n  /// getChosenSubExpr - Return the subexpression chosen according to the\n  /// condition.\n  Expr *getChosenSubExpr() const {\n    return isConditionTrue() ? getLHS() : getRHS();\n  }\n\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n  void setCond(Expr *E) { SubExprs[COND] = E; }\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ChooseExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GNUNullExpr - Implements the GNU __null extension, which is a name\n/// for a null pointer constant that has integral type (e.g., int or\n/// long) and is the same size and alignment as a pointer. The __null\n/// extension is typically only used by system headers, which define\n/// NULL as __null in C++ rather than using 0 (which is an integer\n/// that may not match the size of a pointer).\nclass GNUNullExpr : public Expr {\n  /// TokenLoc - The location of the __null keyword.\n  SourceLocation TokenLoc;\n\npublic:\n  GNUNullExpr(QualType Ty, SourceLocation Loc)\n      : Expr(GNUNullExprClass, Ty, VK_RValue, OK_Ordinary), TokenLoc(Loc) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty GNU __null expression.\n  explicit GNUNullExpr(EmptyShell Empty) : Expr(GNUNullExprClass, Empty) { }\n\n  /// getTokenLocation - The location of the __null token.\n  SourceLocation getTokenLocation() const { return TokenLoc; }\n  void setTokenLocation(SourceLocation L) { TokenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TokenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TokenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GNUNullExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a call to the builtin function \\c __builtin_va_arg.\nclass VAArgExpr : public Expr {\n  Stmt *Val;\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\npublic:\n  VAArgExpr(SourceLocation BLoc, Expr *e, TypeSourceInfo *TInfo,\n            SourceLocation RPLoc, QualType t, bool IsMS)\n      : Expr(VAArgExprClass, t, VK_RValue, OK_Ordinary), Val(e),\n        TInfo(TInfo, IsMS), BuiltinLoc(BLoc), RParenLoc(RPLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty __builtin_va_arg expression.\n  explicit VAArgExpr(EmptyShell Empty)\n      : Expr(VAArgExprClass, Empty), Val(nullptr), TInfo(nullptr, false) {}\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// Returns whether this is really a Win64 ABI va_arg expression.\n  bool isMicrosoftABI() const { return TInfo.getInt(); }\n  void setIsMicrosoftABI(bool IsMS) { TInfo.setInt(IsMS); }\n\n  TypeSourceInfo *getWrittenTypeInfo() const { return TInfo.getPointer(); }\n  void setWrittenTypeInfo(TypeSourceInfo *TI) { TInfo.setPointer(TI); }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == VAArgExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// Represents a function call to one of __builtin_LINE(), __builtin_COLUMN(),\n/// __builtin_FUNCTION(), or __builtin_FILE().\nclass SourceLocExpr final : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n  DeclContext *ParentContext;\n\npublic:\n  enum IdentKind { Function, File, Line, Column };\n\n  SourceLocExpr(const ASTContext &Ctx, IdentKind Type, SourceLocation BLoc,\n                SourceLocation RParenLoc, DeclContext *Context);\n\n  /// Build an empty call expression.\n  explicit SourceLocExpr(EmptyShell Empty) : Expr(SourceLocExprClass, Empty) {}\n\n  /// Return the result of evaluating this SourceLocExpr in the specified\n  /// (and possibly null) default argument or initialization context.\n  APValue EvaluateInContext(const ASTContext &Ctx,\n                            const Expr *DefaultExpr) const;\n\n  /// Return a string representing the name of the specific builtin function.\n  StringRef getBuiltinStr() const;\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(SourceLocExprBits.Kind);\n  }\n\n  bool isStringType() const {\n    switch (getIdentKind()) {\n    case File:\n    case Function:\n      return true;\n    case Line:\n    case Column:\n      return false;\n    }\n    llvm_unreachable(\"unknown source location expression kind\");\n  }\n  bool isIntType() const LLVM_READONLY { return !isStringType(); }\n\n  /// If the SourceLocExpr has been resolved return the subexpression\n  /// representing the resolved value. Otherwise return null.\n  const DeclContext *getParentContext() const { return ParentContext; }\n  DeclContext *getParentContext() { return ParentContext; }\n\n  SourceLocation getLocation() const { return BuiltinLoc; }\n  SourceLocation getBeginLoc() const { return BuiltinLoc; }\n  SourceLocation getEndLoc() const { return RParenLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(child_iterator(), child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SourceLocExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// Describes an C or C++ initializer list.\n///\n/// InitListExpr describes an initializer list, which can be used to\n/// initialize objects of different types, including\n/// struct/class/union types, arrays, and vectors. For example:\n///\n/// @code\n/// struct foo x = { 1, { 2, 3 } };\n/// @endcode\n///\n/// Prior to semantic analysis, an initializer list will represent the\n/// initializer list as written by the user, but will have the\n/// placeholder type \"void\". This initializer list is called the\n/// syntactic form of the initializer, and may contain C99 designated\n/// initializers (represented as DesignatedInitExprs), initializations\n/// of subobject members without explicit braces, and so on. Clients\n/// interested in the original syntax of the initializer list should\n/// use the syntactic form of the initializer list.\n///\n/// After semantic analysis, the initializer list will represent the\n/// semantic form of the initializer, where the initializations of all\n/// subobjects are made explicit with nested InitListExpr nodes and\n/// C99 designators have been eliminated by placing the designated\n/// initializations into the subobject they initialize. Additionally,\n/// any \"holes\" in the initialization, where no initializer has been\n/// specified for a particular subobject, will be replaced with\n/// implicitly-generated ImplicitValueInitExpr expressions that\n/// value-initialize the subobjects. Note, however, that the\n/// initializer lists may still have fewer initializers than there are\n/// elements to initialize within the object.\n///\n/// After semantic analysis has completed, given an initializer list,\n/// method isSemanticForm() returns true if and only if this is the\n/// semantic form of the initializer list (note: the same AST node\n/// may at the same time be the syntactic form).\n/// Given the semantic form of the initializer list, one can retrieve\n/// the syntactic form of that initializer list (when different)\n/// using method getSyntacticForm(); the method returns null if applied\n/// to a initializer list which is already in syntactic form.\n/// Similarly, given the syntactic form (i.e., an initializer list such\n/// that isSemanticForm() returns false), one can retrieve the semantic\n/// form using method getSemanticForm().\n/// Since many initializer lists have the same syntactic and semantic forms,\n/// getSyntacticForm() may return NULL, indicating that the current\n/// semantic initializer list also serves as its syntactic form.\nclass InitListExpr : public Expr {\n  // FIXME: Eliminate this vector in favor of ASTContext allocation\n  typedef ASTVector<Stmt *> InitExprsTy;\n  InitExprsTy InitExprs;\n  SourceLocation LBraceLoc, RBraceLoc;\n\n  /// The alternative form of the initializer list (if it exists).\n  /// The int part of the pair stores whether this initializer list is\n  /// in semantic form. If not null, the pointer points to:\n  ///   - the syntactic form, if this is in semantic form;\n  ///   - the semantic form, if this is in syntactic form.\n  llvm::PointerIntPair<InitListExpr *, 1, bool> AltForm;\n\n  /// Either:\n  ///  If this initializer list initializes an array with more elements than\n  ///  there are initializers in the list, specifies an expression to be used\n  ///  for value initialization of the rest of the elements.\n  /// Or\n  ///  If this initializer list initializes a union, specifies which\n  ///  field within the union will be initialized.\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\npublic:\n  InitListExpr(const ASTContext &C, SourceLocation lbraceloc,\n               ArrayRef<Expr*> initExprs, SourceLocation rbraceloc);\n\n  /// Build an empty initializer list.\n  explicit InitListExpr(EmptyShell Empty)\n    : Expr(InitListExprClass, Empty), AltForm(nullptr, true) { }\n\n  unsigned getNumInits() const { return InitExprs.size(); }\n\n  /// Retrieve the set of initializers.\n  Expr **getInits() { return reinterpret_cast<Expr **>(InitExprs.data()); }\n\n  /// Retrieve the set of initializers.\n  Expr * const *getInits() const {\n    return reinterpret_cast<Expr * const *>(InitExprs.data());\n  }\n\n  ArrayRef<Expr *> inits() {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  ArrayRef<Expr *> inits() const {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  const Expr *getInit(unsigned Init) const {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  Expr *getInit(unsigned Init) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  void setInit(unsigned Init, Expr *expr) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    InitExprs[Init] = expr;\n\n    if (expr)\n      setDependence(getDependence() | expr->getDependence());\n  }\n\n  /// Mark the semantic form of the InitListExpr as error when the semantic\n  /// analysis fails.\n  void markError() {\n    assert(isSemanticForm());\n    setDependence(getDependence() | ExprDependence::ErrorDependent);\n  }\n\n  /// Reserve space for some number of initializers.\n  void reserveInits(const ASTContext &C, unsigned NumInits);\n\n  /// Specify the number of initializers\n  ///\n  /// If there are more than @p NumInits initializers, the remaining\n  /// initializers will be destroyed. If there are fewer than @p\n  /// NumInits initializers, NULL expressions will be added for the\n  /// unknown initializers.\n  void resizeInits(const ASTContext &Context, unsigned NumInits);\n\n  /// Updates the initializer at index @p Init with the new\n  /// expression @p expr, and returns the old expression at that\n  /// location.\n  ///\n  /// When @p Init is out of range for this initializer list, the\n  /// initializer list will be extended with NULL expressions to\n  /// accommodate the new entry.\n  Expr *updateInit(const ASTContext &C, unsigned Init, Expr *expr);\n\n  /// If this initializer list initializes an array with more elements\n  /// than there are initializers in the list, specifies an expression to be\n  /// used for value initialization of the rest of the elements.\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n  const Expr *getArrayFiller() const {\n    return const_cast<InitListExpr *>(this)->getArrayFiller();\n  }\n  void setArrayFiller(Expr *filler);\n\n  /// Return true if this is an array initializer and its array \"filler\"\n  /// has been set.\n  bool hasArrayFiller() const { return getArrayFiller(); }\n\n  /// If this initializes a union, specifies which field in the\n  /// union to initialize.\n  ///\n  /// Typically, this field is the first named field within the\n  /// union. However, a designated initializer can specify the\n  /// initialization of a different field within the union.\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return const_cast<InitListExpr *>(this)->getInitializedFieldInUnion();\n  }\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    assert((FD == nullptr\n            || getInitializedFieldInUnion() == nullptr\n            || getInitializedFieldInUnion() == FD)\n           && \"Only one field of a union may be initialized at a time!\");\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  // Explicit InitListExpr's originate from source code (and have valid source\n  // locations). Implicit InitListExpr's are created by the semantic analyzer.\n  // FIXME: This is wrong; InitListExprs created by semantic analysis have\n  // valid source locations too!\n  bool isExplicit() const {\n    return LBraceLoc.isValid() && RBraceLoc.isValid();\n  }\n\n  // Is this an initializer for an array of characters, initialized by a string\n  // literal or an @encode?\n  bool isStringLiteralInit() const;\n\n  /// Is this a transparent initializer list (that is, an InitListExpr that is\n  /// purely syntactic, and whose semantics are that of the sole contained\n  /// initializer)?\n  bool isTransparent() const;\n\n  /// Is this the zero initializer {0} in a language which considers it\n  /// idiomatic?\n  bool isIdiomaticZeroInitializer(const LangOptions &LangOpts) const;\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation Loc) { LBraceLoc = Loc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation Loc) { RBraceLoc = Loc; }\n\n  bool isSemanticForm() const { return AltForm.getInt(); }\n  InitListExpr *getSemanticForm() const {\n    return isSemanticForm() ? nullptr : AltForm.getPointer();\n  }\n  bool isSyntacticForm() const {\n    return !AltForm.getInt() || !AltForm.getPointer();\n  }\n  InitListExpr *getSyntacticForm() const {\n    return isSemanticForm() ? AltForm.getPointer() : nullptr;\n  }\n\n  void setSyntacticForm(InitListExpr *Init) {\n    AltForm.setPointer(Init);\n    AltForm.setInt(true);\n    Init->AltForm.setPointer(this);\n    Init->AltForm.setInt(false);\n  }\n\n  bool hadArrayRangeDesignator() const {\n    return InitListExprBits.HadArrayRangeDesignator != 0;\n  }\n  void sawArrayRangeDesignator(bool ARD = true) {\n    InitListExprBits.HadArrayRangeDesignator = ARD;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == InitListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    const_child_range CCR = const_cast<const InitListExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n\n  const_child_range children() const {\n    // FIXME: This does not include the array filler expression.\n    if (InitExprs.empty())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&InitExprs[0], &InitExprs[0] + InitExprs.size());\n  }\n\n  typedef InitExprsTy::iterator iterator;\n  typedef InitExprsTy::const_iterator const_iterator;\n  typedef InitExprsTy::reverse_iterator reverse_iterator;\n  typedef InitExprsTy::const_reverse_iterator const_reverse_iterator;\n\n  iterator begin() { return InitExprs.begin(); }\n  const_iterator begin() const { return InitExprs.begin(); }\n  iterator end() { return InitExprs.end(); }\n  const_iterator end() const { return InitExprs.end(); }\n  reverse_iterator rbegin() { return InitExprs.rbegin(); }\n  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }\n  reverse_iterator rend() { return InitExprs.rend(); }\n  const_reverse_iterator rend() const { return InitExprs.rend(); }\n\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents a C99 designated initializer expression.\n///\n/// A designated initializer expression (C99 6.7.8) contains one or\n/// more designators (which can be field designators, array\n/// designators, or GNU array-range designators) followed by an\n/// expression that initializes the field or element(s) that the\n/// designators refer to. For example, given:\n///\n/// @code\n/// struct point {\n///   double x;\n///   double y;\n/// };\n/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };\n/// @endcode\n///\n/// The InitListExpr contains three DesignatedInitExprs, the first of\n/// which covers @c [2].y=1.0. This DesignatedInitExpr will have two\n/// designators, one array designator for @c [2] followed by one field\n/// designator for @c .y. The initialization expression will be 1.0.\nclass DesignatedInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DesignatedInitExpr, Stmt *> {\npublic:\n  /// Forward declaration of the Designator class.\n  class Designator;\n\nprivate:\n  /// The location of the '=' or ':' prior to the actual initializer\n  /// expression.\n  SourceLocation EqualOrColonLoc;\n\n  /// Whether this designated initializer used the GNU deprecated\n  /// syntax rather than the C99 '=' syntax.\n  unsigned GNUSyntax : 1;\n\n  /// The number of designators in this initializer expression.\n  unsigned NumDesignators : 15;\n\n  /// The number of subexpressions of this initializer expression,\n  /// which contains both the initializer and any additional\n  /// expressions used by array and array-range designators.\n  unsigned NumSubExprs : 16;\n\n  /// The designators in this designated initialization\n  /// expression.\n  Designator *Designators;\n\n  DesignatedInitExpr(const ASTContext &C, QualType Ty,\n                     llvm::ArrayRef<Designator> Designators,\n                     SourceLocation EqualOrColonLoc, bool GNUSyntax,\n                     ArrayRef<Expr *> IndexExprs, Expr *Init);\n\n  explicit DesignatedInitExpr(unsigned NumSubExprs)\n    : Expr(DesignatedInitExprClass, EmptyShell()),\n      NumDesignators(0), NumSubExprs(NumSubExprs), Designators(nullptr) { }\n\npublic:\n  /// A field designator, e.g., \".x\".\n  struct FieldDesignator {\n    /// Refers to the field that is being initialized. The low bit\n    /// of this field determines whether this is actually a pointer\n    /// to an IdentifierInfo (if 1) or a FieldDecl (if 0). When\n    /// initially constructed, a field designator will store an\n    /// IdentifierInfo*. After semantic analysis has resolved that\n    /// name, the field designator will instead store a FieldDecl*.\n    uintptr_t NameOrField;\n\n    /// The location of the '.' in the designated initializer.\n    SourceLocation DotLoc;\n\n    /// The location of the field name in the designated initializer.\n    SourceLocation FieldLoc;\n  };\n\n  /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n  struct ArrayOrRangeDesignator {\n    /// Location of the first index expression within the designated\n    /// initializer expression's list of subexpressions.\n    unsigned Index;\n    /// The location of the '[' starting the array range designator.\n    SourceLocation LBracketLoc;\n    /// The location of the ellipsis separating the start and end\n    /// indices. Only valid for GNU array-range designators.\n    SourceLocation EllipsisLoc;\n    /// The location of the ']' terminating the array range designator.\n    SourceLocation RBracketLoc;\n  };\n\n  /// Represents a single C99 designator.\n  ///\n  /// @todo This class is infuriatingly similar to clang::Designator,\n  /// but minor differences (storing indices vs. storing pointers)\n  /// keep us from reusing it. Try harder, later, to rectify these\n  /// differences.\n  class Designator {\n    /// The kind of designator this describes.\n    enum {\n      FieldDesignator,\n      ArrayDesignator,\n      ArrayRangeDesignator\n    } Kind;\n\n    union {\n      /// A field designator, e.g., \".x\".\n      struct FieldDesignator Field;\n      /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n      struct ArrayOrRangeDesignator ArrayOrRange;\n    };\n    friend class DesignatedInitExpr;\n\n  public:\n    Designator() {}\n\n    /// Initializes a field designator.\n    Designator(const IdentifierInfo *FieldName, SourceLocation DotLoc,\n               SourceLocation FieldLoc)\n      : Kind(FieldDesignator) {\n      new (&Field) DesignatedInitExpr::FieldDesignator;\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FieldName) | 0x01;\n      Field.DotLoc = DotLoc;\n      Field.FieldLoc = FieldLoc;\n    }\n\n    /// Initializes an array designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation RBracketLoc)\n      : Kind(ArrayDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = SourceLocation();\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    /// Initializes a GNU array-range designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation EllipsisLoc, SourceLocation RBracketLoc)\n      : Kind(ArrayRangeDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = EllipsisLoc;\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    bool isFieldDesignator() const { return Kind == FieldDesignator; }\n    bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n    bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n    IdentifierInfo *getFieldName() const;\n\n    FieldDecl *getField() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      if (Field.NameOrField & 0x01)\n        return nullptr;\n      else\n        return reinterpret_cast<FieldDecl *>(Field.NameOrField);\n    }\n\n    void setField(FieldDecl *FD) {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FD);\n    }\n\n    SourceLocation getDotLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.DotLoc;\n    }\n\n    SourceLocation getFieldLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.FieldLoc;\n    }\n\n    SourceLocation getLBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.LBracketLoc;\n    }\n\n    SourceLocation getRBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.RBracketLoc;\n    }\n\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == ArrayRangeDesignator &&\n             \"Only valid on an array-range designator\");\n      return ArrayOrRange.EllipsisLoc;\n    }\n\n    unsigned getFirstExprIndex() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.Index;\n    }\n\n    SourceLocation getBeginLoc() const LLVM_READONLY {\n      if (Kind == FieldDesignator)\n        return getDotLoc().isInvalid()? getFieldLoc() : getDotLoc();\n      else\n        return getLBracketLoc();\n    }\n    SourceLocation getEndLoc() const LLVM_READONLY {\n      return Kind == FieldDesignator ? getFieldLoc() : getRBracketLoc();\n    }\n    SourceRange getSourceRange() const LLVM_READONLY {\n      return SourceRange(getBeginLoc(), getEndLoc());\n    }\n  };\n\n  static DesignatedInitExpr *Create(const ASTContext &C,\n                                    llvm::ArrayRef<Designator> Designators,\n                                    ArrayRef<Expr*> IndexExprs,\n                                    SourceLocation EqualOrColonLoc,\n                                    bool GNUSyntax, Expr *Init);\n\n  static DesignatedInitExpr *CreateEmpty(const ASTContext &C,\n                                         unsigned NumIndexExprs);\n\n  /// Returns the number of designators in this initializer.\n  unsigned size() const { return NumDesignators; }\n\n  // Iterator access to the designators.\n  llvm::MutableArrayRef<Designator> designators() {\n    return {Designators, NumDesignators};\n  }\n\n  llvm::ArrayRef<Designator> designators() const {\n    return {Designators, NumDesignators};\n  }\n\n  Designator *getDesignator(unsigned Idx) { return &designators()[Idx]; }\n  const Designator *getDesignator(unsigned Idx) const {\n    return &designators()[Idx];\n  }\n\n  void setDesignators(const ASTContext &C, const Designator *Desigs,\n                      unsigned NumDesigs);\n\n  Expr *getArrayIndex(const Designator &D) const;\n  Expr *getArrayRangeStart(const Designator &D) const;\n  Expr *getArrayRangeEnd(const Designator &D) const;\n\n  /// Retrieve the location of the '=' that precedes the\n  /// initializer value itself, if present.\n  SourceLocation getEqualOrColonLoc() const { return EqualOrColonLoc; }\n  void setEqualOrColonLoc(SourceLocation L) { EqualOrColonLoc = L; }\n\n  /// Whether this designated initializer should result in direct-initialization\n  /// of the designated subobject (eg, '{.foo{1, 2, 3}}').\n  bool isDirectInit() const { return EqualOrColonLoc.isInvalid(); }\n\n  /// Determines whether this designated initializer used the\n  /// deprecated GNU syntax for designated initializers.\n  bool usesGNUSyntax() const { return GNUSyntax; }\n  void setGNUSyntax(bool GNU) { GNUSyntax = GNU; }\n\n  /// Retrieve the initializer value.\n  Expr *getInit() const {\n    return cast<Expr>(*const_cast<DesignatedInitExpr*>(this)->child_begin());\n  }\n\n  void setInit(Expr *init) {\n    *child_begin() = init;\n  }\n\n  /// Retrieve the total number of subexpressions in this\n  /// designated initializer expression, including the actual\n  /// initialized value and any expressions that occur within array\n  /// and array-range designators.\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr *getSubExpr(unsigned Idx) const {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    return cast<Expr>(getTrailingObjects<Stmt *>()[Idx]);\n  }\n\n  void setSubExpr(unsigned Idx, Expr *E) {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    getTrailingObjects<Stmt *>()[Idx] = E;\n  }\n\n  /// Replaces the designator at index @p Idx with the series\n  /// of designators in [First, Last).\n  void ExpandDesignator(const ASTContext &C, unsigned Idx,\n                        const Designator *First, const Designator *Last);\n\n  SourceRange getDesignatorsSourceRange() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = getTrailingObjects<Stmt *>();\n    return child_range(begin, begin + NumSubExprs);\n  }\n  const_child_range children() const {\n    Stmt * const *begin = getTrailingObjects<Stmt *>();\n    return const_child_range(begin, begin + NumSubExprs);\n  }\n\n  friend TrailingObjects;\n};\n\n/// Represents a place-holder for an object not to be initialized by\n/// anything.\n///\n/// This only makes sense when it appears as part of an updater of a\n/// DesignatedInitUpdateExpr (see below). The base expression of a DIUE\n/// initializes a big object, and the NoInitExpr's mark the spots within the\n/// big object not to be overwritten by the updater.\n///\n/// \\see DesignatedInitUpdateExpr\nclass NoInitExpr : public Expr {\npublic:\n  explicit NoInitExpr(QualType ty)\n      : Expr(NoInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit NoInitExpr(EmptyShell Empty)\n    : Expr(NoInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NoInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n// In cases like:\n//   struct Q { int a, b, c; };\n//   Q *getQ();\n//   void foo() {\n//     struct A { Q q; } a = { *getQ(), .q.b = 3 };\n//   }\n//\n// We will have an InitListExpr for a, with type A, and then a\n// DesignatedInitUpdateExpr for \"a.q\" with type Q. The \"base\" for this DIUE\n// is the call expression *getQ(); the \"updater\" for the DIUE is \".q.b = 3\"\n//\nclass DesignatedInitUpdateExpr : public Expr {\n  // BaseAndUpdaterExprs[0] is the base expression;\n  // BaseAndUpdaterExprs[1] is an InitListExpr overwriting part of the base.\n  Stmt *BaseAndUpdaterExprs[2];\n\npublic:\n  DesignatedInitUpdateExpr(const ASTContext &C, SourceLocation lBraceLoc,\n                           Expr *baseExprs, SourceLocation rBraceLoc);\n\n  explicit DesignatedInitUpdateExpr(EmptyShell Empty)\n    : Expr(DesignatedInitUpdateExprClass, Empty) { }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitUpdateExprClass;\n  }\n\n  Expr *getBase() const { return cast<Expr>(BaseAndUpdaterExprs[0]); }\n  void setBase(Expr *Base) { BaseAndUpdaterExprs[0] = Base; }\n\n  InitListExpr *getUpdater() const {\n    return cast<InitListExpr>(BaseAndUpdaterExprs[1]);\n  }\n  void setUpdater(Expr *Updater) { BaseAndUpdaterExprs[1] = Updater; }\n\n  // Iterators\n  // children = the base and the updater\n  child_range children() {\n    return child_range(&BaseAndUpdaterExprs[0], &BaseAndUpdaterExprs[0] + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(&BaseAndUpdaterExprs[0],\n                             &BaseAndUpdaterExprs[0] + 2);\n  }\n};\n\n/// Represents a loop initializing the elements of an array.\n///\n/// The need to initialize the elements of an array occurs in a number of\n/// contexts:\n///\n///  * in the implicit copy/move constructor for a class with an array member\n///  * when a lambda-expression captures an array by value\n///  * when a decomposition declaration decomposes an array\n///\n/// There are two subexpressions: a common expression (the source array)\n/// that is evaluated once up-front, and a per-element initializer that\n/// runs once for each array element.\n///\n/// Within the per-element initializer, the common expression may be referenced\n/// via an OpaqueValueExpr, and the current index may be obtained via an\n/// ArrayInitIndexExpr.\nclass ArrayInitLoopExpr : public Expr {\n  Stmt *SubExprs[2];\n\n  explicit ArrayInitLoopExpr(EmptyShell Empty)\n      : Expr(ArrayInitLoopExprClass, Empty), SubExprs{} {}\n\npublic:\n  explicit ArrayInitLoopExpr(QualType T, Expr *CommonInit, Expr *ElementInit)\n      : Expr(ArrayInitLoopExprClass, T, VK_RValue, OK_Ordinary),\n        SubExprs{CommonInit, ElementInit} {\n    setDependence(computeDependence(this));\n  }\n\n  /// Get the common subexpression shared by all initializations (the source\n  /// array).\n  OpaqueValueExpr *getCommonExpr() const {\n    return cast<OpaqueValueExpr>(SubExprs[0]);\n  }\n\n  /// Get the initializer to use for each array element.\n  Expr *getSubExpr() const { return cast<Expr>(SubExprs[1]); }\n\n  llvm::APInt getArraySize() const {\n    return cast<ConstantArrayType>(getType()->castAsArrayTypeUnsafe())\n        ->getSize();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitLoopExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommonExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCommonExpr()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents the index of the current element of an array being\n/// initialized by an ArrayInitLoopExpr. This can only appear within the\n/// subexpression of an ArrayInitLoopExpr.\nclass ArrayInitIndexExpr : public Expr {\n  explicit ArrayInitIndexExpr(EmptyShell Empty)\n      : Expr(ArrayInitIndexExprClass, Empty) {}\n\npublic:\n  explicit ArrayInitIndexExpr(QualType T)\n      : Expr(ArrayInitIndexExprClass, T, VK_RValue, OK_Ordinary) {\n    setDependence(ExprDependence::None);\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitIndexExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n};\n\n/// Represents an implicitly-generated value initialization of\n/// an object of a given type.\n///\n/// Implicit value initializations occur within semantic initializer\n/// list expressions (InitListExpr) as placeholders for subobject\n/// initializations not explicitly specified by the user.\n///\n/// \\see InitListExpr\nclass ImplicitValueInitExpr : public Expr {\npublic:\n  explicit ImplicitValueInitExpr(QualType ty)\n      : Expr(ImplicitValueInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty implicit value initialization.\n  explicit ImplicitValueInitExpr(EmptyShell Empty)\n    : Expr(ImplicitValueInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitValueInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass ParenListExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ParenListExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the left and right parentheses.\n  SourceLocation LParenLoc, RParenLoc;\n\n  /// Build a paren list.\n  ParenListExpr(SourceLocation LParenLoc, ArrayRef<Expr *> Exprs,\n                SourceLocation RParenLoc);\n\n  /// Build an empty paren list.\n  ParenListExpr(EmptyShell Empty, unsigned NumExprs);\n\npublic:\n  /// Create a paren list.\n  static ParenListExpr *Create(const ASTContext &Ctx, SourceLocation LParenLoc,\n                               ArrayRef<Expr *> Exprs,\n                               SourceLocation RParenLoc);\n\n  /// Create an empty paren list.\n  static ParenListExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumExprs);\n\n  /// Return the number of expressions in this paren list.\n  unsigned getNumExprs() const { return ParenListExprBits.NumExprs; }\n\n  Expr *getExpr(unsigned Init) {\n    assert(Init < getNumExprs() && \"Initializer access out of range!\");\n    return getExprs()[Init];\n  }\n\n  const Expr *getExpr(unsigned Init) const {\n    return const_cast<ParenListExpr *>(this)->getExpr(Init);\n  }\n\n  Expr **getExprs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>());\n  }\n\n  ArrayRef<Expr *> exprs() {\n    return llvm::makeArrayRef(getExprs(), getNumExprs());\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getLParenLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n};\n\n/// Represents a C11 generic selection.\n///\n/// A generic selection (C11 6.5.1.1) contains an unevaluated controlling\n/// expression, followed by one or more generic associations.  Each generic\n/// association specifies a type name and an expression, or \"default\" and an\n/// expression (in which case it is known as a default generic association).\n/// The type and value of the generic selection are identical to those of its\n/// result expression, which is defined as the expression in the generic\n/// association with a type name that is compatible with the type of the\n/// controlling expression, or the expression in the default generic association\n/// if no types are compatible.  For example:\n///\n/// @code\n/// _Generic(X, double: 1, float: 2, default: 3)\n/// @endcode\n///\n/// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f\n/// or 3 if \"hello\".\n///\n/// As an extension, generic selections are allowed in C++, where the following\n/// additional semantics apply:\n///\n/// Any generic selection whose controlling expression is type-dependent or\n/// which names a dependent type in its association list is result-dependent,\n/// which means that the choice of result expression is dependent.\n/// Result-dependent generic associations are both type- and value-dependent.\nclass GenericSelectionExpr final\n    : public Expr,\n      private llvm::TrailingObjects<GenericSelectionExpr, Stmt *,\n                                    TypeSourceInfo *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The number of association expressions and the index of the result\n  /// expression in the case where the generic selection expression is not\n  /// result-dependent. The result index is equal to ResultDependentIndex\n  /// if and only if the generic selection expression is result-dependent.\n  unsigned NumAssocs, ResultIndex;\n  enum : unsigned {\n    ResultDependentIndex = std::numeric_limits<unsigned>::max(),\n    ControllingIndex = 0,\n    AssocExprStartIndex = 1\n  };\n\n  /// The location of the \"default\" and of the right parenthesis.\n  SourceLocation DefaultLoc, RParenLoc;\n\n  // GenericSelectionExpr is followed by several trailing objects.\n  // They are (in order):\n  //\n  // * A single Stmt * for the controlling expression.\n  // * An array of getNumAssocs() Stmt * for the association expressions.\n  // * An array of getNumAssocs() TypeSourceInfo *, one for each of the\n  //   association expressions.\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    // Add one to account for the controlling expression; the remainder\n    // are the associated expressions.\n    return 1 + getNumAssocs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumAssocs();\n  }\n\n  template <bool Const> class AssociationIteratorTy;\n  /// Bundle together an association expression and its TypeSourceInfo.\n  /// The Const template parameter is for the const and non-const versions\n  /// of AssociationTy.\n  template <bool Const> class AssociationTy {\n    friend class GenericSelectionExpr;\n    template <bool OtherConst> friend class AssociationIteratorTy;\n    using ExprPtrTy = std::conditional_t<Const, const Expr *, Expr *>;\n    using TSIPtrTy =\n        std::conditional_t<Const, const TypeSourceInfo *, TypeSourceInfo *>;\n    ExprPtrTy E;\n    TSIPtrTy TSI;\n    bool Selected;\n    AssociationTy(ExprPtrTy E, TSIPtrTy TSI, bool Selected)\n        : E(E), TSI(TSI), Selected(Selected) {}\n\n  public:\n    ExprPtrTy getAssociationExpr() const { return E; }\n    TSIPtrTy getTypeSourceInfo() const { return TSI; }\n    QualType getType() const { return TSI ? TSI->getType() : QualType(); }\n    bool isSelected() const { return Selected; }\n    AssociationTy *operator->() { return this; }\n    const AssociationTy *operator->() const { return this; }\n  }; // class AssociationTy\n\n  /// Iterator over const and non-const Association objects. The Association\n  /// objects are created on the fly when the iterator is dereferenced.\n  /// This abstract over how exactly the association expressions and the\n  /// corresponding TypeSourceInfo * are stored.\n  template <bool Const>\n  class AssociationIteratorTy\n      : public llvm::iterator_facade_base<\n            AssociationIteratorTy<Const>, std::input_iterator_tag,\n            AssociationTy<Const>, std::ptrdiff_t, AssociationTy<Const>,\n            AssociationTy<Const>> {\n    friend class GenericSelectionExpr;\n    // FIXME: This iterator could conceptually be a random access iterator, and\n    // it would be nice if we could strengthen the iterator category someday.\n    // However this iterator does not satisfy two requirements of forward\n    // iterators:\n    // a) reference = T& or reference = const T&\n    // b) If It1 and It2 are both dereferenceable, then It1 == It2 if and only\n    //    if *It1 and *It2 are bound to the same objects.\n    // An alternative design approach was discussed during review;\n    // store an Association object inside the iterator, and return a reference\n    // to it when dereferenced. This idea was discarded beacuse of nasty\n    // lifetime issues:\n    //    AssociationIterator It = ...;\n    //    const Association &Assoc = *It++; // Oops, Assoc is dangling.\n    using BaseTy = typename AssociationIteratorTy::iterator_facade_base;\n    using StmtPtrPtrTy =\n        std::conditional_t<Const, const Stmt *const *, Stmt **>;\n    using TSIPtrPtrTy = std::conditional_t<Const, const TypeSourceInfo *const *,\n                                           TypeSourceInfo **>;\n    StmtPtrPtrTy E; // = nullptr; FIXME: Once support for gcc 4.8 is dropped.\n    TSIPtrPtrTy TSI; // Kept in sync with E.\n    unsigned Offset = 0, SelectedOffset = 0;\n    AssociationIteratorTy(StmtPtrPtrTy E, TSIPtrPtrTy TSI, unsigned Offset,\n                          unsigned SelectedOffset)\n        : E(E), TSI(TSI), Offset(Offset), SelectedOffset(SelectedOffset) {}\n\n  public:\n    AssociationIteratorTy() : E(nullptr), TSI(nullptr) {}\n    typename BaseTy::reference operator*() const {\n      return AssociationTy<Const>(cast<Expr>(*E), *TSI,\n                                  Offset == SelectedOffset);\n    }\n    typename BaseTy::pointer operator->() const { return **this; }\n    using BaseTy::operator++;\n    AssociationIteratorTy &operator++() {\n      ++E;\n      ++TSI;\n      ++Offset;\n      return *this;\n    }\n    bool operator==(AssociationIteratorTy Other) const { return E == Other.E; }\n  }; // class AssociationIterator\n\n  /// Build a non-result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack,\n                       unsigned ResultIndex);\n\n  /// Build a result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack);\n\n  /// Build an empty generic selection expression for deserialization.\n  explicit GenericSelectionExpr(EmptyShell Empty, unsigned NumAssocs);\n\npublic:\n  /// Create a non-result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack,\n         unsigned ResultIndex);\n\n  /// Create a result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack);\n\n  /// Create an empty generic selection expression for deserialization.\n  static GenericSelectionExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumAssocs);\n\n  using Association = AssociationTy<false>;\n  using ConstAssociation = AssociationTy<true>;\n  using AssociationIterator = AssociationIteratorTy<false>;\n  using ConstAssociationIterator = AssociationIteratorTy<true>;\n  using association_range = llvm::iterator_range<AssociationIterator>;\n  using const_association_range =\n      llvm::iterator_range<ConstAssociationIterator>;\n\n  /// The number of association expressions.\n  unsigned getNumAssocs() const { return NumAssocs; }\n\n  /// The zero-based index of the result expression's generic association in\n  /// the generic selection's association list.  Defined only if the\n  /// generic selection is not result-dependent.\n  unsigned getResultIndex() const {\n    assert(!isResultDependent() &&\n           \"Generic selection is result-dependent but getResultIndex called!\");\n    return ResultIndex;\n  }\n\n  /// Whether this generic selection is result-dependent.\n  bool isResultDependent() const { return ResultIndex == ResultDependentIndex; }\n\n  /// Return the controlling expression of this generic selection expression.\n  Expr *getControllingExpr() {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n  const Expr *getControllingExpr() const {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n\n  /// Return the result expression of this controlling expression. Defined if\n  /// and only if the generic selection expression is not result-dependent.\n  Expr *getResultExpr() {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n  const Expr *getResultExpr() const {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n\n  ArrayRef<Expr *> getAssocExprs() const {\n    return {reinterpret_cast<Expr *const *>(getTrailingObjects<Stmt *>() +\n                                            AssocExprStartIndex),\n            NumAssocs};\n  }\n  ArrayRef<TypeSourceInfo *> getAssocTypeSourceInfos() const {\n    return {getTrailingObjects<TypeSourceInfo *>(), NumAssocs};\n  }\n\n  /// Return the Ith association expression with its TypeSourceInfo,\n  /// bundled together in GenericSelectionExpr::(Const)Association.\n  Association getAssociation(unsigned I) {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return Association(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n  ConstAssociation getAssociation(unsigned I) const {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return ConstAssociation(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n\n  association_range associations() {\n    AssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                  AssocExprStartIndex,\n                              getTrailingObjects<TypeSourceInfo *>(),\n                              /*Offset=*/0, ResultIndex);\n    AssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                            /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  const_association_range associations() const {\n    ConstAssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                       AssocExprStartIndex,\n                                   getTrailingObjects<TypeSourceInfo *>(),\n                                   /*Offset=*/0, ResultIndex);\n    ConstAssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                                 /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  SourceLocation getGenericLoc() const {\n    return GenericSelectionExprBits.GenericLoc;\n  }\n  SourceLocation getDefaultLoc() const { return DefaultLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getGenericLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GenericSelectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Clang Extensions\n//===----------------------------------------------------------------------===//\n\n/// ExtVectorElementExpr - This represents access to specific elements of a\n/// vector, and may occur on the left hand side or right hand side.  For example\n/// the following is legal:  \"V.xy = V.zw\" if V is a 4 element extended vector.\n///\n/// Note that the base may have either vector or pointer to vector type, just\n/// like a struct field reference.\n///\nclass ExtVectorElementExpr : public Expr {\n  Stmt *Base;\n  IdentifierInfo *Accessor;\n  SourceLocation AccessorLoc;\npublic:\n  ExtVectorElementExpr(QualType ty, ExprValueKind VK, Expr *base,\n                       IdentifierInfo &accessor, SourceLocation loc)\n      : Expr(ExtVectorElementExprClass, ty, VK,\n             (VK == VK_RValue ? OK_Ordinary : OK_VectorComponent)),\n        Base(base), Accessor(&accessor), AccessorLoc(loc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty vector element expression.\n  explicit ExtVectorElementExpr(EmptyShell Empty)\n    : Expr(ExtVectorElementExprClass, Empty) { }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr *E) { Base = E; }\n\n  IdentifierInfo &getAccessor() const { return *Accessor; }\n  void setAccessor(IdentifierInfo *II) { Accessor = II; }\n\n  SourceLocation getAccessorLoc() const { return AccessorLoc; }\n  void setAccessorLoc(SourceLocation L) { AccessorLoc = L; }\n\n  /// getNumElements - Get the number of components being selected.\n  unsigned getNumElements() const;\n\n  /// containsDuplicateElements - Return true if any element access is\n  /// repeated.\n  bool containsDuplicateElements() const;\n\n  /// getEncodedElementAccess - Encode the elements accessed into an llvm\n  /// aggregate Constant of ConstantInt(s).\n  void getEncodedElementAccess(SmallVectorImpl<uint32_t> &Elts) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return AccessorLoc; }\n\n  /// isArrow - Return true if the base expression is a pointer to vector,\n  /// return false if the base expression is a vector.\n  bool isArrow() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExtVectorElementExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockExpr : public Expr {\nprotected:\n  BlockDecl *TheBlock;\npublic:\n  BlockExpr(BlockDecl *BD, QualType ty)\n      : Expr(BlockExprClass, ty, VK_RValue, OK_Ordinary), TheBlock(BD) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty block expression.\n  explicit BlockExpr(EmptyShell Empty) : Expr(BlockExprClass, Empty) { }\n\n  const BlockDecl *getBlockDecl() const { return TheBlock; }\n  BlockDecl *getBlockDecl() { return TheBlock; }\n  void setBlockDecl(BlockDecl *BD) { TheBlock = BD; }\n\n  // Convenience functions for probing the underlying BlockDecl.\n  SourceLocation getCaretLocation() const;\n  const Stmt *getBody() const;\n  Stmt *getBody();\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCaretLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  /// getFunctionType - Return the underlying function type for this block.\n  const FunctionProtoType *getFunctionType() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BlockExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Copy initialization expr of a __block variable and a boolean flag that\n/// indicates whether the expression can throw.\nstruct BlockVarCopyInit {\n  BlockVarCopyInit() = default;\n  BlockVarCopyInit(Expr *CopyExpr, bool CanThrow)\n      : ExprAndFlag(CopyExpr, CanThrow) {}\n  void setExprAndFlag(Expr *CopyExpr, bool CanThrow) {\n    ExprAndFlag.setPointerAndInt(CopyExpr, CanThrow);\n  }\n  Expr *getCopyExpr() const { return ExprAndFlag.getPointer(); }\n  bool canThrow() const { return ExprAndFlag.getInt(); }\n  llvm::PointerIntPair<Expr *, 1, bool> ExprAndFlag;\n};\n\n/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL 6.2.4.2]\n/// This AST node provides support for reinterpreting a type to another\n/// type of the same size.\nclass AsTypeExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit AsTypeExpr(EmptyShell Empty) : Expr(AsTypeExprClass, Empty) {}\n\npublic:\n  AsTypeExpr(Expr *SrcExpr, QualType DstType, ExprValueKind VK,\n             ExprObjectKind OK, SourceLocation BuiltinLoc,\n             SourceLocation RParenLoc)\n      : Expr(AsTypeExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getBuiltinLoc - Return the location of the __builtin_astype token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AsTypeExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// PseudoObjectExpr - An expression which accesses a pseudo-object\n/// l-value.  A pseudo-object is an abstract object, accesses to which\n/// are translated to calls.  The pseudo-object expression has a\n/// syntactic form, which shows how the expression was actually\n/// written in the source code, and a semantic form, which is a series\n/// of expressions to be executed in order which detail how the\n/// operation is actually evaluated.  Optionally, one of the semantic\n/// forms may also provide a result value for the expression.\n///\n/// If any of the semantic-form expressions is an OpaqueValueExpr,\n/// that OVE is required to have a source expression, and it is bound\n/// to the result of that source expression.  Such OVEs may appear\n/// only in subsequent semantic-form expressions and as\n/// sub-expressions of the syntactic form.\n///\n/// PseudoObjectExpr should be used only when an operation can be\n/// usefully described in terms of fairly simple rewrite rules on\n/// objects and functions that are meant to be used by end-developers.\n/// For example, under the Itanium ABI, dynamic casts are implemented\n/// as a call to a runtime function called __dynamic_cast; using this\n/// class to describe that would be inappropriate because that call is\n/// not really part of the user-visible semantics, and instead the\n/// cast is properly reflected in the AST and IR-generation has been\n/// taught to generate the call as necessary.  In contrast, an\n/// Objective-C property access is semantically defined to be\n/// equivalent to a particular message send, and this is very much\n/// part of the user model.  The name of this class encourages this\n/// modelling design.\nclass PseudoObjectExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PseudoObjectExpr, Expr *> {\n  // PseudoObjectExprBits.NumSubExprs - The number of sub-expressions.\n  // Always at least two, because the first sub-expression is the\n  // syntactic form.\n\n  // PseudoObjectExprBits.ResultIndex - The index of the\n  // sub-expression holding the result.  0 means the result is void,\n  // which is unambiguous because it's the index of the syntactic\n  // form.  Note that this is therefore 1 higher than the value passed\n  // in to Create, which is an index within the semantic forms.\n  // Note also that ASTStmtWriter assumes this encoding.\n\n  Expr **getSubExprsBuffer() { return getTrailingObjects<Expr *>(); }\n  const Expr * const *getSubExprsBuffer() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  PseudoObjectExpr(QualType type, ExprValueKind VK,\n                   Expr *syntactic, ArrayRef<Expr*> semantic,\n                   unsigned resultIndex);\n\n  PseudoObjectExpr(EmptyShell shell, unsigned numSemanticExprs);\n\n  unsigned getNumSubExprs() const {\n    return PseudoObjectExprBits.NumSubExprs;\n  }\n\npublic:\n  /// NoResult - A value for the result index indicating that there is\n  /// no semantic result.\n  enum : unsigned { NoResult = ~0U };\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, Expr *syntactic,\n                                  ArrayRef<Expr*> semantic,\n                                  unsigned resultIndex);\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, EmptyShell shell,\n                                  unsigned numSemanticExprs);\n\n  /// Return the syntactic form of this expression, i.e. the\n  /// expression it actually looks like.  Likely to be expressed in\n  /// terms of OpaqueValueExprs bound in the semantic form.\n  Expr *getSyntacticForm() { return getSubExprsBuffer()[0]; }\n  const Expr *getSyntacticForm() const { return getSubExprsBuffer()[0]; }\n\n  /// Return the index of the result-bearing expression into the semantics\n  /// expressions, or PseudoObjectExpr::NoResult if there is none.\n  unsigned getResultExprIndex() const {\n    if (PseudoObjectExprBits.ResultIndex == 0) return NoResult;\n    return PseudoObjectExprBits.ResultIndex - 1;\n  }\n\n  /// Return the result-bearing expression, or null if there is none.\n  Expr *getResultExpr() {\n    if (PseudoObjectExprBits.ResultIndex == 0)\n      return nullptr;\n    return getSubExprsBuffer()[PseudoObjectExprBits.ResultIndex];\n  }\n  const Expr *getResultExpr() const {\n    return const_cast<PseudoObjectExpr*>(this)->getResultExpr();\n  }\n\n  unsigned getNumSemanticExprs() const { return getNumSubExprs() - 1; }\n\n  typedef Expr * const *semantics_iterator;\n  typedef const Expr * const *const_semantics_iterator;\n  semantics_iterator semantics_begin() {\n    return getSubExprsBuffer() + 1;\n  }\n  const_semantics_iterator semantics_begin() const {\n    return getSubExprsBuffer() + 1;\n  }\n  semantics_iterator semantics_end() {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n  const_semantics_iterator semantics_end() const {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n\n  llvm::iterator_range<semantics_iterator> semantics() {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n  llvm::iterator_range<const_semantics_iterator> semantics() const {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n\n  Expr *getSemanticExpr(unsigned index) {\n    assert(index + 1 < getNumSubExprs());\n    return getSubExprsBuffer()[index + 1];\n  }\n  const Expr *getSemanticExpr(unsigned index) const {\n    return const_cast<PseudoObjectExpr*>(this)->getSemanticExpr(index);\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getExprLoc();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getEndLoc();\n  }\n\n  child_range children() {\n    const_child_range CCR =\n        const_cast<const PseudoObjectExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n  const_child_range children() const {\n    Stmt *const *cs = const_cast<Stmt *const *>(\n        reinterpret_cast<const Stmt *const *>(getSubExprsBuffer()));\n    return const_child_range(cs, cs + getNumSubExprs());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PseudoObjectExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n};\n\n/// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,\n/// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the\n/// similarly-named C++11 instructions, and __c11 variants for <stdatomic.h>,\n/// and corresponding __opencl_atomic_* for OpenCL 2.0.\n/// All of these instructions take one primary pointer, at least one memory\n/// order. The instructions for which getScopeModel returns non-null value\n/// take one synch scope.\nclass AtomicExpr : public Expr {\npublic:\n  enum AtomicOp {\n#define BUILTIN(ID, TYPE, ATTRS)\n#define ATOMIC_BUILTIN(ID, TYPE, ATTRS) AO ## ID,\n#include \"clang/Basic/Builtins.def\"\n    // Avoid trailing comma\n    BI_First = 0\n  };\n\nprivate:\n  /// Location of sub-expressions.\n  /// The location of Scope sub-expression is NumSubExprs - 1, which is\n  /// not fixed, therefore is not defined in enum.\n  enum { PTR, ORDER, VAL1, ORDER_FAIL, VAL2, WEAK, END_EXPR };\n  Stmt *SubExprs[END_EXPR + 1];\n  unsigned NumSubExprs;\n  SourceLocation BuiltinLoc, RParenLoc;\n  AtomicOp Op;\n\n  friend class ASTStmtReader;\npublic:\n  AtomicExpr(SourceLocation BLoc, ArrayRef<Expr*> args, QualType t,\n             AtomicOp op, SourceLocation RP);\n\n  /// Determine the number of arguments the specified atomic builtin\n  /// should have.\n  static unsigned getNumSubExprs(AtomicOp Op);\n\n  /// Build an empty AtomicExpr.\n  explicit AtomicExpr(EmptyShell Empty) : Expr(AtomicExprClass, Empty) { }\n\n  Expr *getPtr() const {\n    return cast<Expr>(SubExprs[PTR]);\n  }\n  Expr *getOrder() const {\n    return cast<Expr>(SubExprs[ORDER]);\n  }\n  Expr *getScope() const {\n    assert(getScopeModel() && \"No scope\");\n    return cast<Expr>(SubExprs[NumSubExprs - 1]);\n  }\n  Expr *getVal1() const {\n    if (Op == AO__c11_atomic_init || Op == AO__opencl_atomic_init)\n      return cast<Expr>(SubExprs[ORDER]);\n    assert(NumSubExprs > VAL1);\n    return cast<Expr>(SubExprs[VAL1]);\n  }\n  Expr *getOrderFail() const {\n    assert(NumSubExprs > ORDER_FAIL);\n    return cast<Expr>(SubExprs[ORDER_FAIL]);\n  }\n  Expr *getVal2() const {\n    if (Op == AO__atomic_exchange)\n      return cast<Expr>(SubExprs[ORDER_FAIL]);\n    assert(NumSubExprs > VAL2);\n    return cast<Expr>(SubExprs[VAL2]);\n  }\n  Expr *getWeak() const {\n    assert(NumSubExprs > WEAK);\n    return cast<Expr>(SubExprs[WEAK]);\n  }\n  QualType getValueType() const;\n\n  AtomicOp getOp() const { return Op; }\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n  const Expr * const *getSubExprs() const {\n    return reinterpret_cast<Expr * const *>(SubExprs);\n  }\n\n  bool isVolatile() const {\n    return getPtr()->getType()->getPointeeType().isVolatileQualified();\n  }\n\n  bool isCmpXChg() const {\n    return getOp() == AO__c11_atomic_compare_exchange_strong ||\n           getOp() == AO__c11_atomic_compare_exchange_weak ||\n           getOp() == AO__opencl_atomic_compare_exchange_strong ||\n           getOp() == AO__opencl_atomic_compare_exchange_weak ||\n           getOp() == AO__atomic_compare_exchange ||\n           getOp() == AO__atomic_compare_exchange_n;\n  }\n\n  bool isOpenCL() const {\n    return getOp() >= AO__opencl_atomic_init &&\n           getOp() <= AO__opencl_atomic_fetch_max;\n  }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AtomicExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs+NumSubExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NumSubExprs);\n  }\n\n  /// Get atomic scope model for the atomic op code.\n  /// \\return empty atomic scope model if the atomic op code does not have\n  ///   scope operand.\n  static std::unique_ptr<AtomicScopeModel> getScopeModel(AtomicOp Op) {\n    auto Kind =\n        (Op >= AO__opencl_atomic_load && Op <= AO__opencl_atomic_fetch_max)\n            ? AtomicScopeModelKind::OpenCL\n            : AtomicScopeModelKind::None;\n    return AtomicScopeModel::create(Kind);\n  }\n\n  /// Get atomic scope model.\n  /// \\return empty atomic scope model if this atomic expression does not have\n  ///   scope operand.\n  std::unique_ptr<AtomicScopeModel> getScopeModel() const {\n    return getScopeModel(getOp());\n  }\n};\n\n/// TypoExpr - Internal placeholder for expressions where typo correction\n/// still needs to be performed and/or an error diagnostic emitted.\nclass TypoExpr : public Expr {\n  // The location for the typo name.\n  SourceLocation TypoLoc;\n\npublic:\n  TypoExpr(QualType T, SourceLocation TypoLoc)\n      : Expr(TypoExprClass, T, VK_LValue, OK_Ordinary), TypoLoc(TypoLoc) {\n    assert(T->isDependentType() && \"TypoExpr given a non-dependent type\");\n    setDependence(ExprDependence::TypeValueInstantiation |\n                  ExprDependence::Error);\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TypoLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TypoLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypoExprClass;\n  }\n\n};\n\n/// Frontend produces RecoveryExprs on semantic errors that prevent creating\n/// other well-formed expressions. E.g. when type-checking of a binary operator\n/// fails, we cannot produce a BinaryOperator expression. Instead, we can choose\n/// to produce a recovery expression storing left and right operands.\n///\n/// RecoveryExpr does not have any semantic meaning in C++, it is only useful to\n/// preserve expressions in AST that would otherwise be dropped. It captures\n/// subexpressions of some expression that we could not construct and source\n/// range covered by the expression.\n///\n/// By default, RecoveryExpr uses dependence-bits to take advantage of existing\n/// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved\n/// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In\n/// addition to that, clang does not report most errors on dependent\n/// expressions, so we get rid of bogus errors for free. However, note that\n/// unlike other dependent expressions, RecoveryExpr can be produced in\n/// non-template contexts.\n///\n/// We will preserve the type in RecoveryExpr when the type is known, e.g.\n/// preserving the return type for a broken non-overloaded function call, a\n/// overloaded call where all candidates have the same return type. In this\n/// case, the expression is not type-dependent (unless the known type is itself\n/// dependent)\n///\n/// One can also reliably suppress all bogus errors on expressions containing\n/// recovery expressions by examining results of Expr::containsErrors().\nclass RecoveryExpr final : public Expr,\n                           private llvm::TrailingObjects<RecoveryExpr, Expr *> {\npublic:\n  static RecoveryExpr *Create(ASTContext &Ctx, QualType T,\n                              SourceLocation BeginLoc, SourceLocation EndLoc,\n                              ArrayRef<Expr *> SubExprs);\n  static RecoveryExpr *CreateEmpty(ASTContext &Ctx, unsigned NumSubExprs);\n\n  ArrayRef<Expr *> subExpressions() {\n    auto *B = getTrailingObjects<Expr *>();\n    return llvm::makeArrayRef(B, B + NumExprs);\n  }\n\n  ArrayRef<const Expr *> subExpressions() const {\n    return const_cast<RecoveryExpr *>(this)->subExpressions();\n  }\n\n  child_range children() {\n    Stmt **B = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(B, B + NumExprs);\n  }\n\n  SourceLocation getBeginLoc() const { return BeginLoc; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RecoveryExprClass;\n  }\n\nprivate:\n  RecoveryExpr(ASTContext &Ctx, QualType T, SourceLocation BeginLoc,\n               SourceLocation EndLoc, ArrayRef<Expr *> SubExprs);\n  RecoveryExpr(EmptyShell Empty, unsigned NumSubExprs)\n      : Expr(RecoveryExprClass, Empty), NumExprs(NumSubExprs) {}\n\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const { return NumExprs; }\n\n  SourceLocation BeginLoc, EndLoc;\n  unsigned NumExprs;\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_AST_EXPR_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h", "content": "//===- PreprocessorOptions.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSOROPTIONS_H_\n#define LLVM_CLANG_LEX_PREPROCESSOROPTIONS_H_\n\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include <functional>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\n} // namespace llvm\n\nnamespace clang {\n\n/// Enumerate the kinds of standard library that\nenum ObjCXXARCStandardLibraryKind {\n  ARCXX_nolib,\n\n  /// libc++\n  ARCXX_libcxx,\n\n  /// libstdc++\n  ARCXX_libstdcxx\n};\n\n/// Whether to disable the normal validation performed on precompiled\n/// headers and module files when they are loaded.\nenum class DisableValidationForModuleKind {\n  /// Perform validation, don't disable it.\n  None = 0,\n\n  /// Disable validation for a precompiled header and the modules it depends on.\n  PCH = 0x1,\n\n  /// Disable validation for module files.\n  Module = 0x2,\n\n  /// Disable validation for all kinds.\n  All = PCH | Module,\n\n  LLVM_MARK_AS_BITMASK_ENUM(Module)\n};\n\n/// PreprocessorOptions - This class is used for passing the various options\n/// used in preprocessor initialization to InitializePreprocessor().\nclass PreprocessorOptions {\npublic:\n  std::vector<std::pair<std::string, bool/*isUndef*/>> Macros;\n  std::vector<std::string> Includes;\n  std::vector<std::string> MacroIncludes;\n\n  /// Initialize the preprocessor with the compiler and target specific\n  /// predefines.\n  bool UsePredefines = true;\n\n  /// Whether we should maintain a detailed record of all macro\n  /// definitions and expansions.\n  bool DetailedRecord = false;\n\n  /// When true, we are creating or using a PCH where a #pragma hdrstop is\n  /// expected to indicate the beginning or end of the PCH.\n  bool PCHWithHdrStop = false;\n\n  /// When true, we are creating a PCH or creating the PCH object while\n  /// expecting a #pragma hdrstop to separate the two.  Allow for a\n  /// missing #pragma hdrstop, which generates a PCH for the whole file,\n  /// and creates an empty PCH object.\n  bool PCHWithHdrStopCreate = false;\n\n  /// If non-empty, the filename used in an #include directive in the primary\n  /// source file (or command-line preinclude) that is used to implement\n  /// MSVC-style precompiled headers. When creating a PCH, after the #include\n  /// of this header, the PCH generation stops. When using a PCH, tokens are\n  /// skipped until after an #include of this header is seen.\n  std::string PCHThroughHeader;\n\n  /// The implicit PCH included at the start of the translation unit, or empty.\n  std::string ImplicitPCHInclude;\n\n  /// Headers that will be converted to chained PCHs in memory.\n  std::vector<std::string> ChainedIncludes;\n\n  /// Whether to disable most of the normal validation performed on\n  /// precompiled headers and module files.\n  DisableValidationForModuleKind DisablePCHOrModuleValidation =\n      DisableValidationForModuleKind::None;\n\n  /// When true, a PCH with compiler errors will not be rejected.\n  bool AllowPCHWithCompilerErrors = false;\n\n  /// Dump declarations that are deserialized from PCH, for testing.\n  bool DumpDeserializedPCHDecls = false;\n\n  /// This is a set of names for decls that we do not want to be\n  /// deserialized, and we emit an error if they are; for testing purposes.\n  std::set<std::string> DeserializedPCHDeclsToErrorOn;\n\n  /// If non-zero, the implicit PCH include is actually a precompiled\n  /// preamble that covers this number of bytes in the main source file.\n  ///\n  /// The boolean indicates whether the preamble ends at the start of a new\n  /// line.\n  std::pair<unsigned, bool> PrecompiledPreambleBytes;\n\n  /// True indicates that a preamble is being generated.\n  ///\n  /// When the lexer is done, one of the things that need to be preserved is the\n  /// conditional #if stack, so the ASTWriter/ASTReader can save/restore it when\n  /// processing the rest of the file.\n  bool GeneratePreamble = false;\n\n  /// Whether to write comment locations into the PCH when building it.\n  /// Reading the comments from the PCH can be a performance hit even if the\n  /// clients don't use them.\n  bool WriteCommentListToPCH = true;\n\n  /// When enabled, preprocessor is in a mode for parsing a single file only.\n  ///\n  /// Disables #includes of other files and if there are unresolved identifiers\n  /// in preprocessor directive conditions it causes all blocks to be parsed so\n  /// that the client can get the maximum amount of information from the parser.\n  bool SingleFileParseMode = false;\n\n  /// When enabled, the preprocessor will construct editor placeholder tokens.\n  bool LexEditorPlaceholders = true;\n\n  /// True if the SourceManager should report the original file name for\n  /// contents of files that were remapped to other files. Defaults to true.\n  bool RemappedFilesKeepOriginalName = true;\n\n  /// The set of file remappings, which take existing files on\n  /// the system (the first part of each pair) and gives them the\n  /// contents of other files on the system (the second part of each\n  /// pair).\n  std::vector<std::pair<std::string, std::string>> RemappedFiles;\n\n  /// The set of file-to-buffer remappings, which take existing files\n  /// on the system (the first part of each pair) and gives them the contents\n  /// of the specified memory buffer (the second part of each pair).\n  std::vector<std::pair<std::string, llvm::MemoryBuffer *>> RemappedFileBuffers;\n\n  /// Whether the compiler instance should retain (i.e., not free)\n  /// the buffers associated with remapped files.\n  ///\n  /// This flag defaults to false; it can be set true only through direct\n  /// manipulation of the compiler invocation object, in cases where the\n  /// compiler invocation and its buffers will be reused.\n  bool RetainRemappedFileBuffers = false;\n\n  /// When enabled, excluded conditional blocks retain in the main file.\n  bool RetainExcludedConditionalBlocks = false;\n\n  /// The Objective-C++ ARC standard library that we should support,\n  /// by providing appropriate definitions to retrofit the standard library\n  /// with support for lifetime-qualified pointers.\n  ObjCXXARCStandardLibraryKind ObjCXXARCStandardLibrary = ARCXX_nolib;\n\n  /// Records the set of modules\n  class FailedModulesSet {\n    llvm::StringSet<> Failed;\n\n  public:\n    bool hasAlreadyFailed(StringRef module) {\n      return Failed.count(module) > 0;\n    }\n\n    void addFailed(StringRef module) {\n      Failed.insert(module);\n    }\n  };\n\n  /// The set of modules that failed to build.\n  ///\n  /// This pointer will be shared among all of the compiler instances created\n  /// to (re)build modules, so that once a module fails to build anywhere,\n  /// other instances will see that the module has failed and won't try to\n  /// build it again.\n  std::shared_ptr<FailedModulesSet> FailedModules;\n\n  /// A prefix map for __FILE__ and __BASE_FILE__.\n  std::map<std::string, std::string, std::greater<std::string>> MacroPrefixMap;\n\n  /// Contains the currently active skipped range mappings for skipping excluded\n  /// conditional directives.\n  ///\n  /// The pointer is passed to the Preprocessor when it's constructed. The\n  /// pointer is unowned, the client is responsible for its lifetime.\n  ExcludedPreprocessorDirectiveSkipMapping\n      *ExcludedConditionalDirectiveSkipMappings = nullptr;\n\n  /// Set up preprocessor for RunAnalysis action.\n  bool SetUpStaticAnalyzer = false;\n\n  /// Prevents intended crashes when using #pragma clang __debug. For testing.\n  bool DisablePragmaDebugCrash = false;\n\npublic:\n  PreprocessorOptions() : PrecompiledPreambleBytes(0, false) {}\n\n  void addMacroDef(StringRef Name) {\n    Macros.emplace_back(std::string(Name), false);\n  }\n  void addMacroUndef(StringRef Name) {\n    Macros.emplace_back(std::string(Name), true);\n  }\n\n  void addRemappedFile(StringRef From, StringRef To) {\n    RemappedFiles.emplace_back(std::string(From), std::string(To));\n  }\n\n  void addRemappedFile(StringRef From, llvm::MemoryBuffer *To) {\n    RemappedFileBuffers.emplace_back(std::string(From), To);\n  }\n\n  void clearRemappedFiles() {\n    RemappedFiles.clear();\n    RemappedFileBuffers.clear();\n  }\n\n  /// Reset any options that are not considered when building a\n  /// module.\n  void resetNonModularOptions() {\n    Includes.clear();\n    MacroIncludes.clear();\n    ChainedIncludes.clear();\n    DumpDeserializedPCHDecls = false;\n    ImplicitPCHInclude.clear();\n    SingleFileParseMode = false;\n    LexEditorPlaceholders = true;\n    RetainRemappedFileBuffers = true;\n    PrecompiledPreambleBytes.first = 0;\n    PrecompiledPreambleBytes.second = false;\n    RetainExcludedConditionalBlocks = false;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSOROPTIONS_H_\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "content": "//===--- Sema.h - Semantic Analysis & AST Building --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the Sema class, which performs semantic analysis and\n// builds ASTs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_SEMA_H\n#define LLVM_CLANG_SEMA_SEMA_H\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Availability.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprConcepts.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LocInfoType.h\"\n#include \"clang/AST/MangleNumberingContext.h\"\n#include \"clang/AST/NSAPI.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"clang/Basic/ExpressionTraits.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TemplateKinds.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"clang/Sema/AnalysisBasedWarnings.h\"\n#include \"clang/Sema/CleanupInfo.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/ObjCMethodList.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/SemaConcept.h\"\n#include \"clang/Sema/TypoCorrection.h\"\n#include \"clang/Sema/Weak.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include <deque>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n\nnamespace llvm {\n  class APSInt;\n  template <typename ValueT> struct DenseMapInfo;\n  template <typename ValueT, typename ValueInfoT> class DenseSet;\n  class SmallBitVector;\n  struct InlineAsmIdentifierInfo;\n}\n\nnamespace clang {\n  class ADLResult;\n  class ASTConsumer;\n  class ASTContext;\n  class ASTMutationListener;\n  class ASTReader;\n  class ASTWriter;\n  class ArrayType;\n  class ParsedAttr;\n  class BindingDecl;\n  class BlockDecl;\n  class CapturedDecl;\n  class CXXBasePath;\n  class CXXBasePaths;\n  class CXXBindTemporaryExpr;\n  typedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n  class CXXConstructorDecl;\n  class CXXConversionDecl;\n  class CXXDeleteExpr;\n  class CXXDestructorDecl;\n  class CXXFieldCollector;\n  class CXXMemberCallExpr;\n  class CXXMethodDecl;\n  class CXXScopeSpec;\n  class CXXTemporary;\n  class CXXTryStmt;\n  class CallExpr;\n  class ClassTemplateDecl;\n  class ClassTemplatePartialSpecializationDecl;\n  class ClassTemplateSpecializationDecl;\n  class VarTemplatePartialSpecializationDecl;\n  class CodeCompleteConsumer;\n  class CodeCompletionAllocator;\n  class CodeCompletionTUInfo;\n  class CodeCompletionResult;\n  class CoroutineBodyStmt;\n  class Decl;\n  class DeclAccessPair;\n  class DeclContext;\n  class DeclRefExpr;\n  class DeclaratorDecl;\n  class DeducedTemplateArgument;\n  class DependentDiagnostic;\n  class DesignatedInitExpr;\n  class Designation;\n  class EnableIfAttr;\n  class EnumConstantDecl;\n  class Expr;\n  class ExtVectorType;\n  class FormatAttr;\n  class FriendDecl;\n  class FunctionDecl;\n  class FunctionProtoType;\n  class FunctionTemplateDecl;\n  class ImplicitConversionSequence;\n  typedef MutableArrayRef<ImplicitConversionSequence> ConversionSequenceList;\n  class InitListExpr;\n  class InitializationKind;\n  class InitializationSequence;\n  class InitializedEntity;\n  class IntegerLiteral;\n  class LabelStmt;\n  class LambdaExpr;\n  class LangOptions;\n  class LocalInstantiationScope;\n  class LookupResult;\n  class MacroInfo;\n  typedef ArrayRef<std::pair<IdentifierInfo *, SourceLocation>> ModuleIdPath;\n  class ModuleLoader;\n  class MultiLevelTemplateArgumentList;\n  class NamedDecl;\n  class ObjCCategoryDecl;\n  class ObjCCategoryImplDecl;\n  class ObjCCompatibleAliasDecl;\n  class ObjCContainerDecl;\n  class ObjCImplDecl;\n  class ObjCImplementationDecl;\n  class ObjCInterfaceDecl;\n  class ObjCIvarDecl;\n  template <class T> class ObjCList;\n  class ObjCMessageExpr;\n  class ObjCMethodDecl;\n  class ObjCPropertyDecl;\n  class ObjCProtocolDecl;\n  class OMPThreadPrivateDecl;\n  class OMPRequiresDecl;\n  class OMPDeclareReductionDecl;\n  class OMPDeclareSimdDecl;\n  class OMPClause;\n  struct OMPVarListLocTy;\n  struct OverloadCandidate;\n  enum class OverloadCandidateParamOrder : char;\n  enum OverloadCandidateRewriteKind : unsigned;\n  class OverloadCandidateSet;\n  class OverloadExpr;\n  class ParenListExpr;\n  class ParmVarDecl;\n  class Preprocessor;\n  class PseudoDestructorTypeStorage;\n  class PseudoObjectExpr;\n  class QualType;\n  class StandardConversionSequence;\n  class Stmt;\n  class StringLiteral;\n  class SwitchStmt;\n  class TemplateArgument;\n  class TemplateArgumentList;\n  class TemplateArgumentLoc;\n  class TemplateDecl;\n  class TemplateInstantiationCallback;\n  class TemplateParameterList;\n  class TemplatePartialOrderingContext;\n  class TemplateTemplateParmDecl;\n  class Token;\n  class TypeAliasDecl;\n  class TypedefDecl;\n  class TypedefNameDecl;\n  class TypeLoc;\n  class TypoCorrectionConsumer;\n  class UnqualifiedId;\n  class UnresolvedLookupExpr;\n  class UnresolvedMemberExpr;\n  class UnresolvedSetImpl;\n  class UnresolvedSetIterator;\n  class UsingDecl;\n  class UsingShadowDecl;\n  class ValueDecl;\n  class VarDecl;\n  class VarTemplateSpecializationDecl;\n  class VisibilityAttr;\n  class VisibleDeclConsumer;\n  class IndirectFieldDecl;\n  struct DeductionFailureInfo;\n  class TemplateSpecCandidateSet;\n\nnamespace sema {\n  class AccessedEntity;\n  class BlockScopeInfo;\n  class Capture;\n  class CapturedRegionScopeInfo;\n  class CapturingScopeInfo;\n  class CompoundScopeInfo;\n  class DelayedDiagnostic;\n  class DelayedDiagnosticPool;\n  class FunctionScopeInfo;\n  class LambdaScopeInfo;\n  class PossiblyUnreachableDiag;\n  class SemaPPCallbacks;\n  class TemplateDeductionInfo;\n}\n\nnamespace threadSafety {\n  class BeforeSet;\n  void threadSafetyCleanup(BeforeSet* Cache);\n}\n\n// FIXME: No way to easily map from TemplateTypeParmTypes to\n// TemplateTypeParmDecls, so we have this horrible PointerUnion.\ntypedef std::pair<llvm::PointerUnion<const TemplateTypeParmType*, NamedDecl*>,\n                  SourceLocation> UnexpandedParameterPack;\n\n/// Describes whether we've seen any nullability information for the given\n/// file.\nstruct FileNullability {\n  /// The first pointer declarator (of any pointer kind) in the file that does\n  /// not have a corresponding nullability annotation.\n  SourceLocation PointerLoc;\n\n  /// The end location for the first pointer declarator in the file. Used for\n  /// placing fix-its.\n  SourceLocation PointerEndLoc;\n\n  /// Which kind of pointer declarator we saw.\n  uint8_t PointerKind;\n\n  /// Whether we saw any type nullability annotations in the given file.\n  bool SawTypeNullability = false;\n};\n\n/// A mapping from file IDs to a record of whether we've seen nullability\n/// information in that file.\nclass FileNullabilityMap {\n  /// A mapping from file IDs to the nullability information for each file ID.\n  llvm::DenseMap<FileID, FileNullability> Map;\n\n  /// A single-element cache based on the file ID.\n  struct {\n    FileID File;\n    FileNullability Nullability;\n  } Cache;\n\npublic:\n  FileNullability &operator[](FileID file) {\n    // Check the single-element cache.\n    if (file == Cache.File)\n      return Cache.Nullability;\n\n    // It's not in the single-element cache; flush the cache if we have one.\n    if (!Cache.File.isInvalid()) {\n      Map[Cache.File] = Cache.Nullability;\n    }\n\n    // Pull this entry into the cache.\n    Cache.File = file;\n    Cache.Nullability = Map[file];\n    return Cache.Nullability;\n  }\n};\n\n/// Keeps track of expected type during expression parsing. The type is tied to\n/// a particular token, all functions that update or consume the type take a\n/// start location of the token they are looking at as a parameter. This allows\n/// to avoid updating the type on hot paths in the parser.\nclass PreferredTypeBuilder {\npublic:\n  PreferredTypeBuilder() = default;\n  explicit PreferredTypeBuilder(QualType Type) : Type(Type) {}\n\n  void enterCondition(Sema &S, SourceLocation Tok);\n  void enterReturn(Sema &S, SourceLocation Tok);\n  void enterVariableInit(SourceLocation Tok, Decl *D);\n  /// Handles e.g. BaseType{ .D = Tok...\n  void enterDesignatedInitializer(SourceLocation Tok, QualType BaseType,\n                                  const Designation &D);\n  /// Computing a type for the function argument may require running\n  /// overloading, so we postpone its computation until it is actually needed.\n  ///\n  /// Clients should be very careful when using this funciton, as it stores a\n  /// function_ref, clients should make sure all calls to get() with the same\n  /// location happen while function_ref is alive.\n  void enterFunctionArgument(SourceLocation Tok,\n                             llvm::function_ref<QualType()> ComputeType);\n\n  void enterParenExpr(SourceLocation Tok, SourceLocation LParLoc);\n  void enterUnary(Sema &S, SourceLocation Tok, tok::TokenKind OpKind,\n                  SourceLocation OpLoc);\n  void enterBinary(Sema &S, SourceLocation Tok, Expr *LHS, tok::TokenKind Op);\n  void enterMemAccess(Sema &S, SourceLocation Tok, Expr *Base);\n  void enterSubscript(Sema &S, SourceLocation Tok, Expr *LHS);\n  /// Handles all type casts, including C-style cast, C++ casts, etc.\n  void enterTypeCast(SourceLocation Tok, QualType CastType);\n\n  QualType get(SourceLocation Tok) const {\n    if (Tok != ExpectedLoc)\n      return QualType();\n    if (!Type.isNull())\n      return Type;\n    if (ComputeType)\n      return ComputeType();\n    return QualType();\n  }\n\nprivate:\n  /// Start position of a token for which we store expected type.\n  SourceLocation ExpectedLoc;\n  /// Expected type for a token starting at ExpectedLoc.\n  QualType Type;\n  /// A function to compute expected type at ExpectedLoc. It is only considered\n  /// if Type is null.\n  llvm::function_ref<QualType()> ComputeType;\n};\n\n/// Sema - This implements semantic analysis and AST building for C.\nclass Sema final {\n  Sema(const Sema &) = delete;\n  void operator=(const Sema &) = delete;\n\n  /// A key method to reduce duplicate debug info from Sema.\n  virtual void anchor();\n\n  ///Source of additional semantic information.\n  ExternalSemaSource *ExternalSource;\n\n  ///Whether Sema has generated a multiplexer and has to delete it.\n  bool isMultiplexExternalSource;\n\n  static bool mightHaveNonExternalLinkage(const DeclaratorDecl *FD);\n\n  bool isVisibleSlow(const NamedDecl *D);\n\n  /// Determine whether two declarations should be linked together, given that\n  /// the old declaration might not be visible and the new declaration might\n  /// not have external linkage.\n  bool shouldLinkPossiblyHiddenDecl(const NamedDecl *Old,\n                                    const NamedDecl *New) {\n    if (isVisible(Old))\n     return true;\n    // See comment in below overload for why it's safe to compute the linkage\n    // of the new declaration here.\n    if (New->isExternallyDeclarable()) {\n      assert(Old->isExternallyDeclarable() &&\n             \"should not have found a non-externally-declarable previous decl\");\n      return true;\n    }\n    return false;\n  }\n  bool shouldLinkPossiblyHiddenDecl(LookupResult &Old, const NamedDecl *New);\n\n  void setupImplicitSpecialMemberType(CXXMethodDecl *SpecialMem,\n                                      QualType ResultTy,\n                                      ArrayRef<QualType> Args);\n\npublic:\n  /// The maximum alignment, same as in llvm::Value. We duplicate them here\n  /// because that allows us not to duplicate the constants in clang code,\n  /// which we must to since we can't directly use the llvm constants.\n  /// The value is verified against llvm here: lib/CodeGen/CGDecl.cpp\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  typedef OpaquePtr<DeclGroupRef> DeclGroupPtrTy;\n  typedef OpaquePtr<TemplateName> TemplateTy;\n  typedef OpaquePtr<QualType> TypeTy;\n\n  OpenCLOptions OpenCLFeatures;\n  FPOptions CurFPFeatures;\n\n  const LangOptions &LangOpts;\n  Preprocessor &PP;\n  ASTContext &Context;\n  ASTConsumer &Consumer;\n  DiagnosticsEngine &Diags;\n  SourceManager &SourceMgr;\n\n  /// Flag indicating whether or not to collect detailed statistics.\n  bool CollectStats;\n\n  /// Code-completion consumer.\n  CodeCompleteConsumer *CodeCompleter;\n\n  /// CurContext - This is the current declaration context of parsing.\n  DeclContext *CurContext;\n\n  /// Generally null except when we temporarily switch decl contexts,\n  /// like in \\see ActOnObjCTemporaryExitContainerContext.\n  DeclContext *OriginalLexicalContext;\n\n  /// VAListTagName - The declaration name corresponding to __va_list_tag.\n  /// This is used as part of a hack to omit that class from ADL results.\n  DeclarationName VAListTagName;\n\n  bool MSStructPragmaOn; // True when \\#pragma ms_struct on\n\n  /// Controls member pointer representation format under the MS ABI.\n  LangOptions::PragmaMSPointersToMembersKind\n      MSPointerToMemberRepresentationMethod;\n\n  /// Stack of active SEH __finally scopes.  Can be empty.\n  SmallVector<Scope*, 2> CurrentSEHFinally;\n\n  /// Source location for newly created implicit MSInheritanceAttrs\n  SourceLocation ImplicitMSInheritanceAttrLoc;\n\n  /// Holds TypoExprs that are created from `createDelayedTypo`. This is used by\n  /// `TransformTypos` in order to keep track of any TypoExprs that are created\n  /// recursively during typo correction and wipe them away if the correction\n  /// fails.\n  llvm::SmallVector<TypoExpr *, 2> TypoExprs;\n\n  /// pragma clang section kind\n  enum PragmaClangSectionKind {\n    PCSK_Invalid      = 0,\n    PCSK_BSS          = 1,\n    PCSK_Data         = 2,\n    PCSK_Rodata       = 3,\n    PCSK_Text         = 4,\n    PCSK_Relro        = 5\n   };\n\n  enum PragmaClangSectionAction {\n    PCSA_Set     = 0,\n    PCSA_Clear   = 1\n  };\n\n  struct PragmaClangSection {\n    std::string SectionName;\n    bool Valid = false;\n    SourceLocation PragmaLocation;\n  };\n\n   PragmaClangSection PragmaClangBSSSection;\n   PragmaClangSection PragmaClangDataSection;\n   PragmaClangSection PragmaClangRodataSection;\n   PragmaClangSection PragmaClangRelroSection;\n   PragmaClangSection PragmaClangTextSection;\n\n  enum PragmaMsStackAction {\n    PSK_Reset     = 0x0,                // #pragma ()\n    PSK_Set       = 0x1,                // #pragma (value)\n    PSK_Push      = 0x2,                // #pragma (push[, id])\n    PSK_Pop       = 0x4,                // #pragma (pop[, id])\n    PSK_Show      = 0x8,                // #pragma (show) -- only for \"pack\"!\n    PSK_Push_Set  = PSK_Push | PSK_Set, // #pragma (push[, id], value)\n    PSK_Pop_Set   = PSK_Pop | PSK_Set,  // #pragma (pop[, id], value)\n  };\n\n  // #pragma pack and align.\n  class AlignPackInfo {\n  public:\n    // `Native` represents default align mode, which may vary based on the\n    // platform.\n    enum Mode : unsigned char { Native, Natural, Packed, Mac68k };\n\n    // #pragma pack info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, unsigned Num, bool IsXL)\n        : PackAttr(true), AlignMode(M), PackNumber(Num), XLStack(IsXL) {\n      assert(Num == PackNumber && \"The pack number has been truncated.\");\n    }\n\n    // #pragma align info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, bool IsXL)\n        : PackAttr(false), AlignMode(M),\n          PackNumber(M == Packed ? 1 : UninitPackVal), XLStack(IsXL) {}\n\n    explicit AlignPackInfo(bool IsXL) : AlignPackInfo(Native, IsXL) {}\n\n    AlignPackInfo() : AlignPackInfo(Native, false) {}\n\n    // When a AlignPackInfo itself cannot be used, this returns an 32-bit\n    // integer encoding for it. This should only be passed to\n    // AlignPackInfo::getFromRawEncoding, it should not be inspected directly.\n    static uint32_t getRawEncoding(const AlignPackInfo &Info) {\n      std::uint32_t Encoding{};\n      if (Info.IsXLStack())\n        Encoding |= IsXLMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getAlignMode()) << 1;\n\n      if (Info.IsPackAttr())\n        Encoding |= PackAttrMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getPackNumber()) << 4;\n\n      return Encoding;\n    }\n\n    static AlignPackInfo getFromRawEncoding(unsigned Encoding) {\n      bool IsXL = static_cast<bool>(Encoding & IsXLMask);\n      AlignPackInfo::Mode M =\n          static_cast<AlignPackInfo::Mode>((Encoding & AlignModeMask) >> 1);\n      int PackNumber = (Encoding & PackNumMask) >> 4;\n\n      if (Encoding & PackAttrMask)\n        return AlignPackInfo(M, PackNumber, IsXL);\n\n      return AlignPackInfo(M, IsXL);\n    }\n\n    bool IsPackAttr() const { return PackAttr; }\n\n    bool IsAlignAttr() const { return !PackAttr; }\n\n    Mode getAlignMode() const { return AlignMode; }\n\n    unsigned getPackNumber() const { return PackNumber; }\n\n    bool IsPackSet() const {\n      // #pragma align, #pragma pack(), and #pragma pack(0) do not set the pack\n      // attriute on a decl.\n      return PackNumber != UninitPackVal && PackNumber != 0;\n    }\n\n    bool IsXLStack() const { return XLStack; }\n\n    bool operator==(const AlignPackInfo &Info) const {\n      return std::tie(AlignMode, PackNumber, PackAttr, XLStack) ==\n             std::tie(Info.AlignMode, Info.PackNumber, Info.PackAttr,\n                      Info.XLStack);\n    }\n\n    bool operator!=(const AlignPackInfo &Info) const {\n      return !(*this == Info);\n    }\n\n  private:\n    /// \\brief True if this is a pragma pack attribute,\n    ///         not a pragma align attribute.\n    bool PackAttr;\n\n    /// \\brief The alignment mode that is in effect.\n    Mode AlignMode;\n\n    /// \\brief The pack number of the stack.\n    unsigned char PackNumber;\n\n    /// \\brief True if it is a XL #pragma align/pack stack.\n    bool XLStack;\n\n    /// \\brief Uninitialized pack value.\n    static constexpr unsigned char UninitPackVal = -1;\n\n    // Masks to encode and decode an AlignPackInfo.\n    static constexpr uint32_t IsXLMask{0x0000'0001};\n    static constexpr uint32_t AlignModeMask{0x0000'0006};\n    static constexpr uint32_t PackAttrMask{0x00000'0008};\n    static constexpr uint32_t PackNumMask{0x0000'01F0};\n  };\n\n  template<typename ValueType>\n  struct PragmaStack {\n    struct Slot {\n      llvm::StringRef StackSlotLabel;\n      ValueType Value;\n      SourceLocation PragmaLocation;\n      SourceLocation PragmaPushLocation;\n      Slot(llvm::StringRef StackSlotLabel, ValueType Value,\n           SourceLocation PragmaLocation, SourceLocation PragmaPushLocation)\n          : StackSlotLabel(StackSlotLabel), Value(Value),\n            PragmaLocation(PragmaLocation),\n            PragmaPushLocation(PragmaPushLocation) {}\n    };\n\n    void Act(SourceLocation PragmaLocation, PragmaMsStackAction Action,\n             llvm::StringRef StackSlotLabel, ValueType Value) {\n      if (Action == PSK_Reset) {\n        CurrentValue = DefaultValue;\n        CurrentPragmaLocation = PragmaLocation;\n        return;\n      }\n      if (Action & PSK_Push)\n        Stack.emplace_back(StackSlotLabel, CurrentValue, CurrentPragmaLocation,\n                           PragmaLocation);\n      else if (Action & PSK_Pop) {\n        if (!StackSlotLabel.empty()) {\n          // If we've got a label, try to find it and jump there.\n          auto I = llvm::find_if(llvm::reverse(Stack), [&](const Slot &x) {\n            return x.StackSlotLabel == StackSlotLabel;\n          });\n          // If we found the label so pop from there.\n          if (I != Stack.rend()) {\n            CurrentValue = I->Value;\n            CurrentPragmaLocation = I->PragmaLocation;\n            Stack.erase(std::prev(I.base()), Stack.end());\n          }\n        } else if (!Stack.empty()) {\n          // We do not have a label, just pop the last entry.\n          CurrentValue = Stack.back().Value;\n          CurrentPragmaLocation = Stack.back().PragmaLocation;\n          Stack.pop_back();\n        }\n      }\n      if (Action & PSK_Set) {\n        CurrentValue = Value;\n        CurrentPragmaLocation = PragmaLocation;\n      }\n    }\n\n    // MSVC seems to add artificial slots to #pragma stacks on entering a C++\n    // method body to restore the stacks on exit, so it works like this:\n    //\n    //   struct S {\n    //     #pragma <name>(push, InternalPragmaSlot, <current_pragma_value>)\n    //     void Method {}\n    //     #pragma <name>(pop, InternalPragmaSlot)\n    //   };\n    //\n    // It works even with #pragma vtordisp, although MSVC doesn't support\n    //   #pragma vtordisp(push [, id], n)\n    // syntax.\n    //\n    // Push / pop a named sentinel slot.\n    void SentinelAction(PragmaMsStackAction Action, StringRef Label) {\n      assert((Action == PSK_Push || Action == PSK_Pop) &&\n             \"Can only push / pop #pragma stack sentinels!\");\n      Act(CurrentPragmaLocation, Action, Label, CurrentValue);\n    }\n\n    // Constructors.\n    explicit PragmaStack(const ValueType &Default)\n        : DefaultValue(Default), CurrentValue(Default) {}\n\n    bool hasValue() const { return CurrentValue != DefaultValue; }\n\n    SmallVector<Slot, 2> Stack;\n    ValueType DefaultValue; // Value used for PSK_Reset action.\n    ValueType CurrentValue;\n    SourceLocation CurrentPragmaLocation;\n  };\n  // FIXME: We should serialize / deserialize these if they occur in a PCH (but\n  // we shouldn't do so if they're in a module).\n\n  /// Whether to insert vtordisps prior to virtual bases in the Microsoft\n  /// C++ ABI.  Possible values are 0, 1, and 2, which mean:\n  ///\n  /// 0: Suppress all vtordisps\n  /// 1: Insert vtordisps in the presence of vbase overrides and non-trivial\n  ///    structors\n  /// 2: Always insert vtordisps to support RTTI on partially constructed\n  ///    objects\n  PragmaStack<MSVtorDispMode> VtorDispStack;\n  PragmaStack<AlignPackInfo> AlignPackStack;\n  // The current #pragma align/pack values and locations at each #include.\n  struct AlignPackIncludeState {\n    AlignPackInfo CurrentValue;\n    SourceLocation CurrentPragmaLocation;\n    bool HasNonDefaultValue, ShouldWarnOnInclude;\n  };\n  SmallVector<AlignPackIncludeState, 8> AlignPackIncludeStack;\n  // Segment #pragmas.\n  PragmaStack<StringLiteral *> DataSegStack;\n  PragmaStack<StringLiteral *> BSSSegStack;\n  PragmaStack<StringLiteral *> ConstSegStack;\n  PragmaStack<StringLiteral *> CodeSegStack;\n\n  // This stack tracks the current state of Sema.CurFPFeatures.\n  PragmaStack<FPOptionsOverride> FpPragmaStack;\n  FPOptionsOverride CurFPFeatureOverrides() {\n    FPOptionsOverride result;\n    if (!FpPragmaStack.hasValue()) {\n      result = FPOptionsOverride();\n    } else {\n      result = FpPragmaStack.CurrentValue;\n    }\n    return result;\n  }\n\n  // RAII object to push / pop sentinel slots for all MS #pragma stacks.\n  // Actions should be performed only if we enter / exit a C++ method body.\n  class PragmaStackSentinelRAII {\n  public:\n    PragmaStackSentinelRAII(Sema &S, StringRef SlotLabel, bool ShouldAct);\n    ~PragmaStackSentinelRAII();\n\n  private:\n    Sema &S;\n    StringRef SlotLabel;\n    bool ShouldAct;\n  };\n\n  /// A mapping that describes the nullability we've seen in each header file.\n  FileNullabilityMap NullabilityMap;\n\n  /// Last section used with #pragma init_seg.\n  StringLiteral *CurInitSeg;\n  SourceLocation CurInitSegLoc;\n\n  /// VisContext - Manages the stack for \\#pragma GCC visibility.\n  void *VisContext; // Really a \"PragmaVisStack*\"\n\n  /// This an attribute introduced by \\#pragma clang attribute.\n  struct PragmaAttributeEntry {\n    SourceLocation Loc;\n    ParsedAttr *Attribute;\n    SmallVector<attr::SubjectMatchRule, 4> MatchRules;\n    bool IsUsed;\n  };\n\n  /// A push'd group of PragmaAttributeEntries.\n  struct PragmaAttributeGroup {\n    /// The location of the push attribute.\n    SourceLocation Loc;\n    /// The namespace of this push group.\n    const IdentifierInfo *Namespace;\n    SmallVector<PragmaAttributeEntry, 2> Entries;\n  };\n\n  SmallVector<PragmaAttributeGroup, 2> PragmaAttributeStack;\n\n  /// The declaration that is currently receiving an attribute from the\n  /// #pragma attribute stack.\n  const Decl *PragmaAttributeCurrentTargetDecl;\n\n  /// This represents the last location of a \"#pragma clang optimize off\"\n  /// directive if such a directive has not been closed by an \"on\" yet. If\n  /// optimizations are currently \"on\", this is set to an invalid location.\n  SourceLocation OptimizeOffPragmaLocation;\n\n  /// Flag indicating if Sema is building a recovery call expression.\n  ///\n  /// This flag is used to avoid building recovery call expressions\n  /// if Sema is already doing so, which would cause infinite recursions.\n  bool IsBuildingRecoveryCallExpr;\n\n  /// Used to control the generation of ExprWithCleanups.\n  CleanupInfo Cleanup;\n\n  /// ExprCleanupObjects - This is the stack of objects requiring\n  /// cleanup that are created by the current full expression.\n  SmallVector<ExprWithCleanups::CleanupObject, 8> ExprCleanupObjects;\n\n  /// Store a set of either DeclRefExprs or MemberExprs that contain a reference\n  /// to a variable (constant) that may or may not be odr-used in this Expr, and\n  /// we won't know until all lvalue-to-rvalue and discarded value conversions\n  /// have been applied to all subexpressions of the enclosing full expression.\n  /// This is cleared at the end of each full expression.\n  using MaybeODRUseExprSet = llvm::SetVector<Expr *, SmallVector<Expr *, 4>,\n                                             llvm::SmallPtrSet<Expr *, 4>>;\n  MaybeODRUseExprSet MaybeODRUseExprs;\n\n  std::unique_ptr<sema::FunctionScopeInfo> CachedFunctionScope;\n\n  /// Stack containing information about each of the nested\n  /// function, block, and method scopes that are currently active.\n  SmallVector<sema::FunctionScopeInfo *, 4> FunctionScopes;\n\n  /// The index of the first FunctionScope that corresponds to the current\n  /// context.\n  unsigned FunctionScopesStart = 0;\n\n  ArrayRef<sema::FunctionScopeInfo*> getFunctionScopes() const {\n    return llvm::makeArrayRef(FunctionScopes.begin() + FunctionScopesStart,\n                              FunctionScopes.end());\n  }\n\n  /// Stack containing information needed when in C++2a an 'auto' is encountered\n  /// in a function declaration parameter type specifier in order to invent a\n  /// corresponding template parameter in the enclosing abbreviated function\n  /// template. This information is also present in LambdaScopeInfo, stored in\n  /// the FunctionScopes stack.\n  SmallVector<InventedTemplateParameterInfo, 4> InventedParameterInfos;\n\n  /// The index of the first InventedParameterInfo that refers to the current\n  /// context.\n  unsigned InventedParameterInfosStart = 0;\n\n  ArrayRef<InventedTemplateParameterInfo> getInventedParameterInfos() const {\n    return llvm::makeArrayRef(InventedParameterInfos.begin() +\n                                  InventedParameterInfosStart,\n                              InventedParameterInfos.end());\n  }\n\n  typedef LazyVector<TypedefNameDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadExtVectorDecls, 2, 2>\n    ExtVectorDeclsType;\n\n  /// ExtVectorDecls - This is a list all the extended vector types. This allows\n  /// us to associate a raw vector type with one of the ext_vector type names.\n  /// This is only necessary for issuing pretty diagnostics.\n  ExtVectorDeclsType ExtVectorDecls;\n\n  /// FieldCollector - Collects CXXFieldDecls during parsing of C++ classes.\n  std::unique_ptr<CXXFieldCollector> FieldCollector;\n\n  typedef llvm::SmallSetVector<NamedDecl *, 16> NamedDeclSetType;\n\n  /// Set containing all declared private fields that are not used.\n  NamedDeclSetType UnusedPrivateFields;\n\n  /// Set containing all typedefs that are likely unused.\n  llvm::SmallSetVector<const TypedefNameDecl *, 4>\n      UnusedLocalTypedefNameCandidates;\n\n  /// Delete-expressions to be analyzed at the end of translation unit\n  ///\n  /// This list contains class members, and locations of delete-expressions\n  /// that could not be proven as to whether they mismatch with new-expression\n  /// used in initializer of the field.\n  typedef std::pair<SourceLocation, bool> DeleteExprLoc;\n  typedef llvm::SmallVector<DeleteExprLoc, 4> DeleteLocs;\n  llvm::MapVector<FieldDecl *, DeleteLocs> DeleteExprs;\n\n  typedef llvm::SmallPtrSet<const CXXRecordDecl*, 8> RecordDeclSetTy;\n\n  /// PureVirtualClassDiagSet - a set of class declarations which we have\n  /// emitted a list of pure virtual functions. Used to prevent emitting the\n  /// same list more than once.\n  std::unique_ptr<RecordDeclSetTy> PureVirtualClassDiagSet;\n\n  /// ParsingInitForAutoVars - a set of declarations with auto types for which\n  /// we are currently parsing the initializer.\n  llvm::SmallPtrSet<const Decl*, 4> ParsingInitForAutoVars;\n\n  /// Look for a locally scoped extern \"C\" declaration by the given name.\n  NamedDecl *findLocallyScopedExternCDecl(DeclarationName Name);\n\n  typedef LazyVector<VarDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadTentativeDefinitions, 2, 2>\n    TentativeDefinitionsType;\n\n  /// All the tentative definitions encountered in the TU.\n  TentativeDefinitionsType TentativeDefinitions;\n\n  /// All the external declarations encoutered and used in the TU.\n  SmallVector<VarDecl *, 4> ExternalDeclarations;\n\n  typedef LazyVector<const DeclaratorDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadUnusedFileScopedDecls, 2, 2>\n    UnusedFileScopedDeclsType;\n\n  /// The set of file scoped decls seen so far that have not been used\n  /// and must warn if not used. Only contains the first declaration.\n  UnusedFileScopedDeclsType UnusedFileScopedDecls;\n\n  typedef LazyVector<CXXConstructorDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadDelegatingConstructors, 2, 2>\n    DelegatingCtorDeclsType;\n\n  /// All the delegating constructors seen so far in the file, used for\n  /// cycle detection at the end of the TU.\n  DelegatingCtorDeclsType DelegatingCtorDecls;\n\n  /// All the overriding functions seen during a class definition\n  /// that had their exception spec checks delayed, plus the overridden\n  /// function.\n  SmallVector<std::pair<const CXXMethodDecl*, const CXXMethodDecl*>, 2>\n    DelayedOverridingExceptionSpecChecks;\n\n  /// All the function redeclarations seen during a class definition that had\n  /// their exception spec checks delayed, plus the prior declaration they\n  /// should be checked against. Except during error recovery, the new decl\n  /// should always be a friend declaration, as that's the only valid way to\n  /// redeclare a special member before its class is complete.\n  SmallVector<std::pair<FunctionDecl*, FunctionDecl*>, 2>\n    DelayedEquivalentExceptionSpecChecks;\n\n  typedef llvm::MapVector<const FunctionDecl *,\n                          std::unique_ptr<LateParsedTemplate>>\n      LateParsedTemplateMapT;\n  LateParsedTemplateMapT LateParsedTemplateMap;\n\n  /// Callback to the parser to parse templated functions when needed.\n  typedef void LateTemplateParserCB(void *P, LateParsedTemplate &LPT);\n  typedef void LateTemplateParserCleanupCB(void *P);\n  LateTemplateParserCB *LateTemplateParser;\n  LateTemplateParserCleanupCB *LateTemplateParserCleanup;\n  void *OpaqueParser;\n\n  void SetLateTemplateParser(LateTemplateParserCB *LTP,\n                             LateTemplateParserCleanupCB *LTPCleanup,\n                             void *P) {\n    LateTemplateParser = LTP;\n    LateTemplateParserCleanup = LTPCleanup;\n    OpaqueParser = P;\n  }\n\n  class DelayedDiagnostics;\n\n  class DelayedDiagnosticsState {\n    sema::DelayedDiagnosticPool *SavedPool;\n    friend class Sema::DelayedDiagnostics;\n  };\n  typedef DelayedDiagnosticsState ParsingDeclState;\n  typedef DelayedDiagnosticsState ProcessingContextState;\n\n  /// A class which encapsulates the logic for delaying diagnostics\n  /// during parsing and other processing.\n  class DelayedDiagnostics {\n    /// The current pool of diagnostics into which delayed\n    /// diagnostics should go.\n    sema::DelayedDiagnosticPool *CurPool;\n\n  public:\n    DelayedDiagnostics() : CurPool(nullptr) {}\n\n    /// Adds a delayed diagnostic.\n    void add(const sema::DelayedDiagnostic &diag); // in DelayedDiagnostic.h\n\n    /// Determines whether diagnostics should be delayed.\n    bool shouldDelayDiagnostics() { return CurPool != nullptr; }\n\n    /// Returns the current delayed-diagnostics pool.\n    sema::DelayedDiagnosticPool *getCurrentPool() const {\n      return CurPool;\n    }\n\n    /// Enter a new scope.  Access and deprecation diagnostics will be\n    /// collected in this pool.\n    DelayedDiagnosticsState push(sema::DelayedDiagnosticPool &pool) {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = &pool;\n      return state;\n    }\n\n    /// Leave a delayed-diagnostic state that was previously pushed.\n    /// Do not emit any of the diagnostics.  This is performed as part\n    /// of the bookkeeping of popping a pool \"properly\".\n    void popWithoutEmitting(DelayedDiagnosticsState state) {\n      CurPool = state.SavedPool;\n    }\n\n    /// Enter a new scope where access and deprecation diagnostics are\n    /// not delayed.\n    DelayedDiagnosticsState pushUndelayed() {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = nullptr;\n      return state;\n    }\n\n    /// Undo a previous pushUndelayed().\n    void popUndelayed(DelayedDiagnosticsState state) {\n      assert(CurPool == nullptr);\n      CurPool = state.SavedPool;\n    }\n  } DelayedDiagnostics;\n\n  /// A RAII object to temporarily push a declaration context.\n  class ContextRAII {\n  private:\n    Sema &S;\n    DeclContext *SavedContext;\n    ProcessingContextState SavedContextState;\n    QualType SavedCXXThisTypeOverride;\n    unsigned SavedFunctionScopesStart;\n    unsigned SavedInventedParameterInfosStart;\n\n  public:\n    ContextRAII(Sema &S, DeclContext *ContextToPush, bool NewThisContext = true)\n      : S(S), SavedContext(S.CurContext),\n        SavedContextState(S.DelayedDiagnostics.pushUndelayed()),\n        SavedCXXThisTypeOverride(S.CXXThisTypeOverride),\n        SavedFunctionScopesStart(S.FunctionScopesStart),\n        SavedInventedParameterInfosStart(S.InventedParameterInfosStart)\n    {\n      assert(ContextToPush && \"pushing null context\");\n      S.CurContext = ContextToPush;\n      if (NewThisContext)\n        S.CXXThisTypeOverride = QualType();\n      // Any saved FunctionScopes do not refer to this context.\n      S.FunctionScopesStart = S.FunctionScopes.size();\n      S.InventedParameterInfosStart = S.InventedParameterInfos.size();\n    }\n\n    void pop() {\n      if (!SavedContext) return;\n      S.CurContext = SavedContext;\n      S.DelayedDiagnostics.popUndelayed(SavedContextState);\n      S.CXXThisTypeOverride = SavedCXXThisTypeOverride;\n      S.FunctionScopesStart = SavedFunctionScopesStart;\n      S.InventedParameterInfosStart = SavedInventedParameterInfosStart;\n      SavedContext = nullptr;\n    }\n\n    ~ContextRAII() {\n      pop();\n    }\n  };\n\n  /// Whether the AST is currently being rebuilt to correct immediate\n  /// invocations. Immediate invocation candidates and references to consteval\n  /// functions aren't tracked when this is set.\n  bool RebuildingImmediateInvocation = false;\n\n  /// Used to change context to isConstantEvaluated without pushing a heavy\n  /// ExpressionEvaluationContextRecord object.\n  bool isConstantEvaluatedOverride;\n\n  bool isConstantEvaluated() {\n    return ExprEvalContexts.back().isConstantEvaluated() ||\n           isConstantEvaluatedOverride;\n  }\n\n  /// RAII object to handle the state changes required to synthesize\n  /// a function body.\n  class SynthesizedFunctionScope {\n    Sema &S;\n    Sema::ContextRAII SavedContext;\n    bool PushedCodeSynthesisContext = false;\n\n  public:\n    SynthesizedFunctionScope(Sema &S, DeclContext *DC)\n        : S(S), SavedContext(S, DC) {\n      S.PushFunctionScope();\n      S.PushExpressionEvaluationContext(\n          Sema::ExpressionEvaluationContext::PotentiallyEvaluated);\n      if (auto *FD = dyn_cast<FunctionDecl>(DC))\n        FD->setWillHaveBody(true);\n      else\n        assert(isa<ObjCMethodDecl>(DC));\n    }\n\n    void addContextNote(SourceLocation UseLoc) {\n      assert(!PushedCodeSynthesisContext);\n\n      Sema::CodeSynthesisContext Ctx;\n      Ctx.Kind = Sema::CodeSynthesisContext::DefiningSynthesizedFunction;\n      Ctx.PointOfInstantiation = UseLoc;\n      Ctx.Entity = cast<Decl>(S.CurContext);\n      S.pushCodeSynthesisContext(Ctx);\n\n      PushedCodeSynthesisContext = true;\n    }\n\n    ~SynthesizedFunctionScope() {\n      if (PushedCodeSynthesisContext)\n        S.popCodeSynthesisContext();\n      if (auto *FD = dyn_cast<FunctionDecl>(S.CurContext))\n        FD->setWillHaveBody(false);\n      S.PopExpressionEvaluationContext();\n      S.PopFunctionScopeInfo();\n    }\n  };\n\n  /// WeakUndeclaredIdentifiers - Identifiers contained in\n  /// \\#pragma weak before declared. rare. may alias another\n  /// identifier, declared or undeclared\n  llvm::MapVector<IdentifierInfo *, WeakInfo> WeakUndeclaredIdentifiers;\n\n  /// ExtnameUndeclaredIdentifiers - Identifiers contained in\n  /// \\#pragma redefine_extname before declared.  Used in Solaris system headers\n  /// to define functions that occur in multiple standards to call the version\n  /// in the currently selected standard.\n  llvm::DenseMap<IdentifierInfo*,AsmLabelAttr*> ExtnameUndeclaredIdentifiers;\n\n\n  /// Load weak undeclared identifiers from the external source.\n  void LoadExternalWeakUndeclaredIdentifiers();\n\n  /// WeakTopLevelDecl - Translation-unit scoped declarations generated by\n  /// \\#pragma weak during processing of other Decls.\n  /// I couldn't figure out a clean way to generate these in-line, so\n  /// we store them here and handle separately -- which is a hack.\n  /// It would be best to refactor this.\n  SmallVector<Decl*,2> WeakTopLevelDecl;\n\n  IdentifierResolver IdResolver;\n\n  /// Translation Unit Scope - useful to Objective-C actions that need\n  /// to lookup file scope declarations in the \"ordinary\" C decl namespace.\n  /// For example, user-defined classes, built-in \"id\" type, etc.\n  Scope *TUScope;\n\n  /// The C++ \"std\" namespace, where the standard library resides.\n  LazyDeclPtr StdNamespace;\n\n  /// The C++ \"std::bad_alloc\" class, which is defined by the C++\n  /// standard library.\n  LazyDeclPtr StdBadAlloc;\n\n  /// The C++ \"std::align_val_t\" enum class, which is defined by the C++\n  /// standard library.\n  LazyDeclPtr StdAlignValT;\n\n  /// The C++ \"std::experimental\" namespace, where the experimental parts\n  /// of the standard library resides.\n  NamespaceDecl *StdExperimentalNamespaceCache;\n\n  /// The C++ \"std::initializer_list\" template, which is defined in\n  /// \\<initializer_list>.\n  ClassTemplateDecl *StdInitializerList;\n\n  /// The C++ \"std::coroutine_traits\" template, which is defined in\n  /// \\<coroutine_traits>\n  ClassTemplateDecl *StdCoroutineTraitsCache;\n\n  /// The C++ \"type_info\" declaration, which is defined in \\<typeinfo>.\n  RecordDecl *CXXTypeInfoDecl;\n\n  /// The MSVC \"_GUID\" struct, which is defined in MSVC header files.\n  RecordDecl *MSVCGuidDecl;\n\n  /// Caches identifiers/selectors for NSFoundation APIs.\n  std::unique_ptr<NSAPI> NSAPIObj;\n\n  /// The declaration of the Objective-C NSNumber class.\n  ObjCInterfaceDecl *NSNumberDecl;\n\n  /// The declaration of the Objective-C NSValue class.\n  ObjCInterfaceDecl *NSValueDecl;\n\n  /// Pointer to NSNumber type (NSNumber *).\n  QualType NSNumberPointer;\n\n  /// Pointer to NSValue type (NSValue *).\n  QualType NSValuePointer;\n\n  /// The Objective-C NSNumber methods used to create NSNumber literals.\n  ObjCMethodDecl *NSNumberLiteralMethods[NSAPI::NumNSNumberLiteralMethods];\n\n  /// The declaration of the Objective-C NSString class.\n  ObjCInterfaceDecl *NSStringDecl;\n\n  /// Pointer to NSString type (NSString *).\n  QualType NSStringPointer;\n\n  /// The declaration of the stringWithUTF8String: method.\n  ObjCMethodDecl *StringWithUTF8StringMethod;\n\n  /// The declaration of the valueWithBytes:objCType: method.\n  ObjCMethodDecl *ValueWithBytesObjCTypeMethod;\n\n  /// The declaration of the Objective-C NSArray class.\n  ObjCInterfaceDecl *NSArrayDecl;\n\n  /// The declaration of the arrayWithObjects:count: method.\n  ObjCMethodDecl *ArrayWithObjectsMethod;\n\n  /// The declaration of the Objective-C NSDictionary class.\n  ObjCInterfaceDecl *NSDictionaryDecl;\n\n  /// The declaration of the dictionaryWithObjects:forKeys:count: method.\n  ObjCMethodDecl *DictionaryWithObjectsMethod;\n\n  /// id<NSCopying> type.\n  QualType QIDNSCopying;\n\n  /// will hold 'respondsToSelector:'\n  Selector RespondsToSelectorSel;\n\n  /// A flag to remember whether the implicit forms of operator new and delete\n  /// have been declared.\n  bool GlobalNewDeleteDeclared;\n\n  /// Describes how the expressions currently being parsed are\n  /// evaluated at run-time, if at all.\n  enum class ExpressionEvaluationContext {\n    /// The current expression and its subexpressions occur within an\n    /// unevaluated operand (C++11 [expr]p7), such as the subexpression of\n    /// \\c sizeof, where the type of the expression may be significant but\n    /// no code will be generated to evaluate the value of the expression at\n    /// run time.\n    Unevaluated,\n\n    /// The current expression occurs within a braced-init-list within\n    /// an unevaluated operand. This is mostly like a regular unevaluated\n    /// context, except that we still instantiate constexpr functions that are\n    /// referenced here so that we can perform narrowing checks correctly.\n    UnevaluatedList,\n\n    /// The current expression occurs within a discarded statement.\n    /// This behaves largely similarly to an unevaluated operand in preventing\n    /// definitions from being required, but not in other ways.\n    DiscardedStatement,\n\n    /// The current expression occurs within an unevaluated\n    /// operand that unconditionally permits abstract references to\n    /// fields, such as a SIZE operator in MS-style inline assembly.\n    UnevaluatedAbstract,\n\n    /// The current context is \"potentially evaluated\" in C++11 terms,\n    /// but the expression is evaluated at compile-time (like the values of\n    /// cases in a switch statement).\n    ConstantEvaluated,\n\n    /// The current expression is potentially evaluated at run time,\n    /// which means that code may be generated to evaluate the value of the\n    /// expression at run time.\n    PotentiallyEvaluated,\n\n    /// The current expression is potentially evaluated, but any\n    /// declarations referenced inside that expression are only used if\n    /// in fact the current expression is used.\n    ///\n    /// This value is used when parsing default function arguments, for which\n    /// we would like to provide diagnostics (e.g., passing non-POD arguments\n    /// through varargs) but do not want to mark declarations as \"referenced\"\n    /// until the default argument is used.\n    PotentiallyEvaluatedIfUsed\n  };\n\n  using ImmediateInvocationCandidate = llvm::PointerIntPair<ConstantExpr *, 1>;\n\n  /// Data structure used to record current or nested\n  /// expression evaluation contexts.\n  struct ExpressionEvaluationContextRecord {\n    /// The expression evaluation context.\n    ExpressionEvaluationContext Context;\n\n    /// Whether the enclosing context needed a cleanup.\n    CleanupInfo ParentCleanup;\n\n    /// The number of active cleanup objects when we entered\n    /// this expression evaluation context.\n    unsigned NumCleanupObjects;\n\n    /// The number of typos encountered during this expression evaluation\n    /// context (i.e. the number of TypoExprs created).\n    unsigned NumTypos;\n\n    MaybeODRUseExprSet SavedMaybeODRUseExprs;\n\n    /// The lambdas that are present within this context, if it\n    /// is indeed an unevaluated context.\n    SmallVector<LambdaExpr *, 2> Lambdas;\n\n    /// The declaration that provides context for lambda expressions\n    /// and block literals if the normal declaration context does not\n    /// suffice, e.g., in a default function argument.\n    Decl *ManglingContextDecl;\n\n    /// If we are processing a decltype type, a set of call expressions\n    /// for which we have deferred checking the completeness of the return type.\n    SmallVector<CallExpr *, 8> DelayedDecltypeCalls;\n\n    /// If we are processing a decltype type, a set of temporary binding\n    /// expressions for which we have deferred checking the destructor.\n    SmallVector<CXXBindTemporaryExpr *, 8> DelayedDecltypeBinds;\n\n    llvm::SmallPtrSet<const Expr *, 8> PossibleDerefs;\n\n    /// Expressions appearing as the LHS of a volatile assignment in this\n    /// context. We produce a warning for these when popping the context if\n    /// they are not discarded-value expressions nor unevaluated operands.\n    SmallVector<Expr*, 2> VolatileAssignmentLHSs;\n\n    /// Set of candidates for starting an immediate invocation.\n    llvm::SmallVector<ImmediateInvocationCandidate, 4> ImmediateInvocationCandidates;\n\n    /// Set of DeclRefExprs referencing a consteval function when used in a\n    /// context not already known to be immediately invoked.\n    llvm::SmallPtrSet<DeclRefExpr *, 4> ReferenceToConsteval;\n\n    /// \\brief Describes whether we are in an expression constext which we have\n    /// to handle differently.\n    enum ExpressionKind {\n      EK_Decltype, EK_TemplateArgument, EK_Other\n    } ExprContext;\n\n    ExpressionEvaluationContextRecord(ExpressionEvaluationContext Context,\n                                      unsigned NumCleanupObjects,\n                                      CleanupInfo ParentCleanup,\n                                      Decl *ManglingContextDecl,\n                                      ExpressionKind ExprContext)\n        : Context(Context), ParentCleanup(ParentCleanup),\n          NumCleanupObjects(NumCleanupObjects), NumTypos(0),\n          ManglingContextDecl(ManglingContextDecl), ExprContext(ExprContext) {}\n\n    bool isUnevaluated() const {\n      return Context == ExpressionEvaluationContext::Unevaluated ||\n             Context == ExpressionEvaluationContext::UnevaluatedAbstract ||\n             Context == ExpressionEvaluationContext::UnevaluatedList;\n    }\n    bool isConstantEvaluated() const {\n      return Context == ExpressionEvaluationContext::ConstantEvaluated;\n    }\n  };\n\n  /// A stack of expression evaluation contexts.\n  SmallVector<ExpressionEvaluationContextRecord, 8> ExprEvalContexts;\n\n  /// Emit a warning for all pending noderef expressions that we recorded.\n  void WarnOnPendingNoDerefs(ExpressionEvaluationContextRecord &Rec);\n\n  /// Compute the mangling number context for a lambda expression or\n  /// block literal. Also return the extra mangling decl if any.\n  ///\n  /// \\param DC - The DeclContext containing the lambda expression or\n  /// block literal.\n  std::tuple<MangleNumberingContext *, Decl *>\n  getCurrentMangleNumberContext(const DeclContext *DC);\n\n\n  /// SpecialMemberOverloadResult - The overloading result for a special member\n  /// function.\n  ///\n  /// This is basically a wrapper around PointerIntPair. The lowest bits of the\n  /// integer are used to determine whether overload resolution succeeded.\n  class SpecialMemberOverloadResult {\n  public:\n    enum Kind {\n      NoMemberOrDeleted,\n      Ambiguous,\n      Success\n    };\n\n  private:\n    llvm::PointerIntPair<CXXMethodDecl*, 2> Pair;\n\n  public:\n    SpecialMemberOverloadResult() : Pair() {}\n    SpecialMemberOverloadResult(CXXMethodDecl *MD)\n        : Pair(MD, MD->isDeleted() ? NoMemberOrDeleted : Success) {}\n\n    CXXMethodDecl *getMethod() const { return Pair.getPointer(); }\n    void setMethod(CXXMethodDecl *MD) { Pair.setPointer(MD); }\n\n    Kind getKind() const { return static_cast<Kind>(Pair.getInt()); }\n    void setKind(Kind K) { Pair.setInt(K); }\n  };\n\n  class SpecialMemberOverloadResultEntry\n      : public llvm::FastFoldingSetNode,\n        public SpecialMemberOverloadResult {\n  public:\n    SpecialMemberOverloadResultEntry(const llvm::FoldingSetNodeID &ID)\n      : FastFoldingSetNode(ID)\n    {}\n  };\n\n  /// A cache of special member function overload resolution results\n  /// for C++ records.\n  llvm::FoldingSet<SpecialMemberOverloadResultEntry> SpecialMemberCache;\n\n  /// A cache of the flags available in enumerations with the flag_bits\n  /// attribute.\n  mutable llvm::DenseMap<const EnumDecl*, llvm::APInt> FlagBitsCache;\n\n  /// The kind of translation unit we are processing.\n  ///\n  /// When we're processing a complete translation unit, Sema will perform\n  /// end-of-translation-unit semantic tasks (such as creating\n  /// initializers for tentative definitions in C) once parsing has\n  /// completed. Modules and precompiled headers perform different kinds of\n  /// checks.\n  TranslationUnitKind TUKind;\n\n  llvm::BumpPtrAllocator BumpAlloc;\n\n  /// The number of SFINAE diagnostics that have been trapped.\n  unsigned NumSFINAEErrors;\n\n  typedef llvm::DenseMap<ParmVarDecl *, llvm::TinyPtrVector<ParmVarDecl *>>\n    UnparsedDefaultArgInstantiationsMap;\n\n  /// A mapping from parameters with unparsed default arguments to the\n  /// set of instantiations of each parameter.\n  ///\n  /// This mapping is a temporary data structure used when parsing\n  /// nested class templates or nested classes of class templates,\n  /// where we might end up instantiating an inner class before the\n  /// default arguments of its methods have been parsed.\n  UnparsedDefaultArgInstantiationsMap UnparsedDefaultArgInstantiations;\n\n  // Contains the locations of the beginning of unparsed default\n  // argument locations.\n  llvm::DenseMap<ParmVarDecl *, SourceLocation> UnparsedDefaultArgLocs;\n\n  /// UndefinedInternals - all the used, undefined objects which require a\n  /// definition in this translation unit.\n  llvm::MapVector<NamedDecl *, SourceLocation> UndefinedButUsed;\n\n  /// Determine if VD, which must be a variable or function, is an external\n  /// symbol that nonetheless can't be referenced from outside this translation\n  /// unit because its type has no linkage and it's not extern \"C\".\n  bool isExternalWithNoLinkageType(ValueDecl *VD);\n\n  /// Obtain a sorted list of functions that are undefined but ODR-used.\n  void getUndefinedButUsed(\n      SmallVectorImpl<std::pair<NamedDecl *, SourceLocation> > &Undefined);\n\n  /// Retrieves list of suspicious delete-expressions that will be checked at\n  /// the end of translation unit.\n  const llvm::MapVector<FieldDecl *, DeleteLocs> &\n  getMismatchingDeleteExpressions() const;\n\n  typedef std::pair<ObjCMethodList, ObjCMethodList> GlobalMethods;\n  typedef llvm::DenseMap<Selector, GlobalMethods> GlobalMethodPool;\n\n  /// Method Pool - allows efficient lookup when typechecking messages to \"id\".\n  /// We need to maintain a list, since selectors can have differing signatures\n  /// across classes. In Cocoa, this happens to be extremely uncommon (only 1%\n  /// of selectors are \"overloaded\").\n  /// At the head of the list it is recorded whether there were 0, 1, or >= 2\n  /// methods inside categories with a particular selector.\n  GlobalMethodPool MethodPool;\n\n  /// Method selectors used in a \\@selector expression. Used for implementation\n  /// of -Wselector.\n  llvm::MapVector<Selector, SourceLocation> ReferencedSelectors;\n\n  /// List of SourceLocations where 'self' is implicitly retained inside a\n  /// block.\n  llvm::SmallVector<std::pair<SourceLocation, const BlockDecl *>, 1>\n      ImplicitlyRetainedSelfLocs;\n\n  /// Kinds of C++ special members.\n  enum CXXSpecialMember {\n    CXXDefaultConstructor,\n    CXXCopyConstructor,\n    CXXMoveConstructor,\n    CXXCopyAssignment,\n    CXXMoveAssignment,\n    CXXDestructor,\n    CXXInvalid\n  };\n\n  typedef llvm::PointerIntPair<CXXRecordDecl *, 3, CXXSpecialMember>\n      SpecialMemberDecl;\n\n  /// The C++ special members which we are currently in the process of\n  /// declaring. If this process recursively triggers the declaration of the\n  /// same special member, we should act as if it is not yet declared.\n  llvm::SmallPtrSet<SpecialMemberDecl, 4> SpecialMembersBeingDeclared;\n\n  /// Kinds of defaulted comparison operator functions.\n  enum class DefaultedComparisonKind : unsigned char {\n    /// This is not a defaultable comparison operator.\n    None,\n    /// This is an operator== that should be implemented as a series of\n    /// subobject comparisons.\n    Equal,\n    /// This is an operator<=> that should be implemented as a series of\n    /// subobject comparisons.\n    ThreeWay,\n    /// This is an operator!= that should be implemented as a rewrite in terms\n    /// of a == comparison.\n    NotEqual,\n    /// This is an <, <=, >, or >= that should be implemented as a rewrite in\n    /// terms of a <=> comparison.\n    Relational,\n  };\n\n  /// The function definitions which were renamed as part of typo-correction\n  /// to match their respective declarations. We want to keep track of them\n  /// to ensure that we don't emit a \"redefinition\" error if we encounter a\n  /// correctly named definition after the renamed definition.\n  llvm::SmallPtrSet<const NamedDecl *, 4> TypoCorrectedFunctionDefinitions;\n\n  /// Stack of types that correspond to the parameter entities that are\n  /// currently being copy-initialized. Can be empty.\n  llvm::SmallVector<QualType, 4> CurrentParameterCopyTypes;\n\n  void ReadMethodPool(Selector Sel);\n  void updateOutOfDateSelector(Selector Sel);\n\n  /// Private Helper predicate to check for 'self'.\n  bool isSelfExpr(Expr *RExpr);\n  bool isSelfExpr(Expr *RExpr, const ObjCMethodDecl *Method);\n\n  /// Cause the active diagnostic on the DiagosticsEngine to be\n  /// emitted. This is closely coupled to the SemaDiagnosticBuilder class and\n  /// should not be used elsewhere.\n  void EmitCurrentDiagnostic(unsigned DiagID);\n\n  /// Records and restores the CurFPFeatures state on entry/exit of compound\n  /// statements.\n  class FPFeaturesStateRAII {\n  public:\n    FPFeaturesStateRAII(Sema &S) : S(S), OldFPFeaturesState(S.CurFPFeatures) {\n      OldOverrides = S.FpPragmaStack.CurrentValue;\n    }\n    ~FPFeaturesStateRAII() {\n      S.CurFPFeatures = OldFPFeaturesState;\n      S.FpPragmaStack.CurrentValue = OldOverrides;\n    }\n    FPOptionsOverride getOverrides() { return OldOverrides; }\n\n  private:\n    Sema& S;\n    FPOptions OldFPFeaturesState;\n    FPOptionsOverride OldOverrides;\n  };\n\n  void addImplicitTypedef(StringRef Name, QualType T);\n\n  bool WarnedStackExhausted = false;\n\npublic:\n  Sema(Preprocessor &pp, ASTContext &ctxt, ASTConsumer &consumer,\n       TranslationUnitKind TUKind = TU_Complete,\n       CodeCompleteConsumer *CompletionConsumer = nullptr);\n  ~Sema();\n\n  /// Perform initialization that occurs after the parser has been\n  /// initialized but before it parses anything.\n  void Initialize();\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  OpenCLOptions &getOpenCLOptions() { return OpenCLFeatures; }\n  FPOptions     &getCurFPFeatures() { return CurFPFeatures; }\n\n  DiagnosticsEngine &getDiagnostics() const { return Diags; }\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  Preprocessor &getPreprocessor() const { return PP; }\n  ASTContext &getASTContext() const { return Context; }\n  ASTConsumer &getASTConsumer() const { return Consumer; }\n  ASTMutationListener *getASTMutationListener() const;\n  ExternalSemaSource* getExternalSource() const { return ExternalSource; }\n\n  ///Registers an external source. If an external source already exists,\n  /// creates a multiplex external source and appends to it.\n  ///\n  ///\\param[in] E - A non-null external sema source.\n  ///\n  void addExternalSource(ExternalSemaSource *E);\n\n  void PrintStats() const;\n\n  /// Warn that the stack is nearly exhausted.\n  void warnStackExhausted(SourceLocation Loc);\n\n  /// Run some code with \"sufficient\" stack space. (Currently, at least 256K is\n  /// guaranteed). Produces a warning if we're low on stack space and allocates\n  /// more in that case. Use this in code that may recurse deeply (for example,\n  /// in template instantiation) to avoid stack overflow.\n  void runWithSufficientStackSpace(SourceLocation Loc,\n                                   llvm::function_ref<void()> Fn);\n\n  /// Helper class that creates diagnostics with optional\n  /// template instantiation stacks.\n  ///\n  /// This class provides a wrapper around the basic DiagnosticBuilder\n  /// class that emits diagnostics. ImmediateDiagBuilder is\n  /// responsible for emitting the diagnostic (as DiagnosticBuilder\n  /// does) and, if the diagnostic comes from inside a template\n  /// instantiation, printing the template instantiation stack as\n  /// well.\n  class ImmediateDiagBuilder : public DiagnosticBuilder {\n    Sema &SemaRef;\n    unsigned DiagID;\n\n  public:\n    ImmediateDiagBuilder(DiagnosticBuilder &DB, Sema &SemaRef, unsigned DiagID)\n        : DiagnosticBuilder(DB), SemaRef(SemaRef), DiagID(DiagID) {}\n    ImmediateDiagBuilder(DiagnosticBuilder &&DB, Sema &SemaRef, unsigned DiagID)\n        : DiagnosticBuilder(DB), SemaRef(SemaRef), DiagID(DiagID) {}\n\n    // This is a cunning lie. DiagnosticBuilder actually performs move\n    // construction in its copy constructor (but due to varied uses, it's not\n    // possible to conveniently express this as actual move construction). So\n    // the default copy ctor here is fine, because the base class disables the\n    // source anyway, so the user-defined ~ImmediateDiagBuilder is a safe no-op\n    // in that case anwyay.\n    ImmediateDiagBuilder(const ImmediateDiagBuilder &) = default;\n\n    ~ImmediateDiagBuilder() {\n      // If we aren't active, there is nothing to do.\n      if (!isActive()) return;\n\n      // Otherwise, we need to emit the diagnostic. First clear the diagnostic\n      // builder itself so it won't emit the diagnostic in its own destructor.\n      //\n      // This seems wasteful, in that as written the DiagnosticBuilder dtor will\n      // do its own needless checks to see if the diagnostic needs to be\n      // emitted. However, because we take care to ensure that the builder\n      // objects never escape, a sufficiently smart compiler will be able to\n      // eliminate that code.\n      Clear();\n\n      // Dispatch to Sema to emit the diagnostic.\n      SemaRef.EmitCurrentDiagnostic(DiagID);\n    }\n\n    /// Teach operator<< to produce an object of the correct type.\n    template <typename T>\n    friend const ImmediateDiagBuilder &\n    operator<<(const ImmediateDiagBuilder &Diag, const T &Value) {\n      const DiagnosticBuilder &BaseDiag = Diag;\n      BaseDiag << Value;\n      return Diag;\n    }\n\n    // It is necessary to limit this to rvalue reference to avoid calling this\n    // function with a bitfield lvalue argument since non-const reference to\n    // bitfield is not allowed.\n    template <typename T, typename = typename std::enable_if<\n                              !std::is_lvalue_reference<T>::value>::type>\n    const ImmediateDiagBuilder &operator<<(T &&V) const {\n      const DiagnosticBuilder &BaseDiag = *this;\n      BaseDiag << std::move(V);\n      return *this;\n    }\n  };\n\n  /// A generic diagnostic builder for errors which may or may not be deferred.\n  ///\n  /// In CUDA, there exist constructs (e.g. variable-length arrays, try/catch)\n  /// which are not allowed to appear inside __device__ functions and are\n  /// allowed to appear in __host__ __device__ functions only if the host+device\n  /// function is never codegen'ed.\n  ///\n  /// To handle this, we use the notion of \"deferred diagnostics\", where we\n  /// attach a diagnostic to a FunctionDecl that's emitted iff it's codegen'ed.\n  ///\n  /// This class lets you emit either a regular diagnostic, a deferred\n  /// diagnostic, or no diagnostic at all, according to an argument you pass to\n  /// its constructor, thus simplifying the process of creating these \"maybe\n  /// deferred\" diagnostics.\n  class SemaDiagnosticBuilder {\n  public:\n    enum Kind {\n      /// Emit no diagnostics.\n      K_Nop,\n      /// Emit the diagnostic immediately (i.e., behave like Sema::Diag()).\n      K_Immediate,\n      /// Emit the diagnostic immediately, and, if it's a warning or error, also\n      /// emit a call stack showing how this function can be reached by an a\n      /// priori known-emitted function.\n      K_ImmediateWithCallStack,\n      /// Create a deferred diagnostic, which is emitted only if the function\n      /// it's attached to is codegen'ed.  Also emit a call stack as with\n      /// K_ImmediateWithCallStack.\n      K_Deferred\n    };\n\n    SemaDiagnosticBuilder(Kind K, SourceLocation Loc, unsigned DiagID,\n                          FunctionDecl *Fn, Sema &S);\n    SemaDiagnosticBuilder(SemaDiagnosticBuilder &&D);\n    SemaDiagnosticBuilder(const SemaDiagnosticBuilder &) = default;\n    ~SemaDiagnosticBuilder();\n\n    bool isImmediate() const { return ImmediateDiag.hasValue(); }\n\n    /// Convertible to bool: True if we immediately emitted an error, false if\n    /// we didn't emit an error or we created a deferred error.\n    ///\n    /// Example usage:\n    ///\n    ///   if (SemaDiagnosticBuilder(...) << foo << bar)\n    ///     return ExprError();\n    ///\n    /// But see CUDADiagIfDeviceCode() and CUDADiagIfHostCode() -- you probably\n    /// want to use these instead of creating a SemaDiagnosticBuilder yourself.\n    operator bool() const { return isImmediate(); }\n\n    template <typename T>\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const T &Value) {\n      if (Diag.ImmediateDiag.hasValue())\n        *Diag.ImmediateDiag << Value;\n      else if (Diag.PartialDiagId.hasValue())\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second\n            << Value;\n      return Diag;\n    }\n\n    // It is necessary to limit this to rvalue reference to avoid calling this\n    // function with a bitfield lvalue argument since non-const reference to\n    // bitfield is not allowed.\n    template <typename T, typename = typename std::enable_if<\n                              !std::is_lvalue_reference<T>::value>::type>\n    const SemaDiagnosticBuilder &operator<<(T &&V) const {\n      if (ImmediateDiag.hasValue())\n        *ImmediateDiag << std::move(V);\n      else if (PartialDiagId.hasValue())\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second << std::move(V);\n      return *this;\n    }\n\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const PartialDiagnostic &PD) {\n      if (Diag.ImmediateDiag.hasValue())\n        PD.Emit(*Diag.ImmediateDiag);\n      else if (Diag.PartialDiagId.hasValue())\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second = PD;\n      return Diag;\n    }\n\n    void AddFixItHint(const FixItHint &Hint) const {\n      if (ImmediateDiag.hasValue())\n        ImmediateDiag->AddFixItHint(Hint);\n      else if (PartialDiagId.hasValue())\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second.AddFixItHint(Hint);\n    }\n\n    friend ExprResult ExprError(const SemaDiagnosticBuilder &) {\n      return ExprError();\n    }\n    friend StmtResult StmtError(const SemaDiagnosticBuilder &) {\n      return StmtError();\n    }\n    operator ExprResult() const { return ExprError(); }\n    operator StmtResult() const { return StmtError(); }\n    operator TypeResult() const { return TypeError(); }\n    operator DeclResult() const { return DeclResult(true); }\n    operator MemInitResult() const { return MemInitResult(true); }\n\n  private:\n    Sema &S;\n    SourceLocation Loc;\n    unsigned DiagID;\n    FunctionDecl *Fn;\n    bool ShowCallStack;\n\n    // Invariant: At most one of these Optionals has a value.\n    // FIXME: Switch these to a Variant once that exists.\n    llvm::Optional<ImmediateDiagBuilder> ImmediateDiag;\n    llvm::Optional<unsigned> PartialDiagId;\n  };\n\n  /// Is the last error level diagnostic immediate. This is used to determined\n  /// whether the next info diagnostic should be immediate.\n  bool IsLastErrorImmediate = true;\n\n  /// Emit a diagnostic.\n  SemaDiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID,\n                             bool DeferHint = false);\n\n  /// Emit a partial diagnostic.\n  SemaDiagnosticBuilder Diag(SourceLocation Loc, const PartialDiagnostic &PD,\n                             bool DeferHint = false);\n\n  /// Build a partial diagnostic.\n  PartialDiagnostic PDiag(unsigned DiagID = 0); // in SemaInternal.h\n\n  /// Whether uncompilable error has occurred. This includes error happens\n  /// in deferred diagnostics.\n  bool hasUncompilableErrorOccurred() const;\n\n  bool findMacroSpelling(SourceLocation &loc, StringRef name);\n\n  /// Get a string to suggest for zero-initialization of a type.\n  std::string\n  getFixItZeroInitializerForType(QualType T, SourceLocation Loc) const;\n  std::string getFixItZeroLiteralForType(QualType T, SourceLocation Loc) const;\n\n  /// Calls \\c Lexer::getLocForEndOfToken()\n  SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset = 0);\n\n  /// Retrieve the module loader associated with the preprocessor.\n  ModuleLoader &getModuleLoader() const;\n\n  /// Invent a new identifier for parameters of abbreviated templates.\n  IdentifierInfo *\n  InventAbbreviatedTemplateParameterTypeName(IdentifierInfo *ParamName,\n                                             unsigned Index);\n\n  void emitAndClearUnusedLocalTypedefWarnings();\n\n  private:\n    /// Function or variable declarations to be checked for whether the deferred\n    /// diagnostics should be emitted.\n    SmallVector<Decl *, 4> DeclsToCheckForDeferredDiags;\n\n  public:\n  // Emit all deferred diagnostics.\n  void emitDeferredDiags();\n\n  enum TUFragmentKind {\n    /// The global module fragment, between 'module;' and a module-declaration.\n    Global,\n    /// A normal translation unit fragment. For a non-module unit, this is the\n    /// entire translation unit. Otherwise, it runs from the module-declaration\n    /// to the private-module-fragment (if any) or the end of the TU (if not).\n    Normal,\n    /// The private module fragment, between 'module :private;' and the end of\n    /// the translation unit.\n    Private\n  };\n\n  void ActOnStartOfTranslationUnit();\n  void ActOnEndOfTranslationUnit();\n  void ActOnEndOfTranslationUnitFragment(TUFragmentKind Kind);\n\n  void CheckDelegatingCtorCycles();\n\n  Scope *getScopeForContext(DeclContext *Ctx);\n\n  void PushFunctionScope();\n  void PushBlockScope(Scope *BlockScope, BlockDecl *Block);\n  sema::LambdaScopeInfo *PushLambdaScope();\n\n  /// This is used to inform Sema what the current TemplateParameterDepth\n  /// is during Parsing.  Currently it is used to pass on the depth\n  /// when parsing generic lambda 'auto' parameters.\n  void RecordParsingTemplateParameterDepth(unsigned Depth);\n\n  void PushCapturedRegionScope(Scope *RegionScope, CapturedDecl *CD,\n                               RecordDecl *RD, CapturedRegionKind K,\n                               unsigned OpenMPCaptureLevel = 0);\n\n  /// Custom deleter to allow FunctionScopeInfos to be kept alive for a short\n  /// time after they've been popped.\n  class PoppedFunctionScopeDeleter {\n    Sema *Self;\n\n  public:\n    explicit PoppedFunctionScopeDeleter(Sema *Self) : Self(Self) {}\n    void operator()(sema::FunctionScopeInfo *Scope) const;\n  };\n\n  using PoppedFunctionScopePtr =\n      std::unique_ptr<sema::FunctionScopeInfo, PoppedFunctionScopeDeleter>;\n\n  PoppedFunctionScopePtr\n  PopFunctionScopeInfo(const sema::AnalysisBasedWarnings::Policy *WP = nullptr,\n                       const Decl *D = nullptr,\n                       QualType BlockType = QualType());\n\n  sema::FunctionScopeInfo *getCurFunction() const {\n    return FunctionScopes.empty() ? nullptr : FunctionScopes.back();\n  }\n\n  sema::FunctionScopeInfo *getEnclosingFunction() const;\n\n  void setFunctionHasBranchIntoScope();\n  void setFunctionHasBranchProtectedScope();\n  void setFunctionHasIndirectGoto();\n\n  void PushCompoundScope(bool IsStmtExpr);\n  void PopCompoundScope();\n\n  sema::CompoundScopeInfo &getCurCompoundScope() const;\n\n  bool hasAnyUnrecoverableErrorsInThisFunction() const;\n\n  /// Retrieve the current block, if any.\n  sema::BlockScopeInfo *getCurBlock();\n\n  /// Get the innermost lambda enclosing the current location, if any. This\n  /// looks through intervening non-lambda scopes such as local functions and\n  /// blocks.\n  sema::LambdaScopeInfo *getEnclosingLambda() const;\n\n  /// Retrieve the current lambda scope info, if any.\n  /// \\param IgnoreNonLambdaCapturingScope true if should find the top-most\n  /// lambda scope info ignoring all inner capturing scopes that are not\n  /// lambda scopes.\n  sema::LambdaScopeInfo *\n  getCurLambda(bool IgnoreNonLambdaCapturingScope = false);\n\n  /// Retrieve the current generic lambda info, if any.\n  sema::LambdaScopeInfo *getCurGenericLambda();\n\n  /// Retrieve the current captured region, if any.\n  sema::CapturedRegionScopeInfo *getCurCapturedRegion();\n\n  /// WeakTopLevelDeclDecls - access to \\#pragma weak-generated Decls\n  SmallVectorImpl<Decl *> &WeakTopLevelDecls() { return WeakTopLevelDecl; }\n\n  /// Called before parsing a function declarator belonging to a function\n  /// declaration.\n  void ActOnStartFunctionDeclarationDeclarator(Declarator &D,\n                                               unsigned TemplateParameterDepth);\n\n  /// Called after parsing a function declarator belonging to a function\n  /// declaration.\n  void ActOnFinishFunctionDeclarationDeclarator(Declarator &D);\n\n  void ActOnComment(SourceRange Comment);\n\n  //===--------------------------------------------------------------------===//\n  // Type Analysis / Processing: SemaType.cpp.\n  //\n\n  QualType BuildQualifiedType(QualType T, SourceLocation Loc, Qualifiers Qs,\n                              const DeclSpec *DS = nullptr);\n  QualType BuildQualifiedType(QualType T, SourceLocation Loc, unsigned CVRA,\n                              const DeclSpec *DS = nullptr);\n  QualType BuildPointerType(QualType T,\n                            SourceLocation Loc, DeclarationName Entity);\n  QualType BuildReferenceType(QualType T, bool LValueRef,\n                              SourceLocation Loc, DeclarationName Entity);\n  QualType BuildArrayType(QualType T, ArrayType::ArraySizeModifier ASM,\n                          Expr *ArraySize, unsigned Quals,\n                          SourceRange Brackets, DeclarationName Entity);\n  QualType BuildVectorType(QualType T, Expr *VecSize, SourceLocation AttrLoc);\n  QualType BuildExtVectorType(QualType T, Expr *ArraySize,\n                              SourceLocation AttrLoc);\n  QualType BuildMatrixType(QualType T, Expr *NumRows, Expr *NumColumns,\n                           SourceLocation AttrLoc);\n\n  QualType BuildAddressSpaceAttr(QualType &T, LangAS ASIdx, Expr *AddrSpace,\n                                 SourceLocation AttrLoc);\n\n  /// Same as above, but constructs the AddressSpace index if not provided.\n  QualType BuildAddressSpaceAttr(QualType &T, Expr *AddrSpace,\n                                 SourceLocation AttrLoc);\n\n  bool CheckQualifiedFunctionForTypeId(QualType T, SourceLocation Loc);\n\n  bool CheckFunctionReturnType(QualType T, SourceLocation Loc);\n\n  /// Build a function type.\n  ///\n  /// This routine checks the function type according to C++ rules and\n  /// under the assumption that the result type and parameter types have\n  /// just been instantiated from a template. It therefore duplicates\n  /// some of the behavior of GetTypeForDeclarator, but in a much\n  /// simpler form that is only suitable for this narrow use case.\n  ///\n  /// \\param T The return type of the function.\n  ///\n  /// \\param ParamTypes The parameter types of the function. This array\n  /// will be modified to account for adjustments to the types of the\n  /// function parameters.\n  ///\n  /// \\param Loc The location of the entity whose type involves this\n  /// function type or, if there is no such entity, the location of the\n  /// type that will have function type.\n  ///\n  /// \\param Entity The name of the entity that involves the function\n  /// type, if known.\n  ///\n  /// \\param EPI Extra information about the function type. Usually this will\n  /// be taken from an existing function with the same prototype.\n  ///\n  /// \\returns A suitable function type, if there are no errors. The\n  /// unqualified type will always be a FunctionProtoType.\n  /// Otherwise, returns a NULL type.\n  QualType BuildFunctionType(QualType T,\n                             MutableArrayRef<QualType> ParamTypes,\n                             SourceLocation Loc, DeclarationName Entity,\n                             const FunctionProtoType::ExtProtoInfo &EPI);\n\n  QualType BuildMemberPointerType(QualType T, QualType Class,\n                                  SourceLocation Loc,\n                                  DeclarationName Entity);\n  QualType BuildBlockPointerType(QualType T,\n                                 SourceLocation Loc, DeclarationName Entity);\n  QualType BuildParenType(QualType T);\n  QualType BuildAtomicType(QualType T, SourceLocation Loc);\n  QualType BuildReadPipeType(QualType T,\n                         SourceLocation Loc);\n  QualType BuildWritePipeType(QualType T,\n                         SourceLocation Loc);\n  QualType BuildExtIntType(bool IsUnsigned, Expr *BitWidth, SourceLocation Loc);\n\n  TypeSourceInfo *GetTypeForDeclarator(Declarator &D, Scope *S);\n  TypeSourceInfo *GetTypeForDeclaratorCast(Declarator &D, QualType FromTy);\n\n  /// Package the given type and TSI into a ParsedType.\n  ParsedType CreateParsedType(QualType T, TypeSourceInfo *TInfo);\n  DeclarationNameInfo GetNameForDeclarator(Declarator &D);\n  DeclarationNameInfo GetNameFromUnqualifiedId(const UnqualifiedId &Name);\n  static QualType GetTypeFromParser(ParsedType Ty,\n                                    TypeSourceInfo **TInfo = nullptr);\n  CanThrowResult canThrow(const Stmt *E);\n  /// Determine whether the callee of a particular function call can throw.\n  /// E, D and Loc are all optional.\n  static CanThrowResult canCalleeThrow(Sema &S, const Expr *E, const Decl *D,\n                                       SourceLocation Loc = SourceLocation());\n  const FunctionProtoType *ResolveExceptionSpec(SourceLocation Loc,\n                                                const FunctionProtoType *FPT);\n  void UpdateExceptionSpec(FunctionDecl *FD,\n                           const FunctionProtoType::ExceptionSpecInfo &ESI);\n  bool CheckSpecifiedExceptionType(QualType &T, SourceRange Range);\n  bool CheckDistantExceptionSpec(QualType T);\n  bool CheckEquivalentExceptionSpec(FunctionDecl *Old, FunctionDecl *New);\n  bool CheckEquivalentExceptionSpec(\n      const FunctionProtoType *Old, SourceLocation OldLoc,\n      const FunctionProtoType *New, SourceLocation NewLoc);\n  bool CheckEquivalentExceptionSpec(\n      const PartialDiagnostic &DiagID, const PartialDiagnostic & NoteID,\n      const FunctionProtoType *Old, SourceLocation OldLoc,\n      const FunctionProtoType *New, SourceLocation NewLoc);\n  bool handlerCanCatch(QualType HandlerType, QualType ExceptionType);\n  bool CheckExceptionSpecSubset(const PartialDiagnostic &DiagID,\n                                const PartialDiagnostic &NestedDiagID,\n                                const PartialDiagnostic &NoteID,\n                                const PartialDiagnostic &NoThrowDiagID,\n                                const FunctionProtoType *Superset,\n                                SourceLocation SuperLoc,\n                                const FunctionProtoType *Subset,\n                                SourceLocation SubLoc);\n  bool CheckParamExceptionSpec(const PartialDiagnostic &NestedDiagID,\n                               const PartialDiagnostic &NoteID,\n                               const FunctionProtoType *Target,\n                               SourceLocation TargetLoc,\n                               const FunctionProtoType *Source,\n                               SourceLocation SourceLoc);\n\n  TypeResult ActOnTypeName(Scope *S, Declarator &D);\n\n  /// The parser has parsed the context-sensitive type 'instancetype'\n  /// in an Objective-C message declaration. Return the appropriate type.\n  ParsedType ActOnObjCInstanceType(SourceLocation Loc);\n\n  /// Abstract class used to diagnose incomplete types.\n  struct TypeDiagnoser {\n    TypeDiagnoser() {}\n\n    virtual void diagnose(Sema &S, SourceLocation Loc, QualType T) = 0;\n    virtual ~TypeDiagnoser() {}\n  };\n\n  static int getPrintable(int I) { return I; }\n  static unsigned getPrintable(unsigned I) { return I; }\n  static bool getPrintable(bool B) { return B; }\n  static const char * getPrintable(const char *S) { return S; }\n  static StringRef getPrintable(StringRef S) { return S; }\n  static const std::string &getPrintable(const std::string &S) { return S; }\n  static const IdentifierInfo *getPrintable(const IdentifierInfo *II) {\n    return II;\n  }\n  static DeclarationName getPrintable(DeclarationName N) { return N; }\n  static QualType getPrintable(QualType T) { return T; }\n  static SourceRange getPrintable(SourceRange R) { return R; }\n  static SourceRange getPrintable(SourceLocation L) { return L; }\n  static SourceRange getPrintable(const Expr *E) { return E->getSourceRange(); }\n  static SourceRange getPrintable(TypeLoc TL) { return TL.getSourceRange();}\n\n  template <typename... Ts> class BoundTypeDiagnoser : public TypeDiagnoser {\n  protected:\n    unsigned DiagID;\n    std::tuple<const Ts &...> Args;\n\n    template <std::size_t... Is>\n    void emit(const SemaDiagnosticBuilder &DB,\n              std::index_sequence<Is...>) const {\n      // Apply all tuple elements to the builder in order.\n      bool Dummy[] = {false, (DB << getPrintable(std::get<Is>(Args)))...};\n      (void)Dummy;\n    }\n\n  public:\n    BoundTypeDiagnoser(unsigned DiagID, const Ts &...Args)\n        : TypeDiagnoser(), DiagID(DiagID), Args(Args...) {\n      assert(DiagID != 0 && \"no diagnostic for type diagnoser\");\n    }\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      const SemaDiagnosticBuilder &DB = S.Diag(Loc, DiagID);\n      emit(DB, std::index_sequence_for<Ts...>());\n      DB << T;\n    }\n  };\n\n  /// Do a check to make sure \\p Name looks like a legal argument for the\n  /// swift_name attribute applied to decl \\p D.  Raise a diagnostic if the name\n  /// is invalid for the given declaration.\n  ///\n  /// \\p AL is used to provide caret diagnostics in case of a malformed name.\n  ///\n  /// \\returns true if the name is a valid swift name for \\p D, false otherwise.\n  bool DiagnoseSwiftName(Decl *D, StringRef Name, SourceLocation Loc,\n                         const ParsedAttr &AL, bool IsAsync);\n\n  /// A derivative of BoundTypeDiagnoser for which the diagnostic's type\n  /// parameter is preceded by a 0/1 enum that is 1 if the type is sizeless.\n  /// For example, a diagnostic with no other parameters would generally have\n  /// the form \"...%select{incomplete|sizeless}0 type %1...\".\n  template <typename... Ts>\n  class SizelessTypeDiagnoser : public BoundTypeDiagnoser<Ts...> {\n  public:\n    SizelessTypeDiagnoser(unsigned DiagID, const Ts &... Args)\n        : BoundTypeDiagnoser<Ts...>(DiagID, Args...) {}\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      const SemaDiagnosticBuilder &DB = S.Diag(Loc, this->DiagID);\n      this->emit(DB, std::index_sequence_for<Ts...>());\n      DB << T->isSizelessType() << T;\n    }\n  };\n\n  enum class CompleteTypeKind {\n    /// Apply the normal rules for complete types.  In particular,\n    /// treat all sizeless types as incomplete.\n    Normal,\n\n    /// Relax the normal rules for complete types so that they include\n    /// sizeless built-in types.\n    AcceptSizeless,\n\n    // FIXME: Eventually we should flip the default to Normal and opt in\n    // to AcceptSizeless rather than opt out of it.\n    Default = AcceptSizeless\n  };\n\nprivate:\n  /// Methods for marking which expressions involve dereferencing a pointer\n  /// marked with the 'noderef' attribute. Expressions are checked bottom up as\n  /// they are parsed, meaning that a noderef pointer may not be accessed. For\n  /// example, in `&*p` where `p` is a noderef pointer, we will first parse the\n  /// `*p`, but need to check that `address of` is called on it. This requires\n  /// keeping a container of all pending expressions and checking if the address\n  /// of them are eventually taken.\n  void CheckSubscriptAccessOfNoDeref(const ArraySubscriptExpr *E);\n  void CheckAddressOfNoDeref(const Expr *E);\n  void CheckMemberAccessOfNoDeref(const MemberExpr *E);\n\n  bool RequireCompleteTypeImpl(SourceLocation Loc, QualType T,\n                               CompleteTypeKind Kind, TypeDiagnoser *Diagnoser);\n\n  struct ModuleScope {\n    SourceLocation BeginLoc;\n    clang::Module *Module = nullptr;\n    bool ModuleInterface = false;\n    bool ImplicitGlobalModuleFragment = false;\n    VisibleModuleSet OuterVisibleModules;\n  };\n  /// The modules we're currently parsing.\n  llvm::SmallVector<ModuleScope, 16> ModuleScopes;\n\n  /// Namespace definitions that we will export when they finish.\n  llvm::SmallPtrSet<const NamespaceDecl*, 8> DeferredExportedNamespaces;\n\n  /// Get the module whose scope we are currently within.\n  Module *getCurrentModule() const {\n    return ModuleScopes.empty() ? nullptr : ModuleScopes.back().Module;\n  }\n\n  VisibleModuleSet VisibleModules;\n\npublic:\n  /// Get the module owning an entity.\n  Module *getOwningModule(const Decl *Entity) {\n    return Entity->getOwningModule();\n  }\n\n  /// Make a merged definition of an existing hidden definition \\p ND\n  /// visible at the specified location.\n  void makeMergedDefinitionVisible(NamedDecl *ND);\n\n  bool isModuleVisible(const Module *M, bool ModulePrivate = false);\n\n  // When loading a non-modular PCH files, this is used to restore module\n  // visibility.\n  void makeModuleVisible(Module *Mod, SourceLocation ImportLoc) {\n    VisibleModules.setVisible(Mod, ImportLoc);\n  }\n\n  /// Determine whether a declaration is visible to name lookup.\n  bool isVisible(const NamedDecl *D) {\n    return D->isUnconditionallyVisible() || isVisibleSlow(D);\n  }\n\n  /// Determine whether any declaration of an entity is visible.\n  bool\n  hasVisibleDeclaration(const NamedDecl *D,\n                        llvm::SmallVectorImpl<Module *> *Modules = nullptr) {\n    return isVisible(D) || hasVisibleDeclarationSlow(D, Modules);\n  }\n  bool hasVisibleDeclarationSlow(const NamedDecl *D,\n                                 llvm::SmallVectorImpl<Module *> *Modules);\n\n  bool hasVisibleMergedDefinition(NamedDecl *Def);\n  bool hasMergedDefinitionInCurrentModule(NamedDecl *Def);\n\n  /// Determine if \\p D and \\p Suggested have a structurally compatible\n  /// layout as described in C11 6.2.7/1.\n  bool hasStructuralCompatLayout(Decl *D, Decl *Suggested);\n\n  /// Determine if \\p D has a visible definition. If not, suggest a declaration\n  /// that should be made visible to expose the definition.\n  bool hasVisibleDefinition(NamedDecl *D, NamedDecl **Suggested,\n                            bool OnlyNeedComplete = false);\n  bool hasVisibleDefinition(const NamedDecl *D) {\n    NamedDecl *Hidden;\n    return hasVisibleDefinition(const_cast<NamedDecl*>(D), &Hidden);\n  }\n\n  /// Determine if the template parameter \\p D has a visible default argument.\n  bool\n  hasVisibleDefaultArgument(const NamedDecl *D,\n                            llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if there is a visible declaration of \\p D that is an explicit\n  /// specialization declaration for a specialization of a template. (For a\n  /// member specialization, use hasVisibleMemberSpecialization.)\n  bool hasVisibleExplicitSpecialization(\n      const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if there is a visible declaration of \\p D that is a member\n  /// specialization declaration (as opposed to an instantiated declaration).\n  bool hasVisibleMemberSpecialization(\n      const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if \\p A and \\p B are equivalent internal linkage declarations\n  /// from different modules, and thus an ambiguity error can be downgraded to\n  /// an extension warning.\n  bool isEquivalentInternalLinkageDeclaration(const NamedDecl *A,\n                                              const NamedDecl *B);\n  void diagnoseEquivalentInternalLinkageDeclarations(\n      SourceLocation Loc, const NamedDecl *D,\n      ArrayRef<const NamedDecl *> Equiv);\n\n  bool isUsualDeallocationFunction(const CXXMethodDecl *FD);\n\n  bool isCompleteType(SourceLocation Loc, QualType T,\n                      CompleteTypeKind Kind = CompleteTypeKind::Default) {\n    return !RequireCompleteTypeImpl(Loc, T, Kind, nullptr);\n  }\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           CompleteTypeKind Kind, TypeDiagnoser &Diagnoser);\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           CompleteTypeKind Kind, unsigned DiagID);\n\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           TypeDiagnoser &Diagnoser) {\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Default, Diagnoser);\n  }\n  bool RequireCompleteType(SourceLocation Loc, QualType T, unsigned DiagID) {\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Default, DiagID);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteType(SourceLocation Loc, QualType T, unsigned DiagID,\n                           const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteType(Loc, T, Diagnoser);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteSizedType(SourceLocation Loc, QualType T, unsigned DiagID,\n                                const Ts &... Args) {\n    SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Normal, Diagnoser);\n  }\n\n  /// Get the type of expression E, triggering instantiation to complete the\n  /// type if necessary -- that is, if the expression refers to a templated\n  /// static data member of incomplete array type.\n  ///\n  /// May still return an incomplete type if instantiation was not possible or\n  /// if the type is incomplete for a different reason. Use\n  /// RequireCompleteExprType instead if a diagnostic is expected for an\n  /// incomplete expression type.\n  QualType getCompletedType(Expr *E);\n\n  void completeExprArrayBound(Expr *E);\n  bool RequireCompleteExprType(Expr *E, CompleteTypeKind Kind,\n                               TypeDiagnoser &Diagnoser);\n  bool RequireCompleteExprType(Expr *E, unsigned DiagID);\n\n  template <typename... Ts>\n  bool RequireCompleteExprType(Expr *E, unsigned DiagID, const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteExprType(E, CompleteTypeKind::Default, Diagnoser);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteSizedExprType(Expr *E, unsigned DiagID,\n                                    const Ts &... Args) {\n    SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteExprType(E, CompleteTypeKind::Normal, Diagnoser);\n  }\n\n  bool RequireLiteralType(SourceLocation Loc, QualType T,\n                          TypeDiagnoser &Diagnoser);\n  bool RequireLiteralType(SourceLocation Loc, QualType T, unsigned DiagID);\n\n  template <typename... Ts>\n  bool RequireLiteralType(SourceLocation Loc, QualType T, unsigned DiagID,\n                          const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireLiteralType(Loc, T, Diagnoser);\n  }\n\n  QualType getElaboratedType(ElaboratedTypeKeyword Keyword,\n                             const CXXScopeSpec &SS, QualType T,\n                             TagDecl *OwnedTagDecl = nullptr);\n\n  QualType BuildTypeofExprType(Expr *E, SourceLocation Loc);\n  /// If AsUnevaluated is false, E is treated as though it were an evaluated\n  /// context, such as when building a type for decltype(auto).\n  QualType BuildDecltypeType(Expr *E, SourceLocation Loc,\n                             bool AsUnevaluated = true);\n  QualType BuildUnaryTransformType(QualType BaseType,\n                                   UnaryTransformType::UTTKind UKind,\n                                   SourceLocation Loc);\n\n  //===--------------------------------------------------------------------===//\n  // Symbol table / Decl tracking callbacks: SemaDecl.cpp.\n  //\n\n  struct SkipBodyInfo {\n    SkipBodyInfo()\n        : ShouldSkip(false), CheckSameAsPrevious(false), Previous(nullptr),\n          New(nullptr) {}\n    bool ShouldSkip;\n    bool CheckSameAsPrevious;\n    NamedDecl *Previous;\n    NamedDecl *New;\n  };\n\n  DeclGroupPtrTy ConvertDeclToDeclGroup(Decl *Ptr, Decl *OwnedType = nullptr);\n\n  void DiagnoseUseOfUnimplementedSelectors();\n\n  bool isSimpleTypeSpecifier(tok::TokenKind Kind) const;\n\n  ParsedType getTypeName(const IdentifierInfo &II, SourceLocation NameLoc,\n                         Scope *S, CXXScopeSpec *SS = nullptr,\n                         bool isClassName = false, bool HasTrailingDot = false,\n                         ParsedType ObjectType = nullptr,\n                         bool IsCtorOrDtorName = false,\n                         bool WantNontrivialTypeSourceInfo = false,\n                         bool IsClassTemplateDeductionContext = true,\n                         IdentifierInfo **CorrectedII = nullptr);\n  TypeSpecifierType isTagName(IdentifierInfo &II, Scope *S);\n  bool isMicrosoftMissingTypename(const CXXScopeSpec *SS, Scope *S);\n  void DiagnoseUnknownTypeName(IdentifierInfo *&II,\n                               SourceLocation IILoc,\n                               Scope *S,\n                               CXXScopeSpec *SS,\n                               ParsedType &SuggestedType,\n                               bool IsTemplateName = false);\n\n  /// Attempt to behave like MSVC in situations where lookup of an unqualified\n  /// type name has failed in a dependent context. In these situations, we\n  /// automatically form a DependentTypeName that will retry lookup in a related\n  /// scope during instantiation.\n  ParsedType ActOnMSVCUnknownTypeName(const IdentifierInfo &II,\n                                      SourceLocation NameLoc,\n                                      bool IsTemplateTypeArg);\n\n  /// Describes the result of the name lookup and resolution performed\n  /// by \\c ClassifyName().\n  enum NameClassificationKind {\n    /// This name is not a type or template in this context, but might be\n    /// something else.\n    NC_Unknown,\n    /// Classification failed; an error has been produced.\n    NC_Error,\n    /// The name has been typo-corrected to a keyword.\n    NC_Keyword,\n    /// The name was classified as a type.\n    NC_Type,\n    /// The name was classified as a specific non-type, non-template\n    /// declaration. ActOnNameClassifiedAsNonType should be called to\n    /// convert the declaration to an expression.\n    NC_NonType,\n    /// The name was classified as an ADL-only function name.\n    /// ActOnNameClassifiedAsUndeclaredNonType should be called to convert the\n    /// result to an expression.\n    NC_UndeclaredNonType,\n    /// The name denotes a member of a dependent type that could not be\n    /// resolved. ActOnNameClassifiedAsDependentNonType should be called to\n    /// convert the result to an expression.\n    NC_DependentNonType,\n    /// The name was classified as an overload set, and an expression\n    /// representing that overload set has been formed.\n    /// ActOnNameClassifiedAsOverloadSet should be called to form a suitable\n    /// expression referencing the overload set.\n    NC_OverloadSet,\n    /// The name was classified as a template whose specializations are types.\n    NC_TypeTemplate,\n    /// The name was classified as a variable template name.\n    NC_VarTemplate,\n    /// The name was classified as a function template name.\n    NC_FunctionTemplate,\n    /// The name was classified as an ADL-only function template name.\n    NC_UndeclaredTemplate,\n    /// The name was classified as a concept name.\n    NC_Concept,\n  };\n\n  class NameClassification {\n    NameClassificationKind Kind;\n    union {\n      ExprResult Expr;\n      NamedDecl *NonTypeDecl;\n      TemplateName Template;\n      ParsedType Type;\n    };\n\n    explicit NameClassification(NameClassificationKind Kind) : Kind(Kind) {}\n\n  public:\n    NameClassification(ParsedType Type) : Kind(NC_Type), Type(Type) {}\n\n    NameClassification(const IdentifierInfo *Keyword) : Kind(NC_Keyword) {}\n\n    static NameClassification Error() {\n      return NameClassification(NC_Error);\n    }\n\n    static NameClassification Unknown() {\n      return NameClassification(NC_Unknown);\n    }\n\n    static NameClassification OverloadSet(ExprResult E) {\n      NameClassification Result(NC_OverloadSet);\n      Result.Expr = E;\n      return Result;\n    }\n\n    static NameClassification NonType(NamedDecl *D) {\n      NameClassification Result(NC_NonType);\n      Result.NonTypeDecl = D;\n      return Result;\n    }\n\n    static NameClassification UndeclaredNonType() {\n      return NameClassification(NC_UndeclaredNonType);\n    }\n\n    static NameClassification DependentNonType() {\n      return NameClassification(NC_DependentNonType);\n    }\n\n    static NameClassification TypeTemplate(TemplateName Name) {\n      NameClassification Result(NC_TypeTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification VarTemplate(TemplateName Name) {\n      NameClassification Result(NC_VarTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification FunctionTemplate(TemplateName Name) {\n      NameClassification Result(NC_FunctionTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification Concept(TemplateName Name) {\n      NameClassification Result(NC_Concept);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification UndeclaredTemplate(TemplateName Name) {\n      NameClassification Result(NC_UndeclaredTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    NameClassificationKind getKind() const { return Kind; }\n\n    ExprResult getExpression() const {\n      assert(Kind == NC_OverloadSet);\n      return Expr;\n    }\n\n    ParsedType getType() const {\n      assert(Kind == NC_Type);\n      return Type;\n    }\n\n    NamedDecl *getNonTypeDecl() const {\n      assert(Kind == NC_NonType);\n      return NonTypeDecl;\n    }\n\n    TemplateName getTemplateName() const {\n      assert(Kind == NC_TypeTemplate || Kind == NC_FunctionTemplate ||\n             Kind == NC_VarTemplate || Kind == NC_Concept ||\n             Kind == NC_UndeclaredTemplate);\n      return Template;\n    }\n\n    TemplateNameKind getTemplateNameKind() const {\n      switch (Kind) {\n      case NC_TypeTemplate:\n        return TNK_Type_template;\n      case NC_FunctionTemplate:\n        return TNK_Function_template;\n      case NC_VarTemplate:\n        return TNK_Var_template;\n      case NC_Concept:\n        return TNK_Concept_template;\n      case NC_UndeclaredTemplate:\n        return TNK_Undeclared_template;\n      default:\n        llvm_unreachable(\"unsupported name classification.\");\n      }\n    }\n  };\n\n  /// Perform name lookup on the given name, classifying it based on\n  /// the results of name lookup and the following token.\n  ///\n  /// This routine is used by the parser to resolve identifiers and help direct\n  /// parsing. When the identifier cannot be found, this routine will attempt\n  /// to correct the typo and classify based on the resulting name.\n  ///\n  /// \\param S The scope in which we're performing name lookup.\n  ///\n  /// \\param SS The nested-name-specifier that precedes the name.\n  ///\n  /// \\param Name The identifier. If typo correction finds an alternative name,\n  /// this pointer parameter will be updated accordingly.\n  ///\n  /// \\param NameLoc The location of the identifier.\n  ///\n  /// \\param NextToken The token following the identifier. Used to help\n  /// disambiguate the name.\n  ///\n  /// \\param CCC The correction callback, if typo correction is desired.\n  NameClassification ClassifyName(Scope *S, CXXScopeSpec &SS,\n                                  IdentifierInfo *&Name, SourceLocation NameLoc,\n                                  const Token &NextToken,\n                                  CorrectionCandidateCallback *CCC = nullptr);\n\n  /// Act on the result of classifying a name as an undeclared (ADL-only)\n  /// non-type declaration.\n  ExprResult ActOnNameClassifiedAsUndeclaredNonType(IdentifierInfo *Name,\n                                                    SourceLocation NameLoc);\n  /// Act on the result of classifying a name as an undeclared member of a\n  /// dependent base class.\n  ExprResult ActOnNameClassifiedAsDependentNonType(const CXXScopeSpec &SS,\n                                                   IdentifierInfo *Name,\n                                                   SourceLocation NameLoc,\n                                                   bool IsAddressOfOperand);\n  /// Act on the result of classifying a name as a specific non-type\n  /// declaration.\n  ExprResult ActOnNameClassifiedAsNonType(Scope *S, const CXXScopeSpec &SS,\n                                          NamedDecl *Found,\n                                          SourceLocation NameLoc,\n                                          const Token &NextToken);\n  /// Act on the result of classifying a name as an overload set.\n  ExprResult ActOnNameClassifiedAsOverloadSet(Scope *S, Expr *OverloadSet);\n\n  /// Describes the detailed kind of a template name. Used in diagnostics.\n  enum class TemplateNameKindForDiagnostics {\n    ClassTemplate,\n    FunctionTemplate,\n    VarTemplate,\n    AliasTemplate,\n    TemplateTemplateParam,\n    Concept,\n    DependentTemplate\n  };\n  TemplateNameKindForDiagnostics\n  getTemplateNameKindForDiagnostics(TemplateName Name);\n\n  /// Determine whether it's plausible that E was intended to be a\n  /// template-name.\n  bool mightBeIntendedToBeTemplateName(ExprResult E, bool &Dependent) {\n    if (!getLangOpts().CPlusPlus || E.isInvalid())\n      return false;\n    Dependent = false;\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E.get()))\n      return !DRE->hasExplicitTemplateArgs();\n    if (auto *ME = dyn_cast<MemberExpr>(E.get()))\n      return !ME->hasExplicitTemplateArgs();\n    Dependent = true;\n    if (auto *DSDRE = dyn_cast<DependentScopeDeclRefExpr>(E.get()))\n      return !DSDRE->hasExplicitTemplateArgs();\n    if (auto *DSME = dyn_cast<CXXDependentScopeMemberExpr>(E.get()))\n      return !DSME->hasExplicitTemplateArgs();\n    // Any additional cases recognized here should also be handled by\n    // diagnoseExprIntendedAsTemplateName.\n    return false;\n  }\n  void diagnoseExprIntendedAsTemplateName(Scope *S, ExprResult TemplateName,\n                                          SourceLocation Less,\n                                          SourceLocation Greater);\n\n  Decl *ActOnDeclarator(Scope *S, Declarator &D);\n\n  NamedDecl *HandleDeclarator(Scope *S, Declarator &D,\n                              MultiTemplateParamsArg TemplateParameterLists);\n  void RegisterLocallyScopedExternCDecl(NamedDecl *ND, Scope *S);\n  bool DiagnoseClassNameShadow(DeclContext *DC, DeclarationNameInfo Info);\n  bool diagnoseQualifiedDeclaration(CXXScopeSpec &SS, DeclContext *DC,\n                                    DeclarationName Name, SourceLocation Loc,\n                                    bool IsTemplateId);\n  void\n  diagnoseIgnoredQualifiers(unsigned DiagID, unsigned Quals,\n                            SourceLocation FallbackLoc,\n                            SourceLocation ConstQualLoc = SourceLocation(),\n                            SourceLocation VolatileQualLoc = SourceLocation(),\n                            SourceLocation RestrictQualLoc = SourceLocation(),\n                            SourceLocation AtomicQualLoc = SourceLocation(),\n                            SourceLocation UnalignedQualLoc = SourceLocation());\n\n  static bool adjustContextForLocalExternDecl(DeclContext *&DC);\n  void DiagnoseFunctionSpecifiers(const DeclSpec &DS);\n  NamedDecl *getShadowedDeclaration(const TypedefNameDecl *D,\n                                    const LookupResult &R);\n  NamedDecl *getShadowedDeclaration(const VarDecl *D, const LookupResult &R);\n  NamedDecl *getShadowedDeclaration(const BindingDecl *D,\n                                    const LookupResult &R);\n  void CheckShadow(NamedDecl *D, NamedDecl *ShadowedDecl,\n                   const LookupResult &R);\n  void CheckShadow(Scope *S, VarDecl *D);\n\n  /// Warn if 'E', which is an expression that is about to be modified, refers\n  /// to a shadowing declaration.\n  void CheckShadowingDeclModification(Expr *E, SourceLocation Loc);\n\n  void DiagnoseShadowingLambdaDecls(const sema::LambdaScopeInfo *LSI);\n\nprivate:\n  /// Map of current shadowing declarations to shadowed declarations. Warn if\n  /// it looks like the user is trying to modify the shadowing declaration.\n  llvm::DenseMap<const NamedDecl *, const NamedDecl *> ShadowingDecls;\n\npublic:\n  void CheckCastAlign(Expr *Op, QualType T, SourceRange TRange);\n  void handleTagNumbering(const TagDecl *Tag, Scope *TagScope);\n  void setTagNameForLinkagePurposes(TagDecl *TagFromDeclSpec,\n                                    TypedefNameDecl *NewTD);\n  void CheckTypedefForVariablyModifiedType(Scope *S, TypedefNameDecl *D);\n  NamedDecl* ActOnTypedefDeclarator(Scope* S, Declarator& D, DeclContext* DC,\n                                    TypeSourceInfo *TInfo,\n                                    LookupResult &Previous);\n  NamedDecl* ActOnTypedefNameDecl(Scope* S, DeclContext* DC, TypedefNameDecl *D,\n                                  LookupResult &Previous, bool &Redeclaration);\n  NamedDecl *ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,\n                                     TypeSourceInfo *TInfo,\n                                     LookupResult &Previous,\n                                     MultiTemplateParamsArg TemplateParamLists,\n                                     bool &AddToScope,\n                                     ArrayRef<BindingDecl *> Bindings = None);\n  NamedDecl *\n  ActOnDecompositionDeclarator(Scope *S, Declarator &D,\n                               MultiTemplateParamsArg TemplateParamLists);\n  // Returns true if the variable declaration is a redeclaration\n  bool CheckVariableDeclaration(VarDecl *NewVD, LookupResult &Previous);\n  void CheckVariableDeclarationType(VarDecl *NewVD);\n  bool DeduceVariableDeclarationType(VarDecl *VDecl, bool DirectInit,\n                                     Expr *Init);\n  void CheckCompleteVariableDeclaration(VarDecl *VD);\n  void CheckCompleteDecompositionDeclaration(DecompositionDecl *DD);\n  void MaybeSuggestAddingStaticToDecl(const FunctionDecl *D);\n\n  NamedDecl* ActOnFunctionDeclarator(Scope* S, Declarator& D, DeclContext* DC,\n                                     TypeSourceInfo *TInfo,\n                                     LookupResult &Previous,\n                                     MultiTemplateParamsArg TemplateParamLists,\n                                     bool &AddToScope);\n  bool AddOverriddenMethods(CXXRecordDecl *DC, CXXMethodDecl *MD);\n\n  enum class CheckConstexprKind {\n    /// Diagnose issues that are non-constant or that are extensions.\n    Diagnose,\n    /// Identify whether this function satisfies the formal rules for constexpr\n    /// functions in the current lanugage mode (with no extensions).\n    CheckValid\n  };\n\n  bool CheckConstexprFunctionDefinition(const FunctionDecl *FD,\n                                        CheckConstexprKind Kind);\n\n  void DiagnoseHiddenVirtualMethods(CXXMethodDecl *MD);\n  void FindHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);\n  void NoteHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);\n  // Returns true if the function declaration is a redeclaration\n  bool CheckFunctionDeclaration(Scope *S,\n                                FunctionDecl *NewFD, LookupResult &Previous,\n                                bool IsMemberSpecialization);\n  bool shouldLinkDependentDeclWithPrevious(Decl *D, Decl *OldDecl);\n  bool canFullyTypeCheckRedeclaration(ValueDecl *NewD, ValueDecl *OldD,\n                                      QualType NewT, QualType OldT);\n  void CheckMain(FunctionDecl *FD, const DeclSpec &D);\n  void CheckMSVCRTEntryPoint(FunctionDecl *FD);\n  Attr *getImplicitCodeSegOrSectionAttrForFunction(const FunctionDecl *FD,\n                                                   bool IsDefinition);\n  void CheckFunctionOrTemplateParamDeclarator(Scope *S, Declarator &D);\n  Decl *ActOnParamDeclarator(Scope *S, Declarator &D);\n  ParmVarDecl *BuildParmVarDeclForTypedef(DeclContext *DC,\n                                          SourceLocation Loc,\n                                          QualType T);\n  ParmVarDecl *CheckParameter(DeclContext *DC, SourceLocation StartLoc,\n                              SourceLocation NameLoc, IdentifierInfo *Name,\n                              QualType T, TypeSourceInfo *TSInfo,\n                              StorageClass SC);\n  void ActOnParamDefaultArgument(Decl *param,\n                                 SourceLocation EqualLoc,\n                                 Expr *defarg);\n  void ActOnParamUnparsedDefaultArgument(Decl *param, SourceLocation EqualLoc,\n                                         SourceLocation ArgLoc);\n  void ActOnParamDefaultArgumentError(Decl *param, SourceLocation EqualLoc);\n  ExprResult ConvertParamDefaultArgument(const ParmVarDecl *Param,\n                                         Expr *DefaultArg,\n                                         SourceLocation EqualLoc);\n  void SetParamDefaultArgument(ParmVarDecl *Param, Expr *DefaultArg,\n                               SourceLocation EqualLoc);\n\n  // Contexts where using non-trivial C union types can be disallowed. This is\n  // passed to err_non_trivial_c_union_in_invalid_context.\n  enum NonTrivialCUnionContext {\n    // Function parameter.\n    NTCUC_FunctionParam,\n    // Function return.\n    NTCUC_FunctionReturn,\n    // Default-initialized object.\n    NTCUC_DefaultInitializedObject,\n    // Variable with automatic storage duration.\n    NTCUC_AutoVar,\n    // Initializer expression that might copy from another object.\n    NTCUC_CopyInit,\n    // Assignment.\n    NTCUC_Assignment,\n    // Compound literal.\n    NTCUC_CompoundLiteral,\n    // Block capture.\n    NTCUC_BlockCapture,\n    // lvalue-to-rvalue conversion of volatile type.\n    NTCUC_LValueToRValueVolatile,\n  };\n\n  /// Emit diagnostics if the initializer or any of its explicit or\n  /// implicitly-generated subexpressions require copying or\n  /// default-initializing a type that is or contains a C union type that is\n  /// non-trivial to copy or default-initialize.\n  void checkNonTrivialCUnionInInitializer(const Expr *Init, SourceLocation Loc);\n\n  // These flags are passed to checkNonTrivialCUnion.\n  enum NonTrivialCUnionKind {\n    NTCUK_Init = 0x1,\n    NTCUK_Destruct = 0x2,\n    NTCUK_Copy = 0x4,\n  };\n\n  /// Emit diagnostics if a non-trivial C union type or a struct that contains\n  /// a non-trivial C union is used in an invalid context.\n  void checkNonTrivialCUnion(QualType QT, SourceLocation Loc,\n                             NonTrivialCUnionContext UseContext,\n                             unsigned NonTrivialKind);\n\n  void AddInitializerToDecl(Decl *dcl, Expr *init, bool DirectInit);\n  void ActOnUninitializedDecl(Decl *dcl);\n  void ActOnInitializerError(Decl *Dcl);\n\n  void ActOnPureSpecifier(Decl *D, SourceLocation PureSpecLoc);\n  void ActOnCXXForRangeDecl(Decl *D);\n  StmtResult ActOnCXXForRangeIdentifier(Scope *S, SourceLocation IdentLoc,\n                                        IdentifierInfo *Ident,\n                                        ParsedAttributes &Attrs,\n                                        SourceLocation AttrEnd);\n  void SetDeclDeleted(Decl *dcl, SourceLocation DelLoc);\n  void SetDeclDefaulted(Decl *dcl, SourceLocation DefaultLoc);\n  void CheckStaticLocalForDllExport(VarDecl *VD);\n  void FinalizeDeclaration(Decl *D);\n  DeclGroupPtrTy FinalizeDeclaratorGroup(Scope *S, const DeclSpec &DS,\n                                         ArrayRef<Decl *> Group);\n  DeclGroupPtrTy BuildDeclaratorGroup(MutableArrayRef<Decl *> Group);\n\n  /// Should be called on all declarations that might have attached\n  /// documentation comments.\n  void ActOnDocumentableDecl(Decl *D);\n  void ActOnDocumentableDecls(ArrayRef<Decl *> Group);\n\n  void ActOnFinishKNRParamDeclarations(Scope *S, Declarator &D,\n                                       SourceLocation LocAfterDecls);\n  void CheckForFunctionRedefinition(\n      FunctionDecl *FD, const FunctionDecl *EffectiveDefinition = nullptr,\n      SkipBodyInfo *SkipBody = nullptr);\n  Decl *ActOnStartOfFunctionDef(Scope *S, Declarator &D,\n                                MultiTemplateParamsArg TemplateParamLists,\n                                SkipBodyInfo *SkipBody = nullptr);\n  Decl *ActOnStartOfFunctionDef(Scope *S, Decl *D,\n                                SkipBodyInfo *SkipBody = nullptr);\n  void ActOnStartTrailingRequiresClause(Scope *S, Declarator &D);\n  ExprResult ActOnFinishTrailingRequiresClause(ExprResult ConstraintExpr);\n  ExprResult ActOnRequiresClause(ExprResult ConstraintExpr);\n  void ActOnStartOfObjCMethodDef(Scope *S, Decl *D);\n  bool isObjCMethodDecl(Decl *D) {\n    return D && isa<ObjCMethodDecl>(D);\n  }\n\n  /// Determine whether we can delay parsing the body of a function or\n  /// function template until it is used, assuming we don't care about emitting\n  /// code for that function.\n  ///\n  /// This will be \\c false if we may need the body of the function in the\n  /// middle of parsing an expression (where it's impractical to switch to\n  /// parsing a different function), for instance, if it's constexpr in C++11\n  /// or has an 'auto' return type in C++14. These cases are essentially bugs.\n  bool canDelayFunctionBody(const Declarator &D);\n\n  /// Determine whether we can skip parsing the body of a function\n  /// definition, assuming we don't care about analyzing its body or emitting\n  /// code for that function.\n  ///\n  /// This will be \\c false only if we may need the body of the function in\n  /// order to parse the rest of the program (for instance, if it is\n  /// \\c constexpr in C++11 or has an 'auto' return type in C++14).\n  bool canSkipFunctionBody(Decl *D);\n\n  void computeNRVO(Stmt *Body, sema::FunctionScopeInfo *Scope);\n  Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body);\n  Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body, bool IsInstantiation);\n  Decl *ActOnSkippedFunctionBody(Decl *Decl);\n  void ActOnFinishInlineFunctionDef(FunctionDecl *D);\n\n  /// ActOnFinishDelayedAttribute - Invoked when we have finished parsing an\n  /// attribute for which parsing is delayed.\n  void ActOnFinishDelayedAttribute(Scope *S, Decl *D, ParsedAttributes &Attrs);\n\n  /// Diagnose any unused parameters in the given sequence of\n  /// ParmVarDecl pointers.\n  void DiagnoseUnusedParameters(ArrayRef<ParmVarDecl *> Parameters);\n\n  /// Diagnose whether the size of parameters or return value of a\n  /// function or obj-c method definition is pass-by-value and larger than a\n  /// specified threshold.\n  void\n  DiagnoseSizeOfParametersAndReturnValue(ArrayRef<ParmVarDecl *> Parameters,\n                                         QualType ReturnTy, NamedDecl *D);\n\n  void DiagnoseInvalidJumps(Stmt *Body);\n  Decl *ActOnFileScopeAsmDecl(Expr *expr,\n                              SourceLocation AsmLoc,\n                              SourceLocation RParenLoc);\n\n  /// Handle a C++11 empty-declaration and attribute-declaration.\n  Decl *ActOnEmptyDeclaration(Scope *S, const ParsedAttributesView &AttrList,\n                              SourceLocation SemiLoc);\n\n  enum class ModuleDeclKind {\n    Interface,      ///< 'export module X;'\n    Implementation, ///< 'module X;'\n  };\n\n  /// The parser has processed a module-declaration that begins the definition\n  /// of a module interface or implementation.\n  DeclGroupPtrTy ActOnModuleDecl(SourceLocation StartLoc,\n                                 SourceLocation ModuleLoc, ModuleDeclKind MDK,\n                                 ModuleIdPath Path, bool IsFirstDecl);\n\n  /// The parser has processed a global-module-fragment declaration that begins\n  /// the definition of the global module fragment of the current module unit.\n  /// \\param ModuleLoc The location of the 'module' keyword.\n  DeclGroupPtrTy ActOnGlobalModuleFragmentDecl(SourceLocation ModuleLoc);\n\n  /// The parser has processed a private-module-fragment declaration that begins\n  /// the definition of the private module fragment of the current module unit.\n  /// \\param ModuleLoc The location of the 'module' keyword.\n  /// \\param PrivateLoc The location of the 'private' keyword.\n  DeclGroupPtrTy ActOnPrivateModuleFragmentDecl(SourceLocation ModuleLoc,\n                                                SourceLocation PrivateLoc);\n\n  /// The parser has processed a module import declaration.\n  ///\n  /// \\param StartLoc The location of the first token in the declaration. This\n  ///        could be the location of an '@', 'export', or 'import'.\n  /// \\param ExportLoc The location of the 'export' keyword, if any.\n  /// \\param ImportLoc The location of the 'import' keyword.\n  /// \\param Path The module access path.\n  DeclResult ActOnModuleImport(SourceLocation StartLoc,\n                               SourceLocation ExportLoc,\n                               SourceLocation ImportLoc, ModuleIdPath Path);\n  DeclResult ActOnModuleImport(SourceLocation StartLoc,\n                               SourceLocation ExportLoc,\n                               SourceLocation ImportLoc, Module *M,\n                               ModuleIdPath Path = {});\n\n  /// The parser has processed a module import translated from a\n  /// #include or similar preprocessing directive.\n  void ActOnModuleInclude(SourceLocation DirectiveLoc, Module *Mod);\n  void BuildModuleInclude(SourceLocation DirectiveLoc, Module *Mod);\n\n  /// The parsed has entered a submodule.\n  void ActOnModuleBegin(SourceLocation DirectiveLoc, Module *Mod);\n  /// The parser has left a submodule.\n  void ActOnModuleEnd(SourceLocation DirectiveLoc, Module *Mod);\n\n  /// Create an implicit import of the given module at the given\n  /// source location, for error recovery, if possible.\n  ///\n  /// This routine is typically used when an entity found by name lookup\n  /// is actually hidden within a module that we know about but the user\n  /// has forgotten to import.\n  void createImplicitModuleImportForErrorRecovery(SourceLocation Loc,\n                                                  Module *Mod);\n\n  /// Kinds of missing import. Note, the values of these enumerators correspond\n  /// to %select values in diagnostics.\n  enum class MissingImportKind {\n    Declaration,\n    Definition,\n    DefaultArgument,\n    ExplicitSpecialization,\n    PartialSpecialization\n  };\n\n  /// Diagnose that the specified declaration needs to be visible but\n  /// isn't, and suggest a module import that would resolve the problem.\n  void diagnoseMissingImport(SourceLocation Loc, NamedDecl *Decl,\n                             MissingImportKind MIK, bool Recover = true);\n  void diagnoseMissingImport(SourceLocation Loc, NamedDecl *Decl,\n                             SourceLocation DeclLoc, ArrayRef<Module *> Modules,\n                             MissingImportKind MIK, bool Recover);\n\n  Decl *ActOnStartExportDecl(Scope *S, SourceLocation ExportLoc,\n                             SourceLocation LBraceLoc);\n  Decl *ActOnFinishExportDecl(Scope *S, Decl *ExportDecl,\n                              SourceLocation RBraceLoc);\n\n  /// We've found a use of a templated declaration that would trigger an\n  /// implicit instantiation. Check that any relevant explicit specializations\n  /// and partial specializations are visible, and diagnose if not.\n  void checkSpecializationVisibility(SourceLocation Loc, NamedDecl *Spec);\n\n  /// Retrieve a suitable printing policy for diagnostics.\n  PrintingPolicy getPrintingPolicy() const {\n    return getPrintingPolicy(Context, PP);\n  }\n\n  /// Retrieve a suitable printing policy for diagnostics.\n  static PrintingPolicy getPrintingPolicy(const ASTContext &Ctx,\n                                          const Preprocessor &PP);\n\n  /// Scope actions.\n  void ActOnPopScope(SourceLocation Loc, Scope *S);\n  void ActOnTranslationUnitScope(Scope *S);\n\n  Decl *ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                   RecordDecl *&AnonRecord);\n  Decl *ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                   MultiTemplateParamsArg TemplateParams,\n                                   bool IsExplicitInstantiation,\n                                   RecordDecl *&AnonRecord);\n\n  Decl *BuildAnonymousStructOrUnion(Scope *S, DeclSpec &DS,\n                                    AccessSpecifier AS,\n                                    RecordDecl *Record,\n                                    const PrintingPolicy &Policy);\n\n  Decl *BuildMicrosoftCAnonymousStruct(Scope *S, DeclSpec &DS,\n                                       RecordDecl *Record);\n\n  /// Common ways to introduce type names without a tag for use in diagnostics.\n  /// Keep in sync with err_tag_reference_non_tag.\n  enum NonTagKind {\n    NTK_NonStruct,\n    NTK_NonClass,\n    NTK_NonUnion,\n    NTK_NonEnum,\n    NTK_Typedef,\n    NTK_TypeAlias,\n    NTK_Template,\n    NTK_TypeAliasTemplate,\n    NTK_TemplateTemplateArgument,\n  };\n\n  /// Given a non-tag type declaration, returns an enum useful for indicating\n  /// what kind of non-tag type this is.\n  NonTagKind getNonTagTypeDeclKind(const Decl *D, TagTypeKind TTK);\n\n  bool isAcceptableTagRedeclaration(const TagDecl *Previous,\n                                    TagTypeKind NewTag, bool isDefinition,\n                                    SourceLocation NewTagLoc,\n                                    const IdentifierInfo *Name);\n\n  enum TagUseKind {\n    TUK_Reference,   // Reference to a tag:  'struct foo *X;'\n    TUK_Declaration, // Fwd decl of a tag:   'struct foo;'\n    TUK_Definition,  // Definition of a tag: 'struct foo { int X; } Y;'\n    TUK_Friend       // Friend declaration:  'friend struct foo;'\n  };\n\n  Decl *ActOnTag(Scope *S, unsigned TagSpec, TagUseKind TUK,\n                 SourceLocation KWLoc, CXXScopeSpec &SS, IdentifierInfo *Name,\n                 SourceLocation NameLoc, const ParsedAttributesView &Attr,\n                 AccessSpecifier AS, SourceLocation ModulePrivateLoc,\n                 MultiTemplateParamsArg TemplateParameterLists, bool &OwnedDecl,\n                 bool &IsDependent, SourceLocation ScopedEnumKWLoc,\n                 bool ScopedEnumUsesClassTag, TypeResult UnderlyingType,\n                 bool IsTypeSpecifier, bool IsTemplateParamOrArg,\n                 SkipBodyInfo *SkipBody = nullptr);\n\n  Decl *ActOnTemplatedFriendTag(Scope *S, SourceLocation FriendLoc,\n                                unsigned TagSpec, SourceLocation TagLoc,\n                                CXXScopeSpec &SS, IdentifierInfo *Name,\n                                SourceLocation NameLoc,\n                                const ParsedAttributesView &Attr,\n                                MultiTemplateParamsArg TempParamLists);\n\n  TypeResult ActOnDependentTag(Scope *S,\n                               unsigned TagSpec,\n                               TagUseKind TUK,\n                               const CXXScopeSpec &SS,\n                               IdentifierInfo *Name,\n                               SourceLocation TagLoc,\n                               SourceLocation NameLoc);\n\n  void ActOnDefs(Scope *S, Decl *TagD, SourceLocation DeclStart,\n                 IdentifierInfo *ClassName,\n                 SmallVectorImpl<Decl *> &Decls);\n  Decl *ActOnField(Scope *S, Decl *TagD, SourceLocation DeclStart,\n                   Declarator &D, Expr *BitfieldWidth);\n\n  FieldDecl *HandleField(Scope *S, RecordDecl *TagD, SourceLocation DeclStart,\n                         Declarator &D, Expr *BitfieldWidth,\n                         InClassInitStyle InitStyle,\n                         AccessSpecifier AS);\n  MSPropertyDecl *HandleMSProperty(Scope *S, RecordDecl *TagD,\n                                   SourceLocation DeclStart, Declarator &D,\n                                   Expr *BitfieldWidth,\n                                   InClassInitStyle InitStyle,\n                                   AccessSpecifier AS,\n                                   const ParsedAttr &MSPropertyAttr);\n\n  FieldDecl *CheckFieldDecl(DeclarationName Name, QualType T,\n                            TypeSourceInfo *TInfo,\n                            RecordDecl *Record, SourceLocation Loc,\n                            bool Mutable, Expr *BitfieldWidth,\n                            InClassInitStyle InitStyle,\n                            SourceLocation TSSL,\n                            AccessSpecifier AS, NamedDecl *PrevDecl,\n                            Declarator *D = nullptr);\n\n  bool CheckNontrivialField(FieldDecl *FD);\n  void DiagnoseNontrivial(const CXXRecordDecl *Record, CXXSpecialMember CSM);\n\n  enum TrivialABIHandling {\n    /// The triviality of a method unaffected by \"trivial_abi\".\n    TAH_IgnoreTrivialABI,\n\n    /// The triviality of a method affected by \"trivial_abi\".\n    TAH_ConsiderTrivialABI\n  };\n\n  bool SpecialMemberIsTrivial(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                              TrivialABIHandling TAH = TAH_IgnoreTrivialABI,\n                              bool Diagnose = false);\n\n  /// For a defaulted function, the kind of defaulted function that it is.\n  class DefaultedFunctionKind {\n    CXXSpecialMember SpecialMember : 8;\n    DefaultedComparisonKind Comparison : 8;\n\n  public:\n    DefaultedFunctionKind()\n        : SpecialMember(CXXInvalid), Comparison(DefaultedComparisonKind::None) {\n    }\n    DefaultedFunctionKind(CXXSpecialMember CSM)\n        : SpecialMember(CSM), Comparison(DefaultedComparisonKind::None) {}\n    DefaultedFunctionKind(DefaultedComparisonKind Comp)\n        : SpecialMember(CXXInvalid), Comparison(Comp) {}\n\n    bool isSpecialMember() const { return SpecialMember != CXXInvalid; }\n    bool isComparison() const {\n      return Comparison != DefaultedComparisonKind::None;\n    }\n\n    explicit operator bool() const {\n      return isSpecialMember() || isComparison();\n    }\n\n    CXXSpecialMember asSpecialMember() const { return SpecialMember; }\n    DefaultedComparisonKind asComparison() const { return Comparison; }\n\n    /// Get the index of this function kind for use in diagnostics.\n    unsigned getDiagnosticIndex() const {\n      static_assert(CXXInvalid > CXXDestructor,\n                    \"invalid should have highest index\");\n      static_assert((unsigned)DefaultedComparisonKind::None == 0,\n                    \"none should be equal to zero\");\n      return SpecialMember + (unsigned)Comparison;\n    }\n  };\n\n  DefaultedFunctionKind getDefaultedFunctionKind(const FunctionDecl *FD);\n\n  CXXSpecialMember getSpecialMember(const CXXMethodDecl *MD) {\n    return getDefaultedFunctionKind(MD).asSpecialMember();\n  }\n  DefaultedComparisonKind getDefaultedComparisonKind(const FunctionDecl *FD) {\n    return getDefaultedFunctionKind(FD).asComparison();\n  }\n\n  void ActOnLastBitfield(SourceLocation DeclStart,\n                         SmallVectorImpl<Decl *> &AllIvarDecls);\n  Decl *ActOnIvar(Scope *S, SourceLocation DeclStart,\n                  Declarator &D, Expr *BitfieldWidth,\n                  tok::ObjCKeywordKind visibility);\n\n  // This is used for both record definitions and ObjC interface declarations.\n  void ActOnFields(Scope *S, SourceLocation RecLoc, Decl *TagDecl,\n                   ArrayRef<Decl *> Fields, SourceLocation LBrac,\n                   SourceLocation RBrac, const ParsedAttributesView &AttrList);\n\n  /// ActOnTagStartDefinition - Invoked when we have entered the\n  /// scope of a tag's definition (e.g., for an enumeration, class,\n  /// struct, or union).\n  void ActOnTagStartDefinition(Scope *S, Decl *TagDecl);\n\n  /// Perform ODR-like check for C/ObjC when merging tag types from modules.\n  /// Differently from C++, actually parse the body and reject / error out\n  /// in case of a structural mismatch.\n  bool ActOnDuplicateDefinition(DeclSpec &DS, Decl *Prev,\n                                SkipBodyInfo &SkipBody);\n\n  typedef void *SkippedDefinitionContext;\n\n  /// Invoked when we enter a tag definition that we're skipping.\n  SkippedDefinitionContext ActOnTagStartSkippedDefinition(Scope *S, Decl *TD);\n\n  Decl *ActOnObjCContainerStartDefinition(Decl *IDecl);\n\n  /// ActOnStartCXXMemberDeclarations - Invoked when we have parsed a\n  /// C++ record definition's base-specifiers clause and are starting its\n  /// member declarations.\n  void ActOnStartCXXMemberDeclarations(Scope *S, Decl *TagDecl,\n                                       SourceLocation FinalLoc,\n                                       bool IsFinalSpelledSealed,\n                                       SourceLocation LBraceLoc);\n\n  /// ActOnTagFinishDefinition - Invoked once we have finished parsing\n  /// the definition of a tag (enumeration, class, struct, or union).\n  void ActOnTagFinishDefinition(Scope *S, Decl *TagDecl,\n                                SourceRange BraceRange);\n\n  void ActOnTagFinishSkippedDefinition(SkippedDefinitionContext Context);\n\n  void ActOnObjCContainerFinishDefinition();\n\n  /// Invoked when we must temporarily exit the objective-c container\n  /// scope for parsing/looking-up C constructs.\n  ///\n  /// Must be followed by a call to \\see ActOnObjCReenterContainerContext\n  void ActOnObjCTemporaryExitContainerContext(DeclContext *DC);\n  void ActOnObjCReenterContainerContext(DeclContext *DC);\n\n  /// ActOnTagDefinitionError - Invoked when there was an unrecoverable\n  /// error parsing the definition of a tag.\n  void ActOnTagDefinitionError(Scope *S, Decl *TagDecl);\n\n  EnumConstantDecl *CheckEnumConstant(EnumDecl *Enum,\n                                      EnumConstantDecl *LastEnumConst,\n                                      SourceLocation IdLoc,\n                                      IdentifierInfo *Id,\n                                      Expr *val);\n  bool CheckEnumUnderlyingType(TypeSourceInfo *TI);\n  bool CheckEnumRedeclaration(SourceLocation EnumLoc, bool IsScoped,\n                              QualType EnumUnderlyingTy, bool IsFixed,\n                              const EnumDecl *Prev);\n\n  /// Determine whether the body of an anonymous enumeration should be skipped.\n  /// \\param II The name of the first enumerator.\n  SkipBodyInfo shouldSkipAnonEnumBody(Scope *S, IdentifierInfo *II,\n                                      SourceLocation IILoc);\n\n  Decl *ActOnEnumConstant(Scope *S, Decl *EnumDecl, Decl *LastEnumConstant,\n                          SourceLocation IdLoc, IdentifierInfo *Id,\n                          const ParsedAttributesView &Attrs,\n                          SourceLocation EqualLoc, Expr *Val);\n  void ActOnEnumBody(SourceLocation EnumLoc, SourceRange BraceRange,\n                     Decl *EnumDecl, ArrayRef<Decl *> Elements, Scope *S,\n                     const ParsedAttributesView &Attr);\n\n  /// Set the current declaration context until it gets popped.\n  void PushDeclContext(Scope *S, DeclContext *DC);\n  void PopDeclContext();\n\n  /// EnterDeclaratorContext - Used when we must lookup names in the context\n  /// of a declarator's nested name specifier.\n  void EnterDeclaratorContext(Scope *S, DeclContext *DC);\n  void ExitDeclaratorContext(Scope *S);\n\n  /// Enter a template parameter scope, after it's been associated with a particular\n  /// DeclContext. Causes lookup within the scope to chain through enclosing contexts\n  /// in the correct order.\n  void EnterTemplatedContext(Scope *S, DeclContext *DC);\n\n  /// Push the parameters of D, which must be a function, into scope.\n  void ActOnReenterFunctionContext(Scope* S, Decl* D);\n  void ActOnExitFunctionContext();\n\n  DeclContext *getFunctionLevelDeclContext();\n\n  /// getCurFunctionDecl - If inside of a function body, this returns a pointer\n  /// to the function decl for the function being parsed.  If we're currently\n  /// in a 'block', this returns the containing context.\n  FunctionDecl *getCurFunctionDecl();\n\n  /// getCurMethodDecl - If inside of a method body, this returns a pointer to\n  /// the method decl for the method being parsed.  If we're currently\n  /// in a 'block', this returns the containing context.\n  ObjCMethodDecl *getCurMethodDecl();\n\n  /// getCurFunctionOrMethodDecl - Return the Decl for the current ObjC method\n  /// or C function we're in, otherwise return null.  If we're currently\n  /// in a 'block', this returns the containing context.\n  NamedDecl *getCurFunctionOrMethodDecl();\n\n  /// Add this decl to the scope shadowed decl chains.\n  void PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext = true);\n\n  /// isDeclInScope - If 'Ctx' is a function/method, isDeclInScope returns true\n  /// if 'D' is in Scope 'S', otherwise 'S' is ignored and isDeclInScope returns\n  /// true if 'D' belongs to the given declaration context.\n  ///\n  /// \\param AllowInlineNamespace If \\c true, allow the declaration to be in the\n  ///        enclosing namespace set of the context, rather than contained\n  ///        directly within it.\n  bool isDeclInScope(NamedDecl *D, DeclContext *Ctx, Scope *S = nullptr,\n                     bool AllowInlineNamespace = false);\n\n  /// Finds the scope corresponding to the given decl context, if it\n  /// happens to be an enclosing scope.  Otherwise return NULL.\n  static Scope *getScopeForDeclContext(Scope *S, DeclContext *DC);\n\n  /// Subroutines of ActOnDeclarator().\n  TypedefDecl *ParseTypedefDecl(Scope *S, Declarator &D, QualType T,\n                                TypeSourceInfo *TInfo);\n  bool isIncompatibleTypedef(TypeDecl *Old, TypedefNameDecl *New);\n\n  /// Describes the kind of merge to perform for availability\n  /// attributes (including \"deprecated\", \"unavailable\", and \"availability\").\n  enum AvailabilityMergeKind {\n    /// Don't merge availability attributes at all.\n    AMK_None,\n    /// Merge availability attributes for a redeclaration, which requires\n    /// an exact match.\n    AMK_Redeclaration,\n    /// Merge availability attributes for an override, which requires\n    /// an exact match or a weakening of constraints.\n    AMK_Override,\n    /// Merge availability attributes for an implementation of\n    /// a protocol requirement.\n    AMK_ProtocolImplementation,\n  };\n\n  /// Describes the kind of priority given to an availability attribute.\n  ///\n  /// The sum of priorities deteremines the final priority of the attribute.\n  /// The final priority determines how the attribute will be merged.\n  /// An attribute with a lower priority will always remove higher priority\n  /// attributes for the specified platform when it is being applied. An\n  /// attribute with a higher priority will not be applied if the declaration\n  /// already has an availability attribute with a lower priority for the\n  /// specified platform. The final prirority values are not expected to match\n  /// the values in this enumeration, but instead should be treated as a plain\n  /// integer value. This enumeration just names the priority weights that are\n  /// used to calculate that final vaue.\n  enum AvailabilityPriority : int {\n    /// The availability attribute was specified explicitly next to the\n    /// declaration.\n    AP_Explicit = 0,\n\n    /// The availability attribute was applied using '#pragma clang attribute'.\n    AP_PragmaClangAttribute = 1,\n\n    /// The availability attribute for a specific platform was inferred from\n    /// an availability attribute for another platform.\n    AP_InferredFromOtherPlatform = 2\n  };\n\n  /// Attribute merging methods. Return true if a new attribute was added.\n  AvailabilityAttr *\n  mergeAvailabilityAttr(NamedDecl *D, const AttributeCommonInfo &CI,\n                        IdentifierInfo *Platform, bool Implicit,\n                        VersionTuple Introduced, VersionTuple Deprecated,\n                        VersionTuple Obsoleted, bool IsUnavailable,\n                        StringRef Message, bool IsStrict, StringRef Replacement,\n                        AvailabilityMergeKind AMK, int Priority);\n  TypeVisibilityAttr *\n  mergeTypeVisibilityAttr(Decl *D, const AttributeCommonInfo &CI,\n                          TypeVisibilityAttr::VisibilityType Vis);\n  VisibilityAttr *mergeVisibilityAttr(Decl *D, const AttributeCommonInfo &CI,\n                                      VisibilityAttr::VisibilityType Vis);\n  UuidAttr *mergeUuidAttr(Decl *D, const AttributeCommonInfo &CI,\n                          StringRef UuidAsWritten, MSGuidDecl *GuidDecl);\n  DLLImportAttr *mergeDLLImportAttr(Decl *D, const AttributeCommonInfo &CI);\n  DLLExportAttr *mergeDLLExportAttr(Decl *D, const AttributeCommonInfo &CI);\n  MSInheritanceAttr *mergeMSInheritanceAttr(Decl *D,\n                                            const AttributeCommonInfo &CI,\n                                            bool BestCase,\n                                            MSInheritanceModel Model);\n  FormatAttr *mergeFormatAttr(Decl *D, const AttributeCommonInfo &CI,\n                              IdentifierInfo *Format, int FormatIdx,\n                              int FirstArg);\n  SectionAttr *mergeSectionAttr(Decl *D, const AttributeCommonInfo &CI,\n                                StringRef Name);\n  CodeSegAttr *mergeCodeSegAttr(Decl *D, const AttributeCommonInfo &CI,\n                                StringRef Name);\n  AlwaysInlineAttr *mergeAlwaysInlineAttr(Decl *D,\n                                          const AttributeCommonInfo &CI,\n                                          const IdentifierInfo *Ident);\n  MinSizeAttr *mergeMinSizeAttr(Decl *D, const AttributeCommonInfo &CI);\n  NoSpeculativeLoadHardeningAttr *\n  mergeNoSpeculativeLoadHardeningAttr(Decl *D,\n                                      const NoSpeculativeLoadHardeningAttr &AL);\n  SpeculativeLoadHardeningAttr *\n  mergeSpeculativeLoadHardeningAttr(Decl *D,\n                                    const SpeculativeLoadHardeningAttr &AL);\n  SwiftNameAttr *mergeSwiftNameAttr(Decl *D, const SwiftNameAttr &SNA,\n                                    StringRef Name);\n  OptimizeNoneAttr *mergeOptimizeNoneAttr(Decl *D,\n                                          const AttributeCommonInfo &CI);\n  InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D, const ParsedAttr &AL);\n  InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D,\n                                                const InternalLinkageAttr &AL);\n  CommonAttr *mergeCommonAttr(Decl *D, const ParsedAttr &AL);\n  CommonAttr *mergeCommonAttr(Decl *D, const CommonAttr &AL);\n  WebAssemblyImportNameAttr *mergeImportNameAttr(\n      Decl *D, const WebAssemblyImportNameAttr &AL);\n  WebAssemblyImportModuleAttr *mergeImportModuleAttr(\n      Decl *D, const WebAssemblyImportModuleAttr &AL);\n  EnforceTCBAttr *mergeEnforceTCBAttr(Decl *D, const EnforceTCBAttr &AL);\n  EnforceTCBLeafAttr *mergeEnforceTCBLeafAttr(Decl *D,\n                                              const EnforceTCBLeafAttr &AL);\n\n  void mergeDeclAttributes(NamedDecl *New, Decl *Old,\n                           AvailabilityMergeKind AMK = AMK_Redeclaration);\n  void MergeTypedefNameDecl(Scope *S, TypedefNameDecl *New,\n                            LookupResult &OldDecls);\n  bool MergeFunctionDecl(FunctionDecl *New, NamedDecl *&Old, Scope *S,\n                         bool MergeTypeWithOld);\n  bool MergeCompatibleFunctionDecls(FunctionDecl *New, FunctionDecl *Old,\n                                    Scope *S, bool MergeTypeWithOld);\n  void mergeObjCMethodDecls(ObjCMethodDecl *New, ObjCMethodDecl *Old);\n  void MergeVarDecl(VarDecl *New, LookupResult &Previous);\n  void MergeVarDeclTypes(VarDecl *New, VarDecl *Old, bool MergeTypeWithOld);\n  void MergeVarDeclExceptionSpecs(VarDecl *New, VarDecl *Old);\n  bool checkVarDeclRedefinition(VarDecl *OldDefn, VarDecl *NewDefn);\n  void notePreviousDefinition(const NamedDecl *Old, SourceLocation New);\n  bool MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old, Scope *S);\n\n  // AssignmentAction - This is used by all the assignment diagnostic functions\n  // to represent what is actually causing the operation\n  enum AssignmentAction {\n    AA_Assigning,\n    AA_Passing,\n    AA_Returning,\n    AA_Converting,\n    AA_Initializing,\n    AA_Sending,\n    AA_Casting,\n    AA_Passing_CFAudited\n  };\n\n  /// C++ Overloading.\n  enum OverloadKind {\n    /// This is a legitimate overload: the existing declarations are\n    /// functions or function templates with different signatures.\n    Ovl_Overload,\n\n    /// This is not an overload because the signature exactly matches\n    /// an existing declaration.\n    Ovl_Match,\n\n    /// This is not an overload because the lookup results contain a\n    /// non-function.\n    Ovl_NonFunction\n  };\n  OverloadKind CheckOverload(Scope *S,\n                             FunctionDecl *New,\n                             const LookupResult &OldDecls,\n                             NamedDecl *&OldDecl,\n                             bool IsForUsingDecl);\n  bool IsOverload(FunctionDecl *New, FunctionDecl *Old, bool IsForUsingDecl,\n                  bool ConsiderCudaAttrs = true,\n                  bool ConsiderRequiresClauses = true);\n\n  enum class AllowedExplicit {\n    /// Allow no explicit functions to be used.\n    None,\n    /// Allow explicit conversion functions but not explicit constructors.\n    Conversions,\n    /// Allow both explicit conversion functions and explicit constructors.\n    All\n  };\n\n  ImplicitConversionSequence\n  TryImplicitConversion(Expr *From, QualType ToType,\n                        bool SuppressUserConversions,\n                        AllowedExplicit AllowExplicit,\n                        bool InOverloadResolution,\n                        bool CStyle,\n                        bool AllowObjCWritebackConversion);\n\n  bool IsIntegralPromotion(Expr *From, QualType FromType, QualType ToType);\n  bool IsFloatingPointPromotion(QualType FromType, QualType ToType);\n  bool IsComplexPromotion(QualType FromType, QualType ToType);\n  bool IsPointerConversion(Expr *From, QualType FromType, QualType ToType,\n                           bool InOverloadResolution,\n                           QualType& ConvertedType, bool &IncompatibleObjC);\n  bool isObjCPointerConversion(QualType FromType, QualType ToType,\n                               QualType& ConvertedType, bool &IncompatibleObjC);\n  bool isObjCWritebackConversion(QualType FromType, QualType ToType,\n                                 QualType &ConvertedType);\n  bool IsBlockPointerConversion(QualType FromType, QualType ToType,\n                                QualType& ConvertedType);\n  bool FunctionParamTypesAreEqual(const FunctionProtoType *OldType,\n                                  const FunctionProtoType *NewType,\n                                  unsigned *ArgPos = nullptr);\n  void HandleFunctionTypeMismatch(PartialDiagnostic &PDiag,\n                                  QualType FromType, QualType ToType);\n\n  void maybeExtendBlockObject(ExprResult &E);\n  CastKind PrepareCastToObjCObjectPointer(ExprResult &E);\n  bool CheckPointerConversion(Expr *From, QualType ToType,\n                              CastKind &Kind,\n                              CXXCastPath& BasePath,\n                              bool IgnoreBaseAccess,\n                              bool Diagnose = true);\n  bool IsMemberPointerConversion(Expr *From, QualType FromType, QualType ToType,\n                                 bool InOverloadResolution,\n                                 QualType &ConvertedType);\n  bool CheckMemberPointerConversion(Expr *From, QualType ToType,\n                                    CastKind &Kind,\n                                    CXXCastPath &BasePath,\n                                    bool IgnoreBaseAccess);\n  bool IsQualificationConversion(QualType FromType, QualType ToType,\n                                 bool CStyle, bool &ObjCLifetimeConversion);\n  bool IsFunctionConversion(QualType FromType, QualType ToType,\n                            QualType &ResultTy);\n  bool DiagnoseMultipleUserDefinedConversion(Expr *From, QualType ToType);\n  bool isSameOrCompatibleFunctionType(CanQualType Param, CanQualType Arg);\n\n  ExprResult PerformMoveOrCopyInitialization(const InitializedEntity &Entity,\n                                             const VarDecl *NRVOCandidate,\n                                             QualType ResultType,\n                                             Expr *Value,\n                                             bool AllowNRVO = true);\n\n  bool CanPerformAggregateInitializationForOverloadResolution(\n      const InitializedEntity &Entity, InitListExpr *From);\n\n  bool IsStringInit(Expr *Init, const ArrayType *AT);\n\n  bool CanPerformCopyInitialization(const InitializedEntity &Entity,\n                                    ExprResult Init);\n  ExprResult PerformCopyInitialization(const InitializedEntity &Entity,\n                                       SourceLocation EqualLoc,\n                                       ExprResult Init,\n                                       bool TopLevelOfInitList = false,\n                                       bool AllowExplicit = false);\n  ExprResult PerformObjectArgumentInitialization(Expr *From,\n                                                 NestedNameSpecifier *Qualifier,\n                                                 NamedDecl *FoundDecl,\n                                                 CXXMethodDecl *Method);\n\n  /// Check that the lifetime of the initializer (and its subobjects) is\n  /// sufficient for initializing the entity, and perform lifetime extension\n  /// (when permitted) if not.\n  void checkInitializerLifetime(const InitializedEntity &Entity, Expr *Init);\n\n  ExprResult PerformContextuallyConvertToBool(Expr *From);\n  ExprResult PerformContextuallyConvertToObjCPointer(Expr *From);\n\n  /// Contexts in which a converted constant expression is required.\n  enum CCEKind {\n    CCEK_CaseValue,   ///< Expression in a case label.\n    CCEK_Enumerator,  ///< Enumerator value with fixed underlying type.\n    CCEK_TemplateArg, ///< Value of a non-type template parameter.\n    CCEK_ArrayBound,  ///< Array bound in array declarator or new-expression.\n    CCEK_ConstexprIf, ///< Condition in a constexpr if statement.\n    CCEK_ExplicitBool ///< Condition in an explicit(bool) specifier.\n  };\n  ExprResult CheckConvertedConstantExpression(Expr *From, QualType T,\n                                              llvm::APSInt &Value, CCEKind CCE);\n  ExprResult CheckConvertedConstantExpression(Expr *From, QualType T,\n                                              APValue &Value, CCEKind CCE,\n                                              NamedDecl *Dest = nullptr);\n\n  /// Abstract base class used to perform a contextual implicit\n  /// conversion from an expression to any type passing a filter.\n  class ContextualImplicitConverter {\n  public:\n    bool Suppress;\n    bool SuppressConversion;\n\n    ContextualImplicitConverter(bool Suppress = false,\n                                bool SuppressConversion = false)\n        : Suppress(Suppress), SuppressConversion(SuppressConversion) {}\n\n    /// Determine whether the specified type is a valid destination type\n    /// for this conversion.\n    virtual bool match(QualType T) = 0;\n\n    /// Emits a diagnostic complaining that the expression does not have\n    /// integral or enumeration type.\n    virtual SemaDiagnosticBuilder\n    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a diagnostic when the expression has incomplete class type.\n    virtual SemaDiagnosticBuilder\n    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a diagnostic when the only matching conversion function\n    /// is explicit.\n    virtual SemaDiagnosticBuilder diagnoseExplicitConv(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;\n\n    /// Emits a note for the explicit conversion function.\n    virtual SemaDiagnosticBuilder\n    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) = 0;\n\n    /// Emits a diagnostic when there are multiple possible conversion\n    /// functions.\n    virtual SemaDiagnosticBuilder\n    diagnoseAmbiguous(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a note for one of the candidate conversions.\n    virtual SemaDiagnosticBuilder\n    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) = 0;\n\n    /// Emits a diagnostic when we picked a conversion function\n    /// (for cases when we are not allowed to pick a conversion function).\n    virtual SemaDiagnosticBuilder diagnoseConversion(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;\n\n    virtual ~ContextualImplicitConverter() {}\n  };\n\n  class ICEConvertDiagnoser : public ContextualImplicitConverter {\n    bool AllowScopedEnumerations;\n\n  public:\n    ICEConvertDiagnoser(bool AllowScopedEnumerations,\n                        bool Suppress, bool SuppressConversion)\n        : ContextualImplicitConverter(Suppress, SuppressConversion),\n          AllowScopedEnumerations(AllowScopedEnumerations) {}\n\n    /// Match an integral or (possibly scoped) enumeration type.\n    bool match(QualType T) override;\n\n    SemaDiagnosticBuilder\n    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) override {\n      return diagnoseNotInt(S, Loc, T);\n    }\n\n    /// Emits a diagnostic complaining that the expression does not have\n    /// integral or enumeration type.\n    virtual SemaDiagnosticBuilder\n    diagnoseNotInt(Sema &S, SourceLocation Loc, QualType T) = 0;\n  };\n\n  /// Perform a contextual implicit conversion.\n  ExprResult PerformContextualImplicitConversion(\n      SourceLocation Loc, Expr *FromE, ContextualImplicitConverter &Converter);\n\n\n  enum ObjCSubscriptKind {\n    OS_Array,\n    OS_Dictionary,\n    OS_Error\n  };\n  ObjCSubscriptKind CheckSubscriptingKind(Expr *FromE);\n\n  // Note that LK_String is intentionally after the other literals, as\n  // this is used for diagnostics logic.\n  enum ObjCLiteralKind {\n    LK_Array,\n    LK_Dictionary,\n    LK_Numeric,\n    LK_Boxed,\n    LK_String,\n    LK_Block,\n    LK_None\n  };\n  ObjCLiteralKind CheckLiteralKind(Expr *FromE);\n\n  ExprResult PerformObjectMemberConversion(Expr *From,\n                                           NestedNameSpecifier *Qualifier,\n                                           NamedDecl *FoundDecl,\n                                           NamedDecl *Member);\n\n  // Members have to be NamespaceDecl* or TranslationUnitDecl*.\n  // TODO: make this is a typesafe union.\n  typedef llvm::SmallSetVector<DeclContext   *, 16> AssociatedNamespaceSet;\n  typedef llvm::SmallSetVector<CXXRecordDecl *, 16> AssociatedClassSet;\n\n  using ADLCallKind = CallExpr::ADLCallKind;\n\n  void AddOverloadCandidate(FunctionDecl *Function, DeclAccessPair FoundDecl,\n                            ArrayRef<Expr *> Args,\n                            OverloadCandidateSet &CandidateSet,\n                            bool SuppressUserConversions = false,\n                            bool PartialOverloading = false,\n                            bool AllowExplicit = true,\n                            bool AllowExplicitConversion = false,\n                            ADLCallKind IsADLCandidate = ADLCallKind::NotADL,\n                            ConversionSequenceList EarlyConversions = None,\n                            OverloadCandidateParamOrder PO = {});\n  void AddFunctionCandidates(const UnresolvedSetImpl &Functions,\n                      ArrayRef<Expr *> Args,\n                      OverloadCandidateSet &CandidateSet,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,\n                      bool SuppressUserConversions = false,\n                      bool PartialOverloading = false,\n                      bool FirstArgumentIsBase = false);\n  void AddMethodCandidate(DeclAccessPair FoundDecl,\n                          QualType ObjectType,\n                          Expr::Classification ObjectClassification,\n                          ArrayRef<Expr *> Args,\n                          OverloadCandidateSet& CandidateSet,\n                          bool SuppressUserConversion = false,\n                          OverloadCandidateParamOrder PO = {});\n  void AddMethodCandidate(CXXMethodDecl *Method,\n                          DeclAccessPair FoundDecl,\n                          CXXRecordDecl *ActingContext, QualType ObjectType,\n                          Expr::Classification ObjectClassification,\n                          ArrayRef<Expr *> Args,\n                          OverloadCandidateSet& CandidateSet,\n                          bool SuppressUserConversions = false,\n                          bool PartialOverloading = false,\n                          ConversionSequenceList EarlyConversions = None,\n                          OverloadCandidateParamOrder PO = {});\n  void AddMethodTemplateCandidate(FunctionTemplateDecl *MethodTmpl,\n                                  DeclAccessPair FoundDecl,\n                                  CXXRecordDecl *ActingContext,\n                                 TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                  QualType ObjectType,\n                                  Expr::Classification ObjectClassification,\n                                  ArrayRef<Expr *> Args,\n                                  OverloadCandidateSet& CandidateSet,\n                                  bool SuppressUserConversions = false,\n                                  bool PartialOverloading = false,\n                                  OverloadCandidateParamOrder PO = {});\n  void AddTemplateOverloadCandidate(\n      FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n      TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n      OverloadCandidateSet &CandidateSet, bool SuppressUserConversions = false,\n      bool PartialOverloading = false, bool AllowExplicit = true,\n      ADLCallKind IsADLCandidate = ADLCallKind::NotADL,\n      OverloadCandidateParamOrder PO = {});\n  bool CheckNonDependentConversions(\n      FunctionTemplateDecl *FunctionTemplate, ArrayRef<QualType> ParamTypes,\n      ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet,\n      ConversionSequenceList &Conversions, bool SuppressUserConversions,\n      CXXRecordDecl *ActingContext = nullptr, QualType ObjectType = QualType(),\n      Expr::Classification ObjectClassification = {},\n      OverloadCandidateParamOrder PO = {});\n  void AddConversionCandidate(\n      CXXConversionDecl *Conversion, DeclAccessPair FoundDecl,\n      CXXRecordDecl *ActingContext, Expr *From, QualType ToType,\n      OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n      bool AllowExplicit, bool AllowResultConversion = true);\n  void AddTemplateConversionCandidate(\n      FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n      CXXRecordDecl *ActingContext, Expr *From, QualType ToType,\n      OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n      bool AllowExplicit, bool AllowResultConversion = true);\n  void AddSurrogateCandidate(CXXConversionDecl *Conversion,\n                             DeclAccessPair FoundDecl,\n                             CXXRecordDecl *ActingContext,\n                             const FunctionProtoType *Proto,\n                             Expr *Object, ArrayRef<Expr *> Args,\n                             OverloadCandidateSet& CandidateSet);\n  void AddNonMemberOperatorCandidates(\n      const UnresolvedSetImpl &Functions, ArrayRef<Expr *> Args,\n      OverloadCandidateSet &CandidateSet,\n      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);\n  void AddMemberOperatorCandidates(OverloadedOperatorKind Op,\n                                   SourceLocation OpLoc, ArrayRef<Expr *> Args,\n                                   OverloadCandidateSet &CandidateSet,\n                                   OverloadCandidateParamOrder PO = {});\n  void AddBuiltinCandidate(QualType *ParamTys, ArrayRef<Expr *> Args,\n                           OverloadCandidateSet& CandidateSet,\n                           bool IsAssignmentOperator = false,\n                           unsigned NumContextualBoolArguments = 0);\n  void AddBuiltinOperatorCandidates(OverloadedOperatorKind Op,\n                                    SourceLocation OpLoc, ArrayRef<Expr *> Args,\n                                    OverloadCandidateSet& CandidateSet);\n  void AddArgumentDependentLookupCandidates(DeclarationName Name,\n                                            SourceLocation Loc,\n                                            ArrayRef<Expr *> Args,\n                                TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                            OverloadCandidateSet& CandidateSet,\n                                            bool PartialOverloading = false);\n\n  // Emit as a 'note' the specific overload candidate\n  void NoteOverloadCandidate(\n      NamedDecl *Found, FunctionDecl *Fn,\n      OverloadCandidateRewriteKind RewriteKind = OverloadCandidateRewriteKind(),\n      QualType DestType = QualType(), bool TakingAddress = false);\n\n  // Emit as a series of 'note's all template and non-templates identified by\n  // the expression Expr\n  void NoteAllOverloadCandidates(Expr *E, QualType DestType = QualType(),\n                                 bool TakingAddress = false);\n\n  /// Check the enable_if expressions on the given function. Returns the first\n  /// failing attribute, or NULL if they were all successful.\n  EnableIfAttr *CheckEnableIf(FunctionDecl *Function, SourceLocation CallLoc,\n                              ArrayRef<Expr *> Args,\n                              bool MissingImplicitThis = false);\n\n  /// Find the failed Boolean condition within a given Boolean\n  /// constant expression, and describe it with a string.\n  std::pair<Expr *, std::string> findFailedBooleanCondition(Expr *Cond);\n\n  /// Emit diagnostics for the diagnose_if attributes on Function, ignoring any\n  /// non-ArgDependent DiagnoseIfAttrs.\n  ///\n  /// Argument-dependent diagnose_if attributes should be checked each time a\n  /// function is used as a direct callee of a function call.\n  ///\n  /// Returns true if any errors were emitted.\n  bool diagnoseArgDependentDiagnoseIfAttrs(const FunctionDecl *Function,\n                                           const Expr *ThisArg,\n                                           ArrayRef<const Expr *> Args,\n                                           SourceLocation Loc);\n\n  /// Emit diagnostics for the diagnose_if attributes on Function, ignoring any\n  /// ArgDependent DiagnoseIfAttrs.\n  ///\n  /// Argument-independent diagnose_if attributes should be checked on every use\n  /// of a function.\n  ///\n  /// Returns true if any errors were emitted.\n  bool diagnoseArgIndependentDiagnoseIfAttrs(const NamedDecl *ND,\n                                             SourceLocation Loc);\n\n  /// Returns whether the given function's address can be taken or not,\n  /// optionally emitting a diagnostic if the address can't be taken.\n  ///\n  /// Returns false if taking the address of the function is illegal.\n  bool checkAddressOfFunctionIsAvailable(const FunctionDecl *Function,\n                                         bool Complain = false,\n                                         SourceLocation Loc = SourceLocation());\n\n  // [PossiblyAFunctionType]  -->   [Return]\n  // NonFunctionType --> NonFunctionType\n  // R (A) --> R(A)\n  // R (*)(A) --> R (A)\n  // R (&)(A) --> R (A)\n  // R (S::*)(A) --> R (A)\n  QualType ExtractUnqualifiedFunctionType(QualType PossiblyAFunctionType);\n\n  FunctionDecl *\n  ResolveAddressOfOverloadedFunction(Expr *AddressOfExpr,\n                                     QualType TargetType,\n                                     bool Complain,\n                                     DeclAccessPair &Found,\n                                     bool *pHadMultipleCandidates = nullptr);\n\n  FunctionDecl *\n  resolveAddressOfSingleOverloadCandidate(Expr *E, DeclAccessPair &FoundResult);\n\n  bool resolveAndFixAddressOfSingleOverloadCandidate(\n      ExprResult &SrcExpr, bool DoFunctionPointerConversion = false);\n\n  FunctionDecl *\n  ResolveSingleFunctionTemplateSpecialization(OverloadExpr *ovl,\n                                              bool Complain = false,\n                                              DeclAccessPair *Found = nullptr);\n\n  bool ResolveAndFixSingleFunctionTemplateSpecialization(\n                      ExprResult &SrcExpr,\n                      bool DoFunctionPointerConverion = false,\n                      bool Complain = false,\n                      SourceRange OpRangeForComplaining = SourceRange(),\n                      QualType DestTypeForComplaining = QualType(),\n                      unsigned DiagIDForComplaining = 0);\n\n\n  Expr *FixOverloadedFunctionReference(Expr *E,\n                                       DeclAccessPair FoundDecl,\n                                       FunctionDecl *Fn);\n  ExprResult FixOverloadedFunctionReference(ExprResult,\n                                            DeclAccessPair FoundDecl,\n                                            FunctionDecl *Fn);\n\n  void AddOverloadedCallCandidates(UnresolvedLookupExpr *ULE,\n                                   ArrayRef<Expr *> Args,\n                                   OverloadCandidateSet &CandidateSet,\n                                   bool PartialOverloading = false);\n  void AddOverloadedCallCandidates(\n      LookupResult &R, TemplateArgumentListInfo *ExplicitTemplateArgs,\n      ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet);\n\n  // An enum used to represent the different possible results of building a\n  // range-based for loop.\n  enum ForRangeStatus {\n    FRS_Success,\n    FRS_NoViableFunction,\n    FRS_DiagnosticIssued\n  };\n\n  ForRangeStatus BuildForRangeBeginEndCall(SourceLocation Loc,\n                                           SourceLocation RangeLoc,\n                                           const DeclarationNameInfo &NameInfo,\n                                           LookupResult &MemberLookup,\n                                           OverloadCandidateSet *CandidateSet,\n                                           Expr *Range, ExprResult *CallExpr);\n\n  ExprResult BuildOverloadedCallExpr(Scope *S, Expr *Fn,\n                                     UnresolvedLookupExpr *ULE,\n                                     SourceLocation LParenLoc,\n                                     MultiExprArg Args,\n                                     SourceLocation RParenLoc,\n                                     Expr *ExecConfig,\n                                     bool AllowTypoCorrection=true,\n                                     bool CalleesAddressIsTaken=false);\n\n  bool buildOverloadedCallSet(Scope *S, Expr *Fn, UnresolvedLookupExpr *ULE,\n                              MultiExprArg Args, SourceLocation RParenLoc,\n                              OverloadCandidateSet *CandidateSet,\n                              ExprResult *Result);\n\n  ExprResult CreateUnresolvedLookupExpr(CXXRecordDecl *NamingClass,\n                                        NestedNameSpecifierLoc NNSLoc,\n                                        DeclarationNameInfo DNI,\n                                        const UnresolvedSetImpl &Fns,\n                                        bool PerformADL = true);\n\n  ExprResult CreateOverloadedUnaryOp(SourceLocation OpLoc,\n                                     UnaryOperatorKind Opc,\n                                     const UnresolvedSetImpl &Fns,\n                                     Expr *input, bool RequiresADL = true);\n\n  void LookupOverloadedBinOp(OverloadCandidateSet &CandidateSet,\n                             OverloadedOperatorKind Op,\n                             const UnresolvedSetImpl &Fns,\n                             ArrayRef<Expr *> Args, bool RequiresADL = true);\n  ExprResult CreateOverloadedBinOp(SourceLocation OpLoc,\n                                   BinaryOperatorKind Opc,\n                                   const UnresolvedSetImpl &Fns,\n                                   Expr *LHS, Expr *RHS,\n                                   bool RequiresADL = true,\n                                   bool AllowRewrittenCandidates = true,\n                                   FunctionDecl *DefaultedFn = nullptr);\n  ExprResult BuildSynthesizedThreeWayComparison(SourceLocation OpLoc,\n                                                const UnresolvedSetImpl &Fns,\n                                                Expr *LHS, Expr *RHS,\n                                                FunctionDecl *DefaultedFn);\n\n  ExprResult CreateOverloadedArraySubscriptExpr(SourceLocation LLoc,\n                                                SourceLocation RLoc,\n                                                Expr *Base,Expr *Idx);\n\n  ExprResult BuildCallToMemberFunction(Scope *S, Expr *MemExpr,\n                                       SourceLocation LParenLoc,\n                                       MultiExprArg Args,\n                                       SourceLocation RParenLoc,\n                                       bool AllowRecovery = false);\n  ExprResult\n  BuildCallToObjectOfClassType(Scope *S, Expr *Object, SourceLocation LParenLoc,\n                               MultiExprArg Args,\n                               SourceLocation RParenLoc);\n\n  ExprResult BuildOverloadedArrowExpr(Scope *S, Expr *Base,\n                                      SourceLocation OpLoc,\n                                      bool *NoArrowOperatorFound = nullptr);\n\n  /// CheckCallReturnType - Checks that a call expression's return type is\n  /// complete. Returns true on failure. The location passed in is the location\n  /// that best represents the call.\n  bool CheckCallReturnType(QualType ReturnType, SourceLocation Loc,\n                           CallExpr *CE, FunctionDecl *FD);\n\n  /// Helpers for dealing with blocks and functions.\n  bool CheckParmsForFunctionDef(ArrayRef<ParmVarDecl *> Parameters,\n                                bool CheckParameterNames);\n  void CheckCXXDefaultArguments(FunctionDecl *FD);\n  void CheckExtraCXXDefaultArguments(Declarator &D);\n  Scope *getNonFieldDeclScope(Scope *S);\n\n  /// \\name Name lookup\n  ///\n  /// These routines provide name lookup that is used during semantic\n  /// analysis to resolve the various kinds of names (identifiers,\n  /// overloaded operator names, constructor names, etc.) into zero or\n  /// more declarations within a particular scope. The major entry\n  /// points are LookupName, which performs unqualified name lookup,\n  /// and LookupQualifiedName, which performs qualified name lookup.\n  ///\n  /// All name lookup is performed based on some specific criteria,\n  /// which specify what names will be visible to name lookup and how\n  /// far name lookup should work. These criteria are important both\n  /// for capturing language semantics (certain lookups will ignore\n  /// certain names, for example) and for performance, since name\n  /// lookup is often a bottleneck in the compilation of C++. Name\n  /// lookup criteria is specified via the LookupCriteria enumeration.\n  ///\n  /// The results of name lookup can vary based on the kind of name\n  /// lookup performed, the current language, and the translation\n  /// unit. In C, for example, name lookup will either return nothing\n  /// (no entity found) or a single declaration. In C++, name lookup\n  /// can additionally refer to a set of overloaded functions or\n  /// result in an ambiguity. All of the possible results of name\n  /// lookup are captured by the LookupResult class, which provides\n  /// the ability to distinguish among them.\n  //@{\n\n  /// Describes the kind of name lookup to perform.\n  enum LookupNameKind {\n    /// Ordinary name lookup, which finds ordinary names (functions,\n    /// variables, typedefs, etc.) in C and most kinds of names\n    /// (functions, variables, members, types, etc.) in C++.\n    LookupOrdinaryName = 0,\n    /// Tag name lookup, which finds the names of enums, classes,\n    /// structs, and unions.\n    LookupTagName,\n    /// Label name lookup.\n    LookupLabel,\n    /// Member name lookup, which finds the names of\n    /// class/struct/union members.\n    LookupMemberName,\n    /// Look up of an operator name (e.g., operator+) for use with\n    /// operator overloading. This lookup is similar to ordinary name\n    /// lookup, but will ignore any declarations that are class members.\n    LookupOperatorName,\n    /// Look up a name following ~ in a destructor name. This is an ordinary\n    /// lookup, but prefers tags to typedefs.\n    LookupDestructorName,\n    /// Look up of a name that precedes the '::' scope resolution\n    /// operator in C++. This lookup completely ignores operator, object,\n    /// function, and enumerator names (C++ [basic.lookup.qual]p1).\n    LookupNestedNameSpecifierName,\n    /// Look up a namespace name within a C++ using directive or\n    /// namespace alias definition, ignoring non-namespace names (C++\n    /// [basic.lookup.udir]p1).\n    LookupNamespaceName,\n    /// Look up all declarations in a scope with the given name,\n    /// including resolved using declarations.  This is appropriate\n    /// for checking redeclarations for a using declaration.\n    LookupUsingDeclName,\n    /// Look up an ordinary name that is going to be redeclared as a\n    /// name with linkage. This lookup ignores any declarations that\n    /// are outside of the current scope unless they have linkage. See\n    /// C99 6.2.2p4-5 and C++ [basic.link]p6.\n    LookupRedeclarationWithLinkage,\n    /// Look up a friend of a local class. This lookup does not look\n    /// outside the innermost non-class scope. See C++11 [class.friend]p11.\n    LookupLocalFriendName,\n    /// Look up the name of an Objective-C protocol.\n    LookupObjCProtocolName,\n    /// Look up implicit 'self' parameter of an objective-c method.\n    LookupObjCImplicitSelfParam,\n    /// Look up the name of an OpenMP user-defined reduction operation.\n    LookupOMPReductionName,\n    /// Look up the name of an OpenMP user-defined mapper.\n    LookupOMPMapperName,\n    /// Look up any declaration with any name.\n    LookupAnyName\n  };\n\n  /// Specifies whether (or how) name lookup is being performed for a\n  /// redeclaration (vs. a reference).\n  enum RedeclarationKind {\n    /// The lookup is a reference to this name that is not for the\n    /// purpose of redeclaring the name.\n    NotForRedeclaration = 0,\n    /// The lookup results will be used for redeclaration of a name,\n    /// if an entity by that name already exists and is visible.\n    ForVisibleRedeclaration,\n    /// The lookup results will be used for redeclaration of a name\n    /// with external linkage; non-visible lookup results with external linkage\n    /// may also be found.\n    ForExternalRedeclaration\n  };\n\n  RedeclarationKind forRedeclarationInCurContext() {\n    // A declaration with an owning module for linkage can never link against\n    // anything that is not visible. We don't need to check linkage here; if\n    // the context has internal linkage, redeclaration lookup won't find things\n    // from other TUs, and we can't safely compute linkage yet in general.\n    if (cast<Decl>(CurContext)\n            ->getOwningModuleForLinkage(/*IgnoreLinkage*/true))\n      return ForVisibleRedeclaration;\n    return ForExternalRedeclaration;\n  }\n\n  /// The possible outcomes of name lookup for a literal operator.\n  enum LiteralOperatorLookupResult {\n    /// The lookup resulted in an error.\n    LOLR_Error,\n    /// The lookup found no match but no diagnostic was issued.\n    LOLR_ErrorNoDiagnostic,\n    /// The lookup found a single 'cooked' literal operator, which\n    /// expects a normal literal to be built and passed to it.\n    LOLR_Cooked,\n    /// The lookup found a single 'raw' literal operator, which expects\n    /// a string literal containing the spelling of the literal token.\n    LOLR_Raw,\n    /// The lookup found an overload set of literal operator templates,\n    /// which expect the characters of the spelling of the literal token to be\n    /// passed as a non-type template argument pack.\n    LOLR_Template,\n    /// The lookup found an overload set of literal operator templates,\n    /// which expect the character type and characters of the spelling of the\n    /// string literal token to be passed as template arguments.\n    LOLR_StringTemplatePack,\n  };\n\n  SpecialMemberOverloadResult LookupSpecialMember(CXXRecordDecl *D,\n                                                  CXXSpecialMember SM,\n                                                  bool ConstArg,\n                                                  bool VolatileArg,\n                                                  bool RValueThis,\n                                                  bool ConstThis,\n                                                  bool VolatileThis);\n\n  typedef std::function<void(const TypoCorrection &)> TypoDiagnosticGenerator;\n  typedef std::function<ExprResult(Sema &, TypoExpr *, TypoCorrection)>\n      TypoRecoveryCallback;\n\nprivate:\n  bool CppLookupName(LookupResult &R, Scope *S);\n\n  struct TypoExprState {\n    std::unique_ptr<TypoCorrectionConsumer> Consumer;\n    TypoDiagnosticGenerator DiagHandler;\n    TypoRecoveryCallback RecoveryHandler;\n    TypoExprState();\n    TypoExprState(TypoExprState &&other) noexcept;\n    TypoExprState &operator=(TypoExprState &&other) noexcept;\n  };\n\n  /// The set of unhandled TypoExprs and their associated state.\n  llvm::MapVector<TypoExpr *, TypoExprState> DelayedTypos;\n\n  /// Creates a new TypoExpr AST node.\n  TypoExpr *createDelayedTypo(std::unique_ptr<TypoCorrectionConsumer> TCC,\n                              TypoDiagnosticGenerator TDG,\n                              TypoRecoveryCallback TRC, SourceLocation TypoLoc);\n\n  // The set of known/encountered (unique, canonicalized) NamespaceDecls.\n  //\n  // The boolean value will be true to indicate that the namespace was loaded\n  // from an AST/PCH file, or false otherwise.\n  llvm::MapVector<NamespaceDecl*, bool> KnownNamespaces;\n\n  /// Whether we have already loaded known namespaces from an extenal\n  /// source.\n  bool LoadedExternalKnownNamespaces;\n\n  /// Helper for CorrectTypo and CorrectTypoDelayed used to create and\n  /// populate a new TypoCorrectionConsumer. Returns nullptr if typo correction\n  /// should be skipped entirely.\n  std::unique_ptr<TypoCorrectionConsumer>\n  makeTypoCorrectionConsumer(const DeclarationNameInfo &Typo,\n                             Sema::LookupNameKind LookupKind, Scope *S,\n                             CXXScopeSpec *SS,\n                             CorrectionCandidateCallback &CCC,\n                             DeclContext *MemberContext, bool EnteringContext,\n                             const ObjCObjectPointerType *OPT,\n                             bool ErrorRecovery);\n\npublic:\n  const TypoExprState &getTypoExprState(TypoExpr *TE) const;\n\n  /// Clears the state of the given TypoExpr.\n  void clearDelayedTypo(TypoExpr *TE);\n\n  /// Look up a name, looking for a single declaration.  Return\n  /// null if the results were absent, ambiguous, or overloaded.\n  ///\n  /// It is preferable to use the elaborated form and explicitly handle\n  /// ambiguity and overloaded.\n  NamedDecl *LookupSingleName(Scope *S, DeclarationName Name,\n                              SourceLocation Loc,\n                              LookupNameKind NameKind,\n                              RedeclarationKind Redecl\n                                = NotForRedeclaration);\n  bool LookupBuiltin(LookupResult &R);\n  void LookupNecessaryTypesForBuiltin(Scope *S, unsigned ID);\n  bool LookupName(LookupResult &R, Scope *S,\n                  bool AllowBuiltinCreation = false);\n  bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                           bool InUnqualifiedLookup = false);\n  bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                           CXXScopeSpec &SS);\n  bool LookupParsedName(LookupResult &R, Scope *S, CXXScopeSpec *SS,\n                        bool AllowBuiltinCreation = false,\n                        bool EnteringContext = false);\n  ObjCProtocolDecl *LookupProtocol(IdentifierInfo *II, SourceLocation IdLoc,\n                                   RedeclarationKind Redecl\n                                     = NotForRedeclaration);\n  bool LookupInSuper(LookupResult &R, CXXRecordDecl *Class);\n\n  void LookupOverloadedOperatorName(OverloadedOperatorKind Op, Scope *S,\n                                    UnresolvedSetImpl &Functions);\n\n  LabelDecl *LookupOrCreateLabel(IdentifierInfo *II, SourceLocation IdentLoc,\n                                 SourceLocation GnuLabelLoc = SourceLocation());\n\n  DeclContextLookupResult LookupConstructors(CXXRecordDecl *Class);\n  CXXConstructorDecl *LookupDefaultConstructor(CXXRecordDecl *Class);\n  CXXConstructorDecl *LookupCopyingConstructor(CXXRecordDecl *Class,\n                                               unsigned Quals);\n  CXXMethodDecl *LookupCopyingAssignment(CXXRecordDecl *Class, unsigned Quals,\n                                         bool RValueThis, unsigned ThisQuals);\n  CXXConstructorDecl *LookupMovingConstructor(CXXRecordDecl *Class,\n                                              unsigned Quals);\n  CXXMethodDecl *LookupMovingAssignment(CXXRecordDecl *Class, unsigned Quals,\n                                        bool RValueThis, unsigned ThisQuals);\n  CXXDestructorDecl *LookupDestructor(CXXRecordDecl *Class);\n\n  bool checkLiteralOperatorId(const CXXScopeSpec &SS, const UnqualifiedId &Id);\n  LiteralOperatorLookupResult\n  LookupLiteralOperator(Scope *S, LookupResult &R, ArrayRef<QualType> ArgTys,\n                        bool AllowRaw, bool AllowTemplate,\n                        bool AllowStringTemplate, bool DiagnoseMissing,\n                        StringLiteral *StringLit = nullptr);\n  bool isKnownName(StringRef name);\n\n  /// Status of the function emission on the CUDA/HIP/OpenMP host/device attrs.\n  enum class FunctionEmissionStatus {\n    Emitted,\n    CUDADiscarded,     // Discarded due to CUDA/HIP hostness\n    OMPDiscarded,      // Discarded due to OpenMP hostness\n    TemplateDiscarded, // Discarded due to uninstantiated templates\n    Unknown,\n  };\n  FunctionEmissionStatus getEmissionStatus(FunctionDecl *Decl,\n                                           bool Final = false);\n\n  // Whether the callee should be ignored in CUDA/HIP/OpenMP host/device check.\n  bool shouldIgnoreInHostDeviceCheck(FunctionDecl *Callee);\n\n  void ArgumentDependentLookup(DeclarationName Name, SourceLocation Loc,\n                               ArrayRef<Expr *> Args, ADLResult &Functions);\n\n  void LookupVisibleDecls(Scope *S, LookupNameKind Kind,\n                          VisibleDeclConsumer &Consumer,\n                          bool IncludeGlobalScope = true,\n                          bool LoadExternal = true);\n  void LookupVisibleDecls(DeclContext *Ctx, LookupNameKind Kind,\n                          VisibleDeclConsumer &Consumer,\n                          bool IncludeGlobalScope = true,\n                          bool IncludeDependentBases = false,\n                          bool LoadExternal = true);\n\n  enum CorrectTypoKind {\n    CTK_NonError,     // CorrectTypo used in a non error recovery situation.\n    CTK_ErrorRecovery // CorrectTypo used in normal error recovery.\n  };\n\n  TypoCorrection CorrectTypo(const DeclarationNameInfo &Typo,\n                             Sema::LookupNameKind LookupKind,\n                             Scope *S, CXXScopeSpec *SS,\n                             CorrectionCandidateCallback &CCC,\n                             CorrectTypoKind Mode,\n                             DeclContext *MemberContext = nullptr,\n                             bool EnteringContext = false,\n                             const ObjCObjectPointerType *OPT = nullptr,\n                             bool RecordFailure = true);\n\n  TypoExpr *CorrectTypoDelayed(const DeclarationNameInfo &Typo,\n                               Sema::LookupNameKind LookupKind, Scope *S,\n                               CXXScopeSpec *SS,\n                               CorrectionCandidateCallback &CCC,\n                               TypoDiagnosticGenerator TDG,\n                               TypoRecoveryCallback TRC, CorrectTypoKind Mode,\n                               DeclContext *MemberContext = nullptr,\n                               bool EnteringContext = false,\n                               const ObjCObjectPointerType *OPT = nullptr);\n\n  /// Process any TypoExprs in the given Expr and its children,\n  /// generating diagnostics as appropriate and returning a new Expr if there\n  /// were typos that were all successfully corrected and ExprError if one or\n  /// more typos could not be corrected.\n  ///\n  /// \\param E The Expr to check for TypoExprs.\n  ///\n  /// \\param InitDecl A VarDecl to avoid because the Expr being corrected is its\n  /// initializer.\n  ///\n  /// \\param RecoverUncorrectedTypos If true, when typo correction fails, it\n  /// will rebuild the given Expr with all TypoExprs degraded to RecoveryExprs.\n  ///\n  /// \\param Filter A function applied to a newly rebuilt Expr to determine if\n  /// it is an acceptable/usable result from a single combination of typo\n  /// corrections. As long as the filter returns ExprError, different\n  /// combinations of corrections will be tried until all are exhausted.\n  ExprResult CorrectDelayedTyposInExpr(\n      Expr *E, VarDecl *InitDecl = nullptr,\n      bool RecoverUncorrectedTypos = false,\n      llvm::function_ref<ExprResult(Expr *)> Filter =\n          [](Expr *E) -> ExprResult { return E; });\n\n  ExprResult CorrectDelayedTyposInExpr(\n      ExprResult ER, VarDecl *InitDecl = nullptr,\n      bool RecoverUncorrectedTypos = false,\n      llvm::function_ref<ExprResult(Expr *)> Filter =\n          [](Expr *E) -> ExprResult { return E; }) {\n    return ER.isInvalid()\n               ? ER\n               : CorrectDelayedTyposInExpr(ER.get(), InitDecl,\n                                           RecoverUncorrectedTypos, Filter);\n  }\n\n  void diagnoseTypo(const TypoCorrection &Correction,\n                    const PartialDiagnostic &TypoDiag,\n                    bool ErrorRecovery = true);\n\n  void diagnoseTypo(const TypoCorrection &Correction,\n                    const PartialDiagnostic &TypoDiag,\n                    const PartialDiagnostic &PrevNote,\n                    bool ErrorRecovery = true);\n\n  void MarkTypoCorrectedFunctionDefinition(const NamedDecl *F);\n\n  void FindAssociatedClassesAndNamespaces(SourceLocation InstantiationLoc,\n                                          ArrayRef<Expr *> Args,\n                                   AssociatedNamespaceSet &AssociatedNamespaces,\n                                   AssociatedClassSet &AssociatedClasses);\n\n  void FilterLookupForScope(LookupResult &R, DeclContext *Ctx, Scope *S,\n                            bool ConsiderLinkage, bool AllowInlineNamespace);\n\n  bool CheckRedeclarationModuleOwnership(NamedDecl *New, NamedDecl *Old);\n\n  void DiagnoseAmbiguousLookup(LookupResult &Result);\n  //@}\n\n  /// Attempts to produce a RecoveryExpr after some AST node cannot be created.\n  ExprResult CreateRecoveryExpr(SourceLocation Begin, SourceLocation End,\n                                ArrayRef<Expr *> SubExprs,\n                                QualType T = QualType());\n\n  ObjCInterfaceDecl *getObjCInterfaceDecl(IdentifierInfo *&Id,\n                                          SourceLocation IdLoc,\n                                          bool TypoCorrection = false);\n  FunctionDecl *CreateBuiltin(IdentifierInfo *II, QualType Type, unsigned ID,\n                              SourceLocation Loc);\n  NamedDecl *LazilyCreateBuiltin(IdentifierInfo *II, unsigned ID,\n                                 Scope *S, bool ForRedeclaration,\n                                 SourceLocation Loc);\n  NamedDecl *ImplicitlyDefineFunction(SourceLocation Loc, IdentifierInfo &II,\n                                      Scope *S);\n  void AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction(\n      FunctionDecl *FD);\n  void AddKnownFunctionAttributes(FunctionDecl *FD);\n\n  // More parsing and symbol table subroutines.\n\n  void ProcessPragmaWeak(Scope *S, Decl *D);\n  // Decl attributes - this routine is the top level dispatcher.\n  void ProcessDeclAttributes(Scope *S, Decl *D, const Declarator &PD);\n  // Helper for delayed processing of attributes.\n  void ProcessDeclAttributeDelayed(Decl *D,\n                                   const ParsedAttributesView &AttrList);\n  void ProcessDeclAttributeList(Scope *S, Decl *D, const ParsedAttributesView &AL,\n                             bool IncludeCXX11Attributes = true);\n  bool ProcessAccessDeclAttributeList(AccessSpecDecl *ASDecl,\n                                   const ParsedAttributesView &AttrList);\n\n  void checkUnusedDeclAttributes(Declarator &D);\n\n  /// Determine if type T is a valid subject for a nonnull and similar\n  /// attributes. By default, we look through references (the behavior used by\n  /// nonnull), but if the second parameter is true, then we treat a reference\n  /// type as valid.\n  bool isValidPointerAttrType(QualType T, bool RefOkay = false);\n\n  bool CheckRegparmAttr(const ParsedAttr &attr, unsigned &value);\n  bool CheckCallingConvAttr(const ParsedAttr &attr, CallingConv &CC,\n                            const FunctionDecl *FD = nullptr);\n  bool CheckAttrTarget(const ParsedAttr &CurrAttr);\n  bool CheckAttrNoArgs(const ParsedAttr &CurrAttr);\n  bool checkStringLiteralArgumentAttr(const ParsedAttr &Attr, unsigned ArgNum,\n                                      StringRef &Str,\n                                      SourceLocation *ArgLocation = nullptr);\n  bool checkSectionName(SourceLocation LiteralLoc, StringRef Str);\n  bool checkTargetAttr(SourceLocation LiteralLoc, StringRef Str);\n  bool checkMSInheritanceAttrOnDefinition(\n      CXXRecordDecl *RD, SourceRange Range, bool BestCase,\n      MSInheritanceModel SemanticSpelling);\n\n  void CheckAlignasUnderalignment(Decl *D);\n\n  /// Adjust the calling convention of a method to be the ABI default if it\n  /// wasn't specified explicitly.  This handles method types formed from\n  /// function type typedefs and typename template arguments.\n  void adjustMemberFunctionCC(QualType &T, bool IsStatic, bool IsCtorOrDtor,\n                              SourceLocation Loc);\n\n  // Check if there is an explicit attribute, but only look through parens.\n  // The intent is to look for an attribute on the current declarator, but not\n  // one that came from a typedef.\n  bool hasExplicitCallingConv(QualType T);\n\n  /// Get the outermost AttributedType node that sets a calling convention.\n  /// Valid types should not have multiple attributes with different CCs.\n  const AttributedType *getCallingConvAttributedType(QualType T) const;\n\n  /// Stmt attributes - this routine is the top level dispatcher.\n  StmtResult ProcessStmtAttributes(Stmt *Stmt,\n                                   const ParsedAttributesView &Attrs,\n                                   SourceRange Range);\n\n  void WarnConflictingTypedMethods(ObjCMethodDecl *Method,\n                                   ObjCMethodDecl *MethodDecl,\n                                   bool IsProtocolMethodDecl);\n\n  void CheckConflictingOverridingMethod(ObjCMethodDecl *Method,\n                                   ObjCMethodDecl *Overridden,\n                                   bool IsProtocolMethodDecl);\n\n  /// WarnExactTypedMethods - This routine issues a warning if method\n  /// implementation declaration matches exactly that of its declaration.\n  void WarnExactTypedMethods(ObjCMethodDecl *Method,\n                             ObjCMethodDecl *MethodDecl,\n                             bool IsProtocolMethodDecl);\n\n  typedef llvm::SmallPtrSet<Selector, 8> SelectorSet;\n\n  /// CheckImplementationIvars - This routine checks if the instance variables\n  /// listed in the implelementation match those listed in the interface.\n  void CheckImplementationIvars(ObjCImplementationDecl *ImpDecl,\n                                ObjCIvarDecl **Fields, unsigned nIvars,\n                                SourceLocation Loc);\n\n  /// ImplMethodsVsClassMethods - This is main routine to warn if any method\n  /// remains unimplemented in the class or category \\@implementation.\n  void ImplMethodsVsClassMethods(Scope *S, ObjCImplDecl* IMPDecl,\n                                 ObjCContainerDecl* IDecl,\n                                 bool IncompleteImpl = false);\n\n  /// DiagnoseUnimplementedProperties - This routine warns on those properties\n  /// which must be implemented by this implementation.\n  void DiagnoseUnimplementedProperties(Scope *S, ObjCImplDecl* IMPDecl,\n                                       ObjCContainerDecl *CDecl,\n                                       bool SynthesizeProperties);\n\n  /// Diagnose any null-resettable synthesized setters.\n  void diagnoseNullResettableSynthesizedSetters(const ObjCImplDecl *impDecl);\n\n  /// DefaultSynthesizeProperties - This routine default synthesizes all\n  /// properties which must be synthesized in the class's \\@implementation.\n  void DefaultSynthesizeProperties(Scope *S, ObjCImplDecl *IMPDecl,\n                                   ObjCInterfaceDecl *IDecl,\n                                   SourceLocation AtEnd);\n  void DefaultSynthesizeProperties(Scope *S, Decl *D, SourceLocation AtEnd);\n\n  /// IvarBacksCurrentMethodAccessor - This routine returns 'true' if 'IV' is\n  /// an ivar synthesized for 'Method' and 'Method' is a property accessor\n  /// declared in class 'IFace'.\n  bool IvarBacksCurrentMethodAccessor(ObjCInterfaceDecl *IFace,\n                                      ObjCMethodDecl *Method, ObjCIvarDecl *IV);\n\n  /// DiagnoseUnusedBackingIvarInAccessor - Issue an 'unused' warning if ivar which\n  /// backs the property is not used in the property's accessor.\n  void DiagnoseUnusedBackingIvarInAccessor(Scope *S,\n                                           const ObjCImplementationDecl *ImplD);\n\n  /// GetIvarBackingPropertyAccessor - If method is a property setter/getter and\n  /// it property has a backing ivar, returns this ivar; otherwise, returns NULL.\n  /// It also returns ivar's property on success.\n  ObjCIvarDecl *GetIvarBackingPropertyAccessor(const ObjCMethodDecl *Method,\n                                               const ObjCPropertyDecl *&PDecl) const;\n\n  /// Called by ActOnProperty to handle \\@property declarations in\n  /// class extensions.\n  ObjCPropertyDecl *HandlePropertyInClassExtension(Scope *S,\n                      SourceLocation AtLoc,\n                      SourceLocation LParenLoc,\n                      FieldDeclarator &FD,\n                      Selector GetterSel,\n                      SourceLocation GetterNameLoc,\n                      Selector SetterSel,\n                      SourceLocation SetterNameLoc,\n                      const bool isReadWrite,\n                      unsigned &Attributes,\n                      const unsigned AttributesAsWritten,\n                      QualType T,\n                      TypeSourceInfo *TSI,\n                      tok::ObjCKeywordKind MethodImplKind);\n\n  /// Called by ActOnProperty and HandlePropertyInClassExtension to\n  /// handle creating the ObjcPropertyDecl for a category or \\@interface.\n  ObjCPropertyDecl *CreatePropertyDecl(Scope *S,\n                                       ObjCContainerDecl *CDecl,\n                                       SourceLocation AtLoc,\n                                       SourceLocation LParenLoc,\n                                       FieldDeclarator &FD,\n                                       Selector GetterSel,\n                                       SourceLocation GetterNameLoc,\n                                       Selector SetterSel,\n                                       SourceLocation SetterNameLoc,\n                                       const bool isReadWrite,\n                                       const unsigned Attributes,\n                                       const unsigned AttributesAsWritten,\n                                       QualType T,\n                                       TypeSourceInfo *TSI,\n                                       tok::ObjCKeywordKind MethodImplKind,\n                                       DeclContext *lexicalDC = nullptr);\n\n  /// AtomicPropertySetterGetterRules - This routine enforces the rule (via\n  /// warning) when atomic property has one but not the other user-declared\n  /// setter or getter.\n  void AtomicPropertySetterGetterRules(ObjCImplDecl* IMPDecl,\n                                       ObjCInterfaceDecl* IDecl);\n\n  void DiagnoseOwningPropertyGetterSynthesis(const ObjCImplementationDecl *D);\n\n  void DiagnoseMissingDesignatedInitOverrides(\n                                          const ObjCImplementationDecl *ImplD,\n                                          const ObjCInterfaceDecl *IFD);\n\n  void DiagnoseDuplicateIvars(ObjCInterfaceDecl *ID, ObjCInterfaceDecl *SID);\n\n  enum MethodMatchStrategy {\n    MMS_loose,\n    MMS_strict\n  };\n\n  /// MatchTwoMethodDeclarations - Checks if two methods' type match and returns\n  /// true, or false, accordingly.\n  bool MatchTwoMethodDeclarations(const ObjCMethodDecl *Method,\n                                  const ObjCMethodDecl *PrevMethod,\n                                  MethodMatchStrategy strategy = MMS_strict);\n\n  /// MatchAllMethodDeclarations - Check methods declaraed in interface or\n  /// or protocol against those declared in their implementations.\n  void MatchAllMethodDeclarations(const SelectorSet &InsMap,\n                                  const SelectorSet &ClsMap,\n                                  SelectorSet &InsMapSeen,\n                                  SelectorSet &ClsMapSeen,\n                                  ObjCImplDecl* IMPDecl,\n                                  ObjCContainerDecl* IDecl,\n                                  bool &IncompleteImpl,\n                                  bool ImmediateClass,\n                                  bool WarnCategoryMethodImpl=false);\n\n  /// CheckCategoryVsClassMethodMatches - Checks that methods implemented in\n  /// category matches with those implemented in its primary class and\n  /// warns each time an exact match is found.\n  void CheckCategoryVsClassMethodMatches(ObjCCategoryImplDecl *CatIMP);\n\n  /// Add the given method to the list of globally-known methods.\n  void addMethodToGlobalList(ObjCMethodList *List, ObjCMethodDecl *Method);\n\n  /// Returns default addr space for method qualifiers.\n  LangAS getDefaultCXXMethodAddrSpace() const;\n\nprivate:\n  /// AddMethodToGlobalPool - Add an instance or factory method to the global\n  /// pool. See descriptoin of AddInstanceMethodToGlobalPool.\n  void AddMethodToGlobalPool(ObjCMethodDecl *Method, bool impl, bool instance);\n\n  /// LookupMethodInGlobalPool - Returns the instance or factory method and\n  /// optionally warns if there are multiple signatures.\n  ObjCMethodDecl *LookupMethodInGlobalPool(Selector Sel, SourceRange R,\n                                           bool receiverIdOrClass,\n                                           bool instance);\n\npublic:\n  /// - Returns instance or factory methods in global method pool for\n  /// given selector. It checks the desired kind first, if none is found, and\n  /// parameter checkTheOther is set, it then checks the other kind. If no such\n  /// method or only one method is found, function returns false; otherwise, it\n  /// returns true.\n  bool\n  CollectMultipleMethodsInGlobalPool(Selector Sel,\n                                     SmallVectorImpl<ObjCMethodDecl*>& Methods,\n                                     bool InstanceFirst, bool CheckTheOther,\n                                     const ObjCObjectType *TypeBound = nullptr);\n\n  bool\n  AreMultipleMethodsInGlobalPool(Selector Sel, ObjCMethodDecl *BestMethod,\n                                 SourceRange R, bool receiverIdOrClass,\n                                 SmallVectorImpl<ObjCMethodDecl*>& Methods);\n\n  void\n  DiagnoseMultipleMethodInGlobalPool(SmallVectorImpl<ObjCMethodDecl*> &Methods,\n                                     Selector Sel, SourceRange R,\n                                     bool receiverIdOrClass);\n\nprivate:\n  /// - Returns a selector which best matches given argument list or\n  /// nullptr if none could be found\n  ObjCMethodDecl *SelectBestMethod(Selector Sel, MultiExprArg Args,\n                                   bool IsInstance,\n                                   SmallVectorImpl<ObjCMethodDecl*>& Methods);\n\n\n  /// Record the typo correction failure and return an empty correction.\n  TypoCorrection FailedCorrection(IdentifierInfo *Typo, SourceLocation TypoLoc,\n                                  bool RecordFailure = true) {\n    if (RecordFailure)\n      TypoCorrectionFailures[Typo].insert(TypoLoc);\n    return TypoCorrection();\n  }\n\npublic:\n  /// AddInstanceMethodToGlobalPool - All instance methods in a translation\n  /// unit are added to a global pool. This allows us to efficiently associate\n  /// a selector with a method declaraation for purposes of typechecking\n  /// messages sent to \"id\" (where the class of the object is unknown).\n  void AddInstanceMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {\n    AddMethodToGlobalPool(Method, impl, /*instance*/true);\n  }\n\n  /// AddFactoryMethodToGlobalPool - Same as above, but for factory methods.\n  void AddFactoryMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {\n    AddMethodToGlobalPool(Method, impl, /*instance*/false);\n  }\n\n  /// AddAnyMethodToGlobalPool - Add any method, instance or factory to global\n  /// pool.\n  void AddAnyMethodToGlobalPool(Decl *D);\n\n  /// LookupInstanceMethodInGlobalPool - Returns the method and warns if\n  /// there are multiple signatures.\n  ObjCMethodDecl *LookupInstanceMethodInGlobalPool(Selector Sel, SourceRange R,\n                                                   bool receiverIdOrClass=false) {\n    return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,\n                                    /*instance*/true);\n  }\n\n  /// LookupFactoryMethodInGlobalPool - Returns the method and warns if\n  /// there are multiple signatures.\n  ObjCMethodDecl *LookupFactoryMethodInGlobalPool(Selector Sel, SourceRange R,\n                                                  bool receiverIdOrClass=false) {\n    return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,\n                                    /*instance*/false);\n  }\n\n  const ObjCMethodDecl *SelectorsForTypoCorrection(Selector Sel,\n                              QualType ObjectType=QualType());\n  /// LookupImplementedMethodInGlobalPool - Returns the method which has an\n  /// implementation.\n  ObjCMethodDecl *LookupImplementedMethodInGlobalPool(Selector Sel);\n\n  /// CollectIvarsToConstructOrDestruct - Collect those ivars which require\n  /// initialization.\n  void CollectIvarsToConstructOrDestruct(ObjCInterfaceDecl *OI,\n                                  SmallVectorImpl<ObjCIvarDecl*> &Ivars);\n\n  //===--------------------------------------------------------------------===//\n  // Statement Parsing Callbacks: SemaStmt.cpp.\npublic:\n  class FullExprArg {\n  public:\n    FullExprArg() : E(nullptr) { }\n    FullExprArg(Sema &actions) : E(nullptr) { }\n\n    ExprResult release() {\n      return E;\n    }\n\n    Expr *get() const { return E; }\n\n    Expr *operator->() {\n      return E;\n    }\n\n  private:\n    // FIXME: No need to make the entire Sema class a friend when it's just\n    // Sema::MakeFullExpr that needs access to the constructor below.\n    friend class Sema;\n\n    explicit FullExprArg(Expr *expr) : E(expr) {}\n\n    Expr *E;\n  };\n\n  FullExprArg MakeFullExpr(Expr *Arg) {\n    return MakeFullExpr(Arg, Arg ? Arg->getExprLoc() : SourceLocation());\n  }\n  FullExprArg MakeFullExpr(Expr *Arg, SourceLocation CC) {\n    return FullExprArg(\n        ActOnFinishFullExpr(Arg, CC, /*DiscardedValue*/ false).get());\n  }\n  FullExprArg MakeFullDiscardedValueExpr(Expr *Arg) {\n    ExprResult FE =\n        ActOnFinishFullExpr(Arg, Arg ? Arg->getExprLoc() : SourceLocation(),\n                            /*DiscardedValue*/ true);\n    return FullExprArg(FE.get());\n  }\n\n  StmtResult ActOnExprStmt(ExprResult Arg, bool DiscardedValue = true);\n  StmtResult ActOnExprStmtError();\n\n  StmtResult ActOnNullStmt(SourceLocation SemiLoc,\n                           bool HasLeadingEmptyMacro = false);\n\n  void ActOnStartOfCompoundStmt(bool IsStmtExpr);\n  void ActOnAfterCompoundStatementLeadingPragmas();\n  void ActOnFinishOfCompoundStmt();\n  StmtResult ActOnCompoundStmt(SourceLocation L, SourceLocation R,\n                               ArrayRef<Stmt *> Elts, bool isStmtExpr);\n\n  /// A RAII object to enter scope of a compound statement.\n  class CompoundScopeRAII {\n  public:\n    CompoundScopeRAII(Sema &S, bool IsStmtExpr = false) : S(S) {\n      S.ActOnStartOfCompoundStmt(IsStmtExpr);\n    }\n\n    ~CompoundScopeRAII() {\n      S.ActOnFinishOfCompoundStmt();\n    }\n\n  private:\n    Sema &S;\n  };\n\n  /// An RAII helper that pops function a function scope on exit.\n  struct FunctionScopeRAII {\n    Sema &S;\n    bool Active;\n    FunctionScopeRAII(Sema &S) : S(S), Active(true) {}\n    ~FunctionScopeRAII() {\n      if (Active)\n        S.PopFunctionScopeInfo();\n    }\n    void disable() { Active = false; }\n  };\n\n  StmtResult ActOnDeclStmt(DeclGroupPtrTy Decl,\n                                   SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  void ActOnForEachDeclStmt(DeclGroupPtrTy Decl);\n  StmtResult ActOnForEachLValueExpr(Expr *E);\n  ExprResult ActOnCaseExpr(SourceLocation CaseLoc, ExprResult Val);\n  StmtResult ActOnCaseStmt(SourceLocation CaseLoc, ExprResult LHS,\n                           SourceLocation DotDotDotLoc, ExprResult RHS,\n                           SourceLocation ColonLoc);\n  void ActOnCaseStmtBody(Stmt *CaseStmt, Stmt *SubStmt);\n\n  StmtResult ActOnDefaultStmt(SourceLocation DefaultLoc,\n                                      SourceLocation ColonLoc,\n                                      Stmt *SubStmt, Scope *CurScope);\n  StmtResult ActOnLabelStmt(SourceLocation IdentLoc, LabelDecl *TheDecl,\n                            SourceLocation ColonLoc, Stmt *SubStmt);\n\n  StmtResult ActOnAttributedStmt(SourceLocation AttrLoc,\n                                 ArrayRef<const Attr*> Attrs,\n                                 Stmt *SubStmt);\n\n  class ConditionResult;\n  StmtResult ActOnIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                         SourceLocation LParenLoc, Stmt *InitStmt,\n                         ConditionResult Cond, SourceLocation RParenLoc,\n                         Stmt *ThenVal, SourceLocation ElseLoc, Stmt *ElseVal);\n  StmtResult BuildIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                         SourceLocation LParenLoc, Stmt *InitStmt,\n                         ConditionResult Cond, SourceLocation RParenLoc,\n                         Stmt *ThenVal, SourceLocation ElseLoc, Stmt *ElseVal);\n  StmtResult ActOnStartOfSwitchStmt(SourceLocation SwitchLoc,\n                                    SourceLocation LParenLoc, Stmt *InitStmt,\n                                    ConditionResult Cond,\n                                    SourceLocation RParenLoc);\n  StmtResult ActOnFinishSwitchStmt(SourceLocation SwitchLoc,\n                                           Stmt *Switch, Stmt *Body);\n  StmtResult ActOnWhileStmt(SourceLocation WhileLoc, SourceLocation LParenLoc,\n                            ConditionResult Cond, SourceLocation RParenLoc,\n                            Stmt *Body);\n  StmtResult ActOnDoStmt(SourceLocation DoLoc, Stmt *Body,\n                         SourceLocation WhileLoc, SourceLocation CondLParen,\n                         Expr *Cond, SourceLocation CondRParen);\n\n  StmtResult ActOnForStmt(SourceLocation ForLoc,\n                          SourceLocation LParenLoc,\n                          Stmt *First,\n                          ConditionResult Second,\n                          FullExprArg Third,\n                          SourceLocation RParenLoc,\n                          Stmt *Body);\n  ExprResult CheckObjCForCollectionOperand(SourceLocation forLoc,\n                                           Expr *collection);\n  StmtResult ActOnObjCForCollectionStmt(SourceLocation ForColLoc,\n                                        Stmt *First, Expr *collection,\n                                        SourceLocation RParenLoc);\n  StmtResult FinishObjCForCollectionStmt(Stmt *ForCollection, Stmt *Body);\n\n  enum BuildForRangeKind {\n    /// Initial building of a for-range statement.\n    BFRK_Build,\n    /// Instantiation or recovery rebuild of a for-range statement. Don't\n    /// attempt any typo-correction.\n    BFRK_Rebuild,\n    /// Determining whether a for-range statement could be built. Avoid any\n    /// unnecessary or irreversible actions.\n    BFRK_Check\n  };\n\n  StmtResult ActOnCXXForRangeStmt(Scope *S, SourceLocation ForLoc,\n                                  SourceLocation CoawaitLoc,\n                                  Stmt *InitStmt,\n                                  Stmt *LoopVar,\n                                  SourceLocation ColonLoc, Expr *Collection,\n                                  SourceLocation RParenLoc,\n                                  BuildForRangeKind Kind);\n  StmtResult BuildCXXForRangeStmt(SourceLocation ForLoc,\n                                  SourceLocation CoawaitLoc,\n                                  Stmt *InitStmt,\n                                  SourceLocation ColonLoc,\n                                  Stmt *RangeDecl, Stmt *Begin, Stmt *End,\n                                  Expr *Cond, Expr *Inc,\n                                  Stmt *LoopVarDecl,\n                                  SourceLocation RParenLoc,\n                                  BuildForRangeKind Kind);\n  StmtResult FinishCXXForRangeStmt(Stmt *ForRange, Stmt *Body);\n\n  StmtResult ActOnGotoStmt(SourceLocation GotoLoc,\n                           SourceLocation LabelLoc,\n                           LabelDecl *TheDecl);\n  StmtResult ActOnIndirectGotoStmt(SourceLocation GotoLoc,\n                                   SourceLocation StarLoc,\n                                   Expr *DestExp);\n  StmtResult ActOnContinueStmt(SourceLocation ContinueLoc, Scope *CurScope);\n  StmtResult ActOnBreakStmt(SourceLocation BreakLoc, Scope *CurScope);\n\n  void ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                CapturedRegionKind Kind, unsigned NumParams);\n  typedef std::pair<StringRef, QualType> CapturedParamNameType;\n  void ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                CapturedRegionKind Kind,\n                                ArrayRef<CapturedParamNameType> Params,\n                                unsigned OpenMPCaptureLevel = 0);\n  StmtResult ActOnCapturedRegionEnd(Stmt *S);\n  void ActOnCapturedRegionError();\n  RecordDecl *CreateCapturedStmtRecordDecl(CapturedDecl *&CD,\n                                           SourceLocation Loc,\n                                           unsigned NumParams);\n\n  enum CopyElisionSemanticsKind {\n    CES_Strict = 0,\n    CES_AllowParameters = 1,\n    CES_AllowDifferentTypes = 2,\n    CES_AllowExceptionVariables = 4,\n    CES_AllowRValueReferenceType = 8,\n    CES_ImplicitlyMovableCXX11CXX14CXX17 =\n        (CES_AllowParameters | CES_AllowDifferentTypes),\n    CES_ImplicitlyMovableCXX20 =\n        (CES_AllowParameters | CES_AllowDifferentTypes |\n         CES_AllowExceptionVariables | CES_AllowRValueReferenceType),\n  };\n\n  VarDecl *getCopyElisionCandidate(QualType ReturnType, Expr *E,\n                                   CopyElisionSemanticsKind CESK);\n  bool isCopyElisionCandidate(QualType ReturnType, const VarDecl *VD,\n                              CopyElisionSemanticsKind CESK);\n\n  StmtResult ActOnReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp,\n                             Scope *CurScope);\n  StmtResult BuildReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp);\n  StmtResult ActOnCapScopeReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp);\n\n  StmtResult ActOnGCCAsmStmt(SourceLocation AsmLoc, bool IsSimple,\n                             bool IsVolatile, unsigned NumOutputs,\n                             unsigned NumInputs, IdentifierInfo **Names,\n                             MultiExprArg Constraints, MultiExprArg Exprs,\n                             Expr *AsmString, MultiExprArg Clobbers,\n                             unsigned NumLabels,\n                             SourceLocation RParenLoc);\n\n  void FillInlineAsmIdentifierInfo(Expr *Res,\n                                   llvm::InlineAsmIdentifierInfo &Info);\n  ExprResult LookupInlineAsmIdentifier(CXXScopeSpec &SS,\n                                       SourceLocation TemplateKWLoc,\n                                       UnqualifiedId &Id,\n                                       bool IsUnevaluatedContext);\n  bool LookupInlineAsmField(StringRef Base, StringRef Member,\n                            unsigned &Offset, SourceLocation AsmLoc);\n  ExprResult LookupInlineAsmVarDeclField(Expr *RefExpr, StringRef Member,\n                                         SourceLocation AsmLoc);\n  StmtResult ActOnMSAsmStmt(SourceLocation AsmLoc, SourceLocation LBraceLoc,\n                            ArrayRef<Token> AsmToks,\n                            StringRef AsmString,\n                            unsigned NumOutputs, unsigned NumInputs,\n                            ArrayRef<StringRef> Constraints,\n                            ArrayRef<StringRef> Clobbers,\n                            ArrayRef<Expr*> Exprs,\n                            SourceLocation EndLoc);\n  LabelDecl *GetOrCreateMSAsmLabel(StringRef ExternalLabelName,\n                                   SourceLocation Location,\n                                   bool AlwaysCreate);\n\n  VarDecl *BuildObjCExceptionDecl(TypeSourceInfo *TInfo, QualType ExceptionType,\n                                  SourceLocation StartLoc,\n                                  SourceLocation IdLoc, IdentifierInfo *Id,\n                                  bool Invalid = false);\n\n  Decl *ActOnObjCExceptionDecl(Scope *S, Declarator &D);\n\n  StmtResult ActOnObjCAtCatchStmt(SourceLocation AtLoc, SourceLocation RParen,\n                                  Decl *Parm, Stmt *Body);\n\n  StmtResult ActOnObjCAtFinallyStmt(SourceLocation AtLoc, Stmt *Body);\n\n  StmtResult ActOnObjCAtTryStmt(SourceLocation AtLoc, Stmt *Try,\n                                MultiStmtArg Catch, Stmt *Finally);\n\n  StmtResult BuildObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw);\n  StmtResult ActOnObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw,\n                                  Scope *CurScope);\n  ExprResult ActOnObjCAtSynchronizedOperand(SourceLocation atLoc,\n                                            Expr *operand);\n  StmtResult ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc,\n                                         Expr *SynchExpr,\n                                         Stmt *SynchBody);\n\n  StmtResult ActOnObjCAutoreleasePoolStmt(SourceLocation AtLoc, Stmt *Body);\n\n  VarDecl *BuildExceptionDeclaration(Scope *S, TypeSourceInfo *TInfo,\n                                     SourceLocation StartLoc,\n                                     SourceLocation IdLoc,\n                                     IdentifierInfo *Id);\n\n  Decl *ActOnExceptionDeclarator(Scope *S, Declarator &D);\n\n  StmtResult ActOnCXXCatchBlock(SourceLocation CatchLoc,\n                                Decl *ExDecl, Stmt *HandlerBlock);\n  StmtResult ActOnCXXTryBlock(SourceLocation TryLoc, Stmt *TryBlock,\n                              ArrayRef<Stmt *> Handlers);\n\n  StmtResult ActOnSEHTryBlock(bool IsCXXTry, // try (true) or __try (false) ?\n                              SourceLocation TryLoc, Stmt *TryBlock,\n                              Stmt *Handler);\n  StmtResult ActOnSEHExceptBlock(SourceLocation Loc,\n                                 Expr *FilterExpr,\n                                 Stmt *Block);\n  void ActOnStartSEHFinallyBlock();\n  void ActOnAbortSEHFinallyBlock();\n  StmtResult ActOnFinishSEHFinallyBlock(SourceLocation Loc, Stmt *Block);\n  StmtResult ActOnSEHLeaveStmt(SourceLocation Loc, Scope *CurScope);\n\n  void DiagnoseReturnInConstructorExceptionHandler(CXXTryStmt *TryBlock);\n\n  bool ShouldWarnIfUnusedFileScopedDecl(const DeclaratorDecl *D) const;\n\n  /// If it's a file scoped decl that must warn if not used, keep track\n  /// of it.\n  void MarkUnusedFileScopedDecl(const DeclaratorDecl *D);\n\n  /// DiagnoseUnusedExprResult - If the statement passed in is an expression\n  /// whose result is unused, warn.\n  void DiagnoseUnusedExprResult(const Stmt *S);\n  void DiagnoseUnusedNestedTypedefs(const RecordDecl *D);\n  void DiagnoseUnusedDecl(const NamedDecl *ND);\n\n  /// Emit \\p DiagID if statement located on \\p StmtLoc has a suspicious null\n  /// statement as a \\p Body, and it is located on the same line.\n  ///\n  /// This helps prevent bugs due to typos, such as:\n  ///     if (condition);\n  ///       do_stuff();\n  void DiagnoseEmptyStmtBody(SourceLocation StmtLoc,\n                             const Stmt *Body,\n                             unsigned DiagID);\n\n  /// Warn if a for/while loop statement \\p S, which is followed by\n  /// \\p PossibleBody, has a suspicious null statement as a body.\n  void DiagnoseEmptyLoopBody(const Stmt *S,\n                             const Stmt *PossibleBody);\n\n  /// Warn if a value is moved to itself.\n  void DiagnoseSelfMove(const Expr *LHSExpr, const Expr *RHSExpr,\n                        SourceLocation OpLoc);\n\n  /// Warn if we're implicitly casting from a _Nullable pointer type to a\n  /// _Nonnull one.\n  void diagnoseNullableToNonnullConversion(QualType DstType, QualType SrcType,\n                                           SourceLocation Loc);\n\n  /// Warn when implicitly casting 0 to nullptr.\n  void diagnoseZeroToNullptrConversion(CastKind Kind, const Expr *E);\n\n  ParsingDeclState PushParsingDeclaration(sema::DelayedDiagnosticPool &pool) {\n    return DelayedDiagnostics.push(pool);\n  }\n  void PopParsingDeclaration(ParsingDeclState state, Decl *decl);\n\n  typedef ProcessingContextState ParsingClassState;\n  ParsingClassState PushParsingClass() {\n    ParsingClassDepth++;\n    return DelayedDiagnostics.pushUndelayed();\n  }\n  void PopParsingClass(ParsingClassState state) {\n    ParsingClassDepth--;\n    DelayedDiagnostics.popUndelayed(state);\n  }\n\n  void redelayDiagnostics(sema::DelayedDiagnosticPool &pool);\n\n  void DiagnoseAvailabilityOfDecl(NamedDecl *D, ArrayRef<SourceLocation> Locs,\n                                  const ObjCInterfaceDecl *UnknownObjCClass,\n                                  bool ObjCPropertyAccess,\n                                  bool AvoidPartialAvailabilityChecks = false,\n                                  ObjCInterfaceDecl *ClassReceiver = nullptr);\n\n  bool makeUnavailableInSystemHeader(SourceLocation loc,\n                                     UnavailableAttr::ImplicitReason reason);\n\n  /// Issue any -Wunguarded-availability warnings in \\c FD\n  void DiagnoseUnguardedAvailabilityViolations(Decl *FD);\n\n  void handleDelayedAvailabilityCheck(sema::DelayedDiagnostic &DD, Decl *Ctx);\n\n  //===--------------------------------------------------------------------===//\n  // Expression Parsing Callbacks: SemaExpr.cpp.\n\n  bool CanUseDecl(NamedDecl *D, bool TreatUnavailableAsInvalid);\n  bool DiagnoseUseOfDecl(NamedDecl *D, ArrayRef<SourceLocation> Locs,\n                         const ObjCInterfaceDecl *UnknownObjCClass = nullptr,\n                         bool ObjCPropertyAccess = false,\n                         bool AvoidPartialAvailabilityChecks = false,\n                         ObjCInterfaceDecl *ClassReciever = nullptr);\n  void NoteDeletedFunction(FunctionDecl *FD);\n  void NoteDeletedInheritingConstructor(CXXConstructorDecl *CD);\n  bool DiagnosePropertyAccessorMismatch(ObjCPropertyDecl *PD,\n                                        ObjCMethodDecl *Getter,\n                                        SourceLocation Loc);\n  void DiagnoseSentinelCalls(NamedDecl *D, SourceLocation Loc,\n                             ArrayRef<Expr *> Args);\n\n  void PushExpressionEvaluationContext(\n      ExpressionEvaluationContext NewContext, Decl *LambdaContextDecl = nullptr,\n      ExpressionEvaluationContextRecord::ExpressionKind Type =\n          ExpressionEvaluationContextRecord::EK_Other);\n  enum ReuseLambdaContextDecl_t { ReuseLambdaContextDecl };\n  void PushExpressionEvaluationContext(\n      ExpressionEvaluationContext NewContext, ReuseLambdaContextDecl_t,\n      ExpressionEvaluationContextRecord::ExpressionKind Type =\n          ExpressionEvaluationContextRecord::EK_Other);\n  void PopExpressionEvaluationContext();\n\n  void DiscardCleanupsInEvaluationContext();\n\n  ExprResult TransformToPotentiallyEvaluated(Expr *E);\n  ExprResult HandleExprEvaluationContextForTypeof(Expr *E);\n\n  ExprResult CheckUnevaluatedOperand(Expr *E);\n  void CheckUnusedVolatileAssignment(Expr *E);\n\n  ExprResult ActOnConstantExpression(ExprResult Res);\n\n  // Functions for marking a declaration referenced.  These functions also\n  // contain the relevant logic for marking if a reference to a function or\n  // variable is an odr-use (in the C++11 sense).  There are separate variants\n  // for expressions referring to a decl; these exist because odr-use marking\n  // needs to be delayed for some constant variables when we build one of the\n  // named expressions.\n  //\n  // MightBeOdrUse indicates whether the use could possibly be an odr-use, and\n  // should usually be true. This only needs to be set to false if the lack of\n  // odr-use cannot be determined from the current context (for instance,\n  // because the name denotes a virtual function and was written without an\n  // explicit nested-name-specifier).\n  void MarkAnyDeclReferenced(SourceLocation Loc, Decl *D, bool MightBeOdrUse);\n  void MarkFunctionReferenced(SourceLocation Loc, FunctionDecl *Func,\n                              bool MightBeOdrUse = true);\n  void MarkVariableReferenced(SourceLocation Loc, VarDecl *Var);\n  void MarkDeclRefReferenced(DeclRefExpr *E, const Expr *Base = nullptr);\n  void MarkMemberReferenced(MemberExpr *E);\n  void MarkFunctionParmPackReferenced(FunctionParmPackExpr *E);\n  void MarkCaptureUsedInEnclosingContext(VarDecl *Capture, SourceLocation Loc,\n                                         unsigned CapturingScopeIndex);\n\n  ExprResult CheckLValueToRValueConversionOperand(Expr *E);\n  void CleanupVarDeclMarking();\n\n  enum TryCaptureKind {\n    TryCapture_Implicit, TryCapture_ExplicitByVal, TryCapture_ExplicitByRef\n  };\n\n  /// Try to capture the given variable.\n  ///\n  /// \\param Var The variable to capture.\n  ///\n  /// \\param Loc The location at which the capture occurs.\n  ///\n  /// \\param Kind The kind of capture, which may be implicit (for either a\n  /// block or a lambda), or explicit by-value or by-reference (for a lambda).\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis, if one is provided in\n  /// an explicit lambda capture.\n  ///\n  /// \\param BuildAndDiagnose Whether we are actually supposed to add the\n  /// captures or diagnose errors. If false, this routine merely check whether\n  /// the capture can occur without performing the capture itself or complaining\n  /// if the variable cannot be captured.\n  ///\n  /// \\param CaptureType Will be set to the type of the field used to capture\n  /// this variable in the innermost block or lambda. Only valid when the\n  /// variable can be captured.\n  ///\n  /// \\param DeclRefType Will be set to the type of a reference to the capture\n  /// from within the current scope. Only valid when the variable can be\n  /// captured.\n  ///\n  /// \\param FunctionScopeIndexToStopAt If non-null, it points to the index\n  /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.\n  /// This is useful when enclosing lambdas must speculatively capture\n  /// variables that may or may not be used in certain specializations of\n  /// a nested generic lambda.\n  ///\n  /// \\returns true if an error occurred (i.e., the variable cannot be\n  /// captured) and false if the capture succeeded.\n  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc, TryCaptureKind Kind,\n                          SourceLocation EllipsisLoc, bool BuildAndDiagnose,\n                          QualType &CaptureType,\n                          QualType &DeclRefType,\n                          const unsigned *const FunctionScopeIndexToStopAt);\n\n  /// Try to capture the given variable.\n  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc,\n                          TryCaptureKind Kind = TryCapture_Implicit,\n                          SourceLocation EllipsisLoc = SourceLocation());\n\n  /// Checks if the variable must be captured.\n  bool NeedToCaptureVariable(VarDecl *Var, SourceLocation Loc);\n\n  /// Given a variable, determine the type that a reference to that\n  /// variable will have in the given scope.\n  QualType getCapturedDeclRefType(VarDecl *Var, SourceLocation Loc);\n\n  /// Mark all of the declarations referenced within a particular AST node as\n  /// referenced. Used when template instantiation instantiates a non-dependent\n  /// type -- entities referenced by the type are now referenced.\n  void MarkDeclarationsReferencedInType(SourceLocation Loc, QualType T);\n  void MarkDeclarationsReferencedInExpr(Expr *E,\n                                        bool SkipLocalVariables = false);\n\n  /// Try to recover by turning the given expression into a\n  /// call.  Returns true if recovery was attempted or an error was\n  /// emitted; this may also leave the ExprResult invalid.\n  bool tryToRecoverWithCall(ExprResult &E, const PartialDiagnostic &PD,\n                            bool ForceComplain = false,\n                            bool (*IsPlausibleResult)(QualType) = nullptr);\n\n  /// Figure out if an expression could be turned into a call.\n  bool tryExprAsCall(Expr &E, QualType &ZeroArgCallReturnTy,\n                     UnresolvedSetImpl &NonTemplateOverloads);\n\n  /// Try to convert an expression \\p E to type \\p Ty. Returns the result of the\n  /// conversion.\n  ExprResult tryConvertExprToType(Expr *E, QualType Ty);\n\n  /// Conditionally issue a diagnostic based on the current\n  /// evaluation context.\n  ///\n  /// \\param Statement If Statement is non-null, delay reporting the\n  /// diagnostic until the function body is parsed, and then do a basic\n  /// reachability analysis to determine if the statement is reachable.\n  /// If it is unreachable, the diagnostic will not be emitted.\n  bool DiagRuntimeBehavior(SourceLocation Loc, const Stmt *Statement,\n                           const PartialDiagnostic &PD);\n  /// Similar, but diagnostic is only produced if all the specified statements\n  /// are reachable.\n  bool DiagRuntimeBehavior(SourceLocation Loc, ArrayRef<const Stmt*> Stmts,\n                           const PartialDiagnostic &PD);\n\n  // Primary Expressions.\n  SourceRange getExprRange(Expr *E) const;\n\n  ExprResult ActOnIdExpression(\n      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      UnqualifiedId &Id, bool HasTrailingLParen, bool IsAddressOfOperand,\n      CorrectionCandidateCallback *CCC = nullptr,\n      bool IsInlineAsmIdentifier = false, Token *KeywordReplacement = nullptr);\n\n  void DecomposeUnqualifiedId(const UnqualifiedId &Id,\n                              TemplateArgumentListInfo &Buffer,\n                              DeclarationNameInfo &NameInfo,\n                              const TemplateArgumentListInfo *&TemplateArgs);\n\n  bool DiagnoseDependentMemberLookup(LookupResult &R);\n\n  bool\n  DiagnoseEmptyLookup(Scope *S, CXXScopeSpec &SS, LookupResult &R,\n                      CorrectionCandidateCallback &CCC,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,\n                      ArrayRef<Expr *> Args = None, TypoExpr **Out = nullptr);\n\n  DeclResult LookupIvarInObjCMethod(LookupResult &Lookup, Scope *S,\n                                    IdentifierInfo *II);\n  ExprResult BuildIvarRefExpr(Scope *S, SourceLocation Loc, ObjCIvarDecl *IV);\n\n  ExprResult LookupInObjCMethod(LookupResult &LookUp, Scope *S,\n                                IdentifierInfo *II,\n                                bool AllowBuiltinCreation=false);\n\n  ExprResult ActOnDependentIdExpression(const CXXScopeSpec &SS,\n                                        SourceLocation TemplateKWLoc,\n                                        const DeclarationNameInfo &NameInfo,\n                                        bool isAddressOfOperand,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  /// If \\p D cannot be odr-used in the current expression evaluation context,\n  /// return a reason explaining why. Otherwise, return NOUR_None.\n  NonOdrUseReason getNonOdrUseReasonInCurrentContext(ValueDecl *D);\n\n  DeclRefExpr *BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                                SourceLocation Loc,\n                                const CXXScopeSpec *SS = nullptr);\n  DeclRefExpr *\n  BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                   const DeclarationNameInfo &NameInfo,\n                   const CXXScopeSpec *SS = nullptr,\n                   NamedDecl *FoundD = nullptr,\n                   SourceLocation TemplateKWLoc = SourceLocation(),\n                   const TemplateArgumentListInfo *TemplateArgs = nullptr);\n  DeclRefExpr *\n  BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                   const DeclarationNameInfo &NameInfo,\n                   NestedNameSpecifierLoc NNS,\n                   NamedDecl *FoundD = nullptr,\n                   SourceLocation TemplateKWLoc = SourceLocation(),\n                   const TemplateArgumentListInfo *TemplateArgs = nullptr);\n\n  ExprResult\n  BuildAnonymousStructUnionMemberReference(\n      const CXXScopeSpec &SS,\n      SourceLocation nameLoc,\n      IndirectFieldDecl *indirectField,\n      DeclAccessPair FoundDecl = DeclAccessPair::make(nullptr, AS_none),\n      Expr *baseObjectExpr = nullptr,\n      SourceLocation opLoc = SourceLocation());\n\n  ExprResult BuildPossibleImplicitMemberExpr(\n      const CXXScopeSpec &SS, SourceLocation TemplateKWLoc, LookupResult &R,\n      const TemplateArgumentListInfo *TemplateArgs, const Scope *S,\n      UnresolvedLookupExpr *AsULE = nullptr);\n  ExprResult BuildImplicitMemberExpr(const CXXScopeSpec &SS,\n                                     SourceLocation TemplateKWLoc,\n                                     LookupResult &R,\n                                const TemplateArgumentListInfo *TemplateArgs,\n                                     bool IsDefiniteInstance,\n                                     const Scope *S);\n  bool UseArgumentDependentLookup(const CXXScopeSpec &SS,\n                                  const LookupResult &R,\n                                  bool HasTrailingLParen);\n\n  ExprResult\n  BuildQualifiedDeclarationNameExpr(CXXScopeSpec &SS,\n                                    const DeclarationNameInfo &NameInfo,\n                                    bool IsAddressOfOperand, const Scope *S,\n                                    TypeSourceInfo **RecoveryTSI = nullptr);\n\n  ExprResult BuildDependentDeclRefExpr(const CXXScopeSpec &SS,\n                                       SourceLocation TemplateKWLoc,\n                                const DeclarationNameInfo &NameInfo,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult BuildDeclarationNameExpr(const CXXScopeSpec &SS,\n                                      LookupResult &R,\n                                      bool NeedsADL,\n                                      bool AcceptInvalidDecl = false);\n  ExprResult BuildDeclarationNameExpr(\n      const CXXScopeSpec &SS, const DeclarationNameInfo &NameInfo, NamedDecl *D,\n      NamedDecl *FoundD = nullptr,\n      const TemplateArgumentListInfo *TemplateArgs = nullptr,\n      bool AcceptInvalidDecl = false);\n\n  ExprResult BuildLiteralOperatorCall(LookupResult &R,\n                      DeclarationNameInfo &SuffixInfo,\n                      ArrayRef<Expr *> Args,\n                      SourceLocation LitEndLoc,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);\n\n  ExprResult BuildPredefinedExpr(SourceLocation Loc,\n                                 PredefinedExpr::IdentKind IK);\n  ExprResult ActOnPredefinedExpr(SourceLocation Loc, tok::TokenKind Kind);\n  ExprResult ActOnIntegerConstant(SourceLocation Loc, uint64_t Val);\n\n  bool CheckLoopHintExpr(Expr *E, SourceLocation Loc);\n\n  ExprResult ActOnNumericConstant(const Token &Tok, Scope *UDLScope = nullptr);\n  ExprResult ActOnCharacterConstant(const Token &Tok,\n                                    Scope *UDLScope = nullptr);\n  ExprResult ActOnParenExpr(SourceLocation L, SourceLocation R, Expr *E);\n  ExprResult ActOnParenListExpr(SourceLocation L,\n                                SourceLocation R,\n                                MultiExprArg Val);\n\n  /// ActOnStringLiteral - The specified tokens were lexed as pasted string\n  /// fragments (e.g. \"foo\" \"bar\" L\"baz\").\n  ExprResult ActOnStringLiteral(ArrayRef<Token> StringToks,\n                                Scope *UDLScope = nullptr);\n\n  ExprResult ActOnGenericSelectionExpr(SourceLocation KeyLoc,\n                                       SourceLocation DefaultLoc,\n                                       SourceLocation RParenLoc,\n                                       Expr *ControllingExpr,\n                                       ArrayRef<ParsedType> ArgTypes,\n                                       ArrayRef<Expr *> ArgExprs);\n  ExprResult CreateGenericSelectionExpr(SourceLocation KeyLoc,\n                                        SourceLocation DefaultLoc,\n                                        SourceLocation RParenLoc,\n                                        Expr *ControllingExpr,\n                                        ArrayRef<TypeSourceInfo *> Types,\n                                        ArrayRef<Expr *> Exprs);\n\n  // Binary/Unary Operators.  'Tok' is the token for the operator.\n  ExprResult CreateBuiltinUnaryOp(SourceLocation OpLoc, UnaryOperatorKind Opc,\n                                  Expr *InputExpr);\n  ExprResult BuildUnaryOp(Scope *S, SourceLocation OpLoc,\n                          UnaryOperatorKind Opc, Expr *Input);\n  ExprResult ActOnUnaryOp(Scope *S, SourceLocation OpLoc,\n                          tok::TokenKind Op, Expr *Input);\n\n  bool isQualifiedMemberAccess(Expr *E);\n  QualType CheckAddressOfOperand(ExprResult &Operand, SourceLocation OpLoc);\n\n  ExprResult CreateUnaryExprOrTypeTraitExpr(TypeSourceInfo *TInfo,\n                                            SourceLocation OpLoc,\n                                            UnaryExprOrTypeTrait ExprKind,\n                                            SourceRange R);\n  ExprResult CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,\n                                            UnaryExprOrTypeTrait ExprKind);\n  ExprResult\n    ActOnUnaryExprOrTypeTraitExpr(SourceLocation OpLoc,\n                                  UnaryExprOrTypeTrait ExprKind,\n                                  bool IsType, void *TyOrEx,\n                                  SourceRange ArgRange);\n\n  ExprResult CheckPlaceholderExpr(Expr *E);\n  bool CheckVecStepExpr(Expr *E);\n\n  bool CheckUnaryExprOrTypeTraitOperand(Expr *E, UnaryExprOrTypeTrait ExprKind);\n  bool CheckUnaryExprOrTypeTraitOperand(QualType ExprType, SourceLocation OpLoc,\n                                        SourceRange ExprRange,\n                                        UnaryExprOrTypeTrait ExprKind);\n  ExprResult ActOnSizeofParameterPackExpr(Scope *S,\n                                          SourceLocation OpLoc,\n                                          IdentifierInfo &Name,\n                                          SourceLocation NameLoc,\n                                          SourceLocation RParenLoc);\n  ExprResult ActOnPostfixUnaryOp(Scope *S, SourceLocation OpLoc,\n                                 tok::TokenKind Kind, Expr *Input);\n\n  ExprResult ActOnArraySubscriptExpr(Scope *S, Expr *Base, SourceLocation LLoc,\n                                     Expr *Idx, SourceLocation RLoc);\n  ExprResult CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,\n                                             Expr *Idx, SourceLocation RLoc);\n\n  ExprResult CreateBuiltinMatrixSubscriptExpr(Expr *Base, Expr *RowIdx,\n                                              Expr *ColumnIdx,\n                                              SourceLocation RBLoc);\n\n  ExprResult ActOnOMPArraySectionExpr(Expr *Base, SourceLocation LBLoc,\n                                      Expr *LowerBound,\n                                      SourceLocation ColonLocFirst,\n                                      SourceLocation ColonLocSecond,\n                                      Expr *Length, Expr *Stride,\n                                      SourceLocation RBLoc);\n  ExprResult ActOnOMPArrayShapingExpr(Expr *Base, SourceLocation LParenLoc,\n                                      SourceLocation RParenLoc,\n                                      ArrayRef<Expr *> Dims,\n                                      ArrayRef<SourceRange> Brackets);\n\n  /// Data structure for iterator expression.\n  struct OMPIteratorData {\n    IdentifierInfo *DeclIdent = nullptr;\n    SourceLocation DeclIdentLoc;\n    ParsedType Type;\n    OMPIteratorExpr::IteratorRange Range;\n    SourceLocation AssignLoc;\n    SourceLocation ColonLoc;\n    SourceLocation SecColonLoc;\n  };\n\n  ExprResult ActOnOMPIteratorExpr(Scope *S, SourceLocation IteratorKwLoc,\n                                  SourceLocation LLoc, SourceLocation RLoc,\n                                  ArrayRef<OMPIteratorData> Data);\n\n  // This struct is for use by ActOnMemberAccess to allow\n  // BuildMemberReferenceExpr to be able to reinvoke ActOnMemberAccess after\n  // changing the access operator from a '.' to a '->' (to see if that is the\n  // change needed to fix an error about an unknown member, e.g. when the class\n  // defines a custom operator->).\n  struct ActOnMemberAccessExtraArgs {\n    Scope *S;\n    UnqualifiedId &Id;\n    Decl *ObjCImpDecl;\n  };\n\n  ExprResult BuildMemberReferenceExpr(\n      Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,\n      CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,\n      const TemplateArgumentListInfo *TemplateArgs,\n      const Scope *S,\n      ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);\n\n  ExprResult\n  BuildMemberReferenceExpr(Expr *Base, QualType BaseType, SourceLocation OpLoc,\n                           bool IsArrow, const CXXScopeSpec &SS,\n                           SourceLocation TemplateKWLoc,\n                           NamedDecl *FirstQualifierInScope, LookupResult &R,\n                           const TemplateArgumentListInfo *TemplateArgs,\n                           const Scope *S,\n                           bool SuppressQualifierCheck = false,\n                           ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);\n\n  ExprResult BuildFieldReferenceExpr(Expr *BaseExpr, bool IsArrow,\n                                     SourceLocation OpLoc,\n                                     const CXXScopeSpec &SS, FieldDecl *Field,\n                                     DeclAccessPair FoundDecl,\n                                     const DeclarationNameInfo &MemberNameInfo);\n\n  ExprResult PerformMemberExprBaseConversion(Expr *Base, bool IsArrow);\n\n  bool CheckQualifiedMemberReference(Expr *BaseExpr, QualType BaseType,\n                                     const CXXScopeSpec &SS,\n                                     const LookupResult &R);\n\n  ExprResult ActOnDependentMemberExpr(Expr *Base, QualType BaseType,\n                                      bool IsArrow, SourceLocation OpLoc,\n                                      const CXXScopeSpec &SS,\n                                      SourceLocation TemplateKWLoc,\n                                      NamedDecl *FirstQualifierInScope,\n                               const DeclarationNameInfo &NameInfo,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult ActOnMemberAccessExpr(Scope *S, Expr *Base,\n                                   SourceLocation OpLoc,\n                                   tok::TokenKind OpKind,\n                                   CXXScopeSpec &SS,\n                                   SourceLocation TemplateKWLoc,\n                                   UnqualifiedId &Member,\n                                   Decl *ObjCImpDecl);\n\n  MemberExpr *\n  BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,\n                  const CXXScopeSpec *SS, SourceLocation TemplateKWLoc,\n                  ValueDecl *Member, DeclAccessPair FoundDecl,\n                  bool HadMultipleCandidates,\n                  const DeclarationNameInfo &MemberNameInfo, QualType Ty,\n                  ExprValueKind VK, ExprObjectKind OK,\n                  const TemplateArgumentListInfo *TemplateArgs = nullptr);\n  MemberExpr *\n  BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,\n                  NestedNameSpecifierLoc NNS, SourceLocation TemplateKWLoc,\n                  ValueDecl *Member, DeclAccessPair FoundDecl,\n                  bool HadMultipleCandidates,\n                  const DeclarationNameInfo &MemberNameInfo, QualType Ty,\n                  ExprValueKind VK, ExprObjectKind OK,\n                  const TemplateArgumentListInfo *TemplateArgs = nullptr);\n\n  void ActOnDefaultCtorInitializers(Decl *CDtorDecl);\n  bool ConvertArgumentsForCall(CallExpr *Call, Expr *Fn,\n                               FunctionDecl *FDecl,\n                               const FunctionProtoType *Proto,\n                               ArrayRef<Expr *> Args,\n                               SourceLocation RParenLoc,\n                               bool ExecConfig = false);\n  void CheckStaticArrayArgument(SourceLocation CallLoc,\n                                ParmVarDecl *Param,\n                                const Expr *ArgExpr);\n\n  /// ActOnCallExpr - Handle a call to Fn with the specified array of arguments.\n  /// This provides the location of the left/right parens and a list of comma\n  /// locations.\n  ExprResult ActOnCallExpr(Scope *S, Expr *Fn, SourceLocation LParenLoc,\n                           MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                           Expr *ExecConfig = nullptr);\n  ExprResult BuildCallExpr(Scope *S, Expr *Fn, SourceLocation LParenLoc,\n                           MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                           Expr *ExecConfig = nullptr,\n                           bool IsExecConfig = false,\n                           bool AllowRecovery = false);\n  enum class AtomicArgumentOrder { API, AST };\n  ExprResult\n  BuildAtomicExpr(SourceRange CallRange, SourceRange ExprRange,\n                  SourceLocation RParenLoc, MultiExprArg Args,\n                  AtomicExpr::AtomicOp Op,\n                  AtomicArgumentOrder ArgOrder = AtomicArgumentOrder::API);\n  ExprResult\n  BuildResolvedCallExpr(Expr *Fn, NamedDecl *NDecl, SourceLocation LParenLoc,\n                        ArrayRef<Expr *> Arg, SourceLocation RParenLoc,\n                        Expr *Config = nullptr, bool IsExecConfig = false,\n                        ADLCallKind UsesADL = ADLCallKind::NotADL);\n\n  ExprResult ActOnCUDAExecConfigExpr(Scope *S, SourceLocation LLLLoc,\n                                     MultiExprArg ExecConfig,\n                                     SourceLocation GGGLoc);\n\n  ExprResult ActOnCastExpr(Scope *S, SourceLocation LParenLoc,\n                           Declarator &D, ParsedType &Ty,\n                           SourceLocation RParenLoc, Expr *CastExpr);\n  ExprResult BuildCStyleCastExpr(SourceLocation LParenLoc,\n                                 TypeSourceInfo *Ty,\n                                 SourceLocation RParenLoc,\n                                 Expr *Op);\n  CastKind PrepareScalarCast(ExprResult &src, QualType destType);\n\n  /// Build an altivec or OpenCL literal.\n  ExprResult BuildVectorLiteral(SourceLocation LParenLoc,\n                                SourceLocation RParenLoc, Expr *E,\n                                TypeSourceInfo *TInfo);\n\n  ExprResult MaybeConvertParenListExprToParenExpr(Scope *S, Expr *ME);\n\n  ExprResult ActOnCompoundLiteral(SourceLocation LParenLoc,\n                                  ParsedType Ty,\n                                  SourceLocation RParenLoc,\n                                  Expr *InitExpr);\n\n  ExprResult BuildCompoundLiteralExpr(SourceLocation LParenLoc,\n                                      TypeSourceInfo *TInfo,\n                                      SourceLocation RParenLoc,\n                                      Expr *LiteralExpr);\n\n  ExprResult ActOnInitList(SourceLocation LBraceLoc,\n                           MultiExprArg InitArgList,\n                           SourceLocation RBraceLoc);\n\n  ExprResult BuildInitList(SourceLocation LBraceLoc,\n                           MultiExprArg InitArgList,\n                           SourceLocation RBraceLoc);\n\n  ExprResult ActOnDesignatedInitializer(Designation &Desig,\n                                        SourceLocation EqualOrColonLoc,\n                                        bool GNUSyntax,\n                                        ExprResult Init);\n\nprivate:\n  static BinaryOperatorKind ConvertTokenKindToBinaryOpcode(tok::TokenKind Kind);\n\npublic:\n  ExprResult ActOnBinOp(Scope *S, SourceLocation TokLoc,\n                        tok::TokenKind Kind, Expr *LHSExpr, Expr *RHSExpr);\n  ExprResult BuildBinOp(Scope *S, SourceLocation OpLoc,\n                        BinaryOperatorKind Opc, Expr *LHSExpr, Expr *RHSExpr);\n  ExprResult CreateBuiltinBinOp(SourceLocation OpLoc, BinaryOperatorKind Opc,\n                                Expr *LHSExpr, Expr *RHSExpr);\n  void LookupBinOp(Scope *S, SourceLocation OpLoc, BinaryOperatorKind Opc,\n                   UnresolvedSetImpl &Functions);\n\n  void DiagnoseCommaOperator(const Expr *LHS, SourceLocation Loc);\n\n  /// ActOnConditionalOp - Parse a ?: operation.  Note that 'LHS' may be null\n  /// in the case of a the GNU conditional expr extension.\n  ExprResult ActOnConditionalOp(SourceLocation QuestionLoc,\n                                SourceLocation ColonLoc,\n                                Expr *CondExpr, Expr *LHSExpr, Expr *RHSExpr);\n\n  /// ActOnAddrLabel - Parse the GNU address of label extension: \"&&foo\".\n  ExprResult ActOnAddrLabel(SourceLocation OpLoc, SourceLocation LabLoc,\n                            LabelDecl *TheDecl);\n\n  void ActOnStartStmtExpr();\n  ExprResult ActOnStmtExpr(Scope *S, SourceLocation LPLoc, Stmt *SubStmt,\n                           SourceLocation RPLoc);\n  ExprResult BuildStmtExpr(SourceLocation LPLoc, Stmt *SubStmt,\n                           SourceLocation RPLoc, unsigned TemplateDepth);\n  // Handle the final expression in a statement expression.\n  ExprResult ActOnStmtExprResult(ExprResult E);\n  void ActOnStmtExprError();\n\n  // __builtin_offsetof(type, identifier(.identifier|[expr])*)\n  struct OffsetOfComponent {\n    SourceLocation LocStart, LocEnd;\n    bool isBrackets;  // true if [expr], false if .ident\n    union {\n      IdentifierInfo *IdentInfo;\n      Expr *E;\n    } U;\n  };\n\n  /// __builtin_offsetof(type, a.b[123][456].c)\n  ExprResult BuildBuiltinOffsetOf(SourceLocation BuiltinLoc,\n                                  TypeSourceInfo *TInfo,\n                                  ArrayRef<OffsetOfComponent> Components,\n                                  SourceLocation RParenLoc);\n  ExprResult ActOnBuiltinOffsetOf(Scope *S,\n                                  SourceLocation BuiltinLoc,\n                                  SourceLocation TypeLoc,\n                                  ParsedType ParsedArgTy,\n                                  ArrayRef<OffsetOfComponent> Components,\n                                  SourceLocation RParenLoc);\n\n  // __builtin_choose_expr(constExpr, expr1, expr2)\n  ExprResult ActOnChooseExpr(SourceLocation BuiltinLoc,\n                             Expr *CondExpr, Expr *LHSExpr,\n                             Expr *RHSExpr, SourceLocation RPLoc);\n\n  // __builtin_va_arg(expr, type)\n  ExprResult ActOnVAArg(SourceLocation BuiltinLoc, Expr *E, ParsedType Ty,\n                        SourceLocation RPLoc);\n  ExprResult BuildVAArgExpr(SourceLocation BuiltinLoc, Expr *E,\n                            TypeSourceInfo *TInfo, SourceLocation RPLoc);\n\n  // __builtin_LINE(), __builtin_FUNCTION(), __builtin_FILE(),\n  // __builtin_COLUMN()\n  ExprResult ActOnSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                SourceLocation BuiltinLoc,\n                                SourceLocation RPLoc);\n\n  // Build a potentially resolved SourceLocExpr.\n  ExprResult BuildSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                SourceLocation BuiltinLoc, SourceLocation RPLoc,\n                                DeclContext *ParentContext);\n\n  // __null\n  ExprResult ActOnGNUNullExpr(SourceLocation TokenLoc);\n\n  bool CheckCaseExpression(Expr *E);\n\n  /// Describes the result of an \"if-exists\" condition check.\n  enum IfExistsResult {\n    /// The symbol exists.\n    IER_Exists,\n\n    /// The symbol does not exist.\n    IER_DoesNotExist,\n\n    /// The name is a dependent name, so the results will differ\n    /// from one instantiation to the next.\n    IER_Dependent,\n\n    /// An error occurred.\n    IER_Error\n  };\n\n  IfExistsResult\n  CheckMicrosoftIfExistsSymbol(Scope *S, CXXScopeSpec &SS,\n                               const DeclarationNameInfo &TargetNameInfo);\n\n  IfExistsResult\n  CheckMicrosoftIfExistsSymbol(Scope *S, SourceLocation KeywordLoc,\n                               bool IsIfExists, CXXScopeSpec &SS,\n                               UnqualifiedId &Name);\n\n  StmtResult BuildMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                        bool IsIfExists,\n                                        NestedNameSpecifierLoc QualifierLoc,\n                                        DeclarationNameInfo NameInfo,\n                                        Stmt *Nested);\n  StmtResult ActOnMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                        bool IsIfExists,\n                                        CXXScopeSpec &SS, UnqualifiedId &Name,\n                                        Stmt *Nested);\n\n  //===------------------------- \"Block\" Extension ------------------------===//\n\n  /// ActOnBlockStart - This callback is invoked when a block literal is\n  /// started.\n  void ActOnBlockStart(SourceLocation CaretLoc, Scope *CurScope);\n\n  /// ActOnBlockArguments - This callback allows processing of block arguments.\n  /// If there are no arguments, this is still invoked.\n  void ActOnBlockArguments(SourceLocation CaretLoc, Declarator &ParamInfo,\n                           Scope *CurScope);\n\n  /// ActOnBlockError - If there is an error parsing a block, this callback\n  /// is invoked to pop the information about the block from the action impl.\n  void ActOnBlockError(SourceLocation CaretLoc, Scope *CurScope);\n\n  /// ActOnBlockStmtExpr - This is called when the body of a block statement\n  /// literal was successfully completed.  ^(int x){...}\n  ExprResult ActOnBlockStmtExpr(SourceLocation CaretLoc, Stmt *Body,\n                                Scope *CurScope);\n\n  //===---------------------------- Clang Extensions ----------------------===//\n\n  /// __builtin_convertvector(...)\n  ExprResult ActOnConvertVectorExpr(Expr *E, ParsedType ParsedDestTy,\n                                    SourceLocation BuiltinLoc,\n                                    SourceLocation RParenLoc);\n\n  //===---------------------------- OpenCL Features -----------------------===//\n\n  /// __builtin_astype(...)\n  ExprResult ActOnAsTypeExpr(Expr *E, ParsedType ParsedDestTy,\n                             SourceLocation BuiltinLoc,\n                             SourceLocation RParenLoc);\n\n  //===---------------------------- C++ Features --------------------------===//\n\n  // Act on C++ namespaces\n  Decl *ActOnStartNamespaceDef(Scope *S, SourceLocation InlineLoc,\n                               SourceLocation NamespaceLoc,\n                               SourceLocation IdentLoc, IdentifierInfo *Ident,\n                               SourceLocation LBrace,\n                               const ParsedAttributesView &AttrList,\n                               UsingDirectiveDecl *&UsingDecl);\n  void ActOnFinishNamespaceDef(Decl *Dcl, SourceLocation RBrace);\n\n  NamespaceDecl *getStdNamespace() const;\n  NamespaceDecl *getOrCreateStdNamespace();\n\n  NamespaceDecl *lookupStdExperimentalNamespace();\n\n  CXXRecordDecl *getStdBadAlloc() const;\n  EnumDecl *getStdAlignValT() const;\n\nprivate:\n  // A cache representing if we've fully checked the various comparison category\n  // types stored in ASTContext. The bit-index corresponds to the integer value\n  // of a ComparisonCategoryType enumerator.\n  llvm::SmallBitVector FullyCheckedComparisonCategories;\n\n  ValueDecl *tryLookupCtorInitMemberDecl(CXXRecordDecl *ClassDecl,\n                                         CXXScopeSpec &SS,\n                                         ParsedType TemplateTypeTy,\n                                         IdentifierInfo *MemberOrBase);\n\npublic:\n  enum class ComparisonCategoryUsage {\n    /// The '<=>' operator was used in an expression and a builtin operator\n    /// was selected.\n    OperatorInExpression,\n    /// A defaulted 'operator<=>' needed the comparison category. This\n    /// typically only applies to 'std::strong_ordering', due to the implicit\n    /// fallback return value.\n    DefaultedOperator,\n  };\n\n  /// Lookup the specified comparison category types in the standard\n  ///   library, an check the VarDecls possibly returned by the operator<=>\n  ///   builtins for that type.\n  ///\n  /// \\return The type of the comparison category type corresponding to the\n  ///   specified Kind, or a null type if an error occurs\n  QualType CheckComparisonCategoryType(ComparisonCategoryType Kind,\n                                       SourceLocation Loc,\n                                       ComparisonCategoryUsage Usage);\n\n  /// Tests whether Ty is an instance of std::initializer_list and, if\n  /// it is and Element is not NULL, assigns the element type to Element.\n  bool isStdInitializerList(QualType Ty, QualType *Element);\n\n  /// Looks for the std::initializer_list template and instantiates it\n  /// with Element, or emits an error if it's not found.\n  ///\n  /// \\returns The instantiated template, or null on error.\n  QualType BuildStdInitializerList(QualType Element, SourceLocation Loc);\n\n  /// Determine whether Ctor is an initializer-list constructor, as\n  /// defined in [dcl.init.list]p2.\n  bool isInitListConstructor(const FunctionDecl *Ctor);\n\n  Decl *ActOnUsingDirective(Scope *CurScope, SourceLocation UsingLoc,\n                            SourceLocation NamespcLoc, CXXScopeSpec &SS,\n                            SourceLocation IdentLoc,\n                            IdentifierInfo *NamespcName,\n                            const ParsedAttributesView &AttrList);\n\n  void PushUsingDirective(Scope *S, UsingDirectiveDecl *UDir);\n\n  Decl *ActOnNamespaceAliasDef(Scope *CurScope,\n                               SourceLocation NamespaceLoc,\n                               SourceLocation AliasLoc,\n                               IdentifierInfo *Alias,\n                               CXXScopeSpec &SS,\n                               SourceLocation IdentLoc,\n                               IdentifierInfo *Ident);\n\n  void HideUsingShadowDecl(Scope *S, UsingShadowDecl *Shadow);\n  bool CheckUsingShadowDecl(UsingDecl *UD, NamedDecl *Target,\n                            const LookupResult &PreviousDecls,\n                            UsingShadowDecl *&PrevShadow);\n  UsingShadowDecl *BuildUsingShadowDecl(Scope *S, UsingDecl *UD,\n                                        NamedDecl *Target,\n                                        UsingShadowDecl *PrevDecl);\n\n  bool CheckUsingDeclRedeclaration(SourceLocation UsingLoc,\n                                   bool HasTypenameKeyword,\n                                   const CXXScopeSpec &SS,\n                                   SourceLocation NameLoc,\n                                   const LookupResult &Previous);\n  bool CheckUsingDeclQualifier(SourceLocation UsingLoc,\n                               bool HasTypename,\n                               const CXXScopeSpec &SS,\n                               const DeclarationNameInfo &NameInfo,\n                               SourceLocation NameLoc);\n\n  NamedDecl *BuildUsingDeclaration(\n      Scope *S, AccessSpecifier AS, SourceLocation UsingLoc,\n      bool HasTypenameKeyword, SourceLocation TypenameLoc, CXXScopeSpec &SS,\n      DeclarationNameInfo NameInfo, SourceLocation EllipsisLoc,\n      const ParsedAttributesView &AttrList, bool IsInstantiation);\n  NamedDecl *BuildUsingPackDecl(NamedDecl *InstantiatedFrom,\n                                ArrayRef<NamedDecl *> Expansions);\n\n  bool CheckInheritingConstructorUsingDecl(UsingDecl *UD);\n\n  /// Given a derived-class using shadow declaration for a constructor and the\n  /// correspnding base class constructor, find or create the implicit\n  /// synthesized derived class constructor to use for this initialization.\n  CXXConstructorDecl *\n  findInheritingConstructor(SourceLocation Loc, CXXConstructorDecl *BaseCtor,\n                            ConstructorUsingShadowDecl *DerivedShadow);\n\n  Decl *ActOnUsingDeclaration(Scope *CurScope, AccessSpecifier AS,\n                              SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc, CXXScopeSpec &SS,\n                              UnqualifiedId &Name, SourceLocation EllipsisLoc,\n                              const ParsedAttributesView &AttrList);\n  Decl *ActOnAliasDeclaration(Scope *CurScope, AccessSpecifier AS,\n                              MultiTemplateParamsArg TemplateParams,\n                              SourceLocation UsingLoc, UnqualifiedId &Name,\n                              const ParsedAttributesView &AttrList,\n                              TypeResult Type, Decl *DeclFromDeclSpec);\n\n  /// BuildCXXConstructExpr - Creates a complete call to a constructor,\n  /// including handling of its default argument expressions.\n  ///\n  /// \\param ConstructKind - a CXXConstructExpr::ConstructionKind\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        NamedDecl *FoundDecl,\n                        CXXConstructorDecl *Constructor, MultiExprArg Exprs,\n                        bool HadMultipleCandidates, bool IsListInitialization,\n                        bool IsStdInitListInitialization,\n                        bool RequiresZeroInit, unsigned ConstructKind,\n                        SourceRange ParenRange);\n\n  /// Build a CXXConstructExpr whose constructor has already been resolved if\n  /// it denotes an inherited constructor.\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        CXXConstructorDecl *Constructor, bool Elidable,\n                        MultiExprArg Exprs,\n                        bool HadMultipleCandidates, bool IsListInitialization,\n                        bool IsStdInitListInitialization,\n                        bool RequiresZeroInit, unsigned ConstructKind,\n                        SourceRange ParenRange);\n\n  // FIXME: Can we remove this and have the above BuildCXXConstructExpr check if\n  // the constructor can be elidable?\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        NamedDecl *FoundDecl,\n                        CXXConstructorDecl *Constructor, bool Elidable,\n                        MultiExprArg Exprs, bool HadMultipleCandidates,\n                        bool IsListInitialization,\n                        bool IsStdInitListInitialization, bool RequiresZeroInit,\n                        unsigned ConstructKind, SourceRange ParenRange);\n\n  ExprResult BuildCXXDefaultInitExpr(SourceLocation Loc, FieldDecl *Field);\n\n\n  /// Instantiate or parse a C++ default argument expression as necessary.\n  /// Return true on error.\n  bool CheckCXXDefaultArgExpr(SourceLocation CallLoc, FunctionDecl *FD,\n                              ParmVarDecl *Param);\n\n  /// BuildCXXDefaultArgExpr - Creates a CXXDefaultArgExpr, instantiating\n  /// the default expr if needed.\n  ExprResult BuildCXXDefaultArgExpr(SourceLocation CallLoc,\n                                    FunctionDecl *FD,\n                                    ParmVarDecl *Param);\n\n  /// FinalizeVarWithDestructor - Prepare for calling destructor on the\n  /// constructed variable.\n  void FinalizeVarWithDestructor(VarDecl *VD, const RecordType *DeclInitType);\n\n  /// Helper class that collects exception specifications for\n  /// implicitly-declared special member functions.\n  class ImplicitExceptionSpecification {\n    // Pointer to allow copying\n    Sema *Self;\n    // We order exception specifications thus:\n    // noexcept is the most restrictive, but is only used in C++11.\n    // throw() comes next.\n    // Then a throw(collected exceptions)\n    // Finally no specification, which is expressed as noexcept(false).\n    // throw(...) is used instead if any called function uses it.\n    ExceptionSpecificationType ComputedEST;\n    llvm::SmallPtrSet<CanQualType, 4> ExceptionsSeen;\n    SmallVector<QualType, 4> Exceptions;\n\n    void ClearExceptions() {\n      ExceptionsSeen.clear();\n      Exceptions.clear();\n    }\n\n  public:\n    explicit ImplicitExceptionSpecification(Sema &Self)\n      : Self(&Self), ComputedEST(EST_BasicNoexcept) {\n      if (!Self.getLangOpts().CPlusPlus11)\n        ComputedEST = EST_DynamicNone;\n    }\n\n    /// Get the computed exception specification type.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      assert(!isComputedNoexcept(ComputedEST) &&\n             \"noexcept(expr) should not be a possible result\");\n      return ComputedEST;\n    }\n\n    /// The number of exceptions in the exception specification.\n    unsigned size() const { return Exceptions.size(); }\n\n    /// The set of exceptions in the exception specification.\n    const QualType *data() const { return Exceptions.data(); }\n\n    /// Integrate another called method into the collected data.\n    void CalledDecl(SourceLocation CallLoc, const CXXMethodDecl *Method);\n\n    /// Integrate an invoked expression into the collected data.\n    void CalledExpr(Expr *E) { CalledStmt(E); }\n\n    /// Integrate an invoked statement into the collected data.\n    void CalledStmt(Stmt *S);\n\n    /// Overwrite an EPI's exception specification with this\n    /// computed exception specification.\n    FunctionProtoType::ExceptionSpecInfo getExceptionSpec() const {\n      FunctionProtoType::ExceptionSpecInfo ESI;\n      ESI.Type = getExceptionSpecType();\n      if (ESI.Type == EST_Dynamic) {\n        ESI.Exceptions = Exceptions;\n      } else if (ESI.Type == EST_None) {\n        /// C++11 [except.spec]p14:\n        ///   The exception-specification is noexcept(false) if the set of\n        ///   potential exceptions of the special member function contains \"any\"\n        ESI.Type = EST_NoexceptFalse;\n        ESI.NoexceptExpr = Self->ActOnCXXBoolLiteral(SourceLocation(),\n                                                     tok::kw_false).get();\n      }\n      return ESI;\n    }\n  };\n\n  /// Evaluate the implicit exception specification for a defaulted\n  /// special member function.\n  void EvaluateImplicitExceptionSpec(SourceLocation Loc, FunctionDecl *FD);\n\n  /// Check the given noexcept-specifier, convert its expression, and compute\n  /// the appropriate ExceptionSpecificationType.\n  ExprResult ActOnNoexceptSpec(SourceLocation NoexceptLoc, Expr *NoexceptExpr,\n                               ExceptionSpecificationType &EST);\n\n  /// Check the given exception-specification and update the\n  /// exception specification information with the results.\n  void checkExceptionSpecification(bool IsTopLevel,\n                                   ExceptionSpecificationType EST,\n                                   ArrayRef<ParsedType> DynamicExceptions,\n                                   ArrayRef<SourceRange> DynamicExceptionRanges,\n                                   Expr *NoexceptExpr,\n                                   SmallVectorImpl<QualType> &Exceptions,\n                                   FunctionProtoType::ExceptionSpecInfo &ESI);\n\n  /// Determine if we're in a case where we need to (incorrectly) eagerly\n  /// parse an exception specification to work around a libstdc++ bug.\n  bool isLibstdcxxEagerExceptionSpecHack(const Declarator &D);\n\n  /// Add an exception-specification to the given member function\n  /// (or member function template). The exception-specification was parsed\n  /// after the method itself was declared.\n  void actOnDelayedExceptionSpecification(Decl *Method,\n         ExceptionSpecificationType EST,\n         SourceRange SpecificationRange,\n         ArrayRef<ParsedType> DynamicExceptions,\n         ArrayRef<SourceRange> DynamicExceptionRanges,\n         Expr *NoexceptExpr);\n\n  class InheritedConstructorInfo;\n\n  /// Determine if a special member function should have a deleted\n  /// definition when it is defaulted.\n  bool ShouldDeleteSpecialMember(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                                 InheritedConstructorInfo *ICI = nullptr,\n                                 bool Diagnose = false);\n\n  /// Produce notes explaining why a defaulted function was defined as deleted.\n  void DiagnoseDeletedDefaultedFunction(FunctionDecl *FD);\n\n  /// Declare the implicit default constructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// default constructor will be added.\n  ///\n  /// \\returns The implicitly-declared default constructor.\n  CXXConstructorDecl *DeclareImplicitDefaultConstructor(\n                                                     CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitDefaultConstructor - Checks for feasibility of\n  /// defining this constructor as the default constructor.\n  void DefineImplicitDefaultConstructor(SourceLocation CurrentLocation,\n                                        CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit destructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// destructor will be added.\n  ///\n  /// \\returns The implicitly-declared destructor.\n  CXXDestructorDecl *DeclareImplicitDestructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitDestructor - Checks for feasibility of\n  /// defining this destructor as the default destructor.\n  void DefineImplicitDestructor(SourceLocation CurrentLocation,\n                                CXXDestructorDecl *Destructor);\n\n  /// Build an exception spec for destructors that don't have one.\n  ///\n  /// C++11 says that user-defined destructors with no exception spec get one\n  /// that looks as if the destructor was implicitly declared.\n  void AdjustDestructorExceptionSpec(CXXDestructorDecl *Destructor);\n\n  /// Define the specified inheriting constructor.\n  void DefineInheritingConstructor(SourceLocation UseLoc,\n                                   CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit copy constructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// copy constructor will be added.\n  ///\n  /// \\returns The implicitly-declared copy constructor.\n  CXXConstructorDecl *DeclareImplicitCopyConstructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitCopyConstructor - Checks for feasibility of\n  /// defining this constructor as the copy constructor.\n  void DefineImplicitCopyConstructor(SourceLocation CurrentLocation,\n                                     CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit move constructor for the given class.\n  ///\n  /// \\param ClassDecl The Class declaration into which the implicit\n  /// move constructor will be added.\n  ///\n  /// \\returns The implicitly-declared move constructor, or NULL if it wasn't\n  /// declared.\n  CXXConstructorDecl *DeclareImplicitMoveConstructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitMoveConstructor - Checks for feasibility of\n  /// defining this constructor as the move constructor.\n  void DefineImplicitMoveConstructor(SourceLocation CurrentLocation,\n                                     CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit copy assignment operator for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// copy assignment operator will be added.\n  ///\n  /// \\returns The implicitly-declared copy assignment operator.\n  CXXMethodDecl *DeclareImplicitCopyAssignment(CXXRecordDecl *ClassDecl);\n\n  /// Defines an implicitly-declared copy assignment operator.\n  void DefineImplicitCopyAssignment(SourceLocation CurrentLocation,\n                                    CXXMethodDecl *MethodDecl);\n\n  /// Declare the implicit move assignment operator for the given class.\n  ///\n  /// \\param ClassDecl The Class declaration into which the implicit\n  /// move assignment operator will be added.\n  ///\n  /// \\returns The implicitly-declared move assignment operator, or NULL if it\n  /// wasn't declared.\n  CXXMethodDecl *DeclareImplicitMoveAssignment(CXXRecordDecl *ClassDecl);\n\n  /// Defines an implicitly-declared move assignment operator.\n  void DefineImplicitMoveAssignment(SourceLocation CurrentLocation,\n                                    CXXMethodDecl *MethodDecl);\n\n  /// Force the declaration of any implicitly-declared members of this\n  /// class.\n  void ForceDeclarationOfImplicitMembers(CXXRecordDecl *Class);\n\n  /// Check a completed declaration of an implicit special member.\n  void CheckImplicitSpecialMemberDeclaration(Scope *S, FunctionDecl *FD);\n\n  /// Determine whether the given function is an implicitly-deleted\n  /// special member function.\n  bool isImplicitlyDeleted(FunctionDecl *FD);\n\n  /// Check whether 'this' shows up in the type of a static member\n  /// function after the (naturally empty) cv-qualifier-seq would be.\n  ///\n  /// \\returns true if an error occurred.\n  bool checkThisInStaticMemberFunctionType(CXXMethodDecl *Method);\n\n  /// Whether this' shows up in the exception specification of a static\n  /// member function.\n  bool checkThisInStaticMemberFunctionExceptionSpec(CXXMethodDecl *Method);\n\n  /// Check whether 'this' shows up in the attributes of the given\n  /// static member function.\n  ///\n  /// \\returns true if an error occurred.\n  bool checkThisInStaticMemberFunctionAttributes(CXXMethodDecl *Method);\n\n  /// MaybeBindToTemporary - If the passed in expression has a record type with\n  /// a non-trivial destructor, this will return CXXBindTemporaryExpr. Otherwise\n  /// it simply returns the passed in expression.\n  ExprResult MaybeBindToTemporary(Expr *E);\n\n  /// Wrap the expression in a ConstantExpr if it is a potential immediate\n  /// invocation.\n  ExprResult CheckForImmediateInvocation(ExprResult E, FunctionDecl *Decl);\n\n  bool CompleteConstructorCall(CXXConstructorDecl *Constructor,\n                               QualType DeclInitType, MultiExprArg ArgsPtr,\n                               SourceLocation Loc,\n                               SmallVectorImpl<Expr *> &ConvertedArgs,\n                               bool AllowExplicit = false,\n                               bool IsListInitialization = false);\n\n  ParsedType getInheritingConstructorName(CXXScopeSpec &SS,\n                                          SourceLocation NameLoc,\n                                          IdentifierInfo &Name);\n\n  ParsedType getConstructorName(IdentifierInfo &II, SourceLocation NameLoc,\n                                Scope *S, CXXScopeSpec &SS,\n                                bool EnteringContext);\n  ParsedType getDestructorName(SourceLocation TildeLoc,\n                               IdentifierInfo &II, SourceLocation NameLoc,\n                               Scope *S, CXXScopeSpec &SS,\n                               ParsedType ObjectType,\n                               bool EnteringContext);\n\n  ParsedType getDestructorTypeForDecltype(const DeclSpec &DS,\n                                          ParsedType ObjectType);\n\n  // Checks that reinterpret casts don't have undefined behavior.\n  void CheckCompatibleReinterpretCast(QualType SrcType, QualType DestType,\n                                      bool IsDereference, SourceRange Range);\n\n  /// ActOnCXXNamedCast - Parse\n  /// {dynamic,static,reinterpret,const,addrspace}_cast's.\n  ExprResult ActOnCXXNamedCast(SourceLocation OpLoc,\n                               tok::TokenKind Kind,\n                               SourceLocation LAngleBracketLoc,\n                               Declarator &D,\n                               SourceLocation RAngleBracketLoc,\n                               SourceLocation LParenLoc,\n                               Expr *E,\n                               SourceLocation RParenLoc);\n\n  ExprResult BuildCXXNamedCast(SourceLocation OpLoc,\n                               tok::TokenKind Kind,\n                               TypeSourceInfo *Ty,\n                               Expr *E,\n                               SourceRange AngleBrackets,\n                               SourceRange Parens);\n\n  ExprResult ActOnBuiltinBitCastExpr(SourceLocation KWLoc, Declarator &Dcl,\n                                     ExprResult Operand,\n                                     SourceLocation RParenLoc);\n\n  ExprResult BuildBuiltinBitCastExpr(SourceLocation KWLoc, TypeSourceInfo *TSI,\n                                     Expr *Operand, SourceLocation RParenLoc);\n\n  ExprResult BuildCXXTypeId(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            TypeSourceInfo *Operand,\n                            SourceLocation RParenLoc);\n  ExprResult BuildCXXTypeId(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            Expr *Operand,\n                            SourceLocation RParenLoc);\n\n  /// ActOnCXXTypeid - Parse typeid( something ).\n  ExprResult ActOnCXXTypeid(SourceLocation OpLoc,\n                            SourceLocation LParenLoc, bool isType,\n                            void *TyOrExpr,\n                            SourceLocation RParenLoc);\n\n  ExprResult BuildCXXUuidof(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            TypeSourceInfo *Operand,\n                            SourceLocation RParenLoc);\n  ExprResult BuildCXXUuidof(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            Expr *Operand,\n                            SourceLocation RParenLoc);\n\n  /// ActOnCXXUuidof - Parse __uuidof( something ).\n  ExprResult ActOnCXXUuidof(SourceLocation OpLoc,\n                            SourceLocation LParenLoc, bool isType,\n                            void *TyOrExpr,\n                            SourceLocation RParenLoc);\n\n  /// Handle a C++1z fold-expression: ( expr op ... op expr ).\n  ExprResult ActOnCXXFoldExpr(Scope *S, SourceLocation LParenLoc, Expr *LHS,\n                              tok::TokenKind Operator,\n                              SourceLocation EllipsisLoc, Expr *RHS,\n                              SourceLocation RParenLoc);\n  ExprResult BuildCXXFoldExpr(UnresolvedLookupExpr *Callee,\n                              SourceLocation LParenLoc, Expr *LHS,\n                              BinaryOperatorKind Operator,\n                              SourceLocation EllipsisLoc, Expr *RHS,\n                              SourceLocation RParenLoc,\n                              Optional<unsigned> NumExpansions);\n  ExprResult BuildEmptyCXXFoldExpr(SourceLocation EllipsisLoc,\n                                   BinaryOperatorKind Operator);\n\n  //// ActOnCXXThis -  Parse 'this' pointer.\n  ExprResult ActOnCXXThis(SourceLocation loc);\n\n  /// Build a CXXThisExpr and mark it referenced in the current context.\n  Expr *BuildCXXThisExpr(SourceLocation Loc, QualType Type, bool IsImplicit);\n  void MarkThisReferenced(CXXThisExpr *This);\n\n  /// Try to retrieve the type of the 'this' pointer.\n  ///\n  /// \\returns The type of 'this', if possible. Otherwise, returns a NULL type.\n  QualType getCurrentThisType();\n\n  /// When non-NULL, the C++ 'this' expression is allowed despite the\n  /// current context not being a non-static member function. In such cases,\n  /// this provides the type used for 'this'.\n  QualType CXXThisTypeOverride;\n\n  /// RAII object used to temporarily allow the C++ 'this' expression\n  /// to be used, with the given qualifiers on the current class type.\n  class CXXThisScopeRAII {\n    Sema &S;\n    QualType OldCXXThisTypeOverride;\n    bool Enabled;\n\n  public:\n    /// Introduce a new scope where 'this' may be allowed (when enabled),\n    /// using the given declaration (which is either a class template or a\n    /// class) along with the given qualifiers.\n    /// along with the qualifiers placed on '*this'.\n    CXXThisScopeRAII(Sema &S, Decl *ContextDecl, Qualifiers CXXThisTypeQuals,\n                     bool Enabled = true);\n\n    ~CXXThisScopeRAII();\n  };\n\n  /// Make sure the value of 'this' is actually available in the current\n  /// context, if it is a potentially evaluated context.\n  ///\n  /// \\param Loc The location at which the capture of 'this' occurs.\n  ///\n  /// \\param Explicit Whether 'this' is explicitly captured in a lambda\n  /// capture list.\n  ///\n  /// \\param FunctionScopeIndexToStopAt If non-null, it points to the index\n  /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.\n  /// This is useful when enclosing lambdas must speculatively capture\n  /// 'this' that may or may not be used in certain specializations of\n  /// a nested generic lambda (depending on whether the name resolves to\n  /// a non-static member function or a static function).\n  /// \\return returns 'true' if failed, 'false' if success.\n  bool CheckCXXThisCapture(SourceLocation Loc, bool Explicit = false,\n      bool BuildAndDiagnose = true,\n      const unsigned *const FunctionScopeIndexToStopAt = nullptr,\n      bool ByCopy = false);\n\n  /// Determine whether the given type is the type of *this that is used\n  /// outside of the body of a member function for a type that is currently\n  /// being defined.\n  bool isThisOutsideMemberFunctionBody(QualType BaseType);\n\n  /// ActOnCXXBoolLiteral - Parse {true,false} literals.\n  ExprResult ActOnCXXBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);\n\n\n  /// ActOnObjCBoolLiteral - Parse {__objc_yes,__objc_no} literals.\n  ExprResult ActOnObjCBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);\n\n  ExprResult\n  ActOnObjCAvailabilityCheckExpr(llvm::ArrayRef<AvailabilitySpec> AvailSpecs,\n                                 SourceLocation AtLoc, SourceLocation RParen);\n\n  /// ActOnCXXNullPtrLiteral - Parse 'nullptr'.\n  ExprResult ActOnCXXNullPtrLiteral(SourceLocation Loc);\n\n  //// ActOnCXXThrow -  Parse throw expressions.\n  ExprResult ActOnCXXThrow(Scope *S, SourceLocation OpLoc, Expr *expr);\n  ExprResult BuildCXXThrow(SourceLocation OpLoc, Expr *Ex,\n                           bool IsThrownVarInScope);\n  bool CheckCXXThrowOperand(SourceLocation ThrowLoc, QualType ThrowTy, Expr *E);\n\n  /// ActOnCXXTypeConstructExpr - Parse construction of a specified type.\n  /// Can be interpreted either as function-style casting (\"int(x)\")\n  /// or class type construction (\"ClassType(x,y,z)\")\n  /// or creation of a value-initialized type (\"int()\").\n  ExprResult ActOnCXXTypeConstructExpr(ParsedType TypeRep,\n                                       SourceLocation LParenOrBraceLoc,\n                                       MultiExprArg Exprs,\n                                       SourceLocation RParenOrBraceLoc,\n                                       bool ListInitialization);\n\n  ExprResult BuildCXXTypeConstructExpr(TypeSourceInfo *Type,\n                                       SourceLocation LParenLoc,\n                                       MultiExprArg Exprs,\n                                       SourceLocation RParenLoc,\n                                       bool ListInitialization);\n\n  /// ActOnCXXNew - Parsed a C++ 'new' expression.\n  ExprResult ActOnCXXNew(SourceLocation StartLoc, bool UseGlobal,\n                         SourceLocation PlacementLParen,\n                         MultiExprArg PlacementArgs,\n                         SourceLocation PlacementRParen,\n                         SourceRange TypeIdParens, Declarator &D,\n                         Expr *Initializer);\n  ExprResult BuildCXXNew(SourceRange Range, bool UseGlobal,\n                         SourceLocation PlacementLParen,\n                         MultiExprArg PlacementArgs,\n                         SourceLocation PlacementRParen,\n                         SourceRange TypeIdParens,\n                         QualType AllocType,\n                         TypeSourceInfo *AllocTypeInfo,\n                         Optional<Expr *> ArraySize,\n                         SourceRange DirectInitRange,\n                         Expr *Initializer);\n\n  /// Determine whether \\p FD is an aligned allocation or deallocation\n  /// function that is unavailable.\n  bool isUnavailableAlignedAllocationFunction(const FunctionDecl &FD) const;\n\n  /// Produce diagnostics if \\p FD is an aligned allocation or deallocation\n  /// function that is unavailable.\n  void diagnoseUnavailableAlignedAllocation(const FunctionDecl &FD,\n                                            SourceLocation Loc);\n\n  bool CheckAllocatedType(QualType AllocType, SourceLocation Loc,\n                          SourceRange R);\n\n  /// The scope in which to find allocation functions.\n  enum AllocationFunctionScope {\n    /// Only look for allocation functions in the global scope.\n    AFS_Global,\n    /// Only look for allocation functions in the scope of the\n    /// allocated class.\n    AFS_Class,\n    /// Look for allocation functions in both the global scope\n    /// and in the scope of the allocated class.\n    AFS_Both\n  };\n\n  /// Finds the overloads of operator new and delete that are appropriate\n  /// for the allocation.\n  bool FindAllocationFunctions(SourceLocation StartLoc, SourceRange Range,\n                               AllocationFunctionScope NewScope,\n                               AllocationFunctionScope DeleteScope,\n                               QualType AllocType, bool IsArray,\n                               bool &PassAlignment, MultiExprArg PlaceArgs,\n                               FunctionDecl *&OperatorNew,\n                               FunctionDecl *&OperatorDelete,\n                               bool Diagnose = true);\n  void DeclareGlobalNewDelete();\n  void DeclareGlobalAllocationFunction(DeclarationName Name, QualType Return,\n                                       ArrayRef<QualType> Params);\n\n  bool FindDeallocationFunction(SourceLocation StartLoc, CXXRecordDecl *RD,\n                                DeclarationName Name, FunctionDecl* &Operator,\n                                bool Diagnose = true);\n  FunctionDecl *FindUsualDeallocationFunction(SourceLocation StartLoc,\n                                              bool CanProvideSize,\n                                              bool Overaligned,\n                                              DeclarationName Name);\n  FunctionDecl *FindDeallocationFunctionForDestructor(SourceLocation StartLoc,\n                                                      CXXRecordDecl *RD);\n\n  /// ActOnCXXDelete - Parsed a C++ 'delete' expression\n  ExprResult ActOnCXXDelete(SourceLocation StartLoc,\n                            bool UseGlobal, bool ArrayForm,\n                            Expr *Operand);\n  void CheckVirtualDtorCall(CXXDestructorDecl *dtor, SourceLocation Loc,\n                            bool IsDelete, bool CallCanBeVirtual,\n                            bool WarnOnNonAbstractTypes,\n                            SourceLocation DtorLoc);\n\n  ExprResult ActOnNoexceptExpr(SourceLocation KeyLoc, SourceLocation LParen,\n                               Expr *Operand, SourceLocation RParen);\n  ExprResult BuildCXXNoexceptExpr(SourceLocation KeyLoc, Expr *Operand,\n                                  SourceLocation RParen);\n\n  /// Parsed one of the type trait support pseudo-functions.\n  ExprResult ActOnTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                            ArrayRef<ParsedType> Args,\n                            SourceLocation RParenLoc);\n  ExprResult BuildTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                            ArrayRef<TypeSourceInfo *> Args,\n                            SourceLocation RParenLoc);\n\n  /// ActOnArrayTypeTrait - Parsed one of the binary type trait support\n  /// pseudo-functions.\n  ExprResult ActOnArrayTypeTrait(ArrayTypeTrait ATT,\n                                 SourceLocation KWLoc,\n                                 ParsedType LhsTy,\n                                 Expr *DimExpr,\n                                 SourceLocation RParen);\n\n  ExprResult BuildArrayTypeTrait(ArrayTypeTrait ATT,\n                                 SourceLocation KWLoc,\n                                 TypeSourceInfo *TSInfo,\n                                 Expr *DimExpr,\n                                 SourceLocation RParen);\n\n  /// ActOnExpressionTrait - Parsed one of the unary type trait support\n  /// pseudo-functions.\n  ExprResult ActOnExpressionTrait(ExpressionTrait OET,\n                                  SourceLocation KWLoc,\n                                  Expr *Queried,\n                                  SourceLocation RParen);\n\n  ExprResult BuildExpressionTrait(ExpressionTrait OET,\n                                  SourceLocation KWLoc,\n                                  Expr *Queried,\n                                  SourceLocation RParen);\n\n  ExprResult ActOnStartCXXMemberReference(Scope *S,\n                                          Expr *Base,\n                                          SourceLocation OpLoc,\n                                          tok::TokenKind OpKind,\n                                          ParsedType &ObjectType,\n                                          bool &MayBePseudoDestructor);\n\n  ExprResult BuildPseudoDestructorExpr(Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       const CXXScopeSpec &SS,\n                                       TypeSourceInfo *ScopeType,\n                                       SourceLocation CCLoc,\n                                       SourceLocation TildeLoc,\n                                     PseudoDestructorTypeStorage DestroyedType);\n\n  ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       CXXScopeSpec &SS,\n                                       UnqualifiedId &FirstTypeName,\n                                       SourceLocation CCLoc,\n                                       SourceLocation TildeLoc,\n                                       UnqualifiedId &SecondTypeName);\n\n  ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       SourceLocation TildeLoc,\n                                       const DeclSpec& DS);\n\n  /// MaybeCreateExprWithCleanups - If the current full-expression\n  /// requires any cleanups, surround it with a ExprWithCleanups node.\n  /// Otherwise, just returns the passed-in expression.\n  Expr *MaybeCreateExprWithCleanups(Expr *SubExpr);\n  Stmt *MaybeCreateStmtWithCleanups(Stmt *SubStmt);\n  ExprResult MaybeCreateExprWithCleanups(ExprResult SubExpr);\n\n  MaterializeTemporaryExpr *\n  CreateMaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                                 bool BoundToLvalueReference);\n\n  ExprResult ActOnFinishFullExpr(Expr *Expr, bool DiscardedValue) {\n    return ActOnFinishFullExpr(\n        Expr, Expr ? Expr->getExprLoc() : SourceLocation(), DiscardedValue);\n  }\n  ExprResult ActOnFinishFullExpr(Expr *Expr, SourceLocation CC,\n                                 bool DiscardedValue, bool IsConstexpr = false);\n  StmtResult ActOnFinishFullStmt(Stmt *Stmt);\n\n  // Marks SS invalid if it represents an incomplete type.\n  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *DC);\n\n  DeclContext *computeDeclContext(QualType T);\n  DeclContext *computeDeclContext(const CXXScopeSpec &SS,\n                                  bool EnteringContext = false);\n  bool isDependentScopeSpecifier(const CXXScopeSpec &SS);\n  CXXRecordDecl *getCurrentInstantiationOf(NestedNameSpecifier *NNS);\n\n  /// The parser has parsed a global nested-name-specifier '::'.\n  ///\n  /// \\param CCLoc The location of the '::'.\n  ///\n  /// \\param SS The nested-name-specifier, which will be updated in-place\n  /// to reflect the parsed nested-name-specifier.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXGlobalScopeSpecifier(SourceLocation CCLoc, CXXScopeSpec &SS);\n\n  /// The parser has parsed a '__super' nested-name-specifier.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  ///\n  /// \\param ColonColonLoc The location of the '::'.\n  ///\n  /// \\param SS The nested-name-specifier, which will be updated in-place\n  /// to reflect the parsed nested-name-specifier.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnSuperScopeSpecifier(SourceLocation SuperLoc,\n                                SourceLocation ColonColonLoc, CXXScopeSpec &SS);\n\n  bool isAcceptableNestedNameSpecifier(const NamedDecl *SD,\n                                       bool *CanCorrect = nullptr);\n  NamedDecl *FindFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS);\n\n  /// Keeps information about an identifier in a nested-name-spec.\n  ///\n  struct NestedNameSpecInfo {\n    /// The type of the object, if we're parsing nested-name-specifier in\n    /// a member access expression.\n    ParsedType ObjectType;\n\n    /// The identifier preceding the '::'.\n    IdentifierInfo *Identifier;\n\n    /// The location of the identifier.\n    SourceLocation IdentifierLoc;\n\n    /// The location of the '::'.\n    SourceLocation CCLoc;\n\n    /// Creates info object for the most typical case.\n    NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,\n             SourceLocation ColonColonLoc, ParsedType ObjectType = ParsedType())\n      : ObjectType(ObjectType), Identifier(II), IdentifierLoc(IdLoc),\n        CCLoc(ColonColonLoc) {\n    }\n\n    NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,\n                       SourceLocation ColonColonLoc, QualType ObjectType)\n      : ObjectType(ParsedType::make(ObjectType)), Identifier(II),\n        IdentifierLoc(IdLoc), CCLoc(ColonColonLoc) {\n    }\n  };\n\n  bool isNonTypeNestedNameSpecifier(Scope *S, CXXScopeSpec &SS,\n                                    NestedNameSpecInfo &IdInfo);\n\n  bool BuildCXXNestedNameSpecifier(Scope *S,\n                                   NestedNameSpecInfo &IdInfo,\n                                   bool EnteringContext,\n                                   CXXScopeSpec &SS,\n                                   NamedDecl *ScopeLookupResult,\n                                   bool ErrorRecoveryLookup,\n                                   bool *IsCorrectedToColon = nullptr,\n                                   bool OnlyNamespace = false);\n\n  /// The parser has parsed a nested-name-specifier 'identifier::'.\n  ///\n  /// \\param S The scope in which this nested-name-specifier occurs.\n  ///\n  /// \\param IdInfo Parser information about an identifier in the\n  /// nested-name-spec.\n  ///\n  /// \\param EnteringContext Whether we're entering the context nominated by\n  /// this nested-name-specifier.\n  ///\n  /// \\param SS The nested-name-specifier, which is both an input\n  /// parameter (the nested-name-specifier before this type) and an\n  /// output parameter (containing the full nested-name-specifier,\n  /// including this new type).\n  ///\n  /// \\param ErrorRecoveryLookup If true, then this method is called to improve\n  /// error recovery. In this case do not emit error message.\n  ///\n  /// \\param IsCorrectedToColon If not null, suggestions to replace '::' -> ':'\n  /// are allowed.  The bool value pointed by this parameter is set to 'true'\n  /// if the identifier is treated as if it was followed by ':', not '::'.\n  ///\n  /// \\param OnlyNamespace If true, only considers namespaces in lookup.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXNestedNameSpecifier(Scope *S,\n                                   NestedNameSpecInfo &IdInfo,\n                                   bool EnteringContext,\n                                   CXXScopeSpec &SS,\n                                   bool ErrorRecoveryLookup = false,\n                                   bool *IsCorrectedToColon = nullptr,\n                                   bool OnlyNamespace = false);\n\n  ExprResult ActOnDecltypeExpression(Expr *E);\n\n  bool ActOnCXXNestedNameSpecifierDecltype(CXXScopeSpec &SS,\n                                           const DeclSpec &DS,\n                                           SourceLocation ColonColonLoc);\n\n  bool IsInvalidUnlessNestedName(Scope *S, CXXScopeSpec &SS,\n                                 NestedNameSpecInfo &IdInfo,\n                                 bool EnteringContext);\n\n  /// The parser has parsed a nested-name-specifier\n  /// 'template[opt] template-name < template-args >::'.\n  ///\n  /// \\param S The scope in which this nested-name-specifier occurs.\n  ///\n  /// \\param SS The nested-name-specifier, which is both an input\n  /// parameter (the nested-name-specifier before this type) and an\n  /// output parameter (containing the full nested-name-specifier,\n  /// including this new type).\n  ///\n  /// \\param TemplateKWLoc the location of the 'template' keyword, if any.\n  /// \\param TemplateName the template name.\n  /// \\param TemplateNameLoc The location of the template name.\n  /// \\param LAngleLoc The location of the opening angle bracket  ('<').\n  /// \\param TemplateArgs The template arguments.\n  /// \\param RAngleLoc The location of the closing angle bracket  ('>').\n  /// \\param CCLoc The location of the '::'.\n  ///\n  /// \\param EnteringContext Whether we're entering the context of the\n  /// nested-name-specifier.\n  ///\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXNestedNameSpecifier(Scope *S,\n                                   CXXScopeSpec &SS,\n                                   SourceLocation TemplateKWLoc,\n                                   TemplateTy TemplateName,\n                                   SourceLocation TemplateNameLoc,\n                                   SourceLocation LAngleLoc,\n                                   ASTTemplateArgsPtr TemplateArgs,\n                                   SourceLocation RAngleLoc,\n                                   SourceLocation CCLoc,\n                                   bool EnteringContext);\n\n  /// Given a C++ nested-name-specifier, produce an annotation value\n  /// that the parser can use later to reconstruct the given\n  /// nested-name-specifier.\n  ///\n  /// \\param SS A nested-name-specifier.\n  ///\n  /// \\returns A pointer containing all of the information in the\n  /// nested-name-specifier \\p SS.\n  void *SaveNestedNameSpecifierAnnotation(CXXScopeSpec &SS);\n\n  /// Given an annotation pointer for a nested-name-specifier, restore\n  /// the nested-name-specifier structure.\n  ///\n  /// \\param Annotation The annotation pointer, produced by\n  /// \\c SaveNestedNameSpecifierAnnotation().\n  ///\n  /// \\param AnnotationRange The source range corresponding to the annotation.\n  ///\n  /// \\param SS The nested-name-specifier that will be updated with the contents\n  /// of the annotation pointer.\n  void RestoreNestedNameSpecifierAnnotation(void *Annotation,\n                                            SourceRange AnnotationRange,\n                                            CXXScopeSpec &SS);\n\n  bool ShouldEnterDeclaratorScope(Scope *S, const CXXScopeSpec &SS);\n\n  /// ActOnCXXEnterDeclaratorScope - Called when a C++ scope specifier (global\n  /// scope or nested-name-specifier) is parsed, part of a declarator-id.\n  /// After this method is called, according to [C++ 3.4.3p3], names should be\n  /// looked up in the declarator-id's scope, until the declarator is parsed and\n  /// ActOnCXXExitDeclaratorScope is called.\n  /// The 'SS' should be a non-empty valid CXXScopeSpec.\n  bool ActOnCXXEnterDeclaratorScope(Scope *S, CXXScopeSpec &SS);\n\n  /// ActOnCXXExitDeclaratorScope - Called when a declarator that previously\n  /// invoked ActOnCXXEnterDeclaratorScope(), is finished. 'SS' is the same\n  /// CXXScopeSpec that was passed to ActOnCXXEnterDeclaratorScope as well.\n  /// Used to indicate that names should revert to being looked up in the\n  /// defining scope.\n  void ActOnCXXExitDeclaratorScope(Scope *S, const CXXScopeSpec &SS);\n\n  /// ActOnCXXEnterDeclInitializer - Invoked when we are about to parse an\n  /// initializer for the declaration 'Dcl'.\n  /// After this method is called, according to [C++ 3.4.1p13], if 'Dcl' is a\n  /// static data member of class X, names should be looked up in the scope of\n  /// class X.\n  void ActOnCXXEnterDeclInitializer(Scope *S, Decl *Dcl);\n\n  /// ActOnCXXExitDeclInitializer - Invoked after we are finished parsing an\n  /// initializer for the declaration 'Dcl'.\n  void ActOnCXXExitDeclInitializer(Scope *S, Decl *Dcl);\n\n  /// Create a new lambda closure type.\n  CXXRecordDecl *createLambdaClosureType(SourceRange IntroducerRange,\n                                         TypeSourceInfo *Info,\n                                         bool KnownDependent,\n                                         LambdaCaptureDefault CaptureDefault);\n\n  /// Start the definition of a lambda expression.\n  CXXMethodDecl *startLambdaDefinition(CXXRecordDecl *Class,\n                                       SourceRange IntroducerRange,\n                                       TypeSourceInfo *MethodType,\n                                       SourceLocation EndLoc,\n                                       ArrayRef<ParmVarDecl *> Params,\n                                       ConstexprSpecKind ConstexprKind,\n                                       Expr *TrailingRequiresClause);\n\n  /// Number lambda for linkage purposes if necessary.\n  void handleLambdaNumbering(\n      CXXRecordDecl *Class, CXXMethodDecl *Method,\n      Optional<std::tuple<bool, unsigned, unsigned, Decl *>> Mangling = None);\n\n  /// Endow the lambda scope info with the relevant properties.\n  void buildLambdaScope(sema::LambdaScopeInfo *LSI,\n                        CXXMethodDecl *CallOperator,\n                        SourceRange IntroducerRange,\n                        LambdaCaptureDefault CaptureDefault,\n                        SourceLocation CaptureDefaultLoc,\n                        bool ExplicitParams,\n                        bool ExplicitResultType,\n                        bool Mutable);\n\n  /// Perform initialization analysis of the init-capture and perform\n  /// any implicit conversions such as an lvalue-to-rvalue conversion if\n  /// not being used to initialize a reference.\n  ParsedType actOnLambdaInitCaptureInitialization(\n      SourceLocation Loc, bool ByRef, SourceLocation EllipsisLoc,\n      IdentifierInfo *Id, LambdaCaptureInitKind InitKind, Expr *&Init) {\n    return ParsedType::make(buildLambdaInitCaptureInitialization(\n        Loc, ByRef, EllipsisLoc, None, Id,\n        InitKind != LambdaCaptureInitKind::CopyInit, Init));\n  }\n  QualType buildLambdaInitCaptureInitialization(\n      SourceLocation Loc, bool ByRef, SourceLocation EllipsisLoc,\n      Optional<unsigned> NumExpansions, IdentifierInfo *Id, bool DirectInit,\n      Expr *&Init);\n\n  /// Create a dummy variable within the declcontext of the lambda's\n  ///  call operator, for name lookup purposes for a lambda init capture.\n  ///\n  ///  CodeGen handles emission of lambda captures, ignoring these dummy\n  ///  variables appropriately.\n  VarDecl *createLambdaInitCaptureVarDecl(SourceLocation Loc,\n                                          QualType InitCaptureType,\n                                          SourceLocation EllipsisLoc,\n                                          IdentifierInfo *Id,\n                                          unsigned InitStyle, Expr *Init);\n\n  /// Add an init-capture to a lambda scope.\n  void addInitCapture(sema::LambdaScopeInfo *LSI, VarDecl *Var);\n\n  /// Note that we have finished the explicit captures for the\n  /// given lambda.\n  void finishLambdaExplicitCaptures(sema::LambdaScopeInfo *LSI);\n\n  /// \\brief This is called after parsing the explicit template parameter list\n  /// on a lambda (if it exists) in C++2a.\n  void ActOnLambdaExplicitTemplateParameterList(SourceLocation LAngleLoc,\n                                                ArrayRef<NamedDecl *> TParams,\n                                                SourceLocation RAngleLoc,\n                                                ExprResult RequiresClause);\n\n  /// Introduce the lambda parameters into scope.\n  void addLambdaParameters(\n      ArrayRef<LambdaIntroducer::LambdaCapture> Captures,\n      CXXMethodDecl *CallOperator, Scope *CurScope);\n\n  /// Deduce a block or lambda's return type based on the return\n  /// statements present in the body.\n  void deduceClosureReturnType(sema::CapturingScopeInfo &CSI);\n\n  /// ActOnStartOfLambdaDefinition - This is called just before we start\n  /// parsing the body of a lambda; it analyzes the explicit captures and\n  /// arguments, and sets up various data-structures for the body of the\n  /// lambda.\n  void ActOnStartOfLambdaDefinition(LambdaIntroducer &Intro,\n                                    Declarator &ParamInfo, Scope *CurScope);\n\n  /// ActOnLambdaError - If there is an error parsing a lambda, this callback\n  /// is invoked to pop the information about the lambda.\n  void ActOnLambdaError(SourceLocation StartLoc, Scope *CurScope,\n                        bool IsInstantiation = false);\n\n  /// ActOnLambdaExpr - This is called when the body of a lambda expression\n  /// was successfully completed.\n  ExprResult ActOnLambdaExpr(SourceLocation StartLoc, Stmt *Body,\n                             Scope *CurScope);\n\n  /// Does copying/destroying the captured variable have side effects?\n  bool CaptureHasSideEffects(const sema::Capture &From);\n\n  /// Diagnose if an explicit lambda capture is unused. Returns true if a\n  /// diagnostic is emitted.\n  bool DiagnoseUnusedLambdaCapture(SourceRange CaptureRange,\n                                   const sema::Capture &From);\n\n  /// Build a FieldDecl suitable to hold the given capture.\n  FieldDecl *BuildCaptureField(RecordDecl *RD, const sema::Capture &Capture);\n\n  /// Initialize the given capture with a suitable expression.\n  ExprResult BuildCaptureInit(const sema::Capture &Capture,\n                              SourceLocation ImplicitCaptureLoc,\n                              bool IsOpenMPMapping = false);\n\n  /// Complete a lambda-expression having processed and attached the\n  /// lambda body.\n  ExprResult BuildLambdaExpr(SourceLocation StartLoc, SourceLocation EndLoc,\n                             sema::LambdaScopeInfo *LSI);\n\n  /// Get the return type to use for a lambda's conversion function(s) to\n  /// function pointer type, given the type of the call operator.\n  QualType\n  getLambdaConversionFunctionResultType(const FunctionProtoType *CallOpType,\n                                        CallingConv CC);\n\n  /// Define the \"body\" of the conversion from a lambda object to a\n  /// function pointer.\n  ///\n  /// This routine doesn't actually define a sensible body; rather, it fills\n  /// in the initialization expression needed to copy the lambda object into\n  /// the block, and IR generation actually generates the real body of the\n  /// block pointer conversion.\n  void DefineImplicitLambdaToFunctionPointerConversion(\n         SourceLocation CurrentLoc, CXXConversionDecl *Conv);\n\n  /// Define the \"body\" of the conversion from a lambda object to a\n  /// block pointer.\n  ///\n  /// This routine doesn't actually define a sensible body; rather, it fills\n  /// in the initialization expression needed to copy the lambda object into\n  /// the block, and IR generation actually generates the real body of the\n  /// block pointer conversion.\n  void DefineImplicitLambdaToBlockPointerConversion(SourceLocation CurrentLoc,\n                                                    CXXConversionDecl *Conv);\n\n  ExprResult BuildBlockForLambdaConversion(SourceLocation CurrentLocation,\n                                           SourceLocation ConvLocation,\n                                           CXXConversionDecl *Conv,\n                                           Expr *Src);\n\n  /// Check whether the given expression is a valid constraint expression.\n  /// A diagnostic is emitted if it is not, false is returned, and\n  /// PossibleNonPrimary will be set to true if the failure might be due to a\n  /// non-primary expression being used as an atomic constraint.\n  bool CheckConstraintExpression(const Expr *CE, Token NextToken = Token(),\n                                 bool *PossibleNonPrimary = nullptr,\n                                 bool IsTrailingRequiresClause = false);\n\nprivate:\n  /// Caches pairs of template-like decls whose associated constraints were\n  /// checked for subsumption and whether or not the first's constraints did in\n  /// fact subsume the second's.\n  llvm::DenseMap<std::pair<NamedDecl *, NamedDecl *>, bool> SubsumptionCache;\n  /// Caches the normalized associated constraints of declarations (concepts or\n  /// constrained declarations). If an error occurred while normalizing the\n  /// associated constraints of the template or concept, nullptr will be cached\n  /// here.\n  llvm::DenseMap<NamedDecl *, NormalizedConstraint *>\n      NormalizationCache;\n\n  llvm::ContextualFoldingSet<ConstraintSatisfaction, const ASTContext &>\n      SatisfactionCache;\n\npublic:\n  const NormalizedConstraint *\n  getNormalizedAssociatedConstraints(\n      NamedDecl *ConstrainedDecl, ArrayRef<const Expr *> AssociatedConstraints);\n\n  /// \\brief Check whether the given declaration's associated constraints are\n  /// at least as constrained than another declaration's according to the\n  /// partial ordering of constraints.\n  ///\n  /// \\param Result If no error occurred, receives the result of true if D1 is\n  /// at least constrained than D2, and false otherwise.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool IsAtLeastAsConstrained(NamedDecl *D1, ArrayRef<const Expr *> AC1,\n                              NamedDecl *D2, ArrayRef<const Expr *> AC2,\n                              bool &Result);\n\n  /// If D1 was not at least as constrained as D2, but would've been if a pair\n  /// of atomic constraints involved had been declared in a concept and not\n  /// repeated in two separate places in code.\n  /// \\returns true if such a diagnostic was emitted, false otherwise.\n  bool MaybeEmitAmbiguousAtomicConstraintsDiagnostic(NamedDecl *D1,\n      ArrayRef<const Expr *> AC1, NamedDecl *D2, ArrayRef<const Expr *> AC2);\n\n  /// \\brief Check whether the given list of constraint expressions are\n  /// satisfied (as if in a 'conjunction') given template arguments.\n  /// \\param Template the template-like entity that triggered the constraints\n  /// check (either a concept or a constrained entity).\n  /// \\param ConstraintExprs a list of constraint expressions, treated as if\n  /// they were 'AND'ed together.\n  /// \\param TemplateArgs the list of template arguments to substitute into the\n  /// constraint expression.\n  /// \\param TemplateIDRange The source range of the template id that\n  /// caused the constraints check.\n  /// \\param Satisfaction if true is returned, will contain details of the\n  /// satisfaction, with enough information to diagnose an unsatisfied\n  /// expression.\n  /// \\returns true if an error occurred and satisfaction could not be checked,\n  /// false otherwise.\n  bool CheckConstraintSatisfaction(\n      const NamedDecl *Template, ArrayRef<const Expr *> ConstraintExprs,\n      ArrayRef<TemplateArgument> TemplateArgs,\n      SourceRange TemplateIDRange, ConstraintSatisfaction &Satisfaction);\n\n  /// \\brief Check whether the given non-dependent constraint expression is\n  /// satisfied. Returns false and updates Satisfaction with the satisfaction\n  /// verdict if successful, emits a diagnostic and returns true if an error\n  /// occured and satisfaction could not be determined.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckConstraintSatisfaction(const Expr *ConstraintExpr,\n                                   ConstraintSatisfaction &Satisfaction);\n\n  /// Check whether the given function decl's trailing requires clause is\n  /// satisfied, if any. Returns false and updates Satisfaction with the\n  /// satisfaction verdict if successful, emits a diagnostic and returns true if\n  /// an error occured and satisfaction could not be determined.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckFunctionConstraints(const FunctionDecl *FD,\n                                ConstraintSatisfaction &Satisfaction,\n                                SourceLocation UsageLoc = SourceLocation());\n\n\n  /// \\brief Ensure that the given template arguments satisfy the constraints\n  /// associated with the given template, emitting a diagnostic if they do not.\n  ///\n  /// \\param Template The template to which the template arguments are being\n  /// provided.\n  ///\n  /// \\param TemplateArgs The converted, canonicalized template arguments.\n  ///\n  /// \\param TemplateIDRange The source range of the template id that\n  /// caused the constraints check.\n  ///\n  /// \\returns true if the constrains are not satisfied or could not be checked\n  /// for satisfaction, false if the constraints are satisfied.\n  bool EnsureTemplateArgumentListConstraints(TemplateDecl *Template,\n                                       ArrayRef<TemplateArgument> TemplateArgs,\n                                             SourceRange TemplateIDRange);\n\n  /// \\brief Emit diagnostics explaining why a constraint expression was deemed\n  /// unsatisfied.\n  /// \\param First whether this is the first time an unsatisfied constraint is\n  /// diagnosed for this error.\n  void\n  DiagnoseUnsatisfiedConstraint(const ConstraintSatisfaction &Satisfaction,\n                                bool First = true);\n\n  /// \\brief Emit diagnostics explaining why a constraint expression was deemed\n  /// unsatisfied.\n  void\n  DiagnoseUnsatisfiedConstraint(const ASTConstraintSatisfaction &Satisfaction,\n                                bool First = true);\n\n  // ParseObjCStringLiteral - Parse Objective-C string literals.\n  ExprResult ParseObjCStringLiteral(SourceLocation *AtLocs,\n                                    ArrayRef<Expr *> Strings);\n\n  ExprResult BuildObjCStringLiteral(SourceLocation AtLoc, StringLiteral *S);\n\n  /// BuildObjCNumericLiteral - builds an ObjCBoxedExpr AST node for the\n  /// numeric literal expression. Type of the expression will be \"NSNumber *\"\n  /// or \"id\" if NSNumber is unavailable.\n  ExprResult BuildObjCNumericLiteral(SourceLocation AtLoc, Expr *Number);\n  ExprResult ActOnObjCBoolLiteral(SourceLocation AtLoc, SourceLocation ValueLoc,\n                                  bool Value);\n  ExprResult BuildObjCArrayLiteral(SourceRange SR, MultiExprArg Elements);\n\n  /// BuildObjCBoxedExpr - builds an ObjCBoxedExpr AST node for the\n  /// '@' prefixed parenthesized expression. The type of the expression will\n  /// either be \"NSNumber *\", \"NSString *\" or \"NSValue *\" depending on the type\n  /// of ValueType, which is allowed to be a built-in numeric type, \"char *\",\n  /// \"const char *\" or C structure with attribute 'objc_boxable'.\n  ExprResult BuildObjCBoxedExpr(SourceRange SR, Expr *ValueExpr);\n\n  ExprResult BuildObjCSubscriptExpression(SourceLocation RB, Expr *BaseExpr,\n                                          Expr *IndexExpr,\n                                          ObjCMethodDecl *getterMethod,\n                                          ObjCMethodDecl *setterMethod);\n\n  ExprResult BuildObjCDictionaryLiteral(SourceRange SR,\n                               MutableArrayRef<ObjCDictionaryElement> Elements);\n\n  ExprResult BuildObjCEncodeExpression(SourceLocation AtLoc,\n                                  TypeSourceInfo *EncodedTypeInfo,\n                                  SourceLocation RParenLoc);\n  ExprResult BuildCXXMemberCallExpr(Expr *Exp, NamedDecl *FoundDecl,\n                                    CXXConversionDecl *Method,\n                                    bool HadMultipleCandidates);\n\n  ExprResult ParseObjCEncodeExpression(SourceLocation AtLoc,\n                                       SourceLocation EncodeLoc,\n                                       SourceLocation LParenLoc,\n                                       ParsedType Ty,\n                                       SourceLocation RParenLoc);\n\n  /// ParseObjCSelectorExpression - Build selector expression for \\@selector\n  ExprResult ParseObjCSelectorExpression(Selector Sel,\n                                         SourceLocation AtLoc,\n                                         SourceLocation SelLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation RParenLoc,\n                                         bool WarnMultipleSelectors);\n\n  /// ParseObjCProtocolExpression - Build protocol expression for \\@protocol\n  ExprResult ParseObjCProtocolExpression(IdentifierInfo * ProtocolName,\n                                         SourceLocation AtLoc,\n                                         SourceLocation ProtoLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation ProtoIdLoc,\n                                         SourceLocation RParenLoc);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Declarations\n  //\n  Decl *ActOnStartLinkageSpecification(Scope *S,\n                                       SourceLocation ExternLoc,\n                                       Expr *LangStr,\n                                       SourceLocation LBraceLoc);\n  Decl *ActOnFinishLinkageSpecification(Scope *S,\n                                        Decl *LinkageSpec,\n                                        SourceLocation RBraceLoc);\n\n\n  //===--------------------------------------------------------------------===//\n  // C++ Classes\n  //\n  CXXRecordDecl *getCurrentClass(Scope *S, const CXXScopeSpec *SS);\n  bool isCurrentClassName(const IdentifierInfo &II, Scope *S,\n                          const CXXScopeSpec *SS = nullptr);\n  bool isCurrentClassNameTypo(IdentifierInfo *&II, const CXXScopeSpec *SS);\n\n  bool ActOnAccessSpecifier(AccessSpecifier Access, SourceLocation ASLoc,\n                            SourceLocation ColonLoc,\n                            const ParsedAttributesView &Attrs);\n\n  NamedDecl *ActOnCXXMemberDeclarator(Scope *S, AccessSpecifier AS,\n                                 Declarator &D,\n                                 MultiTemplateParamsArg TemplateParameterLists,\n                                 Expr *BitfieldWidth, const VirtSpecifiers &VS,\n                                 InClassInitStyle InitStyle);\n\n  void ActOnStartCXXInClassMemberInitializer();\n  void ActOnFinishCXXInClassMemberInitializer(Decl *VarDecl,\n                                              SourceLocation EqualLoc,\n                                              Expr *Init);\n\n  MemInitResult ActOnMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    SourceLocation LParenLoc,\n                                    ArrayRef<Expr *> Args,\n                                    SourceLocation RParenLoc,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult ActOnMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    Expr *InitList,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult BuildMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    Expr *Init,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult BuildMemberInitializer(ValueDecl *Member,\n                                       Expr *Init,\n                                       SourceLocation IdLoc);\n\n  MemInitResult BuildBaseInitializer(QualType BaseType,\n                                     TypeSourceInfo *BaseTInfo,\n                                     Expr *Init,\n                                     CXXRecordDecl *ClassDecl,\n                                     SourceLocation EllipsisLoc);\n\n  MemInitResult BuildDelegatingInitializer(TypeSourceInfo *TInfo,\n                                           Expr *Init,\n                                           CXXRecordDecl *ClassDecl);\n\n  bool SetDelegatingInitializer(CXXConstructorDecl *Constructor,\n                                CXXCtorInitializer *Initializer);\n\n  bool SetCtorInitializers(CXXConstructorDecl *Constructor, bool AnyErrors,\n                           ArrayRef<CXXCtorInitializer *> Initializers = None);\n\n  void SetIvarInitializers(ObjCImplementationDecl *ObjCImplementation);\n\n\n  /// MarkBaseAndMemberDestructorsReferenced - Given a record decl,\n  /// mark all the non-trivial destructors of its members and bases as\n  /// referenced.\n  void MarkBaseAndMemberDestructorsReferenced(SourceLocation Loc,\n                                              CXXRecordDecl *Record);\n\n  /// Mark destructors of virtual bases of this class referenced. In the Itanium\n  /// C++ ABI, this is done when emitting a destructor for any non-abstract\n  /// class. In the Microsoft C++ ABI, this is done any time a class's\n  /// destructor is referenced.\n  void MarkVirtualBaseDestructorsReferenced(\n      SourceLocation Location, CXXRecordDecl *ClassDecl,\n      llvm::SmallPtrSetImpl<const RecordType *> *DirectVirtualBases = nullptr);\n\n  /// Do semantic checks to allow the complete destructor variant to be emitted\n  /// when the destructor is defined in another translation unit. In the Itanium\n  /// C++ ABI, destructor variants are emitted together. In the MS C++ ABI, they\n  /// can be emitted in separate TUs. To emit the complete variant, run a subset\n  /// of the checks performed when emitting a regular destructor.\n  void CheckCompleteDestructorVariant(SourceLocation CurrentLocation,\n                                      CXXDestructorDecl *Dtor);\n\n  /// The list of classes whose vtables have been used within\n  /// this translation unit, and the source locations at which the\n  /// first use occurred.\n  typedef std::pair<CXXRecordDecl*, SourceLocation> VTableUse;\n\n  /// The list of vtables that are required but have not yet been\n  /// materialized.\n  SmallVector<VTableUse, 16> VTableUses;\n\n  /// The set of classes whose vtables have been used within\n  /// this translation unit, and a bit that will be true if the vtable is\n  /// required to be emitted (otherwise, it should be emitted only if needed\n  /// by code generation).\n  llvm::DenseMap<CXXRecordDecl *, bool> VTablesUsed;\n\n  /// Load any externally-stored vtable uses.\n  void LoadExternalVTableUses();\n\n  /// Note that the vtable for the given class was used at the\n  /// given location.\n  void MarkVTableUsed(SourceLocation Loc, CXXRecordDecl *Class,\n                      bool DefinitionRequired = false);\n\n  /// Mark the exception specifications of all virtual member functions\n  /// in the given class as needed.\n  void MarkVirtualMemberExceptionSpecsNeeded(SourceLocation Loc,\n                                             const CXXRecordDecl *RD);\n\n  /// MarkVirtualMembersReferenced - Will mark all members of the given\n  /// CXXRecordDecl referenced.\n  void MarkVirtualMembersReferenced(SourceLocation Loc, const CXXRecordDecl *RD,\n                                    bool ConstexprOnly = false);\n\n  /// Define all of the vtables that have been used in this\n  /// translation unit and reference any virtual members used by those\n  /// vtables.\n  ///\n  /// \\returns true if any work was done, false otherwise.\n  bool DefineUsedVTables();\n\n  void AddImplicitlyDeclaredMembersToClass(CXXRecordDecl *ClassDecl);\n\n  void ActOnMemInitializers(Decl *ConstructorDecl,\n                            SourceLocation ColonLoc,\n                            ArrayRef<CXXCtorInitializer*> MemInits,\n                            bool AnyErrors);\n\n  /// Check class-level dllimport/dllexport attribute. The caller must\n  /// ensure that referenceDLLExportedClassMethods is called some point later\n  /// when all outer classes of Class are complete.\n  void checkClassLevelDLLAttribute(CXXRecordDecl *Class);\n  void checkClassLevelCodeSegAttribute(CXXRecordDecl *Class);\n\n  void referenceDLLExportedClassMethods();\n\n  void propagateDLLAttrToBaseClassTemplate(\n      CXXRecordDecl *Class, Attr *ClassAttr,\n      ClassTemplateSpecializationDecl *BaseTemplateSpec,\n      SourceLocation BaseLoc);\n\n  /// Add gsl::Pointer attribute to std::container::iterator\n  /// \\param ND The declaration that introduces the name\n  /// std::container::iterator. \\param UnderlyingRecord The record named by ND.\n  void inferGslPointerAttribute(NamedDecl *ND, CXXRecordDecl *UnderlyingRecord);\n\n  /// Add [[gsl::Owner]] and [[gsl::Pointer]] attributes for std:: types.\n  void inferGslOwnerPointerAttribute(CXXRecordDecl *Record);\n\n  /// Add [[gsl::Pointer]] attributes for std:: types.\n  void inferGslPointerAttribute(TypedefNameDecl *TD);\n\n  void CheckCompletedCXXClass(Scope *S, CXXRecordDecl *Record);\n\n  /// Check that the C++ class annoated with \"trivial_abi\" satisfies all the\n  /// conditions that are needed for the attribute to have an effect.\n  void checkIllFormedTrivialABIStruct(CXXRecordDecl &RD);\n\n  void ActOnFinishCXXMemberSpecification(Scope *S, SourceLocation RLoc,\n                                         Decl *TagDecl, SourceLocation LBrac,\n                                         SourceLocation RBrac,\n                                         const ParsedAttributesView &AttrList);\n  void ActOnFinishCXXMemberDecls();\n  void ActOnFinishCXXNonNestedClass();\n\n  void ActOnReenterCXXMethodParameter(Scope *S, ParmVarDecl *Param);\n  unsigned ActOnReenterTemplateScope(Decl *Template,\n                                     llvm::function_ref<Scope *()> EnterScope);\n  void ActOnStartDelayedMemberDeclarations(Scope *S, Decl *Record);\n  void ActOnStartDelayedCXXMethodDeclaration(Scope *S, Decl *Method);\n  void ActOnDelayedCXXMethodParameter(Scope *S, Decl *Param);\n  void ActOnFinishDelayedMemberDeclarations(Scope *S, Decl *Record);\n  void ActOnFinishDelayedCXXMethodDeclaration(Scope *S, Decl *Method);\n  void ActOnFinishDelayedMemberInitializers(Decl *Record);\n  void MarkAsLateParsedTemplate(FunctionDecl *FD, Decl *FnD,\n                                CachedTokens &Toks);\n  void UnmarkAsLateParsedTemplate(FunctionDecl *FD);\n  bool IsInsideALocalClassWithinATemplateFunction();\n\n  Decl *ActOnStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                     Expr *AssertExpr,\n                                     Expr *AssertMessageExpr,\n                                     SourceLocation RParenLoc);\n  Decl *BuildStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                     Expr *AssertExpr,\n                                     StringLiteral *AssertMessageExpr,\n                                     SourceLocation RParenLoc,\n                                     bool Failed);\n\n  FriendDecl *CheckFriendTypeDecl(SourceLocation LocStart,\n                                  SourceLocation FriendLoc,\n                                  TypeSourceInfo *TSInfo);\n  Decl *ActOnFriendTypeDecl(Scope *S, const DeclSpec &DS,\n                            MultiTemplateParamsArg TemplateParams);\n  NamedDecl *ActOnFriendFunctionDecl(Scope *S, Declarator &D,\n                                     MultiTemplateParamsArg TemplateParams);\n\n  QualType CheckConstructorDeclarator(Declarator &D, QualType R,\n                                      StorageClass& SC);\n  void CheckConstructor(CXXConstructorDecl *Constructor);\n  QualType CheckDestructorDeclarator(Declarator &D, QualType R,\n                                     StorageClass& SC);\n  bool CheckDestructor(CXXDestructorDecl *Destructor);\n  void CheckConversionDeclarator(Declarator &D, QualType &R,\n                                 StorageClass& SC);\n  Decl *ActOnConversionDeclarator(CXXConversionDecl *Conversion);\n  void CheckDeductionGuideDeclarator(Declarator &D, QualType &R,\n                                     StorageClass &SC);\n  void CheckDeductionGuideTemplate(FunctionTemplateDecl *TD);\n\n  void CheckExplicitlyDefaultedFunction(Scope *S, FunctionDecl *MD);\n\n  bool CheckExplicitlyDefaultedSpecialMember(CXXMethodDecl *MD,\n                                             CXXSpecialMember CSM);\n  void CheckDelayedMemberExceptionSpecs();\n\n  bool CheckExplicitlyDefaultedComparison(Scope *S, FunctionDecl *MD,\n                                          DefaultedComparisonKind DCK);\n  void DeclareImplicitEqualityComparison(CXXRecordDecl *RD,\n                                         FunctionDecl *Spaceship);\n  void DefineDefaultedComparison(SourceLocation Loc, FunctionDecl *FD,\n                                 DefaultedComparisonKind DCK);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Derived Classes\n  //\n\n  /// ActOnBaseSpecifier - Parsed a base specifier\n  CXXBaseSpecifier *CheckBaseSpecifier(CXXRecordDecl *Class,\n                                       SourceRange SpecifierRange,\n                                       bool Virtual, AccessSpecifier Access,\n                                       TypeSourceInfo *TInfo,\n                                       SourceLocation EllipsisLoc);\n\n  BaseResult ActOnBaseSpecifier(Decl *classdecl,\n                                SourceRange SpecifierRange,\n                                ParsedAttributes &Attrs,\n                                bool Virtual, AccessSpecifier Access,\n                                ParsedType basetype,\n                                SourceLocation BaseLoc,\n                                SourceLocation EllipsisLoc);\n\n  bool AttachBaseSpecifiers(CXXRecordDecl *Class,\n                            MutableArrayRef<CXXBaseSpecifier *> Bases);\n  void ActOnBaseSpecifiers(Decl *ClassDecl,\n                           MutableArrayRef<CXXBaseSpecifier *> Bases);\n\n  bool IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base);\n  bool IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base,\n                     CXXBasePaths &Paths);\n\n  // FIXME: I don't like this name.\n  void BuildBasePathArray(const CXXBasePaths &Paths, CXXCastPath &BasePath);\n\n  bool CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                    SourceLocation Loc, SourceRange Range,\n                                    CXXCastPath *BasePath = nullptr,\n                                    bool IgnoreAccess = false);\n  bool CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                    unsigned InaccessibleBaseID,\n                                    unsigned AmbiguousBaseConvID,\n                                    SourceLocation Loc, SourceRange Range,\n                                    DeclarationName Name,\n                                    CXXCastPath *BasePath,\n                                    bool IgnoreAccess = false);\n\n  std::string getAmbiguousPathsDisplayString(CXXBasePaths &Paths);\n\n  bool CheckOverridingFunctionAttributes(const CXXMethodDecl *New,\n                                         const CXXMethodDecl *Old);\n\n  /// CheckOverridingFunctionReturnType - Checks whether the return types are\n  /// covariant, according to C++ [class.virtual]p5.\n  bool CheckOverridingFunctionReturnType(const CXXMethodDecl *New,\n                                         const CXXMethodDecl *Old);\n\n  /// CheckOverridingFunctionExceptionSpec - Checks whether the exception\n  /// spec is a subset of base spec.\n  bool CheckOverridingFunctionExceptionSpec(const CXXMethodDecl *New,\n                                            const CXXMethodDecl *Old);\n\n  bool CheckPureMethod(CXXMethodDecl *Method, SourceRange InitRange);\n\n  /// CheckOverrideControl - Check C++11 override control semantics.\n  void CheckOverrideControl(NamedDecl *D);\n\n  /// DiagnoseAbsenceOfOverrideControl - Diagnose if 'override' keyword was\n  /// not used in the declaration of an overriding method.\n  void DiagnoseAbsenceOfOverrideControl(NamedDecl *D, bool Inconsistent);\n\n  /// CheckForFunctionMarkedFinal - Checks whether a virtual member function\n  /// overrides a virtual member function marked 'final', according to\n  /// C++11 [class.virtual]p4.\n  bool CheckIfOverriddenFunctionIsMarkedFinal(const CXXMethodDecl *New,\n                                              const CXXMethodDecl *Old);\n\n\n  //===--------------------------------------------------------------------===//\n  // C++ Access Control\n  //\n\n  enum AccessResult {\n    AR_accessible,\n    AR_inaccessible,\n    AR_dependent,\n    AR_delayed\n  };\n\n  bool SetMemberAccessSpecifier(NamedDecl *MemberDecl,\n                                NamedDecl *PrevMemberDecl,\n                                AccessSpecifier LexicalAS);\n\n  AccessResult CheckUnresolvedMemberAccess(UnresolvedMemberExpr *E,\n                                           DeclAccessPair FoundDecl);\n  AccessResult CheckUnresolvedLookupAccess(UnresolvedLookupExpr *E,\n                                           DeclAccessPair FoundDecl);\n  AccessResult CheckAllocationAccess(SourceLocation OperatorLoc,\n                                     SourceRange PlacementRange,\n                                     CXXRecordDecl *NamingClass,\n                                     DeclAccessPair FoundDecl,\n                                     bool Diagnose = true);\n  AccessResult CheckConstructorAccess(SourceLocation Loc,\n                                      CXXConstructorDecl *D,\n                                      DeclAccessPair FoundDecl,\n                                      const InitializedEntity &Entity,\n                                      bool IsCopyBindingRefToTemp = false);\n  AccessResult CheckConstructorAccess(SourceLocation Loc,\n                                      CXXConstructorDecl *D,\n                                      DeclAccessPair FoundDecl,\n                                      const InitializedEntity &Entity,\n                                      const PartialDiagnostic &PDiag);\n  AccessResult CheckDestructorAccess(SourceLocation Loc,\n                                     CXXDestructorDecl *Dtor,\n                                     const PartialDiagnostic &PDiag,\n                                     QualType objectType = QualType());\n  AccessResult CheckFriendAccess(NamedDecl *D);\n  AccessResult CheckMemberAccess(SourceLocation UseLoc,\n                                 CXXRecordDecl *NamingClass,\n                                 DeclAccessPair Found);\n  AccessResult\n  CheckStructuredBindingMemberAccess(SourceLocation UseLoc,\n                                     CXXRecordDecl *DecomposedClass,\n                                     DeclAccessPair Field);\n  AccessResult CheckMemberOperatorAccess(SourceLocation Loc,\n                                         Expr *ObjectExpr,\n                                         Expr *ArgExpr,\n                                         DeclAccessPair FoundDecl);\n  AccessResult CheckAddressOfMemberAccess(Expr *OvlExpr,\n                                          DeclAccessPair FoundDecl);\n  AccessResult CheckBaseClassAccess(SourceLocation AccessLoc,\n                                    QualType Base, QualType Derived,\n                                    const CXXBasePath &Path,\n                                    unsigned DiagID,\n                                    bool ForceCheck = false,\n                                    bool ForceUnprivileged = false);\n  void CheckLookupAccess(const LookupResult &R);\n  bool IsSimplyAccessible(NamedDecl *Decl, CXXRecordDecl *NamingClass,\n                          QualType BaseType);\n  bool isMemberAccessibleForDeletion(CXXRecordDecl *NamingClass,\n                                     DeclAccessPair Found, QualType ObjectType,\n                                     SourceLocation Loc,\n                                     const PartialDiagnostic &Diag);\n  bool isMemberAccessibleForDeletion(CXXRecordDecl *NamingClass,\n                                     DeclAccessPair Found,\n                                     QualType ObjectType) {\n    return isMemberAccessibleForDeletion(NamingClass, Found, ObjectType,\n                                         SourceLocation(), PDiag());\n  }\n\n  void HandleDependentAccessCheck(const DependentDiagnostic &DD,\n                         const MultiLevelTemplateArgumentList &TemplateArgs);\n  void PerformDependentDiagnostics(const DeclContext *Pattern,\n                        const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  void HandleDelayedAccessCheck(sema::DelayedDiagnostic &DD, Decl *Ctx);\n\n  /// When true, access checking violations are treated as SFINAE\n  /// failures rather than hard errors.\n  bool AccessCheckingSFINAE;\n\n  enum AbstractDiagSelID {\n    AbstractNone = -1,\n    AbstractReturnType,\n    AbstractParamType,\n    AbstractVariableType,\n    AbstractFieldType,\n    AbstractIvarType,\n    AbstractSynthesizedIvarType,\n    AbstractArrayType\n  };\n\n  bool isAbstractType(SourceLocation Loc, QualType T);\n  bool RequireNonAbstractType(SourceLocation Loc, QualType T,\n                              TypeDiagnoser &Diagnoser);\n  template <typename... Ts>\n  bool RequireNonAbstractType(SourceLocation Loc, QualType T, unsigned DiagID,\n                              const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireNonAbstractType(Loc, T, Diagnoser);\n  }\n\n  void DiagnoseAbstractType(const CXXRecordDecl *RD);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Overloaded Operators [C++ 13.5]\n  //\n\n  bool CheckOverloadedOperatorDeclaration(FunctionDecl *FnDecl);\n\n  bool CheckLiteralOperatorDeclaration(FunctionDecl *FnDecl);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Templates [C++ 14]\n  //\n  void FilterAcceptableTemplateNames(LookupResult &R,\n                                     bool AllowFunctionTemplates = true,\n                                     bool AllowDependent = true);\n  bool hasAnyAcceptableTemplateNames(LookupResult &R,\n                                     bool AllowFunctionTemplates = true,\n                                     bool AllowDependent = true,\n                                     bool AllowNonTemplateFunctions = false);\n  /// Try to interpret the lookup result D as a template-name.\n  ///\n  /// \\param D A declaration found by name lookup.\n  /// \\param AllowFunctionTemplates Whether function templates should be\n  ///        considered valid results.\n  /// \\param AllowDependent Whether unresolved using declarations (that might\n  ///        name templates) should be considered valid results.\n  static NamedDecl *getAsTemplateNameDecl(NamedDecl *D,\n                                          bool AllowFunctionTemplates = true,\n                                          bool AllowDependent = true);\n\n  enum TemplateNameIsRequiredTag { TemplateNameIsRequired };\n  /// Whether and why a template name is required in this lookup.\n  class RequiredTemplateKind {\n  public:\n    /// Template name is required if TemplateKWLoc is valid.\n    RequiredTemplateKind(SourceLocation TemplateKWLoc = SourceLocation())\n        : TemplateKW(TemplateKWLoc) {}\n    /// Template name is unconditionally required.\n    RequiredTemplateKind(TemplateNameIsRequiredTag) : TemplateKW() {}\n\n    SourceLocation getTemplateKeywordLoc() const {\n      return TemplateKW.getValueOr(SourceLocation());\n    }\n    bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n    bool isRequired() const { return TemplateKW != SourceLocation(); }\n    explicit operator bool() const { return isRequired(); }\n\n  private:\n    llvm::Optional<SourceLocation> TemplateKW;\n  };\n\n  enum class AssumedTemplateKind {\n    /// This is not assumed to be a template name.\n    None,\n    /// This is assumed to be a template name because lookup found nothing.\n    FoundNothing,\n    /// This is assumed to be a template name because lookup found one or more\n    /// functions (but no function templates).\n    FoundFunctions,\n  };\n  bool LookupTemplateName(\n      LookupResult &R, Scope *S, CXXScopeSpec &SS, QualType ObjectType,\n      bool EnteringContext, bool &MemberOfUnknownSpecialization,\n      RequiredTemplateKind RequiredTemplate = SourceLocation(),\n      AssumedTemplateKind *ATK = nullptr, bool AllowTypoCorrection = true);\n\n  TemplateNameKind isTemplateName(Scope *S,\n                                  CXXScopeSpec &SS,\n                                  bool hasTemplateKeyword,\n                                  const UnqualifiedId &Name,\n                                  ParsedType ObjectType,\n                                  bool EnteringContext,\n                                  TemplateTy &Template,\n                                  bool &MemberOfUnknownSpecialization,\n                                  bool Disambiguation = false);\n\n  /// Try to resolve an undeclared template name as a type template.\n  ///\n  /// Sets II to the identifier corresponding to the template name, and updates\n  /// Name to a corresponding (typo-corrected) type template name and TNK to\n  /// the corresponding kind, if possible.\n  void ActOnUndeclaredTypeTemplateName(Scope *S, TemplateTy &Name,\n                                       TemplateNameKind &TNK,\n                                       SourceLocation NameLoc,\n                                       IdentifierInfo *&II);\n\n  bool resolveAssumedTemplateNameAsType(Scope *S, TemplateName &Name,\n                                        SourceLocation NameLoc,\n                                        bool Diagnose = true);\n\n  /// Determine whether a particular identifier might be the name in a C++1z\n  /// deduction-guide declaration.\n  bool isDeductionGuideName(Scope *S, const IdentifierInfo &Name,\n                            SourceLocation NameLoc,\n                            ParsedTemplateTy *Template = nullptr);\n\n  bool DiagnoseUnknownTemplateName(const IdentifierInfo &II,\n                                   SourceLocation IILoc,\n                                   Scope *S,\n                                   const CXXScopeSpec *SS,\n                                   TemplateTy &SuggestedTemplate,\n                                   TemplateNameKind &SuggestedKind);\n\n  bool DiagnoseUninstantiableTemplate(SourceLocation PointOfInstantiation,\n                                      NamedDecl *Instantiation,\n                                      bool InstantiatedFromMember,\n                                      const NamedDecl *Pattern,\n                                      const NamedDecl *PatternDef,\n                                      TemplateSpecializationKind TSK,\n                                      bool Complain = true);\n\n  void DiagnoseTemplateParameterShadow(SourceLocation Loc, Decl *PrevDecl);\n  TemplateDecl *AdjustDeclIfTemplate(Decl *&Decl);\n\n  NamedDecl *ActOnTypeParameter(Scope *S, bool Typename,\n                                SourceLocation EllipsisLoc,\n                                SourceLocation KeyLoc,\n                                IdentifierInfo *ParamName,\n                                SourceLocation ParamNameLoc,\n                                unsigned Depth, unsigned Position,\n                                SourceLocation EqualLoc,\n                                ParsedType DefaultArg, bool HasTypeConstraint);\n\n  bool ActOnTypeConstraint(const CXXScopeSpec &SS,\n                           TemplateIdAnnotation *TypeConstraint,\n                           TemplateTypeParmDecl *ConstrainedParameter,\n                           SourceLocation EllipsisLoc);\n\n  bool AttachTypeConstraint(NestedNameSpecifierLoc NS,\n                            DeclarationNameInfo NameInfo,\n                            ConceptDecl *NamedConcept,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            TemplateTypeParmDecl *ConstrainedParameter,\n                            SourceLocation EllipsisLoc);\n\n  bool AttachTypeConstraint(AutoTypeLoc TL,\n                            NonTypeTemplateParmDecl *ConstrainedParameter,\n                            SourceLocation EllipsisLoc);\n\n  bool RequireStructuralType(QualType T, SourceLocation Loc);\n\n  QualType CheckNonTypeTemplateParameterType(TypeSourceInfo *&TSI,\n                                             SourceLocation Loc);\n  QualType CheckNonTypeTemplateParameterType(QualType T, SourceLocation Loc);\n\n  NamedDecl *ActOnNonTypeTemplateParameter(Scope *S, Declarator &D,\n                                      unsigned Depth,\n                                      unsigned Position,\n                                      SourceLocation EqualLoc,\n                                      Expr *DefaultArg);\n  NamedDecl *ActOnTemplateTemplateParameter(Scope *S,\n                                       SourceLocation TmpLoc,\n                                       TemplateParameterList *Params,\n                                       SourceLocation EllipsisLoc,\n                                       IdentifierInfo *ParamName,\n                                       SourceLocation ParamNameLoc,\n                                       unsigned Depth,\n                                       unsigned Position,\n                                       SourceLocation EqualLoc,\n                                       ParsedTemplateArgument DefaultArg);\n\n  TemplateParameterList *\n  ActOnTemplateParameterList(unsigned Depth,\n                             SourceLocation ExportLoc,\n                             SourceLocation TemplateLoc,\n                             SourceLocation LAngleLoc,\n                             ArrayRef<NamedDecl *> Params,\n                             SourceLocation RAngleLoc,\n                             Expr *RequiresClause);\n\n  /// The context in which we are checking a template parameter list.\n  enum TemplateParamListContext {\n    TPC_ClassTemplate,\n    TPC_VarTemplate,\n    TPC_FunctionTemplate,\n    TPC_ClassTemplateMember,\n    TPC_FriendClassTemplate,\n    TPC_FriendFunctionTemplate,\n    TPC_FriendFunctionTemplateDefinition,\n    TPC_TypeAliasTemplate\n  };\n\n  bool CheckTemplateParameterList(TemplateParameterList *NewParams,\n                                  TemplateParameterList *OldParams,\n                                  TemplateParamListContext TPC,\n                                  SkipBodyInfo *SkipBody = nullptr);\n  TemplateParameterList *MatchTemplateParametersToScopeSpecifier(\n      SourceLocation DeclStartLoc, SourceLocation DeclLoc,\n      const CXXScopeSpec &SS, TemplateIdAnnotation *TemplateId,\n      ArrayRef<TemplateParameterList *> ParamLists,\n      bool IsFriend, bool &IsMemberSpecialization, bool &Invalid,\n      bool SuppressDiagnostic = false);\n\n  DeclResult CheckClassTemplate(\n      Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n      CXXScopeSpec &SS, IdentifierInfo *Name, SourceLocation NameLoc,\n      const ParsedAttributesView &Attr, TemplateParameterList *TemplateParams,\n      AccessSpecifier AS, SourceLocation ModulePrivateLoc,\n      SourceLocation FriendLoc, unsigned NumOuterTemplateParamLists,\n      TemplateParameterList **OuterTemplateParamLists,\n      SkipBodyInfo *SkipBody = nullptr);\n\n  TemplateArgumentLoc getTrivialTemplateArgumentLoc(const TemplateArgument &Arg,\n                                                    QualType NTTPType,\n                                                    SourceLocation Loc);\n\n  /// Get a template argument mapping the given template parameter to itself,\n  /// e.g. for X in \\c template<int X>, this would return an expression template\n  /// argument referencing X.\n  TemplateArgumentLoc getIdentityTemplateArgumentLoc(NamedDecl *Param,\n                                                     SourceLocation Location);\n\n  void translateTemplateArguments(const ASTTemplateArgsPtr &In,\n                                  TemplateArgumentListInfo &Out);\n\n  ParsedTemplateArgument ActOnTemplateTypeArgument(TypeResult ParsedType);\n\n  void NoteAllFoundTemplates(TemplateName Name);\n\n  QualType CheckTemplateIdType(TemplateName Template,\n                               SourceLocation TemplateLoc,\n                              TemplateArgumentListInfo &TemplateArgs);\n\n  TypeResult\n  ActOnTemplateIdType(Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n                      TemplateTy Template, IdentifierInfo *TemplateII,\n                      SourceLocation TemplateIILoc, SourceLocation LAngleLoc,\n                      ASTTemplateArgsPtr TemplateArgs, SourceLocation RAngleLoc,\n                      bool IsCtorOrDtorName = false, bool IsClassName = false);\n\n  /// Parsed an elaborated-type-specifier that refers to a template-id,\n  /// such as \\c class T::template apply<U>.\n  TypeResult ActOnTagTemplateIdType(TagUseKind TUK,\n                                    TypeSpecifierType TagSpec,\n                                    SourceLocation TagLoc,\n                                    CXXScopeSpec &SS,\n                                    SourceLocation TemplateKWLoc,\n                                    TemplateTy TemplateD,\n                                    SourceLocation TemplateLoc,\n                                    SourceLocation LAngleLoc,\n                                    ASTTemplateArgsPtr TemplateArgsIn,\n                                    SourceLocation RAngleLoc);\n\n  DeclResult ActOnVarTemplateSpecialization(\n      Scope *S, Declarator &D, TypeSourceInfo *DI,\n      SourceLocation TemplateKWLoc, TemplateParameterList *TemplateParams,\n      StorageClass SC, bool IsPartialSpecialization);\n\n  /// Get the specialization of the given variable template corresponding to\n  /// the specified argument list, or a null-but-valid result if the arguments\n  /// are dependent.\n  DeclResult CheckVarTemplateId(VarTemplateDecl *Template,\n                                SourceLocation TemplateLoc,\n                                SourceLocation TemplateNameLoc,\n                                const TemplateArgumentListInfo &TemplateArgs);\n\n  /// Form a reference to the specialization of the given variable template\n  /// corresponding to the specified argument list, or a null-but-valid result\n  /// if the arguments are dependent.\n  ExprResult CheckVarTemplateId(const CXXScopeSpec &SS,\n                                const DeclarationNameInfo &NameInfo,\n                                VarTemplateDecl *Template,\n                                SourceLocation TemplateLoc,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult\n  CheckConceptTemplateId(const CXXScopeSpec &SS,\n                         SourceLocation TemplateKWLoc,\n                         const DeclarationNameInfo &ConceptNameInfo,\n                         NamedDecl *FoundDecl, ConceptDecl *NamedConcept,\n                         const TemplateArgumentListInfo *TemplateArgs);\n\n  void diagnoseMissingTemplateArguments(TemplateName Name, SourceLocation Loc);\n\n  ExprResult BuildTemplateIdExpr(const CXXScopeSpec &SS,\n                                 SourceLocation TemplateKWLoc,\n                                 LookupResult &R,\n                                 bool RequiresADL,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult BuildQualifiedTemplateIdExpr(CXXScopeSpec &SS,\n                                          SourceLocation TemplateKWLoc,\n                               const DeclarationNameInfo &NameInfo,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  TemplateNameKind ActOnTemplateName(\n      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      const UnqualifiedId &Name, ParsedType ObjectType, bool EnteringContext,\n      TemplateTy &Template, bool AllowInjectedClassName = false);\n\n  DeclResult ActOnClassTemplateSpecialization(\n      Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n      SourceLocation ModulePrivateLoc, CXXScopeSpec &SS,\n      TemplateIdAnnotation &TemplateId, const ParsedAttributesView &Attr,\n      MultiTemplateParamsArg TemplateParameterLists,\n      SkipBodyInfo *SkipBody = nullptr);\n\n  bool CheckTemplatePartialSpecializationArgs(SourceLocation Loc,\n                                              TemplateDecl *PrimaryTemplate,\n                                              unsigned NumExplicitArgs,\n                                              ArrayRef<TemplateArgument> Args);\n  void CheckTemplatePartialSpecialization(\n      ClassTemplatePartialSpecializationDecl *Partial);\n  void CheckTemplatePartialSpecialization(\n      VarTemplatePartialSpecializationDecl *Partial);\n\n  Decl *ActOnTemplateDeclarator(Scope *S,\n                                MultiTemplateParamsArg TemplateParameterLists,\n                                Declarator &D);\n\n  bool\n  CheckSpecializationInstantiationRedecl(SourceLocation NewLoc,\n                                         TemplateSpecializationKind NewTSK,\n                                         NamedDecl *PrevDecl,\n                                         TemplateSpecializationKind PrevTSK,\n                                         SourceLocation PrevPtOfInstantiation,\n                                         bool &SuppressNew);\n\n  bool CheckDependentFunctionTemplateSpecialization(FunctionDecl *FD,\n                    const TemplateArgumentListInfo &ExplicitTemplateArgs,\n                                                    LookupResult &Previous);\n\n  bool CheckFunctionTemplateSpecialization(\n      FunctionDecl *FD, TemplateArgumentListInfo *ExplicitTemplateArgs,\n      LookupResult &Previous, bool QualifiedFriend = false);\n  bool CheckMemberSpecialization(NamedDecl *Member, LookupResult &Previous);\n  void CompleteMemberSpecialization(NamedDecl *Member, LookupResult &Previous);\n\n  DeclResult ActOnExplicitInstantiation(\n      Scope *S, SourceLocation ExternLoc, SourceLocation TemplateLoc,\n      unsigned TagSpec, SourceLocation KWLoc, const CXXScopeSpec &SS,\n      TemplateTy Template, SourceLocation TemplateNameLoc,\n      SourceLocation LAngleLoc, ASTTemplateArgsPtr TemplateArgs,\n      SourceLocation RAngleLoc, const ParsedAttributesView &Attr);\n\n  DeclResult ActOnExplicitInstantiation(Scope *S, SourceLocation ExternLoc,\n                                        SourceLocation TemplateLoc,\n                                        unsigned TagSpec, SourceLocation KWLoc,\n                                        CXXScopeSpec &SS, IdentifierInfo *Name,\n                                        SourceLocation NameLoc,\n                                        const ParsedAttributesView &Attr);\n\n  DeclResult ActOnExplicitInstantiation(Scope *S,\n                                        SourceLocation ExternLoc,\n                                        SourceLocation TemplateLoc,\n                                        Declarator &D);\n\n  TemplateArgumentLoc\n  SubstDefaultTemplateArgumentIfAvailable(TemplateDecl *Template,\n                                          SourceLocation TemplateLoc,\n                                          SourceLocation RAngleLoc,\n                                          Decl *Param,\n                                          SmallVectorImpl<TemplateArgument>\n                                            &Converted,\n                                          bool &HasDefaultArg);\n\n  /// Specifies the context in which a particular template\n  /// argument is being checked.\n  enum CheckTemplateArgumentKind {\n    /// The template argument was specified in the code or was\n    /// instantiated with some deduced template arguments.\n    CTAK_Specified,\n\n    /// The template argument was deduced via template argument\n    /// deduction.\n    CTAK_Deduced,\n\n    /// The template argument was deduced from an array bound\n    /// via template argument deduction.\n    CTAK_DeducedFromArrayBound\n  };\n\n  bool CheckTemplateArgument(NamedDecl *Param,\n                             TemplateArgumentLoc &Arg,\n                             NamedDecl *Template,\n                             SourceLocation TemplateLoc,\n                             SourceLocation RAngleLoc,\n                             unsigned ArgumentPackIndex,\n                           SmallVectorImpl<TemplateArgument> &Converted,\n                             CheckTemplateArgumentKind CTAK = CTAK_Specified);\n\n  /// Check that the given template arguments can be be provided to\n  /// the given template, converting the arguments along the way.\n  ///\n  /// \\param Template The template to which the template arguments are being\n  /// provided.\n  ///\n  /// \\param TemplateLoc The location of the template name in the source.\n  ///\n  /// \\param TemplateArgs The list of template arguments. If the template is\n  /// a template template parameter, this function may extend the set of\n  /// template arguments to also include substituted, defaulted template\n  /// arguments.\n  ///\n  /// \\param PartialTemplateArgs True if the list of template arguments is\n  /// intentionally partial, e.g., because we're checking just the initial\n  /// set of template arguments.\n  ///\n  /// \\param Converted Will receive the converted, canonicalized template\n  /// arguments.\n  ///\n  /// \\param UpdateArgsWithConversions If \\c true, update \\p TemplateArgs to\n  /// contain the converted forms of the template arguments as written.\n  /// Otherwise, \\p TemplateArgs will not be modified.\n  ///\n  /// \\param ConstraintsNotSatisfied If provided, and an error occured, will\n  /// receive true if the cause for the error is the associated constraints of\n  /// the template not being satisfied by the template arguments.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckTemplateArgumentList(TemplateDecl *Template,\n                                 SourceLocation TemplateLoc,\n                                 TemplateArgumentListInfo &TemplateArgs,\n                                 bool PartialTemplateArgs,\n                                 SmallVectorImpl<TemplateArgument> &Converted,\n                                 bool UpdateArgsWithConversions = true,\n                                 bool *ConstraintsNotSatisfied = nullptr);\n\n  bool CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,\n                                 TemplateArgumentLoc &Arg,\n                           SmallVectorImpl<TemplateArgument> &Converted);\n\n  bool CheckTemplateArgument(TemplateTypeParmDecl *Param,\n                             TypeSourceInfo *Arg);\n  ExprResult CheckTemplateArgument(NonTypeTemplateParmDecl *Param,\n                                   QualType InstantiatedParamType, Expr *Arg,\n                                   TemplateArgument &Converted,\n                               CheckTemplateArgumentKind CTAK = CTAK_Specified);\n  bool CheckTemplateTemplateArgument(TemplateTemplateParmDecl *Param,\n                                     TemplateParameterList *Params,\n                                     TemplateArgumentLoc &Arg);\n\n  ExprResult\n  BuildExpressionFromDeclTemplateArgument(const TemplateArgument &Arg,\n                                          QualType ParamType,\n                                          SourceLocation Loc);\n  ExprResult\n  BuildExpressionFromIntegralTemplateArgument(const TemplateArgument &Arg,\n                                              SourceLocation Loc);\n\n  /// Enumeration describing how template parameter lists are compared\n  /// for equality.\n  enum TemplateParameterListEqualKind {\n    /// We are matching the template parameter lists of two templates\n    /// that might be redeclarations.\n    ///\n    /// \\code\n    /// template<typename T> struct X;\n    /// template<typename T> struct X;\n    /// \\endcode\n    TPL_TemplateMatch,\n\n    /// We are matching the template parameter lists of two template\n    /// template parameters as part of matching the template parameter lists\n    /// of two templates that might be redeclarations.\n    ///\n    /// \\code\n    /// template<template<int I> class TT> struct X;\n    /// template<template<int Value> class Other> struct X;\n    /// \\endcode\n    TPL_TemplateTemplateParmMatch,\n\n    /// We are matching the template parameter lists of a template\n    /// template argument against the template parameter lists of a template\n    /// template parameter.\n    ///\n    /// \\code\n    /// template<template<int Value> class Metafun> struct X;\n    /// template<int Value> struct integer_c;\n    /// X<integer_c> xic;\n    /// \\endcode\n    TPL_TemplateTemplateArgumentMatch\n  };\n\n  bool TemplateParameterListsAreEqual(TemplateParameterList *New,\n                                      TemplateParameterList *Old,\n                                      bool Complain,\n                                      TemplateParameterListEqualKind Kind,\n                                      SourceLocation TemplateArgLoc\n                                        = SourceLocation());\n\n  bool CheckTemplateDeclScope(Scope *S, TemplateParameterList *TemplateParams);\n\n  /// Called when the parser has parsed a C++ typename\n  /// specifier, e.g., \"typename T::type\".\n  ///\n  /// \\param S The scope in which this typename type occurs.\n  /// \\param TypenameLoc the location of the 'typename' keyword\n  /// \\param SS the nested-name-specifier following the typename (e.g., 'T::').\n  /// \\param II the identifier we're retrieving (e.g., 'type' in the example).\n  /// \\param IdLoc the location of the identifier.\n  TypeResult\n  ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,\n                    const CXXScopeSpec &SS, const IdentifierInfo &II,\n                    SourceLocation IdLoc);\n\n  /// Called when the parser has parsed a C++ typename\n  /// specifier that ends in a template-id, e.g.,\n  /// \"typename MetaFun::template apply<T1, T2>\".\n  ///\n  /// \\param S The scope in which this typename type occurs.\n  /// \\param TypenameLoc the location of the 'typename' keyword\n  /// \\param SS the nested-name-specifier following the typename (e.g., 'T::').\n  /// \\param TemplateLoc the location of the 'template' keyword, if any.\n  /// \\param TemplateName The template name.\n  /// \\param TemplateII The identifier used to name the template.\n  /// \\param TemplateIILoc The location of the template name.\n  /// \\param LAngleLoc The location of the opening angle bracket  ('<').\n  /// \\param TemplateArgs The template arguments.\n  /// \\param RAngleLoc The location of the closing angle bracket  ('>').\n  TypeResult\n  ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,\n                    const CXXScopeSpec &SS,\n                    SourceLocation TemplateLoc,\n                    TemplateTy TemplateName,\n                    IdentifierInfo *TemplateII,\n                    SourceLocation TemplateIILoc,\n                    SourceLocation LAngleLoc,\n                    ASTTemplateArgsPtr TemplateArgs,\n                    SourceLocation RAngleLoc);\n\n  QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                             SourceLocation KeywordLoc,\n                             NestedNameSpecifierLoc QualifierLoc,\n                             const IdentifierInfo &II,\n                             SourceLocation IILoc,\n                             TypeSourceInfo **TSI,\n                             bool DeducedTSTContext);\n\n  QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                             SourceLocation KeywordLoc,\n                             NestedNameSpecifierLoc QualifierLoc,\n                             const IdentifierInfo &II,\n                             SourceLocation IILoc,\n                             bool DeducedTSTContext = true);\n\n\n  TypeSourceInfo *RebuildTypeInCurrentInstantiation(TypeSourceInfo *T,\n                                                    SourceLocation Loc,\n                                                    DeclarationName Name);\n  bool RebuildNestedNameSpecifierInCurrentInstantiation(CXXScopeSpec &SS);\n\n  ExprResult RebuildExprInCurrentInstantiation(Expr *E);\n  bool RebuildTemplateParamsInCurrentInstantiation(\n                                                TemplateParameterList *Params);\n\n  std::string\n  getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                  const TemplateArgumentList &Args);\n\n  std::string\n  getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                  const TemplateArgument *Args,\n                                  unsigned NumArgs);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Concepts\n  //===--------------------------------------------------------------------===//\n  Decl *ActOnConceptDefinition(\n      Scope *S, MultiTemplateParamsArg TemplateParameterLists,\n      IdentifierInfo *Name, SourceLocation NameLoc, Expr *ConstraintExpr);\n\n  RequiresExprBodyDecl *\n  ActOnStartRequiresExpr(SourceLocation RequiresKWLoc,\n                         ArrayRef<ParmVarDecl *> LocalParameters,\n                         Scope *BodyScope);\n  void ActOnFinishRequiresExpr();\n  concepts::Requirement *ActOnSimpleRequirement(Expr *E);\n  concepts::Requirement *ActOnTypeRequirement(\n      SourceLocation TypenameKWLoc, CXXScopeSpec &SS, SourceLocation NameLoc,\n      IdentifierInfo *TypeName, TemplateIdAnnotation *TemplateId);\n  concepts::Requirement *ActOnCompoundRequirement(Expr *E,\n                                                  SourceLocation NoexceptLoc);\n  concepts::Requirement *\n  ActOnCompoundRequirement(\n      Expr *E, SourceLocation NoexceptLoc, CXXScopeSpec &SS,\n      TemplateIdAnnotation *TypeConstraint, unsigned Depth);\n  concepts::Requirement *ActOnNestedRequirement(Expr *Constraint);\n  concepts::ExprRequirement *\n  BuildExprRequirement(\n      Expr *E, bool IsSatisfied, SourceLocation NoexceptLoc,\n      concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);\n  concepts::ExprRequirement *\n  BuildExprRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *ExprSubstDiag,\n      bool IsSatisfied, SourceLocation NoexceptLoc,\n      concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);\n  concepts::TypeRequirement *BuildTypeRequirement(TypeSourceInfo *Type);\n  concepts::TypeRequirement *\n  BuildTypeRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *SubstDiag);\n  concepts::NestedRequirement *BuildNestedRequirement(Expr *E);\n  concepts::NestedRequirement *\n  BuildNestedRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *SubstDiag);\n  ExprResult ActOnRequiresExpr(SourceLocation RequiresKWLoc,\n                               RequiresExprBodyDecl *Body,\n                               ArrayRef<ParmVarDecl *> LocalParameters,\n                               ArrayRef<concepts::Requirement *> Requirements,\n                               SourceLocation ClosingBraceLoc);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Variadic Templates (C++0x [temp.variadic])\n  //===--------------------------------------------------------------------===//\n\n  /// Determine whether an unexpanded parameter pack might be permitted in this\n  /// location. Useful for error recovery.\n  bool isUnexpandedParameterPackPermitted();\n\n  /// The context in which an unexpanded parameter pack is\n  /// being diagnosed.\n  ///\n  /// Note that the values of this enumeration line up with the first\n  /// argument to the \\c err_unexpanded_parameter_pack diagnostic.\n  enum UnexpandedParameterPackContext {\n    /// An arbitrary expression.\n    UPPC_Expression = 0,\n\n    /// The base type of a class type.\n    UPPC_BaseType,\n\n    /// The type of an arbitrary declaration.\n    UPPC_DeclarationType,\n\n    /// The type of a data member.\n    UPPC_DataMemberType,\n\n    /// The size of a bit-field.\n    UPPC_BitFieldWidth,\n\n    /// The expression in a static assertion.\n    UPPC_StaticAssertExpression,\n\n    /// The fixed underlying type of an enumeration.\n    UPPC_FixedUnderlyingType,\n\n    /// The enumerator value.\n    UPPC_EnumeratorValue,\n\n    /// A using declaration.\n    UPPC_UsingDeclaration,\n\n    /// A friend declaration.\n    UPPC_FriendDeclaration,\n\n    /// A declaration qualifier.\n    UPPC_DeclarationQualifier,\n\n    /// An initializer.\n    UPPC_Initializer,\n\n    /// A default argument.\n    UPPC_DefaultArgument,\n\n    /// The type of a non-type template parameter.\n    UPPC_NonTypeTemplateParameterType,\n\n    /// The type of an exception.\n    UPPC_ExceptionType,\n\n    /// Partial specialization.\n    UPPC_PartialSpecialization,\n\n    /// Microsoft __if_exists.\n    UPPC_IfExists,\n\n    /// Microsoft __if_not_exists.\n    UPPC_IfNotExists,\n\n    /// Lambda expression.\n    UPPC_Lambda,\n\n    /// Block expression.\n    UPPC_Block,\n\n    /// A type constraint.\n    UPPC_TypeConstraint,\n\n    // A requirement in a requires-expression.\n    UPPC_Requirement,\n\n    // A requires-clause.\n    UPPC_RequiresClause,\n  };\n\n  /// Diagnose unexpanded parameter packs.\n  ///\n  /// \\param Loc The location at which we should emit the diagnostic.\n  ///\n  /// \\param UPPC The context in which we are diagnosing unexpanded\n  /// parameter packs.\n  ///\n  /// \\param Unexpanded the set of unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPacks(SourceLocation Loc,\n                                        UnexpandedParameterPackContext UPPC,\n                                  ArrayRef<UnexpandedParameterPack> Unexpanded);\n\n  /// If the given type contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param Loc The source location where a diagnostc should be emitted.\n  ///\n  /// \\param T The type that is being checked for unexpanded parameter\n  /// packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(SourceLocation Loc, TypeSourceInfo *T,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given expression contains an unexpanded parameter\n  /// pack, diagnose the error.\n  ///\n  /// \\param E The expression that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(Expr *E,\n                       UnexpandedParameterPackContext UPPC = UPPC_Expression);\n\n  /// If the given requirees-expression contains an unexpanded reference to one\n  /// of its own parameter packs, diagnose the error.\n  ///\n  /// \\param RE The requiress-expression that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPackInRequiresExpr(RequiresExpr *RE);\n\n  /// If the given nested-name-specifier contains an unexpanded\n  /// parameter pack, diagnose the error.\n  ///\n  /// \\param SS The nested-name-specifier that is being checked for\n  /// unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(const CXXScopeSpec &SS,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given name contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param NameInfo The name (with source location information) that\n  /// is being checked for unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(const DeclarationNameInfo &NameInfo,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given template name contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param Loc The location of the template name.\n  ///\n  /// \\param Template The template name that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(SourceLocation Loc,\n                                       TemplateName Template,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given template argument contains an unexpanded parameter\n  /// pack, diagnose the error.\n  ///\n  /// \\param Arg The template argument that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(TemplateArgumentLoc Arg,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// template argument.\n  ///\n  /// \\param Arg The template argument that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TemplateArgument Arg,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// template argument.\n  ///\n  /// \\param Arg The template argument that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TemplateArgumentLoc Arg,\n                    SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// type.\n  ///\n  /// \\param T The type that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(QualType T,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// type.\n  ///\n  /// \\param TL The type that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TypeLoc TL,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// nested-name-specifier.\n  ///\n  /// \\param NNS The nested-name-specifier that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(NestedNameSpecifierLoc NNS,\n                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// name.\n  ///\n  /// \\param NameInfo The name that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(const DeclarationNameInfo &NameInfo,\n                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Invoked when parsing a template argument followed by an\n  /// ellipsis, which creates a pack expansion.\n  ///\n  /// \\param Arg The template argument preceding the ellipsis, which\n  /// may already be invalid.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ParsedTemplateArgument ActOnPackExpansion(const ParsedTemplateArgument &Arg,\n                                            SourceLocation EllipsisLoc);\n\n  /// Invoked when parsing a type followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Type The type preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  TypeResult ActOnPackExpansion(ParsedType Type, SourceLocation EllipsisLoc);\n\n  /// Construct a pack expansion type from the pattern of the pack\n  /// expansion.\n  TypeSourceInfo *CheckPackExpansion(TypeSourceInfo *Pattern,\n                                     SourceLocation EllipsisLoc,\n                                     Optional<unsigned> NumExpansions);\n\n  /// Construct a pack expansion type from the pattern of the pack\n  /// expansion.\n  QualType CheckPackExpansion(QualType Pattern,\n                              SourceRange PatternRange,\n                              SourceLocation EllipsisLoc,\n                              Optional<unsigned> NumExpansions);\n\n  /// Invoked when parsing an expression followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Pattern The expression preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ExprResult ActOnPackExpansion(Expr *Pattern, SourceLocation EllipsisLoc);\n\n  /// Invoked when parsing an expression followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Pattern The expression preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ExprResult CheckPackExpansion(Expr *Pattern, SourceLocation EllipsisLoc,\n                                Optional<unsigned> NumExpansions);\n\n  /// Determine whether we could expand a pack expansion with the\n  /// given set of parameter packs into separate arguments by repeatedly\n  /// transforming the pattern.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis that identifies the\n  /// pack expansion.\n  ///\n  /// \\param PatternRange The source range that covers the entire pattern of\n  /// the pack expansion.\n  ///\n  /// \\param Unexpanded The set of unexpanded parameter packs within the\n  /// pattern.\n  ///\n  /// \\param ShouldExpand Will be set to \\c true if the transformer should\n  /// expand the corresponding pack expansions into separate arguments. When\n  /// set, \\c NumExpansions must also be set.\n  ///\n  /// \\param RetainExpansion Whether the caller should add an unexpanded\n  /// pack expansion after all of the expanded arguments. This is used\n  /// when extending explicitly-specified template argument packs per\n  /// C++0x [temp.arg.explicit]p9.\n  ///\n  /// \\param NumExpansions The number of separate arguments that will be in\n  /// the expanded form of the corresponding pack expansion. This is both an\n  /// input and an output parameter, which can be set by the caller if the\n  /// number of expansions is known a priori (e.g., due to a prior substitution)\n  /// and will be set by the callee when the number of expansions is known.\n  /// The callee must set this value when \\c ShouldExpand is \\c true; it may\n  /// set this value in other cases.\n  ///\n  /// \\returns true if an error occurred (e.g., because the parameter packs\n  /// are to be instantiated with arguments of different lengths), false\n  /// otherwise. If false, \\c ShouldExpand (and possibly \\c NumExpansions)\n  /// must be set.\n  bool CheckParameterPacksForExpansion(SourceLocation EllipsisLoc,\n                                       SourceRange PatternRange,\n                             ArrayRef<UnexpandedParameterPack> Unexpanded,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                                       bool &ShouldExpand,\n                                       bool &RetainExpansion,\n                                       Optional<unsigned> &NumExpansions);\n\n  /// Determine the number of arguments in the given pack expansion\n  /// type.\n  ///\n  /// This routine assumes that the number of arguments in the expansion is\n  /// consistent across all of the unexpanded parameter packs in its pattern.\n  ///\n  /// Returns an empty Optional if the type can't be expanded.\n  Optional<unsigned> getNumArgumentsInExpansion(QualType T,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Determine whether the given declarator contains any unexpanded\n  /// parameter packs.\n  ///\n  /// This routine is used by the parser to disambiguate function declarators\n  /// with an ellipsis prior to the ')', e.g.,\n  ///\n  /// \\code\n  ///   void f(T...);\n  /// \\endcode\n  ///\n  /// To determine whether we have an (unnamed) function parameter pack or\n  /// a variadic function.\n  ///\n  /// \\returns true if the declarator contains any unexpanded parameter packs,\n  /// false otherwise.\n  bool containsUnexpandedParameterPacks(Declarator &D);\n\n  /// Returns the pattern of the pack expansion for a template argument.\n  ///\n  /// \\param OrigLoc The template argument to expand.\n  ///\n  /// \\param Ellipsis Will be set to the location of the ellipsis.\n  ///\n  /// \\param NumExpansions Will be set to the number of expansions that will\n  /// be generated from this pack expansion, if known a priori.\n  TemplateArgumentLoc getTemplateArgumentPackExpansionPattern(\n      TemplateArgumentLoc OrigLoc,\n      SourceLocation &Ellipsis,\n      Optional<unsigned> &NumExpansions) const;\n\n  /// Given a template argument that contains an unexpanded parameter pack, but\n  /// which has already been substituted, attempt to determine the number of\n  /// elements that will be produced once this argument is fully-expanded.\n  ///\n  /// This is intended for use when transforming 'sizeof...(Arg)' in order to\n  /// avoid actually expanding the pack where possible.\n  Optional<unsigned> getFullyPackExpandedSize(TemplateArgument Arg);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Template Argument Deduction (C++ [temp.deduct])\n  //===--------------------------------------------------------------------===//\n\n  /// Adjust the type \\p ArgFunctionType to match the calling convention,\n  /// noreturn, and optionally the exception specification of \\p FunctionType.\n  /// Deduction often wants to ignore these properties when matching function\n  /// types.\n  QualType adjustCCAndNoReturn(QualType ArgFunctionType, QualType FunctionType,\n                               bool AdjustExceptionSpec = false);\n\n  /// Describes the result of template argument deduction.\n  ///\n  /// The TemplateDeductionResult enumeration describes the result of\n  /// template argument deduction, as returned from\n  /// DeduceTemplateArguments(). The separate TemplateDeductionInfo\n  /// structure provides additional information about the results of\n  /// template argument deduction, e.g., the deduced template argument\n  /// list (if successful) or the specific template parameters or\n  /// deduced arguments that were involved in the failure.\n  enum TemplateDeductionResult {\n    /// Template argument deduction was successful.\n    TDK_Success = 0,\n    /// The declaration was invalid; do nothing.\n    TDK_Invalid,\n    /// Template argument deduction exceeded the maximum template\n    /// instantiation depth (which has already been diagnosed).\n    TDK_InstantiationDepth,\n    /// Template argument deduction did not deduce a value\n    /// for every template parameter.\n    TDK_Incomplete,\n    /// Template argument deduction did not deduce a value for every\n    /// expansion of an expanded template parameter pack.\n    TDK_IncompletePack,\n    /// Template argument deduction produced inconsistent\n    /// deduced values for the given template parameter.\n    TDK_Inconsistent,\n    /// Template argument deduction failed due to inconsistent\n    /// cv-qualifiers on a template parameter type that would\n    /// otherwise be deduced, e.g., we tried to deduce T in \"const T\"\n    /// but were given a non-const \"X\".\n    TDK_Underqualified,\n    /// Substitution of the deduced template argument values\n    /// resulted in an error.\n    TDK_SubstitutionFailure,\n    /// After substituting deduced template arguments, a dependent\n    /// parameter type did not match the corresponding argument.\n    TDK_DeducedMismatch,\n    /// After substituting deduced template arguments, an element of\n    /// a dependent parameter type did not match the corresponding element\n    /// of the corresponding argument (when deducing from an initializer list).\n    TDK_DeducedMismatchNested,\n    /// A non-depnedent component of the parameter did not match the\n    /// corresponding component of the argument.\n    TDK_NonDeducedMismatch,\n    /// When performing template argument deduction for a function\n    /// template, there were too many call arguments.\n    TDK_TooManyArguments,\n    /// When performing template argument deduction for a function\n    /// template, there were too few call arguments.\n    TDK_TooFewArguments,\n    /// The explicitly-specified template arguments were not valid\n    /// template arguments for the given template.\n    TDK_InvalidExplicitArguments,\n    /// Checking non-dependent argument conversions failed.\n    TDK_NonDependentConversionFailure,\n    /// The deduced arguments did not satisfy the constraints associated\n    /// with the template.\n    TDK_ConstraintsNotSatisfied,\n    /// Deduction failed; that's all we know.\n    TDK_MiscellaneousDeductionFailure,\n    /// CUDA Target attributes do not match.\n    TDK_CUDATargetMismatch\n  };\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(ClassTemplatePartialSpecializationDecl *Partial,\n                          const TemplateArgumentList &TemplateArgs,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(VarTemplatePartialSpecializationDecl *Partial,\n                          const TemplateArgumentList &TemplateArgs,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult SubstituteExplicitTemplateArguments(\n      FunctionTemplateDecl *FunctionTemplate,\n      TemplateArgumentListInfo &ExplicitTemplateArgs,\n      SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n      SmallVectorImpl<QualType> &ParamTypes, QualType *FunctionType,\n      sema::TemplateDeductionInfo &Info);\n\n  /// brief A function argument from which we performed template argument\n  // deduction for a call.\n  struct OriginalCallArg {\n    OriginalCallArg(QualType OriginalParamType, bool DecomposedParam,\n                    unsigned ArgIdx, QualType OriginalArgType)\n        : OriginalParamType(OriginalParamType),\n          DecomposedParam(DecomposedParam), ArgIdx(ArgIdx),\n          OriginalArgType(OriginalArgType) {}\n\n    QualType OriginalParamType;\n    bool DecomposedParam;\n    unsigned ArgIdx;\n    QualType OriginalArgType;\n  };\n\n  TemplateDeductionResult FinishTemplateArgumentDeduction(\n      FunctionTemplateDecl *FunctionTemplate,\n      SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n      unsigned NumExplicitlySpecified, FunctionDecl *&Specialization,\n      sema::TemplateDeductionInfo &Info,\n      SmallVectorImpl<OriginalCallArg> const *OriginalCallArgs = nullptr,\n      bool PartialOverloading = false,\n      llvm::function_ref<bool()> CheckNonDependent = []{ return false; });\n\n  TemplateDeductionResult DeduceTemplateArguments(\n      FunctionTemplateDecl *FunctionTemplate,\n      TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n      FunctionDecl *&Specialization, sema::TemplateDeductionInfo &Info,\n      bool PartialOverloading,\n      llvm::function_ref<bool(ArrayRef<QualType>)> CheckNonDependent);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          TemplateArgumentListInfo *ExplicitTemplateArgs,\n                          QualType ArgFunctionType,\n                          FunctionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info,\n                          bool IsAddressOfFunction = false);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          QualType ToType,\n                          CXXConversionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          TemplateArgumentListInfo *ExplicitTemplateArgs,\n                          FunctionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info,\n                          bool IsAddressOfFunction = false);\n\n  /// Substitute Replacement for \\p auto in \\p TypeWithAuto\n  QualType SubstAutoType(QualType TypeWithAuto, QualType Replacement);\n  /// Substitute Replacement for auto in TypeWithAuto\n  TypeSourceInfo* SubstAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                          QualType Replacement);\n  /// Completely replace the \\c auto in \\p TypeWithAuto by\n  /// \\p Replacement. This does not retain any \\c auto type sugar.\n  QualType ReplaceAutoType(QualType TypeWithAuto, QualType Replacement);\n  TypeSourceInfo *ReplaceAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                            QualType Replacement);\n\n  /// Result type of DeduceAutoType.\n  enum DeduceAutoResult {\n    DAR_Succeeded,\n    DAR_Failed,\n    DAR_FailedAlreadyDiagnosed\n  };\n\n  DeduceAutoResult\n  DeduceAutoType(TypeSourceInfo *AutoType, Expr *&Initializer, QualType &Result,\n                 Optional<unsigned> DependentDeductionDepth = None,\n                 bool IgnoreConstraints = false);\n  DeduceAutoResult\n  DeduceAutoType(TypeLoc AutoTypeLoc, Expr *&Initializer, QualType &Result,\n                 Optional<unsigned> DependentDeductionDepth = None,\n                 bool IgnoreConstraints = false);\n  void DiagnoseAutoDeductionFailure(VarDecl *VDecl, Expr *Init);\n  bool DeduceReturnType(FunctionDecl *FD, SourceLocation Loc,\n                        bool Diagnose = true);\n\n  /// Declare implicit deduction guides for a class template if we've\n  /// not already done so.\n  void DeclareImplicitDeductionGuides(TemplateDecl *Template,\n                                      SourceLocation Loc);\n\n  QualType DeduceTemplateSpecializationFromInitializer(\n      TypeSourceInfo *TInfo, const InitializedEntity &Entity,\n      const InitializationKind &Kind, MultiExprArg Init);\n\n  QualType deduceVarTypeFromInitializer(VarDecl *VDecl, DeclarationName Name,\n                                        QualType Type, TypeSourceInfo *TSI,\n                                        SourceRange Range, bool DirectInit,\n                                        Expr *Init);\n\n  TypeLoc getReturnTypeLoc(FunctionDecl *FD) const;\n\n  bool DeduceFunctionTypeFromReturnExpr(FunctionDecl *FD,\n                                        SourceLocation ReturnLoc,\n                                        Expr *&RetExpr, AutoType *AT);\n\n  FunctionTemplateDecl *getMoreSpecializedTemplate(\n      FunctionTemplateDecl *FT1, FunctionTemplateDecl *FT2, SourceLocation Loc,\n      TemplatePartialOrderingContext TPOC, unsigned NumCallArguments1,\n      unsigned NumCallArguments2, bool Reversed = false);\n  UnresolvedSetIterator\n  getMostSpecialized(UnresolvedSetIterator SBegin, UnresolvedSetIterator SEnd,\n                     TemplateSpecCandidateSet &FailedCandidates,\n                     SourceLocation Loc,\n                     const PartialDiagnostic &NoneDiag,\n                     const PartialDiagnostic &AmbigDiag,\n                     const PartialDiagnostic &CandidateDiag,\n                     bool Complain = true, QualType TargetType = QualType());\n\n  ClassTemplatePartialSpecializationDecl *\n  getMoreSpecializedPartialSpecialization(\n                                  ClassTemplatePartialSpecializationDecl *PS1,\n                                  ClassTemplatePartialSpecializationDecl *PS2,\n                                  SourceLocation Loc);\n\n  bool isMoreSpecializedThanPrimary(ClassTemplatePartialSpecializationDecl *T,\n                                    sema::TemplateDeductionInfo &Info);\n\n  VarTemplatePartialSpecializationDecl *getMoreSpecializedPartialSpecialization(\n      VarTemplatePartialSpecializationDecl *PS1,\n      VarTemplatePartialSpecializationDecl *PS2, SourceLocation Loc);\n\n  bool isMoreSpecializedThanPrimary(VarTemplatePartialSpecializationDecl *T,\n                                    sema::TemplateDeductionInfo &Info);\n\n  bool isTemplateTemplateParameterAtLeastAsSpecializedAs(\n      TemplateParameterList *PParam, TemplateDecl *AArg, SourceLocation Loc);\n\n  void MarkUsedTemplateParameters(const Expr *E, bool OnlyDeduced,\n                                  unsigned Depth, llvm::SmallBitVector &Used);\n\n  void MarkUsedTemplateParameters(const TemplateArgumentList &TemplateArgs,\n                                  bool OnlyDeduced,\n                                  unsigned Depth,\n                                  llvm::SmallBitVector &Used);\n  void MarkDeducedTemplateParameters(\n                                  const FunctionTemplateDecl *FunctionTemplate,\n                                  llvm::SmallBitVector &Deduced) {\n    return MarkDeducedTemplateParameters(Context, FunctionTemplate, Deduced);\n  }\n  static void MarkDeducedTemplateParameters(ASTContext &Ctx,\n                                  const FunctionTemplateDecl *FunctionTemplate,\n                                  llvm::SmallBitVector &Deduced);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Template Instantiation\n  //\n\n  MultiLevelTemplateArgumentList\n  getTemplateInstantiationArgs(NamedDecl *D,\n                               const TemplateArgumentList *Innermost = nullptr,\n                               bool RelativeToPrimary = false,\n                               const FunctionDecl *Pattern = nullptr);\n\n  /// A context in which code is being synthesized (where a source location\n  /// alone is not sufficient to identify the context). This covers template\n  /// instantiation and various forms of implicitly-generated functions.\n  struct CodeSynthesisContext {\n    /// The kind of template instantiation we are performing\n    enum SynthesisKind {\n      /// We are instantiating a template declaration. The entity is\n      /// the declaration we're instantiating (e.g., a CXXRecordDecl).\n      TemplateInstantiation,\n\n      /// We are instantiating a default argument for a template\n      /// parameter. The Entity is the template parameter whose argument is\n      /// being instantiated, the Template is the template, and the\n      /// TemplateArgs/NumTemplateArguments provide the template arguments as\n      /// specified.\n      DefaultTemplateArgumentInstantiation,\n\n      /// We are instantiating a default argument for a function.\n      /// The Entity is the ParmVarDecl, and TemplateArgs/NumTemplateArgs\n      /// provides the template arguments as specified.\n      DefaultFunctionArgumentInstantiation,\n\n      /// We are substituting explicit template arguments provided for\n      /// a function template. The entity is a FunctionTemplateDecl.\n      ExplicitTemplateArgumentSubstitution,\n\n      /// We are substituting template argument determined as part of\n      /// template argument deduction for either a class template\n      /// partial specialization or a function template. The\n      /// Entity is either a {Class|Var}TemplatePartialSpecializationDecl or\n      /// a TemplateDecl.\n      DeducedTemplateArgumentSubstitution,\n\n      /// We are substituting prior template arguments into a new\n      /// template parameter. The template parameter itself is either a\n      /// NonTypeTemplateParmDecl or a TemplateTemplateParmDecl.\n      PriorTemplateArgumentSubstitution,\n\n      /// We are checking the validity of a default template argument that\n      /// has been used when naming a template-id.\n      DefaultTemplateArgumentChecking,\n\n      /// We are computing the exception specification for a defaulted special\n      /// member function.\n      ExceptionSpecEvaluation,\n\n      /// We are instantiating the exception specification for a function\n      /// template which was deferred until it was needed.\n      ExceptionSpecInstantiation,\n\n      /// We are instantiating a requirement of a requires expression.\n      RequirementInstantiation,\n\n      /// We are checking the satisfaction of a nested requirement of a requires\n      /// expression.\n      NestedRequirementConstraintsCheck,\n\n      /// We are declaring an implicit special member function.\n      DeclaringSpecialMember,\n\n      /// We are declaring an implicit 'operator==' for a defaulted\n      /// 'operator<=>'.\n      DeclaringImplicitEqualityComparison,\n\n      /// We are defining a synthesized function (such as a defaulted special\n      /// member).\n      DefiningSynthesizedFunction,\n\n      // We are checking the constraints associated with a constrained entity or\n      // the constraint expression of a concept. This includes the checks that\n      // atomic constraints have the type 'bool' and that they can be constant\n      // evaluated.\n      ConstraintsCheck,\n\n      // We are substituting template arguments into a constraint expression.\n      ConstraintSubstitution,\n\n      // We are normalizing a constraint expression.\n      ConstraintNormalization,\n\n      // We are substituting into the parameter mapping of an atomic constraint\n      // during normalization.\n      ParameterMappingSubstitution,\n\n      /// We are rewriting a comparison operator in terms of an operator<=>.\n      RewritingOperatorAsSpaceship,\n\n      /// We are initializing a structured binding.\n      InitializingStructuredBinding,\n\n      /// We are marking a class as __dllexport.\n      MarkingClassDllexported,\n\n      /// Added for Template instantiation observation.\n      /// Memoization means we are _not_ instantiating a template because\n      /// it is already instantiated (but we entered a context where we\n      /// would have had to if it was not already instantiated).\n      Memoization\n    } Kind;\n\n    /// Was the enclosing context a non-instantiation SFINAE context?\n    bool SavedInNonInstantiationSFINAEContext;\n\n    /// The point of instantiation or synthesis within the source code.\n    SourceLocation PointOfInstantiation;\n\n    /// The entity that is being synthesized.\n    Decl *Entity;\n\n    /// The template (or partial specialization) in which we are\n    /// performing the instantiation, for substitutions of prior template\n    /// arguments.\n    NamedDecl *Template;\n\n    /// The list of template arguments we are substituting, if they\n    /// are not part of the entity.\n    const TemplateArgument *TemplateArgs;\n\n    // FIXME: Wrap this union around more members, or perhaps store the\n    // kind-specific members in the RAII object owning the context.\n    union {\n      /// The number of template arguments in TemplateArgs.\n      unsigned NumTemplateArgs;\n\n      /// The special member being declared or defined.\n      CXXSpecialMember SpecialMember;\n    };\n\n    ArrayRef<TemplateArgument> template_arguments() const {\n      assert(Kind != DeclaringSpecialMember);\n      return {TemplateArgs, NumTemplateArgs};\n    }\n\n    /// The template deduction info object associated with the\n    /// substitution or checking of explicit or deduced template arguments.\n    sema::TemplateDeductionInfo *DeductionInfo;\n\n    /// The source range that covers the construct that cause\n    /// the instantiation, e.g., the template-id that causes a class\n    /// template instantiation.\n    SourceRange InstantiationRange;\n\n    CodeSynthesisContext()\n        : Kind(TemplateInstantiation),\n          SavedInNonInstantiationSFINAEContext(false), Entity(nullptr),\n          Template(nullptr), TemplateArgs(nullptr), NumTemplateArgs(0),\n          DeductionInfo(nullptr) {}\n\n    /// Determines whether this template is an actual instantiation\n    /// that should be counted toward the maximum instantiation depth.\n    bool isInstantiationRecord() const;\n  };\n\n  /// List of active code synthesis contexts.\n  ///\n  /// This vector is treated as a stack. As synthesis of one entity requires\n  /// synthesis of another, additional contexts are pushed onto the stack.\n  SmallVector<CodeSynthesisContext, 16> CodeSynthesisContexts;\n\n  /// Specializations whose definitions are currently being instantiated.\n  llvm::DenseSet<std::pair<Decl *, unsigned>> InstantiatingSpecializations;\n\n  /// Non-dependent types used in templates that have already been instantiated\n  /// by some template instantiation.\n  llvm::DenseSet<QualType> InstantiatedNonDependentTypes;\n\n  /// Extra modules inspected when performing a lookup during a template\n  /// instantiation. Computed lazily.\n  SmallVector<Module*, 16> CodeSynthesisContextLookupModules;\n\n  /// Cache of additional modules that should be used for name lookup\n  /// within the current template instantiation. Computed lazily; use\n  /// getLookupModules() to get a complete set.\n  llvm::DenseSet<Module*> LookupModulesCache;\n\n  /// Get the set of additional modules that should be checked during\n  /// name lookup. A module and its imports become visible when instanting a\n  /// template defined within it.\n  llvm::DenseSet<Module*> &getLookupModules();\n\n  /// Map from the most recent declaration of a namespace to the most\n  /// recent visible declaration of that namespace.\n  llvm::DenseMap<NamedDecl*, NamedDecl*> VisibleNamespaceCache;\n\n  /// Whether we are in a SFINAE context that is not associated with\n  /// template instantiation.\n  ///\n  /// This is used when setting up a SFINAE trap (\\c see SFINAETrap) outside\n  /// of a template instantiation or template argument deduction.\n  bool InNonInstantiationSFINAEContext;\n\n  /// The number of \\p CodeSynthesisContexts that are not template\n  /// instantiations and, therefore, should not be counted as part of the\n  /// instantiation depth.\n  ///\n  /// When the instantiation depth reaches the user-configurable limit\n  /// \\p LangOptions::InstantiationDepth we will abort instantiation.\n  // FIXME: Should we have a similar limit for other forms of synthesis?\n  unsigned NonInstantiationEntries;\n\n  /// The depth of the context stack at the point when the most recent\n  /// error or warning was produced.\n  ///\n  /// This value is used to suppress printing of redundant context stacks\n  /// when there are multiple errors or warnings in the same instantiation.\n  // FIXME: Does this belong in Sema? It's tough to implement it anywhere else.\n  unsigned LastEmittedCodeSynthesisContextDepth = 0;\n\n  /// The template instantiation callbacks to trace or track\n  /// instantiations (objects can be chained).\n  ///\n  /// This callbacks is used to print, trace or track template\n  /// instantiations as they are being constructed.\n  std::vector<std::unique_ptr<TemplateInstantiationCallback>>\n      TemplateInstCallbacks;\n\n  /// The current index into pack expansion arguments that will be\n  /// used for substitution of parameter packs.\n  ///\n  /// The pack expansion index will be -1 to indicate that parameter packs\n  /// should be instantiated as themselves. Otherwise, the index specifies\n  /// which argument within the parameter pack will be used for substitution.\n  int ArgumentPackSubstitutionIndex;\n\n  /// RAII object used to change the argument pack substitution index\n  /// within a \\c Sema object.\n  ///\n  /// See \\c ArgumentPackSubstitutionIndex for more information.\n  class ArgumentPackSubstitutionIndexRAII {\n    Sema &Self;\n    int OldSubstitutionIndex;\n\n  public:\n    ArgumentPackSubstitutionIndexRAII(Sema &Self, int NewSubstitutionIndex)\n      : Self(Self), OldSubstitutionIndex(Self.ArgumentPackSubstitutionIndex) {\n      Self.ArgumentPackSubstitutionIndex = NewSubstitutionIndex;\n    }\n\n    ~ArgumentPackSubstitutionIndexRAII() {\n      Self.ArgumentPackSubstitutionIndex = OldSubstitutionIndex;\n    }\n  };\n\n  friend class ArgumentPackSubstitutionRAII;\n\n  /// For each declaration that involved template argument deduction, the\n  /// set of diagnostics that were suppressed during that template argument\n  /// deduction.\n  ///\n  /// FIXME: Serialize this structure to the AST file.\n  typedef llvm::DenseMap<Decl *, SmallVector<PartialDiagnosticAt, 1> >\n    SuppressedDiagnosticsMap;\n  SuppressedDiagnosticsMap SuppressedDiagnostics;\n\n  /// A stack object to be created when performing template\n  /// instantiation.\n  ///\n  /// Construction of an object of type \\c InstantiatingTemplate\n  /// pushes the current instantiation onto the stack of active\n  /// instantiations. If the size of this stack exceeds the maximum\n  /// number of recursive template instantiations, construction\n  /// produces an error and evaluates true.\n  ///\n  /// Destruction of this object will pop the named instantiation off\n  /// the stack.\n  struct InstantiatingTemplate {\n    /// Note that we are instantiating a class template,\n    /// function template, variable template, alias template,\n    /// or a member thereof.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          Decl *Entity,\n                          SourceRange InstantiationRange = SourceRange());\n\n    struct ExceptionSpecification {};\n    /// Note that we are instantiating an exception specification\n    /// of a function template.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionDecl *Entity, ExceptionSpecification,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument in a\n    /// template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateParameter Param, TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting either explicitly-specified or\n    /// deduced template arguments during function template argument deduction.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionTemplateDecl *FunctionTemplate,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          CodeSynthesisContext::SynthesisKind Kind,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template declaration.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a variable template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          VarTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument for a function\n    /// parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParmVarDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting prior template arguments into a\n    /// non-type parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          NonTypeTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are substituting prior template arguments into a\n    /// template template parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          TemplateTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are checking the default template argument\n    /// against the template parameter for a given template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          NamedDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintsCheck {};\n    /// \\brief Note that we are checking the constraints associated with some\n    /// constrained entity (a concept declaration or a template with associated\n    /// constraints).\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintsCheck, NamedDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintSubstitution {};\n    /// \\brief Note that we are checking a constraint expression associated\n    /// with a template declaration or as part of the satisfaction check of a\n    /// concept.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintSubstitution, NamedDecl *Template,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintNormalization {};\n    /// \\brief Note that we are normalizing a constraint expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintNormalization, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    struct ParameterMappingSubstitution {};\n    /// \\brief Note that we are subtituting into the parameter mapping of an\n    /// atomic constraint during constraint normalization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParameterMappingSubstitution, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    /// \\brief Note that we are substituting template arguments into a part of\n    /// a requirement of a requires expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::Requirement *Req,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// \\brief Note that we are checking the satisfaction of the constraint\n    /// expression inside of a nested requirement.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::NestedRequirement *Req, ConstraintsCheck,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we have finished instantiating this template.\n    void Clear();\n\n    ~InstantiatingTemplate() { Clear(); }\n\n    /// Determines whether we have exceeded the maximum\n    /// recursive template instantiations.\n    bool isInvalid() const { return Invalid; }\n\n    /// Determine whether we are already instantiating this\n    /// specialization in some surrounding active instantiation.\n    bool isAlreadyInstantiating() const { return AlreadyInstantiating; }\n\n  private:\n    Sema &SemaRef;\n    bool Invalid;\n    bool AlreadyInstantiating;\n    bool CheckInstantiationDepth(SourceLocation PointOfInstantiation,\n                                 SourceRange InstantiationRange);\n\n    InstantiatingTemplate(\n        Sema &SemaRef, CodeSynthesisContext::SynthesisKind Kind,\n        SourceLocation PointOfInstantiation, SourceRange InstantiationRange,\n        Decl *Entity, NamedDecl *Template = nullptr,\n        ArrayRef<TemplateArgument> TemplateArgs = None,\n        sema::TemplateDeductionInfo *DeductionInfo = nullptr);\n\n    InstantiatingTemplate(const InstantiatingTemplate&) = delete;\n\n    InstantiatingTemplate&\n    operator=(const InstantiatingTemplate&) = delete;\n  };\n\n  void pushCodeSynthesisContext(CodeSynthesisContext Ctx);\n  void popCodeSynthesisContext();\n\n  /// Determine whether we are currently performing template instantiation.\n  bool inTemplateInstantiation() const {\n    return CodeSynthesisContexts.size() > NonInstantiationEntries;\n  }\n\n  void PrintContextStack() {\n    if (!CodeSynthesisContexts.empty() &&\n        CodeSynthesisContexts.size() != LastEmittedCodeSynthesisContextDepth) {\n      PrintInstantiationStack();\n      LastEmittedCodeSynthesisContextDepth = CodeSynthesisContexts.size();\n    }\n    if (PragmaAttributeCurrentTargetDecl)\n      PrintPragmaAttributeInstantiationPoint();\n  }\n  void PrintInstantiationStack();\n\n  void PrintPragmaAttributeInstantiationPoint();\n\n  /// Determines whether we are currently in a context where\n  /// template argument substitution failures are not considered\n  /// errors.\n  ///\n  /// \\returns An empty \\c Optional if we're not in a SFINAE context.\n  /// Otherwise, contains a pointer that, if non-NULL, contains the nearest\n  /// template-deduction context object, which can be used to capture\n  /// diagnostics that will be suppressed.\n  Optional<sema::TemplateDeductionInfo *> isSFINAEContext() const;\n\n  /// Determines whether we are currently in a context that\n  /// is not evaluated as per C++ [expr] p5.\n  bool isUnevaluatedContext() const {\n    assert(!ExprEvalContexts.empty() &&\n           \"Must be in an expression evaluation context\");\n    return ExprEvalContexts.back().isUnevaluated();\n  }\n\n  /// RAII class used to determine whether SFINAE has\n  /// trapped any errors that occur during template argument\n  /// deduction.\n  class SFINAETrap {\n    Sema &SemaRef;\n    unsigned PrevSFINAEErrors;\n    bool PrevInNonInstantiationSFINAEContext;\n    bool PrevAccessCheckingSFINAE;\n    bool PrevLastDiagnosticIgnored;\n\n  public:\n    explicit SFINAETrap(Sema &SemaRef, bool AccessCheckingSFINAE = false)\n      : SemaRef(SemaRef), PrevSFINAEErrors(SemaRef.NumSFINAEErrors),\n        PrevInNonInstantiationSFINAEContext(\n                                      SemaRef.InNonInstantiationSFINAEContext),\n        PrevAccessCheckingSFINAE(SemaRef.AccessCheckingSFINAE),\n        PrevLastDiagnosticIgnored(\n            SemaRef.getDiagnostics().isLastDiagnosticIgnored())\n    {\n      if (!SemaRef.isSFINAEContext())\n        SemaRef.InNonInstantiationSFINAEContext = true;\n      SemaRef.AccessCheckingSFINAE = AccessCheckingSFINAE;\n    }\n\n    ~SFINAETrap() {\n      SemaRef.NumSFINAEErrors = PrevSFINAEErrors;\n      SemaRef.InNonInstantiationSFINAEContext\n        = PrevInNonInstantiationSFINAEContext;\n      SemaRef.AccessCheckingSFINAE = PrevAccessCheckingSFINAE;\n      SemaRef.getDiagnostics().setLastDiagnosticIgnored(\n          PrevLastDiagnosticIgnored);\n    }\n\n    /// Determine whether any SFINAE errors have been trapped.\n    bool hasErrorOccurred() const {\n      return SemaRef.NumSFINAEErrors > PrevSFINAEErrors;\n    }\n  };\n\n  /// RAII class used to indicate that we are performing provisional\n  /// semantic analysis to determine the validity of a construct, so\n  /// typo-correction and diagnostics in the immediate context (not within\n  /// implicitly-instantiated templates) should be suppressed.\n  class TentativeAnalysisScope {\n    Sema &SemaRef;\n    // FIXME: Using a SFINAETrap for this is a hack.\n    SFINAETrap Trap;\n    bool PrevDisableTypoCorrection;\n  public:\n    explicit TentativeAnalysisScope(Sema &SemaRef)\n        : SemaRef(SemaRef), Trap(SemaRef, true),\n          PrevDisableTypoCorrection(SemaRef.DisableTypoCorrection) {\n      SemaRef.DisableTypoCorrection = true;\n    }\n    ~TentativeAnalysisScope() {\n      SemaRef.DisableTypoCorrection = PrevDisableTypoCorrection;\n    }\n  };\n\n  /// The current instantiation scope used to store local\n  /// variables.\n  LocalInstantiationScope *CurrentInstantiationScope;\n\n  /// Tracks whether we are in a context where typo correction is\n  /// disabled.\n  bool DisableTypoCorrection;\n\n  /// The number of typos corrected by CorrectTypo.\n  unsigned TyposCorrected;\n\n  typedef llvm::SmallSet<SourceLocation, 2> SrcLocSet;\n  typedef llvm::DenseMap<IdentifierInfo *, SrcLocSet> IdentifierSourceLocations;\n\n  /// A cache containing identifiers for which typo correction failed and\n  /// their locations, so that repeated attempts to correct an identifier in a\n  /// given location are ignored if typo correction already failed for it.\n  IdentifierSourceLocations TypoCorrectionFailures;\n\n  /// Worker object for performing CFG-based warnings.\n  sema::AnalysisBasedWarnings AnalysisWarnings;\n  threadSafety::BeforeSet *ThreadSafetyDeclCache;\n\n  /// An entity for which implicit template instantiation is required.\n  ///\n  /// The source location associated with the declaration is the first place in\n  /// the source code where the declaration was \"used\". It is not necessarily\n  /// the point of instantiation (which will be either before or after the\n  /// namespace-scope declaration that triggered this implicit instantiation),\n  /// However, it is the location that diagnostics should generally refer to,\n  /// because users will need to know what code triggered the instantiation.\n  typedef std::pair<ValueDecl *, SourceLocation> PendingImplicitInstantiation;\n\n  /// The queue of implicit template instantiations that are required\n  /// but have not yet been performed.\n  std::deque<PendingImplicitInstantiation> PendingInstantiations;\n\n  /// Queue of implicit template instantiations that cannot be performed\n  /// eagerly.\n  SmallVector<PendingImplicitInstantiation, 1> LateParsedInstantiations;\n\n  class GlobalEagerInstantiationScope {\n  public:\n    GlobalEagerInstantiationScope(Sema &S, bool Enabled)\n        : S(S), Enabled(Enabled) {\n      if (!Enabled) return;\n\n      SavedPendingInstantiations.swap(S.PendingInstantiations);\n      SavedVTableUses.swap(S.VTableUses);\n    }\n\n    void perform() {\n      if (Enabled) {\n        S.DefineUsedVTables();\n        S.PerformPendingInstantiations();\n      }\n    }\n\n    ~GlobalEagerInstantiationScope() {\n      if (!Enabled) return;\n\n      // Restore the set of pending vtables.\n      assert(S.VTableUses.empty() &&\n             \"VTableUses should be empty before it is discarded.\");\n      S.VTableUses.swap(SavedVTableUses);\n\n      // Restore the set of pending implicit instantiations.\n      if (S.TUKind != TU_Prefix || !S.LangOpts.PCHInstantiateTemplates) {\n        assert(S.PendingInstantiations.empty() &&\n               \"PendingInstantiations should be empty before it is discarded.\");\n        S.PendingInstantiations.swap(SavedPendingInstantiations);\n      } else {\n        // Template instantiations in the PCH may be delayed until the TU.\n        S.PendingInstantiations.swap(SavedPendingInstantiations);\n        S.PendingInstantiations.insert(S.PendingInstantiations.end(),\n                                       SavedPendingInstantiations.begin(),\n                                       SavedPendingInstantiations.end());\n      }\n    }\n\n  private:\n    Sema &S;\n    SmallVector<VTableUse, 16> SavedVTableUses;\n    std::deque<PendingImplicitInstantiation> SavedPendingInstantiations;\n    bool Enabled;\n  };\n\n  /// The queue of implicit template instantiations that are required\n  /// and must be performed within the current local scope.\n  ///\n  /// This queue is only used for member functions of local classes in\n  /// templates, which must be instantiated in the same scope as their\n  /// enclosing function, so that they can reference function-local\n  /// types, static variables, enumerators, etc.\n  std::deque<PendingImplicitInstantiation> PendingLocalImplicitInstantiations;\n\n  class LocalEagerInstantiationScope {\n  public:\n    LocalEagerInstantiationScope(Sema &S) : S(S) {\n      SavedPendingLocalImplicitInstantiations.swap(\n          S.PendingLocalImplicitInstantiations);\n    }\n\n    void perform() { S.PerformPendingInstantiations(/*LocalOnly=*/true); }\n\n    ~LocalEagerInstantiationScope() {\n      assert(S.PendingLocalImplicitInstantiations.empty() &&\n             \"there shouldn't be any pending local implicit instantiations\");\n      SavedPendingLocalImplicitInstantiations.swap(\n          S.PendingLocalImplicitInstantiations);\n    }\n\n  private:\n    Sema &S;\n    std::deque<PendingImplicitInstantiation>\n        SavedPendingLocalImplicitInstantiations;\n  };\n\n  /// A helper class for building up ExtParameterInfos.\n  class ExtParameterInfoBuilder {\n    SmallVector<FunctionProtoType::ExtParameterInfo, 16> Infos;\n    bool HasInteresting = false;\n\n  public:\n    /// Set the ExtParameterInfo for the parameter at the given index,\n    ///\n    void set(unsigned index, FunctionProtoType::ExtParameterInfo info) {\n      assert(Infos.size() <= index);\n      Infos.resize(index);\n      Infos.push_back(info);\n\n      if (!HasInteresting)\n        HasInteresting = (info != FunctionProtoType::ExtParameterInfo());\n    }\n\n    /// Return a pointer (suitable for setting in an ExtProtoInfo) to the\n    /// ExtParameterInfo array we've built up.\n    const FunctionProtoType::ExtParameterInfo *\n    getPointerOrNull(unsigned numParams) {\n      if (!HasInteresting) return nullptr;\n      Infos.resize(numParams);\n      return Infos.data();\n    }\n  };\n\n  void PerformPendingInstantiations(bool LocalOnly = false);\n\n  TypeSourceInfo *SubstType(TypeSourceInfo *T,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                            SourceLocation Loc, DeclarationName Entity,\n                            bool AllowDeducedTST = false);\n\n  QualType SubstType(QualType T,\n                     const MultiLevelTemplateArgumentList &TemplateArgs,\n                     SourceLocation Loc, DeclarationName Entity);\n\n  TypeSourceInfo *SubstType(TypeLoc TL,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                            SourceLocation Loc, DeclarationName Entity);\n\n  TypeSourceInfo *SubstFunctionDeclType(TypeSourceInfo *T,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                                        SourceLocation Loc,\n                                        DeclarationName Entity,\n                                        CXXRecordDecl *ThisContext,\n                                        Qualifiers ThisTypeQuals);\n  void SubstExceptionSpec(FunctionDecl *New, const FunctionProtoType *Proto,\n                          const MultiLevelTemplateArgumentList &Args);\n  bool SubstExceptionSpec(SourceLocation Loc,\n                          FunctionProtoType::ExceptionSpecInfo &ESI,\n                          SmallVectorImpl<QualType> &ExceptionStorage,\n                          const MultiLevelTemplateArgumentList &Args);\n  ParmVarDecl *SubstParmVarDecl(ParmVarDecl *D,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                                int indexAdjustment,\n                                Optional<unsigned> NumExpansions,\n                                bool ExpectParameterPack);\n  bool SubstParmTypes(SourceLocation Loc, ArrayRef<ParmVarDecl *> Params,\n                      const FunctionProtoType::ExtParameterInfo *ExtParamInfos,\n                      const MultiLevelTemplateArgumentList &TemplateArgs,\n                      SmallVectorImpl<QualType> &ParamTypes,\n                      SmallVectorImpl<ParmVarDecl *> *OutParams,\n                      ExtParameterInfoBuilder &ParamInfos);\n  ExprResult SubstExpr(Expr *E,\n                       const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Substitute the given template arguments into a list of\n  /// expressions, expanding pack expansions if required.\n  ///\n  /// \\param Exprs The list of expressions to substitute into.\n  ///\n  /// \\param IsCall Whether this is some form of call, in which case\n  /// default arguments will be dropped.\n  ///\n  /// \\param TemplateArgs The set of template arguments to substitute.\n  ///\n  /// \\param Outputs Will receive all of the substituted arguments.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool SubstExprs(ArrayRef<Expr *> Exprs, bool IsCall,\n                  const MultiLevelTemplateArgumentList &TemplateArgs,\n                  SmallVectorImpl<Expr *> &Outputs);\n\n  StmtResult SubstStmt(Stmt *S,\n                       const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  TemplateParameterList *\n  SubstTemplateParams(TemplateParameterList *Params, DeclContext *Owner,\n                      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool\n  SubstTemplateArguments(ArrayRef<TemplateArgumentLoc> Args,\n                         const MultiLevelTemplateArgumentList &TemplateArgs,\n                         TemplateArgumentListInfo &Outputs);\n\n\n  Decl *SubstDecl(Decl *D, DeclContext *Owner,\n                  const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Substitute the name and return type of a defaulted 'operator<=>' to form\n  /// an implicit 'operator=='.\n  FunctionDecl *SubstSpaceshipAsEqualEqual(CXXRecordDecl *RD,\n                                           FunctionDecl *Spaceship);\n\n  ExprResult SubstInitializer(Expr *E,\n                       const MultiLevelTemplateArgumentList &TemplateArgs,\n                       bool CXXDirectInit);\n\n  bool\n  SubstBaseSpecifiers(CXXRecordDecl *Instantiation,\n                      CXXRecordDecl *Pattern,\n                      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool\n  InstantiateClass(SourceLocation PointOfInstantiation,\n                   CXXRecordDecl *Instantiation, CXXRecordDecl *Pattern,\n                   const MultiLevelTemplateArgumentList &TemplateArgs,\n                   TemplateSpecializationKind TSK,\n                   bool Complain = true);\n\n  bool InstantiateEnum(SourceLocation PointOfInstantiation,\n                       EnumDecl *Instantiation, EnumDecl *Pattern,\n                       const MultiLevelTemplateArgumentList &TemplateArgs,\n                       TemplateSpecializationKind TSK);\n\n  bool InstantiateInClassInitializer(\n      SourceLocation PointOfInstantiation, FieldDecl *Instantiation,\n      FieldDecl *Pattern, const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  struct LateInstantiatedAttribute {\n    const Attr *TmplAttr;\n    LocalInstantiationScope *Scope;\n    Decl *NewDecl;\n\n    LateInstantiatedAttribute(const Attr *A, LocalInstantiationScope *S,\n                              Decl *D)\n      : TmplAttr(A), Scope(S), NewDecl(D)\n    { }\n  };\n  typedef SmallVector<LateInstantiatedAttribute, 16> LateInstantiatedAttrVec;\n\n  void InstantiateAttrs(const MultiLevelTemplateArgumentList &TemplateArgs,\n                        const Decl *Pattern, Decl *Inst,\n                        LateInstantiatedAttrVec *LateAttrs = nullptr,\n                        LocalInstantiationScope *OuterMostScope = nullptr);\n\n  void\n  InstantiateAttrsForDecl(const MultiLevelTemplateArgumentList &TemplateArgs,\n                          const Decl *Pattern, Decl *Inst,\n                          LateInstantiatedAttrVec *LateAttrs = nullptr,\n                          LocalInstantiationScope *OuterMostScope = nullptr);\n\n  void InstantiateDefaultCtorDefaultArgs(CXXConstructorDecl *Ctor);\n\n  bool usesPartialOrExplicitSpecialization(\n      SourceLocation Loc, ClassTemplateSpecializationDecl *ClassTemplateSpec);\n\n  bool\n  InstantiateClassTemplateSpecialization(SourceLocation PointOfInstantiation,\n                           ClassTemplateSpecializationDecl *ClassTemplateSpec,\n                           TemplateSpecializationKind TSK,\n                           bool Complain = true);\n\n  void InstantiateClassMembers(SourceLocation PointOfInstantiation,\n                               CXXRecordDecl *Instantiation,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                               TemplateSpecializationKind TSK);\n\n  void InstantiateClassTemplateSpecializationMembers(\n                                          SourceLocation PointOfInstantiation,\n                           ClassTemplateSpecializationDecl *ClassTemplateSpec,\n                                                TemplateSpecializationKind TSK);\n\n  NestedNameSpecifierLoc\n  SubstNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS,\n                           const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  DeclarationNameInfo\n  SubstDeclarationNameInfo(const DeclarationNameInfo &NameInfo,\n                           const MultiLevelTemplateArgumentList &TemplateArgs);\n  TemplateName\n  SubstTemplateName(NestedNameSpecifierLoc QualifierLoc, TemplateName Name,\n                    SourceLocation Loc,\n                    const MultiLevelTemplateArgumentList &TemplateArgs);\n  bool Subst(const TemplateArgumentLoc *Args, unsigned NumArgs,\n             TemplateArgumentListInfo &Result,\n             const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool InstantiateDefaultArgument(SourceLocation CallLoc, FunctionDecl *FD,\n                                  ParmVarDecl *Param);\n  void InstantiateExceptionSpec(SourceLocation PointOfInstantiation,\n                                FunctionDecl *Function);\n  bool CheckInstantiatedFunctionTemplateConstraints(\n      SourceLocation PointOfInstantiation, FunctionDecl *Decl,\n      ArrayRef<TemplateArgument> TemplateArgs,\n      ConstraintSatisfaction &Satisfaction);\n  FunctionDecl *InstantiateFunctionDeclaration(FunctionTemplateDecl *FTD,\n                                               const TemplateArgumentList *Args,\n                                               SourceLocation Loc);\n  void InstantiateFunctionDefinition(SourceLocation PointOfInstantiation,\n                                     FunctionDecl *Function,\n                                     bool Recursive = false,\n                                     bool DefinitionRequired = false,\n                                     bool AtEndOfTU = false);\n  VarTemplateSpecializationDecl *BuildVarTemplateInstantiation(\n      VarTemplateDecl *VarTemplate, VarDecl *FromVar,\n      const TemplateArgumentList &TemplateArgList,\n      const TemplateArgumentListInfo &TemplateArgsInfo,\n      SmallVectorImpl<TemplateArgument> &Converted,\n      SourceLocation PointOfInstantiation,\n      LateInstantiatedAttrVec *LateAttrs = nullptr,\n      LocalInstantiationScope *StartingScope = nullptr);\n  VarTemplateSpecializationDecl *CompleteVarTemplateSpecializationDecl(\n      VarTemplateSpecializationDecl *VarSpec, VarDecl *PatternDecl,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n  void\n  BuildVariableInstantiation(VarDecl *NewVar, VarDecl *OldVar,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                             LateInstantiatedAttrVec *LateAttrs,\n                             DeclContext *Owner,\n                             LocalInstantiationScope *StartingScope,\n                             bool InstantiatingVarTemplate = false,\n                             VarTemplateSpecializationDecl *PrevVTSD = nullptr);\n\n  void InstantiateVariableInitializer(\n      VarDecl *Var, VarDecl *OldVar,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n  void InstantiateVariableDefinition(SourceLocation PointOfInstantiation,\n                                     VarDecl *Var, bool Recursive = false,\n                                     bool DefinitionRequired = false,\n                                     bool AtEndOfTU = false);\n\n  void InstantiateMemInitializers(CXXConstructorDecl *New,\n                                  const CXXConstructorDecl *Tmpl,\n                            const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  NamedDecl *FindInstantiatedDecl(SourceLocation Loc, NamedDecl *D,\n                          const MultiLevelTemplateArgumentList &TemplateArgs,\n                          bool FindingInstantiatedContext = false);\n  DeclContext *FindInstantiatedContext(SourceLocation Loc, DeclContext *DC,\n                          const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  // Objective-C declarations.\n  enum ObjCContainerKind {\n    OCK_None = -1,\n    OCK_Interface = 0,\n    OCK_Protocol,\n    OCK_Category,\n    OCK_ClassExtension,\n    OCK_Implementation,\n    OCK_CategoryImplementation\n  };\n  ObjCContainerKind getObjCContainerKind() const;\n\n  DeclResult actOnObjCTypeParam(Scope *S,\n                                ObjCTypeParamVariance variance,\n                                SourceLocation varianceLoc,\n                                unsigned index,\n                                IdentifierInfo *paramName,\n                                SourceLocation paramLoc,\n                                SourceLocation colonLoc,\n                                ParsedType typeBound);\n\n  ObjCTypeParamList *actOnObjCTypeParamList(Scope *S, SourceLocation lAngleLoc,\n                                            ArrayRef<Decl *> typeParams,\n                                            SourceLocation rAngleLoc);\n  void popObjCTypeParamList(Scope *S, ObjCTypeParamList *typeParamList);\n\n  Decl *ActOnStartClassInterface(\n      Scope *S, SourceLocation AtInterfaceLoc, IdentifierInfo *ClassName,\n      SourceLocation ClassLoc, ObjCTypeParamList *typeParamList,\n      IdentifierInfo *SuperName, SourceLocation SuperLoc,\n      ArrayRef<ParsedType> SuperTypeArgs, SourceRange SuperTypeArgsRange,\n      Decl *const *ProtoRefs, unsigned NumProtoRefs,\n      const SourceLocation *ProtoLocs, SourceLocation EndProtoLoc,\n      const ParsedAttributesView &AttrList);\n\n  void ActOnSuperClassOfClassInterface(Scope *S,\n                                       SourceLocation AtInterfaceLoc,\n                                       ObjCInterfaceDecl *IDecl,\n                                       IdentifierInfo *ClassName,\n                                       SourceLocation ClassLoc,\n                                       IdentifierInfo *SuperName,\n                                       SourceLocation SuperLoc,\n                                       ArrayRef<ParsedType> SuperTypeArgs,\n                                       SourceRange SuperTypeArgsRange);\n\n  void ActOnTypedefedProtocols(SmallVectorImpl<Decl *> &ProtocolRefs,\n                               SmallVectorImpl<SourceLocation> &ProtocolLocs,\n                               IdentifierInfo *SuperName,\n                               SourceLocation SuperLoc);\n\n  Decl *ActOnCompatibilityAlias(\n                    SourceLocation AtCompatibilityAliasLoc,\n                    IdentifierInfo *AliasName,  SourceLocation AliasLocation,\n                    IdentifierInfo *ClassName, SourceLocation ClassLocation);\n\n  bool CheckForwardProtocolDeclarationForCircularDependency(\n    IdentifierInfo *PName,\n    SourceLocation &PLoc, SourceLocation PrevLoc,\n    const ObjCList<ObjCProtocolDecl> &PList);\n\n  Decl *ActOnStartProtocolInterface(\n      SourceLocation AtProtoInterfaceLoc, IdentifierInfo *ProtocolName,\n      SourceLocation ProtocolLoc, Decl *const *ProtoRefNames,\n      unsigned NumProtoRefs, const SourceLocation *ProtoLocs,\n      SourceLocation EndProtoLoc, const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartCategoryInterface(\n      SourceLocation AtInterfaceLoc, IdentifierInfo *ClassName,\n      SourceLocation ClassLoc, ObjCTypeParamList *typeParamList,\n      IdentifierInfo *CategoryName, SourceLocation CategoryLoc,\n      Decl *const *ProtoRefs, unsigned NumProtoRefs,\n      const SourceLocation *ProtoLocs, SourceLocation EndProtoLoc,\n      const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartClassImplementation(SourceLocation AtClassImplLoc,\n                                      IdentifierInfo *ClassName,\n                                      SourceLocation ClassLoc,\n                                      IdentifierInfo *SuperClassname,\n                                      SourceLocation SuperClassLoc,\n                                      const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartCategoryImplementation(SourceLocation AtCatImplLoc,\n                                         IdentifierInfo *ClassName,\n                                         SourceLocation ClassLoc,\n                                         IdentifierInfo *CatName,\n                                         SourceLocation CatLoc,\n                                         const ParsedAttributesView &AttrList);\n\n  DeclGroupPtrTy ActOnFinishObjCImplementation(Decl *ObjCImpDecl,\n                                               ArrayRef<Decl *> Decls);\n\n  DeclGroupPtrTy ActOnForwardClassDeclaration(SourceLocation Loc,\n                   IdentifierInfo **IdentList,\n                   SourceLocation *IdentLocs,\n                   ArrayRef<ObjCTypeParamList *> TypeParamLists,\n                   unsigned NumElts);\n\n  DeclGroupPtrTy\n  ActOnForwardProtocolDeclaration(SourceLocation AtProtoclLoc,\n                                  ArrayRef<IdentifierLocPair> IdentList,\n                                  const ParsedAttributesView &attrList);\n\n  void FindProtocolDeclaration(bool WarnOnDeclarations, bool ForObjCContainer,\n                               ArrayRef<IdentifierLocPair> ProtocolId,\n                               SmallVectorImpl<Decl *> &Protocols);\n\n  void DiagnoseTypeArgsAndProtocols(IdentifierInfo *ProtocolId,\n                                    SourceLocation ProtocolLoc,\n                                    IdentifierInfo *TypeArgId,\n                                    SourceLocation TypeArgLoc,\n                                    bool SelectProtocolFirst = false);\n\n  /// Given a list of identifiers (and their locations), resolve the\n  /// names to either Objective-C protocol qualifiers or type\n  /// arguments, as appropriate.\n  void actOnObjCTypeArgsOrProtocolQualifiers(\n         Scope *S,\n         ParsedType baseType,\n         SourceLocation lAngleLoc,\n         ArrayRef<IdentifierInfo *> identifiers,\n         ArrayRef<SourceLocation> identifierLocs,\n         SourceLocation rAngleLoc,\n         SourceLocation &typeArgsLAngleLoc,\n         SmallVectorImpl<ParsedType> &typeArgs,\n         SourceLocation &typeArgsRAngleLoc,\n         SourceLocation &protocolLAngleLoc,\n         SmallVectorImpl<Decl *> &protocols,\n         SourceLocation &protocolRAngleLoc,\n         bool warnOnIncompleteProtocols);\n\n  /// Build a an Objective-C protocol-qualified 'id' type where no\n  /// base type was specified.\n  TypeResult actOnObjCProtocolQualifierType(\n               SourceLocation lAngleLoc,\n               ArrayRef<Decl *> protocols,\n               ArrayRef<SourceLocation> protocolLocs,\n               SourceLocation rAngleLoc);\n\n  /// Build a specialized and/or protocol-qualified Objective-C type.\n  TypeResult actOnObjCTypeArgsAndProtocolQualifiers(\n               Scope *S,\n               SourceLocation Loc,\n               ParsedType BaseType,\n               SourceLocation TypeArgsLAngleLoc,\n               ArrayRef<ParsedType> TypeArgs,\n               SourceLocation TypeArgsRAngleLoc,\n               SourceLocation ProtocolLAngleLoc,\n               ArrayRef<Decl *> Protocols,\n               ArrayRef<SourceLocation> ProtocolLocs,\n               SourceLocation ProtocolRAngleLoc);\n\n  /// Build an Objective-C type parameter type.\n  QualType BuildObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                  SourceLocation ProtocolLAngleLoc,\n                                  ArrayRef<ObjCProtocolDecl *> Protocols,\n                                  ArrayRef<SourceLocation> ProtocolLocs,\n                                  SourceLocation ProtocolRAngleLoc,\n                                  bool FailOnError = false);\n\n  /// Build an Objective-C object pointer type.\n  QualType BuildObjCObjectType(QualType BaseType,\n                               SourceLocation Loc,\n                               SourceLocation TypeArgsLAngleLoc,\n                               ArrayRef<TypeSourceInfo *> TypeArgs,\n                               SourceLocation TypeArgsRAngleLoc,\n                               SourceLocation ProtocolLAngleLoc,\n                               ArrayRef<ObjCProtocolDecl *> Protocols,\n                               ArrayRef<SourceLocation> ProtocolLocs,\n                               SourceLocation ProtocolRAngleLoc,\n                               bool FailOnError = false);\n\n  /// Ensure attributes are consistent with type.\n  /// \\param [in, out] Attributes The attributes to check; they will\n  /// be modified to be consistent with \\p PropertyTy.\n  void CheckObjCPropertyAttributes(Decl *PropertyPtrTy,\n                                   SourceLocation Loc,\n                                   unsigned &Attributes,\n                                   bool propertyInPrimaryClass);\n\n  /// Process the specified property declaration and create decls for the\n  /// setters and getters as needed.\n  /// \\param property The property declaration being processed\n  void ProcessPropertyDecl(ObjCPropertyDecl *property);\n\n\n  void DiagnosePropertyMismatch(ObjCPropertyDecl *Property,\n                                ObjCPropertyDecl *SuperProperty,\n                                const IdentifierInfo *Name,\n                                bool OverridingProtocolProperty);\n\n  void DiagnoseClassExtensionDupMethods(ObjCCategoryDecl *CAT,\n                                        ObjCInterfaceDecl *ID);\n\n  Decl *ActOnAtEnd(Scope *S, SourceRange AtEnd,\n                   ArrayRef<Decl *> allMethods = None,\n                   ArrayRef<DeclGroupPtrTy> allTUVars = None);\n\n  Decl *ActOnProperty(Scope *S, SourceLocation AtLoc,\n                      SourceLocation LParenLoc,\n                      FieldDeclarator &FD, ObjCDeclSpec &ODS,\n                      Selector GetterSel, Selector SetterSel,\n                      tok::ObjCKeywordKind MethodImplKind,\n                      DeclContext *lexicalDC = nullptr);\n\n  Decl *ActOnPropertyImplDecl(Scope *S,\n                              SourceLocation AtLoc,\n                              SourceLocation PropertyLoc,\n                              bool ImplKind,\n                              IdentifierInfo *PropertyId,\n                              IdentifierInfo *PropertyIvar,\n                              SourceLocation PropertyIvarLoc,\n                              ObjCPropertyQueryKind QueryKind);\n\n  enum ObjCSpecialMethodKind {\n    OSMK_None,\n    OSMK_Alloc,\n    OSMK_New,\n    OSMK_Copy,\n    OSMK_RetainingInit,\n    OSMK_NonRetainingInit\n  };\n\n  struct ObjCArgInfo {\n    IdentifierInfo *Name;\n    SourceLocation NameLoc;\n    // The Type is null if no type was specified, and the DeclSpec is invalid\n    // in this case.\n    ParsedType Type;\n    ObjCDeclSpec DeclSpec;\n\n    /// ArgAttrs - Attribute list for this argument.\n    ParsedAttributesView ArgAttrs;\n  };\n\n  Decl *ActOnMethodDeclaration(\n      Scope *S,\n      SourceLocation BeginLoc, // location of the + or -.\n      SourceLocation EndLoc,   // location of the ; or {.\n      tok::TokenKind MethodType, ObjCDeclSpec &ReturnQT, ParsedType ReturnType,\n      ArrayRef<SourceLocation> SelectorLocs, Selector Sel,\n      // optional arguments. The number of types/arguments is obtained\n      // from the Sel.getNumArgs().\n      ObjCArgInfo *ArgInfo, DeclaratorChunk::ParamInfo *CParamInfo,\n      unsigned CNumArgs, // c-style args\n      const ParsedAttributesView &AttrList, tok::ObjCKeywordKind MethodImplKind,\n      bool isVariadic, bool MethodDefinition);\n\n  ObjCMethodDecl *LookupMethodInQualifiedType(Selector Sel,\n                                              const ObjCObjectPointerType *OPT,\n                                              bool IsInstance);\n  ObjCMethodDecl *LookupMethodInObjectType(Selector Sel, QualType Ty,\n                                           bool IsInstance);\n\n  bool CheckARCMethodDecl(ObjCMethodDecl *method);\n  bool inferObjCARCLifetime(ValueDecl *decl);\n\n  void deduceOpenCLAddressSpace(ValueDecl *decl);\n\n  ExprResult\n  HandleExprPropertyRefExpr(const ObjCObjectPointerType *OPT,\n                            Expr *BaseExpr,\n                            SourceLocation OpLoc,\n                            DeclarationName MemberName,\n                            SourceLocation MemberLoc,\n                            SourceLocation SuperLoc, QualType SuperType,\n                            bool Super);\n\n  ExprResult\n  ActOnClassPropertyRefExpr(IdentifierInfo &receiverName,\n                            IdentifierInfo &propertyName,\n                            SourceLocation receiverNameLoc,\n                            SourceLocation propertyNameLoc);\n\n  ObjCMethodDecl *tryCaptureObjCSelf(SourceLocation Loc);\n\n  /// Describes the kind of message expression indicated by a message\n  /// send that starts with an identifier.\n  enum ObjCMessageKind {\n    /// The message is sent to 'super'.\n    ObjCSuperMessage,\n    /// The message is an instance message.\n    ObjCInstanceMessage,\n    /// The message is a class message, and the identifier is a type\n    /// name.\n    ObjCClassMessage\n  };\n\n  ObjCMessageKind getObjCMessageKind(Scope *S,\n                                     IdentifierInfo *Name,\n                                     SourceLocation NameLoc,\n                                     bool IsSuper,\n                                     bool HasTrailingDot,\n                                     ParsedType &ReceiverType);\n\n  ExprResult ActOnSuperMessage(Scope *S, SourceLocation SuperLoc,\n                               Selector Sel,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args);\n\n  ExprResult BuildClassMessage(TypeSourceInfo *ReceiverTypeInfo,\n                               QualType ReceiverType,\n                               SourceLocation SuperLoc,\n                               Selector Sel,\n                               ObjCMethodDecl *Method,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args,\n                               bool isImplicit = false);\n\n  ExprResult BuildClassMessageImplicit(QualType ReceiverType,\n                                       bool isSuperReceiver,\n                                       SourceLocation Loc,\n                                       Selector Sel,\n                                       ObjCMethodDecl *Method,\n                                       MultiExprArg Args);\n\n  ExprResult ActOnClassMessage(Scope *S,\n                               ParsedType Receiver,\n                               Selector Sel,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args);\n\n  ExprResult BuildInstanceMessage(Expr *Receiver,\n                                  QualType ReceiverType,\n                                  SourceLocation SuperLoc,\n                                  Selector Sel,\n                                  ObjCMethodDecl *Method,\n                                  SourceLocation LBracLoc,\n                                  ArrayRef<SourceLocation> SelectorLocs,\n                                  SourceLocation RBracLoc,\n                                  MultiExprArg Args,\n                                  bool isImplicit = false);\n\n  ExprResult BuildInstanceMessageImplicit(Expr *Receiver,\n                                          QualType ReceiverType,\n                                          SourceLocation Loc,\n                                          Selector Sel,\n                                          ObjCMethodDecl *Method,\n                                          MultiExprArg Args);\n\n  ExprResult ActOnInstanceMessage(Scope *S,\n                                  Expr *Receiver,\n                                  Selector Sel,\n                                  SourceLocation LBracLoc,\n                                  ArrayRef<SourceLocation> SelectorLocs,\n                                  SourceLocation RBracLoc,\n                                  MultiExprArg Args);\n\n  ExprResult BuildObjCBridgedCast(SourceLocation LParenLoc,\n                                  ObjCBridgeCastKind Kind,\n                                  SourceLocation BridgeKeywordLoc,\n                                  TypeSourceInfo *TSInfo,\n                                  Expr *SubExpr);\n\n  ExprResult ActOnObjCBridgedCast(Scope *S,\n                                  SourceLocation LParenLoc,\n                                  ObjCBridgeCastKind Kind,\n                                  SourceLocation BridgeKeywordLoc,\n                                  ParsedType Type,\n                                  SourceLocation RParenLoc,\n                                  Expr *SubExpr);\n\n  void CheckTollFreeBridgeCast(QualType castType, Expr *castExpr);\n\n  void CheckObjCBridgeRelatedCast(QualType castType, Expr *castExpr);\n\n  bool CheckTollFreeBridgeStaticCast(QualType castType, Expr *castExpr,\n                                     CastKind &Kind);\n\n  bool checkObjCBridgeRelatedComponents(SourceLocation Loc,\n                                        QualType DestType, QualType SrcType,\n                                        ObjCInterfaceDecl *&RelatedClass,\n                                        ObjCMethodDecl *&ClassMethod,\n                                        ObjCMethodDecl *&InstanceMethod,\n                                        TypedefNameDecl *&TDNDecl,\n                                        bool CfToNs, bool Diagnose = true);\n\n  bool CheckObjCBridgeRelatedConversions(SourceLocation Loc,\n                                         QualType DestType, QualType SrcType,\n                                         Expr *&SrcExpr, bool Diagnose = true);\n\n  bool CheckConversionToObjCLiteral(QualType DstType, Expr *&SrcExpr,\n                                    bool Diagnose = true);\n\n  bool checkInitMethod(ObjCMethodDecl *method, QualType receiverTypeIfCall);\n\n  /// Check whether the given new method is a valid override of the\n  /// given overridden method, and set any properties that should be inherited.\n  void CheckObjCMethodOverride(ObjCMethodDecl *NewMethod,\n                               const ObjCMethodDecl *Overridden);\n\n  /// Describes the compatibility of a result type with its method.\n  enum ResultTypeCompatibilityKind {\n    RTC_Compatible,\n    RTC_Incompatible,\n    RTC_Unknown\n  };\n\n  void CheckObjCMethodDirectOverrides(ObjCMethodDecl *method,\n                                      ObjCMethodDecl *overridden);\n\n  void CheckObjCMethodOverrides(ObjCMethodDecl *ObjCMethod,\n                                ObjCInterfaceDecl *CurrentClass,\n                                ResultTypeCompatibilityKind RTC);\n\n  enum PragmaOptionsAlignKind {\n    POAK_Native,  // #pragma options align=native\n    POAK_Natural, // #pragma options align=natural\n    POAK_Packed,  // #pragma options align=packed\n    POAK_Power,   // #pragma options align=power\n    POAK_Mac68k,  // #pragma options align=mac68k\n    POAK_Reset    // #pragma options align=reset\n  };\n\n  /// ActOnPragmaClangSection - Called on well formed \\#pragma clang section\n  void ActOnPragmaClangSection(SourceLocation PragmaLoc,\n                               PragmaClangSectionAction Action,\n                               PragmaClangSectionKind SecKind, StringRef SecName);\n\n  /// ActOnPragmaOptionsAlign - Called on well formed \\#pragma options align.\n  void ActOnPragmaOptionsAlign(PragmaOptionsAlignKind Kind,\n                               SourceLocation PragmaLoc);\n\n  /// ActOnPragmaPack - Called on well formed \\#pragma pack(...).\n  void ActOnPragmaPack(SourceLocation PragmaLoc, PragmaMsStackAction Action,\n                       StringRef SlotLabel, Expr *Alignment);\n\n  enum class PragmaAlignPackDiagnoseKind {\n    NonDefaultStateAtInclude,\n    ChangedStateAtExit\n  };\n\n  void DiagnoseNonDefaultPragmaAlignPack(PragmaAlignPackDiagnoseKind Kind,\n                                         SourceLocation IncludeLoc);\n  void DiagnoseUnterminatedPragmaAlignPack();\n\n  /// ActOnPragmaMSStruct - Called on well formed \\#pragma ms_struct [on|off].\n  void ActOnPragmaMSStruct(PragmaMSStructKind Kind);\n\n  /// ActOnPragmaMSComment - Called on well formed\n  /// \\#pragma comment(kind, \"arg\").\n  void ActOnPragmaMSComment(SourceLocation CommentLoc, PragmaMSCommentKind Kind,\n                            StringRef Arg);\n\n  /// ActOnPragmaMSPointersToMembers - called on well formed \\#pragma\n  /// pointers_to_members(representation method[, general purpose\n  /// representation]).\n  void ActOnPragmaMSPointersToMembers(\n      LangOptions::PragmaMSPointersToMembersKind Kind,\n      SourceLocation PragmaLoc);\n\n  /// Called on well formed \\#pragma vtordisp().\n  void ActOnPragmaMSVtorDisp(PragmaMsStackAction Action,\n                             SourceLocation PragmaLoc,\n                             MSVtorDispMode Value);\n\n  enum PragmaSectionKind {\n    PSK_DataSeg,\n    PSK_BSSSeg,\n    PSK_ConstSeg,\n    PSK_CodeSeg,\n  };\n\n  bool UnifySection(StringRef SectionName, int SectionFlags,\n                    NamedDecl *TheDecl);\n  bool UnifySection(StringRef SectionName,\n                    int SectionFlags,\n                    SourceLocation PragmaSectionLocation);\n\n  /// Called on well formed \\#pragma bss_seg/data_seg/const_seg/code_seg.\n  void ActOnPragmaMSSeg(SourceLocation PragmaLocation,\n                        PragmaMsStackAction Action,\n                        llvm::StringRef StackSlotLabel,\n                        StringLiteral *SegmentName,\n                        llvm::StringRef PragmaName);\n\n  /// Called on well formed \\#pragma section().\n  void ActOnPragmaMSSection(SourceLocation PragmaLocation,\n                            int SectionFlags, StringLiteral *SegmentName);\n\n  /// Called on well-formed \\#pragma init_seg().\n  void ActOnPragmaMSInitSeg(SourceLocation PragmaLocation,\n                            StringLiteral *SegmentName);\n\n  /// Called on #pragma clang __debug dump II\n  void ActOnPragmaDump(Scope *S, SourceLocation Loc, IdentifierInfo *II);\n\n  /// ActOnPragmaDetectMismatch - Call on well-formed \\#pragma detect_mismatch\n  void ActOnPragmaDetectMismatch(SourceLocation Loc, StringRef Name,\n                                 StringRef Value);\n\n  /// Are precise floating point semantics currently enabled?\n  bool isPreciseFPEnabled() {\n    return !CurFPFeatures.getAllowFPReassociate() &&\n           !CurFPFeatures.getNoSignedZero() &&\n           !CurFPFeatures.getAllowReciprocal() &&\n           !CurFPFeatures.getAllowApproxFunc();\n  }\n\n  /// ActOnPragmaFloatControl - Call on well-formed \\#pragma float_control\n  void ActOnPragmaFloatControl(SourceLocation Loc, PragmaMsStackAction Action,\n                               PragmaFloatControlKind Value);\n\n  /// ActOnPragmaUnused - Called on well-formed '\\#pragma unused'.\n  void ActOnPragmaUnused(const Token &Identifier,\n                         Scope *curScope,\n                         SourceLocation PragmaLoc);\n\n  /// ActOnPragmaVisibility - Called on well formed \\#pragma GCC visibility... .\n  void ActOnPragmaVisibility(const IdentifierInfo* VisType,\n                             SourceLocation PragmaLoc);\n\n  NamedDecl *DeclClonePragmaWeak(NamedDecl *ND, IdentifierInfo *II,\n                                 SourceLocation Loc);\n  void DeclApplyPragmaWeak(Scope *S, NamedDecl *ND, WeakInfo &W);\n\n  /// ActOnPragmaWeakID - Called on well formed \\#pragma weak ident.\n  void ActOnPragmaWeakID(IdentifierInfo* WeakName,\n                         SourceLocation PragmaLoc,\n                         SourceLocation WeakNameLoc);\n\n  /// ActOnPragmaRedefineExtname - Called on well formed\n  /// \\#pragma redefine_extname oldname newname.\n  void ActOnPragmaRedefineExtname(IdentifierInfo* WeakName,\n                                  IdentifierInfo* AliasName,\n                                  SourceLocation PragmaLoc,\n                                  SourceLocation WeakNameLoc,\n                                  SourceLocation AliasNameLoc);\n\n  /// ActOnPragmaWeakAlias - Called on well formed \\#pragma weak ident = ident.\n  void ActOnPragmaWeakAlias(IdentifierInfo* WeakName,\n                            IdentifierInfo* AliasName,\n                            SourceLocation PragmaLoc,\n                            SourceLocation WeakNameLoc,\n                            SourceLocation AliasNameLoc);\n\n  /// ActOnPragmaFPContract - Called on well formed\n  /// \\#pragma {STDC,OPENCL} FP_CONTRACT and\n  /// \\#pragma clang fp contract\n  void ActOnPragmaFPContract(SourceLocation Loc, LangOptions::FPModeKind FPC);\n\n  /// Called on well formed\n  /// \\#pragma clang fp reassociate\n  void ActOnPragmaFPReassociate(SourceLocation Loc, bool IsEnabled);\n\n  /// ActOnPragmaFenvAccess - Called on well formed\n  /// \\#pragma STDC FENV_ACCESS\n  void ActOnPragmaFEnvAccess(SourceLocation Loc, bool IsEnabled);\n\n  /// Called on well formed '\\#pragma clang fp' that has option 'exceptions'.\n  void ActOnPragmaFPExceptions(SourceLocation Loc,\n                               LangOptions::FPExceptionModeKind);\n\n  /// Called to set constant rounding mode for floating point operations.\n  void setRoundingMode(SourceLocation Loc, llvm::RoundingMode);\n\n  /// Called to set exception behavior for floating point operations.\n  void setExceptionMode(SourceLocation Loc, LangOptions::FPExceptionModeKind);\n\n  /// AddAlignmentAttributesForRecord - Adds any needed alignment attributes to\n  /// a the record decl, to handle '\\#pragma pack' and '\\#pragma options align'.\n  void AddAlignmentAttributesForRecord(RecordDecl *RD);\n\n  /// AddMsStructLayoutForRecord - Adds ms_struct layout attribute to record.\n  void AddMsStructLayoutForRecord(RecordDecl *RD);\n\n  /// PushNamespaceVisibilityAttr - Note that we've entered a\n  /// namespace with a visibility attribute.\n  void PushNamespaceVisibilityAttr(const VisibilityAttr *Attr,\n                                   SourceLocation Loc);\n\n  /// AddPushedVisibilityAttribute - If '\\#pragma GCC visibility' was used,\n  /// add an appropriate visibility attribute.\n  void AddPushedVisibilityAttribute(Decl *RD);\n\n  /// PopPragmaVisibility - Pop the top element of the visibility stack; used\n  /// for '\\#pragma GCC visibility' and visibility attributes on namespaces.\n  void PopPragmaVisibility(bool IsNamespaceEnd, SourceLocation EndLoc);\n\n  /// FreeVisContext - Deallocate and null out VisContext.\n  void FreeVisContext();\n\n  /// AddCFAuditedAttribute - Check whether we're currently within\n  /// '\\#pragma clang arc_cf_code_audited' and, if so, consider adding\n  /// the appropriate attribute.\n  void AddCFAuditedAttribute(Decl *D);\n\n  void ActOnPragmaAttributeAttribute(ParsedAttr &Attribute,\n                                     SourceLocation PragmaLoc,\n                                     attr::ParsedSubjectMatchRuleSet Rules);\n  void ActOnPragmaAttributeEmptyPush(SourceLocation PragmaLoc,\n                                     const IdentifierInfo *Namespace);\n\n  /// Called on well-formed '\\#pragma clang attribute pop'.\n  void ActOnPragmaAttributePop(SourceLocation PragmaLoc,\n                               const IdentifierInfo *Namespace);\n\n  /// Adds the attributes that have been specified using the\n  /// '\\#pragma clang attribute push' directives to the given declaration.\n  void AddPragmaAttributes(Scope *S, Decl *D);\n\n  void DiagnoseUnterminatedPragmaAttribute();\n\n  /// Called on well formed \\#pragma clang optimize.\n  void ActOnPragmaOptimize(bool On, SourceLocation PragmaLoc);\n\n  /// Get the location for the currently active \"\\#pragma clang optimize\n  /// off\". If this location is invalid, then the state of the pragma is \"on\".\n  SourceLocation getOptimizeOffPragmaLocation() const {\n    return OptimizeOffPragmaLocation;\n  }\n\n  /// Only called on function definitions; if there is a pragma in scope\n  /// with the effect of a range-based optnone, consider marking the function\n  /// with attribute optnone.\n  void AddRangeBasedOptnone(FunctionDecl *FD);\n\n  /// Adds the 'optnone' attribute to the function declaration if there\n  /// are no conflicts; Loc represents the location causing the 'optnone'\n  /// attribute to be added (usually because of a pragma).\n  void AddOptnoneAttributeIfNoConflicts(FunctionDecl *FD, SourceLocation Loc);\n\n  /// AddAlignedAttr - Adds an aligned attribute to a particular declaration.\n  void AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                      bool IsPackExpansion);\n  void AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, TypeSourceInfo *T,\n                      bool IsPackExpansion);\n\n  /// AddAssumeAlignedAttr - Adds an assume_aligned attribute to a particular\n  /// declaration.\n  void AddAssumeAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                            Expr *OE);\n\n  /// AddAllocAlignAttr - Adds an alloc_align attribute to a particular\n  /// declaration.\n  void AddAllocAlignAttr(Decl *D, const AttributeCommonInfo &CI,\n                         Expr *ParamExpr);\n\n  /// AddAlignValueAttr - Adds an align_value attribute to a particular\n  /// declaration.\n  void AddAlignValueAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E);\n\n  /// AddAnnotationAttr - Adds an annotation Annot with Args arguments to D.\n  void AddAnnotationAttr(Decl *D, const AttributeCommonInfo &CI,\n                         StringRef Annot, MutableArrayRef<Expr *> Args);\n\n  /// AddLaunchBoundsAttr - Adds a launch_bounds attribute to a particular\n  /// declaration.\n  void AddLaunchBoundsAttr(Decl *D, const AttributeCommonInfo &CI,\n                           Expr *MaxThreads, Expr *MinBlocks);\n\n  /// AddModeAttr - Adds a mode attribute to a particular declaration.\n  void AddModeAttr(Decl *D, const AttributeCommonInfo &CI, IdentifierInfo *Name,\n                   bool InInstantiation = false);\n\n  void AddParameterABIAttr(Decl *D, const AttributeCommonInfo &CI,\n                           ParameterABI ABI);\n\n  enum class RetainOwnershipKind {NS, CF, OS};\n  void AddXConsumedAttr(Decl *D, const AttributeCommonInfo &CI,\n                        RetainOwnershipKind K, bool IsTemplateInstantiation);\n\n  /// addAMDGPUFlatWorkGroupSizeAttr - Adds an amdgpu_flat_work_group_size\n  /// attribute to a particular declaration.\n  void addAMDGPUFlatWorkGroupSizeAttr(Decl *D, const AttributeCommonInfo &CI,\n                                      Expr *Min, Expr *Max);\n\n  /// addAMDGPUWavePersEUAttr - Adds an amdgpu_waves_per_eu attribute to a\n  /// particular declaration.\n  void addAMDGPUWavesPerEUAttr(Decl *D, const AttributeCommonInfo &CI,\n                               Expr *Min, Expr *Max);\n\n  bool checkNSReturnsRetainedReturnType(SourceLocation loc, QualType type);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Coroutines TS\n  //\n  bool ActOnCoroutineBodyStart(Scope *S, SourceLocation KwLoc,\n                               StringRef Keyword);\n  ExprResult ActOnCoawaitExpr(Scope *S, SourceLocation KwLoc, Expr *E);\n  ExprResult ActOnCoyieldExpr(Scope *S, SourceLocation KwLoc, Expr *E);\n  StmtResult ActOnCoreturnStmt(Scope *S, SourceLocation KwLoc, Expr *E);\n\n  ExprResult BuildResolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,\n                                      bool IsImplicit = false);\n  ExprResult BuildUnresolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,\n                                        UnresolvedLookupExpr* Lookup);\n  ExprResult BuildCoyieldExpr(SourceLocation KwLoc, Expr *E);\n  StmtResult BuildCoreturnStmt(SourceLocation KwLoc, Expr *E,\n                               bool IsImplicit = false);\n  StmtResult BuildCoroutineBodyStmt(CoroutineBodyStmt::CtorArgs);\n  bool buildCoroutineParameterMoves(SourceLocation Loc);\n  VarDecl *buildCoroutinePromise(SourceLocation Loc);\n  void CheckCompletedCoroutineBody(FunctionDecl *FD, Stmt *&Body);\n  ClassTemplateDecl *lookupCoroutineTraits(SourceLocation KwLoc,\n                                           SourceLocation FuncLoc);\n  /// Check that the expression co_await promise.final_suspend() shall not be\n  /// potentially-throwing.\n  bool checkFinalSuspendNoThrow(const Stmt *FinalSuspend);\n\n  //===--------------------------------------------------------------------===//\n  // OpenCL extensions.\n  //\nprivate:\n  std::string CurrOpenCLExtension;\n  /// Extensions required by an OpenCL type.\n  llvm::DenseMap<const Type*, std::set<std::string>> OpenCLTypeExtMap;\n  /// Extensions required by an OpenCL declaration.\n  llvm::DenseMap<const Decl*, std::set<std::string>> OpenCLDeclExtMap;\npublic:\n  llvm::StringRef getCurrentOpenCLExtension() const {\n    return CurrOpenCLExtension;\n  }\n\n  /// Check if a function declaration \\p FD associates with any\n  /// extensions present in OpenCLDeclExtMap and if so return the\n  /// extension(s) name(s).\n  std::string getOpenCLExtensionsFromDeclExtMap(FunctionDecl *FD);\n\n  /// Check if a function type \\p FT associates with any\n  /// extensions present in OpenCLTypeExtMap and if so return the\n  /// extension(s) name(s).\n  std::string getOpenCLExtensionsFromTypeExtMap(FunctionType *FT);\n\n  /// Find an extension in an appropriate extension map and return its name\n  template<typename T, typename MapT>\n  std::string getOpenCLExtensionsFromExtMap(T* FT, MapT &Map);\n\n  void setCurrentOpenCLExtension(llvm::StringRef Ext) {\n    CurrOpenCLExtension = std::string(Ext);\n  }\n\n  /// Set OpenCL extensions for a type which can only be used when these\n  /// OpenCL extensions are enabled. If \\p Exts is empty, do nothing.\n  /// \\param Exts A space separated list of OpenCL extensions.\n  void setOpenCLExtensionForType(QualType T, llvm::StringRef Exts);\n\n  /// Set OpenCL extensions for a declaration which can only be\n  /// used when these OpenCL extensions are enabled. If \\p Exts is empty, do\n  /// nothing.\n  /// \\param Exts A space separated list of OpenCL extensions.\n  void setOpenCLExtensionForDecl(Decl *FD, llvm::StringRef Exts);\n\n  /// Set current OpenCL extensions for a type which can only be used\n  /// when these OpenCL extensions are enabled. If current OpenCL extension is\n  /// empty, do nothing.\n  void setCurrentOpenCLExtensionForType(QualType T);\n\n  /// Set current OpenCL extensions for a declaration which\n  /// can only be used when these OpenCL extensions are enabled. If current\n  /// OpenCL extension is empty, do nothing.\n  void setCurrentOpenCLExtensionForDecl(Decl *FD);\n\n  bool isOpenCLDisabledDecl(Decl *FD);\n\n  /// Check if type \\p T corresponding to declaration specifier \\p DS\n  /// is disabled due to required OpenCL extensions being disabled. If so,\n  /// emit diagnostics.\n  /// \\return true if type is disabled.\n  bool checkOpenCLDisabledTypeDeclSpec(const DeclSpec &DS, QualType T);\n\n  /// Check if declaration \\p D used by expression \\p E\n  /// is disabled due to required OpenCL extensions being disabled. If so,\n  /// emit diagnostics.\n  /// \\return true if type is disabled.\n  bool checkOpenCLDisabledDecl(const NamedDecl &D, const Expr &E);\n\n  //===--------------------------------------------------------------------===//\n  // OpenMP directives and clauses.\n  //\nprivate:\n  void *VarDataSharingAttributesStack;\n  /// Number of nested '#pragma omp declare target' directives.\n  SmallVector<SourceLocation, 4> DeclareTargetNesting;\n  /// Initialization of data-sharing attributes stack.\n  void InitDataSharingAttributesStack();\n  void DestroyDataSharingAttributesStack();\n  ExprResult\n  VerifyPositiveIntegerConstantInClause(Expr *Op, OpenMPClauseKind CKind,\n                                        bool StrictlyPositive = true);\n  /// Returns OpenMP nesting level for current directive.\n  unsigned getOpenMPNestingLevel() const;\n\n  /// Adjusts the function scopes index for the target-based regions.\n  void adjustOpenMPTargetScopeIndex(unsigned &FunctionScopesIndex,\n                                    unsigned Level) const;\n\n  /// Returns the number of scopes associated with the construct on the given\n  /// OpenMP level.\n  int getNumberOfConstructScopes(unsigned Level) const;\n\n  /// Push new OpenMP function region for non-capturing function.\n  void pushOpenMPFunctionRegion();\n\n  /// Pop OpenMP function region for non-capturing function.\n  void popOpenMPFunctionRegion(const sema::FunctionScopeInfo *OldFSI);\n\n  /// Checks if a type or a declaration is disabled due to the owning extension\n  /// being disabled, and emits diagnostic messages if it is disabled.\n  /// \\param D type or declaration to be checked.\n  /// \\param DiagLoc source location for the diagnostic message.\n  /// \\param DiagInfo information to be emitted for the diagnostic message.\n  /// \\param SrcRange source range of the declaration.\n  /// \\param Map maps type or declaration to the extensions.\n  /// \\param Selector selects diagnostic message: 0 for type and 1 for\n  ///        declaration.\n  /// \\return true if the type or declaration is disabled.\n  template <typename T, typename DiagLocT, typename DiagInfoT, typename MapT>\n  bool checkOpenCLDisabledTypeOrDecl(T D, DiagLocT DiagLoc, DiagInfoT DiagInfo,\n                                     MapT &Map, unsigned Selector = 0,\n                                     SourceRange SrcRange = SourceRange());\n\n  /// Helper to keep information about the current `omp begin/end declare\n  /// variant` nesting.\n  struct OMPDeclareVariantScope {\n    /// The associated OpenMP context selector.\n    OMPTraitInfo *TI;\n\n    /// The associated OpenMP context selector mangling.\n    std::string NameSuffix;\n\n    OMPDeclareVariantScope(OMPTraitInfo &TI);\n  };\n\n  /// Return the OMPTraitInfo for the surrounding scope, if any.\n  OMPTraitInfo *getOMPTraitInfoForSurroundingScope() {\n    return OMPDeclareVariantScopes.empty() ? nullptr\n                                           : OMPDeclareVariantScopes.back().TI;\n  }\n\n  /// The current `omp begin/end declare variant` scopes.\n  SmallVector<OMPDeclareVariantScope, 4> OMPDeclareVariantScopes;\n\n  /// The current `omp begin/end assumes` scopes.\n  SmallVector<AssumptionAttr *, 4> OMPAssumeScoped;\n\n  /// All `omp assumes` we encountered so far.\n  SmallVector<AssumptionAttr *, 4> OMPAssumeGlobal;\n\npublic:\n  /// The declarator \\p D defines a function in the scope \\p S which is nested\n  /// in an `omp begin/end declare variant` scope. In this method we create a\n  /// declaration for \\p D and rename \\p D according to the OpenMP context\n  /// selector of the surrounding scope. Return all base functions in \\p Bases.\n  void ActOnStartOfFunctionDefinitionInOpenMPDeclareVariantScope(\n      Scope *S, Declarator &D, MultiTemplateParamsArg TemplateParameterLists,\n      SmallVectorImpl<FunctionDecl *> &Bases);\n\n  /// Register \\p D as specialization of all base functions in \\p Bases in the\n  /// current `omp begin/end declare variant` scope.\n  void ActOnFinishedFunctionDefinitionInOpenMPDeclareVariantScope(\n      Decl *D, SmallVectorImpl<FunctionDecl *> &Bases);\n\n  /// Act on \\p D, a function definition inside of an `omp [begin/end] assumes`.\n  void ActOnFinishedFunctionDefinitionInOpenMPAssumeScope(Decl *D);\n\n  /// Can we exit an OpenMP declare variant scope at the moment.\n  bool isInOpenMPDeclareVariantScope() const {\n    return !OMPDeclareVariantScopes.empty();\n  }\n\n  /// Given the potential call expression \\p Call, determine if there is a\n  /// specialization via the OpenMP declare variant mechanism available. If\n  /// there is, return the specialized call expression, otherwise return the\n  /// original \\p Call.\n  ExprResult ActOnOpenMPCall(ExprResult Call, Scope *Scope,\n                             SourceLocation LParenLoc, MultiExprArg ArgExprs,\n                             SourceLocation RParenLoc, Expr *ExecConfig);\n\n  /// Handle a `omp begin declare variant`.\n  void ActOnOpenMPBeginDeclareVariant(SourceLocation Loc, OMPTraitInfo &TI);\n\n  /// Handle a `omp end declare variant`.\n  void ActOnOpenMPEndDeclareVariant();\n\n  /// Checks if the variant/multiversion functions are compatible.\n  bool areMultiversionVariantFunctionsCompatible(\n      const FunctionDecl *OldFD, const FunctionDecl *NewFD,\n      const PartialDiagnostic &NoProtoDiagID,\n      const PartialDiagnosticAt &NoteCausedDiagIDAt,\n      const PartialDiagnosticAt &NoSupportDiagIDAt,\n      const PartialDiagnosticAt &DiffDiagIDAt, bool TemplatesSupported,\n      bool ConstexprSupported, bool CLinkageMayDiffer);\n\n  /// Function tries to capture lambda's captured variables in the OpenMP region\n  /// before the original lambda is captured.\n  void tryCaptureOpenMPLambdas(ValueDecl *V);\n\n  /// Return true if the provided declaration \\a VD should be captured by\n  /// reference.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  /// \\param OpenMPCaptureLevel Capture level within an OpenMP construct.\n  bool isOpenMPCapturedByRef(const ValueDecl *D, unsigned Level,\n                             unsigned OpenMPCaptureLevel) const;\n\n  /// Check if the specified variable is used in one of the private\n  /// clauses (private, firstprivate, lastprivate, reduction etc.) in OpenMP\n  /// constructs.\n  VarDecl *isOpenMPCapturedDecl(ValueDecl *D, bool CheckScopeInfo = false,\n                                unsigned StopAt = 0);\n  ExprResult getOpenMPCapturedExpr(VarDecl *Capture, ExprValueKind VK,\n                                   ExprObjectKind OK, SourceLocation Loc);\n\n  /// If the current region is a loop-based region, mark the start of the loop\n  /// construct.\n  void startOpenMPLoop();\n\n  /// If the current region is a range loop-based region, mark the start of the\n  /// loop construct.\n  void startOpenMPCXXRangeFor();\n\n  /// Check if the specified variable is used in 'private' clause.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  OpenMPClauseKind isOpenMPPrivateDecl(ValueDecl *D, unsigned Level,\n                                       unsigned CapLevel) const;\n\n  /// Sets OpenMP capture kind (OMPC_private, OMPC_firstprivate, OMPC_map etc.)\n  /// for \\p FD based on DSA for the provided corresponding captured declaration\n  /// \\p D.\n  void setOpenMPCaptureKind(FieldDecl *FD, const ValueDecl *D, unsigned Level);\n\n  /// Check if the specified variable is captured  by 'target' directive.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  bool isOpenMPTargetCapturedDecl(const ValueDecl *D, unsigned Level,\n                                  unsigned CaptureLevel) const;\n\n  /// Check if the specified global variable must be captured  by outer capture\n  /// regions.\n  /// \\param Level Relative level of nested OpenMP construct for that\n  /// the check is performed.\n  bool isOpenMPGlobalCapturedDecl(ValueDecl *D, unsigned Level,\n                                  unsigned CaptureLevel) const;\n\n  ExprResult PerformOpenMPImplicitIntegerConversion(SourceLocation OpLoc,\n                                                    Expr *Op);\n  /// Called on start of new data sharing attribute block.\n  void StartOpenMPDSABlock(OpenMPDirectiveKind K,\n                           const DeclarationNameInfo &DirName, Scope *CurScope,\n                           SourceLocation Loc);\n  /// Start analysis of clauses.\n  void StartOpenMPClause(OpenMPClauseKind K);\n  /// End analysis of clauses.\n  void EndOpenMPClause();\n  /// Called on end of data sharing attribute block.\n  void EndOpenMPDSABlock(Stmt *CurDirective);\n\n  /// Check if the current region is an OpenMP loop region and if it is,\n  /// mark loop control variable, used in \\p Init for loop initialization, as\n  /// private by default.\n  /// \\param Init First part of the for loop.\n  void ActOnOpenMPLoopInitialization(SourceLocation ForLoc, Stmt *Init);\n\n  // OpenMP directives and clauses.\n  /// Called on correct id-expression from the '#pragma omp\n  /// threadprivate'.\n  ExprResult ActOnOpenMPIdExpression(Scope *CurScope, CXXScopeSpec &ScopeSpec,\n                                     const DeclarationNameInfo &Id,\n                                     OpenMPDirectiveKind Kind);\n  /// Called on well-formed '#pragma omp threadprivate'.\n  DeclGroupPtrTy ActOnOpenMPThreadprivateDirective(\n                                     SourceLocation Loc,\n                                     ArrayRef<Expr *> VarList);\n  /// Builds a new OpenMPThreadPrivateDecl and checks its correctness.\n  OMPThreadPrivateDecl *CheckOMPThreadPrivateDecl(SourceLocation Loc,\n                                                  ArrayRef<Expr *> VarList);\n  /// Called on well-formed '#pragma omp allocate'.\n  DeclGroupPtrTy ActOnOpenMPAllocateDirective(SourceLocation Loc,\n                                              ArrayRef<Expr *> VarList,\n                                              ArrayRef<OMPClause *> Clauses,\n                                              DeclContext *Owner = nullptr);\n\n  /// Called on well-formed '#pragma omp [begin] assume[s]'.\n  void ActOnOpenMPAssumesDirective(SourceLocation Loc,\n                                   OpenMPDirectiveKind DKind,\n                                   ArrayRef<StringRef> Assumptions,\n                                   bool SkippedClauses);\n\n  /// Check if there is an active global `omp begin assumes` directive.\n  bool isInOpenMPAssumeScope() const { return !OMPAssumeScoped.empty(); }\n\n  /// Check if there is an active global `omp assumes` directive.\n  bool hasGlobalOpenMPAssumes() const { return !OMPAssumeGlobal.empty(); }\n\n  /// Called on well-formed '#pragma omp end assumes'.\n  void ActOnOpenMPEndAssumesDirective();\n\n  /// Called on well-formed '#pragma omp requires'.\n  DeclGroupPtrTy ActOnOpenMPRequiresDirective(SourceLocation Loc,\n                                              ArrayRef<OMPClause *> ClauseList);\n  /// Check restrictions on Requires directive\n  OMPRequiresDecl *CheckOMPRequiresDecl(SourceLocation Loc,\n                                        ArrayRef<OMPClause *> Clauses);\n  /// Check if the specified type is allowed to be used in 'omp declare\n  /// reduction' construct.\n  QualType ActOnOpenMPDeclareReductionType(SourceLocation TyLoc,\n                                           TypeResult ParsedType);\n  /// Called on start of '#pragma omp declare reduction'.\n  DeclGroupPtrTy ActOnOpenMPDeclareReductionDirectiveStart(\n      Scope *S, DeclContext *DC, DeclarationName Name,\n      ArrayRef<std::pair<QualType, SourceLocation>> ReductionTypes,\n      AccessSpecifier AS, Decl *PrevDeclInScope = nullptr);\n  /// Initialize declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionCombinerStart(Scope *S, Decl *D);\n  /// Finish current declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionCombinerEnd(Decl *D, Expr *Combiner);\n  /// Initialize declare reduction construct initializer.\n  /// \\return omp_priv variable.\n  VarDecl *ActOnOpenMPDeclareReductionInitializerStart(Scope *S, Decl *D);\n  /// Finish current declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionInitializerEnd(Decl *D, Expr *Initializer,\n                                                 VarDecl *OmpPrivParm);\n  /// Called at the end of '#pragma omp declare reduction'.\n  DeclGroupPtrTy ActOnOpenMPDeclareReductionDirectiveEnd(\n      Scope *S, DeclGroupPtrTy DeclReductions, bool IsValid);\n\n  /// Check variable declaration in 'omp declare mapper' construct.\n  TypeResult ActOnOpenMPDeclareMapperVarDecl(Scope *S, Declarator &D);\n  /// Check if the specified type is allowed to be used in 'omp declare\n  /// mapper' construct.\n  QualType ActOnOpenMPDeclareMapperType(SourceLocation TyLoc,\n                                        TypeResult ParsedType);\n  /// Called on start of '#pragma omp declare mapper'.\n  DeclGroupPtrTy ActOnOpenMPDeclareMapperDirective(\n      Scope *S, DeclContext *DC, DeclarationName Name, QualType MapperType,\n      SourceLocation StartLoc, DeclarationName VN, AccessSpecifier AS,\n      Expr *MapperVarRef, ArrayRef<OMPClause *> Clauses,\n      Decl *PrevDeclInScope = nullptr);\n  /// Build the mapper variable of '#pragma omp declare mapper'.\n  ExprResult ActOnOpenMPDeclareMapperDirectiveVarDecl(Scope *S,\n                                                      QualType MapperType,\n                                                      SourceLocation StartLoc,\n                                                      DeclarationName VN);\n  bool isOpenMPDeclareMapperVarDeclAllowed(const VarDecl *VD) const;\n  const ValueDecl *getOpenMPDeclareMapperVarName() const;\n\n  /// Called on the start of target region i.e. '#pragma omp declare target'.\n  bool ActOnStartOpenMPDeclareTargetDirective(SourceLocation Loc);\n  /// Called at the end of target region i.e. '#pragme omp end declare target'.\n  void ActOnFinishOpenMPDeclareTargetDirective();\n  /// Searches for the provided declaration name for OpenMP declare target\n  /// directive.\n  NamedDecl *\n  lookupOpenMPDeclareTargetName(Scope *CurScope, CXXScopeSpec &ScopeSpec,\n                                const DeclarationNameInfo &Id,\n                                NamedDeclSetType &SameDirectiveDecls);\n  /// Called on correct id-expression from the '#pragma omp declare target'.\n  void ActOnOpenMPDeclareTargetName(NamedDecl *ND, SourceLocation Loc,\n                                    OMPDeclareTargetDeclAttr::MapTypeTy MT,\n                                    OMPDeclareTargetDeclAttr::DevTypeTy DT);\n  /// Check declaration inside target region.\n  void\n  checkDeclIsAllowedInOpenMPTarget(Expr *E, Decl *D,\n                                   SourceLocation IdLoc = SourceLocation());\n  /// Finishes analysis of the deferred functions calls that may be declared as\n  /// host/nohost during device/host compilation.\n  void finalizeOpenMPDelayedAnalysis(const FunctionDecl *Caller,\n                                     const FunctionDecl *Callee,\n                                     SourceLocation Loc);\n  /// Return true inside OpenMP declare target region.\n  bool isInOpenMPDeclareTargetContext() const {\n    return !DeclareTargetNesting.empty();\n  }\n  /// Return true inside OpenMP target region.\n  bool isInOpenMPTargetExecutionDirective() const;\n\n  /// Return the number of captured regions created for an OpenMP directive.\n  static int getOpenMPCaptureLevels(OpenMPDirectiveKind Kind);\n\n  /// Initialization of captured region for OpenMP region.\n  void ActOnOpenMPRegionStart(OpenMPDirectiveKind DKind, Scope *CurScope);\n\n  /// Called for syntactical loops (ForStmt or CXXForRangeStmt) associated to\n  /// an OpenMP loop directive.\n  StmtResult ActOnOpenMPCanonicalLoop(Stmt *AStmt);\n\n  /// End of OpenMP region.\n  ///\n  /// \\param S Statement associated with the current OpenMP region.\n  /// \\param Clauses List of clauses for the current OpenMP region.\n  ///\n  /// \\returns Statement for finished OpenMP region.\n  StmtResult ActOnOpenMPRegionEnd(StmtResult S, ArrayRef<OMPClause *> Clauses);\n  StmtResult ActOnOpenMPExecutableDirective(\n      OpenMPDirectiveKind Kind, const DeclarationNameInfo &DirName,\n      OpenMPDirectiveKind CancelRegion, ArrayRef<OMPClause *> Clauses,\n      Stmt *AStmt, SourceLocation StartLoc, SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel' after parsing\n  /// of the  associated statement.\n  StmtResult ActOnOpenMPParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt,\n                                          SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  using VarsWithInheritedDSAType =\n      llvm::SmallDenseMap<const ValueDecl *, const Expr *, 4>;\n  /// Called on well-formed '\\#pragma omp simd' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                           SourceLocation StartLoc, SourceLocation EndLoc,\n                           VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '#pragma omp tile' after parsing of its clauses and\n  /// the associated statement.\n  StmtResult ActOnOpenMPTileDirective(ArrayRef<OMPClause *> Clauses,\n                                      Stmt *AStmt, SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp for' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPForDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                          SourceLocation StartLoc, SourceLocation EndLoc,\n                          VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp for simd' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPForSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                              SourceLocation StartLoc, SourceLocation EndLoc,\n                              VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp sections' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp section' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPSectionDirective(Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp single' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPSingleDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp master' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPMasterDirective(Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp critical' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPCriticalDirective(const DeclarationNameInfo &DirName,\n                                          ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel for' after parsing\n  /// of the  associated statement.\n  StmtResult ActOnOpenMPParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel for simd' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelMasterDirective(ArrayRef<OMPClause *> Clauses,\n                                                Stmt *AStmt,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel sections' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                                  Stmt *AStmt,\n                                                  SourceLocation StartLoc,\n                                                  SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp task' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTaskDirective(ArrayRef<OMPClause *> Clauses,\n                                      Stmt *AStmt, SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskyield'.\n  StmtResult ActOnOpenMPTaskyieldDirective(SourceLocation StartLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp barrier'.\n  StmtResult ActOnOpenMPBarrierDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskwait'.\n  StmtResult ActOnOpenMPTaskwaitDirective(SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskgroup'.\n  StmtResult ActOnOpenMPTaskgroupDirective(ArrayRef<OMPClause *> Clauses,\n                                           Stmt *AStmt, SourceLocation StartLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp flush'.\n  StmtResult ActOnOpenMPFlushDirective(ArrayRef<OMPClause *> Clauses,\n                                       SourceLocation StartLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp depobj'.\n  StmtResult ActOnOpenMPDepobjDirective(ArrayRef<OMPClause *> Clauses,\n                                        SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp scan'.\n  StmtResult ActOnOpenMPScanDirective(ArrayRef<OMPClause *> Clauses,\n                                      SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp ordered' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPOrderedDirective(ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp atomic' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPAtomicDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTargetDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target data' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTargetDataDirective(ArrayRef<OMPClause *> Clauses,\n                                            Stmt *AStmt, SourceLocation StartLoc,\n                                            SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target enter data' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetEnterDataDirective(ArrayRef<OMPClause *> Clauses,\n                                                 SourceLocation StartLoc,\n                                                 SourceLocation EndLoc,\n                                                 Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp target exit data' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetExitDataDirective(ArrayRef<OMPClause *> Clauses,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc,\n                                                Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp target parallel' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                                Stmt *AStmt,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target parallel for' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPTargetParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                       Stmt *AStmt, SourceLocation StartLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp cancellation point'.\n  StmtResult\n  ActOnOpenMPCancellationPointDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        OpenMPDirectiveKind CancelRegion);\n  /// Called on well-formed '\\#pragma omp cancel'.\n  StmtResult ActOnOpenMPCancelDirective(ArrayRef<OMPClause *> Clauses,\n                                        SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        OpenMPDirectiveKind CancelRegion);\n  /// Called on well-formed '\\#pragma omp taskloop' after parsing of the\n  /// associated statement.\n  StmtResult\n  ActOnOpenMPTaskLoopDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                               SourceLocation StartLoc, SourceLocation EndLoc,\n                               VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp taskloop simd' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp master taskloop' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPMasterTaskLoopDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp master taskloop simd' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPMasterTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master taskloop' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPParallelMasterTaskLoopDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master taskloop simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPParallelMasterTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPDistributeDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                                 SourceLocation StartLoc, SourceLocation EndLoc,\n                                 VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target update'.\n  StmtResult ActOnOpenMPTargetUpdateDirective(ArrayRef<OMPClause *> Clauses,\n                                              SourceLocation StartLoc,\n                                              SourceLocation EndLoc,\n                                              Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp distribute parallel for' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute parallel for simd'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target parallel for simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target simd' after parsing of\n  /// the associated statement.\n  StmtResult\n  ActOnOpenMPTargetSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                                 SourceLocation StartLoc, SourceLocation EndLoc,\n                                 VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute simd' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute parallel for simd'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute parallel for'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                             Stmt *AStmt,\n                                             SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target teams distribute' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute parallel for'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute parallel for\n  /// simd' after parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n\n  /// Checks correctness of linear modifiers.\n  bool CheckOpenMPLinearModifier(OpenMPLinearClauseKind LinKind,\n                                 SourceLocation LinLoc);\n  /// Checks that the specified declaration matches requirements for the linear\n  /// decls.\n  bool CheckOpenMPLinearDecl(const ValueDecl *D, SourceLocation ELoc,\n                             OpenMPLinearClauseKind LinKind, QualType Type,\n                             bool IsDeclareSimd = false);\n\n  /// Called on well-formed '\\#pragma omp declare simd' after parsing of\n  /// the associated method/function.\n  DeclGroupPtrTy ActOnOpenMPDeclareSimdDirective(\n      DeclGroupPtrTy DG, OMPDeclareSimdDeclAttr::BranchStateTy BS,\n      Expr *Simdlen, ArrayRef<Expr *> Uniforms, ArrayRef<Expr *> Aligneds,\n      ArrayRef<Expr *> Alignments, ArrayRef<Expr *> Linears,\n      ArrayRef<unsigned> LinModifiers, ArrayRef<Expr *> Steps, SourceRange SR);\n\n  /// Checks '\\#pragma omp declare variant' variant function and original\n  /// functions after parsing of the associated method/function.\n  /// \\param DG Function declaration to which declare variant directive is\n  /// applied to.\n  /// \\param VariantRef Expression that references the variant function, which\n  /// must be used instead of the original one, specified in \\p DG.\n  /// \\param TI The trait info object representing the match clause.\n  /// \\returns None, if the function/variant function are not compatible with\n  /// the pragma, pair of original function/variant ref expression otherwise.\n  Optional<std::pair<FunctionDecl *, Expr *>>\n  checkOpenMPDeclareVariantFunction(DeclGroupPtrTy DG, Expr *VariantRef,\n                                    OMPTraitInfo &TI, SourceRange SR);\n\n  /// Called on well-formed '\\#pragma omp declare variant' after parsing of\n  /// the associated method/function.\n  /// \\param FD Function declaration to which declare variant directive is\n  /// applied to.\n  /// \\param VariantRef Expression that references the variant function, which\n  /// must be used instead of the original one, specified in \\p DG.\n  /// \\param TI The context traits associated with the function variant.\n  void ActOnOpenMPDeclareVariantDirective(FunctionDecl *FD, Expr *VariantRef,\n                                          OMPTraitInfo &TI, SourceRange SR);\n\n  OMPClause *ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind,\n                                         Expr *Expr,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed 'allocator' clause.\n  OMPClause *ActOnOpenMPAllocatorClause(Expr *Allocator,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'if' clause.\n  OMPClause *ActOnOpenMPIfClause(OpenMPDirectiveKind NameModifier,\n                                 Expr *Condition, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation NameModifierLoc,\n                                 SourceLocation ColonLoc,\n                                 SourceLocation EndLoc);\n  /// Called on well-formed 'final' clause.\n  OMPClause *ActOnOpenMPFinalClause(Expr *Condition, SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'num_threads' clause.\n  OMPClause *ActOnOpenMPNumThreadsClause(Expr *NumThreads,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed 'safelen' clause.\n  OMPClause *ActOnOpenMPSafelenClause(Expr *Length,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'simdlen' clause.\n  OMPClause *ActOnOpenMPSimdlenClause(Expr *Length, SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-form 'sizes' clause.\n  OMPClause *ActOnOpenMPSizesClause(ArrayRef<Expr *> SizeExprs,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'collapse' clause.\n  OMPClause *ActOnOpenMPCollapseClause(Expr *NumForLoops,\n                                       SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'ordered' clause.\n  OMPClause *\n  ActOnOpenMPOrderedClause(SourceLocation StartLoc, SourceLocation EndLoc,\n                           SourceLocation LParenLoc = SourceLocation(),\n                           Expr *NumForLoops = nullptr);\n  /// Called on well-formed 'grainsize' clause.\n  OMPClause *ActOnOpenMPGrainsizeClause(Expr *Size, SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'num_tasks' clause.\n  OMPClause *ActOnOpenMPNumTasksClause(Expr *NumTasks, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'hint' clause.\n  OMPClause *ActOnOpenMPHintClause(Expr *Hint, SourceLocation StartLoc,\n                                   SourceLocation LParenLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'detach' clause.\n  OMPClause *ActOnOpenMPDetachClause(Expr *Evt, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPSimpleClause(OpenMPClauseKind Kind,\n                                     unsigned Argument,\n                                     SourceLocation ArgumentLoc,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'default' clause.\n  OMPClause *ActOnOpenMPDefaultClause(llvm::omp::DefaultKind Kind,\n                                      SourceLocation KindLoc,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'proc_bind' clause.\n  OMPClause *ActOnOpenMPProcBindClause(llvm::omp::ProcBindKind Kind,\n                                       SourceLocation KindLoc,\n                                       SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'order' clause.\n  OMPClause *ActOnOpenMPOrderClause(OpenMPOrderClauseKind Kind,\n                                    SourceLocation KindLoc,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'update' clause.\n  OMPClause *ActOnOpenMPUpdateClause(OpenMPDependClauseKind Kind,\n                                     SourceLocation KindLoc,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPSingleExprWithArgClause(\n      OpenMPClauseKind Kind, ArrayRef<unsigned> Arguments, Expr *Expr,\n      SourceLocation StartLoc, SourceLocation LParenLoc,\n      ArrayRef<SourceLocation> ArgumentsLoc, SourceLocation DelimLoc,\n      SourceLocation EndLoc);\n  /// Called on well-formed 'schedule' clause.\n  OMPClause *ActOnOpenMPScheduleClause(\n      OpenMPScheduleClauseModifier M1, OpenMPScheduleClauseModifier M2,\n      OpenMPScheduleClauseKind Kind, Expr *ChunkSize, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation M1Loc, SourceLocation M2Loc,\n      SourceLocation KindLoc, SourceLocation CommaLoc, SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPClause(OpenMPClauseKind Kind, SourceLocation StartLoc,\n                               SourceLocation EndLoc);\n  /// Called on well-formed 'nowait' clause.\n  OMPClause *ActOnOpenMPNowaitClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'untied' clause.\n  OMPClause *ActOnOpenMPUntiedClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'mergeable' clause.\n  OMPClause *ActOnOpenMPMergeableClause(SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'read' clause.\n  OMPClause *ActOnOpenMPReadClause(SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'write' clause.\n  OMPClause *ActOnOpenMPWriteClause(SourceLocation StartLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'update' clause.\n  OMPClause *ActOnOpenMPUpdateClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'capture' clause.\n  OMPClause *ActOnOpenMPCaptureClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'seq_cst' clause.\n  OMPClause *ActOnOpenMPSeqCstClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'acq_rel' clause.\n  OMPClause *ActOnOpenMPAcqRelClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'acquire' clause.\n  OMPClause *ActOnOpenMPAcquireClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'release' clause.\n  OMPClause *ActOnOpenMPReleaseClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'relaxed' clause.\n  OMPClause *ActOnOpenMPRelaxedClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'destroy' clause.\n  OMPClause *ActOnOpenMPDestroyClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'threads' clause.\n  OMPClause *ActOnOpenMPThreadsClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'simd' clause.\n  OMPClause *ActOnOpenMPSIMDClause(SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'nogroup' clause.\n  OMPClause *ActOnOpenMPNogroupClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'unified_address' clause.\n  OMPClause *ActOnOpenMPUnifiedAddressClause(SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n\n  /// Called on well-formed 'unified_address' clause.\n  OMPClause *ActOnOpenMPUnifiedSharedMemoryClause(SourceLocation StartLoc,\n                                                  SourceLocation EndLoc);\n\n  /// Called on well-formed 'reverse_offload' clause.\n  OMPClause *ActOnOpenMPReverseOffloadClause(SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n\n  /// Called on well-formed 'dynamic_allocators' clause.\n  OMPClause *ActOnOpenMPDynamicAllocatorsClause(SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n\n  /// Called on well-formed 'atomic_default_mem_order' clause.\n  OMPClause *ActOnOpenMPAtomicDefaultMemOrderClause(\n      OpenMPAtomicDefaultMemOrderClauseKind Kind, SourceLocation KindLoc,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPVarListClause(\n      OpenMPClauseKind Kind, ArrayRef<Expr *> Vars, Expr *DepModOrTailExpr,\n      const OMPVarListLocTy &Locs, SourceLocation ColonLoc,\n      CXXScopeSpec &ReductionOrMapperIdScopeSpec,\n      DeclarationNameInfo &ReductionOrMapperId, int ExtraModifier,\n      ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n      ArrayRef<SourceLocation> MapTypeModifiersLoc, bool IsMapTypeImplicit,\n      SourceLocation ExtraModifierLoc,\n      ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n      ArrayRef<SourceLocation> MotionModifiersLoc);\n  /// Called on well-formed 'inclusive' clause.\n  OMPClause *ActOnOpenMPInclusiveClause(ArrayRef<Expr *> VarList,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'exclusive' clause.\n  OMPClause *ActOnOpenMPExclusiveClause(ArrayRef<Expr *> VarList,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'allocate' clause.\n  OMPClause *\n  ActOnOpenMPAllocateClause(Expr *Allocator, ArrayRef<Expr *> VarList,\n                            SourceLocation StartLoc, SourceLocation ColonLoc,\n                            SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'private' clause.\n  OMPClause *ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'firstprivate' clause.\n  OMPClause *ActOnOpenMPFirstprivateClause(ArrayRef<Expr *> VarList,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed 'lastprivate' clause.\n  OMPClause *ActOnOpenMPLastprivateClause(\n      ArrayRef<Expr *> VarList, OpenMPLastprivateModifier LPKind,\n      SourceLocation LPKindLoc, SourceLocation ColonLoc,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'shared' clause.\n  OMPClause *ActOnOpenMPSharedClause(ArrayRef<Expr *> VarList,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'reduction' clause.\n  OMPClause *ActOnOpenMPReductionClause(\n      ArrayRef<Expr *> VarList, OpenMPReductionClauseModifier Modifier,\n      SourceLocation StartLoc, SourceLocation LParenLoc,\n      SourceLocation ModifierLoc, SourceLocation ColonLoc,\n      SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'task_reduction' clause.\n  OMPClause *ActOnOpenMPTaskReductionClause(\n      ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc,\n      CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'in_reduction' clause.\n  OMPClause *ActOnOpenMPInReductionClause(\n      ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc,\n      CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'linear' clause.\n  OMPClause *\n  ActOnOpenMPLinearClause(ArrayRef<Expr *> VarList, Expr *Step,\n                          SourceLocation StartLoc, SourceLocation LParenLoc,\n                          OpenMPLinearClauseKind LinKind, SourceLocation LinLoc,\n                          SourceLocation ColonLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'aligned' clause.\n  OMPClause *ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList,\n                                      Expr *Alignment,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation ColonLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'copyin' clause.\n  OMPClause *ActOnOpenMPCopyinClause(ArrayRef<Expr *> VarList,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'copyprivate' clause.\n  OMPClause *ActOnOpenMPCopyprivateClause(ArrayRef<Expr *> VarList,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed 'flush' pseudo clause.\n  OMPClause *ActOnOpenMPFlushClause(ArrayRef<Expr *> VarList,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'depobj' pseudo clause.\n  OMPClause *ActOnOpenMPDepobjClause(Expr *Depobj, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'depend' clause.\n  OMPClause *\n  ActOnOpenMPDependClause(Expr *DepModifier, OpenMPDependClauseKind DepKind,\n                          SourceLocation DepLoc, SourceLocation ColonLoc,\n                          ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n                          SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'device' clause.\n  OMPClause *ActOnOpenMPDeviceClause(OpenMPDeviceClauseModifier Modifier,\n                                     Expr *Device, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation ModifierLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'map' clause.\n  OMPClause *\n  ActOnOpenMPMapClause(ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n                       ArrayRef<SourceLocation> MapTypeModifiersLoc,\n                       CXXScopeSpec &MapperIdScopeSpec,\n                       DeclarationNameInfo &MapperId,\n                       OpenMPMapClauseKind MapType, bool IsMapTypeImplicit,\n                       SourceLocation MapLoc, SourceLocation ColonLoc,\n                       ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                       ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'num_teams' clause.\n  OMPClause *ActOnOpenMPNumTeamsClause(Expr *NumTeams, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'thread_limit' clause.\n  OMPClause *ActOnOpenMPThreadLimitClause(Expr *ThreadLimit,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed 'priority' clause.\n  OMPClause *ActOnOpenMPPriorityClause(Expr *Priority, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'dist_schedule' clause.\n  OMPClause *ActOnOpenMPDistScheduleClause(\n      OpenMPDistScheduleClauseKind Kind, Expr *ChunkSize,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation KindLoc,\n      SourceLocation CommaLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'defaultmap' clause.\n  OMPClause *ActOnOpenMPDefaultmapClause(\n      OpenMPDefaultmapClauseModifier M, OpenMPDefaultmapClauseKind Kind,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation MLoc,\n      SourceLocation KindLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'to' clause.\n  OMPClause *\n  ActOnOpenMPToClause(ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                      ArrayRef<SourceLocation> MotionModifiersLoc,\n                      CXXScopeSpec &MapperIdScopeSpec,\n                      DeclarationNameInfo &MapperId, SourceLocation ColonLoc,\n                      ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                      ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'from' clause.\n  OMPClause *\n  ActOnOpenMPFromClause(ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                        ArrayRef<SourceLocation> MotionModifiersLoc,\n                        CXXScopeSpec &MapperIdScopeSpec,\n                        DeclarationNameInfo &MapperId, SourceLocation ColonLoc,\n                        ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                        ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'use_device_ptr' clause.\n  OMPClause *ActOnOpenMPUseDevicePtrClause(ArrayRef<Expr *> VarList,\n                                           const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'use_device_addr' clause.\n  OMPClause *ActOnOpenMPUseDeviceAddrClause(ArrayRef<Expr *> VarList,\n                                            const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'is_device_ptr' clause.\n  OMPClause *ActOnOpenMPIsDevicePtrClause(ArrayRef<Expr *> VarList,\n                                          const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'nontemporal' clause.\n  OMPClause *ActOnOpenMPNontemporalClause(ArrayRef<Expr *> VarList,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n\n  /// Data for list of allocators.\n  struct UsesAllocatorsData {\n    /// Allocator.\n    Expr *Allocator = nullptr;\n    /// Allocator traits.\n    Expr *AllocatorTraits = nullptr;\n    /// Locations of '(' and ')' symbols.\n    SourceLocation LParenLoc, RParenLoc;\n  };\n  /// Called on well-formed 'uses_allocators' clause.\n  OMPClause *ActOnOpenMPUsesAllocatorClause(SourceLocation StartLoc,\n                                            SourceLocation LParenLoc,\n                                            SourceLocation EndLoc,\n                                            ArrayRef<UsesAllocatorsData> Data);\n  /// Called on well-formed 'affinity' clause.\n  OMPClause *ActOnOpenMPAffinityClause(SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation ColonLoc,\n                                       SourceLocation EndLoc, Expr *Modifier,\n                                       ArrayRef<Expr *> Locators);\n\n  /// The kind of conversion being performed.\n  enum CheckedConversionKind {\n    /// An implicit conversion.\n    CCK_ImplicitConversion,\n    /// A C-style cast.\n    CCK_CStyleCast,\n    /// A functional-style cast.\n    CCK_FunctionalCast,\n    /// A cast other than a C-style cast.\n    CCK_OtherCast,\n    /// A conversion for an operand of a builtin overloaded operator.\n    CCK_ForBuiltinOverloadedOp\n  };\n\n  static bool isCast(CheckedConversionKind CCK) {\n    return CCK == CCK_CStyleCast || CCK == CCK_FunctionalCast ||\n           CCK == CCK_OtherCast;\n  }\n\n  /// ImpCastExprToType - If Expr is not of type 'Type', insert an implicit\n  /// cast.  If there is already an implicit cast, merge into the existing one.\n  /// If isLvalue, the result of the cast is an lvalue.\n  ExprResult ImpCastExprToType(Expr *E, QualType Type, CastKind CK,\n                               ExprValueKind VK = VK_RValue,\n                               const CXXCastPath *BasePath = nullptr,\n                               CheckedConversionKind CCK\n                                  = CCK_ImplicitConversion);\n\n  /// ScalarTypeToBooleanCastKind - Returns the cast kind corresponding\n  /// to the conversion from scalar type ScalarTy to the Boolean type.\n  static CastKind ScalarTypeToBooleanCastKind(QualType ScalarTy);\n\n  /// IgnoredValueConversions - Given that an expression's result is\n  /// syntactically ignored, perform any conversions that are\n  /// required.\n  ExprResult IgnoredValueConversions(Expr *E);\n\n  // UsualUnaryConversions - promotes integers (C99 6.3.1.1p2) and converts\n  // functions and arrays to their respective pointers (C99 6.3.2.1).\n  ExprResult UsualUnaryConversions(Expr *E);\n\n  /// CallExprUnaryConversions - a special case of an unary conversion\n  /// performed on a function designator of a call expression.\n  ExprResult CallExprUnaryConversions(Expr *E);\n\n  // DefaultFunctionArrayConversion - converts functions and arrays\n  // to their respective pointers (C99 6.3.2.1).\n  ExprResult DefaultFunctionArrayConversion(Expr *E, bool Diagnose = true);\n\n  // DefaultFunctionArrayLvalueConversion - converts functions and\n  // arrays to their respective pointers and performs the\n  // lvalue-to-rvalue conversion.\n  ExprResult DefaultFunctionArrayLvalueConversion(Expr *E,\n                                                  bool Diagnose = true);\n\n  // DefaultLvalueConversion - performs lvalue-to-rvalue conversion on\n  // the operand. This function is a no-op if the operand has a function type\n  // or an array type.\n  ExprResult DefaultLvalueConversion(Expr *E);\n\n  // DefaultArgumentPromotion (C99 6.5.2.2p6). Used for function calls that\n  // do not have a prototype. Integer promotions are performed on each\n  // argument, and arguments that have type float are promoted to double.\n  ExprResult DefaultArgumentPromotion(Expr *E);\n\n  /// If \\p E is a prvalue denoting an unmaterialized temporary, materialize\n  /// it as an xvalue. In C++98, the result will still be a prvalue, because\n  /// we don't have xvalues there.\n  ExprResult TemporaryMaterializationConversion(Expr *E);\n\n  // Used for emitting the right warning by DefaultVariadicArgumentPromotion\n  enum VariadicCallType {\n    VariadicFunction,\n    VariadicBlock,\n    VariadicMethod,\n    VariadicConstructor,\n    VariadicDoesNotApply\n  };\n\n  VariadicCallType getVariadicCallType(FunctionDecl *FDecl,\n                                       const FunctionProtoType *Proto,\n                                       Expr *Fn);\n\n  // Used for determining in which context a type is allowed to be passed to a\n  // vararg function.\n  enum VarArgKind {\n    VAK_Valid,\n    VAK_ValidInCXX11,\n    VAK_Undefined,\n    VAK_MSVCUndefined,\n    VAK_Invalid\n  };\n\n  // Determines which VarArgKind fits an expression.\n  VarArgKind isValidVarArgType(const QualType &Ty);\n\n  /// Check to see if the given expression is a valid argument to a variadic\n  /// function, issuing a diagnostic if not.\n  void checkVariadicArgument(const Expr *E, VariadicCallType CT);\n\n  /// Check to see if a given expression could have '.c_str()' called on it.\n  bool hasCStrMethod(const Expr *E);\n\n  /// GatherArgumentsForCall - Collector argument expressions for various\n  /// form of call prototypes.\n  bool GatherArgumentsForCall(SourceLocation CallLoc, FunctionDecl *FDecl,\n                              const FunctionProtoType *Proto,\n                              unsigned FirstParam, ArrayRef<Expr *> Args,\n                              SmallVectorImpl<Expr *> &AllArgs,\n                              VariadicCallType CallType = VariadicDoesNotApply,\n                              bool AllowExplicit = false,\n                              bool IsListInitialization = false);\n\n  // DefaultVariadicArgumentPromotion - Like DefaultArgumentPromotion, but\n  // will create a runtime trap if the resulting type is not a POD type.\n  ExprResult DefaultVariadicArgumentPromotion(Expr *E, VariadicCallType CT,\n                                              FunctionDecl *FDecl);\n\n  /// Context in which we're performing a usual arithmetic conversion.\n  enum ArithConvKind {\n    /// An arithmetic operation.\n    ACK_Arithmetic,\n    /// A bitwise operation.\n    ACK_BitwiseOp,\n    /// A comparison.\n    ACK_Comparison,\n    /// A conditional (?:) operator.\n    ACK_Conditional,\n    /// A compound assignment expression.\n    ACK_CompAssign,\n  };\n\n  // UsualArithmeticConversions - performs the UsualUnaryConversions on it's\n  // operands and then handles various conversions that are common to binary\n  // operators (C99 6.3.1.8). If both operands aren't arithmetic, this\n  // routine returns the first non-arithmetic type found. The client is\n  // responsible for emitting appropriate error diagnostics.\n  QualType UsualArithmeticConversions(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc, ArithConvKind ACK);\n\n  /// AssignConvertType - All of the 'assignment' semantic checks return this\n  /// enum to indicate whether the assignment was allowed.  These checks are\n  /// done for simple assignments, as well as initialization, return from\n  /// function, argument passing, etc.  The query is phrased in terms of a\n  /// source and destination type.\n  enum AssignConvertType {\n    /// Compatible - the types are compatible according to the standard.\n    Compatible,\n\n    /// PointerToInt - The assignment converts a pointer to an int, which we\n    /// accept as an extension.\n    PointerToInt,\n\n    /// IntToPointer - The assignment converts an int to a pointer, which we\n    /// accept as an extension.\n    IntToPointer,\n\n    /// FunctionVoidPointer - The assignment is between a function pointer and\n    /// void*, which the standard doesn't allow, but we accept as an extension.\n    FunctionVoidPointer,\n\n    /// IncompatiblePointer - The assignment is between two pointers types that\n    /// are not compatible, but we accept them as an extension.\n    IncompatiblePointer,\n\n    /// IncompatibleFunctionPointer - The assignment is between two function\n    /// pointers types that are not compatible, but we accept them as an\n    /// extension.\n    IncompatibleFunctionPointer,\n\n    /// IncompatiblePointerSign - The assignment is between two pointers types\n    /// which point to integers which have a different sign, but are otherwise\n    /// identical. This is a subset of the above, but broken out because it's by\n    /// far the most common case of incompatible pointers.\n    IncompatiblePointerSign,\n\n    /// CompatiblePointerDiscardsQualifiers - The assignment discards\n    /// c/v/r qualifiers, which we accept as an extension.\n    CompatiblePointerDiscardsQualifiers,\n\n    /// IncompatiblePointerDiscardsQualifiers - The assignment\n    /// discards qualifiers that we don't permit to be discarded,\n    /// like address spaces.\n    IncompatiblePointerDiscardsQualifiers,\n\n    /// IncompatibleNestedPointerAddressSpaceMismatch - The assignment\n    /// changes address spaces in nested pointer types which is not allowed.\n    /// For instance, converting __private int ** to __generic int ** is\n    /// illegal even though __private could be converted to __generic.\n    IncompatibleNestedPointerAddressSpaceMismatch,\n\n    /// IncompatibleNestedPointerQualifiers - The assignment is between two\n    /// nested pointer types, and the qualifiers other than the first two\n    /// levels differ e.g. char ** -> const char **, but we accept them as an\n    /// extension.\n    IncompatibleNestedPointerQualifiers,\n\n    /// IncompatibleVectors - The assignment is between two vector types that\n    /// have the same size, which we accept as an extension.\n    IncompatibleVectors,\n\n    /// IntToBlockPointer - The assignment converts an int to a block\n    /// pointer. We disallow this.\n    IntToBlockPointer,\n\n    /// IncompatibleBlockPointer - The assignment is between two block\n    /// pointers types that are not compatible.\n    IncompatibleBlockPointer,\n\n    /// IncompatibleObjCQualifiedId - The assignment is between a qualified\n    /// id type and something else (that is incompatible with it). For example,\n    /// \"id <XXX>\" = \"Foo *\", where \"Foo *\" doesn't implement the XXX protocol.\n    IncompatibleObjCQualifiedId,\n\n    /// IncompatibleObjCWeakRef - Assigning a weak-unavailable object to an\n    /// object with __weak qualifier.\n    IncompatibleObjCWeakRef,\n\n    /// Incompatible - We reject this conversion outright, it is invalid to\n    /// represent it in the AST.\n    Incompatible\n  };\n\n  /// DiagnoseAssignmentResult - Emit a diagnostic, if required, for the\n  /// assignment conversion type specified by ConvTy.  This returns true if the\n  /// conversion was invalid or false if the conversion was accepted.\n  bool DiagnoseAssignmentResult(AssignConvertType ConvTy,\n                                SourceLocation Loc,\n                                QualType DstType, QualType SrcType,\n                                Expr *SrcExpr, AssignmentAction Action,\n                                bool *Complained = nullptr);\n\n  /// IsValueInFlagEnum - Determine if a value is allowed as part of a flag\n  /// enum. If AllowMask is true, then we also allow the complement of a valid\n  /// value, to be used as a mask.\n  bool IsValueInFlagEnum(const EnumDecl *ED, const llvm::APInt &Val,\n                         bool AllowMask) const;\n\n  /// DiagnoseAssignmentEnum - Warn if assignment to enum is a constant\n  /// integer not in the range of enum values.\n  void DiagnoseAssignmentEnum(QualType DstType, QualType SrcType,\n                              Expr *SrcExpr);\n\n  /// CheckAssignmentConstraints - Perform type checking for assignment,\n  /// argument passing, variable initialization, and function return values.\n  /// C99 6.5.16.\n  AssignConvertType CheckAssignmentConstraints(SourceLocation Loc,\n                                               QualType LHSType,\n                                               QualType RHSType);\n\n  /// Check assignment constraints and optionally prepare for a conversion of\n  /// the RHS to the LHS type. The conversion is prepared for if ConvertRHS\n  /// is true.\n  AssignConvertType CheckAssignmentConstraints(QualType LHSType,\n                                               ExprResult &RHS,\n                                               CastKind &Kind,\n                                               bool ConvertRHS = true);\n\n  /// Check assignment constraints for an assignment of RHS to LHSType.\n  ///\n  /// \\param LHSType The destination type for the assignment.\n  /// \\param RHS The source expression for the assignment.\n  /// \\param Diagnose If \\c true, diagnostics may be produced when checking\n  ///        for assignability. If a diagnostic is produced, \\p RHS will be\n  ///        set to ExprError(). Note that this function may still return\n  ///        without producing a diagnostic, even for an invalid assignment.\n  /// \\param DiagnoseCFAudited If \\c true, the target is a function parameter\n  ///        in an audited Core Foundation API and does not need to be checked\n  ///        for ARC retain issues.\n  /// \\param ConvertRHS If \\c true, \\p RHS will be updated to model the\n  ///        conversions necessary to perform the assignment. If \\c false,\n  ///        \\p Diagnose must also be \\c false.\n  AssignConvertType CheckSingleAssignmentConstraints(\n      QualType LHSType, ExprResult &RHS, bool Diagnose = true,\n      bool DiagnoseCFAudited = false, bool ConvertRHS = true);\n\n  // If the lhs type is a transparent union, check whether we\n  // can initialize the transparent union with the given expression.\n  AssignConvertType CheckTransparentUnionArgumentConstraints(QualType ArgType,\n                                                             ExprResult &RHS);\n\n  bool IsStringLiteralToNonConstPointerConversion(Expr *From, QualType ToType);\n\n  bool CheckExceptionSpecCompatibility(Expr *From, QualType ToType);\n\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       AssignmentAction Action,\n                                       bool AllowExplicit = false);\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       const ImplicitConversionSequence& ICS,\n                                       AssignmentAction Action,\n                                       CheckedConversionKind CCK\n                                          = CCK_ImplicitConversion);\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       const StandardConversionSequence& SCS,\n                                       AssignmentAction Action,\n                                       CheckedConversionKind CCK);\n\n  ExprResult PerformQualificationConversion(\n      Expr *E, QualType Ty, ExprValueKind VK = VK_RValue,\n      CheckedConversionKind CCK = CCK_ImplicitConversion);\n\n  /// the following \"Check\" methods will return a valid/converted QualType\n  /// or a null QualType (indicating an error diagnostic was issued).\n\n  /// type checking binary operators (subroutines of CreateBuiltinBinOp).\n  QualType InvalidOperands(SourceLocation Loc, ExprResult &LHS,\n                           ExprResult &RHS);\n  QualType InvalidLogicalVectorOperands(SourceLocation Loc, ExprResult &LHS,\n                                 ExprResult &RHS);\n  QualType CheckPointerToMemberOperands( // C++ 5.5\n    ExprResult &LHS, ExprResult &RHS, ExprValueKind &VK,\n    SourceLocation OpLoc, bool isIndirect);\n  QualType CheckMultiplyDivideOperands( // C99 6.5.5\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc, bool IsCompAssign,\n    bool IsDivide);\n  QualType CheckRemainderOperands( // C99 6.5.5\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    bool IsCompAssign = false);\n  QualType CheckAdditionOperands( // C99 6.5.6\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc, QualType* CompLHSTy = nullptr);\n  QualType CheckSubtractionOperands( // C99 6.5.6\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    QualType* CompLHSTy = nullptr);\n  QualType CheckShiftOperands( // C99 6.5.7\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc, bool IsCompAssign = false);\n  void CheckPtrComparisonWithNullChar(ExprResult &E, ExprResult &NullE);\n  QualType CheckCompareOperands( // C99 6.5.8/9\n      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n      BinaryOperatorKind Opc);\n  QualType CheckBitwiseOperands( // C99 6.5.[10...12]\n      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n      BinaryOperatorKind Opc);\n  QualType CheckLogicalOperands( // C99 6.5.[13,14]\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc);\n  // CheckAssignmentOperands is used for both simple and compound assignment.\n  // For simple assignment, pass both expressions and a null converted type.\n  // For compound assignment, pass both expressions and the converted type.\n  QualType CheckAssignmentOperands( // C99 6.5.16.[1,2]\n    Expr *LHSExpr, ExprResult &RHS, SourceLocation Loc, QualType CompoundType);\n\n  ExprResult checkPseudoObjectIncDec(Scope *S, SourceLocation OpLoc,\n                                     UnaryOperatorKind Opcode, Expr *Op);\n  ExprResult checkPseudoObjectAssignment(Scope *S, SourceLocation OpLoc,\n                                         BinaryOperatorKind Opcode,\n                                         Expr *LHS, Expr *RHS);\n  ExprResult checkPseudoObjectRValue(Expr *E);\n  Expr *recreateSyntacticForm(PseudoObjectExpr *E);\n\n  QualType CheckConditionalOperands( // C99 6.5.15\n    ExprResult &Cond, ExprResult &LHS, ExprResult &RHS,\n    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation QuestionLoc);\n  QualType CXXCheckConditionalOperands( // C++ 5.16\n    ExprResult &cond, ExprResult &lhs, ExprResult &rhs,\n    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation questionLoc);\n  QualType CheckVectorConditionalTypes(ExprResult &Cond, ExprResult &LHS,\n                                       ExprResult &RHS,\n                                       SourceLocation QuestionLoc);\n  QualType FindCompositePointerType(SourceLocation Loc, Expr *&E1, Expr *&E2,\n                                    bool ConvertArgs = true);\n  QualType FindCompositePointerType(SourceLocation Loc,\n                                    ExprResult &E1, ExprResult &E2,\n                                    bool ConvertArgs = true) {\n    Expr *E1Tmp = E1.get(), *E2Tmp = E2.get();\n    QualType Composite =\n        FindCompositePointerType(Loc, E1Tmp, E2Tmp, ConvertArgs);\n    E1 = E1Tmp;\n    E2 = E2Tmp;\n    return Composite;\n  }\n\n  QualType FindCompositeObjCPointerType(ExprResult &LHS, ExprResult &RHS,\n                                        SourceLocation QuestionLoc);\n\n  bool DiagnoseConditionalForNull(Expr *LHSExpr, Expr *RHSExpr,\n                                  SourceLocation QuestionLoc);\n\n  void DiagnoseAlwaysNonNullPointer(Expr *E,\n                                    Expr::NullPointerConstantKind NullType,\n                                    bool IsEqual, SourceRange Range);\n\n  /// type checking for vector binary operators.\n  QualType CheckVectorOperands(ExprResult &LHS, ExprResult &RHS,\n                               SourceLocation Loc, bool IsCompAssign,\n                               bool AllowBothBool, bool AllowBoolConversion);\n  QualType GetSignedVectorType(QualType V);\n  QualType CheckVectorCompareOperands(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc,\n                                      BinaryOperatorKind Opc);\n  QualType CheckVectorLogicalOperands(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc);\n\n  /// Type checking for matrix binary operators.\n  QualType CheckMatrixElementwiseOperands(ExprResult &LHS, ExprResult &RHS,\n                                          SourceLocation Loc,\n                                          bool IsCompAssign);\n  QualType CheckMatrixMultiplyOperands(ExprResult &LHS, ExprResult &RHS,\n                                       SourceLocation Loc, bool IsCompAssign);\n\n  bool isValidSveBitcast(QualType srcType, QualType destType);\n\n  bool areLaxCompatibleVectorTypes(QualType srcType, QualType destType);\n  bool isLaxVectorConversion(QualType srcType, QualType destType);\n\n  /// type checking declaration initializers (C99 6.7.8)\n  bool CheckForConstantInitializer(Expr *e, QualType t);\n\n  // type checking C++ declaration initializers (C++ [dcl.init]).\n\n  /// ReferenceCompareResult - Expresses the result of comparing two\n  /// types (cv1 T1 and cv2 T2) to determine their compatibility for the\n  /// purposes of initialization by reference (C++ [dcl.init.ref]p4).\n  enum ReferenceCompareResult {\n    /// Ref_Incompatible - The two types are incompatible, so direct\n    /// reference binding is not possible.\n    Ref_Incompatible = 0,\n    /// Ref_Related - The two types are reference-related, which means\n    /// that their unqualified forms (T1 and T2) are either the same\n    /// or T1 is a base class of T2.\n    Ref_Related,\n    /// Ref_Compatible - The two types are reference-compatible.\n    Ref_Compatible\n  };\n\n  // Fake up a scoped enumeration that still contextually converts to bool.\n  struct ReferenceConversionsScope {\n    /// The conversions that would be performed on an lvalue of type T2 when\n    /// binding a reference of type T1 to it, as determined when evaluating\n    /// whether T1 is reference-compatible with T2.\n    enum ReferenceConversions {\n      Qualification = 0x1,\n      NestedQualification = 0x2,\n      Function = 0x4,\n      DerivedToBase = 0x8,\n      ObjC = 0x10,\n      ObjCLifetime = 0x20,\n\n      LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/ObjCLifetime)\n    };\n  };\n  using ReferenceConversions = ReferenceConversionsScope::ReferenceConversions;\n\n  ReferenceCompareResult\n  CompareReferenceRelationship(SourceLocation Loc, QualType T1, QualType T2,\n                               ReferenceConversions *Conv = nullptr);\n\n  ExprResult checkUnknownAnyCast(SourceRange TypeRange, QualType CastType,\n                                 Expr *CastExpr, CastKind &CastKind,\n                                 ExprValueKind &VK, CXXCastPath &Path);\n\n  /// Force an expression with unknown-type to an expression of the\n  /// given type.\n  ExprResult forceUnknownAnyToType(Expr *E, QualType ToType);\n\n  /// Type-check an expression that's being passed to an\n  /// __unknown_anytype parameter.\n  ExprResult checkUnknownAnyArg(SourceLocation callLoc,\n                                Expr *result, QualType &paramType);\n\n  // CheckVectorCast - check type constraints for vectors.\n  // Since vectors are an extension, there are no C standard reference for this.\n  // We allow casting between vectors and integer datatypes of the same size.\n  // returns true if the cast is invalid\n  bool CheckVectorCast(SourceRange R, QualType VectorTy, QualType Ty,\n                       CastKind &Kind);\n\n  /// Prepare `SplattedExpr` for a vector splat operation, adding\n  /// implicit casts if necessary.\n  ExprResult prepareVectorSplat(QualType VectorTy, Expr *SplattedExpr);\n\n  // CheckExtVectorCast - check type constraints for extended vectors.\n  // Since vectors are an extension, there are no C standard reference for this.\n  // We allow casting between vectors and integer datatypes of the same size,\n  // or vectors and the element type of that vector.\n  // returns the cast expr\n  ExprResult CheckExtVectorCast(SourceRange R, QualType DestTy, Expr *CastExpr,\n                                CastKind &Kind);\n\n  ExprResult BuildCXXFunctionalCastExpr(TypeSourceInfo *TInfo, QualType Type,\n                                        SourceLocation LParenLoc,\n                                        Expr *CastExpr,\n                                        SourceLocation RParenLoc);\n\n  enum ARCConversionResult { ACR_okay, ACR_unbridged, ACR_error };\n\n  /// Checks for invalid conversions and casts between\n  /// retainable pointers and other pointer kinds for ARC and Weak.\n  ARCConversionResult CheckObjCConversion(SourceRange castRange,\n                                          QualType castType, Expr *&op,\n                                          CheckedConversionKind CCK,\n                                          bool Diagnose = true,\n                                          bool DiagnoseCFAudited = false,\n                                          BinaryOperatorKind Opc = BO_PtrMemD\n                                          );\n\n  Expr *stripARCUnbridgedCast(Expr *e);\n  void diagnoseARCUnbridgedCast(Expr *e);\n\n  bool CheckObjCARCUnavailableWeakConversion(QualType castType,\n                                             QualType ExprType);\n\n  /// checkRetainCycles - Check whether an Objective-C message send\n  /// might create an obvious retain cycle.\n  void checkRetainCycles(ObjCMessageExpr *msg);\n  void checkRetainCycles(Expr *receiver, Expr *argument);\n  void checkRetainCycles(VarDecl *Var, Expr *Init);\n\n  /// checkUnsafeAssigns - Check whether +1 expr is being assigned\n  /// to weak/__unsafe_unretained type.\n  bool checkUnsafeAssigns(SourceLocation Loc, QualType LHS, Expr *RHS);\n\n  /// checkUnsafeExprAssigns - Check whether +1 expr is being assigned\n  /// to weak/__unsafe_unretained expression.\n  void checkUnsafeExprAssigns(SourceLocation Loc, Expr *LHS, Expr *RHS);\n\n  /// CheckMessageArgumentTypes - Check types in an Obj-C message send.\n  /// \\param Method - May be null.\n  /// \\param [out] ReturnType - The return type of the send.\n  /// \\return true iff there were any incompatible types.\n  bool CheckMessageArgumentTypes(const Expr *Receiver, QualType ReceiverType,\n                                 MultiExprArg Args, Selector Sel,\n                                 ArrayRef<SourceLocation> SelectorLocs,\n                                 ObjCMethodDecl *Method, bool isClassMessage,\n                                 bool isSuperMessage, SourceLocation lbrac,\n                                 SourceLocation rbrac, SourceRange RecRange,\n                                 QualType &ReturnType, ExprValueKind &VK);\n\n  /// Determine the result of a message send expression based on\n  /// the type of the receiver, the method expected to receive the message,\n  /// and the form of the message send.\n  QualType getMessageSendResultType(const Expr *Receiver, QualType ReceiverType,\n                                    ObjCMethodDecl *Method, bool isClassMessage,\n                                    bool isSuperMessage);\n\n  /// If the given expression involves a message send to a method\n  /// with a related result type, emit a note describing what happened.\n  void EmitRelatedResultTypeNote(const Expr *E);\n\n  /// Given that we had incompatible pointer types in a return\n  /// statement, check whether we're in a method with a related result\n  /// type, and if so, emit a note describing what happened.\n  void EmitRelatedResultTypeNoteForReturn(QualType destType);\n\n  class ConditionResult {\n    Decl *ConditionVar;\n    FullExprArg Condition;\n    bool Invalid;\n    bool HasKnownValue;\n    bool KnownValue;\n\n    friend class Sema;\n    ConditionResult(Sema &S, Decl *ConditionVar, FullExprArg Condition,\n                    bool IsConstexpr)\n        : ConditionVar(ConditionVar), Condition(Condition), Invalid(false),\n          HasKnownValue(IsConstexpr && Condition.get() &&\n                        !Condition.get()->isValueDependent()),\n          KnownValue(HasKnownValue &&\n                     !!Condition.get()->EvaluateKnownConstInt(S.Context)) {}\n    explicit ConditionResult(bool Invalid)\n        : ConditionVar(nullptr), Condition(nullptr), Invalid(Invalid),\n          HasKnownValue(false), KnownValue(false) {}\n\n  public:\n    ConditionResult() : ConditionResult(false) {}\n    bool isInvalid() const { return Invalid; }\n    std::pair<VarDecl *, Expr *> get() const {\n      return std::make_pair(cast_or_null<VarDecl>(ConditionVar),\n                            Condition.get());\n    }\n    llvm::Optional<bool> getKnownValue() const {\n      if (!HasKnownValue)\n        return None;\n      return KnownValue;\n    }\n  };\n  static ConditionResult ConditionError() { return ConditionResult(true); }\n\n  enum class ConditionKind {\n    Boolean,     ///< A boolean condition, from 'if', 'while', 'for', or 'do'.\n    ConstexprIf, ///< A constant boolean condition from 'if constexpr'.\n    Switch       ///< An integral condition for a 'switch' statement.\n  };\n\n  ConditionResult ActOnCondition(Scope *S, SourceLocation Loc,\n                                 Expr *SubExpr, ConditionKind CK);\n\n  ConditionResult ActOnConditionVariable(Decl *ConditionVar,\n                                         SourceLocation StmtLoc,\n                                         ConditionKind CK);\n\n  DeclResult ActOnCXXConditionDeclaration(Scope *S, Declarator &D);\n\n  ExprResult CheckConditionVariable(VarDecl *ConditionVar,\n                                    SourceLocation StmtLoc,\n                                    ConditionKind CK);\n  ExprResult CheckSwitchCondition(SourceLocation SwitchLoc, Expr *Cond);\n\n  /// CheckBooleanCondition - Diagnose problems involving the use of\n  /// the given expression as a boolean condition (e.g. in an if\n  /// statement).  Also performs the standard function and array\n  /// decays, possibly changing the input variable.\n  ///\n  /// \\param Loc - A location associated with the condition, e.g. the\n  /// 'if' keyword.\n  /// \\return true iff there were any errors\n  ExprResult CheckBooleanCondition(SourceLocation Loc, Expr *E,\n                                   bool IsConstexpr = false);\n\n  /// ActOnExplicitBoolSpecifier - Build an ExplicitSpecifier from an expression\n  /// found in an explicit(bool) specifier.\n  ExplicitSpecifier ActOnExplicitBoolSpecifier(Expr *E);\n\n  /// tryResolveExplicitSpecifier - Attempt to resolve the explict specifier.\n  /// Returns true if the explicit specifier is now resolved.\n  bool tryResolveExplicitSpecifier(ExplicitSpecifier &ExplicitSpec);\n\n  /// DiagnoseAssignmentAsCondition - Given that an expression is\n  /// being used as a boolean condition, warn if it's an assignment.\n  void DiagnoseAssignmentAsCondition(Expr *E);\n\n  /// Redundant parentheses over an equality comparison can indicate\n  /// that the user intended an assignment used as condition.\n  void DiagnoseEqualityWithExtraParens(ParenExpr *ParenE);\n\n  /// CheckCXXBooleanCondition - Returns true if conversion to bool is invalid.\n  ExprResult CheckCXXBooleanCondition(Expr *CondExpr, bool IsConstexpr = false);\n\n  /// ConvertIntegerToTypeWarnOnOverflow - Convert the specified APInt to have\n  /// the specified width and sign.  If an overflow occurs, detect it and emit\n  /// the specified diagnostic.\n  void ConvertIntegerToTypeWarnOnOverflow(llvm::APSInt &OldVal,\n                                          unsigned NewWidth, bool NewSign,\n                                          SourceLocation Loc, unsigned DiagID);\n\n  /// Checks that the Objective-C declaration is declared in the global scope.\n  /// Emits an error and marks the declaration as invalid if it's not declared\n  /// in the global scope.\n  bool CheckObjCDeclScope(Decl *D);\n\n  /// Abstract base class used for diagnosing integer constant\n  /// expression violations.\n  class VerifyICEDiagnoser {\n  public:\n    bool Suppress;\n\n    VerifyICEDiagnoser(bool Suppress = false) : Suppress(Suppress) { }\n\n    virtual SemaDiagnosticBuilder\n    diagnoseNotICEType(Sema &S, SourceLocation Loc, QualType T);\n    virtual SemaDiagnosticBuilder diagnoseNotICE(Sema &S,\n                                                 SourceLocation Loc) = 0;\n    virtual SemaDiagnosticBuilder diagnoseFold(Sema &S, SourceLocation Loc);\n    virtual ~VerifyICEDiagnoser() {}\n  };\n\n  enum AllowFoldKind {\n    NoFold,\n    AllowFold,\n  };\n\n  /// VerifyIntegerConstantExpression - Verifies that an expression is an ICE,\n  /// and reports the appropriate diagnostics. Returns false on success.\n  /// Can optionally return the value of the expression.\n  ExprResult VerifyIntegerConstantExpression(Expr *E, llvm::APSInt *Result,\n                                             VerifyICEDiagnoser &Diagnoser,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E, llvm::APSInt *Result,\n                                             unsigned DiagID,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E,\n                                             llvm::APSInt *Result = nullptr,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E,\n                                             AllowFoldKind CanFold = NoFold) {\n    return VerifyIntegerConstantExpression(E, nullptr, CanFold);\n  }\n\n  /// VerifyBitField - verifies that a bit field expression is an ICE and has\n  /// the correct width, and that the field type is valid.\n  /// Returns false on success.\n  /// Can optionally return whether the bit-field is of width 0\n  ExprResult VerifyBitField(SourceLocation FieldLoc, IdentifierInfo *FieldName,\n                            QualType FieldTy, bool IsMsStruct,\n                            Expr *BitWidth, bool *ZeroWidth = nullptr);\n\nprivate:\n  unsigned ForceCUDAHostDeviceDepth = 0;\n\npublic:\n  /// Increments our count of the number of times we've seen a pragma forcing\n  /// functions to be __host__ __device__.  So long as this count is greater\n  /// than zero, all functions encountered will be __host__ __device__.\n  void PushForceCUDAHostDevice();\n\n  /// Decrements our count of the number of times we've seen a pragma forcing\n  /// functions to be __host__ __device__.  Returns false if the count is 0\n  /// before incrementing, so you can emit an error.\n  bool PopForceCUDAHostDevice();\n\n  /// Diagnostics that are emitted only if we discover that the given function\n  /// must be codegen'ed.  Because handling these correctly adds overhead to\n  /// compilation, this is currently only enabled for CUDA compilations.\n  llvm::DenseMap<CanonicalDeclPtr<FunctionDecl>,\n                 std::vector<PartialDiagnosticAt>>\n      DeviceDeferredDiags;\n\n  /// A pair of a canonical FunctionDecl and a SourceLocation.  When used as the\n  /// key in a hashtable, both the FD and location are hashed.\n  struct FunctionDeclAndLoc {\n    CanonicalDeclPtr<FunctionDecl> FD;\n    SourceLocation Loc;\n  };\n\n  /// FunctionDecls and SourceLocations for which CheckCUDACall has emitted a\n  /// (maybe deferred) \"bad call\" diagnostic.  We use this to avoid emitting the\n  /// same deferred diag twice.\n  llvm::DenseSet<FunctionDeclAndLoc> LocsWithCUDACallDiags;\n\n  /// An inverse call graph, mapping known-emitted functions to one of their\n  /// known-emitted callers (plus the location of the call).\n  ///\n  /// Functions that we can tell a priori must be emitted aren't added to this\n  /// map.\n  llvm::DenseMap</* Callee = */ CanonicalDeclPtr<FunctionDecl>,\n                 /* Caller = */ FunctionDeclAndLoc>\n      DeviceKnownEmittedFns;\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurContext is a __host__ function, does not emit any diagnostics\n  ///   unless \\p EmitOnBothSides is true.\n  /// - If CurContext is a __device__ or __global__ function, emits the\n  ///   diagnostics immediately.\n  /// - If CurContext is a __host__ __device__ function and we are compiling for\n  ///   the device, creates a diagnostic which is emitted if and when we realize\n  ///   that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in CUDA device code.\n  ///  if (CUDADiagIfDeviceCode(Loc, diag::err_cuda_vla) << CurrentCUDATarget())\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder CUDADiagIfDeviceCode(SourceLocation Loc,\n                                             unsigned DiagID);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as host code\".\n  ///\n  /// Same as CUDADiagIfDeviceCode, with \"host\" and \"device\" switched.\n  SemaDiagnosticBuilder CUDADiagIfHostCode(SourceLocation Loc, unsigned DiagID);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurContext is a `declare target` function or it is known that the\n  /// function is emitted for the device, emits the diagnostics immediately.\n  /// - If CurContext is a non-`declare target` function and we are compiling\n  ///   for the device, creates a diagnostic which is emitted if and when we\n  ///   realize that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in NVPTX device code.\n  ///  if (diagIfOpenMPDeviceCode(Loc, diag::err_vla_unsupported))\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder\n  diagIfOpenMPDeviceCode(SourceLocation Loc, unsigned DiagID, FunctionDecl *FD);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as host code\".\n  ///\n  /// - If CurContext is a `declare target` function or it is known that the\n  /// function is emitted for the host, emits the diagnostics immediately.\n  /// - If CurContext is a non-host function, just ignore it.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in NVPTX device code.\n  ///  if (diagIfOpenMPHostode(Loc, diag::err_vla_unsupported))\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder diagIfOpenMPHostCode(SourceLocation Loc,\n                                             unsigned DiagID, FunctionDecl *FD);\n\n  SemaDiagnosticBuilder targetDiag(SourceLocation Loc, unsigned DiagID,\n                                   FunctionDecl *FD = nullptr);\n  SemaDiagnosticBuilder targetDiag(SourceLocation Loc,\n                                   const PartialDiagnostic &PD,\n                                   FunctionDecl *FD = nullptr) {\n    return targetDiag(Loc, PD.getDiagID(), FD) << PD;\n  }\n\n  /// Check if the expression is allowed to be used in expressions for the\n  /// offloading devices.\n  void checkDeviceDecl(ValueDecl *D, SourceLocation Loc);\n\n  enum CUDAFunctionTarget {\n    CFT_Device,\n    CFT_Global,\n    CFT_Host,\n    CFT_HostDevice,\n    CFT_InvalidTarget\n  };\n\n  /// Determines whether the given function is a CUDA device/host/kernel/etc.\n  /// function.\n  ///\n  /// Use this rather than examining the function's attributes yourself -- you\n  /// will get it wrong.  Returns CFT_Host if D is null.\n  CUDAFunctionTarget IdentifyCUDATarget(const FunctionDecl *D,\n                                        bool IgnoreImplicitHDAttr = false);\n  CUDAFunctionTarget IdentifyCUDATarget(const ParsedAttributesView &Attrs);\n\n  /// Gets the CUDA target for the current context.\n  CUDAFunctionTarget CurrentCUDATarget() {\n    return IdentifyCUDATarget(dyn_cast<FunctionDecl>(CurContext));\n  }\n\n  static bool isCUDAImplicitHostDeviceFunction(const FunctionDecl *D);\n\n  // CUDA function call preference. Must be ordered numerically from\n  // worst to best.\n  enum CUDAFunctionPreference {\n    CFP_Never,      // Invalid caller/callee combination.\n    CFP_WrongSide,  // Calls from host-device to host or device\n                    // function that do not match current compilation\n                    // mode.\n    CFP_HostDevice, // Any calls to host/device functions.\n    CFP_SameSide,   // Calls from host-device to host or device\n                    // function matching current compilation mode.\n    CFP_Native,     // host-to-host or device-to-device calls.\n  };\n\n  /// Identifies relative preference of a given Caller/Callee\n  /// combination, based on their host/device attributes.\n  /// \\param Caller function which needs address of \\p Callee.\n  ///               nullptr in case of global context.\n  /// \\param Callee target function\n  ///\n  /// \\returns preference value for particular Caller/Callee combination.\n  CUDAFunctionPreference IdentifyCUDAPreference(const FunctionDecl *Caller,\n                                                const FunctionDecl *Callee);\n\n  /// Determines whether Caller may invoke Callee, based on their CUDA\n  /// host/device attributes.  Returns false if the call is not allowed.\n  ///\n  /// Note: Will return true for CFP_WrongSide calls.  These may appear in\n  /// semantically correct CUDA programs, but only if they're never codegen'ed.\n  bool IsAllowedCUDACall(const FunctionDecl *Caller,\n                         const FunctionDecl *Callee) {\n    return IdentifyCUDAPreference(Caller, Callee) != CFP_Never;\n  }\n\n  /// May add implicit CUDAHostAttr and CUDADeviceAttr attributes to FD,\n  /// depending on FD and the current compilation settings.\n  void maybeAddCUDAHostDeviceAttrs(FunctionDecl *FD,\n                                   const LookupResult &Previous);\n\n  /// May add implicit CUDAConstantAttr attribute to VD, depending on VD\n  /// and current compilation settings.\n  void MaybeAddCUDAConstantAttr(VarDecl *VD);\n\npublic:\n  /// Check whether we're allowed to call Callee from the current context.\n  ///\n  /// - If the call is never allowed in a semantically-correct program\n  ///   (CFP_Never), emits an error and returns false.\n  ///\n  /// - If the call is allowed in semantically-correct programs, but only if\n  ///   it's never codegen'ed (CFP_WrongSide), creates a deferred diagnostic to\n  ///   be emitted if and when the caller is codegen'ed, and returns true.\n  ///\n  ///   Will only create deferred diagnostics for a given SourceLocation once,\n  ///   so you can safely call this multiple times without generating duplicate\n  ///   deferred errors.\n  ///\n  /// - Otherwise, returns true without emitting any diagnostics.\n  bool CheckCUDACall(SourceLocation Loc, FunctionDecl *Callee);\n\n  void CUDACheckLambdaCapture(CXXMethodDecl *D, const sema::Capture &Capture);\n\n  /// Set __device__ or __host__ __device__ attributes on the given lambda\n  /// operator() method.\n  ///\n  /// CUDA lambdas by default is host device function unless it has explicit\n  /// host or device attribute.\n  void CUDASetLambdaAttrs(CXXMethodDecl *Method);\n\n  /// Finds a function in \\p Matches with highest calling priority\n  /// from \\p Caller context and erases all functions with lower\n  /// calling priority.\n  void EraseUnwantedCUDAMatches(\n      const FunctionDecl *Caller,\n      SmallVectorImpl<std::pair<DeclAccessPair, FunctionDecl *>> &Matches);\n\n  /// Given a implicit special member, infer its CUDA target from the\n  /// calls it needs to make to underlying base/field special members.\n  /// \\param ClassDecl the class for which the member is being created.\n  /// \\param CSM the kind of special member.\n  /// \\param MemberDecl the special member itself.\n  /// \\param ConstRHS true if this is a copy operation with a const object on\n  ///        its RHS.\n  /// \\param Diagnose true if this call should emit diagnostics.\n  /// \\return true if there was an error inferring.\n  /// The result of this call is implicit CUDA target attribute(s) attached to\n  /// the member declaration.\n  bool inferCUDATargetForImplicitSpecialMember(CXXRecordDecl *ClassDecl,\n                                               CXXSpecialMember CSM,\n                                               CXXMethodDecl *MemberDecl,\n                                               bool ConstRHS,\n                                               bool Diagnose);\n\n  /// \\return true if \\p CD can be considered empty according to CUDA\n  /// (E.2.3.1 in CUDA 7.5 Programming guide).\n  bool isEmptyCudaConstructor(SourceLocation Loc, CXXConstructorDecl *CD);\n  bool isEmptyCudaDestructor(SourceLocation Loc, CXXDestructorDecl *CD);\n\n  // \\brief Checks that initializers of \\p Var satisfy CUDA restrictions. In\n  // case of error emits appropriate diagnostic and invalidates \\p Var.\n  //\n  // \\details CUDA allows only empty constructors as initializers for global\n  // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all\n  // __shared__ variables whether they are local or not (they all are implicitly\n  // static in CUDA). One exception is that CUDA allows constant initializers\n  // for __constant__ and __device__ variables.\n  void checkAllowedCUDAInitializer(VarDecl *VD);\n\n  /// Check whether NewFD is a valid overload for CUDA. Emits\n  /// diagnostics and invalidates NewFD if not.\n  void checkCUDATargetOverload(FunctionDecl *NewFD,\n                               const LookupResult &Previous);\n  /// Copies target attributes from the template TD to the function FD.\n  void inheritCUDATargetAttrs(FunctionDecl *FD, const FunctionTemplateDecl &TD);\n\n  /// Returns the name of the launch configuration function.  This is the name\n  /// of the function that will be called to configure kernel call, with the\n  /// parameters specified via <<<>>>.\n  std::string getCudaConfigureFuncName() const;\n\n  /// \\name Code completion\n  //@{\n  /// Describes the context in which code completion occurs.\n  enum ParserCompletionContext {\n    /// Code completion occurs at top-level or namespace context.\n    PCC_Namespace,\n    /// Code completion occurs within a class, struct, or union.\n    PCC_Class,\n    /// Code completion occurs within an Objective-C interface, protocol,\n    /// or category.\n    PCC_ObjCInterface,\n    /// Code completion occurs within an Objective-C implementation or\n    /// category implementation\n    PCC_ObjCImplementation,\n    /// Code completion occurs within the list of instance variables\n    /// in an Objective-C interface, protocol, category, or implementation.\n    PCC_ObjCInstanceVariableList,\n    /// Code completion occurs following one or more template\n    /// headers.\n    PCC_Template,\n    /// Code completion occurs following one or more template\n    /// headers within a class.\n    PCC_MemberTemplate,\n    /// Code completion occurs within an expression.\n    PCC_Expression,\n    /// Code completion occurs within a statement, which may\n    /// also be an expression or a declaration.\n    PCC_Statement,\n    /// Code completion occurs at the beginning of the\n    /// initialization statement (or expression) in a for loop.\n    PCC_ForInit,\n    /// Code completion occurs within the condition of an if,\n    /// while, switch, or for statement.\n    PCC_Condition,\n    /// Code completion occurs within the body of a function on a\n    /// recovery path, where we do not have a specific handle on our position\n    /// in the grammar.\n    PCC_RecoveryInFunction,\n    /// Code completion occurs where only a type is permitted.\n    PCC_Type,\n    /// Code completion occurs in a parenthesized expression, which\n    /// might also be a type cast.\n    PCC_ParenthesizedExpression,\n    /// Code completion occurs within a sequence of declaration\n    /// specifiers within a function, method, or block.\n    PCC_LocalDeclarationSpecifiers\n  };\n\n  void CodeCompleteModuleImport(SourceLocation ImportLoc, ModuleIdPath Path);\n  void CodeCompleteOrdinaryName(Scope *S,\n                                ParserCompletionContext CompletionContext);\n  void CodeCompleteDeclSpec(Scope *S, DeclSpec &DS,\n                            bool AllowNonIdentifiers,\n                            bool AllowNestedNameSpecifiers);\n\n  struct CodeCompleteExpressionData;\n  void CodeCompleteExpression(Scope *S,\n                              const CodeCompleteExpressionData &Data);\n  void CodeCompleteExpression(Scope *S, QualType PreferredType,\n                              bool IsParenthesized = false);\n  void CodeCompleteMemberReferenceExpr(Scope *S, Expr *Base, Expr *OtherOpBase,\n                                       SourceLocation OpLoc, bool IsArrow,\n                                       bool IsBaseExprStatement,\n                                       QualType PreferredType);\n  void CodeCompletePostfixExpression(Scope *S, ExprResult LHS,\n                                     QualType PreferredType);\n  void CodeCompleteTag(Scope *S, unsigned TagSpec);\n  void CodeCompleteTypeQualifiers(DeclSpec &DS);\n  void CodeCompleteFunctionQualifiers(DeclSpec &DS, Declarator &D,\n                                      const VirtSpecifiers *VS = nullptr);\n  void CodeCompleteBracketDeclarator(Scope *S);\n  void CodeCompleteCase(Scope *S);\n  /// Reports signatures for a call to CodeCompleteConsumer and returns the\n  /// preferred type for the current argument. Returned type can be null.\n  QualType ProduceCallSignatureHelp(Scope *S, Expr *Fn, ArrayRef<Expr *> Args,\n                                    SourceLocation OpenParLoc);\n  QualType ProduceConstructorSignatureHelp(Scope *S, QualType Type,\n                                           SourceLocation Loc,\n                                           ArrayRef<Expr *> Args,\n                                           SourceLocation OpenParLoc);\n  QualType ProduceCtorInitMemberSignatureHelp(Scope *S, Decl *ConstructorDecl,\n                                              CXXScopeSpec SS,\n                                              ParsedType TemplateTypeTy,\n                                              ArrayRef<Expr *> ArgExprs,\n                                              IdentifierInfo *II,\n                                              SourceLocation OpenParLoc);\n  void CodeCompleteInitializer(Scope *S, Decl *D);\n  /// Trigger code completion for a record of \\p BaseType. \\p InitExprs are\n  /// expressions in the initializer list seen so far and \\p D is the current\n  /// Designation being parsed.\n  void CodeCompleteDesignator(const QualType BaseType,\n                              llvm::ArrayRef<Expr *> InitExprs,\n                              const Designation &D);\n  void CodeCompleteAfterIf(Scope *S, bool IsBracedThen);\n\n  void CodeCompleteQualifiedId(Scope *S, CXXScopeSpec &SS, bool EnteringContext,\n                               bool IsUsingDeclaration, QualType BaseType,\n                               QualType PreferredType);\n  void CodeCompleteUsing(Scope *S);\n  void CodeCompleteUsingDirective(Scope *S);\n  void CodeCompleteNamespaceDecl(Scope *S);\n  void CodeCompleteNamespaceAliasDecl(Scope *S);\n  void CodeCompleteOperatorName(Scope *S);\n  void CodeCompleteConstructorInitializer(\n                                Decl *Constructor,\n                                ArrayRef<CXXCtorInitializer *> Initializers);\n\n  void CodeCompleteLambdaIntroducer(Scope *S, LambdaIntroducer &Intro,\n                                    bool AfterAmpersand);\n  void CodeCompleteAfterFunctionEquals(Declarator &D);\n\n  void CodeCompleteObjCAtDirective(Scope *S);\n  void CodeCompleteObjCAtVisibility(Scope *S);\n  void CodeCompleteObjCAtStatement(Scope *S);\n  void CodeCompleteObjCAtExpression(Scope *S);\n  void CodeCompleteObjCPropertyFlags(Scope *S, ObjCDeclSpec &ODS);\n  void CodeCompleteObjCPropertyGetter(Scope *S);\n  void CodeCompleteObjCPropertySetter(Scope *S);\n  void CodeCompleteObjCPassingType(Scope *S, ObjCDeclSpec &DS,\n                                   bool IsParameter);\n  void CodeCompleteObjCMessageReceiver(Scope *S);\n  void CodeCompleteObjCSuperMessage(Scope *S, SourceLocation SuperLoc,\n                                    ArrayRef<IdentifierInfo *> SelIdents,\n                                    bool AtArgumentExpression);\n  void CodeCompleteObjCClassMessage(Scope *S, ParsedType Receiver,\n                                    ArrayRef<IdentifierInfo *> SelIdents,\n                                    bool AtArgumentExpression,\n                                    bool IsSuper = false);\n  void CodeCompleteObjCInstanceMessage(Scope *S, Expr *Receiver,\n                                       ArrayRef<IdentifierInfo *> SelIdents,\n                                       bool AtArgumentExpression,\n                                       ObjCInterfaceDecl *Super = nullptr);\n  void CodeCompleteObjCForCollection(Scope *S,\n                                     DeclGroupPtrTy IterationVar);\n  void CodeCompleteObjCSelector(Scope *S,\n                                ArrayRef<IdentifierInfo *> SelIdents);\n  void CodeCompleteObjCProtocolReferences(\n                                         ArrayRef<IdentifierLocPair> Protocols);\n  void CodeCompleteObjCProtocolDecl(Scope *S);\n  void CodeCompleteObjCInterfaceDecl(Scope *S);\n  void CodeCompleteObjCSuperclass(Scope *S,\n                                  IdentifierInfo *ClassName,\n                                  SourceLocation ClassNameLoc);\n  void CodeCompleteObjCImplementationDecl(Scope *S);\n  void CodeCompleteObjCInterfaceCategory(Scope *S,\n                                         IdentifierInfo *ClassName,\n                                         SourceLocation ClassNameLoc);\n  void CodeCompleteObjCImplementationCategory(Scope *S,\n                                              IdentifierInfo *ClassName,\n                                              SourceLocation ClassNameLoc);\n  void CodeCompleteObjCPropertyDefinition(Scope *S);\n  void CodeCompleteObjCPropertySynthesizeIvar(Scope *S,\n                                              IdentifierInfo *PropertyName);\n  void CodeCompleteObjCMethodDecl(Scope *S, Optional<bool> IsInstanceMethod,\n                                  ParsedType ReturnType);\n  void CodeCompleteObjCMethodDeclSelector(Scope *S,\n                                          bool IsInstanceMethod,\n                                          bool AtParameterName,\n                                          ParsedType ReturnType,\n                                          ArrayRef<IdentifierInfo *> SelIdents);\n  void CodeCompleteObjCClassPropertyRefExpr(Scope *S, IdentifierInfo &ClassName,\n                                            SourceLocation ClassNameLoc,\n                                            bool IsBaseExprStatement);\n  void CodeCompletePreprocessorDirective(bool InConditional);\n  void CodeCompleteInPreprocessorConditionalExclusion(Scope *S);\n  void CodeCompletePreprocessorMacroName(bool IsDefinition);\n  void CodeCompletePreprocessorExpression();\n  void CodeCompletePreprocessorMacroArgument(Scope *S,\n                                             IdentifierInfo *Macro,\n                                             MacroInfo *MacroInfo,\n                                             unsigned Argument);\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);\n  void CodeCompleteNaturalLanguage();\n  void CodeCompleteAvailabilityPlatformName();\n  void GatherGlobalCodeCompletions(CodeCompletionAllocator &Allocator,\n                                   CodeCompletionTUInfo &CCTUInfo,\n                  SmallVectorImpl<CodeCompletionResult> &Results);\n  //@}\n\n  //===--------------------------------------------------------------------===//\n  // Extra semantic analysis beyond the C type system\n\npublic:\n  SourceLocation getLocationOfStringLiteralByte(const StringLiteral *SL,\n                                                unsigned ByteNo) const;\n\nprivate:\n  void CheckArrayAccess(const Expr *BaseExpr, const Expr *IndexExpr,\n                        const ArraySubscriptExpr *ASE=nullptr,\n                        bool AllowOnePastEnd=true, bool IndexNegated=false);\n  void CheckArrayAccess(const Expr *E);\n  // Used to grab the relevant information from a FormatAttr and a\n  // FunctionDeclaration.\n  struct FormatStringInfo {\n    unsigned FormatIdx;\n    unsigned FirstDataArg;\n    bool HasVAListArg;\n  };\n\n  static bool getFormatStringInfo(const FormatAttr *Format, bool IsCXXMember,\n                                  FormatStringInfo *FSI);\n  bool CheckFunctionCall(FunctionDecl *FDecl, CallExpr *TheCall,\n                         const FunctionProtoType *Proto);\n  bool CheckObjCMethodCall(ObjCMethodDecl *Method, SourceLocation loc,\n                           ArrayRef<const Expr *> Args);\n  bool CheckPointerCall(NamedDecl *NDecl, CallExpr *TheCall,\n                        const FunctionProtoType *Proto);\n  bool CheckOtherCall(CallExpr *TheCall, const FunctionProtoType *Proto);\n  void CheckConstructorCall(FunctionDecl *FDecl, QualType ThisType,\n                            ArrayRef<const Expr *> Args,\n                            const FunctionProtoType *Proto, SourceLocation Loc);\n\n  void CheckArgAlignment(SourceLocation Loc, NamedDecl *FDecl,\n                         StringRef ParamName, QualType ArgTy, QualType ParamTy);\n\n  void checkCall(NamedDecl *FDecl, const FunctionProtoType *Proto,\n                 const Expr *ThisArg, ArrayRef<const Expr *> Args,\n                 bool IsMemberFunction, SourceLocation Loc, SourceRange Range,\n                 VariadicCallType CallType);\n\n  bool CheckObjCString(Expr *Arg);\n  ExprResult CheckOSLogFormatStringArg(Expr *Arg);\n\n  ExprResult CheckBuiltinFunctionCall(FunctionDecl *FDecl,\n                                      unsigned BuiltinID, CallExpr *TheCall);\n\n  bool CheckTSBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                  CallExpr *TheCall);\n\n  void checkFortifiedBuiltinMemoryFunction(FunctionDecl *FD, CallExpr *TheCall);\n\n  bool CheckARMBuiltinExclusiveCall(unsigned BuiltinID, CallExpr *TheCall,\n                                    unsigned MaxWidth);\n  bool CheckNeonBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                    CallExpr *TheCall);\n  bool CheckMVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckSVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckCDEBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckARMCoprocessorImmediate(const TargetInfo &TI, const Expr *CoprocArg,\n                                    bool WantCDE);\n  bool CheckARMBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n\n  bool CheckAArch64BuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                       CallExpr *TheCall);\n  bool CheckBPFBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckHexagonBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckHexagonBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckMipsBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                    CallExpr *TheCall);\n  bool CheckMipsBuiltinCpu(const TargetInfo &TI, unsigned BuiltinID,\n                           CallExpr *TheCall);\n  bool CheckMipsBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckSystemZBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinRoundingOrSAE(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinGatherScatterScale(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinTileArguments(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinTileArgumentsRange(CallExpr *TheCall,\n                                         ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinTileDuplicate(CallExpr *TheCall, ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinTileRangeAndDuplicate(CallExpr *TheCall,\n                                            ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckPPCBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckAMDGCNBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckRISCVBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                     CallExpr *TheCall);\n\n  bool SemaBuiltinVAStart(unsigned BuiltinID, CallExpr *TheCall);\n  bool SemaBuiltinVAStartARMMicrosoft(CallExpr *Call);\n  bool SemaBuiltinUnorderedCompare(CallExpr *TheCall);\n  bool SemaBuiltinFPClassification(CallExpr *TheCall, unsigned NumArgs);\n  bool SemaBuiltinComplex(CallExpr *TheCall);\n  bool SemaBuiltinVSX(CallExpr *TheCall);\n  bool SemaBuiltinOSLogFormat(CallExpr *TheCall);\n\npublic:\n  // Used by C++ template instantiation.\n  ExprResult SemaBuiltinShuffleVector(CallExpr *TheCall);\n  ExprResult SemaConvertVectorExpr(Expr *E, TypeSourceInfo *TInfo,\n                                   SourceLocation BuiltinLoc,\n                                   SourceLocation RParenLoc);\n\nprivate:\n  bool SemaBuiltinPrefetch(CallExpr *TheCall);\n  bool SemaBuiltinAllocaWithAlign(CallExpr *TheCall);\n  bool SemaBuiltinAssume(CallExpr *TheCall);\n  bool SemaBuiltinAssumeAligned(CallExpr *TheCall);\n  bool SemaBuiltinLongjmp(CallExpr *TheCall);\n  bool SemaBuiltinSetjmp(CallExpr *TheCall);\n  ExprResult SemaBuiltinAtomicOverloaded(ExprResult TheCallResult);\n  ExprResult SemaBuiltinNontemporalOverloaded(ExprResult TheCallResult);\n  ExprResult SemaAtomicOpsOverloaded(ExprResult TheCallResult,\n                                     AtomicExpr::AtomicOp Op);\n  ExprResult SemaBuiltinOperatorNewDeleteOverloaded(ExprResult TheCallResult,\n                                                    bool IsDelete);\n  bool SemaBuiltinConstantArg(CallExpr *TheCall, int ArgNum,\n                              llvm::APSInt &Result);\n  bool SemaBuiltinConstantArgRange(CallExpr *TheCall, int ArgNum, int Low,\n                                   int High, bool RangeIsError = true);\n  bool SemaBuiltinConstantArgMultiple(CallExpr *TheCall, int ArgNum,\n                                      unsigned Multiple);\n  bool SemaBuiltinConstantArgPower2(CallExpr *TheCall, int ArgNum);\n  bool SemaBuiltinConstantArgShiftedByte(CallExpr *TheCall, int ArgNum,\n                                         unsigned ArgBits);\n  bool SemaBuiltinConstantArgShiftedByteOrXXFF(CallExpr *TheCall, int ArgNum,\n                                               unsigned ArgBits);\n  bool SemaBuiltinARMSpecialReg(unsigned BuiltinID, CallExpr *TheCall,\n                                int ArgNum, unsigned ExpectedFieldNum,\n                                bool AllowName);\n  bool SemaBuiltinARMMemoryTaggingCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool SemaBuiltinPPCMMACall(CallExpr *TheCall, const char *TypeDesc);\n\n  bool CheckPPCMMAType(QualType Type, SourceLocation TypeLoc);\n\n  // Matrix builtin handling.\n  ExprResult SemaBuiltinMatrixTranspose(CallExpr *TheCall,\n                                        ExprResult CallResult);\n  ExprResult SemaBuiltinMatrixColumnMajorLoad(CallExpr *TheCall,\n                                              ExprResult CallResult);\n  ExprResult SemaBuiltinMatrixColumnMajorStore(CallExpr *TheCall,\n                                               ExprResult CallResult);\n\npublic:\n  enum FormatStringType {\n    FST_Scanf,\n    FST_Printf,\n    FST_NSString,\n    FST_Strftime,\n    FST_Strfmon,\n    FST_Kprintf,\n    FST_FreeBSDKPrintf,\n    FST_OSTrace,\n    FST_OSLog,\n    FST_Unknown\n  };\n  static FormatStringType GetFormatStringType(const FormatAttr *Format);\n\n  bool FormatStringHasSArg(const StringLiteral *FExpr);\n\n  static bool GetFormatNSStringIdx(const FormatAttr *Format, unsigned &Idx);\n\nprivate:\n  bool CheckFormatArguments(const FormatAttr *Format,\n                            ArrayRef<const Expr *> Args,\n                            bool IsCXXMember,\n                            VariadicCallType CallType,\n                            SourceLocation Loc, SourceRange Range,\n                            llvm::SmallBitVector &CheckedVarArgs);\n  bool CheckFormatArguments(ArrayRef<const Expr *> Args,\n                            bool HasVAListArg, unsigned format_idx,\n                            unsigned firstDataArg, FormatStringType Type,\n                            VariadicCallType CallType,\n                            SourceLocation Loc, SourceRange range,\n                            llvm::SmallBitVector &CheckedVarArgs);\n\n  void CheckAbsoluteValueFunction(const CallExpr *Call,\n                                  const FunctionDecl *FDecl);\n\n  void CheckMaxUnsignedZero(const CallExpr *Call, const FunctionDecl *FDecl);\n\n  void CheckMemaccessArguments(const CallExpr *Call,\n                               unsigned BId,\n                               IdentifierInfo *FnName);\n\n  void CheckStrlcpycatArguments(const CallExpr *Call,\n                                IdentifierInfo *FnName);\n\n  void CheckStrncatArguments(const CallExpr *Call,\n                             IdentifierInfo *FnName);\n\n  void CheckFreeArguments(const CallExpr *E);\n\n  void CheckReturnValExpr(Expr *RetValExp, QualType lhsType,\n                          SourceLocation ReturnLoc,\n                          bool isObjCMethod = false,\n                          const AttrVec *Attrs = nullptr,\n                          const FunctionDecl *FD = nullptr);\n\npublic:\n  void CheckFloatComparison(SourceLocation Loc, Expr *LHS, Expr *RHS);\n\nprivate:\n  void CheckImplicitConversions(Expr *E, SourceLocation CC = SourceLocation());\n  void CheckBoolLikeConversion(Expr *E, SourceLocation CC);\n  void CheckForIntOverflow(Expr *E);\n  void CheckUnsequencedOperations(const Expr *E);\n\n  /// Perform semantic checks on a completed expression. This will either\n  /// be a full-expression or a default argument expression.\n  void CheckCompletedExpr(Expr *E, SourceLocation CheckLoc = SourceLocation(),\n                          bool IsConstexpr = false);\n\n  void CheckBitFieldInitialization(SourceLocation InitLoc, FieldDecl *Field,\n                                   Expr *Init);\n\n  /// Check if there is a field shadowing.\n  void CheckShadowInheritedFields(const SourceLocation &Loc,\n                                  DeclarationName FieldName,\n                                  const CXXRecordDecl *RD,\n                                  bool DeclIsField = true);\n\n  /// Check if the given expression contains 'break' or 'continue'\n  /// statement that produces control flow different from GCC.\n  void CheckBreakContinueBinding(Expr *E);\n\n  /// Check whether receiver is mutable ObjC container which\n  /// attempts to add itself into the container\n  void CheckObjCCircularContainer(ObjCMessageExpr *Message);\n\n  void CheckTCBEnforcement(const CallExpr *TheCall, const FunctionDecl *Callee);\n\n  void AnalyzeDeleteExprMismatch(const CXXDeleteExpr *DE);\n  void AnalyzeDeleteExprMismatch(FieldDecl *Field, SourceLocation DeleteLoc,\n                                 bool DeleteWasArrayForm);\npublic:\n  /// Register a magic integral constant to be used as a type tag.\n  void RegisterTypeTagForDatatype(const IdentifierInfo *ArgumentKind,\n                                  uint64_t MagicValue, QualType Type,\n                                  bool LayoutCompatible, bool MustBeNull);\n\n  struct TypeTagData {\n    TypeTagData() {}\n\n    TypeTagData(QualType Type, bool LayoutCompatible, bool MustBeNull) :\n        Type(Type), LayoutCompatible(LayoutCompatible),\n        MustBeNull(MustBeNull)\n    {}\n\n    QualType Type;\n\n    /// If true, \\c Type should be compared with other expression's types for\n    /// layout-compatibility.\n    unsigned LayoutCompatible : 1;\n    unsigned MustBeNull : 1;\n  };\n\n  /// A pair of ArgumentKind identifier and magic value.  This uniquely\n  /// identifies the magic value.\n  typedef std::pair<const IdentifierInfo *, uint64_t> TypeTagMagicValue;\n\nprivate:\n  /// A map from magic value to type information.\n  std::unique_ptr<llvm::DenseMap<TypeTagMagicValue, TypeTagData>>\n      TypeTagForDatatypeMagicValues;\n\n  /// Peform checks on a call of a function with argument_with_type_tag\n  /// or pointer_with_type_tag attributes.\n  void CheckArgumentWithTypeTag(const ArgumentWithTypeTagAttr *Attr,\n                                const ArrayRef<const Expr *> ExprArgs,\n                                SourceLocation CallSiteLoc);\n\n  /// Check if we are taking the address of a packed field\n  /// as this may be a problem if the pointer value is dereferenced.\n  void CheckAddressOfPackedMember(Expr *rhs);\n\n  /// The parser's current scope.\n  ///\n  /// The parser maintains this state here.\n  Scope *CurScope;\n\n  mutable IdentifierInfo *Ident_super;\n  mutable IdentifierInfo *Ident___float128;\n\n  /// Nullability type specifiers.\n  IdentifierInfo *Ident__Nonnull = nullptr;\n  IdentifierInfo *Ident__Nullable = nullptr;\n  IdentifierInfo *Ident__Nullable_result = nullptr;\n  IdentifierInfo *Ident__Null_unspecified = nullptr;\n\n  IdentifierInfo *Ident_NSError = nullptr;\n\n  /// The handler for the FileChanged preprocessor events.\n  ///\n  /// Used for diagnostics that implement custom semantic analysis for #include\n  /// directives, like -Wpragma-pack.\n  sema::SemaPPCallbacks *SemaPPCallbackHandler;\n\nprotected:\n  friend class Parser;\n  friend class InitializationSequence;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTWriter;\n\npublic:\n  /// Retrieve the keyword associated\n  IdentifierInfo *getNullabilityKeyword(NullabilityKind nullability);\n\n  /// The struct behind the CFErrorRef pointer.\n  RecordDecl *CFError = nullptr;\n  bool isCFError(RecordDecl *D);\n\n  /// Retrieve the identifier \"NSError\".\n  IdentifierInfo *getNSErrorIdent();\n\n  /// Retrieve the parser's current scope.\n  ///\n  /// This routine must only be used when it is certain that semantic analysis\n  /// and the parser are in precisely the same context, which is not the case\n  /// when, e.g., we are performing any kind of template instantiation.\n  /// Therefore, the only safe places to use this scope are in the parser\n  /// itself and in routines directly invoked from the parser and *never* from\n  /// template substitution or instantiation.\n  Scope *getCurScope() const { return CurScope; }\n\n  void incrementMSManglingNumber() const {\n    return CurScope->incrementMSManglingNumber();\n  }\n\n  IdentifierInfo *getSuperIdentifier() const;\n  IdentifierInfo *getFloat128Identifier() const;\n\n  Decl *getObjCDeclContext() const;\n\n  DeclContext *getCurLexicalContext() const {\n    return OriginalLexicalContext ? OriginalLexicalContext : CurContext;\n  }\n\n  const DeclContext *getCurObjCLexicalContext() const {\n    const DeclContext *DC = getCurLexicalContext();\n    // A category implicitly has the attribute of the interface.\n    if (const ObjCCategoryDecl *CatD = dyn_cast<ObjCCategoryDecl>(DC))\n      DC = CatD->getClassInterface();\n    return DC;\n  }\n\n  /// Determine the number of levels of enclosing template parameters. This is\n  /// only usable while parsing. Note that this does not include dependent\n  /// contexts in which no template parameters have yet been declared, such as\n  /// in a terse function template or generic lambda before the first 'auto' is\n  /// encountered.\n  unsigned getTemplateDepth(Scope *S) const;\n\n  /// To be used for checking whether the arguments being passed to\n  /// function exceeds the number of parameters expected for it.\n  static bool TooManyArguments(size_t NumParams, size_t NumArgs,\n                               bool PartialOverloading = false) {\n    // We check whether we're just after a comma in code-completion.\n    if (NumArgs > 0 && PartialOverloading)\n      return NumArgs + 1 > NumParams; // If so, we view as an extra argument.\n    return NumArgs > NumParams;\n  }\n\n  // Emitting members of dllexported classes is delayed until the class\n  // (including field initializers) is fully parsed.\n  SmallVector<CXXRecordDecl*, 4> DelayedDllExportClasses;\n  SmallVector<CXXMethodDecl*, 4> DelayedDllExportMemberFunctions;\n\nprivate:\n  int ParsingClassDepth = 0;\n\n  class SavePendingParsedClassStateRAII {\n  public:\n    SavePendingParsedClassStateRAII(Sema &S) : S(S) { swapSavedState(); }\n\n    ~SavePendingParsedClassStateRAII() {\n      assert(S.DelayedOverridingExceptionSpecChecks.empty() &&\n             \"there shouldn't be any pending delayed exception spec checks\");\n      assert(S.DelayedEquivalentExceptionSpecChecks.empty() &&\n             \"there shouldn't be any pending delayed exception spec checks\");\n      swapSavedState();\n    }\n\n  private:\n    Sema &S;\n    decltype(DelayedOverridingExceptionSpecChecks)\n        SavedOverridingExceptionSpecChecks;\n    decltype(DelayedEquivalentExceptionSpecChecks)\n        SavedEquivalentExceptionSpecChecks;\n\n    void swapSavedState() {\n      SavedOverridingExceptionSpecChecks.swap(\n          S.DelayedOverridingExceptionSpecChecks);\n      SavedEquivalentExceptionSpecChecks.swap(\n          S.DelayedEquivalentExceptionSpecChecks);\n    }\n  };\n\n  /// Helper class that collects misaligned member designations and\n  /// their location info for delayed diagnostics.\n  struct MisalignedMember {\n    Expr *E;\n    RecordDecl *RD;\n    ValueDecl *MD;\n    CharUnits Alignment;\n\n    MisalignedMember() : E(), RD(), MD(), Alignment() {}\n    MisalignedMember(Expr *E, RecordDecl *RD, ValueDecl *MD,\n                     CharUnits Alignment)\n        : E(E), RD(RD), MD(MD), Alignment(Alignment) {}\n    explicit MisalignedMember(Expr *E)\n        : MisalignedMember(E, nullptr, nullptr, CharUnits()) {}\n\n    bool operator==(const MisalignedMember &m) { return this->E == m.E; }\n  };\n  /// Small set of gathered accesses to potentially misaligned members\n  /// due to the packed attribute.\n  SmallVector<MisalignedMember, 4> MisalignedMembers;\n\n  /// Adds an expression to the set of gathered misaligned members.\n  void AddPotentialMisalignedMembers(Expr *E, RecordDecl *RD, ValueDecl *MD,\n                                     CharUnits Alignment);\n\npublic:\n  /// Diagnoses the current set of gathered accesses. This typically\n  /// happens at full expression level. The set is cleared after emitting the\n  /// diagnostics.\n  void DiagnoseMisalignedMembers();\n\n  /// This function checks if the expression is in the sef of potentially\n  /// misaligned members and it is converted to some pointer type T with lower\n  /// or equal alignment requirements. If so it removes it. This is used when\n  /// we do not want to diagnose such misaligned access (e.g. in conversions to\n  /// void*).\n  void DiscardMisalignedMemberAddress(const Type *T, Expr *E);\n\n  /// This function calls Action when it determines that E designates a\n  /// misaligned member due to the packed attribute. This is used to emit\n  /// local diagnostics like in reference binding.\n  void RefersToMemberWithReducedAlignment(\n      Expr *E,\n      llvm::function_ref<void(Expr *, RecordDecl *, FieldDecl *, CharUnits)>\n          Action);\n\n  /// Describes the reason a calling convention specification was ignored, used\n  /// for diagnostics.\n  enum class CallingConventionIgnoredReason {\n    ForThisTarget = 0,\n    VariadicFunction,\n    ConstructorDestructor,\n    BuiltinFunction\n  };\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurLexicalContext is a kernel function or it is known that the\n  ///   function will be emitted for the device, emits the diagnostics\n  ///   immediately.\n  /// - If CurLexicalContext is a function and we are compiling\n  ///   for the device, but we don't know that this function will be codegen'ed\n  ///   for devive yet, creates a diagnostic which is emitted if and when we\n  ///   realize that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  /// Diagnose __float128 type usage only from SYCL device code if the current\n  /// target doesn't support it\n  /// if (!S.Context.getTargetInfo().hasFloat128Type() &&\n  ///     S.getLangOpts().SYCLIsDevice)\n  ///   SYCLDiagIfDeviceCode(Loc, diag::err_type_unsupported) << \"__float128\";\n  SemaDiagnosticBuilder SYCLDiagIfDeviceCode(SourceLocation Loc,\n                                             unsigned DiagID);\n\n  /// Check whether we're allowed to call Callee from the current context.\n  ///\n  /// - If the call is never allowed in a semantically-correct program\n  ///   emits an error and returns false.\n  ///\n  /// - If the call is allowed in semantically-correct programs, but only if\n  ///   it's never codegen'ed, creates a deferred diagnostic to be emitted if\n  ///   and when the caller is codegen'ed, and returns true.\n  ///\n  /// - Otherwise, returns true without emitting any diagnostics.\n  ///\n  /// Adds Callee to DeviceCallGraph if we don't know if its caller will be\n  /// codegen'ed yet.\n  bool checkSYCLDeviceFunction(SourceLocation Loc, FunctionDecl *Callee);\n};\n\n/// RAII object that enters a new expression evaluation context.\nclass EnterExpressionEvaluationContext {\n  Sema &Actions;\n  bool Entered = true;\n\npublic:\n  EnterExpressionEvaluationContext(\n      Sema &Actions, Sema::ExpressionEvaluationContext NewContext,\n      Decl *LambdaContextDecl = nullptr,\n      Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =\n          Sema::ExpressionEvaluationContextRecord::EK_Other,\n      bool ShouldEnter = true)\n      : Actions(Actions), Entered(ShouldEnter) {\n    if (Entered)\n      Actions.PushExpressionEvaluationContext(NewContext, LambdaContextDecl,\n                                              ExprContext);\n  }\n  EnterExpressionEvaluationContext(\n      Sema &Actions, Sema::ExpressionEvaluationContext NewContext,\n      Sema::ReuseLambdaContextDecl_t,\n      Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =\n          Sema::ExpressionEvaluationContextRecord::EK_Other)\n      : Actions(Actions) {\n    Actions.PushExpressionEvaluationContext(\n        NewContext, Sema::ReuseLambdaContextDecl, ExprContext);\n  }\n\n  enum InitListTag { InitList };\n  EnterExpressionEvaluationContext(Sema &Actions, InitListTag,\n                                   bool ShouldEnter = true)\n      : Actions(Actions), Entered(false) {\n    // In C++11 onwards, narrowing checks are performed on the contents of\n    // braced-init-lists, even when they occur within unevaluated operands.\n    // Therefore we still need to instantiate constexpr functions used in such\n    // a context.\n    if (ShouldEnter && Actions.isUnevaluatedContext() &&\n        Actions.getLangOpts().CPlusPlus11) {\n      Actions.PushExpressionEvaluationContext(\n          Sema::ExpressionEvaluationContext::UnevaluatedList);\n      Entered = true;\n    }\n  }\n\n  ~EnterExpressionEvaluationContext() {\n    if (Entered)\n      Actions.PopExpressionEvaluationContext();\n  }\n};\n\nDeductionFailureInfo\nMakeDeductionFailureInfo(ASTContext &Context, Sema::TemplateDeductionResult TDK,\n                         sema::TemplateDeductionInfo &Info);\n\n/// Contains a late templated function.\n/// Will be parsed at the end of the translation unit, used by Sema & Parser.\nstruct LateParsedTemplate {\n  CachedTokens Toks;\n  /// The template function declaration to be late parsed.\n  Decl *D;\n};\n\ntemplate <>\nvoid Sema::PragmaStack<Sema::AlignPackInfo>::Act(SourceLocation PragmaLocation,\n                                                 PragmaMsStackAction Action,\n                                                 llvm::StringRef StackSlotLabel,\n                                                 AlignPackInfo Value);\n\n} // end namespace clang\n\nnamespace llvm {\n// Hash a FunctionDeclAndLoc by looking at both its FunctionDecl and its\n// SourceLocation.\ntemplate <> struct DenseMapInfo<clang::Sema::FunctionDeclAndLoc> {\n  using FunctionDeclAndLoc = clang::Sema::FunctionDeclAndLoc;\n  using FDBaseInfo = DenseMapInfo<clang::CanonicalDeclPtr<clang::FunctionDecl>>;\n\n  static FunctionDeclAndLoc getEmptyKey() {\n    return {FDBaseInfo::getEmptyKey(), clang::SourceLocation()};\n  }\n\n  static FunctionDeclAndLoc getTombstoneKey() {\n    return {FDBaseInfo::getTombstoneKey(), clang::SourceLocation()};\n  }\n\n  static unsigned getHashValue(const FunctionDeclAndLoc &FDL) {\n    return hash_combine(FDBaseInfo::getHashValue(FDL.FD),\n                        FDL.Loc.getHashValue());\n  }\n\n  static bool isEqual(const FunctionDeclAndLoc &LHS,\n                      const FunctionDeclAndLoc &RHS) {\n    return LHS.FD == RHS.FD && LHS.Loc == RHS.Loc;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "content": "//===- ASTReader.h - AST File Reader ----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTReader class, which reads AST files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_ASTREADER_H\n#define LLVM_CLANG_SERIALIZATION_ASTREADER_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Lex/ExternalPreprocessorSource.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/ModuleFile.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"clang/Serialization/ModuleManager.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <ctime>\n#include <deque>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTConsumer;\nclass ASTContext;\nclass ASTDeserializationListener;\nclass ASTReader;\nclass ASTRecordReader;\nclass CXXTemporary;\nclass Decl;\nclass DeclarationName;\nclass DeclaratorDecl;\nclass DeclContext;\nclass EnumDecl;\nclass Expr;\nclass FieldDecl;\nclass FileEntry;\nclass FileManager;\nclass FileSystemOptions;\nclass FunctionDecl;\nclass GlobalModuleIndex;\nstruct HeaderFileInfo;\nclass HeaderSearchOptions;\nclass LangOptions;\nclass LazyASTUnresolvedSet;\nclass MacroInfo;\nclass InMemoryModuleCache;\nclass NamedDecl;\nclass NamespaceDecl;\nclass ObjCCategoryDecl;\nclass ObjCInterfaceDecl;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nstruct QualifierInfo;\nclass Sema;\nclass SourceManager;\nclass Stmt;\nclass SwitchCase;\nclass TargetOptions;\nclass Token;\nclass TypedefNameDecl;\nclass ValueDecl;\nclass VarDecl;\n\n/// Abstract interface for callback invocations by the ASTReader.\n///\n/// While reading an AST file, the ASTReader will call the methods of the\n/// listener to pass on specific information. Some of the listener methods can\n/// return true to indicate to the ASTReader that the information (and\n/// consequently the AST file) is invalid.\nclass ASTReaderListener {\npublic:\n  virtual ~ASTReaderListener();\n\n  /// Receives the full Clang version information.\n  ///\n  /// \\returns true to indicate that the version is invalid. Subclasses should\n  /// generally defer to this implementation.\n  virtual bool ReadFullVersionInformation(StringRef FullVersion) {\n    return FullVersion != getClangFullRepositoryVersion();\n  }\n\n  virtual void ReadModuleName(StringRef ModuleName) {}\n  virtual void ReadModuleMapFile(StringRef ModuleMapPath) {}\n\n  /// Receives the language options.\n  ///\n  /// \\returns true to indicate the options are invalid or false otherwise.\n  virtual bool ReadLanguageOptions(const LangOptions &LangOpts,\n                                   bool Complain,\n                                   bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the target options.\n  ///\n  /// \\returns true to indicate the target options are invalid, or false\n  /// otherwise.\n  virtual bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                                 bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the diagnostic options.\n  ///\n  /// \\returns true to indicate the diagnostic options are invalid, or false\n  /// otherwise.\n  virtual bool\n  ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                        bool Complain) {\n    return false;\n  }\n\n  /// Receives the file system options.\n  ///\n  /// \\returns true to indicate the file system options are invalid, or false\n  /// otherwise.\n  virtual bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                                     bool Complain) {\n    return false;\n  }\n\n  /// Receives the header search options.\n  ///\n  /// \\returns true to indicate the header search options are invalid, or false\n  /// otherwise.\n  virtual bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                                       StringRef SpecificModuleCachePath,\n                                       bool Complain) {\n    return false;\n  }\n\n  /// Receives the preprocessor options.\n  ///\n  /// \\param SuggestedPredefines Can be filled in with the set of predefines\n  /// that are suggested by the preprocessor options. Typically only used when\n  /// loading a precompiled header.\n  ///\n  /// \\returns true to indicate the preprocessor options are invalid, or false\n  /// otherwise.\n  virtual bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                                       bool Complain,\n                                       std::string &SuggestedPredefines) {\n    return false;\n  }\n\n  /// Receives __COUNTER__ value.\n  virtual void ReadCounter(const serialization::ModuleFile &M,\n                           unsigned Value) {}\n\n  /// This is called for each AST file loaded.\n  virtual void visitModuleFile(StringRef Filename,\n                               serialization::ModuleKind Kind) {}\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsInputFileVisitation() { return false; }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// system input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsSystemInputFileVisitation() { return false; }\n\n  /// if \\c needsInputFileVisitation returns true, this is called for\n  /// each non-system input file of the AST File. If\n  /// \\c needsSystemInputFileVisitation is true, then it is called for all\n  /// system input files as well.\n  ///\n  /// \\returns true to continue receiving the next input file, false to stop.\n  virtual bool visitInputFile(StringRef Filename, bool isSystem,\n                              bool isOverridden, bool isExplicitModule) {\n    return true;\n  }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// imports of the AST file via \\c visitImport, false otherwise.\n  virtual bool needsImportVisitation() const { return false; }\n\n  /// If needsImportVisitation returns \\c true, this is called for each\n  /// AST file imported by this AST file.\n  virtual void visitImport(StringRef ModuleName, StringRef Filename) {}\n\n  /// Indicates that a particular module file extension has been read.\n  virtual void readModuleFileExtension(\n                 const ModuleFileExtensionMetadata &Metadata) {}\n};\n\n/// Simple wrapper class for chaining listeners.\nclass ChainedASTReaderListener : public ASTReaderListener {\n  std::unique_ptr<ASTReaderListener> First;\n  std::unique_ptr<ASTReaderListener> Second;\n\npublic:\n  /// Takes ownership of \\p First and \\p Second.\n  ChainedASTReaderListener(std::unique_ptr<ASTReaderListener> First,\n                           std::unique_ptr<ASTReaderListener> Second)\n      : First(std::move(First)), Second(std::move(Second)) {}\n\n  std::unique_ptr<ASTReaderListener> takeFirst() { return std::move(First); }\n  std::unique_ptr<ASTReaderListener> takeSecond() { return std::move(Second); }\n\n  bool ReadFullVersionInformation(StringRef FullVersion) override;\n  void ReadModuleName(StringRef ModuleName) override;\n  void ReadModuleMapFile(StringRef ModuleMapPath) override;\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                             bool Complain) override;\n\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                               bool Complain,\n                               std::string &SuggestedPredefines) override;\n\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n  bool needsInputFileVisitation() override;\n  bool needsSystemInputFileVisitation() override;\n  void visitModuleFile(StringRef Filename,\n                       serialization::ModuleKind Kind) override;\n  bool visitInputFile(StringRef Filename, bool isSystem,\n                      bool isOverridden, bool isExplicitModule) override;\n  void readModuleFileExtension(\n         const ModuleFileExtensionMetadata &Metadata) override;\n};\n\n/// ASTReaderListener implementation to validate the information of\n/// the PCH file against an initialized Preprocessor.\nclass PCHValidator : public ASTReaderListener {\n  Preprocessor &PP;\n  ASTReader &Reader;\n\npublic:\n  PCHValidator(Preprocessor &PP, ASTReader &Reader)\n      : PP(PP), Reader(Reader) {}\n\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n\nprivate:\n  void Error(const char *Msg);\n};\n\n/// ASTReaderListenter implementation to set SuggestedPredefines of\n/// ASTReader which is required to use a pch file. This is the replacement\n/// of PCHValidator or SimplePCHValidator when using a pch file without\n/// validating it.\nclass SimpleASTReaderListener : public ASTReaderListener {\n  Preprocessor &PP;\n\npublic:\n  SimpleASTReaderListener(Preprocessor &PP) : PP(PP) {}\n\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n};\n\nnamespace serialization {\n\nclass ReadMethodPoolVisitor;\n\nnamespace reader {\n\nclass ASTIdentifierLookupTrait;\n\n/// The on-disk hash table(s) used for DeclContext name lookup.\nstruct DeclContextLookupTable;\n\n} // namespace reader\n\n} // namespace serialization\n\n/// Reads an AST files chain containing the contents of a translation\n/// unit.\n///\n/// The ASTReader class reads bitstreams (produced by the ASTWriter\n/// class) containing the serialized representation of a given\n/// abstract syntax tree and its supporting data structures. An\n/// instance of the ASTReader can be attached to an ASTContext object,\n/// which will provide access to the contents of the AST files.\n///\n/// The AST reader provides lazy de-serialization of declarations, as\n/// required when traversing the AST. Only those AST nodes that are\n/// actually required will be de-serialized.\nclass ASTReader\n  : public ExternalPreprocessorSource,\n    public ExternalPreprocessingRecordSource,\n    public ExternalHeaderFileInfoSource,\n    public ExternalSemaSource,\n    public IdentifierInfoLookup,\n    public ExternalSLocEntrySource\n{\npublic:\n  /// Types of AST files.\n  friend class ASTDeclReader;\n  friend class ASTIdentifierIterator;\n  friend class ASTRecordReader;\n  friend class ASTUnit; // ASTUnit needs to remap source locations.\n  friend class ASTWriter;\n  friend class PCHValidator;\n  friend class serialization::reader::ASTIdentifierLookupTrait;\n  friend class serialization::ReadMethodPoolVisitor;\n  friend class TypeLocReader;\n\n  using RecordData = SmallVector<uint64_t, 64>;\n  using RecordDataImpl = SmallVectorImpl<uint64_t>;\n\n  /// The result of reading the control block of an AST file, which\n  /// can fail for various reasons.\n  enum ASTReadResult {\n    /// The control block was read successfully. Aside from failures,\n    /// the AST file is safe to read into the current context.\n    Success,\n\n    /// The AST file itself appears corrupted.\n    Failure,\n\n    /// The AST file was missing.\n    Missing,\n\n    /// The AST file is out-of-date relative to its input files,\n    /// and needs to be regenerated.\n    OutOfDate,\n\n    /// The AST file was written by a different version of Clang.\n    VersionMismatch,\n\n    /// The AST file was writtten with a different language/target\n    /// configuration.\n    ConfigurationMismatch,\n\n    /// The AST file has errors.\n    HadErrors\n  };\n\n  using ModuleFile = serialization::ModuleFile;\n  using ModuleKind = serialization::ModuleKind;\n  using ModuleManager = serialization::ModuleManager;\n  using ModuleIterator = ModuleManager::ModuleIterator;\n  using ModuleConstIterator = ModuleManager::ModuleConstIterator;\n  using ModuleReverseIterator = ModuleManager::ModuleReverseIterator;\n\nprivate:\n  /// The receiver of some callbacks invoked by ASTReader.\n  std::unique_ptr<ASTReaderListener> Listener;\n\n  /// The receiver of deserialization events.\n  ASTDeserializationListener *DeserializationListener = nullptr;\n\n  bool OwnsDeserializationListener = false;\n\n  SourceManager &SourceMgr;\n  FileManager &FileMgr;\n  const PCHContainerReader &PCHContainerRdr;\n  DiagnosticsEngine &Diags;\n\n  /// The semantic analysis object that will be processing the\n  /// AST files and the translation unit that uses it.\n  Sema *SemaObj = nullptr;\n\n  /// The preprocessor that will be loading the source file.\n  Preprocessor &PP;\n\n  /// The AST context into which we'll read the AST files.\n  ASTContext *ContextObj = nullptr;\n\n  /// The AST consumer.\n  ASTConsumer *Consumer = nullptr;\n\n  /// The module manager which manages modules and their dependencies\n  ModuleManager ModuleMgr;\n\n  /// A dummy identifier resolver used to merge TU-scope declarations in\n  /// C, for the cases where we don't have a Sema object to provide a real\n  /// identifier resolver.\n  IdentifierResolver DummyIdResolver;\n\n  /// A mapping from extension block names to module file extensions.\n  llvm::StringMap<std::shared_ptr<ModuleFileExtension>> ModuleFileExtensions;\n\n  /// A timer used to track the time spent deserializing.\n  std::unique_ptr<llvm::Timer> ReadTimer;\n\n  /// The location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  SourceLocation CurrentImportLoc;\n\n  /// The module kind that is currently deserializing.\n  Optional<ModuleKind> CurrentDeserializingModuleKind;\n\n  /// The global module index, if loaded.\n  std::unique_ptr<GlobalModuleIndex> GlobalIndex;\n\n  /// A map of global bit offsets to the module that stores entities\n  /// at those bit offsets.\n  ContinuousRangeMap<uint64_t, ModuleFile*, 4> GlobalBitOffsetsMap;\n\n  /// A map of negated SLocEntryIDs to the modules containing them.\n  ContinuousRangeMap<unsigned, ModuleFile*, 64> GlobalSLocEntryMap;\n\n  using GlobalSLocOffsetMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 64>;\n\n  /// A map of reversed (SourceManager::MaxLoadedOffset - SLocOffset)\n  /// SourceLocation offsets to the modules containing them.\n  GlobalSLocOffsetMapType GlobalSLocOffsetMap;\n\n  /// Types that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the type with\n  /// ID = (I + 1) << FastQual::Width has already been loaded\n  std::vector<QualType> TypesLoaded;\n\n  using GlobalTypeMapType =\n      ContinuousRangeMap<serialization::TypeID, ModuleFile *, 4>;\n\n  /// Mapping from global type IDs to the module in which the\n  /// type resides along with the offset that should be added to the\n  /// global type ID to produce a local ID.\n  GlobalTypeMapType GlobalTypeMap;\n\n  /// Declarations that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the declaration with ID\n  /// = I + 1 has already been loaded.\n  std::vector<Decl *> DeclsLoaded;\n\n  using GlobalDeclMapType =\n      ContinuousRangeMap<serialization::DeclID, ModuleFile *, 4>;\n\n  /// Mapping from global declaration IDs to the module in which the\n  /// declaration resides.\n  GlobalDeclMapType GlobalDeclMap;\n\n  using FileOffset = std::pair<ModuleFile *, uint64_t>;\n  using FileOffsetsTy = SmallVector<FileOffset, 2>;\n  using DeclUpdateOffsetsMap =\n      llvm::DenseMap<serialization::DeclID, FileOffsetsTy>;\n\n  /// Declarations that have modifications residing in a later file\n  /// in the chain.\n  DeclUpdateOffsetsMap DeclUpdateOffsets;\n\n  struct PendingUpdateRecord {\n    Decl *D;\n    serialization::GlobalDeclID ID;\n\n    // Whether the declaration was just deserialized.\n    bool JustLoaded;\n\n    PendingUpdateRecord(serialization::GlobalDeclID ID, Decl *D,\n                        bool JustLoaded)\n        : D(D), ID(ID), JustLoaded(JustLoaded) {}\n  };\n\n  /// Declaration updates for already-loaded declarations that we need\n  /// to apply once we finish processing an import.\n  llvm::SmallVector<PendingUpdateRecord, 16> PendingUpdateRecords;\n\n  enum class PendingFakeDefinitionKind { NotFake, Fake, FakeLoaded };\n\n  /// The DefinitionData pointers that we faked up for class definitions\n  /// that we needed but hadn't loaded yet.\n  llvm::DenseMap<void *, PendingFakeDefinitionKind> PendingFakeDefinitionData;\n\n  /// Exception specification updates that have been loaded but not yet\n  /// propagated across the relevant redeclaration chain. The map key is the\n  /// canonical declaration (used only for deduplication) and the value is a\n  /// declaration that has an exception specification.\n  llvm::SmallMapVector<Decl *, FunctionDecl *, 4> PendingExceptionSpecUpdates;\n\n  /// Deduced return type updates that have been loaded but not yet propagated\n  /// across the relevant redeclaration chain. The map key is the canonical\n  /// declaration and the value is the deduced return type.\n  llvm::SmallMapVector<FunctionDecl *, QualType, 4> PendingDeducedTypeUpdates;\n\n  /// Declarations that have been imported and have typedef names for\n  /// linkage purposes.\n  llvm::DenseMap<std::pair<DeclContext *, IdentifierInfo *>, NamedDecl *>\n      ImportedTypedefNamesForLinkage;\n\n  /// Mergeable declaration contexts that have anonymous declarations\n  /// within them, and those anonymous declarations.\n  llvm::DenseMap<Decl*, llvm::SmallVector<NamedDecl*, 2>>\n    AnonymousDeclarationsForMerging;\n\n  /// Key used to identify LifetimeExtendedTemporaryDecl for merging,\n  /// containing the lifetime-extending declaration and the mangling number.\n  using LETemporaryKey = std::pair<Decl *, unsigned>;\n\n  /// Map of already deserialiazed temporaries.\n  llvm::DenseMap<LETemporaryKey, LifetimeExtendedTemporaryDecl *>\n      LETemporaryForMerging;\n\n  struct FileDeclsInfo {\n    ModuleFile *Mod = nullptr;\n    ArrayRef<serialization::LocalDeclID> Decls;\n\n    FileDeclsInfo() = default;\n    FileDeclsInfo(ModuleFile *Mod, ArrayRef<serialization::LocalDeclID> Decls)\n        : Mod(Mod), Decls(Decls) {}\n  };\n\n  /// Map from a FileID to the file-level declarations that it contains.\n  llvm::DenseMap<FileID, FileDeclsInfo> FileDeclIDs;\n\n  /// An array of lexical contents of a declaration context, as a sequence of\n  /// Decl::Kind, DeclID pairs.\n  using LexicalContents = ArrayRef<llvm::support::unaligned_uint32_t>;\n\n  /// Map from a DeclContext to its lexical contents.\n  llvm::DenseMap<const DeclContext*, std::pair<ModuleFile*, LexicalContents>>\n      LexicalDecls;\n\n  /// Map from the TU to its lexical contents from each module file.\n  std::vector<std::pair<ModuleFile*, LexicalContents>> TULexicalDecls;\n\n  /// Map from a DeclContext to its lookup tables.\n  llvm::DenseMap<const DeclContext *,\n                 serialization::reader::DeclContextLookupTable> Lookups;\n\n  // Updates for visible decls can occur for other contexts than just the\n  // TU, and when we read those update records, the actual context may not\n  // be available yet, so have this pending map using the ID as a key. It\n  // will be realized when the context is actually loaded.\n  struct PendingVisibleUpdate {\n    ModuleFile *Mod;\n    const unsigned char *Data;\n  };\n  using DeclContextVisibleUpdates = SmallVector<PendingVisibleUpdate, 1>;\n\n  /// Updates to the visible declarations of declaration contexts that\n  /// haven't been loaded yet.\n  llvm::DenseMap<serialization::DeclID, DeclContextVisibleUpdates>\n      PendingVisibleUpdates;\n\n  /// The set of C++ or Objective-C classes that have forward\n  /// declarations that have not yet been linked to their definitions.\n  llvm::SmallPtrSet<Decl *, 4> PendingDefinitions;\n\n  using PendingBodiesMap =\n      llvm::MapVector<Decl *, uint64_t,\n                      llvm::SmallDenseMap<Decl *, unsigned, 4>,\n                      SmallVector<std::pair<Decl *, uint64_t>, 4>>;\n\n  /// Functions or methods that have bodies that will be attached.\n  PendingBodiesMap PendingBodies;\n\n  /// Definitions for which we have added merged definitions but not yet\n  /// performed deduplication.\n  llvm::SetVector<NamedDecl *> PendingMergedDefinitionsToDeduplicate;\n\n  /// Read the record that describes the lexical contents of a DC.\n  bool ReadLexicalDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, DeclContext *DC);\n\n  /// Read the record that describes the visible contents of a DC.\n  bool ReadVisibleDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, serialization::DeclID ID);\n\n  /// A vector containing identifiers that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// IdentifierInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<IdentifierInfo *> IdentifiersLoaded;\n\n  using GlobalIdentifierMapType =\n      ContinuousRangeMap<serialization::IdentID, ModuleFile *, 4>;\n\n  /// Mapping from global identifier IDs to the module in which the\n  /// identifier resides along with the offset that should be added to the\n  /// global identifier ID to produce a local ID.\n  GlobalIdentifierMapType GlobalIdentifierMap;\n\n  /// A vector containing macros that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// MacroInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<MacroInfo *> MacrosLoaded;\n\n  using LoadedMacroInfo =\n      std::pair<IdentifierInfo *, serialization::SubmoduleID>;\n\n  /// A set of #undef directives that we have loaded; used to\n  /// deduplicate the same #undef information coming from multiple module\n  /// files.\n  llvm::DenseSet<LoadedMacroInfo> LoadedUndefs;\n\n  using GlobalMacroMapType =\n      ContinuousRangeMap<serialization::MacroID, ModuleFile *, 4>;\n\n  /// Mapping from global macro IDs to the module in which the\n  /// macro resides along with the offset that should be added to the\n  /// global macro ID to produce a local ID.\n  GlobalMacroMapType GlobalMacroMap;\n\n  /// A vector containing submodules that have already been loaded.\n  ///\n  /// This vector is indexed by the Submodule ID (-1). NULL submodule entries\n  /// indicate that the particular submodule ID has not yet been loaded.\n  SmallVector<Module *, 2> SubmodulesLoaded;\n\n  using GlobalSubmoduleMapType =\n      ContinuousRangeMap<serialization::SubmoduleID, ModuleFile *, 4>;\n\n  /// Mapping from global submodule IDs to the module file in which the\n  /// submodule resides along with the offset that should be added to the\n  /// global submodule ID to produce a local ID.\n  GlobalSubmoduleMapType GlobalSubmoduleMap;\n\n  /// A set of hidden declarations.\n  using HiddenNames = SmallVector<Decl *, 2>;\n  using HiddenNamesMapType = llvm::DenseMap<Module *, HiddenNames>;\n\n  /// A mapping from each of the hidden submodules to the deserialized\n  /// declarations in that submodule that could be made visible.\n  HiddenNamesMapType HiddenNamesMap;\n\n  /// A module import, export, or conflict that hasn't yet been resolved.\n  struct UnresolvedModuleRef {\n    /// The file in which this module resides.\n    ModuleFile *File;\n\n    /// The module that is importing or exporting.\n    Module *Mod;\n\n    /// The kind of module reference.\n    enum { Import, Export, Conflict } Kind;\n\n    /// The local ID of the module that is being exported.\n    unsigned ID;\n\n    /// Whether this is a wildcard export.\n    unsigned IsWildcard : 1;\n\n    /// String data.\n    StringRef String;\n  };\n\n  /// The set of module imports and exports that still need to be\n  /// resolved.\n  SmallVector<UnresolvedModuleRef, 2> UnresolvedModuleRefs;\n\n  /// A vector containing selectors that have already been loaded.\n  ///\n  /// This vector is indexed by the Selector ID (-1). NULL selector\n  /// entries indicate that the particular selector ID has not yet\n  /// been loaded.\n  SmallVector<Selector, 16> SelectorsLoaded;\n\n  using GlobalSelectorMapType =\n      ContinuousRangeMap<serialization::SelectorID, ModuleFile *, 4>;\n\n  /// Mapping from global selector IDs to the module in which the\n  /// global selector ID to produce a local ID.\n  GlobalSelectorMapType GlobalSelectorMap;\n\n  /// The generation number of the last time we loaded data from the\n  /// global method pool for this selector.\n  llvm::DenseMap<Selector, unsigned> SelectorGeneration;\n\n  /// Whether a selector is out of date. We mark a selector as out of date\n  /// if we load another module after the method pool entry was pulled in.\n  llvm::DenseMap<Selector, bool> SelectorOutOfDate;\n\n  struct PendingMacroInfo {\n    ModuleFile *M;\n    /// Offset relative to ModuleFile::MacroOffsetsBase.\n    uint32_t MacroDirectivesOffset;\n\n    PendingMacroInfo(ModuleFile *M, uint32_t MacroDirectivesOffset)\n        : M(M), MacroDirectivesOffset(MacroDirectivesOffset) {}\n  };\n\n  using PendingMacroIDsMap =\n      llvm::MapVector<IdentifierInfo *, SmallVector<PendingMacroInfo, 2>>;\n\n  /// Mapping from identifiers that have a macro history to the global\n  /// IDs have not yet been deserialized to the global IDs of those macros.\n  PendingMacroIDsMap PendingMacroIDs;\n\n  using GlobalPreprocessedEntityMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global preprocessing entity IDs to the module in\n  /// which the preprocessed entity resides along with the offset that should be\n  /// added to the global preprocessing entity ID to produce a local ID.\n  GlobalPreprocessedEntityMapType GlobalPreprocessedEntityMap;\n\n  using GlobalSkippedRangeMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global skipped range base IDs to the module in which\n  /// the skipped ranges reside.\n  GlobalSkippedRangeMapType GlobalSkippedRangeMap;\n\n  /// \\name CodeGen-relevant special data\n  /// Fields containing data that is relevant to CodeGen.\n  //@{\n\n  /// The IDs of all declarations that fulfill the criteria of\n  /// \"interesting\" decls.\n  ///\n  /// This contains the data loaded from all EAGERLY_DESERIALIZED_DECLS blocks\n  /// in the chain. The referenced declarations are deserialized and passed to\n  /// the consumer eagerly.\n  SmallVector<uint64_t, 16> EagerlyDeserializedDecls;\n\n  /// The IDs of all tentative definitions stored in the chain.\n  ///\n  /// Sema keeps track of all tentative definitions in a TU because it has to\n  /// complete them and pass them on to CodeGen. Thus, tentative definitions in\n  /// the PCH chain must be eagerly deserialized.\n  SmallVector<uint64_t, 16> TentativeDefinitions;\n\n  /// The IDs of all CXXRecordDecls stored in the chain whose VTables are\n  /// used.\n  ///\n  /// CodeGen has to emit VTables for these records, so they have to be eagerly\n  /// deserialized.\n  SmallVector<uint64_t, 64> VTableUses;\n\n  /// A snapshot of the pending instantiations in the chain.\n  ///\n  /// This record tracks the instantiations that Sema has to perform at the\n  /// end of the TU. It consists of a pair of values for every pending\n  /// instantiation where the first value is the ID of the decl and the second\n  /// is the instantiation location.\n  SmallVector<uint64_t, 64> PendingInstantiations;\n\n  //@}\n\n  /// \\name DiagnosticsEngine-relevant special data\n  /// Fields containing data that is used for generating diagnostics\n  //@{\n\n  /// A snapshot of Sema's unused file-scoped variable tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 16> UnusedFileScopedDecls;\n\n  /// A list of all the delegating constructors we've seen, to diagnose\n  /// cycles.\n  SmallVector<uint64_t, 4> DelegatingCtorDecls;\n\n  /// Method selectors used in a @selector expression. Used for\n  /// implementation of -Wselector.\n  SmallVector<uint64_t, 64> ReferencedSelectorsData;\n\n  /// A snapshot of Sema's weak undeclared identifier tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 64> WeakUndeclaredIdentifiers;\n\n  /// The IDs of type aliases for ext_vectors that exist in the chain.\n  ///\n  /// Used by Sema for finding sugared names for ext_vectors in diagnostics.\n  SmallVector<uint64_t, 4> ExtVectorDecls;\n\n  //@}\n\n  /// \\name Sema-relevant special data\n  /// Fields containing data that is used for semantic analysis\n  //@{\n\n  /// The IDs of all potentially unused typedef names in the chain.\n  ///\n  /// Sema tracks these to emit warnings.\n  SmallVector<uint64_t, 16> UnusedLocalTypedefNameCandidates;\n\n  /// Our current depth in #pragma cuda force_host_device begin/end\n  /// macros.\n  unsigned ForceCUDAHostDeviceDepth = 0;\n\n  /// The IDs of the declarations Sema stores directly.\n  ///\n  /// Sema tracks a few important decls, such as namespace std, directly.\n  SmallVector<uint64_t, 4> SemaDeclRefs;\n\n  /// The IDs of the types ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important types, such as va_list, directly.\n  SmallVector<uint64_t, 16> SpecialTypes;\n\n  /// The IDs of CUDA-specific declarations ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important decls, currently cudaConfigureCall,\n  /// directly.\n  SmallVector<uint64_t, 2> CUDASpecialDeclRefs;\n\n  /// The floating point pragma option settings.\n  SmallVector<uint64_t, 1> FPPragmaOptions;\n\n  /// The pragma clang optimize location (if the pragma state is \"off\").\n  SourceLocation OptimizeOffPragmaLocation;\n\n  /// The PragmaMSStructKind pragma ms_struct state if set, or -1.\n  int PragmaMSStructState = -1;\n\n  /// The PragmaMSPointersToMembersKind pragma pointers_to_members state.\n  int PragmaMSPointersToMembersState = -1;\n  SourceLocation PointersToMembersPragmaLocation;\n\n  /// The pragma float_control state.\n  Optional<FPOptionsOverride> FpPragmaCurrentValue;\n  SourceLocation FpPragmaCurrentLocation;\n  struct FpPragmaStackEntry {\n    FPOptionsOverride Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<FpPragmaStackEntry, 2> FpPragmaStack;\n  llvm::SmallVector<std::string, 2> FpPragmaStrings;\n\n  /// The pragma align/pack state.\n  Optional<Sema::AlignPackInfo> PragmaAlignPackCurrentValue;\n  SourceLocation PragmaAlignPackCurrentLocation;\n  struct PragmaAlignPackStackEntry {\n    Sema::AlignPackInfo Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<PragmaAlignPackStackEntry, 2> PragmaAlignPackStack;\n  llvm::SmallVector<std::string, 2> PragmaAlignPackStrings;\n\n  /// The OpenCL extension settings.\n  OpenCLOptions OpenCLExtensions;\n\n  /// Extensions required by an OpenCL type.\n  llvm::DenseMap<const Type *, std::set<std::string>> OpenCLTypeExtMap;\n\n  /// Extensions required by an OpenCL declaration.\n  llvm::DenseMap<const Decl *, std::set<std::string>> OpenCLDeclExtMap;\n\n  /// A list of the namespaces we've seen.\n  SmallVector<uint64_t, 4> KnownNamespaces;\n\n  /// A list of undefined decls with internal linkage followed by the\n  /// SourceLocation of a matching ODR-use.\n  SmallVector<uint64_t, 8> UndefinedButUsed;\n\n  /// Delete expressions to analyze at the end of translation unit.\n  SmallVector<uint64_t, 8> DelayedDeleteExprs;\n\n  // A list of late parsed template function data with their module files.\n  SmallVector<std::pair<ModuleFile *, SmallVector<uint64_t, 1>>, 4>\n      LateParsedTemplates;\n\n  /// The IDs of all decls to be checked for deferred diags.\n  ///\n  /// Sema tracks these to emit deferred diags.\n  SmallVector<uint64_t, 4> DeclsToCheckForDeferredDiags;\n\n\npublic:\n  struct ImportedSubmodule {\n    serialization::SubmoduleID ID;\n    SourceLocation ImportLoc;\n\n    ImportedSubmodule(serialization::SubmoduleID ID, SourceLocation ImportLoc)\n        : ID(ID), ImportLoc(ImportLoc) {}\n  };\n\nprivate:\n  /// A list of modules that were imported by precompiled headers or\n  /// any other non-module AST file.\n  SmallVector<ImportedSubmodule, 2> ImportedModules;\n  //@}\n\n  /// The system include root to be used when loading the\n  /// precompiled header.\n  std::string isysroot;\n\n  /// Whether to disable the normal validation performed on precompiled\n  /// headers and module files when they are loaded.\n  DisableValidationForModuleKind DisableValidationKind;\n\n  /// Whether to accept an AST file with compiler errors.\n  bool AllowASTWithCompilerErrors;\n\n  /// Whether to accept an AST file that has a different configuration\n  /// from the current compiler instance.\n  bool AllowConfigurationMismatch;\n\n  /// Whether validate system input files.\n  bool ValidateSystemInputs;\n\n  /// Whether validate headers and module maps using hash based on contents.\n  bool ValidateASTInputFilesContent;\n\n  /// Whether we are allowed to use the global module index.\n  bool UseGlobalIndex;\n\n  /// Whether we have tried loading the global module index yet.\n  bool TriedLoadingGlobalIndex = false;\n\n  ///Whether we are currently processing update records.\n  bool ProcessingUpdateRecords = false;\n\n  using SwitchCaseMapTy = llvm::DenseMap<unsigned, SwitchCase *>;\n\n  /// Mapping from switch-case IDs in the chain to switch-case statements\n  ///\n  /// Statements usually don't have IDs, but switch cases need them, so that the\n  /// switch statement can refer to them.\n  SwitchCaseMapTy SwitchCaseStmts;\n\n  SwitchCaseMapTy *CurrSwitchCaseStmts;\n\n  /// The number of source location entries de-serialized from\n  /// the PCH file.\n  unsigned NumSLocEntriesRead = 0;\n\n  /// The number of source location entries in the chain.\n  unsigned TotalNumSLocEntries = 0;\n\n  /// The number of statements (and expressions) de-serialized\n  /// from the chain.\n  unsigned NumStatementsRead = 0;\n\n  /// The total number of statements (and expressions) stored\n  /// in the chain.\n  unsigned TotalNumStatements = 0;\n\n  /// The number of macros de-serialized from the chain.\n  unsigned NumMacrosRead = 0;\n\n  /// The total number of macros stored in the chain.\n  unsigned TotalNumMacros = 0;\n\n  /// The number of lookups into identifier tables.\n  unsigned NumIdentifierLookups = 0;\n\n  /// The number of lookups into identifier tables that succeed.\n  unsigned NumIdentifierLookupHits = 0;\n\n  /// The number of selectors that have been read.\n  unsigned NumSelectorsRead = 0;\n\n  /// The number of method pool entries that have been read.\n  unsigned NumMethodPoolEntriesRead = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool.\n  unsigned NumMethodPoolLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool and found something.\n  unsigned NumMethodPoolHits = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module.\n  unsigned NumMethodPoolTableLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module and found something.\n  unsigned NumMethodPoolTableHits = 0;\n\n  /// The total number of method pool entries in the selector table.\n  unsigned TotalNumMethodPoolEntries = 0;\n\n  /// Number of lexical decl contexts read/total.\n  unsigned NumLexicalDeclContextsRead = 0, TotalLexicalDeclContexts = 0;\n\n  /// Number of visible decl contexts read/total.\n  unsigned NumVisibleDeclContextsRead = 0, TotalVisibleDeclContexts = 0;\n\n  /// Total size of modules, in bits, currently loaded\n  uint64_t TotalModulesSizeInBits = 0;\n\n  /// Number of Decl/types that are currently deserializing.\n  unsigned NumCurrentElementsDeserializing = 0;\n\n  /// Set true while we are in the process of passing deserialized\n  /// \"interesting\" decls to consumer inside FinishedDeserializing().\n  /// This is used as a guard to avoid recursively repeating the process of\n  /// passing decls to consumer.\n  bool PassingDeclsToConsumer = false;\n\n  /// The set of identifiers that were read while the AST reader was\n  /// (recursively) loading declarations.\n  ///\n  /// The declarations on the identifier chain for these identifiers will be\n  /// loaded once the recursive loading has completed.\n  llvm::MapVector<IdentifierInfo *, SmallVector<uint32_t, 4>>\n    PendingIdentifierInfos;\n\n  /// The set of lookup results that we have faked in order to support\n  /// merging of partially deserialized decls but that we have not yet removed.\n  llvm::SmallMapVector<IdentifierInfo *, SmallVector<NamedDecl*, 2>, 16>\n    PendingFakeLookupResults;\n\n  /// The generation number of each identifier, which keeps track of\n  /// the last time we loaded information about this identifier.\n  llvm::DenseMap<IdentifierInfo *, unsigned> IdentifierGeneration;\n\n  class InterestingDecl {\n    Decl *D;\n    bool DeclHasPendingBody;\n\n  public:\n    InterestingDecl(Decl *D, bool HasBody)\n        : D(D), DeclHasPendingBody(HasBody) {}\n\n    Decl *getDecl() { return D; }\n\n    /// Whether the declaration has a pending body.\n    bool hasPendingBody() { return DeclHasPendingBody; }\n  };\n\n  /// Contains declarations and definitions that could be\n  /// \"interesting\" to the ASTConsumer, when we get that AST consumer.\n  ///\n  /// \"Interesting\" declarations are those that have data that may\n  /// need to be emitted, such as inline function definitions or\n  /// Objective-C protocols.\n  std::deque<InterestingDecl> PotentiallyInterestingDecls;\n\n  /// The list of deduced function types that we have not yet read, because\n  /// they might contain a deduced return type that refers to a local type\n  /// declared within the function.\n  SmallVector<std::pair<FunctionDecl *, serialization::TypeID>, 16>\n      PendingFunctionTypes;\n\n  /// The list of redeclaration chains that still need to be\n  /// reconstructed, and the local offset to the corresponding list\n  /// of redeclarations.\n  SmallVector<std::pair<Decl *, uint64_t>, 16> PendingDeclChains;\n\n  /// The list of canonical declarations whose redeclaration chains\n  /// need to be marked as incomplete once we're done deserializing things.\n  SmallVector<Decl *, 16> PendingIncompleteDeclChains;\n\n  /// The Decl IDs for the Sema/Lexical DeclContext of a Decl that has\n  /// been loaded but its DeclContext was not set yet.\n  struct PendingDeclContextInfo {\n    Decl *D;\n    serialization::GlobalDeclID SemaDC;\n    serialization::GlobalDeclID LexicalDC;\n  };\n\n  /// The set of Decls that have been loaded but their DeclContexts are\n  /// not set yet.\n  ///\n  /// The DeclContexts for these Decls will be set once recursive loading has\n  /// been completed.\n  std::deque<PendingDeclContextInfo> PendingDeclContextInfos;\n\n  /// The set of NamedDecls that have been loaded, but are members of a\n  /// context that has been merged into another context where the corresponding\n  /// declaration is either missing or has not yet been loaded.\n  ///\n  /// We will check whether the corresponding declaration is in fact missing\n  /// once recursing loading has been completed.\n  llvm::SmallVector<NamedDecl *, 16> PendingOdrMergeChecks;\n\n  using DataPointers =\n      std::pair<CXXRecordDecl *, struct CXXRecordDecl::DefinitionData *>;\n\n  /// Record definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<CXXRecordDecl *, llvm::SmallVector<DataPointers, 2>, 2>\n      PendingOdrMergeFailures;\n\n  /// Function definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<FunctionDecl *, llvm::SmallVector<FunctionDecl *, 2>, 2>\n      PendingFunctionOdrMergeFailures;\n\n  /// Enum definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<EnumDecl *, llvm::SmallVector<EnumDecl *, 2>, 2>\n      PendingEnumOdrMergeFailures;\n\n  /// DeclContexts in which we have diagnosed an ODR violation.\n  llvm::SmallPtrSet<DeclContext*, 2> DiagnosedOdrMergeFailures;\n\n  /// The set of Objective-C categories that have been deserialized\n  /// since the last time the declaration chains were linked.\n  llvm::SmallPtrSet<ObjCCategoryDecl *, 16> CategoriesDeserialized;\n\n  /// The set of Objective-C class definitions that have already been\n  /// loaded, for which we will need to check for categories whenever a new\n  /// module is loaded.\n  SmallVector<ObjCInterfaceDecl *, 16> ObjCClassesLoaded;\n\n  using KeyDeclsMap =\n      llvm::DenseMap<Decl *, SmallVector<serialization::DeclID, 2>>;\n\n  /// A mapping from canonical declarations to the set of global\n  /// declaration IDs for key declaration that have been merged with that\n  /// canonical declaration. A key declaration is a formerly-canonical\n  /// declaration whose module did not import any other key declaration for that\n  /// entity. These are the IDs that we use as keys when finding redecl chains.\n  KeyDeclsMap KeyDecls;\n\n  /// A mapping from DeclContexts to the semantic DeclContext that we\n  /// are treating as the definition of the entity. This is used, for instance,\n  /// when merging implicit instantiations of class templates across modules.\n  llvm::DenseMap<DeclContext *, DeclContext *> MergedDeclContexts;\n\n  /// A mapping from canonical declarations of enums to their canonical\n  /// definitions. Only populated when using modules in C++.\n  llvm::DenseMap<EnumDecl *, EnumDecl *> EnumDefinitions;\n\n  /// When reading a Stmt tree, Stmt operands are placed in this stack.\n  SmallVector<Stmt *, 16> StmtStack;\n\n  /// What kind of records we are reading.\n  enum ReadingKind {\n    Read_None, Read_Decl, Read_Type, Read_Stmt\n  };\n\n  /// What kind of records we are reading.\n  ReadingKind ReadingKind = Read_None;\n\n  /// RAII object to change the reading kind.\n  class ReadingKindTracker {\n    ASTReader &Reader;\n    enum ReadingKind PrevKind;\n\n  public:\n    ReadingKindTracker(enum ReadingKind newKind, ASTReader &reader)\n        : Reader(reader), PrevKind(Reader.ReadingKind) {\n      Reader.ReadingKind = newKind;\n    }\n\n    ReadingKindTracker(const ReadingKindTracker &) = delete;\n    ReadingKindTracker &operator=(const ReadingKindTracker &) = delete;\n    ~ReadingKindTracker() { Reader.ReadingKind = PrevKind; }\n  };\n\n  /// RAII object to mark the start of processing updates.\n  class ProcessingUpdatesRAIIObj {\n    ASTReader &Reader;\n    bool PrevState;\n\n  public:\n    ProcessingUpdatesRAIIObj(ASTReader &reader)\n        : Reader(reader), PrevState(Reader.ProcessingUpdateRecords) {\n      Reader.ProcessingUpdateRecords = true;\n    }\n\n    ProcessingUpdatesRAIIObj(const ProcessingUpdatesRAIIObj &) = delete;\n    ProcessingUpdatesRAIIObj &\n    operator=(const ProcessingUpdatesRAIIObj &) = delete;\n    ~ProcessingUpdatesRAIIObj() { Reader.ProcessingUpdateRecords = PrevState; }\n  };\n\n  /// Suggested contents of the predefines buffer, after this\n  /// PCH file has been processed.\n  ///\n  /// In most cases, this string will be empty, because the predefines\n  /// buffer computed to build the PCH file will be identical to the\n  /// predefines buffer computed from the command line. However, when\n  /// there are differences that the PCH reader can work around, this\n  /// predefines buffer may contain additional definitions.\n  std::string SuggestedPredefines;\n\n  llvm::DenseMap<const Decl *, bool> DefinitionSource;\n\n  bool shouldDisableValidationForFile(const serialization::ModuleFile &M) const;\n\n  /// Reads a statement from the specified cursor.\n  Stmt *ReadStmtFromStream(ModuleFile &F);\n\n  struct InputFileInfo {\n    std::string Filename;\n    uint64_t ContentHash;\n    off_t StoredSize;\n    time_t StoredTime;\n    bool Overridden;\n    bool Transient;\n    bool TopLevelModuleMap;\n  };\n\n  /// Reads the stored information about an input file.\n  InputFileInfo readInputFileInfo(ModuleFile &F, unsigned ID);\n\n  /// Retrieve the file entry and 'overridden' bit for an input\n  /// file in the given module file.\n  serialization::InputFile getInputFile(ModuleFile &F, unsigned ID,\n                                        bool Complain = true);\n\npublic:\n  void ResolveImportedPath(ModuleFile &M, std::string &Filename);\n  static void ResolveImportedPath(std::string &Filename, StringRef Prefix);\n\n  /// Returns the first key declaration for the given declaration. This\n  /// is one that is formerly-canonical (or still canonical) and whose module\n  /// did not import any other key declaration of the entity.\n  Decl *getKeyDeclaration(Decl *D) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      return D;\n\n    auto I = KeyDecls.find(D);\n    if (I == KeyDecls.end() || I->second.empty())\n      return D;\n    return GetExistingDecl(I->second[0]);\n  }\n  const Decl *getKeyDeclaration(const Decl *D) {\n    return getKeyDeclaration(const_cast<Decl*>(D));\n  }\n\n  /// Run a callback on each imported key declaration of \\p D.\n  template <typename Fn>\n  void forEachImportedKeyDecl(const Decl *D, Fn Visit) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      Visit(D);\n\n    auto It = KeyDecls.find(const_cast<Decl*>(D));\n    if (It != KeyDecls.end())\n      for (auto ID : It->second)\n        Visit(GetExistingDecl(ID));\n  }\n\n  /// Get the loaded lookup tables for \\p Primary, if any.\n  const serialization::reader::DeclContextLookupTable *\n  getLoadedLookupTables(DeclContext *Primary) const;\n\nprivate:\n  struct ImportedModule {\n    ModuleFile *Mod;\n    ModuleFile *ImportedBy;\n    SourceLocation ImportLoc;\n\n    ImportedModule(ModuleFile *Mod,\n                   ModuleFile *ImportedBy,\n                   SourceLocation ImportLoc)\n        : Mod(Mod), ImportedBy(ImportedBy), ImportLoc(ImportLoc) {}\n  };\n\n  ASTReadResult ReadASTCore(StringRef FileName, ModuleKind Type,\n                            SourceLocation ImportLoc, ModuleFile *ImportedBy,\n                            SmallVectorImpl<ImportedModule> &Loaded,\n                            off_t ExpectedSize, time_t ExpectedModTime,\n                            ASTFileSignature ExpectedSignature,\n                            unsigned ClientLoadCapabilities);\n  ASTReadResult ReadControlBlock(ModuleFile &F,\n                                 SmallVectorImpl<ImportedModule> &Loaded,\n                                 const ModuleFile *ImportedBy,\n                                 unsigned ClientLoadCapabilities);\n  static ASTReadResult ReadOptionsBlock(\n      llvm::BitstreamCursor &Stream, unsigned ClientLoadCapabilities,\n      bool AllowCompatibleConfigurationMismatch, ASTReaderListener &Listener,\n      std::string &SuggestedPredefines);\n\n  /// Read the unhashed control block.\n  ///\n  /// This has no effect on \\c F.Stream, instead creating a fresh cursor from\n  /// \\c F.Data and reading ahead.\n  ASTReadResult readUnhashedControlBlock(ModuleFile &F, bool WasImportedBy,\n                                         unsigned ClientLoadCapabilities);\n\n  static ASTReadResult\n  readUnhashedControlBlockImpl(ModuleFile *F, llvm::StringRef StreamData,\n                               unsigned ClientLoadCapabilities,\n                               bool AllowCompatibleConfigurationMismatch,\n                               ASTReaderListener *Listener,\n                               bool ValidateDiagnosticOptions);\n\n  ASTReadResult ReadASTBlock(ModuleFile &F, unsigned ClientLoadCapabilities);\n  ASTReadResult ReadExtensionBlock(ModuleFile &F);\n  void ReadModuleOffsetMap(ModuleFile &F) const;\n  bool ParseLineTable(ModuleFile &F, const RecordData &Record);\n  bool ReadSourceManagerBlock(ModuleFile &F);\n  llvm::BitstreamCursor &SLocCursorForID(int ID);\n  SourceLocation getImportLocation(ModuleFile *F);\n  ASTReadResult ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,\n                                       const ModuleFile *ImportedBy,\n                                       unsigned ClientLoadCapabilities);\n  ASTReadResult ReadSubmoduleBlock(ModuleFile &F,\n                                   unsigned ClientLoadCapabilities);\n  static bool ParseLanguageOptions(const RecordData &Record, bool Complain,\n                                   ASTReaderListener &Listener,\n                                   bool AllowCompatibleDifferences);\n  static bool ParseTargetOptions(const RecordData &Record, bool Complain,\n                                 ASTReaderListener &Listener,\n                                 bool AllowCompatibleDifferences);\n  static bool ParseDiagnosticOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseFileSystemOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseHeaderSearchOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener);\n  static bool ParsePreprocessorOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener,\n                                       std::string &SuggestedPredefines);\n\n  struct RecordLocation {\n    ModuleFile *F;\n    uint64_t Offset;\n\n    RecordLocation(ModuleFile *M, uint64_t O) : F(M), Offset(O) {}\n  };\n\n  QualType readTypeRecord(unsigned Index);\n  RecordLocation TypeCursorForIndex(unsigned Index);\n  void LoadedDecl(unsigned Index, Decl *D);\n  Decl *ReadDeclRecord(serialization::DeclID ID);\n  void markIncompleteDeclChain(Decl *Canon);\n\n  /// Returns the most recent declaration of a declaration (which must be\n  /// of a redeclarable kind) that is either local or has already been loaded\n  /// merged into its redecl chain.\n  Decl *getMostRecentExistingDecl(Decl *D);\n\n  RecordLocation DeclCursorForID(serialization::DeclID ID,\n                                 SourceLocation &Location);\n  void loadDeclUpdateRecords(PendingUpdateRecord &Record);\n  void loadPendingDeclChain(Decl *D, uint64_t LocalOffset);\n  void loadObjCCategories(serialization::GlobalDeclID ID, ObjCInterfaceDecl *D,\n                          unsigned PreviousGeneration = 0);\n\n  RecordLocation getLocalBitOffset(uint64_t GlobalOffset);\n  uint64_t getGlobalBitOffset(ModuleFile &M, uint64_t LocalOffset);\n\n  /// Returns the first preprocessed entity ID that begins or ends after\n  /// \\arg Loc.\n  serialization::PreprocessedEntityID\n  findPreprocessedEntity(SourceLocation Loc, bool EndsAfter) const;\n\n  /// Find the next module that contains entities and return the ID\n  /// of the first entry.\n  ///\n  /// \\param SLocMapI points at a chunk of a module that contains no\n  /// preprocessed entities or the entities it contains are not the\n  /// ones we are looking for.\n  serialization::PreprocessedEntityID\n    findNextPreprocessedEntity(\n                        GlobalSLocOffsetMapType::const_iterator SLocMapI) const;\n\n  /// Returns (ModuleFile, Local index) pair for \\p GlobalIndex of a\n  /// preprocessed entity.\n  std::pair<ModuleFile *, unsigned>\n    getModulePreprocessedEntity(unsigned GlobalIndex);\n\n  /// Returns (begin, end) pair for the preprocessed entities of a\n  /// particular module.\n  llvm::iterator_range<PreprocessingRecord::iterator>\n  getModulePreprocessedEntities(ModuleFile &Mod) const;\n\npublic:\n  class ModuleDeclIterator\n      : public llvm::iterator_adaptor_base<\n            ModuleDeclIterator, const serialization::LocalDeclID *,\n            std::random_access_iterator_tag, const Decl *, ptrdiff_t,\n            const Decl *, const Decl *> {\n    ASTReader *Reader = nullptr;\n    ModuleFile *Mod = nullptr;\n\n  public:\n    ModuleDeclIterator() : iterator_adaptor_base(nullptr) {}\n\n    ModuleDeclIterator(ASTReader *Reader, ModuleFile *Mod,\n                       const serialization::LocalDeclID *Pos)\n        : iterator_adaptor_base(Pos), Reader(Reader), Mod(Mod) {}\n\n    value_type operator*() const {\n      return Reader->GetDecl(Reader->getGlobalDeclID(*Mod, *I));\n    }\n\n    value_type operator->() const { return **this; }\n\n    bool operator==(const ModuleDeclIterator &RHS) const {\n      assert(Reader == RHS.Reader && Mod == RHS.Mod);\n      return I == RHS.I;\n    }\n  };\n\n  llvm::iterator_range<ModuleDeclIterator>\n  getModuleFileLevelDecls(ModuleFile &Mod);\n\nprivate:\n  void PassInterestingDeclsToConsumer();\n  void PassInterestingDeclToConsumer(Decl *D);\n\n  void finishPendingActions();\n  void diagnoseOdrViolations();\n\n  void pushExternalDeclIntoScope(NamedDecl *D, DeclarationName Name);\n\n  void addPendingDeclContextInfo(Decl *D,\n                                 serialization::GlobalDeclID SemaDC,\n                                 serialization::GlobalDeclID LexicalDC) {\n    assert(D);\n    PendingDeclContextInfo Info = { D, SemaDC, LexicalDC };\n    PendingDeclContextInfos.push_back(Info);\n  }\n\n  /// Produce an error diagnostic and return true.\n  ///\n  /// This routine should only be used for fatal errors that have to\n  /// do with non-routine failures (e.g., corrupted AST file).\n  void Error(StringRef Msg) const;\n  void Error(unsigned DiagID, StringRef Arg1 = StringRef(),\n             StringRef Arg2 = StringRef(), StringRef Arg3 = StringRef()) const;\n  void Error(llvm::Error &&Err) const;\n\npublic:\n  /// Load the AST file and validate its contents against the given\n  /// Preprocessor.\n  ///\n  /// \\param PP the preprocessor associated with the context in which this\n  /// precompiled header will be loaded.\n  ///\n  /// \\param Context the AST context that this precompiled header will be\n  /// loaded into, if any.\n  ///\n  /// \\param PCHContainerRdr the PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Extensions the list of module file extensions that can be loaded\n  /// from the AST files.\n  ///\n  /// \\param isysroot If non-NULL, the system include path specified by the\n  /// user. This is only used with relocatable PCH files. If non-NULL,\n  /// a relocatable PCH file will use the default path \"/\".\n  ///\n  /// \\param DisableValidationKind If set, the AST reader will suppress most\n  /// of its regular consistency checking, allowing the use of precompiled\n  /// headers and module files that cannot be determined to be compatible.\n  ///\n  /// \\param AllowASTWithCompilerErrors If true, the AST reader will accept an\n  /// AST file the was created out of an AST with compiler errors,\n  /// otherwise it will reject it.\n  ///\n  /// \\param AllowConfigurationMismatch If true, the AST reader will not check\n  /// for configuration differences between the AST file and the invocation.\n  ///\n  /// \\param ValidateSystemInputs If true, the AST reader will validate\n  /// system input files in addition to user input files. This is only\n  /// meaningful if \\p DisableValidation is false.\n  ///\n  /// \\param UseGlobalIndex If true, the AST reader will try to load and use\n  /// the global module index.\n  ///\n  /// \\param ReadTimer If non-null, a timer used to track the time spent\n  /// deserializing.\n  ASTReader(Preprocessor &PP, InMemoryModuleCache &ModuleCache,\n            ASTContext *Context, const PCHContainerReader &PCHContainerRdr,\n            ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n            StringRef isysroot = \"\",\n            DisableValidationForModuleKind DisableValidationKind =\n                DisableValidationForModuleKind::None,\n            bool AllowASTWithCompilerErrors = false,\n            bool AllowConfigurationMismatch = false,\n            bool ValidateSystemInputs = false,\n            bool ValidateASTInputFilesContent = false,\n            bool UseGlobalIndex = true,\n            std::unique_ptr<llvm::Timer> ReadTimer = {});\n  ASTReader(const ASTReader &) = delete;\n  ASTReader &operator=(const ASTReader &) = delete;\n  ~ASTReader() override;\n\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  FileManager &getFileManager() const { return FileMgr; }\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  /// Flags that indicate what kind of AST loading failures the client\n  /// of the AST reader can directly handle.\n  ///\n  /// When a client states that it can handle a particular kind of failure,\n  /// the AST reader will not emit errors when producing that kind of failure.\n  enum LoadFailureCapabilities {\n    /// The client can't handle any AST loading failures.\n    ARR_None = 0,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is missing.\n    ARR_Missing = 0x1,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is out-of-date relative to its input files.\n    ARR_OutOfDate = 0x2,\n\n    /// The client can handle an AST file that cannot load because it\n    /// was built with a different version of Clang.\n    ARR_VersionMismatch = 0x4,\n\n    /// The client can handle an AST file that cannot load because it's\n    /// compiled configuration doesn't match that of the context it was\n    /// loaded into.\n    ARR_ConfigurationMismatch = 0x8,\n\n    /// If a module file is marked with errors treat it as out-of-date so the\n    /// caller can rebuild it.\n    ARR_TreatModuleWithErrorsAsOutOfDate = 0x10\n  };\n\n  /// Load the AST file designated by the given file name.\n  ///\n  /// \\param FileName The name of the AST file to load.\n  ///\n  /// \\param Type The kind of AST being loaded, e.g., PCH, module, main file,\n  /// or preamble.\n  ///\n  /// \\param ImportLoc the location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  ///\n  /// \\param ClientLoadCapabilities The set of client load-failure\n  /// capabilities, represented as a bitset of the enumerators of\n  /// LoadFailureCapabilities.\n  ///\n  /// \\param Imported optional out-parameter to append the list of modules\n  /// that were imported by precompiled headers or any other non-module AST file\n  ASTReadResult ReadAST(StringRef FileName, ModuleKind Type,\n                        SourceLocation ImportLoc,\n                        unsigned ClientLoadCapabilities,\n                        SmallVectorImpl<ImportedSubmodule> *Imported = nullptr);\n\n  /// Make the entities in the given module and any of its (non-explicit)\n  /// submodules visible to name lookup.\n  ///\n  /// \\param Mod The module whose names should be made visible.\n  ///\n  /// \\param NameVisibility The level of visibility to give the names in the\n  /// module.  Visibility can only be increased over time.\n  ///\n  /// \\param ImportLoc The location at which the import occurs.\n  void makeModuleVisible(Module *Mod,\n                         Module::NameVisibilityKind NameVisibility,\n                         SourceLocation ImportLoc);\n\n  /// Make the names within this set of hidden names visible.\n  void makeNamesVisible(const HiddenNames &Names, Module *Owner);\n\n  /// Note that MergedDef is a redefinition of the canonical definition\n  /// Def, so Def should be visible whenever MergedDef is.\n  void mergeDefinitionVisibility(NamedDecl *Def, NamedDecl *MergedDef);\n\n  /// Take the AST callbacks listener.\n  std::unique_ptr<ASTReaderListener> takeListener() {\n    return std::move(Listener);\n  }\n\n  /// Set the AST callbacks listener.\n  void setListener(std::unique_ptr<ASTReaderListener> Listener) {\n    this->Listener = std::move(Listener);\n  }\n\n  /// Add an AST callback listener.\n  ///\n  /// Takes ownership of \\p L.\n  void addListener(std::unique_ptr<ASTReaderListener> L) {\n    if (Listener)\n      L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                      std::move(Listener));\n    Listener = std::move(L);\n  }\n\n  /// RAII object to temporarily add an AST callback listener.\n  class ListenerScope {\n    ASTReader &Reader;\n    bool Chained = false;\n\n  public:\n    ListenerScope(ASTReader &Reader, std::unique_ptr<ASTReaderListener> L)\n        : Reader(Reader) {\n      auto Old = Reader.takeListener();\n      if (Old) {\n        Chained = true;\n        L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                        std::move(Old));\n      }\n      Reader.setListener(std::move(L));\n    }\n\n    ~ListenerScope() {\n      auto New = Reader.takeListener();\n      if (Chained)\n        Reader.setListener(static_cast<ChainedASTReaderListener *>(New.get())\n                               ->takeSecond());\n    }\n  };\n\n  /// Set the AST deserialization listener.\n  void setDeserializationListener(ASTDeserializationListener *Listener,\n                                  bool TakeOwnership = false);\n\n  /// Get the AST deserialization listener.\n  ASTDeserializationListener *getDeserializationListener() {\n    return DeserializationListener;\n  }\n\n  /// Determine whether this AST reader has a global index.\n  bool hasGlobalIndex() const { return (bool)GlobalIndex; }\n\n  /// Return global module index.\n  GlobalModuleIndex *getGlobalIndex() { return GlobalIndex.get(); }\n\n  /// Reset reader for a reload try.\n  void resetForReload() { TriedLoadingGlobalIndex = false; }\n\n  /// Attempts to load the global index.\n  ///\n  /// \\returns true if loading the global index has failed for any reason.\n  bool loadGlobalIndex();\n\n  /// Determine whether we tried to load the global index, but failed,\n  /// e.g., because it is out-of-date or does not exist.\n  bool isGlobalIndexUnavailable() const;\n\n  /// Initializes the ASTContext\n  void InitializeContext();\n\n  /// Update the state of Sema after loading some additional modules.\n  void UpdateSema();\n\n  /// Add in-memory (virtual file) buffer.\n  void addInMemoryBuffer(StringRef &FileName,\n                         std::unique_ptr<llvm::MemoryBuffer> Buffer) {\n    ModuleMgr.addInMemoryBuffer(FileName, std::move(Buffer));\n  }\n\n  /// Finalizes the AST reader's state before writing an AST file to\n  /// disk.\n  ///\n  /// This operation may undo temporary state in the AST that should not be\n  /// emitted.\n  void finalizeForWriting();\n\n  /// Retrieve the module manager.\n  ModuleManager &getModuleManager() { return ModuleMgr; }\n\n  /// Retrieve the preprocessor.\n  Preprocessor &getPreprocessor() const { return PP; }\n\n  /// Retrieve the name of the original source file name for the primary\n  /// module file.\n  StringRef getOriginalSourceFile() {\n    return ModuleMgr.getPrimaryModule().OriginalSourceFileName;\n  }\n\n  /// Retrieve the name of the original source file name directly from\n  /// the AST file, without actually loading the AST file.\n  static std::string\n  getOriginalSourceFile(const std::string &ASTFileName, FileManager &FileMgr,\n                        const PCHContainerReader &PCHContainerRdr,\n                        DiagnosticsEngine &Diags);\n\n  /// Read the control block for the named AST file.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  static bool\n  readASTFileControlBlock(StringRef Filename, FileManager &FileMgr,\n                          const PCHContainerReader &PCHContainerRdr,\n                          bool FindModuleFileExtensions,\n                          ASTReaderListener &Listener,\n                          bool ValidateDiagnosticOptions);\n\n  /// Determine whether the given AST file is acceptable to load into a\n  /// translation unit with the given language and target options.\n  static bool isAcceptableASTFile(StringRef Filename, FileManager &FileMgr,\n                                  const PCHContainerReader &PCHContainerRdr,\n                                  const LangOptions &LangOpts,\n                                  const TargetOptions &TargetOpts,\n                                  const PreprocessorOptions &PPOpts,\n                                  StringRef ExistingModuleCachePath);\n\n  /// Returns the suggested contents of the predefines buffer,\n  /// which contains a (typically-empty) subset of the predefines\n  /// build prior to including the precompiled header.\n  const std::string &getSuggestedPredefines() { return SuggestedPredefines; }\n\n  /// Read a preallocated preprocessed entity from the external source.\n  ///\n  /// \\returns null if an error occurred that prevented the preprocessed\n  /// entity from being loaded.\n  PreprocessedEntity *ReadPreprocessedEntity(unsigned Index) override;\n\n  /// Returns a pair of [Begin, End) indices of preallocated\n  /// preprocessed entities that \\p Range encompasses.\n  std::pair<unsigned, unsigned>\n      findPreprocessedEntitiesInRange(SourceRange Range) override;\n\n  /// Optionally returns true or false if the preallocated preprocessed\n  /// entity with index \\p Index came from file \\p FID.\n  Optional<bool> isPreprocessedEntityInFileID(unsigned Index,\n                                              FileID FID) override;\n\n  /// Read a preallocated skipped range from the external source.\n  SourceRange ReadSkippedRange(unsigned Index) override;\n\n  /// Read the header file information for the given file entry.\n  HeaderFileInfo GetHeaderFileInfo(const FileEntry *FE) override;\n\n  void ReadPragmaDiagnosticMappings(DiagnosticsEngine &Diag);\n\n  /// Returns the number of source locations found in the chain.\n  unsigned getTotalNumSLocs() const {\n    return TotalNumSLocEntries;\n  }\n\n  /// Returns the number of identifiers found in the chain.\n  unsigned getTotalNumIdentifiers() const {\n    return static_cast<unsigned>(IdentifiersLoaded.size());\n  }\n\n  /// Returns the number of macros found in the chain.\n  unsigned getTotalNumMacros() const {\n    return static_cast<unsigned>(MacrosLoaded.size());\n  }\n\n  /// Returns the number of types found in the chain.\n  unsigned getTotalNumTypes() const {\n    return static_cast<unsigned>(TypesLoaded.size());\n  }\n\n  /// Returns the number of declarations found in the chain.\n  unsigned getTotalNumDecls() const {\n    return static_cast<unsigned>(DeclsLoaded.size());\n  }\n\n  /// Returns the number of submodules known.\n  unsigned getTotalNumSubmodules() const {\n    return static_cast<unsigned>(SubmodulesLoaded.size());\n  }\n\n  /// Returns the number of selectors found in the chain.\n  unsigned getTotalNumSelectors() const {\n    return static_cast<unsigned>(SelectorsLoaded.size());\n  }\n\n  /// Returns the number of preprocessed entities known to the AST\n  /// reader.\n  unsigned getTotalNumPreprocessedEntities() const {\n    unsigned Result = 0;\n    for (const auto &M : ModuleMgr)\n      Result += M.NumPreprocessedEntities;\n    return Result;\n  }\n\n  /// Resolve a type ID into a type, potentially building a new\n  /// type.\n  QualType GetType(serialization::TypeID ID);\n\n  /// Resolve a local type ID within a given AST file into a type.\n  QualType getLocalType(ModuleFile &F, unsigned LocalID);\n\n  /// Map a local type ID within a given AST file into a global type ID.\n  serialization::TypeID getGlobalTypeID(ModuleFile &F, unsigned LocalID) const;\n\n  /// Read a type from the current position in the given record, which\n  /// was read from the given AST file.\n  QualType readType(ModuleFile &F, const RecordData &Record, unsigned &Idx) {\n    if (Idx >= Record.size())\n      return {};\n\n    return getLocalType(F, Record[Idx++]);\n  }\n\n  /// Map from a local declaration ID within a given module to a\n  /// global declaration ID.\n  serialization::DeclID getGlobalDeclID(ModuleFile &F,\n                                      serialization::LocalDeclID LocalID) const;\n\n  /// Returns true if global DeclID \\p ID originated from module \\p M.\n  bool isDeclIDFromModule(serialization::GlobalDeclID ID, ModuleFile &M) const;\n\n  /// Retrieve the module file that owns the given declaration, or NULL\n  /// if the declaration is not from a module file.\n  ModuleFile *getOwningModuleFile(const Decl *D);\n\n  /// Get the best name we know for the module that owns the given\n  /// declaration, or an empty string if the declaration is not from a module.\n  std::string getOwningModuleNameForDiagnostic(const Decl *D);\n\n  /// Returns the source location for the decl \\p ID.\n  SourceLocation getSourceLocationForDeclID(serialization::GlobalDeclID ID);\n\n  /// Resolve a declaration ID into a declaration, potentially\n  /// building a new declaration.\n  Decl *GetDecl(serialization::DeclID ID);\n  Decl *GetExternalDecl(uint32_t ID) override;\n\n  /// Resolve a declaration ID into a declaration. Return 0 if it's not\n  /// been loaded yet.\n  Decl *GetExistingDecl(serialization::DeclID ID);\n\n  /// Reads a declaration with the given local ID in the given module.\n  Decl *GetLocalDecl(ModuleFile &F, uint32_t LocalID) {\n    return GetDecl(getGlobalDeclID(F, LocalID));\n  }\n\n  /// Reads a declaration with the given local ID in the given module.\n  ///\n  /// \\returns The requested declaration, casted to the given return type.\n  template<typename T>\n  T *GetLocalDeclAs(ModuleFile &F, uint32_t LocalID) {\n    return cast_or_null<T>(GetLocalDecl(F, LocalID));\n  }\n\n  /// Map a global declaration ID into the declaration ID used to\n  /// refer to this declaration within the given module fule.\n  ///\n  /// \\returns the global ID of the given declaration as known in the given\n  /// module file.\n  serialization::DeclID\n  mapGlobalIDToModuleFileGlobalID(ModuleFile &M,\n                                  serialization::DeclID GlobalID);\n\n  /// Reads a declaration ID from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration ID read from the record, adjusted to a global ID.\n  serialization::DeclID ReadDeclID(ModuleFile &F, const RecordData &Record,\n                                   unsigned &Idx);\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  Decl *ReadDecl(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return GetDecl(ReadDeclID(F, R, I));\n  }\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration read from this location, casted to the given\n  /// result type.\n  template<typename T>\n  T *ReadDeclAs(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return cast_or_null<T>(GetDecl(ReadDeclID(F, R, I)));\n  }\n\n  /// If any redeclarations of \\p D have been imported since it was\n  /// last checked, this digs out those redeclarations and adds them to the\n  /// redeclaration chain for \\p D.\n  void CompleteRedeclChain(const Decl *D) override;\n\n  CXXBaseSpecifier *GetExternalCXXBaseSpecifiers(uint64_t Offset) override;\n\n  /// Resolve the offset of a statement into a statement.\n  ///\n  /// This operation will read a new statement from the external\n  /// source each time it is called, and is meant to be used via a\n  /// LazyOffsetPtr (which is used by Decls for the body of functions, etc).\n  Stmt *GetExternalDeclStmt(uint64_t Offset) override;\n\n  /// ReadBlockAbbrevs - Enter a subblock of the specified BlockID with the\n  /// specified cursor.  Read the abbreviations that are at the top of the block\n  /// and then leave the cursor pointing into the block.\n  static bool ReadBlockAbbrevs(llvm::BitstreamCursor &Cursor, unsigned BlockID,\n                               uint64_t *StartOfBlockOffset = nullptr);\n\n  /// Finds all the visible declarations with a given name.\n  /// The current implementation of this method just loads the entire\n  /// lookup table as unmaterialized references.\n  bool FindExternalVisibleDeclsByName(const DeclContext *DC,\n                                      DeclarationName Name) override;\n\n  /// Read all of the declarations lexically stored in a\n  /// declaration context.\n  ///\n  /// \\param DC The declaration context whose declarations will be\n  /// read.\n  ///\n  /// \\param IsKindWeWant A predicate indicating which declaration kinds\n  /// we are interested in.\n  ///\n  /// \\param Decls Vector that will contain the declarations loaded\n  /// from the external source. The caller is responsible for merging\n  /// these declarations with any declarations already stored in the\n  /// declaration context.\n  void\n  FindExternalLexicalDecls(const DeclContext *DC,\n                           llvm::function_ref<bool(Decl::Kind)> IsKindWeWant,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  void FindFileRegionDecls(FileID File, unsigned Offset, unsigned Length,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Notify ASTReader that we started deserialization of\n  /// a decl or type so until FinishedDeserializing is called there may be\n  /// decls that are initializing. Must be paired with FinishedDeserializing.\n  void StartedDeserializing() override;\n\n  /// Notify ASTReader that we finished the deserialization of\n  /// a decl or type. Must be paired with StartedDeserializing.\n  void FinishedDeserializing() override;\n\n  /// Function that will be invoked when we begin parsing a new\n  /// translation unit involving this external AST source.\n  ///\n  /// This function will provide all of the external definitions to\n  /// the ASTConsumer.\n  void StartTranslationUnit(ASTConsumer *Consumer) override;\n\n  /// Print some statistics about AST usage.\n  void PrintStats() override;\n\n  /// Dump information about the AST reader to standard error.\n  void dump();\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  void getMemoryBufferSizes(MemoryBufferSizes &sizes) const override;\n\n  /// Initialize the semantic source with the Sema instance\n  /// being used to perform semantic analysis on the abstract syntax\n  /// tree.\n  void InitializeSema(Sema &S) override;\n\n  /// Inform the semantic consumer that Sema is no longer available.\n  void ForgetSema() override { SemaObj = nullptr; }\n\n  /// Retrieve the IdentifierInfo for the named identifier.\n  ///\n  /// This routine builds a new IdentifierInfo for the given identifier. If any\n  /// declarations with this name are visible from translation unit scope, their\n  /// declarations will be deserialized and introduced into the declaration\n  /// chain of the identifier.\n  IdentifierInfo *get(StringRef Name) override;\n\n  /// Retrieve an iterator into the set of all identifiers\n  /// in all loaded AST files.\n  IdentifierIterator *getIdentifiers() override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector.\n  void ReadMethodPool(Selector Sel) override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector if necessary.\n  void updateOutOfDateSelector(Selector Sel) override;\n\n  /// Load the set of namespaces that are known to the external source,\n  /// which will be used during typo correction.\n  void ReadKnownNamespaces(\n                         SmallVectorImpl<NamespaceDecl *> &Namespaces) override;\n\n  void ReadUndefinedButUsed(\n      llvm::MapVector<NamedDecl *, SourceLocation> &Undefined) override;\n\n  void ReadMismatchingDeleteExpressions(llvm::MapVector<\n      FieldDecl *, llvm::SmallVector<std::pair<SourceLocation, bool>, 4>> &\n                                            Exprs) override;\n\n  void ReadTentativeDefinitions(\n                            SmallVectorImpl<VarDecl *> &TentativeDefs) override;\n\n  void ReadUnusedFileScopedDecls(\n                       SmallVectorImpl<const DeclaratorDecl *> &Decls) override;\n\n  void ReadDelegatingConstructors(\n                         SmallVectorImpl<CXXConstructorDecl *> &Decls) override;\n\n  void ReadExtVectorDecls(SmallVectorImpl<TypedefNameDecl *> &Decls) override;\n\n  void ReadUnusedLocalTypedefNameCandidates(\n      llvm::SmallSetVector<const TypedefNameDecl *, 4> &Decls) override;\n\n  void ReadDeclsToCheckForDeferredDiags(\n      llvm::SmallVector<Decl *, 4> &Decls) override;\n\n  void ReadReferencedSelectors(\n           SmallVectorImpl<std::pair<Selector, SourceLocation>> &Sels) override;\n\n  void ReadWeakUndeclaredIdentifiers(\n           SmallVectorImpl<std::pair<IdentifierInfo *, WeakInfo>> &WI) override;\n\n  void ReadUsedVTables(SmallVectorImpl<ExternalVTableUse> &VTables) override;\n\n  void ReadPendingInstantiations(\n                  SmallVectorImpl<std::pair<ValueDecl *,\n                                            SourceLocation>> &Pending) override;\n\n  void ReadLateParsedTemplates(\n      llvm::MapVector<const FunctionDecl *, std::unique_ptr<LateParsedTemplate>>\n          &LPTMap) override;\n\n  /// Load a selector from disk, registering its ID if it exists.\n  void LoadSelector(Selector Sel);\n\n  void SetIdentifierInfo(unsigned ID, IdentifierInfo *II);\n  void SetGloballyVisibleDecls(IdentifierInfo *II,\n                               const SmallVectorImpl<uint32_t> &DeclIDs,\n                               SmallVectorImpl<Decl *> *Decls = nullptr);\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(unsigned DiagID) const;\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const;\n\n  IdentifierInfo *DecodeIdentifierInfo(serialization::IdentifierID ID);\n\n  IdentifierInfo *readIdentifier(ModuleFile &M, const RecordData &Record,\n                                 unsigned &Idx) {\n    return DecodeIdentifierInfo(getGlobalIdentifierID(M, Record[Idx++]));\n  }\n\n  IdentifierInfo *GetIdentifier(serialization::IdentifierID ID) override {\n    // Note that we are loading an identifier.\n    Deserializing AnIdentifier(this);\n\n    return DecodeIdentifierInfo(ID);\n  }\n\n  IdentifierInfo *getLocalIdentifier(ModuleFile &M, unsigned LocalID);\n\n  serialization::IdentifierID getGlobalIdentifierID(ModuleFile &M,\n                                                    unsigned LocalID);\n\n  void resolvePendingMacro(IdentifierInfo *II, const PendingMacroInfo &PMInfo);\n\n  /// Retrieve the macro with the given ID.\n  MacroInfo *getMacro(serialization::MacroID ID);\n\n  /// Retrieve the global macro ID corresponding to the given local\n  /// ID within the given module file.\n  serialization::MacroID getGlobalMacroID(ModuleFile &M, unsigned LocalID);\n\n  /// Read the source location entry with index ID.\n  bool ReadSLocEntry(int ID) override;\n\n  /// Retrieve the module import location and module name for the\n  /// given source manager entry ID.\n  std::pair<SourceLocation, StringRef> getModuleImportLoc(int ID) override;\n\n  /// Retrieve the global submodule ID given a module and its local ID\n  /// number.\n  serialization::SubmoduleID\n  getGlobalSubmoduleID(ModuleFile &M, unsigned LocalID);\n\n  /// Retrieve the submodule that corresponds to a global submodule ID.\n  ///\n  Module *getSubmodule(serialization::SubmoduleID GlobalID);\n\n  /// Retrieve the module that corresponds to the given module ID.\n  ///\n  /// Note: overrides method in ExternalASTSource\n  Module *getModule(unsigned ID) override;\n\n  /// Retrieve the module file with a given local ID within the specified\n  /// ModuleFile.\n  ModuleFile *getLocalModuleFile(ModuleFile &M, unsigned ID);\n\n  /// Get an ID for the given module file.\n  unsigned getModuleFileID(ModuleFile *M);\n\n  /// Return a descriptor for the corresponding module.\n  llvm::Optional<ASTSourceDescriptor> getSourceDescriptor(unsigned ID) override;\n\n  ExtKind hasExternalDefinitions(const Decl *D) override;\n\n  /// Retrieve a selector from the given module with its local ID\n  /// number.\n  Selector getLocalSelector(ModuleFile &M, unsigned LocalID);\n\n  Selector DecodeSelector(serialization::SelectorID Idx);\n\n  Selector GetExternalSelector(serialization::SelectorID ID) override;\n  uint32_t GetNumExternalSelectors() override;\n\n  Selector ReadSelector(ModuleFile &M, const RecordData &Record, unsigned &Idx) {\n    return getLocalSelector(M, Record[Idx++]);\n  }\n\n  /// Retrieve the global selector ID that corresponds to this\n  /// the local selector ID in a given module.\n  serialization::SelectorID getGlobalSelectorID(ModuleFile &F,\n                                                unsigned LocalID) const;\n\n  /// Read the contents of a CXXCtorInitializer array.\n  CXXCtorInitializer **GetExternalCXXCtorInitializers(uint64_t Offset) override;\n\n  /// Read a AlignPackInfo from raw form.\n  Sema::AlignPackInfo ReadAlignPackInfo(uint32_t Raw) const {\n    return Sema::AlignPackInfo::getFromRawEncoding(Raw);\n  }\n\n  /// Read a source location from raw form and return it in its\n  /// originating module file's source location space.\n  SourceLocation ReadUntranslatedSourceLocation(uint32_t Raw) const {\n    return SourceLocation::getFromRawEncoding((Raw >> 1) | (Raw << 31));\n  }\n\n  /// Read a source location from raw form.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile, uint32_t Raw) const {\n    SourceLocation Loc = ReadUntranslatedSourceLocation(Raw);\n    return TranslateSourceLocation(ModuleFile, Loc);\n  }\n\n  /// Translate a source location from another module file's source\n  /// location space into ours.\n  SourceLocation TranslateSourceLocation(ModuleFile &ModuleFile,\n                                         SourceLocation Loc) const {\n    if (!ModuleFile.ModuleOffsetMap.empty())\n      ReadModuleOffsetMap(ModuleFile);\n    assert(ModuleFile.SLocRemap.find(Loc.getOffset()) !=\n               ModuleFile.SLocRemap.end() &&\n           \"Cannot find offset to remap.\");\n    int Remap = ModuleFile.SLocRemap.find(Loc.getOffset())->second;\n    return Loc.getLocWithOffset(Remap);\n  }\n\n  /// Read a source location.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile,\n                                    const RecordDataImpl &Record,\n                                    unsigned &Idx) {\n    return ReadSourceLocation(ModuleFile, Record[Idx++]);\n  }\n\n  /// Read a source range.\n  SourceRange ReadSourceRange(ModuleFile &F,\n                              const RecordData &Record, unsigned &Idx);\n\n  // Read a string\n  static std::string ReadString(const RecordData &Record, unsigned &Idx);\n\n  // Skip a string\n  static void SkipString(const RecordData &Record, unsigned &Idx) {\n    Idx += Record[Idx] + 1;\n  }\n\n  // Read a path\n  std::string ReadPath(ModuleFile &F, const RecordData &Record, unsigned &Idx);\n\n  // Read a path\n  std::string ReadPath(StringRef BaseDirectory, const RecordData &Record,\n                       unsigned &Idx);\n\n  // Skip a path\n  static void SkipPath(const RecordData &Record, unsigned &Idx) {\n    SkipString(Record, Idx);\n  }\n\n  /// Read a version tuple.\n  static VersionTuple ReadVersionTuple(const RecordData &Record, unsigned &Idx);\n\n  CXXTemporary *ReadCXXTemporary(ModuleFile &F, const RecordData &Record,\n                                 unsigned &Idx);\n\n  /// Reads a statement.\n  Stmt *ReadStmt(ModuleFile &F);\n\n  /// Reads an expression.\n  Expr *ReadExpr(ModuleFile &F);\n\n  /// Reads a sub-statement operand during statement reading.\n  Stmt *ReadSubStmt() {\n    assert(ReadingKind == Read_Stmt &&\n           \"Should be called only during statement reading!\");\n    // Subexpressions are stored from last to first, so the next Stmt we need\n    // is at the back of the stack.\n    assert(!StmtStack.empty() && \"Read too many sub-statements!\");\n    return StmtStack.pop_back_val();\n  }\n\n  /// Reads a sub-expression operand during statement reading.\n  Expr *ReadSubExpr();\n\n  /// Reads a token out of a record.\n  Token ReadToken(ModuleFile &M, const RecordDataImpl &Record, unsigned &Idx);\n\n  /// Reads the macro record located at the given offset.\n  MacroInfo *ReadMacroRecord(ModuleFile &F, uint64_t Offset);\n\n  /// Determine the global preprocessed entity ID that corresponds to\n  /// the given local ID within the given module.\n  serialization::PreprocessedEntityID\n  getGlobalPreprocessedEntityID(ModuleFile &M, unsigned LocalID) const;\n\n  /// Add a macro to deserialize its macro directive history.\n  ///\n  /// \\param II The name of the macro.\n  /// \\param M The module file.\n  /// \\param MacroDirectivesOffset Offset of the serialized macro directive\n  /// history.\n  void addPendingMacro(IdentifierInfo *II, ModuleFile *M,\n                       uint32_t MacroDirectivesOffset);\n\n  /// Read the set of macros defined by this external macro source.\n  void ReadDefinedMacros() override;\n\n  /// Update an out-of-date identifier.\n  void updateOutOfDateIdentifier(IdentifierInfo &II) override;\n\n  /// Note that this identifier is up-to-date.\n  void markIdentifierUpToDate(IdentifierInfo *II);\n\n  /// Load all external visible decls in the given DeclContext.\n  void completeVisibleDeclsMap(const DeclContext *DC) override;\n\n  /// Retrieve the AST context that this AST reader supplements.\n  ASTContext &getContext() {\n    assert(ContextObj && \"requested AST context when not loading AST\");\n    return *ContextObj;\n  }\n\n  // Contains the IDs for declarations that were requested before we have\n  // access to a Sema object.\n  SmallVector<uint64_t, 16> PreloadedDeclIDs;\n\n  /// Retrieve the semantic analysis object used to analyze the\n  /// translation unit in which the precompiled header is being\n  /// imported.\n  Sema *getSema() { return SemaObj; }\n\n  /// Get the identifier resolver used for name lookup / updates\n  /// in the translation unit scope. We have one of these even if we don't\n  /// have a Sema object.\n  IdentifierResolver &getIdResolver();\n\n  /// Retrieve the identifier table associated with the\n  /// preprocessor.\n  IdentifierTable &getIdentifierTable();\n\n  /// Record that the given ID maps to the given switch-case\n  /// statement.\n  void RecordSwitchCaseID(SwitchCase *SC, unsigned ID);\n\n  /// Retrieve the switch-case statement with the given ID.\n  SwitchCase *getSwitchCaseWithID(unsigned ID);\n\n  void ClearSwitchCaseIDs();\n\n  /// Cursors for comments blocks.\n  SmallVector<std::pair<llvm::BitstreamCursor,\n                        serialization::ModuleFile *>, 8> CommentsCursors;\n\n  /// Loads comments ranges.\n  void ReadComments() override;\n\n  /// Visit all the input files of the given module file.\n  void visitInputFiles(serialization::ModuleFile &MF,\n                       bool IncludeSystem, bool Complain,\n          llvm::function_ref<void(const serialization::InputFile &IF,\n                                  bool isSystem)> Visitor);\n\n  /// Visit all the top-level module maps loaded when building the given module\n  /// file.\n  void visitTopLevelModuleMaps(serialization::ModuleFile &MF,\n                               llvm::function_ref<\n                                   void(const FileEntry *)> Visitor);\n\n  bool isProcessingUpdateRecords() { return ProcessingUpdateRecords; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SERIALIZATION_ASTREADER_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp", "content": "//===- ASTReaderStmt.cpp - Stmt/Expr Deserialization ----------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Statement/expression deserialization.  This implements the\n// ASTReader::ReadStmt method.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclGroup.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/StmtObjC.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/CapturedStmt.h\"\n#include \"clang/Basic/ExpressionTraits.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ASTRecordReader.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <string>\n\nusing namespace clang;\nusing namespace serialization;\n\nnamespace clang {\n\n  class ASTStmtReader : public StmtVisitor<ASTStmtReader> {\n    ASTRecordReader &Record;\n    llvm::BitstreamCursor &DeclsCursor;\n\n    SourceLocation readSourceLocation() {\n      return Record.readSourceLocation();\n    }\n\n    SourceRange readSourceRange() {\n      return Record.readSourceRange();\n    }\n\n    std::string readString() {\n      return Record.readString();\n    }\n\n    TypeSourceInfo *readTypeSourceInfo() {\n      return Record.readTypeSourceInfo();\n    }\n\n    Decl *readDecl() {\n      return Record.readDecl();\n    }\n\n    template<typename T>\n    T *readDeclAs() {\n      return Record.readDeclAs<T>();\n    }\n\n  public:\n    ASTStmtReader(ASTRecordReader &Record, llvm::BitstreamCursor &Cursor)\n        : Record(Record), DeclsCursor(Cursor) {}\n\n    /// The number of record fields required for the Stmt class\n    /// itself.\n    static const unsigned NumStmtFields = 0;\n\n    /// The number of record fields required for the Expr class\n    /// itself.\n    static const unsigned NumExprFields =\n        NumStmtFields + llvm::BitWidth<ExprDependence> + 3;\n\n    /// Read and initialize a ExplicitTemplateArgumentList structure.\n    void ReadTemplateKWAndArgsInfo(ASTTemplateKWAndArgsInfo &Args,\n                                   TemplateArgumentLoc *ArgsLocArray,\n                                   unsigned NumTemplateArgs);\n\n    /// Read and initialize a ExplicitTemplateArgumentList structure.\n    void ReadExplicitTemplateArgumentList(ASTTemplateArgumentListInfo &ArgList,\n                                          unsigned NumTemplateArgs);\n\n    void VisitStmt(Stmt *S);\n#define STMT(Type, Base) \\\n    void Visit##Type(Type *);\n#include \"clang/AST/StmtNodes.inc\"\n  };\n\n} // namespace clang\n\nvoid ASTStmtReader::ReadTemplateKWAndArgsInfo(ASTTemplateKWAndArgsInfo &Args,\n                                              TemplateArgumentLoc *ArgsLocArray,\n                                              unsigned NumTemplateArgs) {\n  SourceLocation TemplateKWLoc = readSourceLocation();\n  TemplateArgumentListInfo ArgInfo;\n  ArgInfo.setLAngleLoc(readSourceLocation());\n  ArgInfo.setRAngleLoc(readSourceLocation());\n  for (unsigned i = 0; i != NumTemplateArgs; ++i)\n    ArgInfo.addArgument(Record.readTemplateArgumentLoc());\n  Args.initializeFrom(TemplateKWLoc, ArgInfo, ArgsLocArray);\n}\n\nvoid ASTStmtReader::VisitStmt(Stmt *S) {\n  assert(Record.getIdx() == NumStmtFields && \"Incorrect statement field count\");\n}\n\nvoid ASTStmtReader::VisitNullStmt(NullStmt *S) {\n  VisitStmt(S);\n  S->setSemiLoc(readSourceLocation());\n  S->NullStmtBits.HasLeadingEmptyMacro = Record.readInt();\n}\n\nvoid ASTStmtReader::VisitCompoundStmt(CompoundStmt *S) {\n  VisitStmt(S);\n  SmallVector<Stmt *, 16> Stmts;\n  unsigned NumStmts = Record.readInt();\n  while (NumStmts--)\n    Stmts.push_back(Record.readSubStmt());\n  S->setStmts(Stmts);\n  S->CompoundStmtBits.LBraceLoc = readSourceLocation();\n  S->RBraceLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitSwitchCase(SwitchCase *S) {\n  VisitStmt(S);\n  Record.recordSwitchCaseID(S, Record.readInt());\n  S->setKeywordLoc(readSourceLocation());\n  S->setColonLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitCaseStmt(CaseStmt *S) {\n  VisitSwitchCase(S);\n  bool CaseStmtIsGNURange = Record.readInt();\n  S->setLHS(Record.readSubExpr());\n  S->setSubStmt(Record.readSubStmt());\n  if (CaseStmtIsGNURange) {\n    S->setRHS(Record.readSubExpr());\n    S->setEllipsisLoc(readSourceLocation());\n  }\n}\n\nvoid ASTStmtReader::VisitDefaultStmt(DefaultStmt *S) {\n  VisitSwitchCase(S);\n  S->setSubStmt(Record.readSubStmt());\n}\n\nvoid ASTStmtReader::VisitLabelStmt(LabelStmt *S) {\n  VisitStmt(S);\n  auto *LD = readDeclAs<LabelDecl>();\n  LD->setStmt(S);\n  S->setDecl(LD);\n  S->setSubStmt(Record.readSubStmt());\n  S->setIdentLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitAttributedStmt(AttributedStmt *S) {\n  VisitStmt(S);\n  // NumAttrs in AttributedStmt is set when creating an empty\n  // AttributedStmt in AttributedStmt::CreateEmpty, since it is needed\n  // to allocate the right amount of space for the trailing Attr *.\n  uint64_t NumAttrs = Record.readInt();\n  AttrVec Attrs;\n  Record.readAttributes(Attrs);\n  (void)NumAttrs;\n  assert(NumAttrs == S->AttributedStmtBits.NumAttrs);\n  assert(NumAttrs == Attrs.size());\n  std::copy(Attrs.begin(), Attrs.end(), S->getAttrArrayPtr());\n  S->SubStmt = Record.readSubStmt();\n  S->AttributedStmtBits.AttrLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitIfStmt(IfStmt *S) {\n  VisitStmt(S);\n\n  S->setConstexpr(Record.readInt());\n  bool HasElse = Record.readInt();\n  bool HasVar = Record.readInt();\n  bool HasInit = Record.readInt();\n\n  S->setCond(Record.readSubExpr());\n  S->setThen(Record.readSubStmt());\n  if (HasElse)\n    S->setElse(Record.readSubStmt());\n  if (HasVar)\n    S->setConditionVariable(Record.getContext(), readDeclAs<VarDecl>());\n  if (HasInit)\n    S->setInit(Record.readSubStmt());\n\n  S->setIfLoc(readSourceLocation());\n  S->setLParenLoc(readSourceLocation());\n  S->setRParenLoc(readSourceLocation());\n  if (HasElse)\n    S->setElseLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitSwitchStmt(SwitchStmt *S) {\n  VisitStmt(S);\n\n  bool HasInit = Record.readInt();\n  bool HasVar = Record.readInt();\n  bool AllEnumCasesCovered = Record.readInt();\n  if (AllEnumCasesCovered)\n    S->setAllEnumCasesCovered();\n\n  S->setCond(Record.readSubExpr());\n  S->setBody(Record.readSubStmt());\n  if (HasInit)\n    S->setInit(Record.readSubStmt());\n  if (HasVar)\n    S->setConditionVariable(Record.getContext(), readDeclAs<VarDecl>());\n\n  S->setSwitchLoc(readSourceLocation());\n  S->setLParenLoc(readSourceLocation());\n  S->setRParenLoc(readSourceLocation());\n\n  SwitchCase *PrevSC = nullptr;\n  for (auto E = Record.size(); Record.getIdx() != E; ) {\n    SwitchCase *SC = Record.getSwitchCaseWithID(Record.readInt());\n    if (PrevSC)\n      PrevSC->setNextSwitchCase(SC);\n    else\n      S->setSwitchCaseList(SC);\n\n    PrevSC = SC;\n  }\n}\n\nvoid ASTStmtReader::VisitWhileStmt(WhileStmt *S) {\n  VisitStmt(S);\n\n  bool HasVar = Record.readInt();\n\n  S->setCond(Record.readSubExpr());\n  S->setBody(Record.readSubStmt());\n  if (HasVar)\n    S->setConditionVariable(Record.getContext(), readDeclAs<VarDecl>());\n\n  S->setWhileLoc(readSourceLocation());\n  S->setLParenLoc(readSourceLocation());\n  S->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitDoStmt(DoStmt *S) {\n  VisitStmt(S);\n  S->setCond(Record.readSubExpr());\n  S->setBody(Record.readSubStmt());\n  S->setDoLoc(readSourceLocation());\n  S->setWhileLoc(readSourceLocation());\n  S->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitForStmt(ForStmt *S) {\n  VisitStmt(S);\n  S->setInit(Record.readSubStmt());\n  S->setCond(Record.readSubExpr());\n  S->setConditionVariable(Record.getContext(), readDeclAs<VarDecl>());\n  S->setInc(Record.readSubExpr());\n  S->setBody(Record.readSubStmt());\n  S->setForLoc(readSourceLocation());\n  S->setLParenLoc(readSourceLocation());\n  S->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitGotoStmt(GotoStmt *S) {\n  VisitStmt(S);\n  S->setLabel(readDeclAs<LabelDecl>());\n  S->setGotoLoc(readSourceLocation());\n  S->setLabelLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitIndirectGotoStmt(IndirectGotoStmt *S) {\n  VisitStmt(S);\n  S->setGotoLoc(readSourceLocation());\n  S->setStarLoc(readSourceLocation());\n  S->setTarget(Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitContinueStmt(ContinueStmt *S) {\n  VisitStmt(S);\n  S->setContinueLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitBreakStmt(BreakStmt *S) {\n  VisitStmt(S);\n  S->setBreakLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitReturnStmt(ReturnStmt *S) {\n  VisitStmt(S);\n\n  bool HasNRVOCandidate = Record.readInt();\n\n  S->setRetValue(Record.readSubExpr());\n  if (HasNRVOCandidate)\n    S->setNRVOCandidate(readDeclAs<VarDecl>());\n\n  S->setReturnLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitDeclStmt(DeclStmt *S) {\n  VisitStmt(S);\n  S->setStartLoc(readSourceLocation());\n  S->setEndLoc(readSourceLocation());\n\n  if (Record.size() - Record.getIdx() == 1) {\n    // Single declaration\n    S->setDeclGroup(DeclGroupRef(readDecl()));\n  } else {\n    SmallVector<Decl *, 16> Decls;\n    int N = Record.size() - Record.getIdx();\n    Decls.reserve(N);\n    for (int I = 0; I < N; ++I)\n      Decls.push_back(readDecl());\n    S->setDeclGroup(DeclGroupRef(DeclGroup::Create(Record.getContext(),\n                                                   Decls.data(),\n                                                   Decls.size())));\n  }\n}\n\nvoid ASTStmtReader::VisitAsmStmt(AsmStmt *S) {\n  VisitStmt(S);\n  S->NumOutputs = Record.readInt();\n  S->NumInputs = Record.readInt();\n  S->NumClobbers = Record.readInt();\n  S->setAsmLoc(readSourceLocation());\n  S->setVolatile(Record.readInt());\n  S->setSimple(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitGCCAsmStmt(GCCAsmStmt *S) {\n  VisitAsmStmt(S);\n  S->NumLabels = Record.readInt();\n  S->setRParenLoc(readSourceLocation());\n  S->setAsmString(cast_or_null<StringLiteral>(Record.readSubStmt()));\n\n  unsigned NumOutputs = S->getNumOutputs();\n  unsigned NumInputs = S->getNumInputs();\n  unsigned NumClobbers = S->getNumClobbers();\n  unsigned NumLabels = S->getNumLabels();\n\n  // Outputs and inputs\n  SmallVector<IdentifierInfo *, 16> Names;\n  SmallVector<StringLiteral*, 16> Constraints;\n  SmallVector<Stmt*, 16> Exprs;\n  for (unsigned I = 0, N = NumOutputs + NumInputs; I != N; ++I) {\n    Names.push_back(Record.readIdentifier());\n    Constraints.push_back(cast_or_null<StringLiteral>(Record.readSubStmt()));\n    Exprs.push_back(Record.readSubStmt());\n  }\n\n  // Constraints\n  SmallVector<StringLiteral*, 16> Clobbers;\n  for (unsigned I = 0; I != NumClobbers; ++I)\n    Clobbers.push_back(cast_or_null<StringLiteral>(Record.readSubStmt()));\n\n  // Labels\n  for (unsigned I = 0, N = NumLabels; I != N; ++I)\n    Exprs.push_back(Record.readSubStmt());\n\n  S->setOutputsAndInputsAndClobbers(Record.getContext(),\n                                    Names.data(), Constraints.data(),\n                                    Exprs.data(), NumOutputs, NumInputs,\n                                    NumLabels,\n                                    Clobbers.data(), NumClobbers);\n}\n\nvoid ASTStmtReader::VisitMSAsmStmt(MSAsmStmt *S) {\n  VisitAsmStmt(S);\n  S->LBraceLoc = readSourceLocation();\n  S->EndLoc = readSourceLocation();\n  S->NumAsmToks = Record.readInt();\n  std::string AsmStr = readString();\n\n  // Read the tokens.\n  SmallVector<Token, 16> AsmToks;\n  AsmToks.reserve(S->NumAsmToks);\n  for (unsigned i = 0, e = S->NumAsmToks; i != e; ++i) {\n    AsmToks.push_back(Record.readToken());\n  }\n\n  // The calls to reserve() for the FooData vectors are mandatory to\n  // prevent dead StringRefs in the Foo vectors.\n\n  // Read the clobbers.\n  SmallVector<std::string, 16> ClobbersData;\n  SmallVector<StringRef, 16> Clobbers;\n  ClobbersData.reserve(S->NumClobbers);\n  Clobbers.reserve(S->NumClobbers);\n  for (unsigned i = 0, e = S->NumClobbers; i != e; ++i) {\n    ClobbersData.push_back(readString());\n    Clobbers.push_back(ClobbersData.back());\n  }\n\n  // Read the operands.\n  unsigned NumOperands = S->NumOutputs + S->NumInputs;\n  SmallVector<Expr*, 16> Exprs;\n  SmallVector<std::string, 16> ConstraintsData;\n  SmallVector<StringRef, 16> Constraints;\n  Exprs.reserve(NumOperands);\n  ConstraintsData.reserve(NumOperands);\n  Constraints.reserve(NumOperands);\n  for (unsigned i = 0; i != NumOperands; ++i) {\n    Exprs.push_back(cast<Expr>(Record.readSubStmt()));\n    ConstraintsData.push_back(readString());\n    Constraints.push_back(ConstraintsData.back());\n  }\n\n  S->initialize(Record.getContext(), AsmStr, AsmToks,\n                Constraints, Exprs, Clobbers);\n}\n\nvoid ASTStmtReader::VisitCoroutineBodyStmt(CoroutineBodyStmt *S) {\n  VisitStmt(S);\n  assert(Record.peekInt() == S->NumParams);\n  Record.skipInts(1);\n  auto *StoredStmts = S->getStoredStmts();\n  for (unsigned i = 0;\n       i < CoroutineBodyStmt::SubStmt::FirstParamMove + S->NumParams; ++i)\n    StoredStmts[i] = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitCoreturnStmt(CoreturnStmt *S) {\n  VisitStmt(S);\n  S->CoreturnLoc = Record.readSourceLocation();\n  for (auto &SubStmt: S->SubStmts)\n    SubStmt = Record.readSubStmt();\n  S->IsImplicit = Record.readInt() != 0;\n}\n\nvoid ASTStmtReader::VisitCoawaitExpr(CoawaitExpr *E) {\n  VisitExpr(E);\n  E->KeywordLoc = readSourceLocation();\n  for (auto &SubExpr: E->SubExprs)\n    SubExpr = Record.readSubStmt();\n  E->OpaqueValue = cast_or_null<OpaqueValueExpr>(Record.readSubStmt());\n  E->setIsImplicit(Record.readInt() != 0);\n}\n\nvoid ASTStmtReader::VisitCoyieldExpr(CoyieldExpr *E) {\n  VisitExpr(E);\n  E->KeywordLoc = readSourceLocation();\n  for (auto &SubExpr: E->SubExprs)\n    SubExpr = Record.readSubStmt();\n  E->OpaqueValue = cast_or_null<OpaqueValueExpr>(Record.readSubStmt());\n}\n\nvoid ASTStmtReader::VisitDependentCoawaitExpr(DependentCoawaitExpr *E) {\n  VisitExpr(E);\n  E->KeywordLoc = readSourceLocation();\n  for (auto &SubExpr: E->SubExprs)\n    SubExpr = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitCapturedStmt(CapturedStmt *S) {\n  VisitStmt(S);\n  Record.skipInts(1);\n  S->setCapturedDecl(readDeclAs<CapturedDecl>());\n  S->setCapturedRegionKind(static_cast<CapturedRegionKind>(Record.readInt()));\n  S->setCapturedRecordDecl(readDeclAs<RecordDecl>());\n\n  // Capture inits\n  for (CapturedStmt::capture_init_iterator I = S->capture_init_begin(),\n                                           E = S->capture_init_end();\n       I != E; ++I)\n    *I = Record.readSubExpr();\n\n  // Body\n  S->setCapturedStmt(Record.readSubStmt());\n  S->getCapturedDecl()->setBody(S->getCapturedStmt());\n\n  // Captures\n  for (auto &I : S->captures()) {\n    I.VarAndKind.setPointer(readDeclAs<VarDecl>());\n    I.VarAndKind.setInt(\n        static_cast<CapturedStmt::VariableCaptureKind>(Record.readInt()));\n    I.Loc = readSourceLocation();\n  }\n}\n\nvoid ASTStmtReader::VisitExpr(Expr *E) {\n  VisitStmt(E);\n  E->setType(Record.readType());\n\n  // FIXME: write and read all DependentFlags with a single call.\n  bool TypeDependent = Record.readInt();\n  bool ValueDependent = Record.readInt();\n  bool InstantiationDependent = Record.readInt();\n  bool ContainsUnexpandedTemplateParameters = Record.readInt();\n  bool ContainsErrors = Record.readInt();\n  auto Deps = ExprDependence::None;\n  if (TypeDependent)\n    Deps |= ExprDependence::Type;\n  if (ValueDependent)\n    Deps |= ExprDependence::Value;\n  if (InstantiationDependent)\n    Deps |= ExprDependence::Instantiation;\n  if (ContainsUnexpandedTemplateParameters)\n    Deps |= ExprDependence::UnexpandedPack;\n  if (ContainsErrors)\n    Deps |= ExprDependence::Error;\n  E->setDependence(Deps);\n\n  E->setValueKind(static_cast<ExprValueKind>(Record.readInt()));\n  E->setObjectKind(static_cast<ExprObjectKind>(Record.readInt()));\n  assert(Record.getIdx() == NumExprFields &&\n         \"Incorrect expression field count\");\n}\n\nvoid ASTStmtReader::VisitConstantExpr(ConstantExpr *E) {\n  VisitExpr(E);\n\n  auto StorageKind = Record.readInt();\n  assert(E->ConstantExprBits.ResultKind == StorageKind && \"Wrong ResultKind!\");\n\n  E->ConstantExprBits.APValueKind = Record.readInt();\n  E->ConstantExprBits.IsUnsigned = Record.readInt();\n  E->ConstantExprBits.BitWidth = Record.readInt();\n  E->ConstantExprBits.HasCleanup = false; // Not serialized, see below.\n  E->ConstantExprBits.IsImmediateInvocation = Record.readInt();\n\n  switch (StorageKind) {\n  case ConstantExpr::RSK_None:\n    break;\n\n  case ConstantExpr::RSK_Int64:\n    E->Int64Result() = Record.readInt();\n    break;\n\n  case ConstantExpr::RSK_APValue:\n    E->APValueResult() = Record.readAPValue();\n    if (E->APValueResult().needsCleanup()) {\n      E->ConstantExprBits.HasCleanup = true;\n      Record.getContext().addDestruction(&E->APValueResult());\n    }\n    break;\n  default:\n    llvm_unreachable(\"unexpected ResultKind!\");\n  }\n\n  E->setSubExpr(Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitPredefinedExpr(PredefinedExpr *E) {\n  VisitExpr(E);\n  bool HasFunctionName = Record.readInt();\n  E->PredefinedExprBits.HasFunctionName = HasFunctionName;\n  E->PredefinedExprBits.Kind = Record.readInt();\n  E->setLocation(readSourceLocation());\n  if (HasFunctionName)\n    E->setFunctionName(cast<StringLiteral>(Record.readSubExpr()));\n}\n\nvoid ASTStmtReader::VisitDeclRefExpr(DeclRefExpr *E) {\n  VisitExpr(E);\n\n  E->DeclRefExprBits.HasQualifier = Record.readInt();\n  E->DeclRefExprBits.HasFoundDecl = Record.readInt();\n  E->DeclRefExprBits.HasTemplateKWAndArgsInfo = Record.readInt();\n  E->DeclRefExprBits.HadMultipleCandidates = Record.readInt();\n  E->DeclRefExprBits.RefersToEnclosingVariableOrCapture = Record.readInt();\n  E->DeclRefExprBits.NonOdrUseReason = Record.readInt();\n  unsigned NumTemplateArgs = 0;\n  if (E->hasTemplateKWAndArgsInfo())\n    NumTemplateArgs = Record.readInt();\n\n  if (E->hasQualifier())\n    new (E->getTrailingObjects<NestedNameSpecifierLoc>())\n        NestedNameSpecifierLoc(Record.readNestedNameSpecifierLoc());\n\n  if (E->hasFoundDecl())\n    *E->getTrailingObjects<NamedDecl *>() = readDeclAs<NamedDecl>();\n\n  if (E->hasTemplateKWAndArgsInfo())\n    ReadTemplateKWAndArgsInfo(\n        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),\n        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);\n\n  E->D = readDeclAs<ValueDecl>();\n  E->setLocation(readSourceLocation());\n  E->DNLoc = Record.readDeclarationNameLoc(E->getDecl()->getDeclName());\n}\n\nvoid ASTStmtReader::VisitIntegerLiteral(IntegerLiteral *E) {\n  VisitExpr(E);\n  E->setLocation(readSourceLocation());\n  E->setValue(Record.getContext(), Record.readAPInt());\n}\n\nvoid ASTStmtReader::VisitFixedPointLiteral(FixedPointLiteral *E) {\n  VisitExpr(E);\n  E->setLocation(readSourceLocation());\n  E->setScale(Record.readInt());\n  E->setValue(Record.getContext(), Record.readAPInt());\n}\n\nvoid ASTStmtReader::VisitFloatingLiteral(FloatingLiteral *E) {\n  VisitExpr(E);\n  E->setRawSemantics(\n      static_cast<llvm::APFloatBase::Semantics>(Record.readInt()));\n  E->setExact(Record.readInt());\n  E->setValue(Record.getContext(), Record.readAPFloat(E->getSemantics()));\n  E->setLocation(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitImaginaryLiteral(ImaginaryLiteral *E) {\n  VisitExpr(E);\n  E->setSubExpr(Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitStringLiteral(StringLiteral *E) {\n  VisitExpr(E);\n\n  // NumConcatenated, Length and CharByteWidth are set by the empty\n  // ctor since they are needed to allocate storage for the trailing objects.\n  unsigned NumConcatenated = Record.readInt();\n  unsigned Length = Record.readInt();\n  unsigned CharByteWidth = Record.readInt();\n  assert((NumConcatenated == E->getNumConcatenated()) &&\n         \"Wrong number of concatenated tokens!\");\n  assert((Length == E->getLength()) && \"Wrong Length!\");\n  assert((CharByteWidth == E->getCharByteWidth()) && \"Wrong character width!\");\n  E->StringLiteralBits.Kind = Record.readInt();\n  E->StringLiteralBits.IsPascal = Record.readInt();\n\n  // The character width is originally computed via mapCharByteWidth.\n  // Check that the deserialized character width is consistant with the result\n  // of calling mapCharByteWidth.\n  assert((CharByteWidth ==\n          StringLiteral::mapCharByteWidth(Record.getContext().getTargetInfo(),\n                                          E->getKind())) &&\n         \"Wrong character width!\");\n\n  // Deserialize the trailing array of SourceLocation.\n  for (unsigned I = 0; I < NumConcatenated; ++I)\n    E->setStrTokenLoc(I, readSourceLocation());\n\n  // Deserialize the trailing array of char holding the string data.\n  char *StrData = E->getStrDataAsChar();\n  for (unsigned I = 0; I < Length * CharByteWidth; ++I)\n    StrData[I] = Record.readInt();\n}\n\nvoid ASTStmtReader::VisitCharacterLiteral(CharacterLiteral *E) {\n  VisitExpr(E);\n  E->setValue(Record.readInt());\n  E->setLocation(readSourceLocation());\n  E->setKind(static_cast<CharacterLiteral::CharacterKind>(Record.readInt()));\n}\n\nvoid ASTStmtReader::VisitParenExpr(ParenExpr *E) {\n  VisitExpr(E);\n  E->setLParen(readSourceLocation());\n  E->setRParen(readSourceLocation());\n  E->setSubExpr(Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitParenListExpr(ParenListExpr *E) {\n  VisitExpr(E);\n  unsigned NumExprs = Record.readInt();\n  assert((NumExprs == E->getNumExprs()) && \"Wrong NumExprs!\");\n  for (unsigned I = 0; I != NumExprs; ++I)\n    E->getTrailingObjects<Stmt *>()[I] = Record.readSubStmt();\n  E->LParenLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitUnaryOperator(UnaryOperator *E) {\n  VisitExpr(E);\n  bool hasFP_Features = Record.readInt();\n  assert(hasFP_Features == E->hasStoredFPFeatures());\n  E->setSubExpr(Record.readSubExpr());\n  E->setOpcode((UnaryOperator::Opcode)Record.readInt());\n  E->setOperatorLoc(readSourceLocation());\n  E->setCanOverflow(Record.readInt());\n  if (hasFP_Features)\n    E->setStoredFPFeatures(\n        FPOptionsOverride::getFromOpaqueInt(Record.readInt()));\n}\n\nvoid ASTStmtReader::VisitOffsetOfExpr(OffsetOfExpr *E) {\n  VisitExpr(E);\n  assert(E->getNumComponents() == Record.peekInt());\n  Record.skipInts(1);\n  assert(E->getNumExpressions() == Record.peekInt());\n  Record.skipInts(1);\n  E->setOperatorLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n  E->setTypeSourceInfo(readTypeSourceInfo());\n  for (unsigned I = 0, N = E->getNumComponents(); I != N; ++I) {\n    auto Kind = static_cast<OffsetOfNode::Kind>(Record.readInt());\n    SourceLocation Start = readSourceLocation();\n    SourceLocation End = readSourceLocation();\n    switch (Kind) {\n    case OffsetOfNode::Array:\n      E->setComponent(I, OffsetOfNode(Start, Record.readInt(), End));\n      break;\n\n    case OffsetOfNode::Field:\n      E->setComponent(\n          I, OffsetOfNode(Start, readDeclAs<FieldDecl>(), End));\n      break;\n\n    case OffsetOfNode::Identifier:\n      E->setComponent(\n          I,\n          OffsetOfNode(Start, Record.readIdentifier(), End));\n      break;\n\n    case OffsetOfNode::Base: {\n      auto *Base = new (Record.getContext()) CXXBaseSpecifier();\n      *Base = Record.readCXXBaseSpecifier();\n      E->setComponent(I, OffsetOfNode(Base));\n      break;\n    }\n    }\n  }\n\n  for (unsigned I = 0, N = E->getNumExpressions(); I != N; ++I)\n    E->setIndexExpr(I, Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitUnaryExprOrTypeTraitExpr(UnaryExprOrTypeTraitExpr *E) {\n  VisitExpr(E);\n  E->setKind(static_cast<UnaryExprOrTypeTrait>(Record.readInt()));\n  if (Record.peekInt() == 0) {\n    E->setArgument(Record.readSubExpr());\n    Record.skipInts(1);\n  } else {\n    E->setArgument(readTypeSourceInfo());\n  }\n  E->setOperatorLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nstatic ConstraintSatisfaction\nreadConstraintSatisfaction(ASTRecordReader &Record) {\n  ConstraintSatisfaction Satisfaction;\n  Satisfaction.IsSatisfied = Record.readInt();\n  if (!Satisfaction.IsSatisfied) {\n    unsigned NumDetailRecords = Record.readInt();\n    for (unsigned i = 0; i != NumDetailRecords; ++i) {\n      Expr *ConstraintExpr = Record.readExpr();\n      if (/* IsDiagnostic */Record.readInt()) {\n        SourceLocation DiagLocation = Record.readSourceLocation();\n        std::string DiagMessage = Record.readString();\n        Satisfaction.Details.emplace_back(\n            ConstraintExpr, new (Record.getContext())\n                                ConstraintSatisfaction::SubstitutionDiagnostic{\n                                    DiagLocation, DiagMessage});\n      } else\n        Satisfaction.Details.emplace_back(ConstraintExpr, Record.readExpr());\n    }\n  }\n  return Satisfaction;\n}\n\nvoid ASTStmtReader::VisitConceptSpecializationExpr(\n        ConceptSpecializationExpr *E) {\n  VisitExpr(E);\n  unsigned NumTemplateArgs = Record.readInt();\n  E->NestedNameSpec = Record.readNestedNameSpecifierLoc();\n  E->TemplateKWLoc = Record.readSourceLocation();\n  E->ConceptName = Record.readDeclarationNameInfo();\n  E->NamedConcept = readDeclAs<ConceptDecl>();\n  E->FoundDecl = Record.readDeclAs<NamedDecl>();\n  E->ArgsAsWritten = Record.readASTTemplateArgumentListInfo();\n  llvm::SmallVector<TemplateArgument, 4> Args;\n  for (unsigned I = 0; I < NumTemplateArgs; ++I)\n    Args.push_back(Record.readTemplateArgument());\n  E->setTemplateArguments(Args);\n  E->Satisfaction = E->isValueDependent() ? nullptr :\n      ASTConstraintSatisfaction::Create(Record.getContext(),\n                                        readConstraintSatisfaction(Record));\n}\n\nstatic concepts::Requirement::SubstitutionDiagnostic *\nreadSubstitutionDiagnostic(ASTRecordReader &Record) {\n  std::string SubstitutedEntity = Record.readString();\n  SourceLocation DiagLoc = Record.readSourceLocation();\n  std::string DiagMessage = Record.readString();\n  return new (Record.getContext())\n      concepts::Requirement::SubstitutionDiagnostic{SubstitutedEntity, DiagLoc,\n                                                    DiagMessage};\n}\n\nvoid ASTStmtReader::VisitRequiresExpr(RequiresExpr *E) {\n  VisitExpr(E);\n  unsigned NumLocalParameters = Record.readInt();\n  unsigned NumRequirements = Record.readInt();\n  E->RequiresExprBits.RequiresKWLoc = Record.readSourceLocation();\n  E->RequiresExprBits.IsSatisfied = Record.readInt();\n  E->Body = Record.readDeclAs<RequiresExprBodyDecl>();\n  llvm::SmallVector<ParmVarDecl *, 4> LocalParameters;\n  for (unsigned i = 0; i < NumLocalParameters; ++i)\n    LocalParameters.push_back(cast<ParmVarDecl>(Record.readDecl()));\n  std::copy(LocalParameters.begin(), LocalParameters.end(),\n            E->getTrailingObjects<ParmVarDecl *>());\n  llvm::SmallVector<concepts::Requirement *, 4> Requirements;\n  for (unsigned i = 0; i < NumRequirements; ++i) {\n    auto RK =\n        static_cast<concepts::Requirement::RequirementKind>(Record.readInt());\n    concepts::Requirement *R = nullptr;\n    switch (RK) {\n      case concepts::Requirement::RK_Type: {\n        auto Status =\n            static_cast<concepts::TypeRequirement::SatisfactionStatus>(\n                Record.readInt());\n        if (Status == concepts::TypeRequirement::SS_SubstitutionFailure)\n          R = new (Record.getContext())\n              concepts::TypeRequirement(readSubstitutionDiagnostic(Record));\n        else\n          R = new (Record.getContext())\n              concepts::TypeRequirement(Record.readTypeSourceInfo());\n      } break;\n      case concepts::Requirement::RK_Simple:\n      case concepts::Requirement::RK_Compound: {\n        auto Status =\n            static_cast<concepts::ExprRequirement::SatisfactionStatus>(\n                Record.readInt());\n        llvm::PointerUnion<concepts::Requirement::SubstitutionDiagnostic *,\n                           Expr *> E;\n        if (Status == concepts::ExprRequirement::SS_ExprSubstitutionFailure) {\n          E = readSubstitutionDiagnostic(Record);\n        } else\n          E = Record.readExpr();\n\n        llvm::Optional<concepts::ExprRequirement::ReturnTypeRequirement> Req;\n        ConceptSpecializationExpr *SubstitutedConstraintExpr = nullptr;\n        SourceLocation NoexceptLoc;\n        if (RK == concepts::Requirement::RK_Simple) {\n          Req.emplace();\n        } else {\n          NoexceptLoc = Record.readSourceLocation();\n          switch (/* returnTypeRequirementKind */Record.readInt()) {\n            case 0:\n              // No return type requirement.\n              Req.emplace();\n              break;\n            case 1: {\n              // type-constraint\n              TemplateParameterList *TPL = Record.readTemplateParameterList();\n              if (Status >=\n                  concepts::ExprRequirement::SS_ConstraintsNotSatisfied)\n                SubstitutedConstraintExpr =\n                    cast<ConceptSpecializationExpr>(Record.readExpr());\n              Req.emplace(TPL);\n            } break;\n            case 2:\n              // Substitution failure\n              Req.emplace(readSubstitutionDiagnostic(Record));\n              break;\n          }\n        }\n        if (Expr *Ex = E.dyn_cast<Expr *>())\n          R = new (Record.getContext()) concepts::ExprRequirement(\n                  Ex, RK == concepts::Requirement::RK_Simple, NoexceptLoc,\n                  std::move(*Req), Status, SubstitutedConstraintExpr);\n        else\n          R = new (Record.getContext()) concepts::ExprRequirement(\n                  E.get<concepts::Requirement::SubstitutionDiagnostic *>(),\n                  RK == concepts::Requirement::RK_Simple, NoexceptLoc,\n                  std::move(*Req));\n      } break;\n      case concepts::Requirement::RK_Nested: {\n        if (/* IsSubstitutionDiagnostic */Record.readInt()) {\n          R = new (Record.getContext()) concepts::NestedRequirement(\n              readSubstitutionDiagnostic(Record));\n          break;\n        }\n        Expr *E = Record.readExpr();\n        if (E->isInstantiationDependent())\n          R = new (Record.getContext()) concepts::NestedRequirement(E);\n        else\n          R = new (Record.getContext())\n              concepts::NestedRequirement(Record.getContext(), E,\n                                          readConstraintSatisfaction(Record));\n      } break;\n    }\n    if (!R)\n      continue;\n    Requirements.push_back(R);\n  }\n  std::copy(Requirements.begin(), Requirements.end(),\n            E->getTrailingObjects<concepts::Requirement *>());\n  E->RBraceLoc = Record.readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitArraySubscriptExpr(ArraySubscriptExpr *E) {\n  VisitExpr(E);\n  E->setLHS(Record.readSubExpr());\n  E->setRHS(Record.readSubExpr());\n  E->setRBracketLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitMatrixSubscriptExpr(MatrixSubscriptExpr *E) {\n  VisitExpr(E);\n  E->setBase(Record.readSubExpr());\n  E->setRowIdx(Record.readSubExpr());\n  E->setColumnIdx(Record.readSubExpr());\n  E->setRBracketLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitOMPArraySectionExpr(OMPArraySectionExpr *E) {\n  VisitExpr(E);\n  E->setBase(Record.readSubExpr());\n  E->setLowerBound(Record.readSubExpr());\n  E->setLength(Record.readSubExpr());\n  E->setStride(Record.readSubExpr());\n  E->setColonLocFirst(readSourceLocation());\n  E->setColonLocSecond(readSourceLocation());\n  E->setRBracketLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitOMPArrayShapingExpr(OMPArrayShapingExpr *E) {\n  VisitExpr(E);\n  unsigned NumDims = Record.readInt();\n  E->setBase(Record.readSubExpr());\n  SmallVector<Expr *, 4> Dims(NumDims);\n  for (unsigned I = 0; I < NumDims; ++I)\n    Dims[I] = Record.readSubExpr();\n  E->setDimensions(Dims);\n  SmallVector<SourceRange, 4> SRs(NumDims);\n  for (unsigned I = 0; I < NumDims; ++I)\n    SRs[I] = readSourceRange();\n  E->setBracketsRanges(SRs);\n  E->setLParenLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitOMPIteratorExpr(OMPIteratorExpr *E) {\n  VisitExpr(E);\n  unsigned NumIters = Record.readInt();\n  E->setIteratorKwLoc(readSourceLocation());\n  E->setLParenLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n  for (unsigned I = 0; I < NumIters; ++I) {\n    E->setIteratorDeclaration(I, Record.readDeclRef());\n    E->setAssignmentLoc(I, readSourceLocation());\n    Expr *Begin = Record.readSubExpr();\n    Expr *End = Record.readSubExpr();\n    Expr *Step = Record.readSubExpr();\n    SourceLocation ColonLoc = readSourceLocation();\n    SourceLocation SecColonLoc;\n    if (Step)\n      SecColonLoc = readSourceLocation();\n    E->setIteratorRange(I, Begin, ColonLoc, End, SecColonLoc, Step);\n    // Deserialize helpers\n    OMPIteratorHelperData HD;\n    HD.CounterVD = cast_or_null<VarDecl>(Record.readDeclRef());\n    HD.Upper = Record.readSubExpr();\n    HD.Update = Record.readSubExpr();\n    HD.CounterUpdate = Record.readSubExpr();\n    E->setHelper(I, HD);\n  }\n}\n\nvoid ASTStmtReader::VisitCallExpr(CallExpr *E) {\n  VisitExpr(E);\n  unsigned NumArgs = Record.readInt();\n  bool HasFPFeatures = Record.readInt();\n  assert((NumArgs == E->getNumArgs()) && \"Wrong NumArgs!\");\n  E->setRParenLoc(readSourceLocation());\n  E->setCallee(Record.readSubExpr());\n  for (unsigned I = 0; I != NumArgs; ++I)\n    E->setArg(I, Record.readSubExpr());\n  E->setADLCallKind(static_cast<CallExpr::ADLCallKind>(Record.readInt()));\n  if (HasFPFeatures)\n    E->setStoredFPFeatures(\n        FPOptionsOverride::getFromOpaqueInt(Record.readInt()));\n}\n\nvoid ASTStmtReader::VisitCXXMemberCallExpr(CXXMemberCallExpr *E) {\n  VisitCallExpr(E);\n}\n\nvoid ASTStmtReader::VisitMemberExpr(MemberExpr *E) {\n  VisitExpr(E);\n\n  bool HasQualifier = Record.readInt();\n  bool HasFoundDecl = Record.readInt();\n  bool HasTemplateInfo = Record.readInt();\n  unsigned NumTemplateArgs = Record.readInt();\n\n  E->Base = Record.readSubExpr();\n  E->MemberDecl = Record.readDeclAs<ValueDecl>();\n  E->MemberDNLoc = Record.readDeclarationNameLoc(E->MemberDecl->getDeclName());\n  E->MemberLoc = Record.readSourceLocation();\n  E->MemberExprBits.IsArrow = Record.readInt();\n  E->MemberExprBits.HasQualifierOrFoundDecl = HasQualifier || HasFoundDecl;\n  E->MemberExprBits.HasTemplateKWAndArgsInfo = HasTemplateInfo;\n  E->MemberExprBits.HadMultipleCandidates = Record.readInt();\n  E->MemberExprBits.NonOdrUseReason = Record.readInt();\n  E->MemberExprBits.OperatorLoc = Record.readSourceLocation();\n\n  if (HasQualifier || HasFoundDecl) {\n    DeclAccessPair FoundDecl;\n    if (HasFoundDecl) {\n      auto *FoundD = Record.readDeclAs<NamedDecl>();\n      auto AS = (AccessSpecifier)Record.readInt();\n      FoundDecl = DeclAccessPair::make(FoundD, AS);\n    } else {\n      FoundDecl = DeclAccessPair::make(E->MemberDecl,\n                                       E->MemberDecl->getAccess());\n    }\n    E->getTrailingObjects<MemberExprNameQualifier>()->FoundDecl = FoundDecl;\n\n    NestedNameSpecifierLoc QualifierLoc;\n    if (HasQualifier)\n      QualifierLoc = Record.readNestedNameSpecifierLoc();\n    E->getTrailingObjects<MemberExprNameQualifier>()->QualifierLoc =\n        QualifierLoc;\n  }\n\n  if (HasTemplateInfo)\n    ReadTemplateKWAndArgsInfo(\n        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),\n        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);\n}\n\nvoid ASTStmtReader::VisitObjCIsaExpr(ObjCIsaExpr *E) {\n  VisitExpr(E);\n  E->setBase(Record.readSubExpr());\n  E->setIsaMemberLoc(readSourceLocation());\n  E->setOpLoc(readSourceLocation());\n  E->setArrow(Record.readInt());\n}\n\nvoid ASTStmtReader::\nVisitObjCIndirectCopyRestoreExpr(ObjCIndirectCopyRestoreExpr *E) {\n  VisitExpr(E);\n  E->Operand = Record.readSubExpr();\n  E->setShouldCopy(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitObjCBridgedCastExpr(ObjCBridgedCastExpr *E) {\n  VisitExplicitCastExpr(E);\n  E->LParenLoc = readSourceLocation();\n  E->BridgeKeywordLoc = readSourceLocation();\n  E->Kind = Record.readInt();\n}\n\nvoid ASTStmtReader::VisitCastExpr(CastExpr *E) {\n  VisitExpr(E);\n  unsigned NumBaseSpecs = Record.readInt();\n  assert(NumBaseSpecs == E->path_size());\n  unsigned HasFPFeatures = Record.readInt();\n  assert(E->hasStoredFPFeatures() == HasFPFeatures);\n  E->setSubExpr(Record.readSubExpr());\n  E->setCastKind((CastKind)Record.readInt());\n  CastExpr::path_iterator BaseI = E->path_begin();\n  while (NumBaseSpecs--) {\n    auto *BaseSpec = new (Record.getContext()) CXXBaseSpecifier;\n    *BaseSpec = Record.readCXXBaseSpecifier();\n    *BaseI++ = BaseSpec;\n  }\n  if (HasFPFeatures)\n    *E->getTrailingFPFeatures() =\n        FPOptionsOverride::getFromOpaqueInt(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitBinaryOperator(BinaryOperator *E) {\n  bool hasFP_Features;\n  BinaryOperator::Opcode opc;\n  VisitExpr(E);\n  E->setHasStoredFPFeatures(hasFP_Features = Record.readInt());\n  E->setOpcode(opc = (BinaryOperator::Opcode)Record.readInt());\n  E->setLHS(Record.readSubExpr());\n  E->setRHS(Record.readSubExpr());\n  E->setOperatorLoc(readSourceLocation());\n  if (hasFP_Features)\n    E->setStoredFPFeatures(\n        FPOptionsOverride::getFromOpaqueInt(Record.readInt()));\n}\n\nvoid ASTStmtReader::VisitCompoundAssignOperator(CompoundAssignOperator *E) {\n  VisitBinaryOperator(E);\n  E->setComputationLHSType(Record.readType());\n  E->setComputationResultType(Record.readType());\n}\n\nvoid ASTStmtReader::VisitConditionalOperator(ConditionalOperator *E) {\n  VisitExpr(E);\n  E->SubExprs[ConditionalOperator::COND] = Record.readSubExpr();\n  E->SubExprs[ConditionalOperator::LHS] = Record.readSubExpr();\n  E->SubExprs[ConditionalOperator::RHS] = Record.readSubExpr();\n  E->QuestionLoc = readSourceLocation();\n  E->ColonLoc = readSourceLocation();\n}\n\nvoid\nASTStmtReader::VisitBinaryConditionalOperator(BinaryConditionalOperator *E) {\n  VisitExpr(E);\n  E->OpaqueValue = cast<OpaqueValueExpr>(Record.readSubExpr());\n  E->SubExprs[BinaryConditionalOperator::COMMON] = Record.readSubExpr();\n  E->SubExprs[BinaryConditionalOperator::COND] = Record.readSubExpr();\n  E->SubExprs[BinaryConditionalOperator::LHS] = Record.readSubExpr();\n  E->SubExprs[BinaryConditionalOperator::RHS] = Record.readSubExpr();\n  E->QuestionLoc = readSourceLocation();\n  E->ColonLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitImplicitCastExpr(ImplicitCastExpr *E) {\n  VisitCastExpr(E);\n  E->setIsPartOfExplicitCast(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitExplicitCastExpr(ExplicitCastExpr *E) {\n  VisitCastExpr(E);\n  E->setTypeInfoAsWritten(readTypeSourceInfo());\n}\n\nvoid ASTStmtReader::VisitCStyleCastExpr(CStyleCastExpr *E) {\n  VisitExplicitCastExpr(E);\n  E->setLParenLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitCompoundLiteralExpr(CompoundLiteralExpr *E) {\n  VisitExpr(E);\n  E->setLParenLoc(readSourceLocation());\n  E->setTypeSourceInfo(readTypeSourceInfo());\n  E->setInitializer(Record.readSubExpr());\n  E->setFileScope(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitExtVectorElementExpr(ExtVectorElementExpr *E) {\n  VisitExpr(E);\n  E->setBase(Record.readSubExpr());\n  E->setAccessor(Record.readIdentifier());\n  E->setAccessorLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitInitListExpr(InitListExpr *E) {\n  VisitExpr(E);\n  if (auto *SyntForm = cast_or_null<InitListExpr>(Record.readSubStmt()))\n    E->setSyntacticForm(SyntForm);\n  E->setLBraceLoc(readSourceLocation());\n  E->setRBraceLoc(readSourceLocation());\n  bool isArrayFiller = Record.readInt();\n  Expr *filler = nullptr;\n  if (isArrayFiller) {\n    filler = Record.readSubExpr();\n    E->ArrayFillerOrUnionFieldInit = filler;\n  } else\n    E->ArrayFillerOrUnionFieldInit = readDeclAs<FieldDecl>();\n  E->sawArrayRangeDesignator(Record.readInt());\n  unsigned NumInits = Record.readInt();\n  E->reserveInits(Record.getContext(), NumInits);\n  if (isArrayFiller) {\n    for (unsigned I = 0; I != NumInits; ++I) {\n      Expr *init = Record.readSubExpr();\n      E->updateInit(Record.getContext(), I, init ? init : filler);\n    }\n  } else {\n    for (unsigned I = 0; I != NumInits; ++I)\n      E->updateInit(Record.getContext(), I, Record.readSubExpr());\n  }\n}\n\nvoid ASTStmtReader::VisitDesignatedInitExpr(DesignatedInitExpr *E) {\n  using Designator = DesignatedInitExpr::Designator;\n\n  VisitExpr(E);\n  unsigned NumSubExprs = Record.readInt();\n  assert(NumSubExprs == E->getNumSubExprs() && \"Wrong number of subexprs\");\n  for (unsigned I = 0; I != NumSubExprs; ++I)\n    E->setSubExpr(I, Record.readSubExpr());\n  E->setEqualOrColonLoc(readSourceLocation());\n  E->setGNUSyntax(Record.readInt());\n\n  SmallVector<Designator, 4> Designators;\n  while (Record.getIdx() < Record.size()) {\n    switch ((DesignatorTypes)Record.readInt()) {\n    case DESIG_FIELD_DECL: {\n      auto *Field = readDeclAs<FieldDecl>();\n      SourceLocation DotLoc = readSourceLocation();\n      SourceLocation FieldLoc = readSourceLocation();\n      Designators.push_back(Designator(Field->getIdentifier(), DotLoc,\n                                       FieldLoc));\n      Designators.back().setField(Field);\n      break;\n    }\n\n    case DESIG_FIELD_NAME: {\n      const IdentifierInfo *Name = Record.readIdentifier();\n      SourceLocation DotLoc = readSourceLocation();\n      SourceLocation FieldLoc = readSourceLocation();\n      Designators.push_back(Designator(Name, DotLoc, FieldLoc));\n      break;\n    }\n\n    case DESIG_ARRAY: {\n      unsigned Index = Record.readInt();\n      SourceLocation LBracketLoc = readSourceLocation();\n      SourceLocation RBracketLoc = readSourceLocation();\n      Designators.push_back(Designator(Index, LBracketLoc, RBracketLoc));\n      break;\n    }\n\n    case DESIG_ARRAY_RANGE: {\n      unsigned Index = Record.readInt();\n      SourceLocation LBracketLoc = readSourceLocation();\n      SourceLocation EllipsisLoc = readSourceLocation();\n      SourceLocation RBracketLoc = readSourceLocation();\n      Designators.push_back(Designator(Index, LBracketLoc, EllipsisLoc,\n                                       RBracketLoc));\n      break;\n    }\n    }\n  }\n  E->setDesignators(Record.getContext(),\n                    Designators.data(), Designators.size());\n}\n\nvoid ASTStmtReader::VisitDesignatedInitUpdateExpr(DesignatedInitUpdateExpr *E) {\n  VisitExpr(E);\n  E->setBase(Record.readSubExpr());\n  E->setUpdater(Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitNoInitExpr(NoInitExpr *E) {\n  VisitExpr(E);\n}\n\nvoid ASTStmtReader::VisitArrayInitLoopExpr(ArrayInitLoopExpr *E) {\n  VisitExpr(E);\n  E->SubExprs[0] = Record.readSubExpr();\n  E->SubExprs[1] = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitArrayInitIndexExpr(ArrayInitIndexExpr *E) {\n  VisitExpr(E);\n}\n\nvoid ASTStmtReader::VisitImplicitValueInitExpr(ImplicitValueInitExpr *E) {\n  VisitExpr(E);\n}\n\nvoid ASTStmtReader::VisitVAArgExpr(VAArgExpr *E) {\n  VisitExpr(E);\n  E->setSubExpr(Record.readSubExpr());\n  E->setWrittenTypeInfo(readTypeSourceInfo());\n  E->setBuiltinLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n  E->setIsMicrosoftABI(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitSourceLocExpr(SourceLocExpr *E) {\n  VisitExpr(E);\n  E->ParentContext = readDeclAs<DeclContext>();\n  E->BuiltinLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n  E->SourceLocExprBits.Kind =\n      static_cast<SourceLocExpr::IdentKind>(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitAddrLabelExpr(AddrLabelExpr *E) {\n  VisitExpr(E);\n  E->setAmpAmpLoc(readSourceLocation());\n  E->setLabelLoc(readSourceLocation());\n  E->setLabel(readDeclAs<LabelDecl>());\n}\n\nvoid ASTStmtReader::VisitStmtExpr(StmtExpr *E) {\n  VisitExpr(E);\n  E->setLParenLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n  E->setSubStmt(cast_or_null<CompoundStmt>(Record.readSubStmt()));\n  E->StmtExprBits.TemplateDepth = Record.readInt();\n}\n\nvoid ASTStmtReader::VisitChooseExpr(ChooseExpr *E) {\n  VisitExpr(E);\n  E->setCond(Record.readSubExpr());\n  E->setLHS(Record.readSubExpr());\n  E->setRHS(Record.readSubExpr());\n  E->setBuiltinLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n  E->setIsConditionTrue(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitGNUNullExpr(GNUNullExpr *E) {\n  VisitExpr(E);\n  E->setTokenLocation(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitShuffleVectorExpr(ShuffleVectorExpr *E) {\n  VisitExpr(E);\n  SmallVector<Expr *, 16> Exprs;\n  unsigned NumExprs = Record.readInt();\n  while (NumExprs--)\n    Exprs.push_back(Record.readSubExpr());\n  E->setExprs(Record.getContext(), Exprs);\n  E->setBuiltinLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitConvertVectorExpr(ConvertVectorExpr *E) {\n  VisitExpr(E);\n  E->BuiltinLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n  E->TInfo = readTypeSourceInfo();\n  E->SrcExpr = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitBlockExpr(BlockExpr *E) {\n  VisitExpr(E);\n  E->setBlockDecl(readDeclAs<BlockDecl>());\n}\n\nvoid ASTStmtReader::VisitGenericSelectionExpr(GenericSelectionExpr *E) {\n  VisitExpr(E);\n\n  unsigned NumAssocs = Record.readInt();\n  assert(NumAssocs == E->getNumAssocs() && \"Wrong NumAssocs!\");\n  E->ResultIndex = Record.readInt();\n  E->GenericSelectionExprBits.GenericLoc = readSourceLocation();\n  E->DefaultLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n\n  Stmt **Stmts = E->getTrailingObjects<Stmt *>();\n  // Add 1 to account for the controlling expression which is the first\n  // expression in the trailing array of Stmt *. This is not needed for\n  // the trailing array of TypeSourceInfo *.\n  for (unsigned I = 0, N = NumAssocs + 1; I < N; ++I)\n    Stmts[I] = Record.readSubExpr();\n\n  TypeSourceInfo **TSIs = E->getTrailingObjects<TypeSourceInfo *>();\n  for (unsigned I = 0, N = NumAssocs; I < N; ++I)\n    TSIs[I] = readTypeSourceInfo();\n}\n\nvoid ASTStmtReader::VisitPseudoObjectExpr(PseudoObjectExpr *E) {\n  VisitExpr(E);\n  unsigned numSemanticExprs = Record.readInt();\n  assert(numSemanticExprs + 1 == E->PseudoObjectExprBits.NumSubExprs);\n  E->PseudoObjectExprBits.ResultIndex = Record.readInt();\n\n  // Read the syntactic expression.\n  E->getSubExprsBuffer()[0] = Record.readSubExpr();\n\n  // Read all the semantic expressions.\n  for (unsigned i = 0; i != numSemanticExprs; ++i) {\n    Expr *subExpr = Record.readSubExpr();\n    E->getSubExprsBuffer()[i+1] = subExpr;\n  }\n}\n\nvoid ASTStmtReader::VisitAtomicExpr(AtomicExpr *E) {\n  VisitExpr(E);\n  E->Op = AtomicExpr::AtomicOp(Record.readInt());\n  E->NumSubExprs = AtomicExpr::getNumSubExprs(E->Op);\n  for (unsigned I = 0; I != E->NumSubExprs; ++I)\n    E->SubExprs[I] = Record.readSubExpr();\n  E->BuiltinLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n}\n\n//===----------------------------------------------------------------------===//\n// Objective-C Expressions and Statements\n\nvoid ASTStmtReader::VisitObjCStringLiteral(ObjCStringLiteral *E) {\n  VisitExpr(E);\n  E->setString(cast<StringLiteral>(Record.readSubStmt()));\n  E->setAtLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCBoxedExpr(ObjCBoxedExpr *E) {\n  VisitExpr(E);\n  // could be one of several IntegerLiteral, FloatLiteral, etc.\n  E->SubExpr = Record.readSubStmt();\n  E->BoxingMethod = readDeclAs<ObjCMethodDecl>();\n  E->Range = readSourceRange();\n}\n\nvoid ASTStmtReader::VisitObjCArrayLiteral(ObjCArrayLiteral *E) {\n  VisitExpr(E);\n  unsigned NumElements = Record.readInt();\n  assert(NumElements == E->getNumElements() && \"Wrong number of elements\");\n  Expr **Elements = E->getElements();\n  for (unsigned I = 0, N = NumElements; I != N; ++I)\n    Elements[I] = Record.readSubExpr();\n  E->ArrayWithObjectsMethod = readDeclAs<ObjCMethodDecl>();\n  E->Range = readSourceRange();\n}\n\nvoid ASTStmtReader::VisitObjCDictionaryLiteral(ObjCDictionaryLiteral *E) {\n  VisitExpr(E);\n  unsigned NumElements = Record.readInt();\n  assert(NumElements == E->getNumElements() && \"Wrong number of elements\");\n  bool HasPackExpansions = Record.readInt();\n  assert(HasPackExpansions == E->HasPackExpansions &&\"Pack expansion mismatch\");\n  auto *KeyValues =\n      E->getTrailingObjects<ObjCDictionaryLiteral::KeyValuePair>();\n  auto *Expansions =\n      E->getTrailingObjects<ObjCDictionaryLiteral::ExpansionData>();\n  for (unsigned I = 0; I != NumElements; ++I) {\n    KeyValues[I].Key = Record.readSubExpr();\n    KeyValues[I].Value = Record.readSubExpr();\n    if (HasPackExpansions) {\n      Expansions[I].EllipsisLoc = readSourceLocation();\n      Expansions[I].NumExpansionsPlusOne = Record.readInt();\n    }\n  }\n  E->DictWithObjectsMethod = readDeclAs<ObjCMethodDecl>();\n  E->Range = readSourceRange();\n}\n\nvoid ASTStmtReader::VisitObjCEncodeExpr(ObjCEncodeExpr *E) {\n  VisitExpr(E);\n  E->setEncodedTypeSourceInfo(readTypeSourceInfo());\n  E->setAtLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCSelectorExpr(ObjCSelectorExpr *E) {\n  VisitExpr(E);\n  E->setSelector(Record.readSelector());\n  E->setAtLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCProtocolExpr(ObjCProtocolExpr *E) {\n  VisitExpr(E);\n  E->setProtocol(readDeclAs<ObjCProtocolDecl>());\n  E->setAtLoc(readSourceLocation());\n  E->ProtoLoc = readSourceLocation();\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCIvarRefExpr(ObjCIvarRefExpr *E) {\n  VisitExpr(E);\n  E->setDecl(readDeclAs<ObjCIvarDecl>());\n  E->setLocation(readSourceLocation());\n  E->setOpLoc(readSourceLocation());\n  E->setBase(Record.readSubExpr());\n  E->setIsArrow(Record.readInt());\n  E->setIsFreeIvar(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitObjCPropertyRefExpr(ObjCPropertyRefExpr *E) {\n  VisitExpr(E);\n  unsigned MethodRefFlags = Record.readInt();\n  bool Implicit = Record.readInt() != 0;\n  if (Implicit) {\n    auto *Getter = readDeclAs<ObjCMethodDecl>();\n    auto *Setter = readDeclAs<ObjCMethodDecl>();\n    E->setImplicitProperty(Getter, Setter, MethodRefFlags);\n  } else {\n    E->setExplicitProperty(readDeclAs<ObjCPropertyDecl>(), MethodRefFlags);\n  }\n  E->setLocation(readSourceLocation());\n  E->setReceiverLocation(readSourceLocation());\n  switch (Record.readInt()) {\n  case 0:\n    E->setBase(Record.readSubExpr());\n    break;\n  case 1:\n    E->setSuperReceiver(Record.readType());\n    break;\n  case 2:\n    E->setClassReceiver(readDeclAs<ObjCInterfaceDecl>());\n    break;\n  }\n}\n\nvoid ASTStmtReader::VisitObjCSubscriptRefExpr(ObjCSubscriptRefExpr *E) {\n  VisitExpr(E);\n  E->setRBracket(readSourceLocation());\n  E->setBaseExpr(Record.readSubExpr());\n  E->setKeyExpr(Record.readSubExpr());\n  E->GetAtIndexMethodDecl = readDeclAs<ObjCMethodDecl>();\n  E->SetAtIndexMethodDecl = readDeclAs<ObjCMethodDecl>();\n}\n\nvoid ASTStmtReader::VisitObjCMessageExpr(ObjCMessageExpr *E) {\n  VisitExpr(E);\n  assert(Record.peekInt() == E->getNumArgs());\n  Record.skipInts(1);\n  unsigned NumStoredSelLocs = Record.readInt();\n  E->SelLocsKind = Record.readInt();\n  E->setDelegateInitCall(Record.readInt());\n  E->IsImplicit = Record.readInt();\n  auto Kind = static_cast<ObjCMessageExpr::ReceiverKind>(Record.readInt());\n  switch (Kind) {\n  case ObjCMessageExpr::Instance:\n    E->setInstanceReceiver(Record.readSubExpr());\n    break;\n\n  case ObjCMessageExpr::Class:\n    E->setClassReceiver(readTypeSourceInfo());\n    break;\n\n  case ObjCMessageExpr::SuperClass:\n  case ObjCMessageExpr::SuperInstance: {\n    QualType T = Record.readType();\n    SourceLocation SuperLoc = readSourceLocation();\n    E->setSuper(SuperLoc, T, Kind == ObjCMessageExpr::SuperInstance);\n    break;\n  }\n  }\n\n  assert(Kind == E->getReceiverKind());\n\n  if (Record.readInt())\n    E->setMethodDecl(readDeclAs<ObjCMethodDecl>());\n  else\n    E->setSelector(Record.readSelector());\n\n  E->LBracLoc = readSourceLocation();\n  E->RBracLoc = readSourceLocation();\n\n  for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)\n    E->setArg(I, Record.readSubExpr());\n\n  SourceLocation *Locs = E->getStoredSelLocs();\n  for (unsigned I = 0; I != NumStoredSelLocs; ++I)\n    Locs[I] = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitObjCForCollectionStmt(ObjCForCollectionStmt *S) {\n  VisitStmt(S);\n  S->setElement(Record.readSubStmt());\n  S->setCollection(Record.readSubExpr());\n  S->setBody(Record.readSubStmt());\n  S->setForLoc(readSourceLocation());\n  S->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCAtCatchStmt(ObjCAtCatchStmt *S) {\n  VisitStmt(S);\n  S->setCatchBody(Record.readSubStmt());\n  S->setCatchParamDecl(readDeclAs<VarDecl>());\n  S->setAtCatchLoc(readSourceLocation());\n  S->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCAtFinallyStmt(ObjCAtFinallyStmt *S) {\n  VisitStmt(S);\n  S->setFinallyBody(Record.readSubStmt());\n  S->setAtFinallyLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCAutoreleasePoolStmt(ObjCAutoreleasePoolStmt *S) {\n  VisitStmt(S); // FIXME: no test coverage.\n  S->setSubStmt(Record.readSubStmt());\n  S->setAtLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCAtTryStmt(ObjCAtTryStmt *S) {\n  VisitStmt(S);\n  assert(Record.peekInt() == S->getNumCatchStmts());\n  Record.skipInts(1);\n  bool HasFinally = Record.readInt();\n  S->setTryBody(Record.readSubStmt());\n  for (unsigned I = 0, N = S->getNumCatchStmts(); I != N; ++I)\n    S->setCatchStmt(I, cast_or_null<ObjCAtCatchStmt>(Record.readSubStmt()));\n\n  if (HasFinally)\n    S->setFinallyStmt(Record.readSubStmt());\n  S->setAtTryLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCAtSynchronizedStmt(ObjCAtSynchronizedStmt *S) {\n  VisitStmt(S); // FIXME: no test coverage.\n  S->setSynchExpr(Record.readSubStmt());\n  S->setSynchBody(Record.readSubStmt());\n  S->setAtSynchronizedLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCAtThrowStmt(ObjCAtThrowStmt *S) {\n  VisitStmt(S); // FIXME: no test coverage.\n  S->setThrowExpr(Record.readSubStmt());\n  S->setThrowLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCBoolLiteralExpr(ObjCBoolLiteralExpr *E) {\n  VisitExpr(E);\n  E->setValue(Record.readInt());\n  E->setLocation(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitObjCAvailabilityCheckExpr(ObjCAvailabilityCheckExpr *E) {\n  VisitExpr(E);\n  SourceRange R = Record.readSourceRange();\n  E->AtLoc = R.getBegin();\n  E->RParen = R.getEnd();\n  E->VersionToCheck = Record.readVersionTuple();\n}\n\n//===----------------------------------------------------------------------===//\n// C++ Expressions and Statements\n//===----------------------------------------------------------------------===//\n\nvoid ASTStmtReader::VisitCXXCatchStmt(CXXCatchStmt *S) {\n  VisitStmt(S);\n  S->CatchLoc = readSourceLocation();\n  S->ExceptionDecl = readDeclAs<VarDecl>();\n  S->HandlerBlock = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitCXXTryStmt(CXXTryStmt *S) {\n  VisitStmt(S);\n  assert(Record.peekInt() == S->getNumHandlers() && \"NumStmtFields is wrong ?\");\n  Record.skipInts(1);\n  S->TryLoc = readSourceLocation();\n  S->getStmts()[0] = Record.readSubStmt();\n  for (unsigned i = 0, e = S->getNumHandlers(); i != e; ++i)\n    S->getStmts()[i + 1] = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitCXXForRangeStmt(CXXForRangeStmt *S) {\n  VisitStmt(S);\n  S->ForLoc = readSourceLocation();\n  S->CoawaitLoc = readSourceLocation();\n  S->ColonLoc = readSourceLocation();\n  S->RParenLoc = readSourceLocation();\n  S->setInit(Record.readSubStmt());\n  S->setRangeStmt(Record.readSubStmt());\n  S->setBeginStmt(Record.readSubStmt());\n  S->setEndStmt(Record.readSubStmt());\n  S->setCond(Record.readSubExpr());\n  S->setInc(Record.readSubExpr());\n  S->setLoopVarStmt(Record.readSubStmt());\n  S->setBody(Record.readSubStmt());\n}\n\nvoid ASTStmtReader::VisitMSDependentExistsStmt(MSDependentExistsStmt *S) {\n  VisitStmt(S);\n  S->KeywordLoc = readSourceLocation();\n  S->IsIfExists = Record.readInt();\n  S->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  S->NameInfo = Record.readDeclarationNameInfo();\n  S->SubStmt = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitCXXOperatorCallExpr(CXXOperatorCallExpr *E) {\n  VisitCallExpr(E);\n  E->CXXOperatorCallExprBits.OperatorKind = Record.readInt();\n  E->Range = Record.readSourceRange();\n}\n\nvoid ASTStmtReader::VisitCXXRewrittenBinaryOperator(\n    CXXRewrittenBinaryOperator *E) {\n  VisitExpr(E);\n  E->CXXRewrittenBinaryOperatorBits.IsReversed = Record.readInt();\n  E->SemanticForm = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitCXXConstructExpr(CXXConstructExpr *E) {\n  VisitExpr(E);\n\n  unsigned NumArgs = Record.readInt();\n  assert((NumArgs == E->getNumArgs()) && \"Wrong NumArgs!\");\n\n  E->CXXConstructExprBits.Elidable = Record.readInt();\n  E->CXXConstructExprBits.HadMultipleCandidates = Record.readInt();\n  E->CXXConstructExprBits.ListInitialization = Record.readInt();\n  E->CXXConstructExprBits.StdInitListInitialization = Record.readInt();\n  E->CXXConstructExprBits.ZeroInitialization = Record.readInt();\n  E->CXXConstructExprBits.ConstructionKind = Record.readInt();\n  E->CXXConstructExprBits.Loc = readSourceLocation();\n  E->Constructor = readDeclAs<CXXConstructorDecl>();\n  E->ParenOrBraceRange = readSourceRange();\n\n  for (unsigned I = 0; I != NumArgs; ++I)\n    E->setArg(I, Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitCXXInheritedCtorInitExpr(CXXInheritedCtorInitExpr *E) {\n  VisitExpr(E);\n  E->Constructor = readDeclAs<CXXConstructorDecl>();\n  E->Loc = readSourceLocation();\n  E->ConstructsVirtualBase = Record.readInt();\n  E->InheritedFromVirtualBase = Record.readInt();\n}\n\nvoid ASTStmtReader::VisitCXXTemporaryObjectExpr(CXXTemporaryObjectExpr *E) {\n  VisitCXXConstructExpr(E);\n  E->TSI = readTypeSourceInfo();\n}\n\nvoid ASTStmtReader::VisitLambdaExpr(LambdaExpr *E) {\n  VisitExpr(E);\n  unsigned NumCaptures = Record.readInt();\n  (void)NumCaptures;\n  assert(NumCaptures == E->LambdaExprBits.NumCaptures);\n  E->IntroducerRange = readSourceRange();\n  E->LambdaExprBits.CaptureDefault = Record.readInt();\n  E->CaptureDefaultLoc = readSourceLocation();\n  E->LambdaExprBits.ExplicitParams = Record.readInt();\n  E->LambdaExprBits.ExplicitResultType = Record.readInt();\n  E->ClosingBrace = readSourceLocation();\n\n  // Read capture initializers.\n  for (LambdaExpr::capture_init_iterator C = E->capture_init_begin(),\n                                         CEnd = E->capture_init_end();\n       C != CEnd; ++C)\n    *C = Record.readSubExpr();\n\n  // The body will be lazily deserialized when needed from the call operator\n  // declaration.\n}\n\nvoid\nASTStmtReader::VisitCXXStdInitializerListExpr(CXXStdInitializerListExpr *E) {\n  VisitExpr(E);\n  E->SubExpr = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitCXXNamedCastExpr(CXXNamedCastExpr *E) {\n  VisitExplicitCastExpr(E);\n  SourceRange R = readSourceRange();\n  E->Loc = R.getBegin();\n  E->RParenLoc = R.getEnd();\n  R = readSourceRange();\n  E->AngleBrackets = R;\n}\n\nvoid ASTStmtReader::VisitCXXStaticCastExpr(CXXStaticCastExpr *E) {\n  return VisitCXXNamedCastExpr(E);\n}\n\nvoid ASTStmtReader::VisitCXXDynamicCastExpr(CXXDynamicCastExpr *E) {\n  return VisitCXXNamedCastExpr(E);\n}\n\nvoid ASTStmtReader::VisitCXXReinterpretCastExpr(CXXReinterpretCastExpr *E) {\n  return VisitCXXNamedCastExpr(E);\n}\n\nvoid ASTStmtReader::VisitCXXAddrspaceCastExpr(CXXAddrspaceCastExpr *E) {\n  return VisitCXXNamedCastExpr(E);\n}\n\nvoid ASTStmtReader::VisitCXXConstCastExpr(CXXConstCastExpr *E) {\n  return VisitCXXNamedCastExpr(E);\n}\n\nvoid ASTStmtReader::VisitCXXFunctionalCastExpr(CXXFunctionalCastExpr *E) {\n  VisitExplicitCastExpr(E);\n  E->setLParenLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitBuiltinBitCastExpr(BuiltinBitCastExpr *E) {\n  VisitExplicitCastExpr(E);\n  E->KWLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitUserDefinedLiteral(UserDefinedLiteral *E) {\n  VisitCallExpr(E);\n  E->UDSuffixLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitCXXBoolLiteralExpr(CXXBoolLiteralExpr *E) {\n  VisitExpr(E);\n  E->setValue(Record.readInt());\n  E->setLocation(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitCXXNullPtrLiteralExpr(CXXNullPtrLiteralExpr *E) {\n  VisitExpr(E);\n  E->setLocation(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitCXXTypeidExpr(CXXTypeidExpr *E) {\n  VisitExpr(E);\n  E->setSourceRange(readSourceRange());\n  if (E->isTypeOperand())\n    E->Operand = readTypeSourceInfo();\n  else\n    E->Operand = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitCXXThisExpr(CXXThisExpr *E) {\n  VisitExpr(E);\n  E->setLocation(readSourceLocation());\n  E->setImplicit(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitCXXThrowExpr(CXXThrowExpr *E) {\n  VisitExpr(E);\n  E->CXXThrowExprBits.ThrowLoc = readSourceLocation();\n  E->Operand = Record.readSubExpr();\n  E->CXXThrowExprBits.IsThrownVariableInScope = Record.readInt();\n}\n\nvoid ASTStmtReader::VisitCXXDefaultArgExpr(CXXDefaultArgExpr *E) {\n  VisitExpr(E);\n  E->Param = readDeclAs<ParmVarDecl>();\n  E->UsedContext = readDeclAs<DeclContext>();\n  E->CXXDefaultArgExprBits.Loc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitCXXDefaultInitExpr(CXXDefaultInitExpr *E) {\n  VisitExpr(E);\n  E->Field = readDeclAs<FieldDecl>();\n  E->UsedContext = readDeclAs<DeclContext>();\n  E->CXXDefaultInitExprBits.Loc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitCXXBindTemporaryExpr(CXXBindTemporaryExpr *E) {\n  VisitExpr(E);\n  E->setTemporary(Record.readCXXTemporary());\n  E->setSubExpr(Record.readSubExpr());\n}\n\nvoid ASTStmtReader::VisitCXXScalarValueInitExpr(CXXScalarValueInitExpr *E) {\n  VisitExpr(E);\n  E->TypeInfo = readTypeSourceInfo();\n  E->CXXScalarValueInitExprBits.RParenLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitCXXNewExpr(CXXNewExpr *E) {\n  VisitExpr(E);\n\n  bool IsArray = Record.readInt();\n  bool HasInit = Record.readInt();\n  unsigned NumPlacementArgs = Record.readInt();\n  bool IsParenTypeId = Record.readInt();\n\n  E->CXXNewExprBits.IsGlobalNew = Record.readInt();\n  E->CXXNewExprBits.ShouldPassAlignment = Record.readInt();\n  E->CXXNewExprBits.UsualArrayDeleteWantsSize = Record.readInt();\n  E->CXXNewExprBits.StoredInitializationStyle = Record.readInt();\n\n  assert((IsArray == E->isArray()) && \"Wrong IsArray!\");\n  assert((HasInit == E->hasInitializer()) && \"Wrong HasInit!\");\n  assert((NumPlacementArgs == E->getNumPlacementArgs()) &&\n         \"Wrong NumPlacementArgs!\");\n  assert((IsParenTypeId == E->isParenTypeId()) && \"Wrong IsParenTypeId!\");\n  (void)IsArray;\n  (void)HasInit;\n  (void)NumPlacementArgs;\n\n  E->setOperatorNew(readDeclAs<FunctionDecl>());\n  E->setOperatorDelete(readDeclAs<FunctionDecl>());\n  E->AllocatedTypeInfo = readTypeSourceInfo();\n  if (IsParenTypeId)\n    E->getTrailingObjects<SourceRange>()[0] = readSourceRange();\n  E->Range = readSourceRange();\n  E->DirectInitRange = readSourceRange();\n\n  // Install all the subexpressions.\n  for (CXXNewExpr::raw_arg_iterator I = E->raw_arg_begin(),\n                                    N = E->raw_arg_end();\n       I != N; ++I)\n    *I = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitCXXDeleteExpr(CXXDeleteExpr *E) {\n  VisitExpr(E);\n  E->CXXDeleteExprBits.GlobalDelete = Record.readInt();\n  E->CXXDeleteExprBits.ArrayForm = Record.readInt();\n  E->CXXDeleteExprBits.ArrayFormAsWritten = Record.readInt();\n  E->CXXDeleteExprBits.UsualArrayDeleteWantsSize = Record.readInt();\n  E->OperatorDelete = readDeclAs<FunctionDecl>();\n  E->Argument = Record.readSubExpr();\n  E->CXXDeleteExprBits.Loc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitCXXPseudoDestructorExpr(CXXPseudoDestructorExpr *E) {\n  VisitExpr(E);\n\n  E->Base = Record.readSubExpr();\n  E->IsArrow = Record.readInt();\n  E->OperatorLoc = readSourceLocation();\n  E->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  E->ScopeType = readTypeSourceInfo();\n  E->ColonColonLoc = readSourceLocation();\n  E->TildeLoc = readSourceLocation();\n\n  IdentifierInfo *II = Record.readIdentifier();\n  if (II)\n    E->setDestroyedType(II, readSourceLocation());\n  else\n    E->setDestroyedType(readTypeSourceInfo());\n}\n\nvoid ASTStmtReader::VisitExprWithCleanups(ExprWithCleanups *E) {\n  VisitExpr(E);\n\n  unsigned NumObjects = Record.readInt();\n  assert(NumObjects == E->getNumObjects());\n  for (unsigned i = 0; i != NumObjects; ++i) {\n    unsigned CleanupKind = Record.readInt();\n    ExprWithCleanups::CleanupObject Obj;\n    if (CleanupKind == COK_Block)\n      Obj = readDeclAs<BlockDecl>();\n    else if (CleanupKind == COK_CompoundLiteral)\n      Obj = cast<CompoundLiteralExpr>(Record.readSubExpr());\n    else\n      llvm_unreachable(\"unexpected cleanup object type\");\n    E->getTrailingObjects<ExprWithCleanups::CleanupObject>()[i] = Obj;\n  }\n\n  E->ExprWithCleanupsBits.CleanupsHaveSideEffects = Record.readInt();\n  E->SubExpr = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitCXXDependentScopeMemberExpr(\n    CXXDependentScopeMemberExpr *E) {\n  VisitExpr(E);\n\n  bool HasTemplateKWAndArgsInfo = Record.readInt();\n  unsigned NumTemplateArgs = Record.readInt();\n  bool HasFirstQualifierFoundInScope = Record.readInt();\n\n  assert((HasTemplateKWAndArgsInfo == E->hasTemplateKWAndArgsInfo()) &&\n         \"Wrong HasTemplateKWAndArgsInfo!\");\n  assert(\n      (HasFirstQualifierFoundInScope == E->hasFirstQualifierFoundInScope()) &&\n      \"Wrong HasFirstQualifierFoundInScope!\");\n\n  if (HasTemplateKWAndArgsInfo)\n    ReadTemplateKWAndArgsInfo(\n        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),\n        E->getTrailingObjects<TemplateArgumentLoc>(), NumTemplateArgs);\n\n  assert((NumTemplateArgs == E->getNumTemplateArgs()) &&\n         \"Wrong NumTemplateArgs!\");\n\n  E->CXXDependentScopeMemberExprBits.IsArrow = Record.readInt();\n  E->CXXDependentScopeMemberExprBits.OperatorLoc = readSourceLocation();\n  E->BaseType = Record.readType();\n  E->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  E->Base = Record.readSubExpr();\n\n  if (HasFirstQualifierFoundInScope)\n    *E->getTrailingObjects<NamedDecl *>() = readDeclAs<NamedDecl>();\n\n  E->MemberNameInfo = Record.readDeclarationNameInfo();\n}\n\nvoid\nASTStmtReader::VisitDependentScopeDeclRefExpr(DependentScopeDeclRefExpr *E) {\n  VisitExpr(E);\n\n  if (Record.readInt()) // HasTemplateKWAndArgsInfo\n    ReadTemplateKWAndArgsInfo(\n        *E->getTrailingObjects<ASTTemplateKWAndArgsInfo>(),\n        E->getTrailingObjects<TemplateArgumentLoc>(),\n        /*NumTemplateArgs=*/Record.readInt());\n\n  E->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  E->NameInfo = Record.readDeclarationNameInfo();\n}\n\nvoid\nASTStmtReader::VisitCXXUnresolvedConstructExpr(CXXUnresolvedConstructExpr *E) {\n  VisitExpr(E);\n  assert(Record.peekInt() == E->getNumArgs() &&\n         \"Read wrong record during creation ?\");\n  Record.skipInts(1);\n  for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)\n    E->setArg(I, Record.readSubExpr());\n  E->TSI = readTypeSourceInfo();\n  E->setLParenLoc(readSourceLocation());\n  E->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitOverloadExpr(OverloadExpr *E) {\n  VisitExpr(E);\n\n  unsigned NumResults = Record.readInt();\n  bool HasTemplateKWAndArgsInfo = Record.readInt();\n  assert((E->getNumDecls() == NumResults) && \"Wrong NumResults!\");\n  assert((E->hasTemplateKWAndArgsInfo() == HasTemplateKWAndArgsInfo) &&\n         \"Wrong HasTemplateKWAndArgsInfo!\");\n\n  if (HasTemplateKWAndArgsInfo) {\n    unsigned NumTemplateArgs = Record.readInt();\n    ReadTemplateKWAndArgsInfo(*E->getTrailingASTTemplateKWAndArgsInfo(),\n                              E->getTrailingTemplateArgumentLoc(),\n                              NumTemplateArgs);\n    assert((E->getNumTemplateArgs() == NumTemplateArgs) &&\n           \"Wrong NumTemplateArgs!\");\n  }\n\n  UnresolvedSet<8> Decls;\n  for (unsigned I = 0; I != NumResults; ++I) {\n    auto *D = readDeclAs<NamedDecl>();\n    auto AS = (AccessSpecifier)Record.readInt();\n    Decls.addDecl(D, AS);\n  }\n\n  DeclAccessPair *Results = E->getTrailingResults();\n  UnresolvedSetIterator Iter = Decls.begin();\n  for (unsigned I = 0; I != NumResults; ++I) {\n    Results[I] = (Iter + I).getPair();\n  }\n\n  E->NameInfo = Record.readDeclarationNameInfo();\n  E->QualifierLoc = Record.readNestedNameSpecifierLoc();\n}\n\nvoid ASTStmtReader::VisitUnresolvedMemberExpr(UnresolvedMemberExpr *E) {\n  VisitOverloadExpr(E);\n  E->UnresolvedMemberExprBits.IsArrow = Record.readInt();\n  E->UnresolvedMemberExprBits.HasUnresolvedUsing = Record.readInt();\n  E->Base = Record.readSubExpr();\n  E->BaseType = Record.readType();\n  E->OperatorLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitUnresolvedLookupExpr(UnresolvedLookupExpr *E) {\n  VisitOverloadExpr(E);\n  E->UnresolvedLookupExprBits.RequiresADL = Record.readInt();\n  E->UnresolvedLookupExprBits.Overloaded = Record.readInt();\n  E->NamingClass = readDeclAs<CXXRecordDecl>();\n}\n\nvoid ASTStmtReader::VisitTypeTraitExpr(TypeTraitExpr *E) {\n  VisitExpr(E);\n  E->TypeTraitExprBits.NumArgs = Record.readInt();\n  E->TypeTraitExprBits.Kind = Record.readInt();\n  E->TypeTraitExprBits.Value = Record.readInt();\n  SourceRange Range = readSourceRange();\n  E->Loc = Range.getBegin();\n  E->RParenLoc = Range.getEnd();\n\n  auto **Args = E->getTrailingObjects<TypeSourceInfo *>();\n  for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)\n    Args[I] = readTypeSourceInfo();\n}\n\nvoid ASTStmtReader::VisitArrayTypeTraitExpr(ArrayTypeTraitExpr *E) {\n  VisitExpr(E);\n  E->ATT = (ArrayTypeTrait)Record.readInt();\n  E->Value = (unsigned int)Record.readInt();\n  SourceRange Range = readSourceRange();\n  E->Loc = Range.getBegin();\n  E->RParen = Range.getEnd();\n  E->QueriedType = readTypeSourceInfo();\n  E->Dimension = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitExpressionTraitExpr(ExpressionTraitExpr *E) {\n  VisitExpr(E);\n  E->ET = (ExpressionTrait)Record.readInt();\n  E->Value = (bool)Record.readInt();\n  SourceRange Range = readSourceRange();\n  E->QueriedExpression = Record.readSubExpr();\n  E->Loc = Range.getBegin();\n  E->RParen = Range.getEnd();\n}\n\nvoid ASTStmtReader::VisitCXXNoexceptExpr(CXXNoexceptExpr *E) {\n  VisitExpr(E);\n  E->CXXNoexceptExprBits.Value = Record.readInt();\n  E->Range = readSourceRange();\n  E->Operand = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitPackExpansionExpr(PackExpansionExpr *E) {\n  VisitExpr(E);\n  E->EllipsisLoc = readSourceLocation();\n  E->NumExpansions = Record.readInt();\n  E->Pattern = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitSizeOfPackExpr(SizeOfPackExpr *E) {\n  VisitExpr(E);\n  unsigned NumPartialArgs = Record.readInt();\n  E->OperatorLoc = readSourceLocation();\n  E->PackLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n  E->Pack = Record.readDeclAs<NamedDecl>();\n  if (E->isPartiallySubstituted()) {\n    assert(E->Length == NumPartialArgs);\n    for (auto *I = E->getTrailingObjects<TemplateArgument>(),\n              *E = I + NumPartialArgs;\n         I != E; ++I)\n      new (I) TemplateArgument(Record.readTemplateArgument());\n  } else if (!E->isValueDependent()) {\n    E->Length = Record.readInt();\n  }\n}\n\nvoid ASTStmtReader::VisitSubstNonTypeTemplateParmExpr(\n                                              SubstNonTypeTemplateParmExpr *E) {\n  VisitExpr(E);\n  E->ParamAndRef.setPointer(readDeclAs<NonTypeTemplateParmDecl>());\n  E->ParamAndRef.setInt(Record.readInt());\n  E->SubstNonTypeTemplateParmExprBits.NameLoc = readSourceLocation();\n  E->Replacement = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitSubstNonTypeTemplateParmPackExpr(\n                                          SubstNonTypeTemplateParmPackExpr *E) {\n  VisitExpr(E);\n  E->Param = readDeclAs<NonTypeTemplateParmDecl>();\n  TemplateArgument ArgPack = Record.readTemplateArgument();\n  if (ArgPack.getKind() != TemplateArgument::Pack)\n    return;\n\n  E->Arguments = ArgPack.pack_begin();\n  E->NumArguments = ArgPack.pack_size();\n  E->NameLoc = readSourceLocation();\n}\n\nvoid ASTStmtReader::VisitFunctionParmPackExpr(FunctionParmPackExpr *E) {\n  VisitExpr(E);\n  E->NumParameters = Record.readInt();\n  E->ParamPack = readDeclAs<ParmVarDecl>();\n  E->NameLoc = readSourceLocation();\n  auto **Parms = E->getTrailingObjects<VarDecl *>();\n  for (unsigned i = 0, n = E->NumParameters; i != n; ++i)\n    Parms[i] = readDeclAs<VarDecl>();\n}\n\nvoid ASTStmtReader::VisitMaterializeTemporaryExpr(MaterializeTemporaryExpr *E) {\n  VisitExpr(E);\n  bool HasMaterialzedDecl = Record.readInt();\n  if (HasMaterialzedDecl)\n    E->State = cast<LifetimeExtendedTemporaryDecl>(Record.readDecl());\n  else\n    E->State = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitCXXFoldExpr(CXXFoldExpr *E) {\n  VisitExpr(E);\n  E->LParenLoc = readSourceLocation();\n  E->EllipsisLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n  E->NumExpansions = Record.readInt();\n  E->SubExprs[0] = Record.readSubExpr();\n  E->SubExprs[1] = Record.readSubExpr();\n  E->SubExprs[2] = Record.readSubExpr();\n  E->Opcode = (BinaryOperatorKind)Record.readInt();\n}\n\nvoid ASTStmtReader::VisitOpaqueValueExpr(OpaqueValueExpr *E) {\n  VisitExpr(E);\n  E->SourceExpr = Record.readSubExpr();\n  E->OpaqueValueExprBits.Loc = readSourceLocation();\n  E->setIsUnique(Record.readInt());\n}\n\nvoid ASTStmtReader::VisitTypoExpr(TypoExpr *E) {\n  llvm_unreachable(\"Cannot read TypoExpr nodes\");\n}\n\nvoid ASTStmtReader::VisitRecoveryExpr(RecoveryExpr *E) {\n  VisitExpr(E);\n  unsigned NumArgs = Record.readInt();\n  E->BeginLoc = readSourceLocation();\n  E->EndLoc = readSourceLocation();\n  assert((NumArgs + 0LL ==\n          std::distance(E->children().begin(), E->children().end())) &&\n         \"Wrong NumArgs!\");\n  (void)NumArgs;\n  for (Stmt *&Child : E->children())\n    Child = Record.readSubStmt();\n}\n\n//===----------------------------------------------------------------------===//\n// Microsoft Expressions and Statements\n//===----------------------------------------------------------------------===//\nvoid ASTStmtReader::VisitMSPropertyRefExpr(MSPropertyRefExpr *E) {\n  VisitExpr(E);\n  E->IsArrow = (Record.readInt() != 0);\n  E->BaseExpr = Record.readSubExpr();\n  E->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  E->MemberLoc = readSourceLocation();\n  E->TheDecl = readDeclAs<MSPropertyDecl>();\n}\n\nvoid ASTStmtReader::VisitMSPropertySubscriptExpr(MSPropertySubscriptExpr *E) {\n  VisitExpr(E);\n  E->setBase(Record.readSubExpr());\n  E->setIdx(Record.readSubExpr());\n  E->setRBracketLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitCXXUuidofExpr(CXXUuidofExpr *E) {\n  VisitExpr(E);\n  E->setSourceRange(readSourceRange());\n  E->Guid = readDeclAs<MSGuidDecl>();\n  if (E->isTypeOperand())\n    E->Operand = readTypeSourceInfo();\n  else\n    E->Operand = Record.readSubExpr();\n}\n\nvoid ASTStmtReader::VisitSEHLeaveStmt(SEHLeaveStmt *S) {\n  VisitStmt(S);\n  S->setLeaveLoc(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitSEHExceptStmt(SEHExceptStmt *S) {\n  VisitStmt(S);\n  S->Loc = readSourceLocation();\n  S->Children[SEHExceptStmt::FILTER_EXPR] = Record.readSubStmt();\n  S->Children[SEHExceptStmt::BLOCK] = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitSEHFinallyStmt(SEHFinallyStmt *S) {\n  VisitStmt(S);\n  S->Loc = readSourceLocation();\n  S->Block = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitSEHTryStmt(SEHTryStmt *S) {\n  VisitStmt(S);\n  S->IsCXXTry = Record.readInt();\n  S->TryLoc = readSourceLocation();\n  S->Children[SEHTryStmt::TRY] = Record.readSubStmt();\n  S->Children[SEHTryStmt::HANDLER] = Record.readSubStmt();\n}\n\n//===----------------------------------------------------------------------===//\n// CUDA Expressions and Statements\n//===----------------------------------------------------------------------===//\n\nvoid ASTStmtReader::VisitCUDAKernelCallExpr(CUDAKernelCallExpr *E) {\n  VisitCallExpr(E);\n  E->setPreArg(CUDAKernelCallExpr::CONFIG, Record.readSubExpr());\n}\n\n//===----------------------------------------------------------------------===//\n// OpenCL Expressions and Statements.\n//===----------------------------------------------------------------------===//\nvoid ASTStmtReader::VisitAsTypeExpr(AsTypeExpr *E) {\n  VisitExpr(E);\n  E->BuiltinLoc = readSourceLocation();\n  E->RParenLoc = readSourceLocation();\n  E->SrcExpr = Record.readSubExpr();\n}\n\n//===----------------------------------------------------------------------===//\n// OpenMP Directives.\n//===----------------------------------------------------------------------===//\n\nvoid ASTStmtReader::VisitOMPCanonicalLoop(OMPCanonicalLoop *S) {\n  VisitStmt(S);\n  for (Stmt *&SubStmt : S->SubStmts)\n    SubStmt = Record.readSubStmt();\n}\n\nvoid ASTStmtReader::VisitOMPExecutableDirective(OMPExecutableDirective *E) {\n  Record.readOMPChildren(E->Data);\n  E->setLocStart(readSourceLocation());\n  E->setLocEnd(readSourceLocation());\n}\n\nvoid ASTStmtReader::VisitOMPLoopBasedDirective(OMPLoopBasedDirective *D) {\n  VisitStmt(D);\n  // Field CollapsedNum was read in ReadStmtFromStream.\n  Record.skipInts(1);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPLoopDirective(OMPLoopDirective *D) {\n  VisitOMPLoopBasedDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPParallelDirective(OMPParallelDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPSimdDirective(OMPSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTileDirective(OMPTileDirective *D) {\n  VisitOMPLoopBasedDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPForDirective(OMPForDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPForSimdDirective(OMPForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPSectionsDirective(OMPSectionsDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPSectionDirective(OMPSectionDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPSingleDirective(OMPSingleDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPMasterDirective(OMPMasterDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPCriticalDirective(OMPCriticalDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->DirName = Record.readDeclarationNameInfo();\n}\n\nvoid ASTStmtReader::VisitOMPParallelForDirective(OMPParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPParallelForSimdDirective(\n    OMPParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPParallelMasterDirective(\n    OMPParallelMasterDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPParallelSectionsDirective(\n    OMPParallelSectionsDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPTaskDirective(OMPTaskDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPTaskyieldDirective(OMPTaskyieldDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPBarrierDirective(OMPBarrierDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTaskwaitDirective(OMPTaskwaitDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTaskgroupDirective(OMPTaskgroupDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPFlushDirective(OMPFlushDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPDepobjDirective(OMPDepobjDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPScanDirective(OMPScanDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPOrderedDirective(OMPOrderedDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPAtomicDirective(OMPAtomicDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->IsXLHSInRHSPart = Record.readBool();\n  D->IsPostfixUpdate = Record.readBool();\n}\n\nvoid ASTStmtReader::VisitOMPTargetDirective(OMPTargetDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetDataDirective(OMPTargetDataDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetEnterDataDirective(\n    OMPTargetEnterDataDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetExitDataDirective(\n    OMPTargetExitDataDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetParallelDirective(\n    OMPTargetParallelDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPTargetParallelForDirective(\n    OMPTargetParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPTeamsDirective(OMPTeamsDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPCancellationPointDirective(\n    OMPCancellationPointDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setCancelRegion(Record.readEnum<OpenMPDirectiveKind>());\n}\n\nvoid ASTStmtReader::VisitOMPCancelDirective(OMPCancelDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n  D->setCancelRegion(Record.readEnum<OpenMPDirectiveKind>());\n}\n\nvoid ASTStmtReader::VisitOMPTaskLoopDirective(OMPTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPTaskLoopSimdDirective(OMPTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPMasterTaskLoopDirective(\n    OMPMasterTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPMasterTaskLoopSimdDirective(\n    OMPMasterTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPParallelMasterTaskLoopDirective(\n    OMPParallelMasterTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPParallelMasterTaskLoopSimdDirective(\n    OMPParallelMasterTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPDistributeDirective(OMPDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetUpdateDirective(OMPTargetUpdateDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPDistributeParallelForDirective(\n    OMPDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPDistributeParallelForSimdDirective(\n    OMPDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPDistributeSimdDirective(\n    OMPDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetParallelForSimdDirective(\n    OMPTargetParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetSimdDirective(OMPTargetSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTeamsDistributeDirective(\n    OMPTeamsDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTeamsDistributeSimdDirective(\n    OMPTeamsDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTeamsDistributeParallelForSimdDirective(\n    OMPTeamsDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTeamsDistributeParallelForDirective(\n    OMPTeamsDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPTargetTeamsDirective(OMPTargetTeamsDirective *D) {\n  VisitStmt(D);\n  VisitOMPExecutableDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetTeamsDistributeDirective(\n    OMPTargetTeamsDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetTeamsDistributeParallelForDirective(\n    OMPTargetTeamsDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n  D->setHasCancel(Record.readBool());\n}\n\nvoid ASTStmtReader::VisitOMPTargetTeamsDistributeParallelForSimdDirective(\n    OMPTargetTeamsDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid ASTStmtReader::VisitOMPTargetTeamsDistributeSimdDirective(\n    OMPTargetTeamsDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\n//===----------------------------------------------------------------------===//\n// ASTReader Implementation\n//===----------------------------------------------------------------------===//\n\nStmt *ASTReader::ReadStmt(ModuleFile &F) {\n  switch (ReadingKind) {\n  case Read_None:\n    llvm_unreachable(\"should not call this when not reading anything\");\n  case Read_Decl:\n  case Read_Type:\n    return ReadStmtFromStream(F);\n  case Read_Stmt:\n    return ReadSubStmt();\n  }\n\n  llvm_unreachable(\"ReadingKind not set ?\");\n}\n\nExpr *ASTReader::ReadExpr(ModuleFile &F) {\n  return cast_or_null<Expr>(ReadStmt(F));\n}\n\nExpr *ASTReader::ReadSubExpr() {\n  return cast_or_null<Expr>(ReadSubStmt());\n}\n\n// Within the bitstream, expressions are stored in Reverse Polish\n// Notation, with each of the subexpressions preceding the\n// expression they are stored in. Subexpressions are stored from last to first.\n// To evaluate expressions, we continue reading expressions and placing them on\n// the stack, with expressions having operands removing those operands from the\n// stack. Evaluation terminates when we see a STMT_STOP record, and\n// the single remaining expression on the stack is our result.\nStmt *ASTReader::ReadStmtFromStream(ModuleFile &F) {\n  ReadingKindTracker ReadingKind(Read_Stmt, *this);\n  llvm::BitstreamCursor &Cursor = F.DeclsCursor;\n\n  // Map of offset to previously deserialized stmt. The offset points\n  // just after the stmt record.\n  llvm::DenseMap<uint64_t, Stmt *> StmtEntries;\n\n#ifndef NDEBUG\n  unsigned PrevNumStmts = StmtStack.size();\n#endif\n\n  ASTRecordReader Record(*this, F);\n  ASTStmtReader Reader(Record, Cursor);\n  Stmt::EmptyShell Empty;\n\n  while (true) {\n    llvm::Expected<llvm::BitstreamEntry> MaybeEntry =\n        Cursor.advanceSkippingSubblocks();\n    if (!MaybeEntry) {\n      Error(toString(MaybeEntry.takeError()));\n      return nullptr;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::SubBlock: // Handled for us already.\n    case llvm::BitstreamEntry::Error:\n      Error(\"malformed block record in AST file\");\n      return nullptr;\n    case llvm::BitstreamEntry::EndBlock:\n      goto Done;\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    ASTContext &Context = getContext();\n    Stmt *S = nullptr;\n    bool Finished = false;\n    bool IsStmtReference = false;\n    Expected<unsigned> MaybeStmtCode = Record.readRecord(Cursor, Entry.ID);\n    if (!MaybeStmtCode) {\n      Error(toString(MaybeStmtCode.takeError()));\n      return nullptr;\n    }\n    switch ((StmtCode)MaybeStmtCode.get()) {\n    case STMT_STOP:\n      Finished = true;\n      break;\n\n    case STMT_REF_PTR:\n      IsStmtReference = true;\n      assert(StmtEntries.find(Record[0]) != StmtEntries.end() &&\n             \"No stmt was recorded for this offset reference!\");\n      S = StmtEntries[Record.readInt()];\n      break;\n\n    case STMT_NULL_PTR:\n      S = nullptr;\n      break;\n\n    case STMT_NULL:\n      S = new (Context) NullStmt(Empty);\n      break;\n\n    case STMT_COMPOUND:\n      S = CompoundStmt::CreateEmpty(\n          Context, /*NumStmts=*/Record[ASTStmtReader::NumStmtFields]);\n      break;\n\n    case STMT_CASE:\n      S = CaseStmt::CreateEmpty(\n          Context,\n          /*CaseStmtIsGNURange*/ Record[ASTStmtReader::NumStmtFields + 3]);\n      break;\n\n    case STMT_DEFAULT:\n      S = new (Context) DefaultStmt(Empty);\n      break;\n\n    case STMT_LABEL:\n      S = new (Context) LabelStmt(Empty);\n      break;\n\n    case STMT_ATTRIBUTED:\n      S = AttributedStmt::CreateEmpty(\n        Context,\n        /*NumAttrs*/Record[ASTStmtReader::NumStmtFields]);\n      break;\n\n    case STMT_IF:\n      S = IfStmt::CreateEmpty(\n          Context,\n          /* HasElse=*/Record[ASTStmtReader::NumStmtFields + 1],\n          /* HasVar=*/Record[ASTStmtReader::NumStmtFields + 2],\n          /* HasInit=*/Record[ASTStmtReader::NumStmtFields + 3]);\n      break;\n\n    case STMT_SWITCH:\n      S = SwitchStmt::CreateEmpty(\n          Context,\n          /* HasInit=*/Record[ASTStmtReader::NumStmtFields],\n          /* HasVar=*/Record[ASTStmtReader::NumStmtFields + 1]);\n      break;\n\n    case STMT_WHILE:\n      S = WhileStmt::CreateEmpty(\n          Context,\n          /* HasVar=*/Record[ASTStmtReader::NumStmtFields]);\n      break;\n\n    case STMT_DO:\n      S = new (Context) DoStmt(Empty);\n      break;\n\n    case STMT_FOR:\n      S = new (Context) ForStmt(Empty);\n      break;\n\n    case STMT_GOTO:\n      S = new (Context) GotoStmt(Empty);\n      break;\n\n    case STMT_INDIRECT_GOTO:\n      S = new (Context) IndirectGotoStmt(Empty);\n      break;\n\n    case STMT_CONTINUE:\n      S = new (Context) ContinueStmt(Empty);\n      break;\n\n    case STMT_BREAK:\n      S = new (Context) BreakStmt(Empty);\n      break;\n\n    case STMT_RETURN:\n      S = ReturnStmt::CreateEmpty(\n          Context, /* HasNRVOCandidate=*/Record[ASTStmtReader::NumStmtFields]);\n      break;\n\n    case STMT_DECL:\n      S = new (Context) DeclStmt(Empty);\n      break;\n\n    case STMT_GCCASM:\n      S = new (Context) GCCAsmStmt(Empty);\n      break;\n\n    case STMT_MSASM:\n      S = new (Context) MSAsmStmt(Empty);\n      break;\n\n    case STMT_CAPTURED:\n      S = CapturedStmt::CreateDeserialized(\n          Context, Record[ASTStmtReader::NumStmtFields]);\n      break;\n\n    case EXPR_CONSTANT:\n      S = ConstantExpr::CreateEmpty(\n          Context, static_cast<ConstantExpr::ResultStorageKind>(\n                       /*StorageKind=*/Record[ASTStmtReader::NumExprFields]));\n      break;\n\n    case EXPR_PREDEFINED:\n      S = PredefinedExpr::CreateEmpty(\n          Context,\n          /*HasFunctionName*/ Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_DECL_REF:\n      S = DeclRefExpr::CreateEmpty(\n        Context,\n        /*HasQualifier=*/Record[ASTStmtReader::NumExprFields],\n        /*HasFoundDecl=*/Record[ASTStmtReader::NumExprFields + 1],\n        /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields + 2],\n        /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields + 2] ?\n          Record[ASTStmtReader::NumExprFields + 6] : 0);\n      break;\n\n    case EXPR_INTEGER_LITERAL:\n      S = IntegerLiteral::Create(Context, Empty);\n      break;\n\n    case EXPR_FIXEDPOINT_LITERAL:\n      S = FixedPointLiteral::Create(Context, Empty);\n      break;\n\n    case EXPR_FLOATING_LITERAL:\n      S = FloatingLiteral::Create(Context, Empty);\n      break;\n\n    case EXPR_IMAGINARY_LITERAL:\n      S = new (Context) ImaginaryLiteral(Empty);\n      break;\n\n    case EXPR_STRING_LITERAL:\n      S = StringLiteral::CreateEmpty(\n          Context,\n          /* NumConcatenated=*/Record[ASTStmtReader::NumExprFields],\n          /* Length=*/Record[ASTStmtReader::NumExprFields + 1],\n          /* CharByteWidth=*/Record[ASTStmtReader::NumExprFields + 2]);\n      break;\n\n    case EXPR_CHARACTER_LITERAL:\n      S = new (Context) CharacterLiteral(Empty);\n      break;\n\n    case EXPR_PAREN:\n      S = new (Context) ParenExpr(Empty);\n      break;\n\n    case EXPR_PAREN_LIST:\n      S = ParenListExpr::CreateEmpty(\n          Context,\n          /* NumExprs=*/Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_UNARY_OPERATOR:\n      S = UnaryOperator::CreateEmpty(Context,\n                                     Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_OFFSETOF:\n      S = OffsetOfExpr::CreateEmpty(Context,\n                                    Record[ASTStmtReader::NumExprFields],\n                                    Record[ASTStmtReader::NumExprFields + 1]);\n      break;\n\n    case EXPR_SIZEOF_ALIGN_OF:\n      S = new (Context) UnaryExprOrTypeTraitExpr(Empty);\n      break;\n\n    case EXPR_ARRAY_SUBSCRIPT:\n      S = new (Context) ArraySubscriptExpr(Empty);\n      break;\n\n    case EXPR_MATRIX_SUBSCRIPT:\n      S = new (Context) MatrixSubscriptExpr(Empty);\n      break;\n\n    case EXPR_OMP_ARRAY_SECTION:\n      S = new (Context) OMPArraySectionExpr(Empty);\n      break;\n\n    case EXPR_OMP_ARRAY_SHAPING:\n      S = OMPArrayShapingExpr::CreateEmpty(\n          Context, Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_OMP_ITERATOR:\n      S = OMPIteratorExpr::CreateEmpty(Context,\n                                       Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CALL:\n      S = CallExpr::CreateEmpty(\n          Context, /*NumArgs=*/Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures=*/Record[ASTStmtReader::NumExprFields + 1], Empty);\n      break;\n\n    case EXPR_RECOVERY:\n      S = RecoveryExpr::CreateEmpty(\n          Context, /*NumArgs=*/Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_MEMBER:\n      S = MemberExpr::CreateEmpty(Context, Record[ASTStmtReader::NumExprFields],\n                                  Record[ASTStmtReader::NumExprFields + 1],\n                                  Record[ASTStmtReader::NumExprFields + 2],\n                                  Record[ASTStmtReader::NumExprFields + 3]);\n      break;\n\n    case EXPR_BINARY_OPERATOR:\n      S = BinaryOperator::CreateEmpty(Context,\n                                      Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_COMPOUND_ASSIGN_OPERATOR:\n      S = CompoundAssignOperator::CreateEmpty(\n          Context, Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CONDITIONAL_OPERATOR:\n      S = new (Context) ConditionalOperator(Empty);\n      break;\n\n    case EXPR_BINARY_CONDITIONAL_OPERATOR:\n      S = new (Context) BinaryConditionalOperator(Empty);\n      break;\n\n    case EXPR_IMPLICIT_CAST:\n      S = ImplicitCastExpr::CreateEmpty(\n          Context,\n          /*PathSize*/ Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures*/ Record[ASTStmtReader::NumExprFields + 1]);\n      break;\n\n    case EXPR_CSTYLE_CAST:\n      S = CStyleCastExpr::CreateEmpty(\n          Context,\n          /*PathSize*/ Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures*/ Record[ASTStmtReader::NumExprFields + 1]);\n      break;\n\n    case EXPR_COMPOUND_LITERAL:\n      S = new (Context) CompoundLiteralExpr(Empty);\n      break;\n\n    case EXPR_EXT_VECTOR_ELEMENT:\n      S = new (Context) ExtVectorElementExpr(Empty);\n      break;\n\n    case EXPR_INIT_LIST:\n      S = new (Context) InitListExpr(Empty);\n      break;\n\n    case EXPR_DESIGNATED_INIT:\n      S = DesignatedInitExpr::CreateEmpty(Context,\n                                     Record[ASTStmtReader::NumExprFields] - 1);\n\n      break;\n\n    case EXPR_DESIGNATED_INIT_UPDATE:\n      S = new (Context) DesignatedInitUpdateExpr(Empty);\n      break;\n\n    case EXPR_IMPLICIT_VALUE_INIT:\n      S = new (Context) ImplicitValueInitExpr(Empty);\n      break;\n\n    case EXPR_NO_INIT:\n      S = new (Context) NoInitExpr(Empty);\n      break;\n\n    case EXPR_ARRAY_INIT_LOOP:\n      S = new (Context) ArrayInitLoopExpr(Empty);\n      break;\n\n    case EXPR_ARRAY_INIT_INDEX:\n      S = new (Context) ArrayInitIndexExpr(Empty);\n      break;\n\n    case EXPR_VA_ARG:\n      S = new (Context) VAArgExpr(Empty);\n      break;\n\n    case EXPR_SOURCE_LOC:\n      S = new (Context) SourceLocExpr(Empty);\n      break;\n\n    case EXPR_ADDR_LABEL:\n      S = new (Context) AddrLabelExpr(Empty);\n      break;\n\n    case EXPR_STMT:\n      S = new (Context) StmtExpr(Empty);\n      break;\n\n    case EXPR_CHOOSE:\n      S = new (Context) ChooseExpr(Empty);\n      break;\n\n    case EXPR_GNU_NULL:\n      S = new (Context) GNUNullExpr(Empty);\n      break;\n\n    case EXPR_SHUFFLE_VECTOR:\n      S = new (Context) ShuffleVectorExpr(Empty);\n      break;\n\n    case EXPR_CONVERT_VECTOR:\n      S = new (Context) ConvertVectorExpr(Empty);\n      break;\n\n    case EXPR_BLOCK:\n      S = new (Context) BlockExpr(Empty);\n      break;\n\n    case EXPR_GENERIC_SELECTION:\n      S = GenericSelectionExpr::CreateEmpty(\n          Context,\n          /*NumAssocs=*/Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_OBJC_STRING_LITERAL:\n      S = new (Context) ObjCStringLiteral(Empty);\n      break;\n\n    case EXPR_OBJC_BOXED_EXPRESSION:\n      S = new (Context) ObjCBoxedExpr(Empty);\n      break;\n\n    case EXPR_OBJC_ARRAY_LITERAL:\n      S = ObjCArrayLiteral::CreateEmpty(Context,\n                                        Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_OBJC_DICTIONARY_LITERAL:\n      S = ObjCDictionaryLiteral::CreateEmpty(Context,\n            Record[ASTStmtReader::NumExprFields],\n            Record[ASTStmtReader::NumExprFields + 1]);\n      break;\n\n    case EXPR_OBJC_ENCODE:\n      S = new (Context) ObjCEncodeExpr(Empty);\n      break;\n\n    case EXPR_OBJC_SELECTOR_EXPR:\n      S = new (Context) ObjCSelectorExpr(Empty);\n      break;\n\n    case EXPR_OBJC_PROTOCOL_EXPR:\n      S = new (Context) ObjCProtocolExpr(Empty);\n      break;\n\n    case EXPR_OBJC_IVAR_REF_EXPR:\n      S = new (Context) ObjCIvarRefExpr(Empty);\n      break;\n\n    case EXPR_OBJC_PROPERTY_REF_EXPR:\n      S = new (Context) ObjCPropertyRefExpr(Empty);\n      break;\n\n    case EXPR_OBJC_SUBSCRIPT_REF_EXPR:\n      S = new (Context) ObjCSubscriptRefExpr(Empty);\n      break;\n\n    case EXPR_OBJC_KVC_REF_EXPR:\n      llvm_unreachable(\"mismatching AST file\");\n\n    case EXPR_OBJC_MESSAGE_EXPR:\n      S = ObjCMessageExpr::CreateEmpty(Context,\n                                     Record[ASTStmtReader::NumExprFields],\n                                     Record[ASTStmtReader::NumExprFields + 1]);\n      break;\n\n    case EXPR_OBJC_ISA:\n      S = new (Context) ObjCIsaExpr(Empty);\n      break;\n\n    case EXPR_OBJC_INDIRECT_COPY_RESTORE:\n      S = new (Context) ObjCIndirectCopyRestoreExpr(Empty);\n      break;\n\n    case EXPR_OBJC_BRIDGED_CAST:\n      S = new (Context) ObjCBridgedCastExpr(Empty);\n      break;\n\n    case STMT_OBJC_FOR_COLLECTION:\n      S = new (Context) ObjCForCollectionStmt(Empty);\n      break;\n\n    case STMT_OBJC_CATCH:\n      S = new (Context) ObjCAtCatchStmt(Empty);\n      break;\n\n    case STMT_OBJC_FINALLY:\n      S = new (Context) ObjCAtFinallyStmt(Empty);\n      break;\n\n    case STMT_OBJC_AT_TRY:\n      S = ObjCAtTryStmt::CreateEmpty(Context,\n                                     Record[ASTStmtReader::NumStmtFields],\n                                     Record[ASTStmtReader::NumStmtFields + 1]);\n      break;\n\n    case STMT_OBJC_AT_SYNCHRONIZED:\n      S = new (Context) ObjCAtSynchronizedStmt(Empty);\n      break;\n\n    case STMT_OBJC_AT_THROW:\n      S = new (Context) ObjCAtThrowStmt(Empty);\n      break;\n\n    case STMT_OBJC_AUTORELEASE_POOL:\n      S = new (Context) ObjCAutoreleasePoolStmt(Empty);\n      break;\n\n    case EXPR_OBJC_BOOL_LITERAL:\n      S = new (Context) ObjCBoolLiteralExpr(Empty);\n      break;\n\n    case EXPR_OBJC_AVAILABILITY_CHECK:\n      S = new (Context) ObjCAvailabilityCheckExpr(Empty);\n      break;\n\n    case STMT_SEH_LEAVE:\n      S = new (Context) SEHLeaveStmt(Empty);\n      break;\n\n    case STMT_SEH_EXCEPT:\n      S = new (Context) SEHExceptStmt(Empty);\n      break;\n\n    case STMT_SEH_FINALLY:\n      S = new (Context) SEHFinallyStmt(Empty);\n      break;\n\n    case STMT_SEH_TRY:\n      S = new (Context) SEHTryStmt(Empty);\n      break;\n\n    case STMT_CXX_CATCH:\n      S = new (Context) CXXCatchStmt(Empty);\n      break;\n\n    case STMT_CXX_TRY:\n      S = CXXTryStmt::Create(Context, Empty,\n             /*numHandlers=*/Record[ASTStmtReader::NumStmtFields]);\n      break;\n\n    case STMT_CXX_FOR_RANGE:\n      S = new (Context) CXXForRangeStmt(Empty);\n      break;\n\n    case STMT_MS_DEPENDENT_EXISTS:\n      S = new (Context) MSDependentExistsStmt(SourceLocation(), true,\n                                              NestedNameSpecifierLoc(),\n                                              DeclarationNameInfo(),\n                                              nullptr);\n      break;\n\n    case STMT_OMP_CANONICAL_LOOP:\n      S = OMPCanonicalLoop::createEmpty(Context);\n      break;\n\n    case STMT_OMP_PARALLEL_DIRECTIVE:\n      S =\n        OMPParallelDirective::CreateEmpty(Context,\n                                          Record[ASTStmtReader::NumStmtFields],\n                                          Empty);\n      break;\n\n    case STMT_OMP_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPSimdDirective::CreateEmpty(Context, NumClauses,\n                                        CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TILE_DIRECTIVE: {\n      unsigned NumLoops = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTileDirective::CreateEmpty(Context, NumClauses, NumLoops);\n      break;\n    }\n\n    case STMT_OMP_FOR_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPForDirective::CreateEmpty(Context, NumClauses, CollapsedNum,\n                                       Empty);\n      break;\n    }\n\n    case STMT_OMP_FOR_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPForSimdDirective::CreateEmpty(Context, NumClauses, CollapsedNum,\n                                           Empty);\n      break;\n    }\n\n    case STMT_OMP_SECTIONS_DIRECTIVE:\n      S = OMPSectionsDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_SECTION_DIRECTIVE:\n      S = OMPSectionDirective::CreateEmpty(Context, Empty);\n      break;\n\n    case STMT_OMP_SINGLE_DIRECTIVE:\n      S = OMPSingleDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_MASTER_DIRECTIVE:\n      S = OMPMasterDirective::CreateEmpty(Context, Empty);\n      break;\n\n    case STMT_OMP_CRITICAL_DIRECTIVE:\n      S = OMPCriticalDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_PARALLEL_FOR_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPParallelForDirective::CreateEmpty(Context, NumClauses,\n                                               CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPParallelForSimdDirective::CreateEmpty(Context, NumClauses,\n                                                   CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_PARALLEL_MASTER_DIRECTIVE:\n      S = OMPParallelMasterDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE:\n      S = OMPParallelSectionsDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TASK_DIRECTIVE:\n      S = OMPTaskDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TASKYIELD_DIRECTIVE:\n      S = OMPTaskyieldDirective::CreateEmpty(Context, Empty);\n      break;\n\n    case STMT_OMP_BARRIER_DIRECTIVE:\n      S = OMPBarrierDirective::CreateEmpty(Context, Empty);\n      break;\n\n    case STMT_OMP_TASKWAIT_DIRECTIVE:\n      S = OMPTaskwaitDirective::CreateEmpty(Context, Empty);\n      break;\n\n    case STMT_OMP_TASKGROUP_DIRECTIVE:\n      S = OMPTaskgroupDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_FLUSH_DIRECTIVE:\n      S = OMPFlushDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_DEPOBJ_DIRECTIVE:\n      S = OMPDepobjDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_SCAN_DIRECTIVE:\n      S = OMPScanDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_ORDERED_DIRECTIVE: {\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields];\n      bool HasAssociatedStmt = Record[ASTStmtReader::NumStmtFields + 2];\n      S = OMPOrderedDirective::CreateEmpty(Context, NumClauses,\n                                           !HasAssociatedStmt, Empty);\n      break;\n    }\n\n    case STMT_OMP_ATOMIC_DIRECTIVE:\n      S = OMPAtomicDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TARGET_DIRECTIVE:\n      S = OMPTargetDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TARGET_DATA_DIRECTIVE:\n      S = OMPTargetDataDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TARGET_ENTER_DATA_DIRECTIVE:\n      S = OMPTargetEnterDataDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TARGET_EXIT_DATA_DIRECTIVE:\n      S = OMPTargetExitDataDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TARGET_PARALLEL_DIRECTIVE:\n      S = OMPTargetParallelDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TARGET_PARALLEL_FOR_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTargetParallelForDirective::CreateEmpty(Context, NumClauses,\n                                                     CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TARGET_UPDATE_DIRECTIVE:\n      S = OMPTargetUpdateDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TEAMS_DIRECTIVE:\n      S = OMPTeamsDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_CANCELLATION_POINT_DIRECTIVE:\n      S = OMPCancellationPointDirective::CreateEmpty(Context, Empty);\n      break;\n\n    case STMT_OMP_CANCEL_DIRECTIVE:\n      S = OMPCancelDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TASKLOOP_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTaskLoopDirective::CreateEmpty(Context, NumClauses, CollapsedNum,\n                                            Empty);\n      break;\n    }\n\n    case STMT_OMP_TASKLOOP_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTaskLoopSimdDirective::CreateEmpty(Context, NumClauses,\n                                                CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_MASTER_TASKLOOP_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPMasterTaskLoopDirective::CreateEmpty(Context, NumClauses,\n                                                  CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_MASTER_TASKLOOP_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPMasterTaskLoopSimdDirective::CreateEmpty(Context, NumClauses,\n                                                      CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_PARALLEL_MASTER_TASKLOOP_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPParallelMasterTaskLoopDirective::CreateEmpty(Context, NumClauses,\n                                                          CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_PARALLEL_MASTER_TASKLOOP_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPParallelMasterTaskLoopSimdDirective::CreateEmpty(\n          Context, NumClauses, CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_DISTRIBUTE_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPDistributeDirective::CreateEmpty(Context, NumClauses, CollapsedNum,\n                                              Empty);\n      break;\n    }\n\n    case STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPDistributeParallelForDirective::CreateEmpty(Context, NumClauses,\n                                                         CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPDistributeParallelForSimdDirective::CreateEmpty(Context, NumClauses,\n                                                             CollapsedNum,\n                                                             Empty);\n      break;\n    }\n\n    case STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPDistributeSimdDirective::CreateEmpty(Context, NumClauses,\n                                                  CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTargetParallelForSimdDirective::CreateEmpty(Context, NumClauses,\n                                                         CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TARGET_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTargetSimdDirective::CreateEmpty(Context, NumClauses, CollapsedNum,\n                                              Empty);\n      break;\n    }\n\n     case STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE: {\n       unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n       unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n       S = OMPTeamsDistributeDirective::CreateEmpty(Context, NumClauses,\n                                                    CollapsedNum, Empty);\n       break;\n    }\n\n    case STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTeamsDistributeSimdDirective::CreateEmpty(Context, NumClauses,\n                                                       CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTeamsDistributeParallelForSimdDirective::CreateEmpty(\n          Context, NumClauses, CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTeamsDistributeParallelForDirective::CreateEmpty(\n          Context, NumClauses, CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TARGET_TEAMS_DIRECTIVE:\n      S = OMPTargetTeamsDirective::CreateEmpty(\n          Context, Record[ASTStmtReader::NumStmtFields], Empty);\n      break;\n\n    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTargetTeamsDistributeDirective::CreateEmpty(Context, NumClauses,\n                                                         CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTargetTeamsDistributeParallelForDirective::CreateEmpty(\n          Context, NumClauses, CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTargetTeamsDistributeParallelForSimdDirective::CreateEmpty(\n          Context, NumClauses, CollapsedNum, Empty);\n      break;\n    }\n\n    case STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE: {\n      unsigned CollapsedNum = Record[ASTStmtReader::NumStmtFields];\n      unsigned NumClauses = Record[ASTStmtReader::NumStmtFields + 1];\n      S = OMPTargetTeamsDistributeSimdDirective::CreateEmpty(\n          Context, NumClauses, CollapsedNum, Empty);\n      break;\n    }\n\n    case EXPR_CXX_OPERATOR_CALL:\n      S = CXXOperatorCallExpr::CreateEmpty(\n          Context, /*NumArgs=*/Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures=*/Record[ASTStmtReader::NumExprFields + 1], Empty);\n      break;\n\n    case EXPR_CXX_MEMBER_CALL:\n      S = CXXMemberCallExpr::CreateEmpty(\n          Context, /*NumArgs=*/Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures=*/Record[ASTStmtReader::NumExprFields + 1], Empty);\n      break;\n\n    case EXPR_CXX_REWRITTEN_BINARY_OPERATOR:\n      S = new (Context) CXXRewrittenBinaryOperator(Empty);\n      break;\n\n    case EXPR_CXX_CONSTRUCT:\n      S = CXXConstructExpr::CreateEmpty(\n          Context,\n          /* NumArgs=*/Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CXX_INHERITED_CTOR_INIT:\n      S = new (Context) CXXInheritedCtorInitExpr(Empty);\n      break;\n\n    case EXPR_CXX_TEMPORARY_OBJECT:\n      S = CXXTemporaryObjectExpr::CreateEmpty(\n          Context,\n          /* NumArgs=*/Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CXX_STATIC_CAST:\n      S = CXXStaticCastExpr::CreateEmpty(\n          Context,\n          /*PathSize*/ Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures*/ Record[ASTStmtReader::NumExprFields + 1]);\n      break;\n\n    case EXPR_CXX_DYNAMIC_CAST:\n      S = CXXDynamicCastExpr::CreateEmpty(Context,\n                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CXX_REINTERPRET_CAST:\n      S = CXXReinterpretCastExpr::CreateEmpty(Context,\n                       /*PathSize*/ Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CXX_CONST_CAST:\n      S = CXXConstCastExpr::CreateEmpty(Context);\n      break;\n\n    case EXPR_CXX_ADDRSPACE_CAST:\n      S = CXXAddrspaceCastExpr::CreateEmpty(Context);\n      break;\n\n    case EXPR_CXX_FUNCTIONAL_CAST:\n      S = CXXFunctionalCastExpr::CreateEmpty(\n          Context,\n          /*PathSize*/ Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures*/ Record[ASTStmtReader::NumExprFields + 1]);\n      break;\n\n    case EXPR_BUILTIN_BIT_CAST:\n      assert(Record[ASTStmtReader::NumExprFields] == 0 && \"Wrong PathSize!\");\n      S = new (Context) BuiltinBitCastExpr(Empty);\n      break;\n\n    case EXPR_USER_DEFINED_LITERAL:\n      S = UserDefinedLiteral::CreateEmpty(\n          Context, /*NumArgs=*/Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures=*/Record[ASTStmtReader::NumExprFields + 1], Empty);\n      break;\n\n    case EXPR_CXX_STD_INITIALIZER_LIST:\n      S = new (Context) CXXStdInitializerListExpr(Empty);\n      break;\n\n    case EXPR_CXX_BOOL_LITERAL:\n      S = new (Context) CXXBoolLiteralExpr(Empty);\n      break;\n\n    case EXPR_CXX_NULL_PTR_LITERAL:\n      S = new (Context) CXXNullPtrLiteralExpr(Empty);\n      break;\n\n    case EXPR_CXX_TYPEID_EXPR:\n      S = new (Context) CXXTypeidExpr(Empty, true);\n      break;\n\n    case EXPR_CXX_TYPEID_TYPE:\n      S = new (Context) CXXTypeidExpr(Empty, false);\n      break;\n\n    case EXPR_CXX_UUIDOF_EXPR:\n      S = new (Context) CXXUuidofExpr(Empty, true);\n      break;\n\n    case EXPR_CXX_PROPERTY_REF_EXPR:\n      S = new (Context) MSPropertyRefExpr(Empty);\n      break;\n\n    case EXPR_CXX_PROPERTY_SUBSCRIPT_EXPR:\n      S = new (Context) MSPropertySubscriptExpr(Empty);\n      break;\n\n    case EXPR_CXX_UUIDOF_TYPE:\n      S = new (Context) CXXUuidofExpr(Empty, false);\n      break;\n\n    case EXPR_CXX_THIS:\n      S = new (Context) CXXThisExpr(Empty);\n      break;\n\n    case EXPR_CXX_THROW:\n      S = new (Context) CXXThrowExpr(Empty);\n      break;\n\n    case EXPR_CXX_DEFAULT_ARG:\n      S = new (Context) CXXDefaultArgExpr(Empty);\n      break;\n\n    case EXPR_CXX_DEFAULT_INIT:\n      S = new (Context) CXXDefaultInitExpr(Empty);\n      break;\n\n    case EXPR_CXX_BIND_TEMPORARY:\n      S = new (Context) CXXBindTemporaryExpr(Empty);\n      break;\n\n    case EXPR_CXX_SCALAR_VALUE_INIT:\n      S = new (Context) CXXScalarValueInitExpr(Empty);\n      break;\n\n    case EXPR_CXX_NEW:\n      S = CXXNewExpr::CreateEmpty(\n          Context,\n          /*IsArray=*/Record[ASTStmtReader::NumExprFields],\n          /*HasInit=*/Record[ASTStmtReader::NumExprFields + 1],\n          /*NumPlacementArgs=*/Record[ASTStmtReader::NumExprFields + 2],\n          /*IsParenTypeId=*/Record[ASTStmtReader::NumExprFields + 3]);\n      break;\n\n    case EXPR_CXX_DELETE:\n      S = new (Context) CXXDeleteExpr(Empty);\n      break;\n\n    case EXPR_CXX_PSEUDO_DESTRUCTOR:\n      S = new (Context) CXXPseudoDestructorExpr(Empty);\n      break;\n\n    case EXPR_EXPR_WITH_CLEANUPS:\n      S = ExprWithCleanups::Create(Context, Empty,\n                                   Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CXX_DEPENDENT_SCOPE_MEMBER:\n      S = CXXDependentScopeMemberExpr::CreateEmpty(\n          Context,\n          /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields],\n          /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields + 1],\n          /*HasFirstQualifierFoundInScope=*/\n          Record[ASTStmtReader::NumExprFields + 2]);\n      break;\n\n    case EXPR_CXX_DEPENDENT_SCOPE_DECL_REF:\n      S = DependentScopeDeclRefExpr::CreateEmpty(Context,\n         /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields],\n                  /*NumTemplateArgs=*/Record[ASTStmtReader::NumExprFields]\n                                   ? Record[ASTStmtReader::NumExprFields + 1]\n                                   : 0);\n      break;\n\n    case EXPR_CXX_UNRESOLVED_CONSTRUCT:\n      S = CXXUnresolvedConstructExpr::CreateEmpty(Context,\n                              /*NumArgs=*/Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_CXX_UNRESOLVED_MEMBER:\n      S = UnresolvedMemberExpr::CreateEmpty(\n          Context,\n          /*NumResults=*/Record[ASTStmtReader::NumExprFields],\n          /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields + 1],\n          /*NumTemplateArgs=*/\n          Record[ASTStmtReader::NumExprFields + 1]\n              ? Record[ASTStmtReader::NumExprFields + 2]\n              : 0);\n      break;\n\n    case EXPR_CXX_UNRESOLVED_LOOKUP:\n      S = UnresolvedLookupExpr::CreateEmpty(\n          Context,\n          /*NumResults=*/Record[ASTStmtReader::NumExprFields],\n          /*HasTemplateKWAndArgsInfo=*/Record[ASTStmtReader::NumExprFields + 1],\n          /*NumTemplateArgs=*/\n          Record[ASTStmtReader::NumExprFields + 1]\n              ? Record[ASTStmtReader::NumExprFields + 2]\n              : 0);\n      break;\n\n    case EXPR_TYPE_TRAIT:\n      S = TypeTraitExpr::CreateDeserialized(Context,\n            Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_ARRAY_TYPE_TRAIT:\n      S = new (Context) ArrayTypeTraitExpr(Empty);\n      break;\n\n    case EXPR_CXX_EXPRESSION_TRAIT:\n      S = new (Context) ExpressionTraitExpr(Empty);\n      break;\n\n    case EXPR_CXX_NOEXCEPT:\n      S = new (Context) CXXNoexceptExpr(Empty);\n      break;\n\n    case EXPR_PACK_EXPANSION:\n      S = new (Context) PackExpansionExpr(Empty);\n      break;\n\n    case EXPR_SIZEOF_PACK:\n      S = SizeOfPackExpr::CreateDeserialized(\n              Context,\n              /*NumPartialArgs=*/Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_SUBST_NON_TYPE_TEMPLATE_PARM:\n      S = new (Context) SubstNonTypeTemplateParmExpr(Empty);\n      break;\n\n    case EXPR_SUBST_NON_TYPE_TEMPLATE_PARM_PACK:\n      S = new (Context) SubstNonTypeTemplateParmPackExpr(Empty);\n      break;\n\n    case EXPR_FUNCTION_PARM_PACK:\n      S = FunctionParmPackExpr::CreateEmpty(Context,\n                                          Record[ASTStmtReader::NumExprFields]);\n      break;\n\n    case EXPR_MATERIALIZE_TEMPORARY:\n      S = new (Context) MaterializeTemporaryExpr(Empty);\n      break;\n\n    case EXPR_CXX_FOLD:\n      S = new (Context) CXXFoldExpr(Empty);\n      break;\n\n    case EXPR_OPAQUE_VALUE:\n      S = new (Context) OpaqueValueExpr(Empty);\n      break;\n\n    case EXPR_CUDA_KERNEL_CALL:\n      S = CUDAKernelCallExpr::CreateEmpty(\n          Context, /*NumArgs=*/Record[ASTStmtReader::NumExprFields],\n          /*HasFPFeatures=*/Record[ASTStmtReader::NumExprFields + 1], Empty);\n      break;\n\n    case EXPR_ASTYPE:\n      S = new (Context) AsTypeExpr(Empty);\n      break;\n\n    case EXPR_PSEUDO_OBJECT: {\n      unsigned numSemanticExprs = Record[ASTStmtReader::NumExprFields];\n      S = PseudoObjectExpr::Create(Context, Empty, numSemanticExprs);\n      break;\n    }\n\n    case EXPR_ATOMIC:\n      S = new (Context) AtomicExpr(Empty);\n      break;\n\n    case EXPR_LAMBDA: {\n      unsigned NumCaptures = Record[ASTStmtReader::NumExprFields];\n      S = LambdaExpr::CreateDeserialized(Context, NumCaptures);\n      break;\n    }\n\n    case STMT_COROUTINE_BODY: {\n      unsigned NumParams = Record[ASTStmtReader::NumStmtFields];\n      S = CoroutineBodyStmt::Create(Context, Empty, NumParams);\n      break;\n    }\n\n    case STMT_CORETURN:\n      S = new (Context) CoreturnStmt(Empty);\n      break;\n\n    case EXPR_COAWAIT:\n      S = new (Context) CoawaitExpr(Empty);\n      break;\n\n    case EXPR_COYIELD:\n      S = new (Context) CoyieldExpr(Empty);\n      break;\n\n    case EXPR_DEPENDENT_COAWAIT:\n      S = new (Context) DependentCoawaitExpr(Empty);\n      break;\n\n    case EXPR_CONCEPT_SPECIALIZATION: {\n      unsigned numTemplateArgs = Record[ASTStmtReader::NumExprFields];\n      S = ConceptSpecializationExpr::Create(Context, Empty, numTemplateArgs);\n      break;\n    }\n\n    case EXPR_REQUIRES:\n      unsigned numLocalParameters = Record[ASTStmtReader::NumExprFields];\n      unsigned numRequirement = Record[ASTStmtReader::NumExprFields + 1];\n      S = RequiresExpr::Create(Context, Empty, numLocalParameters,\n                               numRequirement);\n      break;\n    }\n\n    // We hit a STMT_STOP, so we're done with this expression.\n    if (Finished)\n      break;\n\n    ++NumStatementsRead;\n\n    if (S && !IsStmtReference) {\n      Reader.Visit(S);\n      StmtEntries[Cursor.GetCurrentBitNo()] = S;\n    }\n\n    assert(Record.getIdx() == Record.size() &&\n           \"Invalid deserialization of statement\");\n    StmtStack.push_back(S);\n  }\nDone:\n  assert(StmtStack.size() > PrevNumStmts && \"Read too many sub-stmts!\");\n  assert(StmtStack.size() == PrevNumStmts + 1 && \"Extra expressions on stack!\");\n  return StmtStack.pop_back_val();\n}\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h", "content": "//===- BitstreamReader.h - Low-level bitstream reader interface -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This header defines the BitstreamReader class.  This class can be used to\n// read an arbitrary bitstream, regardless of its contents.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BITSTREAM_BITSTREAMREADER_H\n#define LLVM_BITSTREAM_BITSTREAMREADER_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Bitstream/BitCodes.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n/// This class maintains the abbreviations read from a block info block.\nclass BitstreamBlockInfo {\npublic:\n  /// This contains information emitted to BLOCKINFO_BLOCK blocks. These\n  /// describe abbreviations that all blocks of the specified ID inherit.\n  struct BlockInfo {\n    unsigned BlockID = 0;\n    std::vector<std::shared_ptr<BitCodeAbbrev>> Abbrevs;\n    std::string Name;\n    std::vector<std::pair<unsigned, std::string>> RecordNames;\n  };\n\nprivate:\n  std::vector<BlockInfo> BlockInfoRecords;\n\npublic:\n  /// If there is block info for the specified ID, return it, otherwise return\n  /// null.\n  const BlockInfo *getBlockInfo(unsigned BlockID) const {\n    // Common case, the most recent entry matches BlockID.\n    if (!BlockInfoRecords.empty() && BlockInfoRecords.back().BlockID == BlockID)\n      return &BlockInfoRecords.back();\n\n    for (unsigned i = 0, e = static_cast<unsigned>(BlockInfoRecords.size());\n         i != e; ++i)\n      if (BlockInfoRecords[i].BlockID == BlockID)\n        return &BlockInfoRecords[i];\n    return nullptr;\n  }\n\n  BlockInfo &getOrCreateBlockInfo(unsigned BlockID) {\n    if (const BlockInfo *BI = getBlockInfo(BlockID))\n      return *const_cast<BlockInfo*>(BI);\n\n    // Otherwise, add a new record.\n    BlockInfoRecords.emplace_back();\n    BlockInfoRecords.back().BlockID = BlockID;\n    return BlockInfoRecords.back();\n  }\n};\n\n/// This represents a position within a bitstream. There may be multiple\n/// independent cursors reading within one bitstream, each maintaining their\n/// own local state.\nclass SimpleBitstreamCursor {\n  ArrayRef<uint8_t> BitcodeBytes;\n  size_t NextChar = 0;\n\npublic:\n  /// This is the current data we have pulled from the stream but have not\n  /// returned to the client. This is specifically and intentionally defined to\n  /// follow the word size of the host machine for efficiency. We use word_t in\n  /// places that are aware of this to make it perfectly explicit what is going\n  /// on.\n  using word_t = size_t;\n\nprivate:\n  word_t CurWord = 0;\n\n  /// This is the number of bits in CurWord that are valid. This is always from\n  /// [0...bits_of(size_t)-1] inclusive.\n  unsigned BitsInCurWord = 0;\n\npublic:\n  static const constexpr size_t MaxChunkSize = sizeof(word_t) * 8;\n\n  SimpleBitstreamCursor() = default;\n  explicit SimpleBitstreamCursor(ArrayRef<uint8_t> BitcodeBytes)\n      : BitcodeBytes(BitcodeBytes) {}\n  explicit SimpleBitstreamCursor(StringRef BitcodeBytes)\n      : BitcodeBytes(arrayRefFromStringRef(BitcodeBytes)) {}\n  explicit SimpleBitstreamCursor(MemoryBufferRef BitcodeBytes)\n      : SimpleBitstreamCursor(BitcodeBytes.getBuffer()) {}\n\n  bool canSkipToPos(size_t pos) const {\n    // pos can be skipped to if it is a valid address or one byte past the end.\n    return pos <= BitcodeBytes.size();\n  }\n\n  bool AtEndOfStream() {\n    return BitsInCurWord == 0 && BitcodeBytes.size() <= NextChar;\n  }\n\n  /// Return the bit # of the bit we are reading.\n  uint64_t GetCurrentBitNo() const {\n    return NextChar*CHAR_BIT - BitsInCurWord;\n  }\n\n  // Return the byte # of the current bit.\n  uint64_t getCurrentByteNo() const { return GetCurrentBitNo() / 8; }\n\n  ArrayRef<uint8_t> getBitcodeBytes() const { return BitcodeBytes; }\n\n  /// Reset the stream to the specified bit number.\n  Error JumpToBit(uint64_t BitNo) {\n    size_t ByteNo = size_t(BitNo/8) & ~(sizeof(word_t)-1);\n    unsigned WordBitNo = unsigned(BitNo & (sizeof(word_t)*8-1));\n    assert(canSkipToPos(ByteNo) && \"Invalid location\");\n\n    // Move the cursor to the right word.\n    NextChar = ByteNo;\n    BitsInCurWord = 0;\n\n    // Skip over any bits that are already consumed.\n    if (WordBitNo) {\n      if (Expected<word_t> Res = Read(WordBitNo))\n        return Error::success();\n      else\n        return Res.takeError();\n    }\n\n    return Error::success();\n  }\n\n  /// Get a pointer into the bitstream at the specified byte offset.\n  const uint8_t *getPointerToByte(uint64_t ByteNo, uint64_t NumBytes) {\n    return BitcodeBytes.data() + ByteNo;\n  }\n\n  /// Get a pointer into the bitstream at the specified bit offset.\n  ///\n  /// The bit offset must be on a byte boundary.\n  const uint8_t *getPointerToBit(uint64_t BitNo, uint64_t NumBytes) {\n    assert(!(BitNo % 8) && \"Expected bit on byte boundary\");\n    return getPointerToByte(BitNo / 8, NumBytes);\n  }\n\n  Error fillCurWord() {\n    if (NextChar >= BitcodeBytes.size())\n      return createStringError(std::errc::io_error,\n                               \"Unexpected end of file reading %u of %u bytes\",\n                               NextChar, BitcodeBytes.size());\n\n    // Read the next word from the stream.\n    const uint8_t *NextCharPtr = BitcodeBytes.data() + NextChar;\n    unsigned BytesRead;\n    if (BitcodeBytes.size() >= NextChar + sizeof(word_t)) {\n      BytesRead = sizeof(word_t);\n      CurWord =\n          support::endian::read<word_t, support::little, support::unaligned>(\n              NextCharPtr);\n    } else {\n      // Short read.\n      BytesRead = BitcodeBytes.size() - NextChar;\n      CurWord = 0;\n      for (unsigned B = 0; B != BytesRead; ++B)\n        CurWord |= uint64_t(NextCharPtr[B]) << (B * 8);\n    }\n    NextChar += BytesRead;\n    BitsInCurWord = BytesRead * 8;\n    return Error::success();\n  }\n\n  Expected<word_t> Read(unsigned NumBits) {\n    static const unsigned BitsInWord = MaxChunkSize;\n\n    assert(NumBits && NumBits <= BitsInWord &&\n           \"Cannot return zero or more than BitsInWord bits!\");\n\n    static const unsigned Mask = sizeof(word_t) > 4 ? 0x3f : 0x1f;\n\n    // If the field is fully contained by CurWord, return it quickly.\n    if (BitsInCurWord >= NumBits) {\n      word_t R = CurWord & (~word_t(0) >> (BitsInWord - NumBits));\n\n      // Use a mask to avoid undefined behavior.\n      CurWord >>= (NumBits & Mask);\n\n      BitsInCurWord -= NumBits;\n      return R;\n    }\n\n    word_t R = BitsInCurWord ? CurWord : 0;\n    unsigned BitsLeft = NumBits - BitsInCurWord;\n\n    if (Error fillResult = fillCurWord())\n      return std::move(fillResult);\n\n    // If we run out of data, abort.\n    if (BitsLeft > BitsInCurWord)\n      return createStringError(std::errc::io_error,\n                               \"Unexpected end of file reading %u of %u bits\",\n                               BitsInCurWord, BitsLeft);\n\n    word_t R2 = CurWord & (~word_t(0) >> (BitsInWord - BitsLeft));\n\n    // Use a mask to avoid undefined behavior.\n    CurWord >>= (BitsLeft & Mask);\n\n    BitsInCurWord -= BitsLeft;\n\n    R |= R2 << (NumBits - BitsLeft);\n\n    return R;\n  }\n\n  Expected<uint32_t> ReadVBR(unsigned NumBits) {\n    Expected<unsigned> MaybeRead = Read(NumBits);\n    if (!MaybeRead)\n      return MaybeRead;\n    uint32_t Piece = MaybeRead.get();\n\n    if ((Piece & (1U << (NumBits-1))) == 0)\n      return Piece;\n\n    uint32_t Result = 0;\n    unsigned NextBit = 0;\n    while (true) {\n      Result |= (Piece & ((1U << (NumBits-1))-1)) << NextBit;\n\n      if ((Piece & (1U << (NumBits-1))) == 0)\n        return Result;\n\n      NextBit += NumBits-1;\n      MaybeRead = Read(NumBits);\n      if (!MaybeRead)\n        return MaybeRead;\n      Piece = MaybeRead.get();\n    }\n  }\n\n  // Read a VBR that may have a value up to 64-bits in size. The chunk size of\n  // the VBR must still be <= 32 bits though.\n  Expected<uint64_t> ReadVBR64(unsigned NumBits) {\n    Expected<uint64_t> MaybeRead = Read(NumBits);\n    if (!MaybeRead)\n      return MaybeRead;\n    uint32_t Piece = MaybeRead.get();\n\n    if ((Piece & (1U << (NumBits-1))) == 0)\n      return uint64_t(Piece);\n\n    uint64_t Result = 0;\n    unsigned NextBit = 0;\n    while (true) {\n      Result |= uint64_t(Piece & ((1U << (NumBits-1))-1)) << NextBit;\n\n      if ((Piece & (1U << (NumBits-1))) == 0)\n        return Result;\n\n      NextBit += NumBits-1;\n      MaybeRead = Read(NumBits);\n      if (!MaybeRead)\n        return MaybeRead;\n      Piece = MaybeRead.get();\n    }\n  }\n\n  void SkipToFourByteBoundary() {\n    // If word_t is 64-bits and if we've read less than 32 bits, just dump\n    // the bits we have up to the next 32-bit boundary.\n    if (sizeof(word_t) > 4 &&\n        BitsInCurWord >= 32) {\n      CurWord >>= BitsInCurWord-32;\n      BitsInCurWord = 32;\n      return;\n    }\n\n    BitsInCurWord = 0;\n  }\n\n  /// Return the size of the stream in bytes.\n  size_t SizeInBytes() const { return BitcodeBytes.size(); }\n\n  /// Skip to the end of the file.\n  void skipToEnd() { NextChar = BitcodeBytes.size(); }\n};\n\n/// When advancing through a bitstream cursor, each advance can discover a few\n/// different kinds of entries:\nstruct BitstreamEntry {\n  enum {\n    Error,    // Malformed bitcode was found.\n    EndBlock, // We've reached the end of the current block, (or the end of the\n              // file, which is treated like a series of EndBlock records.\n    SubBlock, // This is the start of a new subblock of a specific ID.\n    Record    // This is a record with a specific AbbrevID.\n  } Kind;\n\n  unsigned ID;\n\n  static BitstreamEntry getError() {\n    BitstreamEntry E; E.Kind = Error; return E;\n  }\n\n  static BitstreamEntry getEndBlock() {\n    BitstreamEntry E; E.Kind = EndBlock; return E;\n  }\n\n  static BitstreamEntry getSubBlock(unsigned ID) {\n    BitstreamEntry E; E.Kind = SubBlock; E.ID = ID; return E;\n  }\n\n  static BitstreamEntry getRecord(unsigned AbbrevID) {\n    BitstreamEntry E; E.Kind = Record; E.ID = AbbrevID; return E;\n  }\n};\n\n/// This represents a position within a bitcode file, implemented on top of a\n/// SimpleBitstreamCursor.\n///\n/// Unlike iterators, BitstreamCursors are heavy-weight objects that should not\n/// be passed by value.\nclass BitstreamCursor : SimpleBitstreamCursor {\n  // This is the declared size of code values used for the current block, in\n  // bits.\n  unsigned CurCodeSize = 2;\n\n  /// Abbrevs installed at in this block.\n  std::vector<std::shared_ptr<BitCodeAbbrev>> CurAbbrevs;\n\n  struct Block {\n    unsigned PrevCodeSize;\n    std::vector<std::shared_ptr<BitCodeAbbrev>> PrevAbbrevs;\n\n    explicit Block(unsigned PCS) : PrevCodeSize(PCS) {}\n  };\n\n  /// This tracks the codesize of parent blocks.\n  SmallVector<Block, 8> BlockScope;\n\n  BitstreamBlockInfo *BlockInfo = nullptr;\n\npublic:\n  static const size_t MaxChunkSize = sizeof(word_t) * 8;\n\n  BitstreamCursor() = default;\n  explicit BitstreamCursor(ArrayRef<uint8_t> BitcodeBytes)\n      : SimpleBitstreamCursor(BitcodeBytes) {}\n  explicit BitstreamCursor(StringRef BitcodeBytes)\n      : SimpleBitstreamCursor(BitcodeBytes) {}\n  explicit BitstreamCursor(MemoryBufferRef BitcodeBytes)\n      : SimpleBitstreamCursor(BitcodeBytes) {}\n\n  using SimpleBitstreamCursor::AtEndOfStream;\n  using SimpleBitstreamCursor::canSkipToPos;\n  using SimpleBitstreamCursor::fillCurWord;\n  using SimpleBitstreamCursor::getBitcodeBytes;\n  using SimpleBitstreamCursor::GetCurrentBitNo;\n  using SimpleBitstreamCursor::getCurrentByteNo;\n  using SimpleBitstreamCursor::getPointerToByte;\n  using SimpleBitstreamCursor::JumpToBit;\n  using SimpleBitstreamCursor::Read;\n  using SimpleBitstreamCursor::ReadVBR;\n  using SimpleBitstreamCursor::ReadVBR64;\n  using SimpleBitstreamCursor::SizeInBytes;\n  using SimpleBitstreamCursor::skipToEnd;\n\n  /// Return the number of bits used to encode an abbrev #.\n  unsigned getAbbrevIDWidth() const { return CurCodeSize; }\n\n  /// Flags that modify the behavior of advance().\n  enum {\n    /// If this flag is used, the advance() method does not automatically pop\n    /// the block scope when the end of a block is reached.\n    AF_DontPopBlockAtEnd = 1,\n\n    /// If this flag is used, abbrev entries are returned just like normal\n    /// records.\n    AF_DontAutoprocessAbbrevs = 2\n  };\n\n  /// Advance the current bitstream, returning the next entry in the stream.\n  Expected<BitstreamEntry> advance(unsigned Flags = 0) {\n    while (true) {\n      if (AtEndOfStream())\n        return BitstreamEntry::getError();\n\n      Expected<unsigned> MaybeCode = ReadCode();\n      if (!MaybeCode)\n        return MaybeCode.takeError();\n      unsigned Code = MaybeCode.get();\n\n      if (Code == bitc::END_BLOCK) {\n        // Pop the end of the block unless Flags tells us not to.\n        if (!(Flags & AF_DontPopBlockAtEnd) && ReadBlockEnd())\n          return BitstreamEntry::getError();\n        return BitstreamEntry::getEndBlock();\n      }\n\n      if (Code == bitc::ENTER_SUBBLOCK) {\n        if (Expected<unsigned> MaybeSubBlock = ReadSubBlockID())\n          return BitstreamEntry::getSubBlock(MaybeSubBlock.get());\n        else\n          return MaybeSubBlock.takeError();\n      }\n\n      if (Code == bitc::DEFINE_ABBREV &&\n          !(Flags & AF_DontAutoprocessAbbrevs)) {\n        // We read and accumulate abbrev's, the client can't do anything with\n        // them anyway.\n        if (Error Err = ReadAbbrevRecord())\n          return std::move(Err);\n        continue;\n      }\n\n      return BitstreamEntry::getRecord(Code);\n    }\n  }\n\n  /// This is a convenience function for clients that don't expect any\n  /// subblocks. This just skips over them automatically.\n  Expected<BitstreamEntry> advanceSkippingSubblocks(unsigned Flags = 0) {\n    while (true) {\n      // If we found a normal entry, return it.\n      Expected<BitstreamEntry> MaybeEntry = advance(Flags);\n      if (!MaybeEntry)\n        return MaybeEntry;\n      BitstreamEntry Entry = MaybeEntry.get();\n\n      if (Entry.Kind != BitstreamEntry::SubBlock)\n        return Entry;\n\n      // If we found a sub-block, just skip over it and check the next entry.\n      if (Error Err = SkipBlock())\n        return std::move(Err);\n    }\n  }\n\n  Expected<unsigned> ReadCode() { return Read(CurCodeSize); }\n\n  // Block header:\n  //    [ENTER_SUBBLOCK, blockid, newcodelen, <align4bytes>, blocklen]\n\n  /// Having read the ENTER_SUBBLOCK code, read the BlockID for the block.\n  Expected<unsigned> ReadSubBlockID() { return ReadVBR(bitc::BlockIDWidth); }\n\n  /// Having read the ENTER_SUBBLOCK abbrevid and a BlockID, skip over the body\n  /// of this block.\n  Error SkipBlock() {\n    // Read and ignore the codelen value.\n    if (Expected<uint32_t> Res = ReadVBR(bitc::CodeLenWidth))\n      ; // Since we are skipping this block, we don't care what code widths are\n        // used inside of it.\n    else\n      return Res.takeError();\n\n    SkipToFourByteBoundary();\n    Expected<unsigned> MaybeNum = Read(bitc::BlockSizeWidth);\n    if (!MaybeNum)\n      return MaybeNum.takeError();\n    size_t NumFourBytes = MaybeNum.get();\n\n    // Check that the block wasn't partially defined, and that the offset isn't\n    // bogus.\n    size_t SkipTo = GetCurrentBitNo() + NumFourBytes * 4 * 8;\n    if (AtEndOfStream())\n      return createStringError(std::errc::illegal_byte_sequence,\n                               \"can't skip block: already at end of stream\");\n    if (!canSkipToPos(SkipTo / 8))\n      return createStringError(std::errc::illegal_byte_sequence,\n                               \"can't skip to bit %zu from %\" PRIu64, SkipTo,\n                               GetCurrentBitNo());\n\n    if (Error Res = JumpToBit(SkipTo))\n      return Res;\n\n    return Error::success();\n  }\n\n  /// Having read the ENTER_SUBBLOCK abbrevid, and enter the block.\n  Error EnterSubBlock(unsigned BlockID, unsigned *NumWordsP = nullptr);\n\n  bool ReadBlockEnd() {\n    if (BlockScope.empty()) return true;\n\n    // Block tail:\n    //    [END_BLOCK, <align4bytes>]\n    SkipToFourByteBoundary();\n\n    popBlockScope();\n    return false;\n  }\n\nprivate:\n  void popBlockScope() {\n    CurCodeSize = BlockScope.back().PrevCodeSize;\n\n    CurAbbrevs = std::move(BlockScope.back().PrevAbbrevs);\n    BlockScope.pop_back();\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Record Processing\n  //===--------------------------------------------------------------------===//\n\npublic:\n  /// Return the abbreviation for the specified AbbrevId.\n  const BitCodeAbbrev *getAbbrev(unsigned AbbrevID) {\n    unsigned AbbrevNo = AbbrevID - bitc::FIRST_APPLICATION_ABBREV;\n    if (AbbrevNo >= CurAbbrevs.size())\n      report_fatal_error(\"Invalid abbrev number\");\n    return CurAbbrevs[AbbrevNo].get();\n  }\n\n  /// Read the current record and discard it, returning the code for the record.\n  Expected<unsigned> skipRecord(unsigned AbbrevID);\n\n  Expected<unsigned> readRecord(unsigned AbbrevID,\n                                SmallVectorImpl<uint64_t> &Vals,\n                                StringRef *Blob = nullptr);\n\n  //===--------------------------------------------------------------------===//\n  // Abbrev Processing\n  //===--------------------------------------------------------------------===//\n  Error ReadAbbrevRecord();\n\n  /// Read and return a block info block from the bitstream. If an error was\n  /// encountered, return None.\n  ///\n  /// \\param ReadBlockInfoNames Whether to read block/record name information in\n  /// the BlockInfo block. Only llvm-bcanalyzer uses this.\n  Expected<Optional<BitstreamBlockInfo>>\n  ReadBlockInfoBlock(bool ReadBlockInfoNames = false);\n\n  /// Set the block info to be used by this BitstreamCursor to interpret\n  /// abbreviated records.\n  void setBlockInfo(BitstreamBlockInfo *BI) { BlockInfo = BI; }\n};\n\n} // end llvm namespace\n\n#endif // LLVM_BITSTREAM_BITSTREAMREADER_H\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 8, "line": 4065}, "message": "'ConditionalOperator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "7a7fa80f2afd1dcb168506ceb0ea6259", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 4127}, "message": "'BinaryConditionalOperator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "250f2883830d4e9a06ba1661f373d6f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 8, "line": 5023}, "message": "'Designator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "c5bb8fffe7bb7ee214b6cae2cc344c44", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 8, "line": 5031}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "bd34335b5174e6839fa2a4d09042db58", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 64}, "message": "'PreprocessorOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h", "reportHash": "f5bf99651a9d7fcdee2f918c486b18f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 33, "line": 10230}, "message": "'OMPDeclareVariantScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "af1eaba6ddff4933125c9d0c8a7c8196", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 1227}, "message": "'InputFileInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "3c99fba0c00668e2d966b3e0479502ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 40, "line": 71}, "message": "'ASTStmtReader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Serialization/ASTReaderStmt.cpp", "reportHash": "c142d42e2a9716914c6ad1c196e5243e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 65, "line": 42}, "message": "'BlockInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h", "reportHash": "cf7908aaac46494004ac81a7d467a0aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
