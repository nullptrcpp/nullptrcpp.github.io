<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaType.cpp", "content": "//===--- SemaType.cpp - Semantic Analysis for Types -----------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements type-related semantic analysis.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"TypeLocBuilder.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTMutationListener.h\"\n#include \"clang/AST/ASTStructuralEquivalence.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeLocVisitor.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/DelayedDiagnostic.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/ParsedTemplate.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/Template.h\"\n#include \"clang/Sema/TemplateInstCallback.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <bitset>\n\nusing namespace clang;\n\nenum TypeDiagSelector {\n  TDS_Function,\n  TDS_Pointer,\n  TDS_ObjCObjOrBlock\n};\n\n/// isOmittedBlockReturnType - Return true if this declarator is missing a\n/// return type because this is a omitted return type on a block literal.\nstatic bool isOmittedBlockReturnType(const Declarator &D) {\n  if (D.getContext() != DeclaratorContext::BlockLiteral ||\n      D.getDeclSpec().hasTypeSpecifier())\n    return false;\n\n  if (D.getNumTypeObjects() == 0)\n    return true;   // ^{ ... }\n\n  if (D.getNumTypeObjects() == 1 &&\n      D.getTypeObject(0).Kind == DeclaratorChunk::Function)\n    return true;   // ^(int X, float Y) { ... }\n\n  return false;\n}\n\n/// diagnoseBadTypeAttribute - Diagnoses a type attribute which\n/// doesn't apply to the given type.\nstatic void diagnoseBadTypeAttribute(Sema &S, const ParsedAttr &attr,\n                                     QualType type) {\n  TypeDiagSelector WhichType;\n  bool useExpansionLoc = true;\n  switch (attr.getKind()) {\n  case ParsedAttr::AT_ObjCGC:\n    WhichType = TDS_Pointer;\n    break;\n  case ParsedAttr::AT_ObjCOwnership:\n    WhichType = TDS_ObjCObjOrBlock;\n    break;\n  default:\n    // Assume everything else was a function attribute.\n    WhichType = TDS_Function;\n    useExpansionLoc = false;\n    break;\n  }\n\n  SourceLocation loc = attr.getLoc();\n  StringRef name = attr.getAttrName()->getName();\n\n  // The GC attributes are usually written with macros;  special-case them.\n  IdentifierInfo *II = attr.isArgIdent(0) ? attr.getArgAsIdent(0)->Ident\n                                          : nullptr;\n  if (useExpansionLoc && loc.isMacroID() && II) {\n    if (II->isStr(\"strong\")) {\n      if (S.findMacroSpelling(loc, \"__strong\")) name = \"__strong\";\n    } else if (II->isStr(\"weak\")) {\n      if (S.findMacroSpelling(loc, \"__weak\")) name = \"__weak\";\n    }\n  }\n\n  S.Diag(loc, diag::warn_type_attribute_wrong_type) << name << WhichType\n    << type;\n}\n\n// objc_gc applies to Objective-C pointers or, otherwise, to the\n// smallest available pointer type (i.e. 'void*' in 'void**').\n#define OBJC_POINTER_TYPE_ATTRS_CASELIST                                       \\\n  case ParsedAttr::AT_ObjCGC:                                                  \\\n  case ParsedAttr::AT_ObjCOwnership\n\n// Calling convention attributes.\n#define CALLING_CONV_ATTRS_CASELIST                                            \\\n  case ParsedAttr::AT_CDecl:                                                   \\\n  case ParsedAttr::AT_FastCall:                                                \\\n  case ParsedAttr::AT_StdCall:                                                 \\\n  case ParsedAttr::AT_ThisCall:                                                \\\n  case ParsedAttr::AT_RegCall:                                                 \\\n  case ParsedAttr::AT_Pascal:                                                  \\\n  case ParsedAttr::AT_SwiftCall:                                               \\\n  case ParsedAttr::AT_VectorCall:                                              \\\n  case ParsedAttr::AT_AArch64VectorPcs:                                        \\\n  case ParsedAttr::AT_MSABI:                                                   \\\n  case ParsedAttr::AT_SysVABI:                                                 \\\n  case ParsedAttr::AT_Pcs:                                                     \\\n  case ParsedAttr::AT_IntelOclBicc:                                            \\\n  case ParsedAttr::AT_PreserveMost:                                            \\\n  case ParsedAttr::AT_PreserveAll\n\n// Function type attributes.\n#define FUNCTION_TYPE_ATTRS_CASELIST                                           \\\n  case ParsedAttr::AT_NSReturnsRetained:                                       \\\n  case ParsedAttr::AT_NoReturn:                                                \\\n  case ParsedAttr::AT_Regparm:                                                 \\\n  case ParsedAttr::AT_CmseNSCall:                                              \\\n  case ParsedAttr::AT_AnyX86NoCallerSavedRegisters:                            \\\n  case ParsedAttr::AT_AnyX86NoCfCheck:                                         \\\n    CALLING_CONV_ATTRS_CASELIST\n\n// Microsoft-specific type qualifiers.\n#define MS_TYPE_ATTRS_CASELIST                                                 \\\n  case ParsedAttr::AT_Ptr32:                                                   \\\n  case ParsedAttr::AT_Ptr64:                                                   \\\n  case ParsedAttr::AT_SPtr:                                                    \\\n  case ParsedAttr::AT_UPtr\n\n// Nullability qualifiers.\n#define NULLABILITY_TYPE_ATTRS_CASELIST                                        \\\n  case ParsedAttr::AT_TypeNonNull:                                             \\\n  case ParsedAttr::AT_TypeNullable:                                            \\\n  case ParsedAttr::AT_TypeNullableResult:                                      \\\n  case ParsedAttr::AT_TypeNullUnspecified\n\nnamespace {\n  /// An object which stores processing state for the entire\n  /// GetTypeForDeclarator process.\n  class TypeProcessingState {\n    Sema &sema;\n\n    /// The declarator being processed.\n    Declarator &declarator;\n\n    /// The index of the declarator chunk we're currently processing.\n    /// May be the total number of valid chunks, indicating the\n    /// DeclSpec.\n    unsigned chunkIndex;\n\n    /// Whether there are non-trivial modifications to the decl spec.\n    bool trivial;\n\n    /// Whether we saved the attributes in the decl spec.\n    bool hasSavedAttrs;\n\n    /// The original set of attributes on the DeclSpec.\n    SmallVector<ParsedAttr *, 2> savedAttrs;\n\n    /// A list of attributes to diagnose the uselessness of when the\n    /// processing is complete.\n    SmallVector<ParsedAttr *, 2> ignoredTypeAttrs;\n\n    /// Attributes corresponding to AttributedTypeLocs that we have not yet\n    /// populated.\n    // FIXME: The two-phase mechanism by which we construct Types and fill\n    // their TypeLocs makes it hard to correctly assign these. We keep the\n    // attributes in creation order as an attempt to make them line up\n    // properly.\n    using TypeAttrPair = std::pair<const AttributedType*, const Attr*>;\n    SmallVector<TypeAttrPair, 8> AttrsForTypes;\n    bool AttrsForTypesSorted = true;\n\n    /// MacroQualifiedTypes mapping to macro expansion locations that will be\n    /// stored in a MacroQualifiedTypeLoc.\n    llvm::DenseMap<const MacroQualifiedType *, SourceLocation> LocsForMacros;\n\n    /// Flag to indicate we parsed a noderef attribute. This is used for\n    /// validating that noderef was used on a pointer or array.\n    bool parsedNoDeref;\n\n  public:\n    TypeProcessingState(Sema &sema, Declarator &declarator)\n        : sema(sema), declarator(declarator),\n          chunkIndex(declarator.getNumTypeObjects()), trivial(true),\n          hasSavedAttrs(false), parsedNoDeref(false) {}\n\n    Sema &getSema() const {\n      return sema;\n    }\n\n    Declarator &getDeclarator() const {\n      return declarator;\n    }\n\n    bool isProcessingDeclSpec() const {\n      return chunkIndex == declarator.getNumTypeObjects();\n    }\n\n    unsigned getCurrentChunkIndex() const {\n      return chunkIndex;\n    }\n\n    void setCurrentChunkIndex(unsigned idx) {\n      assert(idx <= declarator.getNumTypeObjects());\n      chunkIndex = idx;\n    }\n\n    ParsedAttributesView &getCurrentAttributes() const {\n      if (isProcessingDeclSpec())\n        return getMutableDeclSpec().getAttributes();\n      return declarator.getTypeObject(chunkIndex).getAttrs();\n    }\n\n    /// Save the current set of attributes on the DeclSpec.\n    void saveDeclSpecAttrs() {\n      // Don't try to save them multiple times.\n      if (hasSavedAttrs) return;\n\n      DeclSpec &spec = getMutableDeclSpec();\n      for (ParsedAttr &AL : spec.getAttributes())\n        savedAttrs.push_back(&AL);\n      trivial &= savedAttrs.empty();\n      hasSavedAttrs = true;\n    }\n\n    /// Record that we had nowhere to put the given type attribute.\n    /// We will diagnose such attributes later.\n    void addIgnoredTypeAttr(ParsedAttr &attr) {\n      ignoredTypeAttrs.push_back(&attr);\n    }\n\n    /// Diagnose all the ignored type attributes, given that the\n    /// declarator worked out to the given type.\n    void diagnoseIgnoredTypeAttrs(QualType type) const {\n      for (auto *Attr : ignoredTypeAttrs)\n        diagnoseBadTypeAttribute(getSema(), *Attr, type);\n    }\n\n    /// Get an attributed type for the given attribute, and remember the Attr\n    /// object so that we can attach it to the AttributedTypeLoc.\n    QualType getAttributedType(Attr *A, QualType ModifiedType,\n                               QualType EquivType) {\n      QualType T =\n          sema.Context.getAttributedType(A->getKind(), ModifiedType, EquivType);\n      AttrsForTypes.push_back({cast<AttributedType>(T.getTypePtr()), A});\n      AttrsForTypesSorted = false;\n      return T;\n    }\n\n    /// Completely replace the \\c auto in \\p TypeWithAuto by\n    /// \\p Replacement. Also replace \\p TypeWithAuto in \\c TypeAttrPair if\n    /// necessary.\n    QualType ReplaceAutoType(QualType TypeWithAuto, QualType Replacement) {\n      QualType T = sema.ReplaceAutoType(TypeWithAuto, Replacement);\n      if (auto *AttrTy = TypeWithAuto->getAs<AttributedType>()) {\n        // Attributed type still should be an attributed type after replacement.\n        auto *NewAttrTy = cast<AttributedType>(T.getTypePtr());\n        for (TypeAttrPair &A : AttrsForTypes) {\n          if (A.first == AttrTy)\n            A.first = NewAttrTy;\n        }\n        AttrsForTypesSorted = false;\n      }\n      return T;\n    }\n\n    /// Extract and remove the Attr* for a given attributed type.\n    const Attr *takeAttrForAttributedType(const AttributedType *AT) {\n      if (!AttrsForTypesSorted) {\n        llvm::stable_sort(AttrsForTypes, llvm::less_first());\n        AttrsForTypesSorted = true;\n      }\n\n      // FIXME: This is quadratic if we have lots of reuses of the same\n      // attributed type.\n      for (auto It = std::partition_point(\n               AttrsForTypes.begin(), AttrsForTypes.end(),\n               [=](const TypeAttrPair &A) { return A.first < AT; });\n           It != AttrsForTypes.end() && It->first == AT; ++It) {\n        if (It->second) {\n          const Attr *Result = It->second;\n          It->second = nullptr;\n          return Result;\n        }\n      }\n\n      llvm_unreachable(\"no Attr* for AttributedType*\");\n    }\n\n    SourceLocation\n    getExpansionLocForMacroQualifiedType(const MacroQualifiedType *MQT) const {\n      auto FoundLoc = LocsForMacros.find(MQT);\n      assert(FoundLoc != LocsForMacros.end() &&\n             \"Unable to find macro expansion location for MacroQualifedType\");\n      return FoundLoc->second;\n    }\n\n    void setExpansionLocForMacroQualifiedType(const MacroQualifiedType *MQT,\n                                              SourceLocation Loc) {\n      LocsForMacros[MQT] = Loc;\n    }\n\n    void setParsedNoDeref(bool parsed) { parsedNoDeref = parsed; }\n\n    bool didParseNoDeref() const { return parsedNoDeref; }\n\n    ~TypeProcessingState() {\n      if (trivial) return;\n\n      restoreDeclSpecAttrs();\n    }\n\n  private:\n    DeclSpec &getMutableDeclSpec() const {\n      return const_cast<DeclSpec&>(declarator.getDeclSpec());\n    }\n\n    void restoreDeclSpecAttrs() {\n      assert(hasSavedAttrs);\n\n      getMutableDeclSpec().getAttributes().clearListOnly();\n      for (ParsedAttr *AL : savedAttrs)\n        getMutableDeclSpec().getAttributes().addAtEnd(AL);\n    }\n  };\n} // end anonymous namespace\n\nstatic void moveAttrFromListToList(ParsedAttr &attr,\n                                   ParsedAttributesView &fromList,\n                                   ParsedAttributesView &toList) {\n  fromList.remove(&attr);\n  toList.addAtEnd(&attr);\n}\n\n/// The location of a type attribute.\nenum TypeAttrLocation {\n  /// The attribute is in the decl-specifier-seq.\n  TAL_DeclSpec,\n  /// The attribute is part of a DeclaratorChunk.\n  TAL_DeclChunk,\n  /// The attribute is immediately after the declaration's name.\n  TAL_DeclName\n};\n\nstatic void processTypeAttrs(TypeProcessingState &state, QualType &type,\n                             TypeAttrLocation TAL, ParsedAttributesView &attrs);\n\nstatic bool handleFunctionTypeAttr(TypeProcessingState &state, ParsedAttr &attr,\n                                   QualType &type);\n\nstatic bool handleMSPointerTypeQualifierAttr(TypeProcessingState &state,\n                                             ParsedAttr &attr, QualType &type);\n\nstatic bool handleObjCGCTypeAttr(TypeProcessingState &state, ParsedAttr &attr,\n                                 QualType &type);\n\nstatic bool handleObjCOwnershipTypeAttr(TypeProcessingState &state,\n                                        ParsedAttr &attr, QualType &type);\n\nstatic bool handleObjCPointerTypeAttr(TypeProcessingState &state,\n                                      ParsedAttr &attr, QualType &type) {\n  if (attr.getKind() == ParsedAttr::AT_ObjCGC)\n    return handleObjCGCTypeAttr(state, attr, type);\n  assert(attr.getKind() == ParsedAttr::AT_ObjCOwnership);\n  return handleObjCOwnershipTypeAttr(state, attr, type);\n}\n\n/// Given the index of a declarator chunk, check whether that chunk\n/// directly specifies the return type of a function and, if so, find\n/// an appropriate place for it.\n///\n/// \\param i - a notional index which the search will start\n///   immediately inside\n///\n/// \\param onlyBlockPointers Whether we should only look into block\n/// pointer types (vs. all pointer types).\nstatic DeclaratorChunk *maybeMovePastReturnType(Declarator &declarator,\n                                                unsigned i,\n                                                bool onlyBlockPointers) {\n  assert(i <= declarator.getNumTypeObjects());\n\n  DeclaratorChunk *result = nullptr;\n\n  // First, look inwards past parens for a function declarator.\n  for (; i != 0; --i) {\n    DeclaratorChunk &fnChunk = declarator.getTypeObject(i-1);\n    switch (fnChunk.Kind) {\n    case DeclaratorChunk::Paren:\n      continue;\n\n    // If we find anything except a function, bail out.\n    case DeclaratorChunk::Pointer:\n    case DeclaratorChunk::BlockPointer:\n    case DeclaratorChunk::Array:\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Pipe:\n      return result;\n\n    // If we do find a function declarator, scan inwards from that,\n    // looking for a (block-)pointer declarator.\n    case DeclaratorChunk::Function:\n      for (--i; i != 0; --i) {\n        DeclaratorChunk &ptrChunk = declarator.getTypeObject(i-1);\n        switch (ptrChunk.Kind) {\n        case DeclaratorChunk::Paren:\n        case DeclaratorChunk::Array:\n        case DeclaratorChunk::Function:\n        case DeclaratorChunk::Reference:\n        case DeclaratorChunk::Pipe:\n          continue;\n\n        case DeclaratorChunk::MemberPointer:\n        case DeclaratorChunk::Pointer:\n          if (onlyBlockPointers)\n            continue;\n\n          LLVM_FALLTHROUGH;\n\n        case DeclaratorChunk::BlockPointer:\n          result = &ptrChunk;\n          goto continue_outer;\n        }\n        llvm_unreachable(\"bad declarator chunk kind\");\n      }\n\n      // If we run out of declarators doing that, we're done.\n      return result;\n    }\n    llvm_unreachable(\"bad declarator chunk kind\");\n\n    // Okay, reconsider from our new point.\n  continue_outer: ;\n  }\n\n  // Ran out of chunks, bail out.\n  return result;\n}\n\n/// Given that an objc_gc attribute was written somewhere on a\n/// declaration *other* than on the declarator itself (for which, use\n/// distributeObjCPointerTypeAttrFromDeclarator), and given that it\n/// didn't apply in whatever position it was written in, try to move\n/// it to a more appropriate position.\nstatic void distributeObjCPointerTypeAttr(TypeProcessingState &state,\n                                          ParsedAttr &attr, QualType type) {\n  Declarator &declarator = state.getDeclarator();\n\n  // Move it to the outermost normal or block pointer declarator.\n  for (unsigned i = state.getCurrentChunkIndex(); i != 0; --i) {\n    DeclaratorChunk &chunk = declarator.getTypeObject(i-1);\n    switch (chunk.Kind) {\n    case DeclaratorChunk::Pointer:\n    case DeclaratorChunk::BlockPointer: {\n      // But don't move an ARC ownership attribute to the return type\n      // of a block.\n      DeclaratorChunk *destChunk = nullptr;\n      if (state.isProcessingDeclSpec() &&\n          attr.getKind() == ParsedAttr::AT_ObjCOwnership)\n        destChunk = maybeMovePastReturnType(declarator, i - 1,\n                                            /*onlyBlockPointers=*/true);\n      if (!destChunk) destChunk = &chunk;\n\n      moveAttrFromListToList(attr, state.getCurrentAttributes(),\n                             destChunk->getAttrs());\n      return;\n    }\n\n    case DeclaratorChunk::Paren:\n    case DeclaratorChunk::Array:\n      continue;\n\n    // We may be starting at the return type of a block.\n    case DeclaratorChunk::Function:\n      if (state.isProcessingDeclSpec() &&\n          attr.getKind() == ParsedAttr::AT_ObjCOwnership) {\n        if (DeclaratorChunk *dest = maybeMovePastReturnType(\n                                      declarator, i,\n                                      /*onlyBlockPointers=*/true)) {\n          moveAttrFromListToList(attr, state.getCurrentAttributes(),\n                                 dest->getAttrs());\n          return;\n        }\n      }\n      goto error;\n\n    // Don't walk through these.\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Pipe:\n      goto error;\n    }\n  }\n error:\n\n  diagnoseBadTypeAttribute(state.getSema(), attr, type);\n}\n\n/// Distribute an objc_gc type attribute that was written on the\n/// declarator.\nstatic void distributeObjCPointerTypeAttrFromDeclarator(\n    TypeProcessingState &state, ParsedAttr &attr, QualType &declSpecType) {\n  Declarator &declarator = state.getDeclarator();\n\n  // objc_gc goes on the innermost pointer to something that's not a\n  // pointer.\n  unsigned innermost = -1U;\n  bool considerDeclSpec = true;\n  for (unsigned i = 0, e = declarator.getNumTypeObjects(); i != e; ++i) {\n    DeclaratorChunk &chunk = declarator.getTypeObject(i);\n    switch (chunk.Kind) {\n    case DeclaratorChunk::Pointer:\n    case DeclaratorChunk::BlockPointer:\n      innermost = i;\n      continue;\n\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Paren:\n    case DeclaratorChunk::Array:\n    case DeclaratorChunk::Pipe:\n      continue;\n\n    case DeclaratorChunk::Function:\n      considerDeclSpec = false;\n      goto done;\n    }\n  }\n done:\n\n  // That might actually be the decl spec if we weren't blocked by\n  // anything in the declarator.\n  if (considerDeclSpec) {\n    if (handleObjCPointerTypeAttr(state, attr, declSpecType)) {\n      // Splice the attribute into the decl spec.  Prevents the\n      // attribute from being applied multiple times and gives\n      // the source-location-filler something to work with.\n      state.saveDeclSpecAttrs();\n      declarator.getMutableDeclSpec().getAttributes().takeOneFrom(\n          declarator.getAttributes(), &attr);\n      return;\n    }\n  }\n\n  // Otherwise, if we found an appropriate chunk, splice the attribute\n  // into it.\n  if (innermost != -1U) {\n    moveAttrFromListToList(attr, declarator.getAttributes(),\n                           declarator.getTypeObject(innermost).getAttrs());\n    return;\n  }\n\n  // Otherwise, diagnose when we're done building the type.\n  declarator.getAttributes().remove(&attr);\n  state.addIgnoredTypeAttr(attr);\n}\n\n/// A function type attribute was written somewhere in a declaration\n/// *other* than on the declarator itself or in the decl spec.  Given\n/// that it didn't apply in whatever position it was written in, try\n/// to move it to a more appropriate position.\nstatic void distributeFunctionTypeAttr(TypeProcessingState &state,\n                                       ParsedAttr &attr, QualType type) {\n  Declarator &declarator = state.getDeclarator();\n\n  // Try to push the attribute from the return type of a function to\n  // the function itself.\n  for (unsigned i = state.getCurrentChunkIndex(); i != 0; --i) {\n    DeclaratorChunk &chunk = declarator.getTypeObject(i-1);\n    switch (chunk.Kind) {\n    case DeclaratorChunk::Function:\n      moveAttrFromListToList(attr, state.getCurrentAttributes(),\n                             chunk.getAttrs());\n      return;\n\n    case DeclaratorChunk::Paren:\n    case DeclaratorChunk::Pointer:\n    case DeclaratorChunk::BlockPointer:\n    case DeclaratorChunk::Array:\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Pipe:\n      continue;\n    }\n  }\n\n  diagnoseBadTypeAttribute(state.getSema(), attr, type);\n}\n\n/// Try to distribute a function type attribute to the innermost\n/// function chunk or type.  Returns true if the attribute was\n/// distributed, false if no location was found.\nstatic bool distributeFunctionTypeAttrToInnermost(\n    TypeProcessingState &state, ParsedAttr &attr,\n    ParsedAttributesView &attrList, QualType &declSpecType) {\n  Declarator &declarator = state.getDeclarator();\n\n  // Put it on the innermost function chunk, if there is one.\n  for (unsigned i = 0, e = declarator.getNumTypeObjects(); i != e; ++i) {\n    DeclaratorChunk &chunk = declarator.getTypeObject(i);\n    if (chunk.Kind != DeclaratorChunk::Function) continue;\n\n    moveAttrFromListToList(attr, attrList, chunk.getAttrs());\n    return true;\n  }\n\n  return handleFunctionTypeAttr(state, attr, declSpecType);\n}\n\n/// A function type attribute was written in the decl spec.  Try to\n/// apply it somewhere.\nstatic void distributeFunctionTypeAttrFromDeclSpec(TypeProcessingState &state,\n                                                   ParsedAttr &attr,\n                                                   QualType &declSpecType) {\n  state.saveDeclSpecAttrs();\n\n  // C++11 attributes before the decl specifiers actually appertain to\n  // the declarators. Move them straight there. We don't support the\n  // 'put them wherever you like' semantics we allow for GNU attributes.\n  if (attr.isCXX11Attribute()) {\n    moveAttrFromListToList(attr, state.getCurrentAttributes(),\n                           state.getDeclarator().getAttributes());\n    return;\n  }\n\n  // Try to distribute to the innermost.\n  if (distributeFunctionTypeAttrToInnermost(\n          state, attr, state.getCurrentAttributes(), declSpecType))\n    return;\n\n  // If that failed, diagnose the bad attribute when the declarator is\n  // fully built.\n  state.addIgnoredTypeAttr(attr);\n}\n\n/// A function type attribute was written on the declarator.  Try to\n/// apply it somewhere.\nstatic void distributeFunctionTypeAttrFromDeclarator(TypeProcessingState &state,\n                                                     ParsedAttr &attr,\n                                                     QualType &declSpecType) {\n  Declarator &declarator = state.getDeclarator();\n\n  // Try to distribute to the innermost.\n  if (distributeFunctionTypeAttrToInnermost(\n          state, attr, declarator.getAttributes(), declSpecType))\n    return;\n\n  // If that failed, diagnose the bad attribute when the declarator is\n  // fully built.\n  declarator.getAttributes().remove(&attr);\n  state.addIgnoredTypeAttr(attr);\n}\n\n/// Given that there are attributes written on the declarator\n/// itself, try to distribute any type attributes to the appropriate\n/// declarator chunk.\n///\n/// These are attributes like the following:\n///   int f ATTR;\n///   int (f ATTR)();\n/// but not necessarily this:\n///   int f() ATTR;\nstatic void distributeTypeAttrsFromDeclarator(TypeProcessingState &state,\n                                              QualType &declSpecType) {\n  // Collect all the type attributes from the declarator itself.\n  assert(!state.getDeclarator().getAttributes().empty() &&\n         \"declarator has no attrs!\");\n  // The called functions in this loop actually remove things from the current\n  // list, so iterating over the existing list isn't possible.  Instead, make a\n  // non-owning copy and iterate over that.\n  ParsedAttributesView AttrsCopy{state.getDeclarator().getAttributes()};\n  for (ParsedAttr &attr : AttrsCopy) {\n    // Do not distribute C++11 attributes. They have strict rules for what\n    // they appertain to.\n    if (attr.isCXX11Attribute())\n      continue;\n\n    switch (attr.getKind()) {\n    OBJC_POINTER_TYPE_ATTRS_CASELIST:\n      distributeObjCPointerTypeAttrFromDeclarator(state, attr, declSpecType);\n      break;\n\n    FUNCTION_TYPE_ATTRS_CASELIST:\n      distributeFunctionTypeAttrFromDeclarator(state, attr, declSpecType);\n      break;\n\n    MS_TYPE_ATTRS_CASELIST:\n      // Microsoft type attributes cannot go after the declarator-id.\n      continue;\n\n    NULLABILITY_TYPE_ATTRS_CASELIST:\n      // Nullability specifiers cannot go after the declarator-id.\n\n    // Objective-C __kindof does not get distributed.\n    case ParsedAttr::AT_ObjCKindOf:\n      continue;\n\n    default:\n      break;\n    }\n  }\n}\n\n/// Add a synthetic '()' to a block-literal declarator if it is\n/// required, given the return type.\nstatic void maybeSynthesizeBlockSignature(TypeProcessingState &state,\n                                          QualType declSpecType) {\n  Declarator &declarator = state.getDeclarator();\n\n  // First, check whether the declarator would produce a function,\n  // i.e. whether the innermost semantic chunk is a function.\n  if (declarator.isFunctionDeclarator()) {\n    // If so, make that declarator a prototyped declarator.\n    declarator.getFunctionTypeInfo().hasPrototype = true;\n    return;\n  }\n\n  // If there are any type objects, the type as written won't name a\n  // function, regardless of the decl spec type.  This is because a\n  // block signature declarator is always an abstract-declarator, and\n  // abstract-declarators can't just be parentheses chunks.  Therefore\n  // we need to build a function chunk unless there are no type\n  // objects and the decl spec type is a function.\n  if (!declarator.getNumTypeObjects() && declSpecType->isFunctionType())\n    return;\n\n  // Note that there *are* cases with invalid declarators where\n  // declarators consist solely of parentheses.  In general, these\n  // occur only in failed efforts to make function declarators, so\n  // faking up the function chunk is still the right thing to do.\n\n  // Otherwise, we need to fake up a function declarator.\n  SourceLocation loc = declarator.getBeginLoc();\n\n  // ...and *prepend* it to the declarator.\n  SourceLocation NoLoc;\n  declarator.AddInnermostTypeInfo(DeclaratorChunk::getFunction(\n      /*HasProto=*/true,\n      /*IsAmbiguous=*/false,\n      /*LParenLoc=*/NoLoc,\n      /*ArgInfo=*/nullptr,\n      /*NumParams=*/0,\n      /*EllipsisLoc=*/NoLoc,\n      /*RParenLoc=*/NoLoc,\n      /*RefQualifierIsLvalueRef=*/true,\n      /*RefQualifierLoc=*/NoLoc,\n      /*MutableLoc=*/NoLoc, EST_None,\n      /*ESpecRange=*/SourceRange(),\n      /*Exceptions=*/nullptr,\n      /*ExceptionRanges=*/nullptr,\n      /*NumExceptions=*/0,\n      /*NoexceptExpr=*/nullptr,\n      /*ExceptionSpecTokens=*/nullptr,\n      /*DeclsInPrototype=*/None, loc, loc, declarator));\n\n  // For consistency, make sure the state still has us as processing\n  // the decl spec.\n  assert(state.getCurrentChunkIndex() == declarator.getNumTypeObjects() - 1);\n  state.setCurrentChunkIndex(declarator.getNumTypeObjects());\n}\n\nstatic void diagnoseAndRemoveTypeQualifiers(Sema &S, const DeclSpec &DS,\n                                            unsigned &TypeQuals,\n                                            QualType TypeSoFar,\n                                            unsigned RemoveTQs,\n                                            unsigned DiagID) {\n  // If this occurs outside a template instantiation, warn the user about\n  // it; they probably didn't mean to specify a redundant qualifier.\n  typedef std::pair<DeclSpec::TQ, SourceLocation> QualLoc;\n  for (QualLoc Qual : {QualLoc(DeclSpec::TQ_const, DS.getConstSpecLoc()),\n                       QualLoc(DeclSpec::TQ_restrict, DS.getRestrictSpecLoc()),\n                       QualLoc(DeclSpec::TQ_volatile, DS.getVolatileSpecLoc()),\n                       QualLoc(DeclSpec::TQ_atomic, DS.getAtomicSpecLoc())}) {\n    if (!(RemoveTQs & Qual.first))\n      continue;\n\n    if (!S.inTemplateInstantiation()) {\n      if (TypeQuals & Qual.first)\n        S.Diag(Qual.second, DiagID)\n          << DeclSpec::getSpecifierName(Qual.first) << TypeSoFar\n          << FixItHint::CreateRemoval(Qual.second);\n    }\n\n    TypeQuals &= ~Qual.first;\n  }\n}\n\n/// Return true if this is omitted block return type. Also check type\n/// attributes and type qualifiers when returning true.\nstatic bool checkOmittedBlockReturnType(Sema &S, Declarator &declarator,\n                                        QualType Result) {\n  if (!isOmittedBlockReturnType(declarator))\n    return false;\n\n  // Warn if we see type attributes for omitted return type on a block literal.\n  SmallVector<ParsedAttr *, 2> ToBeRemoved;\n  for (ParsedAttr &AL : declarator.getMutableDeclSpec().getAttributes()) {\n    if (AL.isInvalid() || !AL.isTypeAttr())\n      continue;\n    S.Diag(AL.getLoc(),\n           diag::warn_block_literal_attributes_on_omitted_return_type)\n        << AL;\n    ToBeRemoved.push_back(&AL);\n  }\n  // Remove bad attributes from the list.\n  for (ParsedAttr *AL : ToBeRemoved)\n    declarator.getMutableDeclSpec().getAttributes().remove(AL);\n\n  // Warn if we see type qualifiers for omitted return type on a block literal.\n  const DeclSpec &DS = declarator.getDeclSpec();\n  unsigned TypeQuals = DS.getTypeQualifiers();\n  diagnoseAndRemoveTypeQualifiers(S, DS, TypeQuals, Result, (unsigned)-1,\n      diag::warn_block_literal_qualifiers_on_omitted_return_type);\n  declarator.getMutableDeclSpec().ClearTypeQualifiers();\n\n  return true;\n}\n\n/// Apply Objective-C type arguments to the given type.\nstatic QualType applyObjCTypeArgs(Sema &S, SourceLocation loc, QualType type,\n                                  ArrayRef<TypeSourceInfo *> typeArgs,\n                                  SourceRange typeArgsRange,\n                                  bool failOnError = false) {\n  // We can only apply type arguments to an Objective-C class type.\n  const auto *objcObjectType = type->getAs<ObjCObjectType>();\n  if (!objcObjectType || !objcObjectType->getInterface()) {\n    S.Diag(loc, diag::err_objc_type_args_non_class)\n      << type\n      << typeArgsRange;\n\n    if (failOnError)\n      return QualType();\n    return type;\n  }\n\n  // The class type must be parameterized.\n  ObjCInterfaceDecl *objcClass = objcObjectType->getInterface();\n  ObjCTypeParamList *typeParams = objcClass->getTypeParamList();\n  if (!typeParams) {\n    S.Diag(loc, diag::err_objc_type_args_non_parameterized_class)\n      << objcClass->getDeclName()\n      << FixItHint::CreateRemoval(typeArgsRange);\n\n    if (failOnError)\n      return QualType();\n\n    return type;\n  }\n\n  // The type must not already be specialized.\n  if (objcObjectType->isSpecialized()) {\n    S.Diag(loc, diag::err_objc_type_args_specialized_class)\n      << type\n      << FixItHint::CreateRemoval(typeArgsRange);\n\n    if (failOnError)\n      return QualType();\n\n    return type;\n  }\n\n  // Check the type arguments.\n  SmallVector<QualType, 4> finalTypeArgs;\n  unsigned numTypeParams = typeParams->size();\n  bool anyPackExpansions = false;\n  for (unsigned i = 0, n = typeArgs.size(); i != n; ++i) {\n    TypeSourceInfo *typeArgInfo = typeArgs[i];\n    QualType typeArg = typeArgInfo->getType();\n\n    // Type arguments cannot have explicit qualifiers or nullability.\n    // We ignore indirect sources of these, e.g. behind typedefs or\n    // template arguments.\n    if (TypeLoc qual = typeArgInfo->getTypeLoc().findExplicitQualifierLoc()) {\n      bool diagnosed = false;\n      SourceRange rangeToRemove;\n      if (auto attr = qual.getAs<AttributedTypeLoc>()) {\n        rangeToRemove = attr.getLocalSourceRange();\n        if (attr.getTypePtr()->getImmediateNullability()) {\n          typeArg = attr.getTypePtr()->getModifiedType();\n          S.Diag(attr.getBeginLoc(),\n                 diag::err_objc_type_arg_explicit_nullability)\n              << typeArg << FixItHint::CreateRemoval(rangeToRemove);\n          diagnosed = true;\n        }\n      }\n\n      if (!diagnosed) {\n        S.Diag(qual.getBeginLoc(), diag::err_objc_type_arg_qualified)\n            << typeArg << typeArg.getQualifiers().getAsString()\n            << FixItHint::CreateRemoval(rangeToRemove);\n      }\n    }\n\n    // Remove qualifiers even if they're non-local.\n    typeArg = typeArg.getUnqualifiedType();\n\n    finalTypeArgs.push_back(typeArg);\n\n    if (typeArg->getAs<PackExpansionType>())\n      anyPackExpansions = true;\n\n    // Find the corresponding type parameter, if there is one.\n    ObjCTypeParamDecl *typeParam = nullptr;\n    if (!anyPackExpansions) {\n      if (i < numTypeParams) {\n        typeParam = typeParams->begin()[i];\n      } else {\n        // Too many arguments.\n        S.Diag(loc, diag::err_objc_type_args_wrong_arity)\n          << false\n          << objcClass->getDeclName()\n          << (unsigned)typeArgs.size()\n          << numTypeParams;\n        S.Diag(objcClass->getLocation(), diag::note_previous_decl)\n          << objcClass;\n\n        if (failOnError)\n          return QualType();\n\n        return type;\n      }\n    }\n\n    // Objective-C object pointer types must be substitutable for the bounds.\n    if (const auto *typeArgObjC = typeArg->getAs<ObjCObjectPointerType>()) {\n      // If we don't have a type parameter to match against, assume\n      // everything is fine. There was a prior pack expansion that\n      // means we won't be able to match anything.\n      if (!typeParam) {\n        assert(anyPackExpansions && \"Too many arguments?\");\n        continue;\n      }\n\n      // Retrieve the bound.\n      QualType bound = typeParam->getUnderlyingType();\n      const auto *boundObjC = bound->getAs<ObjCObjectPointerType>();\n\n      // Determine whether the type argument is substitutable for the bound.\n      if (typeArgObjC->isObjCIdType()) {\n        // When the type argument is 'id', the only acceptable type\n        // parameter bound is 'id'.\n        if (boundObjC->isObjCIdType())\n          continue;\n      } else if (S.Context.canAssignObjCInterfaces(boundObjC, typeArgObjC)) {\n        // Otherwise, we follow the assignability rules.\n        continue;\n      }\n\n      // Diagnose the mismatch.\n      S.Diag(typeArgInfo->getTypeLoc().getBeginLoc(),\n             diag::err_objc_type_arg_does_not_match_bound)\n          << typeArg << bound << typeParam->getDeclName();\n      S.Diag(typeParam->getLocation(), diag::note_objc_type_param_here)\n        << typeParam->getDeclName();\n\n      if (failOnError)\n        return QualType();\n\n      return type;\n    }\n\n    // Block pointer types are permitted for unqualified 'id' bounds.\n    if (typeArg->isBlockPointerType()) {\n      // If we don't have a type parameter to match against, assume\n      // everything is fine. There was a prior pack expansion that\n      // means we won't be able to match anything.\n      if (!typeParam) {\n        assert(anyPackExpansions && \"Too many arguments?\");\n        continue;\n      }\n\n      // Retrieve the bound.\n      QualType bound = typeParam->getUnderlyingType();\n      if (bound->isBlockCompatibleObjCPointerType(S.Context))\n        continue;\n\n      // Diagnose the mismatch.\n      S.Diag(typeArgInfo->getTypeLoc().getBeginLoc(),\n             diag::err_objc_type_arg_does_not_match_bound)\n          << typeArg << bound << typeParam->getDeclName();\n      S.Diag(typeParam->getLocation(), diag::note_objc_type_param_here)\n        << typeParam->getDeclName();\n\n      if (failOnError)\n        return QualType();\n\n      return type;\n    }\n\n    // Dependent types will be checked at instantiation time.\n    if (typeArg->isDependentType()) {\n      continue;\n    }\n\n    // Diagnose non-id-compatible type arguments.\n    S.Diag(typeArgInfo->getTypeLoc().getBeginLoc(),\n           diag::err_objc_type_arg_not_id_compatible)\n        << typeArg << typeArgInfo->getTypeLoc().getSourceRange();\n\n    if (failOnError)\n      return QualType();\n\n    return type;\n  }\n\n  // Make sure we didn't have the wrong number of arguments.\n  if (!anyPackExpansions && finalTypeArgs.size() != numTypeParams) {\n    S.Diag(loc, diag::err_objc_type_args_wrong_arity)\n      << (typeArgs.size() < typeParams->size())\n      << objcClass->getDeclName()\n      << (unsigned)finalTypeArgs.size()\n      << (unsigned)numTypeParams;\n    S.Diag(objcClass->getLocation(), diag::note_previous_decl)\n      << objcClass;\n\n    if (failOnError)\n      return QualType();\n\n    return type;\n  }\n\n  // Success. Form the specialized type.\n  return S.Context.getObjCObjectType(type, finalTypeArgs, { }, false);\n}\n\nQualType Sema::BuildObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                      SourceLocation ProtocolLAngleLoc,\n                                      ArrayRef<ObjCProtocolDecl *> Protocols,\n                                      ArrayRef<SourceLocation> ProtocolLocs,\n                                      SourceLocation ProtocolRAngleLoc,\n                                      bool FailOnError) {\n  QualType Result = QualType(Decl->getTypeForDecl(), 0);\n  if (!Protocols.empty()) {\n    bool HasError;\n    Result = Context.applyObjCProtocolQualifiers(Result, Protocols,\n                                                 HasError);\n    if (HasError) {\n      Diag(SourceLocation(), diag::err_invalid_protocol_qualifiers)\n        << SourceRange(ProtocolLAngleLoc, ProtocolRAngleLoc);\n      if (FailOnError) Result = QualType();\n    }\n    if (FailOnError && Result.isNull())\n      return QualType();\n  }\n\n  return Result;\n}\n\nQualType Sema::BuildObjCObjectType(QualType BaseType,\n                                   SourceLocation Loc,\n                                   SourceLocation TypeArgsLAngleLoc,\n                                   ArrayRef<TypeSourceInfo *> TypeArgs,\n                                   SourceLocation TypeArgsRAngleLoc,\n                                   SourceLocation ProtocolLAngleLoc,\n                                   ArrayRef<ObjCProtocolDecl *> Protocols,\n                                   ArrayRef<SourceLocation> ProtocolLocs,\n                                   SourceLocation ProtocolRAngleLoc,\n                                   bool FailOnError) {\n  QualType Result = BaseType;\n  if (!TypeArgs.empty()) {\n    Result = applyObjCTypeArgs(*this, Loc, Result, TypeArgs,\n                               SourceRange(TypeArgsLAngleLoc,\n                                           TypeArgsRAngleLoc),\n                               FailOnError);\n    if (FailOnError && Result.isNull())\n      return QualType();\n  }\n\n  if (!Protocols.empty()) {\n    bool HasError;\n    Result = Context.applyObjCProtocolQualifiers(Result, Protocols,\n                                                 HasError);\n    if (HasError) {\n      Diag(Loc, diag::err_invalid_protocol_qualifiers)\n        << SourceRange(ProtocolLAngleLoc, ProtocolRAngleLoc);\n      if (FailOnError) Result = QualType();\n    }\n    if (FailOnError && Result.isNull())\n      return QualType();\n  }\n\n  return Result;\n}\n\nTypeResult Sema::actOnObjCProtocolQualifierType(\n             SourceLocation lAngleLoc,\n             ArrayRef<Decl *> protocols,\n             ArrayRef<SourceLocation> protocolLocs,\n             SourceLocation rAngleLoc) {\n  // Form id<protocol-list>.\n  QualType Result = Context.getObjCObjectType(\n                      Context.ObjCBuiltinIdTy, { },\n                      llvm::makeArrayRef(\n                        (ObjCProtocolDecl * const *)protocols.data(),\n                        protocols.size()),\n                      false);\n  Result = Context.getObjCObjectPointerType(Result);\n\n  TypeSourceInfo *ResultTInfo = Context.CreateTypeSourceInfo(Result);\n  TypeLoc ResultTL = ResultTInfo->getTypeLoc();\n\n  auto ObjCObjectPointerTL = ResultTL.castAs<ObjCObjectPointerTypeLoc>();\n  ObjCObjectPointerTL.setStarLoc(SourceLocation()); // implicit\n\n  auto ObjCObjectTL = ObjCObjectPointerTL.getPointeeLoc()\n                        .castAs<ObjCObjectTypeLoc>();\n  ObjCObjectTL.setHasBaseTypeAsWritten(false);\n  ObjCObjectTL.getBaseLoc().initialize(Context, SourceLocation());\n\n  // No type arguments.\n  ObjCObjectTL.setTypeArgsLAngleLoc(SourceLocation());\n  ObjCObjectTL.setTypeArgsRAngleLoc(SourceLocation());\n\n  // Fill in protocol qualifiers.\n  ObjCObjectTL.setProtocolLAngleLoc(lAngleLoc);\n  ObjCObjectTL.setProtocolRAngleLoc(rAngleLoc);\n  for (unsigned i = 0, n = protocols.size(); i != n; ++i)\n    ObjCObjectTL.setProtocolLoc(i, protocolLocs[i]);\n\n  // We're done. Return the completed type to the parser.\n  return CreateParsedType(Result, ResultTInfo);\n}\n\nTypeResult Sema::actOnObjCTypeArgsAndProtocolQualifiers(\n             Scope *S,\n             SourceLocation Loc,\n             ParsedType BaseType,\n             SourceLocation TypeArgsLAngleLoc,\n             ArrayRef<ParsedType> TypeArgs,\n             SourceLocation TypeArgsRAngleLoc,\n             SourceLocation ProtocolLAngleLoc,\n             ArrayRef<Decl *> Protocols,\n             ArrayRef<SourceLocation> ProtocolLocs,\n             SourceLocation ProtocolRAngleLoc) {\n  TypeSourceInfo *BaseTypeInfo = nullptr;\n  QualType T = GetTypeFromParser(BaseType, &BaseTypeInfo);\n  if (T.isNull())\n    return true;\n\n  // Handle missing type-source info.\n  if (!BaseTypeInfo)\n    BaseTypeInfo = Context.getTrivialTypeSourceInfo(T, Loc);\n\n  // Extract type arguments.\n  SmallVector<TypeSourceInfo *, 4> ActualTypeArgInfos;\n  for (unsigned i = 0, n = TypeArgs.size(); i != n; ++i) {\n    TypeSourceInfo *TypeArgInfo = nullptr;\n    QualType TypeArg = GetTypeFromParser(TypeArgs[i], &TypeArgInfo);\n    if (TypeArg.isNull()) {\n      ActualTypeArgInfos.clear();\n      break;\n    }\n\n    assert(TypeArgInfo && \"No type source info?\");\n    ActualTypeArgInfos.push_back(TypeArgInfo);\n  }\n\n  // Build the object type.\n  QualType Result = BuildObjCObjectType(\n      T, BaseTypeInfo->getTypeLoc().getSourceRange().getBegin(),\n      TypeArgsLAngleLoc, ActualTypeArgInfos, TypeArgsRAngleLoc,\n      ProtocolLAngleLoc,\n      llvm::makeArrayRef((ObjCProtocolDecl * const *)Protocols.data(),\n                         Protocols.size()),\n      ProtocolLocs, ProtocolRAngleLoc,\n      /*FailOnError=*/false);\n\n  if (Result == T)\n    return BaseType;\n\n  // Create source information for this type.\n  TypeSourceInfo *ResultTInfo = Context.CreateTypeSourceInfo(Result);\n  TypeLoc ResultTL = ResultTInfo->getTypeLoc();\n\n  // For id<Proto1, Proto2> or Class<Proto1, Proto2>, we'll have an\n  // object pointer type. Fill in source information for it.\n  if (auto ObjCObjectPointerTL = ResultTL.getAs<ObjCObjectPointerTypeLoc>()) {\n    // The '*' is implicit.\n    ObjCObjectPointerTL.setStarLoc(SourceLocation());\n    ResultTL = ObjCObjectPointerTL.getPointeeLoc();\n  }\n\n  if (auto OTPTL = ResultTL.getAs<ObjCTypeParamTypeLoc>()) {\n    // Protocol qualifier information.\n    if (OTPTL.getNumProtocols() > 0) {\n      assert(OTPTL.getNumProtocols() == Protocols.size());\n      OTPTL.setProtocolLAngleLoc(ProtocolLAngleLoc);\n      OTPTL.setProtocolRAngleLoc(ProtocolRAngleLoc);\n      for (unsigned i = 0, n = Protocols.size(); i != n; ++i)\n        OTPTL.setProtocolLoc(i, ProtocolLocs[i]);\n    }\n\n    // We're done. Return the completed type to the parser.\n    return CreateParsedType(Result, ResultTInfo);\n  }\n\n  auto ObjCObjectTL = ResultTL.castAs<ObjCObjectTypeLoc>();\n\n  // Type argument information.\n  if (ObjCObjectTL.getNumTypeArgs() > 0) {\n    assert(ObjCObjectTL.getNumTypeArgs() == ActualTypeArgInfos.size());\n    ObjCObjectTL.setTypeArgsLAngleLoc(TypeArgsLAngleLoc);\n    ObjCObjectTL.setTypeArgsRAngleLoc(TypeArgsRAngleLoc);\n    for (unsigned i = 0, n = ActualTypeArgInfos.size(); i != n; ++i)\n      ObjCObjectTL.setTypeArgTInfo(i, ActualTypeArgInfos[i]);\n  } else {\n    ObjCObjectTL.setTypeArgsLAngleLoc(SourceLocation());\n    ObjCObjectTL.setTypeArgsRAngleLoc(SourceLocation());\n  }\n\n  // Protocol qualifier information.\n  if (ObjCObjectTL.getNumProtocols() > 0) {\n    assert(ObjCObjectTL.getNumProtocols() == Protocols.size());\n    ObjCObjectTL.setProtocolLAngleLoc(ProtocolLAngleLoc);\n    ObjCObjectTL.setProtocolRAngleLoc(ProtocolRAngleLoc);\n    for (unsigned i = 0, n = Protocols.size(); i != n; ++i)\n      ObjCObjectTL.setProtocolLoc(i, ProtocolLocs[i]);\n  } else {\n    ObjCObjectTL.setProtocolLAngleLoc(SourceLocation());\n    ObjCObjectTL.setProtocolRAngleLoc(SourceLocation());\n  }\n\n  // Base type.\n  ObjCObjectTL.setHasBaseTypeAsWritten(true);\n  if (ObjCObjectTL.getType() == T)\n    ObjCObjectTL.getBaseLoc().initializeFullCopy(BaseTypeInfo->getTypeLoc());\n  else\n    ObjCObjectTL.getBaseLoc().initialize(Context, Loc);\n\n  // We're done. Return the completed type to the parser.\n  return CreateParsedType(Result, ResultTInfo);\n}\n\nstatic OpenCLAccessAttr::Spelling\ngetImageAccess(const ParsedAttributesView &Attrs) {\n  for (const ParsedAttr &AL : Attrs)\n    if (AL.getKind() == ParsedAttr::AT_OpenCLAccess)\n      return static_cast<OpenCLAccessAttr::Spelling>(AL.getSemanticSpelling());\n  return OpenCLAccessAttr::Keyword_read_only;\n}\n\nstatic QualType ConvertConstrainedAutoDeclSpecToType(Sema &S, DeclSpec &DS,\n                                                     AutoTypeKeyword AutoKW) {\n  assert(DS.isConstrainedAuto());\n  TemplateIdAnnotation *TemplateId = DS.getRepAsTemplateId();\n  TemplateArgumentListInfo TemplateArgsInfo;\n  TemplateArgsInfo.setLAngleLoc(TemplateId->LAngleLoc);\n  TemplateArgsInfo.setRAngleLoc(TemplateId->RAngleLoc);\n  ASTTemplateArgsPtr TemplateArgsPtr(TemplateId->getTemplateArgs(),\n                                     TemplateId->NumArgs);\n  S.translateTemplateArguments(TemplateArgsPtr, TemplateArgsInfo);\n  llvm::SmallVector<TemplateArgument, 8> TemplateArgs;\n  for (auto &ArgLoc : TemplateArgsInfo.arguments())\n    TemplateArgs.push_back(ArgLoc.getArgument());\n  return S.Context.getAutoType(\n      QualType(), AutoKW, false, /*IsPack=*/false,\n      cast<ConceptDecl>(TemplateId->Template.get().getAsTemplateDecl()),\n      TemplateArgs);\n}\n\n/// Convert the specified declspec to the appropriate type\n/// object.\n/// \\param state Specifies the declarator containing the declaration specifier\n/// to be converted, along with other associated processing state.\n/// \\returns The type described by the declaration specifiers.  This function\n/// never returns null.\nstatic QualType ConvertDeclSpecToType(TypeProcessingState &state) {\n  // FIXME: Should move the logic from DeclSpec::Finish to here for validity\n  // checking.\n\n  Sema &S = state.getSema();\n  Declarator &declarator = state.getDeclarator();\n  DeclSpec &DS = declarator.getMutableDeclSpec();\n  SourceLocation DeclLoc = declarator.getIdentifierLoc();\n  if (DeclLoc.isInvalid())\n    DeclLoc = DS.getBeginLoc();\n\n  ASTContext &Context = S.Context;\n\n  QualType Result;\n  switch (DS.getTypeSpecType()) {\n  case DeclSpec::TST_void:\n    Result = Context.VoidTy;\n    break;\n  case DeclSpec::TST_char:\n    if (DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified)\n      Result = Context.CharTy;\n    else if (DS.getTypeSpecSign() == TypeSpecifierSign::Signed)\n      Result = Context.SignedCharTy;\n    else {\n      assert(DS.getTypeSpecSign() == TypeSpecifierSign::Unsigned &&\n             \"Unknown TSS value\");\n      Result = Context.UnsignedCharTy;\n    }\n    break;\n  case DeclSpec::TST_wchar:\n    if (DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified)\n      Result = Context.WCharTy;\n    else if (DS.getTypeSpecSign() == TypeSpecifierSign::Signed) {\n      S.Diag(DS.getTypeSpecSignLoc(), diag::ext_wchar_t_sign_spec)\n        << DS.getSpecifierName(DS.getTypeSpecType(),\n                               Context.getPrintingPolicy());\n      Result = Context.getSignedWCharType();\n    } else {\n      assert(DS.getTypeSpecSign() == TypeSpecifierSign::Unsigned &&\n             \"Unknown TSS value\");\n      S.Diag(DS.getTypeSpecSignLoc(), diag::ext_wchar_t_sign_spec)\n        << DS.getSpecifierName(DS.getTypeSpecType(),\n                               Context.getPrintingPolicy());\n      Result = Context.getUnsignedWCharType();\n    }\n    break;\n  case DeclSpec::TST_char8:\n    assert(DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified &&\n           \"Unknown TSS value\");\n    Result = Context.Char8Ty;\n    break;\n  case DeclSpec::TST_char16:\n    assert(DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified &&\n           \"Unknown TSS value\");\n    Result = Context.Char16Ty;\n    break;\n  case DeclSpec::TST_char32:\n    assert(DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified &&\n           \"Unknown TSS value\");\n    Result = Context.Char32Ty;\n    break;\n  case DeclSpec::TST_unspecified:\n    // If this is a missing declspec in a block literal return context, then it\n    // is inferred from the return statements inside the block.\n    // The declspec is always missing in a lambda expr context; it is either\n    // specified with a trailing return type or inferred.\n    if (S.getLangOpts().CPlusPlus14 &&\n        declarator.getContext() == DeclaratorContext::LambdaExpr) {\n      // In C++1y, a lambda's implicit return type is 'auto'.\n      Result = Context.getAutoDeductType();\n      break;\n    } else if (declarator.getContext() == DeclaratorContext::LambdaExpr ||\n               checkOmittedBlockReturnType(S, declarator,\n                                           Context.DependentTy)) {\n      Result = Context.DependentTy;\n      break;\n    }\n\n    // Unspecified typespec defaults to int in C90.  However, the C90 grammar\n    // [C90 6.5] only allows a decl-spec if there was *some* type-specifier,\n    // type-qualifier, or storage-class-specifier.  If not, emit an extwarn.\n    // Note that the one exception to this is function definitions, which are\n    // allowed to be completely missing a declspec.  This is handled in the\n    // parser already though by it pretending to have seen an 'int' in this\n    // case.\n    if (S.getLangOpts().ImplicitInt) {\n      // In C89 mode, we only warn if there is a completely missing declspec\n      // when one is not allowed.\n      if (DS.isEmpty()) {\n        S.Diag(DeclLoc, diag::ext_missing_declspec)\n            << DS.getSourceRange()\n            << FixItHint::CreateInsertion(DS.getBeginLoc(), \"int\");\n      }\n    } else if (!DS.hasTypeSpecifier()) {\n      // C99 and C++ require a type specifier.  For example, C99 6.7.2p2 says:\n      // \"At least one type specifier shall be given in the declaration\n      // specifiers in each declaration, and in the specifier-qualifier list in\n      // each struct declaration and type name.\"\n      if (S.getLangOpts().CPlusPlus && !DS.isTypeSpecPipe()) {\n        S.Diag(DeclLoc, diag::err_missing_type_specifier)\n          << DS.getSourceRange();\n\n        // When this occurs in C++ code, often something is very broken with the\n        // value being declared, poison it as invalid so we don't get chains of\n        // errors.\n        declarator.setInvalidType(true);\n      } else if ((S.getLangOpts().OpenCLVersion >= 200 ||\n                  S.getLangOpts().OpenCLCPlusPlus) &&\n                 DS.isTypeSpecPipe()) {\n        S.Diag(DeclLoc, diag::err_missing_actual_pipe_type)\n          << DS.getSourceRange();\n        declarator.setInvalidType(true);\n      } else {\n        S.Diag(DeclLoc, diag::ext_missing_type_specifier)\n          << DS.getSourceRange();\n      }\n    }\n\n    LLVM_FALLTHROUGH;\n  case DeclSpec::TST_int: {\n    if (DS.getTypeSpecSign() != TypeSpecifierSign::Unsigned) {\n      switch (DS.getTypeSpecWidth()) {\n      case TypeSpecifierWidth::Unspecified:\n        Result = Context.IntTy;\n        break;\n      case TypeSpecifierWidth::Short:\n        Result = Context.ShortTy;\n        break;\n      case TypeSpecifierWidth::Long:\n        Result = Context.LongTy;\n        break;\n      case TypeSpecifierWidth::LongLong:\n        Result = Context.LongLongTy;\n\n        // 'long long' is a C99 or C++11 feature.\n        if (!S.getLangOpts().C99) {\n          if (S.getLangOpts().CPlusPlus)\n            S.Diag(DS.getTypeSpecWidthLoc(),\n                   S.getLangOpts().CPlusPlus11 ?\n                   diag::warn_cxx98_compat_longlong : diag::ext_cxx11_longlong);\n          else\n            S.Diag(DS.getTypeSpecWidthLoc(), diag::ext_c99_longlong);\n        }\n        break;\n      }\n    } else {\n      switch (DS.getTypeSpecWidth()) {\n      case TypeSpecifierWidth::Unspecified:\n        Result = Context.UnsignedIntTy;\n        break;\n      case TypeSpecifierWidth::Short:\n        Result = Context.UnsignedShortTy;\n        break;\n      case TypeSpecifierWidth::Long:\n        Result = Context.UnsignedLongTy;\n        break;\n      case TypeSpecifierWidth::LongLong:\n        Result = Context.UnsignedLongLongTy;\n\n        // 'long long' is a C99 or C++11 feature.\n        if (!S.getLangOpts().C99) {\n          if (S.getLangOpts().CPlusPlus)\n            S.Diag(DS.getTypeSpecWidthLoc(),\n                   S.getLangOpts().CPlusPlus11 ?\n                   diag::warn_cxx98_compat_longlong : diag::ext_cxx11_longlong);\n          else\n            S.Diag(DS.getTypeSpecWidthLoc(), diag::ext_c99_longlong);\n        }\n        break;\n      }\n    }\n    break;\n  }\n  case DeclSpec::TST_extint: {\n    if (!S.Context.getTargetInfo().hasExtIntType())\n      S.Diag(DS.getTypeSpecTypeLoc(), diag::err_type_unsupported)\n        << \"_ExtInt\";\n    Result =\n        S.BuildExtIntType(DS.getTypeSpecSign() == TypeSpecifierSign::Unsigned,\n                          DS.getRepAsExpr(), DS.getBeginLoc());\n    if (Result.isNull()) {\n      Result = Context.IntTy;\n      declarator.setInvalidType(true);\n    }\n    break;\n  }\n  case DeclSpec::TST_accum: {\n    switch (DS.getTypeSpecWidth()) {\n    case TypeSpecifierWidth::Short:\n      Result = Context.ShortAccumTy;\n      break;\n    case TypeSpecifierWidth::Unspecified:\n      Result = Context.AccumTy;\n      break;\n    case TypeSpecifierWidth::Long:\n      Result = Context.LongAccumTy;\n      break;\n    case TypeSpecifierWidth::LongLong:\n      llvm_unreachable(\"Unable to specify long long as _Accum width\");\n    }\n\n    if (DS.getTypeSpecSign() == TypeSpecifierSign::Unsigned)\n      Result = Context.getCorrespondingUnsignedType(Result);\n\n    if (DS.isTypeSpecSat())\n      Result = Context.getCorrespondingSaturatedType(Result);\n\n    break;\n  }\n  case DeclSpec::TST_fract: {\n    switch (DS.getTypeSpecWidth()) {\n    case TypeSpecifierWidth::Short:\n      Result = Context.ShortFractTy;\n      break;\n    case TypeSpecifierWidth::Unspecified:\n      Result = Context.FractTy;\n      break;\n    case TypeSpecifierWidth::Long:\n      Result = Context.LongFractTy;\n      break;\n    case TypeSpecifierWidth::LongLong:\n      llvm_unreachable(\"Unable to specify long long as _Fract width\");\n    }\n\n    if (DS.getTypeSpecSign() == TypeSpecifierSign::Unsigned)\n      Result = Context.getCorrespondingUnsignedType(Result);\n\n    if (DS.isTypeSpecSat())\n      Result = Context.getCorrespondingSaturatedType(Result);\n\n    break;\n  }\n  case DeclSpec::TST_int128:\n    if (!S.Context.getTargetInfo().hasInt128Type() &&\n        !S.getLangOpts().SYCLIsDevice &&\n        !(S.getLangOpts().OpenMP && S.getLangOpts().OpenMPIsDevice))\n      S.Diag(DS.getTypeSpecTypeLoc(), diag::err_type_unsupported)\n        << \"__int128\";\n    if (DS.getTypeSpecSign() == TypeSpecifierSign::Unsigned)\n      Result = Context.UnsignedInt128Ty;\n    else\n      Result = Context.Int128Ty;\n    break;\n  case DeclSpec::TST_float16:\n    // CUDA host and device may have different _Float16 support, therefore\n    // do not diagnose _Float16 usage to avoid false alarm.\n    // ToDo: more precise diagnostics for CUDA.\n    if (!S.Context.getTargetInfo().hasFloat16Type() && !S.getLangOpts().CUDA &&\n        !(S.getLangOpts().OpenMP && S.getLangOpts().OpenMPIsDevice))\n      S.Diag(DS.getTypeSpecTypeLoc(), diag::err_type_unsupported)\n        << \"_Float16\";\n    Result = Context.Float16Ty;\n    break;\n  case DeclSpec::TST_half:    Result = Context.HalfTy; break;\n  case DeclSpec::TST_BFloat16:\n    if (!S.Context.getTargetInfo().hasBFloat16Type())\n      S.Diag(DS.getTypeSpecTypeLoc(), diag::err_type_unsupported)\n        << \"__bf16\";\n    Result = Context.BFloat16Ty;\n    break;\n  case DeclSpec::TST_float:   Result = Context.FloatTy; break;\n  case DeclSpec::TST_double:\n    if (DS.getTypeSpecWidth() == TypeSpecifierWidth::Long)\n      Result = Context.LongDoubleTy;\n    else\n      Result = Context.DoubleTy;\n    break;\n  case DeclSpec::TST_float128:\n    if (!S.Context.getTargetInfo().hasFloat128Type() &&\n        !S.getLangOpts().SYCLIsDevice &&\n        !(S.getLangOpts().OpenMP && S.getLangOpts().OpenMPIsDevice))\n      S.Diag(DS.getTypeSpecTypeLoc(), diag::err_type_unsupported)\n        << \"__float128\";\n    Result = Context.Float128Ty;\n    break;\n  case DeclSpec::TST_bool:\n    Result = Context.BoolTy; // _Bool or bool\n    break;\n  case DeclSpec::TST_decimal32:    // _Decimal32\n  case DeclSpec::TST_decimal64:    // _Decimal64\n  case DeclSpec::TST_decimal128:   // _Decimal128\n    S.Diag(DS.getTypeSpecTypeLoc(), diag::err_decimal_unsupported);\n    Result = Context.IntTy;\n    declarator.setInvalidType(true);\n    break;\n  case DeclSpec::TST_class:\n  case DeclSpec::TST_enum:\n  case DeclSpec::TST_union:\n  case DeclSpec::TST_struct:\n  case DeclSpec::TST_interface: {\n    TagDecl *D = dyn_cast_or_null<TagDecl>(DS.getRepAsDecl());\n    if (!D) {\n      // This can happen in C++ with ambiguous lookups.\n      Result = Context.IntTy;\n      declarator.setInvalidType(true);\n      break;\n    }\n\n    // If the type is deprecated or unavailable, diagnose it.\n    S.DiagnoseUseOfDecl(D, DS.getTypeSpecTypeNameLoc());\n\n    assert(DS.getTypeSpecWidth() == TypeSpecifierWidth::Unspecified &&\n           DS.getTypeSpecComplex() == 0 &&\n           DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified &&\n           \"No qualifiers on tag names!\");\n\n    // TypeQuals handled by caller.\n    Result = Context.getTypeDeclType(D);\n\n    // In both C and C++, make an ElaboratedType.\n    ElaboratedTypeKeyword Keyword\n      = ElaboratedType::getKeywordForTypeSpec(DS.getTypeSpecType());\n    Result = S.getElaboratedType(Keyword, DS.getTypeSpecScope(), Result,\n                                 DS.isTypeSpecOwned() ? D : nullptr);\n    break;\n  }\n  case DeclSpec::TST_typename: {\n    assert(DS.getTypeSpecWidth() == TypeSpecifierWidth::Unspecified &&\n           DS.getTypeSpecComplex() == 0 &&\n           DS.getTypeSpecSign() == TypeSpecifierSign::Unspecified &&\n           \"Can't handle qualifiers on typedef names yet!\");\n    Result = S.GetTypeFromParser(DS.getRepAsType());\n    if (Result.isNull()) {\n      declarator.setInvalidType(true);\n    }\n\n    // TypeQuals handled by caller.\n    break;\n  }\n  case DeclSpec::TST_typeofType:\n    // FIXME: Preserve type source info.\n    Result = S.GetTypeFromParser(DS.getRepAsType());\n    assert(!Result.isNull() && \"Didn't get a type for typeof?\");\n    if (!Result->isDependentType())\n      if (const TagType *TT = Result->getAs<TagType>())\n        S.DiagnoseUseOfDecl(TT->getDecl(), DS.getTypeSpecTypeLoc());\n    // TypeQuals handled by caller.\n    Result = Context.getTypeOfType(Result);\n    break;\n  case DeclSpec::TST_typeofExpr: {\n    Expr *E = DS.getRepAsExpr();\n    assert(E && \"Didn't get an expression for typeof?\");\n    // TypeQuals handled by caller.\n    Result = S.BuildTypeofExprType(E, DS.getTypeSpecTypeLoc());\n    if (Result.isNull()) {\n      Result = Context.IntTy;\n      declarator.setInvalidType(true);\n    }\n    break;\n  }\n  case DeclSpec::TST_decltype: {\n    Expr *E = DS.getRepAsExpr();\n    assert(E && \"Didn't get an expression for decltype?\");\n    // TypeQuals handled by caller.\n    Result = S.BuildDecltypeType(E, DS.getTypeSpecTypeLoc());\n    if (Result.isNull()) {\n      Result = Context.IntTy;\n      declarator.setInvalidType(true);\n    }\n    break;\n  }\n  case DeclSpec::TST_underlyingType:\n    Result = S.GetTypeFromParser(DS.getRepAsType());\n    assert(!Result.isNull() && \"Didn't get a type for __underlying_type?\");\n    Result = S.BuildUnaryTransformType(Result,\n                                       UnaryTransformType::EnumUnderlyingType,\n                                       DS.getTypeSpecTypeLoc());\n    if (Result.isNull()) {\n      Result = Context.IntTy;\n      declarator.setInvalidType(true);\n    }\n    break;\n\n  case DeclSpec::TST_auto:\n    if (DS.isConstrainedAuto()) {\n      Result = ConvertConstrainedAutoDeclSpecToType(S, DS,\n                                                    AutoTypeKeyword::Auto);\n      break;\n    }\n    Result = Context.getAutoType(QualType(), AutoTypeKeyword::Auto, false);\n    break;\n\n  case DeclSpec::TST_auto_type:\n    Result = Context.getAutoType(QualType(), AutoTypeKeyword::GNUAutoType, false);\n    break;\n\n  case DeclSpec::TST_decltype_auto:\n    if (DS.isConstrainedAuto()) {\n      Result =\n          ConvertConstrainedAutoDeclSpecToType(S, DS,\n                                               AutoTypeKeyword::DecltypeAuto);\n      break;\n    }\n    Result = Context.getAutoType(QualType(), AutoTypeKeyword::DecltypeAuto,\n                                 /*IsDependent*/ false);\n    break;\n\n  case DeclSpec::TST_unknown_anytype:\n    Result = Context.UnknownAnyTy;\n    break;\n\n  case DeclSpec::TST_atomic:\n    Result = S.GetTypeFromParser(DS.getRepAsType());\n    assert(!Result.isNull() && \"Didn't get a type for _Atomic?\");\n    Result = S.BuildAtomicType(Result, DS.getTypeSpecTypeLoc());\n    if (Result.isNull()) {\n      Result = Context.IntTy;\n      declarator.setInvalidType(true);\n    }\n    break;\n\n#define GENERIC_IMAGE_TYPE(ImgType, Id)                                        \\\n  case DeclSpec::TST_##ImgType##_t:                                            \\\n    switch (getImageAccess(DS.getAttributes())) {                              \\\n    case OpenCLAccessAttr::Keyword_write_only:                                 \\\n      Result = Context.Id##WOTy;                                               \\\n      break;                                                                   \\\n    case OpenCLAccessAttr::Keyword_read_write:                                 \\\n      Result = Context.Id##RWTy;                                               \\\n      break;                                                                   \\\n    case OpenCLAccessAttr::Keyword_read_only:                                  \\\n      Result = Context.Id##ROTy;                                               \\\n      break;                                                                   \\\n    case OpenCLAccessAttr::SpellingNotCalculated:                              \\\n      llvm_unreachable(\"Spelling not yet calculated\");                         \\\n    }                                                                          \\\n    break;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\n  case DeclSpec::TST_error:\n    Result = Context.IntTy;\n    declarator.setInvalidType(true);\n    break;\n  }\n\n  // FIXME: we want resulting declarations to be marked invalid, but claiming\n  // the type is invalid is too strong - e.g. it causes ActOnTypeName to return\n  // a null type.\n  if (Result->containsErrors())\n    declarator.setInvalidType();\n\n  if (S.getLangOpts().OpenCL &&\n      S.checkOpenCLDisabledTypeDeclSpec(DS, Result))\n    declarator.setInvalidType(true);\n\n  bool IsFixedPointType = DS.getTypeSpecType() == DeclSpec::TST_accum ||\n                          DS.getTypeSpecType() == DeclSpec::TST_fract;\n\n  // Only fixed point types can be saturated\n  if (DS.isTypeSpecSat() && !IsFixedPointType)\n    S.Diag(DS.getTypeSpecSatLoc(), diag::err_invalid_saturation_spec)\n        << DS.getSpecifierName(DS.getTypeSpecType(),\n                               Context.getPrintingPolicy());\n\n  // Handle complex types.\n  if (DS.getTypeSpecComplex() == DeclSpec::TSC_complex) {\n    if (S.getLangOpts().Freestanding)\n      S.Diag(DS.getTypeSpecComplexLoc(), diag::ext_freestanding_complex);\n    Result = Context.getComplexType(Result);\n  } else if (DS.isTypeAltiVecVector()) {\n    unsigned typeSize = static_cast<unsigned>(Context.getTypeSize(Result));\n    assert(typeSize > 0 && \"type size for vector must be greater than 0 bits\");\n    VectorType::VectorKind VecKind = VectorType::AltiVecVector;\n    if (DS.isTypeAltiVecPixel())\n      VecKind = VectorType::AltiVecPixel;\n    else if (DS.isTypeAltiVecBool())\n      VecKind = VectorType::AltiVecBool;\n    Result = Context.getVectorType(Result, 128/typeSize, VecKind);\n  }\n\n  // FIXME: Imaginary.\n  if (DS.getTypeSpecComplex() == DeclSpec::TSC_imaginary)\n    S.Diag(DS.getTypeSpecComplexLoc(), diag::err_imaginary_not_supported);\n\n  // Before we process any type attributes, synthesize a block literal\n  // function declarator if necessary.\n  if (declarator.getContext() == DeclaratorContext::BlockLiteral)\n    maybeSynthesizeBlockSignature(state, Result);\n\n  // Apply any type attributes from the decl spec.  This may cause the\n  // list of type attributes to be temporarily saved while the type\n  // attributes are pushed around.\n  // pipe attributes will be handled later ( at GetFullTypeForDeclarator )\n  if (!DS.isTypeSpecPipe())\n    processTypeAttrs(state, Result, TAL_DeclSpec, DS.getAttributes());\n\n  // Apply const/volatile/restrict qualifiers to T.\n  if (unsigned TypeQuals = DS.getTypeQualifiers()) {\n    // Warn about CV qualifiers on function types.\n    // C99 6.7.3p8:\n    //   If the specification of a function type includes any type qualifiers,\n    //   the behavior is undefined.\n    // C++11 [dcl.fct]p7:\n    //   The effect of a cv-qualifier-seq in a function declarator is not the\n    //   same as adding cv-qualification on top of the function type. In the\n    //   latter case, the cv-qualifiers are ignored.\n    if (Result->isFunctionType()) {\n      diagnoseAndRemoveTypeQualifiers(\n          S, DS, TypeQuals, Result, DeclSpec::TQ_const | DeclSpec::TQ_volatile,\n          S.getLangOpts().CPlusPlus\n              ? diag::warn_typecheck_function_qualifiers_ignored\n              : diag::warn_typecheck_function_qualifiers_unspecified);\n      // No diagnostic for 'restrict' or '_Atomic' applied to a\n      // function type; we'll diagnose those later, in BuildQualifiedType.\n    }\n\n    // C++11 [dcl.ref]p1:\n    //   Cv-qualified references are ill-formed except when the\n    //   cv-qualifiers are introduced through the use of a typedef-name\n    //   or decltype-specifier, in which case the cv-qualifiers are ignored.\n    //\n    // There don't appear to be any other contexts in which a cv-qualified\n    // reference type could be formed, so the 'ill-formed' clause here appears\n    // to never happen.\n    if (TypeQuals && Result->isReferenceType()) {\n      diagnoseAndRemoveTypeQualifiers(\n          S, DS, TypeQuals, Result,\n          DeclSpec::TQ_const | DeclSpec::TQ_volatile | DeclSpec::TQ_atomic,\n          diag::warn_typecheck_reference_qualifiers);\n    }\n\n    // C90 6.5.3 constraints: \"The same type qualifier shall not appear more\n    // than once in the same specifier-list or qualifier-list, either directly\n    // or via one or more typedefs.\"\n    if (!S.getLangOpts().C99 && !S.getLangOpts().CPlusPlus\n        && TypeQuals & Result.getCVRQualifiers()) {\n      if (TypeQuals & DeclSpec::TQ_const && Result.isConstQualified()) {\n        S.Diag(DS.getConstSpecLoc(), diag::ext_duplicate_declspec)\n          << \"const\";\n      }\n\n      if (TypeQuals & DeclSpec::TQ_volatile && Result.isVolatileQualified()) {\n        S.Diag(DS.getVolatileSpecLoc(), diag::ext_duplicate_declspec)\n          << \"volatile\";\n      }\n\n      // C90 doesn't have restrict nor _Atomic, so it doesn't force us to\n      // produce a warning in this case.\n    }\n\n    QualType Qualified = S.BuildQualifiedType(Result, DeclLoc, TypeQuals, &DS);\n\n    // If adding qualifiers fails, just use the unqualified type.\n    if (Qualified.isNull())\n      declarator.setInvalidType(true);\n    else\n      Result = Qualified;\n  }\n\n  assert(!Result.isNull() && \"This function should not return a null type\");\n  return Result;\n}\n\nstatic std::string getPrintableNameForEntity(DeclarationName Entity) {\n  if (Entity)\n    return Entity.getAsString();\n\n  return \"type name\";\n}\n\nQualType Sema::BuildQualifiedType(QualType T, SourceLocation Loc,\n                                  Qualifiers Qs, const DeclSpec *DS) {\n  if (T.isNull())\n    return QualType();\n\n  // Ignore any attempt to form a cv-qualified reference.\n  if (T->isReferenceType()) {\n    Qs.removeConst();\n    Qs.removeVolatile();\n  }\n\n  // Enforce C99 6.7.3p2: \"Types other than pointer types derived from\n  // object or incomplete types shall not be restrict-qualified.\"\n  if (Qs.hasRestrict()) {\n    unsigned DiagID = 0;\n    QualType ProblemTy;\n\n    if (T->isAnyPointerType() || T->isReferenceType() ||\n        T->isMemberPointerType()) {\n      QualType EltTy;\n      if (T->isObjCObjectPointerType())\n        EltTy = T;\n      else if (const MemberPointerType *PTy = T->getAs<MemberPointerType>())\n        EltTy = PTy->getPointeeType();\n      else\n        EltTy = T->getPointeeType();\n\n      // If we have a pointer or reference, the pointee must have an object\n      // incomplete type.\n      if (!EltTy->isIncompleteOrObjectType()) {\n        DiagID = diag::err_typecheck_invalid_restrict_invalid_pointee;\n        ProblemTy = EltTy;\n      }\n    } else if (!T->isDependentType()) {\n      DiagID = diag::err_typecheck_invalid_restrict_not_pointer;\n      ProblemTy = T;\n    }\n\n    if (DiagID) {\n      Diag(DS ? DS->getRestrictSpecLoc() : Loc, DiagID) << ProblemTy;\n      Qs.removeRestrict();\n    }\n  }\n\n  return Context.getQualifiedType(T, Qs);\n}\n\nQualType Sema::BuildQualifiedType(QualType T, SourceLocation Loc,\n                                  unsigned CVRAU, const DeclSpec *DS) {\n  if (T.isNull())\n    return QualType();\n\n  // Ignore any attempt to form a cv-qualified reference.\n  if (T->isReferenceType())\n    CVRAU &=\n        ~(DeclSpec::TQ_const | DeclSpec::TQ_volatile | DeclSpec::TQ_atomic);\n\n  // Convert from DeclSpec::TQ to Qualifiers::TQ by just dropping TQ_atomic and\n  // TQ_unaligned;\n  unsigned CVR = CVRAU & ~(DeclSpec::TQ_atomic | DeclSpec::TQ_unaligned);\n\n  // C11 6.7.3/5:\n  //   If the same qualifier appears more than once in the same\n  //   specifier-qualifier-list, either directly or via one or more typedefs,\n  //   the behavior is the same as if it appeared only once.\n  //\n  // It's not specified what happens when the _Atomic qualifier is applied to\n  // a type specified with the _Atomic specifier, but we assume that this\n  // should be treated as if the _Atomic qualifier appeared multiple times.\n  if (CVRAU & DeclSpec::TQ_atomic && !T->isAtomicType()) {\n    // C11 6.7.3/5:\n    //   If other qualifiers appear along with the _Atomic qualifier in a\n    //   specifier-qualifier-list, the resulting type is the so-qualified\n    //   atomic type.\n    //\n    // Don't need to worry about array types here, since _Atomic can't be\n    // applied to such types.\n    SplitQualType Split = T.getSplitUnqualifiedType();\n    T = BuildAtomicType(QualType(Split.Ty, 0),\n                        DS ? DS->getAtomicSpecLoc() : Loc);\n    if (T.isNull())\n      return T;\n    Split.Quals.addCVRQualifiers(CVR);\n    return BuildQualifiedType(T, Loc, Split.Quals);\n  }\n\n  Qualifiers Q = Qualifiers::fromCVRMask(CVR);\n  Q.setUnaligned(CVRAU & DeclSpec::TQ_unaligned);\n  return BuildQualifiedType(T, Loc, Q, DS);\n}\n\n/// Build a paren type including \\p T.\nQualType Sema::BuildParenType(QualType T) {\n  return Context.getParenType(T);\n}\n\n/// Given that we're building a pointer or reference to the given\nstatic QualType inferARCLifetimeForPointee(Sema &S, QualType type,\n                                           SourceLocation loc,\n                                           bool isReference) {\n  // Bail out if retention is unrequired or already specified.\n  if (!type->isObjCLifetimeType() ||\n      type.getObjCLifetime() != Qualifiers::OCL_None)\n    return type;\n\n  Qualifiers::ObjCLifetime implicitLifetime = Qualifiers::OCL_None;\n\n  // If the object type is const-qualified, we can safely use\n  // __unsafe_unretained.  This is safe (because there are no read\n  // barriers), and it'll be safe to coerce anything but __weak* to\n  // the resulting type.\n  if (type.isConstQualified()) {\n    implicitLifetime = Qualifiers::OCL_ExplicitNone;\n\n  // Otherwise, check whether the static type does not require\n  // retaining.  This currently only triggers for Class (possibly\n  // protocol-qualifed, and arrays thereof).\n  } else if (type->isObjCARCImplicitlyUnretainedType()) {\n    implicitLifetime = Qualifiers::OCL_ExplicitNone;\n\n  // If we are in an unevaluated context, like sizeof, skip adding a\n  // qualification.\n  } else if (S.isUnevaluatedContext()) {\n    return type;\n\n  // If that failed, give an error and recover using __strong.  __strong\n  // is the option most likely to prevent spurious second-order diagnostics,\n  // like when binding a reference to a field.\n  } else {\n    // These types can show up in private ivars in system headers, so\n    // we need this to not be an error in those cases.  Instead we\n    // want to delay.\n    if (S.DelayedDiagnostics.shouldDelayDiagnostics()) {\n      S.DelayedDiagnostics.add(\n          sema::DelayedDiagnostic::makeForbiddenType(loc,\n              diag::err_arc_indirect_no_ownership, type, isReference));\n    } else {\n      S.Diag(loc, diag::err_arc_indirect_no_ownership) << type << isReference;\n    }\n    implicitLifetime = Qualifiers::OCL_Strong;\n  }\n  assert(implicitLifetime && \"didn't infer any lifetime!\");\n\n  Qualifiers qs;\n  qs.addObjCLifetime(implicitLifetime);\n  return S.Context.getQualifiedType(type, qs);\n}\n\nstatic std::string getFunctionQualifiersAsString(const FunctionProtoType *FnTy){\n  std::string Quals = FnTy->getMethodQuals().getAsString();\n\n  switch (FnTy->getRefQualifier()) {\n  case RQ_None:\n    break;\n\n  case RQ_LValue:\n    if (!Quals.empty())\n      Quals += ' ';\n    Quals += '&';\n    break;\n\n  case RQ_RValue:\n    if (!Quals.empty())\n      Quals += ' ';\n    Quals += \"&&\";\n    break;\n  }\n\n  return Quals;\n}\n\nnamespace {\n/// Kinds of declarator that cannot contain a qualified function type.\n///\n/// C++98 [dcl.fct]p4 / C++11 [dcl.fct]p6:\n///     a function type with a cv-qualifier or a ref-qualifier can only appear\n///     at the topmost level of a type.\n///\n/// Parens and member pointers are permitted. We don't diagnose array and\n/// function declarators, because they don't allow function types at all.\n///\n/// The values of this enum are used in diagnostics.\nenum QualifiedFunctionKind { QFK_BlockPointer, QFK_Pointer, QFK_Reference };\n} // end anonymous namespace\n\n/// Check whether the type T is a qualified function type, and if it is,\n/// diagnose that it cannot be contained within the given kind of declarator.\nstatic bool checkQualifiedFunction(Sema &S, QualType T, SourceLocation Loc,\n                                   QualifiedFunctionKind QFK) {\n  // Does T refer to a function type with a cv-qualifier or a ref-qualifier?\n  const FunctionProtoType *FPT = T->getAs<FunctionProtoType>();\n  if (!FPT ||\n      (FPT->getMethodQuals().empty() && FPT->getRefQualifier() == RQ_None))\n    return false;\n\n  S.Diag(Loc, diag::err_compound_qualified_function_type)\n    << QFK << isa<FunctionType>(T.IgnoreParens()) << T\n    << getFunctionQualifiersAsString(FPT);\n  return true;\n}\n\nbool Sema::CheckQualifiedFunctionForTypeId(QualType T, SourceLocation Loc) {\n  const FunctionProtoType *FPT = T->getAs<FunctionProtoType>();\n  if (!FPT ||\n      (FPT->getMethodQuals().empty() && FPT->getRefQualifier() == RQ_None))\n    return false;\n\n  Diag(Loc, diag::err_qualified_function_typeid)\n      << T << getFunctionQualifiersAsString(FPT);\n  return true;\n}\n\n// Helper to deduce addr space of a pointee type in OpenCL mode.\nstatic QualType deduceOpenCLPointeeAddrSpace(Sema &S, QualType PointeeType) {\n  if (!PointeeType->isUndeducedAutoType() && !PointeeType->isDependentType() &&\n      !PointeeType->isSamplerT() &&\n      !PointeeType.hasAddressSpace())\n    PointeeType = S.getASTContext().getAddrSpaceQualType(\n        PointeeType, S.getLangOpts().OpenCLGenericAddressSpace\n                         ? LangAS::opencl_generic\n                         : LangAS::opencl_private);\n  return PointeeType;\n}\n\n/// Build a pointer type.\n///\n/// \\param T The type to which we'll be building a pointer.\n///\n/// \\param Loc The location of the entity whose type involves this\n/// pointer type or, if there is no such entity, the location of the\n/// type that will have pointer type.\n///\n/// \\param Entity The name of the entity that involves the pointer\n/// type, if known.\n///\n/// \\returns A suitable pointer type, if there are no\n/// errors. Otherwise, returns a NULL type.\nQualType Sema::BuildPointerType(QualType T,\n                                SourceLocation Loc, DeclarationName Entity) {\n  if (T->isReferenceType()) {\n    // C++ 8.3.2p4: There shall be no ... pointers to references ...\n    Diag(Loc, diag::err_illegal_decl_pointer_to_reference)\n      << getPrintableNameForEntity(Entity) << T;\n    return QualType();\n  }\n\n  if (T->isFunctionType() && getLangOpts().OpenCL &&\n      !getOpenCLOptions().isEnabled(\"__cl_clang_function_pointers\")) {\n    Diag(Loc, diag::err_opencl_function_pointer) << /*pointer*/ 0;\n    return QualType();\n  }\n\n  if (checkQualifiedFunction(*this, T, Loc, QFK_Pointer))\n    return QualType();\n\n  assert(!T->isObjCObjectType() && \"Should build ObjCObjectPointerType\");\n\n  // In ARC, it is forbidden to build pointers to unqualified pointers.\n  if (getLangOpts().ObjCAutoRefCount)\n    T = inferARCLifetimeForPointee(*this, T, Loc, /*reference*/ false);\n\n  if (getLangOpts().OpenCL)\n    T = deduceOpenCLPointeeAddrSpace(*this, T);\n\n  // Build the pointer type.\n  return Context.getPointerType(T);\n}\n\n/// Build a reference type.\n///\n/// \\param T The type to which we'll be building a reference.\n///\n/// \\param Loc The location of the entity whose type involves this\n/// reference type or, if there is no such entity, the location of the\n/// type that will have reference type.\n///\n/// \\param Entity The name of the entity that involves the reference\n/// type, if known.\n///\n/// \\returns A suitable reference type, if there are no\n/// errors. Otherwise, returns a NULL type.\nQualType Sema::BuildReferenceType(QualType T, bool SpelledAsLValue,\n                                  SourceLocation Loc,\n                                  DeclarationName Entity) {\n  assert(Context.getCanonicalType(T) != Context.OverloadTy &&\n         \"Unresolved overloaded function type\");\n\n  // C++0x [dcl.ref]p6:\n  //   If a typedef (7.1.3), a type template-parameter (14.3.1), or a\n  //   decltype-specifier (7.1.6.2) denotes a type TR that is a reference to a\n  //   type T, an attempt to create the type \"lvalue reference to cv TR\" creates\n  //   the type \"lvalue reference to T\", while an attempt to create the type\n  //   \"rvalue reference to cv TR\" creates the type TR.\n  bool LValueRef = SpelledAsLValue || T->getAs<LValueReferenceType>();\n\n  // C++ [dcl.ref]p4: There shall be no references to references.\n  //\n  // According to C++ DR 106, references to references are only\n  // diagnosed when they are written directly (e.g., \"int & &\"),\n  // but not when they happen via a typedef:\n  //\n  //   typedef int& intref;\n  //   typedef intref& intref2;\n  //\n  // Parser::ParseDeclaratorInternal diagnoses the case where\n  // references are written directly; here, we handle the\n  // collapsing of references-to-references as described in C++0x.\n  // DR 106 and 540 introduce reference-collapsing into C++98/03.\n\n  // C++ [dcl.ref]p1:\n  //   A declarator that specifies the type \"reference to cv void\"\n  //   is ill-formed.\n  if (T->isVoidType()) {\n    Diag(Loc, diag::err_reference_to_void);\n    return QualType();\n  }\n\n  if (checkQualifiedFunction(*this, T, Loc, QFK_Reference))\n    return QualType();\n\n  if (T->isFunctionType() && getLangOpts().OpenCL &&\n      !getOpenCLOptions().isEnabled(\"__cl_clang_function_pointers\")) {\n    Diag(Loc, diag::err_opencl_function_pointer) << /*reference*/ 1;\n    return QualType();\n  }\n\n  // In ARC, it is forbidden to build references to unqualified pointers.\n  if (getLangOpts().ObjCAutoRefCount)\n    T = inferARCLifetimeForPointee(*this, T, Loc, /*reference*/ true);\n\n  if (getLangOpts().OpenCL)\n    T = deduceOpenCLPointeeAddrSpace(*this, T);\n\n  // Handle restrict on references.\n  if (LValueRef)\n    return Context.getLValueReferenceType(T, SpelledAsLValue);\n  return Context.getRValueReferenceType(T);\n}\n\n/// Build a Read-only Pipe type.\n///\n/// \\param T The type to which we'll be building a Pipe.\n///\n/// \\param Loc We do not use it for now.\n///\n/// \\returns A suitable pipe type, if there are no errors. Otherwise, returns a\n/// NULL type.\nQualType Sema::BuildReadPipeType(QualType T, SourceLocation Loc) {\n  return Context.getReadPipeType(T);\n}\n\n/// Build a Write-only Pipe type.\n///\n/// \\param T The type to which we'll be building a Pipe.\n///\n/// \\param Loc We do not use it for now.\n///\n/// \\returns A suitable pipe type, if there are no errors. Otherwise, returns a\n/// NULL type.\nQualType Sema::BuildWritePipeType(QualType T, SourceLocation Loc) {\n  return Context.getWritePipeType(T);\n}\n\n/// Build a extended int type.\n///\n/// \\param IsUnsigned Boolean representing the signedness of the type.\n///\n/// \\param BitWidth Size of this int type in bits, or an expression representing\n/// that.\n///\n/// \\param Loc Location of the keyword.\nQualType Sema::BuildExtIntType(bool IsUnsigned, Expr *BitWidth,\n                               SourceLocation Loc) {\n  if (BitWidth->isInstantiationDependent())\n    return Context.getDependentExtIntType(IsUnsigned, BitWidth);\n\n  llvm::APSInt Bits(32);\n  ExprResult ICE =\n      VerifyIntegerConstantExpression(BitWidth, &Bits, /*FIXME*/ AllowFold);\n\n  if (ICE.isInvalid())\n    return QualType();\n\n  int64_t NumBits = Bits.getSExtValue();\n  if (!IsUnsigned && NumBits < 2) {\n    Diag(Loc, diag::err_ext_int_bad_size) << 0;\n    return QualType();\n  }\n\n  if (IsUnsigned && NumBits < 1) {\n    Diag(Loc, diag::err_ext_int_bad_size) << 1;\n    return QualType();\n  }\n\n  if (NumBits > llvm::IntegerType::MAX_INT_BITS) {\n    Diag(Loc, diag::err_ext_int_max_size) << IsUnsigned\n                                          << llvm::IntegerType::MAX_INT_BITS;\n    return QualType();\n  }\n\n  return Context.getExtIntType(IsUnsigned, NumBits);\n}\n\n/// Check whether the specified array bound can be evaluated using the relevant\n/// language rules. If so, returns the possibly-converted expression and sets\n/// SizeVal to the size. If not, but the expression might be a VLA bound,\n/// returns ExprResult(). Otherwise, produces a diagnostic and returns\n/// ExprError().\nstatic ExprResult checkArraySize(Sema &S, Expr *&ArraySize,\n                                 llvm::APSInt &SizeVal, unsigned VLADiag,\n                                 bool VLAIsError) {\n  if (S.getLangOpts().CPlusPlus14 &&\n      (VLAIsError ||\n       !ArraySize->getType()->isIntegralOrUnscopedEnumerationType())) {\n    // C++14 [dcl.array]p1:\n    //   The constant-expression shall be a converted constant expression of\n    //   type std::size_t.\n    //\n    // Don't apply this rule if we might be forming a VLA: in that case, we\n    // allow non-constant expressions and constant-folding. We only need to use\n    // the converted constant expression rules (to properly convert the source)\n    // when the source expression is of class type.\n    return S.CheckConvertedConstantExpression(\n        ArraySize, S.Context.getSizeType(), SizeVal, Sema::CCEK_ArrayBound);\n  }\n\n  // If the size is an ICE, it certainly isn't a VLA. If we're in a GNU mode\n  // (like gnu99, but not c99) accept any evaluatable value as an extension.\n  class VLADiagnoser : public Sema::VerifyICEDiagnoser {\n  public:\n    unsigned VLADiag;\n    bool VLAIsError;\n    bool IsVLA = false;\n\n    VLADiagnoser(unsigned VLADiag, bool VLAIsError)\n        : VLADiag(VLADiag), VLAIsError(VLAIsError) {}\n\n    Sema::SemaDiagnosticBuilder diagnoseNotICEType(Sema &S, SourceLocation Loc,\n                                                   QualType T) override {\n      return S.Diag(Loc, diag::err_array_size_non_int) << T;\n    }\n\n    Sema::SemaDiagnosticBuilder diagnoseNotICE(Sema &S,\n                                               SourceLocation Loc) override {\n      IsVLA = !VLAIsError;\n      return S.Diag(Loc, VLADiag);\n    }\n\n    Sema::SemaDiagnosticBuilder diagnoseFold(Sema &S,\n                                             SourceLocation Loc) override {\n      return S.Diag(Loc, diag::ext_vla_folded_to_constant);\n    }\n  } Diagnoser(VLADiag, VLAIsError);\n\n  ExprResult R =\n      S.VerifyIntegerConstantExpression(ArraySize, &SizeVal, Diagnoser);\n  if (Diagnoser.IsVLA)\n    return ExprResult();\n  return R;\n}\n\n/// Build an array type.\n///\n/// \\param T The type of each element in the array.\n///\n/// \\param ASM C99 array size modifier (e.g., '*', 'static').\n///\n/// \\param ArraySize Expression describing the size of the array.\n///\n/// \\param Brackets The range from the opening '[' to the closing ']'.\n///\n/// \\param Entity The name of the entity that involves the array\n/// type, if known.\n///\n/// \\returns A suitable array type, if there are no errors. Otherwise,\n/// returns a NULL type.\nQualType Sema::BuildArrayType(QualType T, ArrayType::ArraySizeModifier ASM,\n                              Expr *ArraySize, unsigned Quals,\n                              SourceRange Brackets, DeclarationName Entity) {\n\n  SourceLocation Loc = Brackets.getBegin();\n  if (getLangOpts().CPlusPlus) {\n    // C++ [dcl.array]p1:\n    //   T is called the array element type; this type shall not be a reference\n    //   type, the (possibly cv-qualified) type void, a function type or an\n    //   abstract class type.\n    //\n    // C++ [dcl.array]p3:\n    //   When several \"array of\" specifications are adjacent, [...] only the\n    //   first of the constant expressions that specify the bounds of the arrays\n    //   may be omitted.\n    //\n    // Note: function types are handled in the common path with C.\n    if (T->isReferenceType()) {\n      Diag(Loc, diag::err_illegal_decl_array_of_references)\n      << getPrintableNameForEntity(Entity) << T;\n      return QualType();\n    }\n\n    if (T->isVoidType() || T->isIncompleteArrayType()) {\n      Diag(Loc, diag::err_array_incomplete_or_sizeless_type) << 0 << T;\n      return QualType();\n    }\n\n    if (RequireNonAbstractType(Brackets.getBegin(), T,\n                               diag::err_array_of_abstract_type))\n      return QualType();\n\n    // Mentioning a member pointer type for an array type causes us to lock in\n    // an inheritance model, even if it's inside an unused typedef.\n    if (Context.getTargetInfo().getCXXABI().isMicrosoft())\n      if (const MemberPointerType *MPTy = T->getAs<MemberPointerType>())\n        if (!MPTy->getClass()->isDependentType())\n          (void)isCompleteType(Loc, T);\n\n  } else {\n    // C99 6.7.5.2p1: If the element type is an incomplete or function type,\n    // reject it (e.g. void ary[7], struct foo ary[7], void ary[7]())\n    if (RequireCompleteSizedType(Loc, T,\n                                 diag::err_array_incomplete_or_sizeless_type))\n      return QualType();\n  }\n\n  if (T->isSizelessType()) {\n    Diag(Loc, diag::err_array_incomplete_or_sizeless_type) << 1 << T;\n    return QualType();\n  }\n\n  if (T->isFunctionType()) {\n    Diag(Loc, diag::err_illegal_decl_array_of_functions)\n      << getPrintableNameForEntity(Entity) << T;\n    return QualType();\n  }\n\n  if (const RecordType *EltTy = T->getAs<RecordType>()) {\n    // If the element type is a struct or union that contains a variadic\n    // array, accept it as a GNU extension: C99 6.7.2.1p2.\n    if (EltTy->getDecl()->hasFlexibleArrayMember())\n      Diag(Loc, diag::ext_flexible_array_in_array) << T;\n  } else if (T->isObjCObjectType()) {\n    Diag(Loc, diag::err_objc_array_of_interfaces) << T;\n    return QualType();\n  }\n\n  // Do placeholder conversions on the array size expression.\n  if (ArraySize && ArraySize->hasPlaceholderType()) {\n    ExprResult Result = CheckPlaceholderExpr(ArraySize);\n    if (Result.isInvalid()) return QualType();\n    ArraySize = Result.get();\n  }\n\n  // Do lvalue-to-rvalue conversions on the array size expression.\n  if (ArraySize && !ArraySize->isRValue()) {\n    ExprResult Result = DefaultLvalueConversion(ArraySize);\n    if (Result.isInvalid())\n      return QualType();\n\n    ArraySize = Result.get();\n  }\n\n  // C99 6.7.5.2p1: The size expression shall have integer type.\n  // C++11 allows contextual conversions to such types.\n  if (!getLangOpts().CPlusPlus11 &&\n      ArraySize && !ArraySize->isTypeDependent() &&\n      !ArraySize->getType()->isIntegralOrUnscopedEnumerationType()) {\n    Diag(ArraySize->getBeginLoc(), diag::err_array_size_non_int)\n        << ArraySize->getType() << ArraySize->getSourceRange();\n    return QualType();\n  }\n\n  // VLAs always produce at least a -Wvla diagnostic, sometimes an error.\n  unsigned VLADiag;\n  bool VLAIsError;\n  if (getLangOpts().OpenCL) {\n    // OpenCL v1.2 s6.9.d: variable length arrays are not supported.\n    VLADiag = diag::err_opencl_vla;\n    VLAIsError = true;\n  } else if (getLangOpts().C99) {\n    VLADiag = diag::warn_vla_used;\n    VLAIsError = false;\n  } else if (isSFINAEContext()) {\n    VLADiag = diag::err_vla_in_sfinae;\n    VLAIsError = true;\n  } else {\n    VLADiag = diag::ext_vla;\n    VLAIsError = false;\n  }\n\n  llvm::APSInt ConstVal(Context.getTypeSize(Context.getSizeType()));\n  if (!ArraySize) {\n    if (ASM == ArrayType::Star) {\n      Diag(Loc, VLADiag);\n      if (VLAIsError)\n        return QualType();\n\n      T = Context.getVariableArrayType(T, nullptr, ASM, Quals, Brackets);\n    } else {\n      T = Context.getIncompleteArrayType(T, ASM, Quals);\n    }\n  } else if (ArraySize->isTypeDependent() || ArraySize->isValueDependent()) {\n    T = Context.getDependentSizedArrayType(T, ArraySize, ASM, Quals, Brackets);\n  } else {\n    ExprResult R =\n        checkArraySize(*this, ArraySize, ConstVal, VLADiag, VLAIsError);\n    if (R.isInvalid())\n      return QualType();\n\n    if (!R.isUsable()) {\n      // C99: an array with a non-ICE size is a VLA. We accept any expression\n      // that we can fold to a non-zero positive value as a non-VLA as an\n      // extension.\n      T = Context.getVariableArrayType(T, ArraySize, ASM, Quals, Brackets);\n    } else if (!T->isDependentType() && !T->isIncompleteType() &&\n               !T->isConstantSizeType()) {\n      // C99: an array with an element type that has a non-constant-size is a\n      // VLA.\n      // FIXME: Add a note to explain why this isn't a VLA.\n      Diag(Loc, VLADiag);\n      if (VLAIsError)\n        return QualType();\n      T = Context.getVariableArrayType(T, ArraySize, ASM, Quals, Brackets);\n    } else {\n      // C99 6.7.5.2p1: If the expression is a constant expression, it shall\n      // have a value greater than zero.\n      // In C++, this follows from narrowing conversions being disallowed.\n      if (ConstVal.isSigned() && ConstVal.isNegative()) {\n        if (Entity)\n          Diag(ArraySize->getBeginLoc(), diag::err_decl_negative_array_size)\n              << getPrintableNameForEntity(Entity)\n              << ArraySize->getSourceRange();\n        else\n          Diag(ArraySize->getBeginLoc(),\n               diag::err_typecheck_negative_array_size)\n              << ArraySize->getSourceRange();\n        return QualType();\n      }\n      if (ConstVal == 0) {\n        // GCC accepts zero sized static arrays. We allow them when\n        // we're not in a SFINAE context.\n        Diag(ArraySize->getBeginLoc(),\n             isSFINAEContext() ? diag::err_typecheck_zero_array_size\n                               : diag::ext_typecheck_zero_array_size)\n            << ArraySize->getSourceRange();\n      }\n\n      // Is the array too large?\n      unsigned ActiveSizeBits =\n          (!T->isDependentType() && !T->isVariablyModifiedType() &&\n           !T->isIncompleteType() && !T->isUndeducedType())\n              ? ConstantArrayType::getNumAddressingBits(Context, T, ConstVal)\n              : ConstVal.getActiveBits();\n      if (ActiveSizeBits > ConstantArrayType::getMaxSizeBits(Context)) {\n        Diag(ArraySize->getBeginLoc(), diag::err_array_too_large)\n            << ConstVal.toString(10) << ArraySize->getSourceRange();\n        return QualType();\n      }\n\n      T = Context.getConstantArrayType(T, ConstVal, ArraySize, ASM, Quals);\n    }\n  }\n\n  if (T->isVariableArrayType() && !Context.getTargetInfo().isVLASupported()) {\n    // CUDA device code and some other targets don't support VLAs.\n    targetDiag(Loc, (getLangOpts().CUDA && getLangOpts().CUDAIsDevice)\n                        ? diag::err_cuda_vla\n                        : diag::err_vla_unsupported)\n        << ((getLangOpts().CUDA && getLangOpts().CUDAIsDevice)\n                ? CurrentCUDATarget()\n                : CFT_InvalidTarget);\n  }\n\n  // If this is not C99, diagnose array size modifiers on non-VLAs.\n  if (!getLangOpts().C99 && !T->isVariableArrayType() &&\n      (ASM != ArrayType::Normal || Quals != 0)) {\n    Diag(Loc, getLangOpts().CPlusPlus ? diag::err_c99_array_usage_cxx\n                                      : diag::ext_c99_array_usage)\n        << ASM;\n  }\n\n  // OpenCL v2.0 s6.12.5 - Arrays of blocks are not supported.\n  // OpenCL v2.0 s6.16.13.1 - Arrays of pipe type are not supported.\n  // OpenCL v2.0 s6.9.b - Arrays of image/sampler type are not supported.\n  if (getLangOpts().OpenCL) {\n    const QualType ArrType = Context.getBaseElementType(T);\n    if (ArrType->isBlockPointerType() || ArrType->isPipeType() ||\n        ArrType->isSamplerT() || ArrType->isImageType()) {\n      Diag(Loc, diag::err_opencl_invalid_type_array) << ArrType;\n      return QualType();\n    }\n  }\n\n  return T;\n}\n\nQualType Sema::BuildVectorType(QualType CurType, Expr *SizeExpr,\n                               SourceLocation AttrLoc) {\n  // The base type must be integer (not Boolean or enumeration) or float, and\n  // can't already be a vector.\n  if ((!CurType->isDependentType() &&\n       (!CurType->isBuiltinType() || CurType->isBooleanType() ||\n        (!CurType->isIntegerType() && !CurType->isRealFloatingType()))) ||\n      CurType->isArrayType()) {\n    Diag(AttrLoc, diag::err_attribute_invalid_vector_type) << CurType;\n    return QualType();\n  }\n\n  if (SizeExpr->isTypeDependent() || SizeExpr->isValueDependent())\n    return Context.getDependentVectorType(CurType, SizeExpr, AttrLoc,\n                                               VectorType::GenericVector);\n\n  Optional<llvm::APSInt> VecSize = SizeExpr->getIntegerConstantExpr(Context);\n  if (!VecSize) {\n    Diag(AttrLoc, diag::err_attribute_argument_type)\n        << \"vector_size\" << AANT_ArgumentIntegerConstant\n        << SizeExpr->getSourceRange();\n    return QualType();\n  }\n\n  if (CurType->isDependentType())\n    return Context.getDependentVectorType(CurType, SizeExpr, AttrLoc,\n                                               VectorType::GenericVector);\n\n  // vecSize is specified in bytes - convert to bits.\n  if (!VecSize->isIntN(61)) {\n    // Bit size will overflow uint64.\n    Diag(AttrLoc, diag::err_attribute_size_too_large)\n        << SizeExpr->getSourceRange() << \"vector\";\n    return QualType();\n  }\n  uint64_t VectorSizeBits = VecSize->getZExtValue() * 8;\n  unsigned TypeSize = static_cast<unsigned>(Context.getTypeSize(CurType));\n\n  if (VectorSizeBits == 0) {\n    Diag(AttrLoc, diag::err_attribute_zero_size)\n        << SizeExpr->getSourceRange() << \"vector\";\n    return QualType();\n  }\n\n  if (VectorSizeBits % TypeSize) {\n    Diag(AttrLoc, diag::err_attribute_invalid_size)\n        << SizeExpr->getSourceRange();\n    return QualType();\n  }\n\n  if (VectorSizeBits / TypeSize > std::numeric_limits<uint32_t>::max()) {\n    Diag(AttrLoc, diag::err_attribute_size_too_large)\n        << SizeExpr->getSourceRange() << \"vector\";\n    return QualType();\n  }\n\n  return Context.getVectorType(CurType, VectorSizeBits / TypeSize,\n                               VectorType::GenericVector);\n}\n\n/// Build an ext-vector type.\n///\n/// Run the required checks for the extended vector type.\nQualType Sema::BuildExtVectorType(QualType T, Expr *ArraySize,\n                                  SourceLocation AttrLoc) {\n  // Unlike gcc's vector_size attribute, we do not allow vectors to be defined\n  // in conjunction with complex types (pointers, arrays, functions, etc.).\n  //\n  // Additionally, OpenCL prohibits vectors of booleans (they're considered a\n  // reserved data type under OpenCL v2.0 s6.1.4), we don't support selects\n  // on bitvectors, and we have no well-defined ABI for bitvectors, so vectors\n  // of bool aren't allowed.\n  if ((!T->isDependentType() && !T->isIntegerType() &&\n       !T->isRealFloatingType()) ||\n      T->isBooleanType()) {\n    Diag(AttrLoc, diag::err_attribute_invalid_vector_type) << T;\n    return QualType();\n  }\n\n  if (!ArraySize->isTypeDependent() && !ArraySize->isValueDependent()) {\n    Optional<llvm::APSInt> vecSize = ArraySize->getIntegerConstantExpr(Context);\n    if (!vecSize) {\n      Diag(AttrLoc, diag::err_attribute_argument_type)\n        << \"ext_vector_type\" << AANT_ArgumentIntegerConstant\n        << ArraySize->getSourceRange();\n      return QualType();\n    }\n\n    if (!vecSize->isIntN(32)) {\n      Diag(AttrLoc, diag::err_attribute_size_too_large)\n          << ArraySize->getSourceRange() << \"vector\";\n      return QualType();\n    }\n    // Unlike gcc's vector_size attribute, the size is specified as the\n    // number of elements, not the number of bytes.\n    unsigned vectorSize = static_cast<unsigned>(vecSize->getZExtValue());\n\n    if (vectorSize == 0) {\n      Diag(AttrLoc, diag::err_attribute_zero_size)\n          << ArraySize->getSourceRange() << \"vector\";\n      return QualType();\n    }\n\n    return Context.getExtVectorType(T, vectorSize);\n  }\n\n  return Context.getDependentSizedExtVectorType(T, ArraySize, AttrLoc);\n}\n\nQualType Sema::BuildMatrixType(QualType ElementTy, Expr *NumRows, Expr *NumCols,\n                               SourceLocation AttrLoc) {\n  assert(Context.getLangOpts().MatrixTypes &&\n         \"Should never build a matrix type when it is disabled\");\n\n  // Check element type, if it is not dependent.\n  if (!ElementTy->isDependentType() &&\n      !MatrixType::isValidElementType(ElementTy)) {\n    Diag(AttrLoc, diag::err_attribute_invalid_matrix_type) << ElementTy;\n    return QualType();\n  }\n\n  if (NumRows->isTypeDependent() || NumCols->isTypeDependent() ||\n      NumRows->isValueDependent() || NumCols->isValueDependent())\n    return Context.getDependentSizedMatrixType(ElementTy, NumRows, NumCols,\n                                               AttrLoc);\n\n  Optional<llvm::APSInt> ValueRows = NumRows->getIntegerConstantExpr(Context);\n  Optional<llvm::APSInt> ValueColumns =\n      NumCols->getIntegerConstantExpr(Context);\n\n  auto const RowRange = NumRows->getSourceRange();\n  auto const ColRange = NumCols->getSourceRange();\n\n  // Both are row and column expressions are invalid.\n  if (!ValueRows && !ValueColumns) {\n    Diag(AttrLoc, diag::err_attribute_argument_type)\n        << \"matrix_type\" << AANT_ArgumentIntegerConstant << RowRange\n        << ColRange;\n    return QualType();\n  }\n\n  // Only the row expression is invalid.\n  if (!ValueRows) {\n    Diag(AttrLoc, diag::err_attribute_argument_type)\n        << \"matrix_type\" << AANT_ArgumentIntegerConstant << RowRange;\n    return QualType();\n  }\n\n  // Only the column expression is invalid.\n  if (!ValueColumns) {\n    Diag(AttrLoc, diag::err_attribute_argument_type)\n        << \"matrix_type\" << AANT_ArgumentIntegerConstant << ColRange;\n    return QualType();\n  }\n\n  // Check the matrix dimensions.\n  unsigned MatrixRows = static_cast<unsigned>(ValueRows->getZExtValue());\n  unsigned MatrixColumns = static_cast<unsigned>(ValueColumns->getZExtValue());\n  if (MatrixRows == 0 && MatrixColumns == 0) {\n    Diag(AttrLoc, diag::err_attribute_zero_size)\n        << \"matrix\" << RowRange << ColRange;\n    return QualType();\n  }\n  if (MatrixRows == 0) {\n    Diag(AttrLoc, diag::err_attribute_zero_size) << \"matrix\" << RowRange;\n    return QualType();\n  }\n  if (MatrixColumns == 0) {\n    Diag(AttrLoc, diag::err_attribute_zero_size) << \"matrix\" << ColRange;\n    return QualType();\n  }\n  if (!ConstantMatrixType::isDimensionValid(MatrixRows)) {\n    Diag(AttrLoc, diag::err_attribute_size_too_large)\n        << RowRange << \"matrix row\";\n    return QualType();\n  }\n  if (!ConstantMatrixType::isDimensionValid(MatrixColumns)) {\n    Diag(AttrLoc, diag::err_attribute_size_too_large)\n        << ColRange << \"matrix column\";\n    return QualType();\n  }\n  return Context.getConstantMatrixType(ElementTy, MatrixRows, MatrixColumns);\n}\n\nbool Sema::CheckFunctionReturnType(QualType T, SourceLocation Loc) {\n  if (T->isArrayType() || T->isFunctionType()) {\n    Diag(Loc, diag::err_func_returning_array_function)\n      << T->isFunctionType() << T;\n    return true;\n  }\n\n  // Functions cannot return half FP.\n  if (T->isHalfType() && !getLangOpts().HalfArgsAndReturns) {\n    Diag(Loc, diag::err_parameters_retval_cannot_have_fp16_type) << 1 <<\n      FixItHint::CreateInsertion(Loc, \"*\");\n    return true;\n  }\n\n  // Methods cannot return interface types. All ObjC objects are\n  // passed by reference.\n  if (T->isObjCObjectType()) {\n    Diag(Loc, diag::err_object_cannot_be_passed_returned_by_value)\n        << 0 << T << FixItHint::CreateInsertion(Loc, \"*\");\n    return true;\n  }\n\n  if (T.hasNonTrivialToPrimitiveDestructCUnion() ||\n      T.hasNonTrivialToPrimitiveCopyCUnion())\n    checkNonTrivialCUnion(T, Loc, NTCUC_FunctionReturn,\n                          NTCUK_Destruct|NTCUK_Copy);\n\n  // C++2a [dcl.fct]p12:\n  //   A volatile-qualified return type is deprecated\n  if (T.isVolatileQualified() && getLangOpts().CPlusPlus20)\n    Diag(Loc, diag::warn_deprecated_volatile_return) << T;\n\n  return false;\n}\n\n/// Check the extended parameter information.  Most of the necessary\n/// checking should occur when applying the parameter attribute; the\n/// only other checks required are positional restrictions.\nstatic void checkExtParameterInfos(Sema &S, ArrayRef<QualType> paramTypes,\n                    const FunctionProtoType::ExtProtoInfo &EPI,\n                    llvm::function_ref<SourceLocation(unsigned)> getParamLoc) {\n  assert(EPI.ExtParameterInfos && \"shouldn't get here without param infos\");\n\n  bool hasCheckedSwiftCall = false;\n  auto checkForSwiftCC = [&](unsigned paramIndex) {\n    // Only do this once.\n    if (hasCheckedSwiftCall) return;\n    hasCheckedSwiftCall = true;\n    if (EPI.ExtInfo.getCC() == CC_Swift) return;\n    S.Diag(getParamLoc(paramIndex), diag::err_swift_param_attr_not_swiftcall)\n      << getParameterABISpelling(EPI.ExtParameterInfos[paramIndex].getABI());\n  };\n\n  for (size_t paramIndex = 0, numParams = paramTypes.size();\n          paramIndex != numParams; ++paramIndex) {\n    switch (EPI.ExtParameterInfos[paramIndex].getABI()) {\n    // Nothing interesting to check for orindary-ABI parameters.\n    case ParameterABI::Ordinary:\n      continue;\n\n    // swift_indirect_result parameters must be a prefix of the function\n    // arguments.\n    case ParameterABI::SwiftIndirectResult:\n      checkForSwiftCC(paramIndex);\n      if (paramIndex != 0 &&\n          EPI.ExtParameterInfos[paramIndex - 1].getABI()\n            != ParameterABI::SwiftIndirectResult) {\n        S.Diag(getParamLoc(paramIndex),\n               diag::err_swift_indirect_result_not_first);\n      }\n      continue;\n\n    case ParameterABI::SwiftContext:\n      checkForSwiftCC(paramIndex);\n      continue;\n\n    // swift_error parameters must be preceded by a swift_context parameter.\n    case ParameterABI::SwiftErrorResult:\n      checkForSwiftCC(paramIndex);\n      if (paramIndex == 0 ||\n          EPI.ExtParameterInfos[paramIndex - 1].getABI() !=\n              ParameterABI::SwiftContext) {\n        S.Diag(getParamLoc(paramIndex),\n               diag::err_swift_error_result_not_after_swift_context);\n      }\n      continue;\n    }\n    llvm_unreachable(\"bad ABI kind\");\n  }\n}\n\nQualType Sema::BuildFunctionType(QualType T,\n                                 MutableArrayRef<QualType> ParamTypes,\n                                 SourceLocation Loc, DeclarationName Entity,\n                                 const FunctionProtoType::ExtProtoInfo &EPI) {\n  bool Invalid = false;\n\n  Invalid |= CheckFunctionReturnType(T, Loc);\n\n  for (unsigned Idx = 0, Cnt = ParamTypes.size(); Idx < Cnt; ++Idx) {\n    // FIXME: Loc is too inprecise here, should use proper locations for args.\n    QualType ParamType = Context.getAdjustedParameterType(ParamTypes[Idx]);\n    if (ParamType->isVoidType()) {\n      Diag(Loc, diag::err_param_with_void_type);\n      Invalid = true;\n    } else if (ParamType->isHalfType() && !getLangOpts().HalfArgsAndReturns) {\n      // Disallow half FP arguments.\n      Diag(Loc, diag::err_parameters_retval_cannot_have_fp16_type) << 0 <<\n        FixItHint::CreateInsertion(Loc, \"*\");\n      Invalid = true;\n    }\n\n    // C++2a [dcl.fct]p4:\n    //   A parameter with volatile-qualified type is deprecated\n    if (ParamType.isVolatileQualified() && getLangOpts().CPlusPlus20)\n      Diag(Loc, diag::warn_deprecated_volatile_param) << ParamType;\n\n    ParamTypes[Idx] = ParamType;\n  }\n\n  if (EPI.ExtParameterInfos) {\n    checkExtParameterInfos(*this, ParamTypes, EPI,\n                           [=](unsigned i) { return Loc; });\n  }\n\n  if (EPI.ExtInfo.getProducesResult()) {\n    // This is just a warning, so we can't fail to build if we see it.\n    checkNSReturnsRetainedReturnType(Loc, T);\n  }\n\n  if (Invalid)\n    return QualType();\n\n  return Context.getFunctionType(T, ParamTypes, EPI);\n}\n\n/// Build a member pointer type \\c T Class::*.\n///\n/// \\param T the type to which the member pointer refers.\n/// \\param Class the class type into which the member pointer points.\n/// \\param Loc the location where this type begins\n/// \\param Entity the name of the entity that will have this member pointer type\n///\n/// \\returns a member pointer type, if successful, or a NULL type if there was\n/// an error.\nQualType Sema::BuildMemberPointerType(QualType T, QualType Class,\n                                      SourceLocation Loc,\n                                      DeclarationName Entity) {\n  // Verify that we're not building a pointer to pointer to function with\n  // exception specification.\n  if (CheckDistantExceptionSpec(T)) {\n    Diag(Loc, diag::err_distant_exception_spec);\n    return QualType();\n  }\n\n  // C++ 8.3.3p3: A pointer to member shall not point to ... a member\n  //   with reference type, or \"cv void.\"\n  if (T->isReferenceType()) {\n    Diag(Loc, diag::err_illegal_decl_mempointer_to_reference)\n      << getPrintableNameForEntity(Entity) << T;\n    return QualType();\n  }\n\n  if (T->isVoidType()) {\n    Diag(Loc, diag::err_illegal_decl_mempointer_to_void)\n      << getPrintableNameForEntity(Entity);\n    return QualType();\n  }\n\n  if (!Class->isDependentType() && !Class->isRecordType()) {\n    Diag(Loc, diag::err_mempointer_in_nonclass_type) << Class;\n    return QualType();\n  }\n\n  if (T->isFunctionType() && getLangOpts().OpenCL &&\n      !getOpenCLOptions().isEnabled(\"__cl_clang_function_pointers\")) {\n    Diag(Loc, diag::err_opencl_function_pointer) << /*pointer*/ 0;\n    return QualType();\n  }\n\n  // Adjust the default free function calling convention to the default method\n  // calling convention.\n  bool IsCtorOrDtor =\n      (Entity.getNameKind() == DeclarationName::CXXConstructorName) ||\n      (Entity.getNameKind() == DeclarationName::CXXDestructorName);\n  if (T->isFunctionType())\n    adjustMemberFunctionCC(T, /*IsStatic=*/false, IsCtorOrDtor, Loc);\n\n  return Context.getMemberPointerType(T, Class.getTypePtr());\n}\n\n/// Build a block pointer type.\n///\n/// \\param T The type to which we'll be building a block pointer.\n///\n/// \\param Loc The source location, used for diagnostics.\n///\n/// \\param Entity The name of the entity that involves the block pointer\n/// type, if known.\n///\n/// \\returns A suitable block pointer type, if there are no\n/// errors. Otherwise, returns a NULL type.\nQualType Sema::BuildBlockPointerType(QualType T,\n                                     SourceLocation Loc,\n                                     DeclarationName Entity) {\n  if (!T->isFunctionType()) {\n    Diag(Loc, diag::err_nonfunction_block_type);\n    return QualType();\n  }\n\n  if (checkQualifiedFunction(*this, T, Loc, QFK_BlockPointer))\n    return QualType();\n\n  if (getLangOpts().OpenCL)\n    T = deduceOpenCLPointeeAddrSpace(*this, T);\n\n  return Context.getBlockPointerType(T);\n}\n\nQualType Sema::GetTypeFromParser(ParsedType Ty, TypeSourceInfo **TInfo) {\n  QualType QT = Ty.get();\n  if (QT.isNull()) {\n    if (TInfo) *TInfo = nullptr;\n    return QualType();\n  }\n\n  TypeSourceInfo *DI = nullptr;\n  if (const LocInfoType *LIT = dyn_cast<LocInfoType>(QT)) {\n    QT = LIT->getType();\n    DI = LIT->getTypeSourceInfo();\n  }\n\n  if (TInfo) *TInfo = DI;\n  return QT;\n}\n\nstatic void transferARCOwnershipToDeclaratorChunk(TypeProcessingState &state,\n                                            Qualifiers::ObjCLifetime ownership,\n                                            unsigned chunkIndex);\n\n/// Given that this is the declaration of a parameter under ARC,\n/// attempt to infer attributes and such for pointer-to-whatever\n/// types.\nstatic void inferARCWriteback(TypeProcessingState &state,\n                              QualType &declSpecType) {\n  Sema &S = state.getSema();\n  Declarator &declarator = state.getDeclarator();\n\n  // TODO: should we care about decl qualifiers?\n\n  // Check whether the declarator has the expected form.  We walk\n  // from the inside out in order to make the block logic work.\n  unsigned outermostPointerIndex = 0;\n  bool isBlockPointer = false;\n  unsigned numPointers = 0;\n  for (unsigned i = 0, e = declarator.getNumTypeObjects(); i != e; ++i) {\n    unsigned chunkIndex = i;\n    DeclaratorChunk &chunk = declarator.getTypeObject(chunkIndex);\n    switch (chunk.Kind) {\n    case DeclaratorChunk::Paren:\n      // Ignore parens.\n      break;\n\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::Pointer:\n      // Count the number of pointers.  Treat references\n      // interchangeably as pointers; if they're mis-ordered, normal\n      // type building will discover that.\n      outermostPointerIndex = chunkIndex;\n      numPointers++;\n      break;\n\n    case DeclaratorChunk::BlockPointer:\n      // If we have a pointer to block pointer, that's an acceptable\n      // indirect reference; anything else is not an application of\n      // the rules.\n      if (numPointers != 1) return;\n      numPointers++;\n      outermostPointerIndex = chunkIndex;\n      isBlockPointer = true;\n\n      // We don't care about pointer structure in return values here.\n      goto done;\n\n    case DeclaratorChunk::Array: // suppress if written (id[])?\n    case DeclaratorChunk::Function:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Pipe:\n      return;\n    }\n  }\n done:\n\n  // If we have *one* pointer, then we want to throw the qualifier on\n  // the declaration-specifiers, which means that it needs to be a\n  // retainable object type.\n  if (numPointers == 1) {\n    // If it's not a retainable object type, the rule doesn't apply.\n    if (!declSpecType->isObjCRetainableType()) return;\n\n    // If it already has lifetime, don't do anything.\n    if (declSpecType.getObjCLifetime()) return;\n\n    // Otherwise, modify the type in-place.\n    Qualifiers qs;\n\n    if (declSpecType->isObjCARCImplicitlyUnretainedType())\n      qs.addObjCLifetime(Qualifiers::OCL_ExplicitNone);\n    else\n      qs.addObjCLifetime(Qualifiers::OCL_Autoreleasing);\n    declSpecType = S.Context.getQualifiedType(declSpecType, qs);\n\n  // If we have *two* pointers, then we want to throw the qualifier on\n  // the outermost pointer.\n  } else if (numPointers == 2) {\n    // If we don't have a block pointer, we need to check whether the\n    // declaration-specifiers gave us something that will turn into a\n    // retainable object pointer after we slap the first pointer on it.\n    if (!isBlockPointer && !declSpecType->isObjCObjectType())\n      return;\n\n    // Look for an explicit lifetime attribute there.\n    DeclaratorChunk &chunk = declarator.getTypeObject(outermostPointerIndex);\n    if (chunk.Kind != DeclaratorChunk::Pointer &&\n        chunk.Kind != DeclaratorChunk::BlockPointer)\n      return;\n    for (const ParsedAttr &AL : chunk.getAttrs())\n      if (AL.getKind() == ParsedAttr::AT_ObjCOwnership)\n        return;\n\n    transferARCOwnershipToDeclaratorChunk(state, Qualifiers::OCL_Autoreleasing,\n                                          outermostPointerIndex);\n\n  // Any other number of pointers/references does not trigger the rule.\n  } else return;\n\n  // TODO: mark whether we did this inference?\n}\n\nvoid Sema::diagnoseIgnoredQualifiers(unsigned DiagID, unsigned Quals,\n                                     SourceLocation FallbackLoc,\n                                     SourceLocation ConstQualLoc,\n                                     SourceLocation VolatileQualLoc,\n                                     SourceLocation RestrictQualLoc,\n                                     SourceLocation AtomicQualLoc,\n                                     SourceLocation UnalignedQualLoc) {\n  if (!Quals)\n    return;\n\n  struct Qual {\n    const char *Name;\n    unsigned Mask;\n    SourceLocation Loc;\n  } const QualKinds[5] = {\n    { \"const\", DeclSpec::TQ_const, ConstQualLoc },\n    { \"volatile\", DeclSpec::TQ_volatile, VolatileQualLoc },\n    { \"restrict\", DeclSpec::TQ_restrict, RestrictQualLoc },\n    { \"__unaligned\", DeclSpec::TQ_unaligned, UnalignedQualLoc },\n    { \"_Atomic\", DeclSpec::TQ_atomic, AtomicQualLoc }\n  };\n\n  SmallString<32> QualStr;\n  unsigned NumQuals = 0;\n  SourceLocation Loc;\n  FixItHint FixIts[5];\n\n  // Build a string naming the redundant qualifiers.\n  for (auto &E : QualKinds) {\n    if (Quals & E.Mask) {\n      if (!QualStr.empty()) QualStr += ' ';\n      QualStr += E.Name;\n\n      // If we have a location for the qualifier, offer a fixit.\n      SourceLocation QualLoc = E.Loc;\n      if (QualLoc.isValid()) {\n        FixIts[NumQuals] = FixItHint::CreateRemoval(QualLoc);\n        if (Loc.isInvalid() ||\n            getSourceManager().isBeforeInTranslationUnit(QualLoc, Loc))\n          Loc = QualLoc;\n      }\n\n      ++NumQuals;\n    }\n  }\n\n  Diag(Loc.isInvalid() ? FallbackLoc : Loc, DiagID)\n    << QualStr << NumQuals << FixIts[0] << FixIts[1] << FixIts[2] << FixIts[3];\n}\n\n// Diagnose pointless type qualifiers on the return type of a function.\nstatic void diagnoseRedundantReturnTypeQualifiers(Sema &S, QualType RetTy,\n                                                  Declarator &D,\n                                                  unsigned FunctionChunkIndex) {\n  const DeclaratorChunk::FunctionTypeInfo &FTI =\n      D.getTypeObject(FunctionChunkIndex).Fun;\n  if (FTI.hasTrailingReturnType()) {\n    S.diagnoseIgnoredQualifiers(diag::warn_qual_return_type,\n                                RetTy.getLocalCVRQualifiers(),\n                                FTI.getTrailingReturnTypeLoc());\n    return;\n  }\n\n  for (unsigned OuterChunkIndex = FunctionChunkIndex + 1,\n                End = D.getNumTypeObjects();\n       OuterChunkIndex != End; ++OuterChunkIndex) {\n    DeclaratorChunk &OuterChunk = D.getTypeObject(OuterChunkIndex);\n    switch (OuterChunk.Kind) {\n    case DeclaratorChunk::Paren:\n      continue;\n\n    case DeclaratorChunk::Pointer: {\n      DeclaratorChunk::PointerTypeInfo &PTI = OuterChunk.Ptr;\n      S.diagnoseIgnoredQualifiers(\n          diag::warn_qual_return_type,\n          PTI.TypeQuals,\n          SourceLocation(),\n          PTI.ConstQualLoc,\n          PTI.VolatileQualLoc,\n          PTI.RestrictQualLoc,\n          PTI.AtomicQualLoc,\n          PTI.UnalignedQualLoc);\n      return;\n    }\n\n    case DeclaratorChunk::Function:\n    case DeclaratorChunk::BlockPointer:\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::Array:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Pipe:\n      // FIXME: We can't currently provide an accurate source location and a\n      // fix-it hint for these.\n      unsigned AtomicQual = RetTy->isAtomicType() ? DeclSpec::TQ_atomic : 0;\n      S.diagnoseIgnoredQualifiers(diag::warn_qual_return_type,\n                                  RetTy.getCVRQualifiers() | AtomicQual,\n                                  D.getIdentifierLoc());\n      return;\n    }\n\n    llvm_unreachable(\"unknown declarator chunk kind\");\n  }\n\n  // If the qualifiers come from a conversion function type, don't diagnose\n  // them -- they're not necessarily redundant, since such a conversion\n  // operator can be explicitly called as \"x.operator const int()\".\n  if (D.getName().getKind() == UnqualifiedIdKind::IK_ConversionFunctionId)\n    return;\n\n  // Just parens all the way out to the decl specifiers. Diagnose any qualifiers\n  // which are present there.\n  S.diagnoseIgnoredQualifiers(diag::warn_qual_return_type,\n                              D.getDeclSpec().getTypeQualifiers(),\n                              D.getIdentifierLoc(),\n                              D.getDeclSpec().getConstSpecLoc(),\n                              D.getDeclSpec().getVolatileSpecLoc(),\n                              D.getDeclSpec().getRestrictSpecLoc(),\n                              D.getDeclSpec().getAtomicSpecLoc(),\n                              D.getDeclSpec().getUnalignedSpecLoc());\n}\n\nstatic std::pair<QualType, TypeSourceInfo *>\nInventTemplateParameter(TypeProcessingState &state, QualType T,\n                        TypeSourceInfo *TrailingTSI, AutoType *Auto,\n                        InventedTemplateParameterInfo &Info) {\n  Sema &S = state.getSema();\n  Declarator &D = state.getDeclarator();\n\n  const unsigned TemplateParameterDepth = Info.AutoTemplateParameterDepth;\n  const unsigned AutoParameterPosition = Info.TemplateParams.size();\n  const bool IsParameterPack = D.hasEllipsis();\n\n  // If auto is mentioned in a lambda parameter or abbreviated function\n  // template context, convert it to a template parameter type.\n\n  // Create the TemplateTypeParmDecl here to retrieve the corresponding\n  // template parameter type. Template parameters are temporarily added\n  // to the TU until the associated TemplateDecl is created.\n  TemplateTypeParmDecl *InventedTemplateParam =\n      TemplateTypeParmDecl::Create(\n          S.Context, S.Context.getTranslationUnitDecl(),\n          /*KeyLoc=*/D.getDeclSpec().getTypeSpecTypeLoc(),\n          /*NameLoc=*/D.getIdentifierLoc(),\n          TemplateParameterDepth, AutoParameterPosition,\n          S.InventAbbreviatedTemplateParameterTypeName(\n              D.getIdentifier(), AutoParameterPosition), false,\n          IsParameterPack, /*HasTypeConstraint=*/Auto->isConstrained());\n  InventedTemplateParam->setImplicit();\n  Info.TemplateParams.push_back(InventedTemplateParam);\n\n  // Attach type constraints to the new parameter.\n  if (Auto->isConstrained()) {\n    if (TrailingTSI) {\n      // The 'auto' appears in a trailing return type we've already built;\n      // extract its type constraints to attach to the template parameter.\n      AutoTypeLoc AutoLoc = TrailingTSI->getTypeLoc().getContainedAutoTypeLoc();\n      TemplateArgumentListInfo TAL(AutoLoc.getLAngleLoc(), AutoLoc.getRAngleLoc());\n      for (unsigned Idx = 0; Idx < AutoLoc.getNumArgs(); ++Idx)\n        TAL.addArgument(AutoLoc.getArgLoc(Idx));\n\n      S.AttachTypeConstraint(AutoLoc.getNestedNameSpecifierLoc(),\n                             AutoLoc.getConceptNameInfo(),\n                             AutoLoc.getNamedConcept(),\n                             AutoLoc.hasExplicitTemplateArgs() ? &TAL : nullptr,\n                             InventedTemplateParam, D.getEllipsisLoc());\n    } else {\n      // The 'auto' appears in the decl-specifiers; we've not finished forming\n      // TypeSourceInfo for it yet.\n      TemplateIdAnnotation *TemplateId = D.getDeclSpec().getRepAsTemplateId();\n      TemplateArgumentListInfo TemplateArgsInfo;\n      if (TemplateId->LAngleLoc.isValid()) {\n        ASTTemplateArgsPtr TemplateArgsPtr(TemplateId->getTemplateArgs(),\n                                           TemplateId->NumArgs);\n        S.translateTemplateArguments(TemplateArgsPtr, TemplateArgsInfo);\n      }\n      S.AttachTypeConstraint(\n          D.getDeclSpec().getTypeSpecScope().getWithLocInContext(S.Context),\n          DeclarationNameInfo(DeclarationName(TemplateId->Name),\n                              TemplateId->TemplateNameLoc),\n          cast<ConceptDecl>(TemplateId->Template.get().getAsTemplateDecl()),\n          TemplateId->LAngleLoc.isValid() ? &TemplateArgsInfo : nullptr,\n          InventedTemplateParam, D.getEllipsisLoc());\n    }\n  }\n\n  // Replace the 'auto' in the function parameter with this invented\n  // template type parameter.\n  // FIXME: Retain some type sugar to indicate that this was written\n  //  as 'auto'?\n  QualType Replacement(InventedTemplateParam->getTypeForDecl(), 0);\n  QualType NewT = state.ReplaceAutoType(T, Replacement);\n  TypeSourceInfo *NewTSI =\n      TrailingTSI ? S.ReplaceAutoTypeSourceInfo(TrailingTSI, Replacement)\n                  : nullptr;\n  return {NewT, NewTSI};\n}\n\nstatic TypeSourceInfo *\nGetTypeSourceInfoForDeclarator(TypeProcessingState &State,\n                               QualType T, TypeSourceInfo *ReturnTypeInfo);\n\nstatic QualType GetDeclSpecTypeForDeclarator(TypeProcessingState &state,\n                                             TypeSourceInfo *&ReturnTypeInfo) {\n  Sema &SemaRef = state.getSema();\n  Declarator &D = state.getDeclarator();\n  QualType T;\n  ReturnTypeInfo = nullptr;\n\n  // The TagDecl owned by the DeclSpec.\n  TagDecl *OwnedTagDecl = nullptr;\n\n  switch (D.getName().getKind()) {\n  case UnqualifiedIdKind::IK_ImplicitSelfParam:\n  case UnqualifiedIdKind::IK_OperatorFunctionId:\n  case UnqualifiedIdKind::IK_Identifier:\n  case UnqualifiedIdKind::IK_LiteralOperatorId:\n  case UnqualifiedIdKind::IK_TemplateId:\n    T = ConvertDeclSpecToType(state);\n\n    if (!D.isInvalidType() && D.getDeclSpec().isTypeSpecOwned()) {\n      OwnedTagDecl = cast<TagDecl>(D.getDeclSpec().getRepAsDecl());\n      // Owned declaration is embedded in declarator.\n      OwnedTagDecl->setEmbeddedInDeclarator(true);\n    }\n    break;\n\n  case UnqualifiedIdKind::IK_ConstructorName:\n  case UnqualifiedIdKind::IK_ConstructorTemplateId:\n  case UnqualifiedIdKind::IK_DestructorName:\n    // Constructors and destructors don't have return types. Use\n    // \"void\" instead.\n    T = SemaRef.Context.VoidTy;\n    processTypeAttrs(state, T, TAL_DeclSpec,\n                     D.getMutableDeclSpec().getAttributes());\n    break;\n\n  case UnqualifiedIdKind::IK_DeductionGuideName:\n    // Deduction guides have a trailing return type and no type in their\n    // decl-specifier sequence. Use a placeholder return type for now.\n    T = SemaRef.Context.DependentTy;\n    break;\n\n  case UnqualifiedIdKind::IK_ConversionFunctionId:\n    // The result type of a conversion function is the type that it\n    // converts to.\n    T = SemaRef.GetTypeFromParser(D.getName().ConversionFunctionId,\n                                  &ReturnTypeInfo);\n    break;\n  }\n\n  if (!D.getAttributes().empty())\n    distributeTypeAttrsFromDeclarator(state, T);\n\n  // Find the deduced type in this type. Look in the trailing return type if we\n  // have one, otherwise in the DeclSpec type.\n  // FIXME: The standard wording doesn't currently describe this.\n  DeducedType *Deduced = T->getContainedDeducedType();\n  bool DeducedIsTrailingReturnType = false;\n  if (Deduced && isa<AutoType>(Deduced) && D.hasTrailingReturnType()) {\n    QualType T = SemaRef.GetTypeFromParser(D.getTrailingReturnType());\n    Deduced = T.isNull() ? nullptr : T->getContainedDeducedType();\n    DeducedIsTrailingReturnType = true;\n  }\n\n  // C++11 [dcl.spec.auto]p5: reject 'auto' if it is not in an allowed context.\n  if (Deduced) {\n    AutoType *Auto = dyn_cast<AutoType>(Deduced);\n    int Error = -1;\n\n    // Is this a 'auto' or 'decltype(auto)' type (as opposed to __auto_type or\n    // class template argument deduction)?\n    bool IsCXXAutoType =\n        (Auto && Auto->getKeyword() != AutoTypeKeyword::GNUAutoType);\n    bool IsDeducedReturnType = false;\n\n    switch (D.getContext()) {\n    case DeclaratorContext::LambdaExpr:\n      // Declared return type of a lambda-declarator is implicit and is always\n      // 'auto'.\n      break;\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n      Error = 0;\n      break;\n    case DeclaratorContext::RequiresExpr:\n      Error = 22;\n      break;\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter: {\n      InventedTemplateParameterInfo *Info = nullptr;\n      if (D.getContext() == DeclaratorContext::Prototype) {\n        // With concepts we allow 'auto' in function parameters.\n        if (!SemaRef.getLangOpts().CPlusPlus20 || !Auto ||\n            Auto->getKeyword() != AutoTypeKeyword::Auto) {\n          Error = 0;\n          break;\n        } else if (!SemaRef.getCurScope()->isFunctionDeclarationScope()) {\n          Error = 21;\n          break;\n        }\n\n        Info = &SemaRef.InventedParameterInfos.back();\n      } else {\n        // In C++14, generic lambdas allow 'auto' in their parameters.\n        if (!SemaRef.getLangOpts().CPlusPlus14 || !Auto ||\n            Auto->getKeyword() != AutoTypeKeyword::Auto) {\n          Error = 16;\n          break;\n        }\n        Info = SemaRef.getCurLambda();\n        assert(Info && \"No LambdaScopeInfo on the stack!\");\n      }\n\n      // We'll deal with inventing template parameters for 'auto' in trailing\n      // return types when we pick up the trailing return type when processing\n      // the function chunk.\n      if (!DeducedIsTrailingReturnType)\n        T = InventTemplateParameter(state, T, nullptr, Auto, *Info).first;\n      break;\n    }\n    case DeclaratorContext::Member: {\n      if (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_static ||\n          D.isFunctionDeclarator())\n        break;\n      bool Cxx = SemaRef.getLangOpts().CPlusPlus;\n      if (isa<ObjCContainerDecl>(SemaRef.CurContext)) {\n        Error = 6; // Interface member.\n      } else {\n        switch (cast<TagDecl>(SemaRef.CurContext)->getTagKind()) {\n        case TTK_Enum: llvm_unreachable(\"unhandled tag kind\");\n        case TTK_Struct: Error = Cxx ? 1 : 2; /* Struct member */ break;\n        case TTK_Union:  Error = Cxx ? 3 : 4; /* Union member */ break;\n        case TTK_Class:  Error = 5; /* Class member */ break;\n        case TTK_Interface: Error = 6; /* Interface member */ break;\n        }\n      }\n      if (D.getDeclSpec().isFriendSpecified())\n        Error = 20; // Friend type\n      break;\n    }\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n      Error = 7; // Exception declaration\n      break;\n    case DeclaratorContext::TemplateParam:\n      if (isa<DeducedTemplateSpecializationType>(Deduced) &&\n          !SemaRef.getLangOpts().CPlusPlus20)\n        Error = 19; // Template parameter (until C++20)\n      else if (!SemaRef.getLangOpts().CPlusPlus17)\n        Error = 8; // Template parameter (until C++17)\n      break;\n    case DeclaratorContext::BlockLiteral:\n      Error = 9; // Block literal\n      break;\n    case DeclaratorContext::TemplateArg:\n      // Within a template argument list, a deduced template specialization\n      // type will be reinterpreted as a template template argument.\n      if (isa<DeducedTemplateSpecializationType>(Deduced) &&\n          !D.getNumTypeObjects() &&\n          D.getDeclSpec().getParsedSpecifiers() == DeclSpec::PQ_TypeSpecifier)\n        break;\n      LLVM_FALLTHROUGH;\n    case DeclaratorContext::TemplateTypeArg:\n      Error = 10; // Template type argument\n      break;\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n      Error = 12; // Type alias\n      break;\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      if (!SemaRef.getLangOpts().CPlusPlus14 || !IsCXXAutoType)\n        Error = 13; // Function return type\n      IsDeducedReturnType = true;\n      break;\n    case DeclaratorContext::ConversionId:\n      if (!SemaRef.getLangOpts().CPlusPlus14 || !IsCXXAutoType)\n        Error = 14; // conversion-type-id\n      IsDeducedReturnType = true;\n      break;\n    case DeclaratorContext::FunctionalCast:\n      if (isa<DeducedTemplateSpecializationType>(Deduced))\n        break;\n      LLVM_FALLTHROUGH;\n    case DeclaratorContext::TypeName:\n      Error = 15; // Generic\n      break;\n    case DeclaratorContext::File:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      // FIXME: P0091R3 (erroneously) does not permit class template argument\n      // deduction in conditions, for-init-statements, and other declarations\n      // that are not simple-declarations.\n      break;\n    case DeclaratorContext::CXXNew:\n      // FIXME: P0091R3 does not permit class template argument deduction here,\n      // but we follow GCC and allow it anyway.\n      if (!IsCXXAutoType && !isa<DeducedTemplateSpecializationType>(Deduced))\n        Error = 17; // 'new' type\n      break;\n    case DeclaratorContext::KNRTypeList:\n      Error = 18; // K&R function parameter\n      break;\n    }\n\n    if (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      Error = 11;\n\n    // In Objective-C it is an error to use 'auto' on a function declarator\n    // (and everywhere for '__auto_type').\n    if (D.isFunctionDeclarator() &&\n        (!SemaRef.getLangOpts().CPlusPlus11 || !IsCXXAutoType))\n      Error = 13;\n\n    SourceRange AutoRange = D.getDeclSpec().getTypeSpecTypeLoc();\n    if (D.getName().getKind() == UnqualifiedIdKind::IK_ConversionFunctionId)\n      AutoRange = D.getName().getSourceRange();\n\n    if (Error != -1) {\n      unsigned Kind;\n      if (Auto) {\n        switch (Auto->getKeyword()) {\n        case AutoTypeKeyword::Auto: Kind = 0; break;\n        case AutoTypeKeyword::DecltypeAuto: Kind = 1; break;\n        case AutoTypeKeyword::GNUAutoType: Kind = 2; break;\n        }\n      } else {\n        assert(isa<DeducedTemplateSpecializationType>(Deduced) &&\n               \"unknown auto type\");\n        Kind = 3;\n      }\n\n      auto *DTST = dyn_cast<DeducedTemplateSpecializationType>(Deduced);\n      TemplateName TN = DTST ? DTST->getTemplateName() : TemplateName();\n\n      SemaRef.Diag(AutoRange.getBegin(), diag::err_auto_not_allowed)\n        << Kind << Error << (int)SemaRef.getTemplateNameKindForDiagnostics(TN)\n        << QualType(Deduced, 0) << AutoRange;\n      if (auto *TD = TN.getAsTemplateDecl())\n        SemaRef.Diag(TD->getLocation(), diag::note_template_decl_here);\n\n      T = SemaRef.Context.IntTy;\n      D.setInvalidType(true);\n    } else if (Auto && D.getContext() != DeclaratorContext::LambdaExpr) {\n      // If there was a trailing return type, we already got\n      // warn_cxx98_compat_trailing_return_type in the parser.\n      SemaRef.Diag(AutoRange.getBegin(),\n                   D.getContext() == DeclaratorContext::LambdaExprParameter\n                       ? diag::warn_cxx11_compat_generic_lambda\n                   : IsDeducedReturnType\n                       ? diag::warn_cxx11_compat_deduced_return_type\n                       : diag::warn_cxx98_compat_auto_type_specifier)\n          << AutoRange;\n    }\n  }\n\n  if (SemaRef.getLangOpts().CPlusPlus &&\n      OwnedTagDecl && OwnedTagDecl->isCompleteDefinition()) {\n    // Check the contexts where C++ forbids the declaration of a new class\n    // or enumeration in a type-specifier-seq.\n    unsigned DiagID = 0;\n    switch (D.getContext()) {\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      // Class and enumeration definitions are syntactically not allowed in\n      // trailing return types.\n      llvm_unreachable(\"parser should not have allowed this\");\n      break;\n    case DeclaratorContext::File:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n      // C++11 [dcl.type]p3:\n      //   A type-specifier-seq shall not define a class or enumeration unless\n      //   it appears in the type-id of an alias-declaration (7.1.3) that is not\n      //   the declaration of a template-declaration.\n    case DeclaratorContext::AliasDecl:\n      break;\n    case DeclaratorContext::AliasTemplate:\n      DiagID = diag::err_type_defined_in_alias_template;\n      break;\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n      DiagID = diag::err_type_defined_in_type_specifier;\n      break;\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::RequiresExpr:\n      // C++ [dcl.fct]p6:\n      //   Types shall not be defined in return or parameter types.\n      DiagID = diag::err_type_defined_in_param_type;\n      break;\n    case DeclaratorContext::Condition:\n      // C++ 6.4p2:\n      // The type-specifier-seq shall not contain typedef and shall not declare\n      // a new class or enumeration.\n      DiagID = diag::err_type_defined_in_condition;\n      break;\n    }\n\n    if (DiagID != 0) {\n      SemaRef.Diag(OwnedTagDecl->getLocation(), DiagID)\n          << SemaRef.Context.getTypeDeclType(OwnedTagDecl);\n      D.setInvalidType(true);\n    }\n  }\n\n  assert(!T.isNull() && \"This function should not return a null type\");\n  return T;\n}\n\n/// Produce an appropriate diagnostic for an ambiguity between a function\n/// declarator and a C++ direct-initializer.\nstatic void warnAboutAmbiguousFunction(Sema &S, Declarator &D,\n                                       DeclaratorChunk &DeclType, QualType RT) {\n  const DeclaratorChunk::FunctionTypeInfo &FTI = DeclType.Fun;\n  assert(FTI.isAmbiguous && \"no direct-initializer / function ambiguity\");\n\n  // If the return type is void there is no ambiguity.\n  if (RT->isVoidType())\n    return;\n\n  // An initializer for a non-class type can have at most one argument.\n  if (!RT->isRecordType() && FTI.NumParams > 1)\n    return;\n\n  // An initializer for a reference must have exactly one argument.\n  if (RT->isReferenceType() && FTI.NumParams != 1)\n    return;\n\n  // Only warn if this declarator is declaring a function at block scope, and\n  // doesn't have a storage class (such as 'extern') specified.\n  if (!D.isFunctionDeclarator() ||\n      D.getFunctionDefinitionKind() != FunctionDefinitionKind::Declaration ||\n      !S.CurContext->isFunctionOrMethod() ||\n      D.getDeclSpec().getStorageClassSpec() != DeclSpec::SCS_unspecified)\n    return;\n\n  // Inside a condition, a direct initializer is not permitted. We allow one to\n  // be parsed in order to give better diagnostics in condition parsing.\n  if (D.getContext() == DeclaratorContext::Condition)\n    return;\n\n  SourceRange ParenRange(DeclType.Loc, DeclType.EndLoc);\n\n  S.Diag(DeclType.Loc,\n         FTI.NumParams ? diag::warn_parens_disambiguated_as_function_declaration\n                       : diag::warn_empty_parens_are_function_decl)\n      << ParenRange;\n\n  // If the declaration looks like:\n  //   T var1,\n  //   f();\n  // and name lookup finds a function named 'f', then the ',' was\n  // probably intended to be a ';'.\n  if (!D.isFirstDeclarator() && D.getIdentifier()) {\n    FullSourceLoc Comma(D.getCommaLoc(), S.SourceMgr);\n    FullSourceLoc Name(D.getIdentifierLoc(), S.SourceMgr);\n    if (Comma.getFileID() != Name.getFileID() ||\n        Comma.getSpellingLineNumber() != Name.getSpellingLineNumber()) {\n      LookupResult Result(S, D.getIdentifier(), SourceLocation(),\n                          Sema::LookupOrdinaryName);\n      if (S.LookupName(Result, S.getCurScope()))\n        S.Diag(D.getCommaLoc(), diag::note_empty_parens_function_call)\n          << FixItHint::CreateReplacement(D.getCommaLoc(), \";\")\n          << D.getIdentifier();\n      Result.suppressDiagnostics();\n    }\n  }\n\n  if (FTI.NumParams > 0) {\n    // For a declaration with parameters, eg. \"T var(T());\", suggest adding\n    // parens around the first parameter to turn the declaration into a\n    // variable declaration.\n    SourceRange Range = FTI.Params[0].Param->getSourceRange();\n    SourceLocation B = Range.getBegin();\n    SourceLocation E = S.getLocForEndOfToken(Range.getEnd());\n    // FIXME: Maybe we should suggest adding braces instead of parens\n    // in C++11 for classes that don't have an initializer_list constructor.\n    S.Diag(B, diag::note_additional_parens_for_variable_declaration)\n      << FixItHint::CreateInsertion(B, \"(\")\n      << FixItHint::CreateInsertion(E, \")\");\n  } else {\n    // For a declaration without parameters, eg. \"T var();\", suggest replacing\n    // the parens with an initializer to turn the declaration into a variable\n    // declaration.\n    const CXXRecordDecl *RD = RT->getAsCXXRecordDecl();\n\n    // Empty parens mean value-initialization, and no parens mean\n    // default initialization. These are equivalent if the default\n    // constructor is user-provided or if zero-initialization is a\n    // no-op.\n    if (RD && RD->hasDefinition() &&\n        (RD->isEmpty() || RD->hasUserProvidedDefaultConstructor()))\n      S.Diag(DeclType.Loc, diag::note_empty_parens_default_ctor)\n        << FixItHint::CreateRemoval(ParenRange);\n    else {\n      std::string Init =\n          S.getFixItZeroInitializerForType(RT, ParenRange.getBegin());\n      if (Init.empty() && S.LangOpts.CPlusPlus11)\n        Init = \"{}\";\n      if (!Init.empty())\n        S.Diag(DeclType.Loc, diag::note_empty_parens_zero_initialize)\n          << FixItHint::CreateReplacement(ParenRange, Init);\n    }\n  }\n}\n\n/// Produce an appropriate diagnostic for a declarator with top-level\n/// parentheses.\nstatic void warnAboutRedundantParens(Sema &S, Declarator &D, QualType T) {\n  DeclaratorChunk &Paren = D.getTypeObject(D.getNumTypeObjects() - 1);\n  assert(Paren.Kind == DeclaratorChunk::Paren &&\n         \"do not have redundant top-level parentheses\");\n\n  // This is a syntactic check; we're not interested in cases that arise\n  // during template instantiation.\n  if (S.inTemplateInstantiation())\n    return;\n\n  // Check whether this could be intended to be a construction of a temporary\n  // object in C++ via a function-style cast.\n  bool CouldBeTemporaryObject =\n      S.getLangOpts().CPlusPlus && D.isExpressionContext() &&\n      !D.isInvalidType() && D.getIdentifier() &&\n      D.getDeclSpec().getParsedSpecifiers() == DeclSpec::PQ_TypeSpecifier &&\n      (T->isRecordType() || T->isDependentType()) &&\n      D.getDeclSpec().getTypeQualifiers() == 0 && D.isFirstDeclarator();\n\n  bool StartsWithDeclaratorId = true;\n  for (auto &C : D.type_objects()) {\n    switch (C.Kind) {\n    case DeclaratorChunk::Paren:\n      if (&C == &Paren)\n        continue;\n      LLVM_FALLTHROUGH;\n    case DeclaratorChunk::Pointer:\n      StartsWithDeclaratorId = false;\n      continue;\n\n    case DeclaratorChunk::Array:\n      if (!C.Arr.NumElts)\n        CouldBeTemporaryObject = false;\n      continue;\n\n    case DeclaratorChunk::Reference:\n      // FIXME: Suppress the warning here if there is no initializer; we're\n      // going to give an error anyway.\n      // We assume that something like 'T (&x) = y;' is highly likely to not\n      // be intended to be a temporary object.\n      CouldBeTemporaryObject = false;\n      StartsWithDeclaratorId = false;\n      continue;\n\n    case DeclaratorChunk::Function:\n      // In a new-type-id, function chunks require parentheses.\n      if (D.getContext() == DeclaratorContext::CXXNew)\n        return;\n      // FIXME: \"A(f())\" deserves a vexing-parse warning, not just a\n      // redundant-parens warning, but we don't know whether the function\n      // chunk was syntactically valid as an expression here.\n      CouldBeTemporaryObject = false;\n      continue;\n\n    case DeclaratorChunk::BlockPointer:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Pipe:\n      // These cannot appear in expressions.\n      CouldBeTemporaryObject = false;\n      StartsWithDeclaratorId = false;\n      continue;\n    }\n  }\n\n  // FIXME: If there is an initializer, assume that this is not intended to be\n  // a construction of a temporary object.\n\n  // Check whether the name has already been declared; if not, this is not a\n  // function-style cast.\n  if (CouldBeTemporaryObject) {\n    LookupResult Result(S, D.getIdentifier(), SourceLocation(),\n                        Sema::LookupOrdinaryName);\n    if (!S.LookupName(Result, S.getCurScope()))\n      CouldBeTemporaryObject = false;\n    Result.suppressDiagnostics();\n  }\n\n  SourceRange ParenRange(Paren.Loc, Paren.EndLoc);\n\n  if (!CouldBeTemporaryObject) {\n    // If we have A (::B), the parentheses affect the meaning of the program.\n    // Suppress the warning in that case. Don't bother looking at the DeclSpec\n    // here: even (e.g.) \"int ::x\" is visually ambiguous even though it's\n    // formally unambiguous.\n    if (StartsWithDeclaratorId && D.getCXXScopeSpec().isValid()) {\n      for (NestedNameSpecifier *NNS = D.getCXXScopeSpec().getScopeRep(); NNS;\n           NNS = NNS->getPrefix()) {\n        if (NNS->getKind() == NestedNameSpecifier::Global)\n          return;\n      }\n    }\n\n    S.Diag(Paren.Loc, diag::warn_redundant_parens_around_declarator)\n        << ParenRange << FixItHint::CreateRemoval(Paren.Loc)\n        << FixItHint::CreateRemoval(Paren.EndLoc);\n    return;\n  }\n\n  S.Diag(Paren.Loc, diag::warn_parens_disambiguated_as_variable_declaration)\n      << ParenRange << D.getIdentifier();\n  auto *RD = T->getAsCXXRecordDecl();\n  if (!RD || !RD->hasDefinition() || RD->hasNonTrivialDestructor())\n    S.Diag(Paren.Loc, diag::note_raii_guard_add_name)\n        << FixItHint::CreateInsertion(Paren.Loc, \" varname\") << T\n        << D.getIdentifier();\n  // FIXME: A cast to void is probably a better suggestion in cases where it's\n  // valid (when there is no initializer and we're not in a condition).\n  S.Diag(D.getBeginLoc(), diag::note_function_style_cast_add_parentheses)\n      << FixItHint::CreateInsertion(D.getBeginLoc(), \"(\")\n      << FixItHint::CreateInsertion(S.getLocForEndOfToken(D.getEndLoc()), \")\");\n  S.Diag(Paren.Loc, diag::note_remove_parens_for_variable_declaration)\n      << FixItHint::CreateRemoval(Paren.Loc)\n      << FixItHint::CreateRemoval(Paren.EndLoc);\n}\n\n/// Helper for figuring out the default CC for a function declarator type.  If\n/// this is the outermost chunk, then we can determine the CC from the\n/// declarator context.  If not, then this could be either a member function\n/// type or normal function type.\nstatic CallingConv getCCForDeclaratorChunk(\n    Sema &S, Declarator &D, const ParsedAttributesView &AttrList,\n    const DeclaratorChunk::FunctionTypeInfo &FTI, unsigned ChunkIndex) {\n  assert(D.getTypeObject(ChunkIndex).Kind == DeclaratorChunk::Function);\n\n  // Check for an explicit CC attribute.\n  for (const ParsedAttr &AL : AttrList) {\n    switch (AL.getKind()) {\n    CALLING_CONV_ATTRS_CASELIST : {\n      // Ignore attributes that don't validate or can't apply to the\n      // function type.  We'll diagnose the failure to apply them in\n      // handleFunctionTypeAttr.\n      CallingConv CC;\n      if (!S.CheckCallingConvAttr(AL, CC) &&\n          (!FTI.isVariadic || supportsVariadicCall(CC))) {\n        return CC;\n      }\n      break;\n    }\n\n    default:\n      break;\n    }\n  }\n\n  bool IsCXXInstanceMethod = false;\n\n  if (S.getLangOpts().CPlusPlus) {\n    // Look inwards through parentheses to see if this chunk will form a\n    // member pointer type or if we're the declarator.  Any type attributes\n    // between here and there will override the CC we choose here.\n    unsigned I = ChunkIndex;\n    bool FoundNonParen = false;\n    while (I && !FoundNonParen) {\n      --I;\n      if (D.getTypeObject(I).Kind != DeclaratorChunk::Paren)\n        FoundNonParen = true;\n    }\n\n    if (FoundNonParen) {\n      // If we're not the declarator, we're a regular function type unless we're\n      // in a member pointer.\n      IsCXXInstanceMethod =\n          D.getTypeObject(I).Kind == DeclaratorChunk::MemberPointer;\n    } else if (D.getContext() == DeclaratorContext::LambdaExpr) {\n      // This can only be a call operator for a lambda, which is an instance\n      // method.\n      IsCXXInstanceMethod = true;\n    } else {\n      // We're the innermost decl chunk, so must be a function declarator.\n      assert(D.isFunctionDeclarator());\n\n      // If we're inside a record, we're declaring a method, but it could be\n      // explicitly or implicitly static.\n      IsCXXInstanceMethod =\n          D.isFirstDeclarationOfMember() &&\n          D.getDeclSpec().getStorageClassSpec() != DeclSpec::SCS_typedef &&\n          !D.isStaticMember();\n    }\n  }\n\n  CallingConv CC = S.Context.getDefaultCallingConvention(FTI.isVariadic,\n                                                         IsCXXInstanceMethod);\n\n  // Attribute AT_OpenCLKernel affects the calling convention for SPIR\n  // and AMDGPU targets, hence it cannot be treated as a calling\n  // convention attribute. This is the simplest place to infer\n  // calling convention for OpenCL kernels.\n  if (S.getLangOpts().OpenCL) {\n    for (const ParsedAttr &AL : D.getDeclSpec().getAttributes()) {\n      if (AL.getKind() == ParsedAttr::AT_OpenCLKernel) {\n        CC = CC_OpenCLKernel;\n        break;\n      }\n    }\n  }\n\n  return CC;\n}\n\nnamespace {\n  /// A simple notion of pointer kinds, which matches up with the various\n  /// pointer declarators.\n  enum class SimplePointerKind {\n    Pointer,\n    BlockPointer,\n    MemberPointer,\n    Array,\n  };\n} // end anonymous namespace\n\nIdentifierInfo *Sema::getNullabilityKeyword(NullabilityKind nullability) {\n  switch (nullability) {\n  case NullabilityKind::NonNull:\n    if (!Ident__Nonnull)\n      Ident__Nonnull = PP.getIdentifierInfo(\"_Nonnull\");\n    return Ident__Nonnull;\n\n  case NullabilityKind::Nullable:\n    if (!Ident__Nullable)\n      Ident__Nullable = PP.getIdentifierInfo(\"_Nullable\");\n    return Ident__Nullable;\n\n  case NullabilityKind::NullableResult:\n    if (!Ident__Nullable_result)\n      Ident__Nullable_result = PP.getIdentifierInfo(\"_Nullable_result\");\n    return Ident__Nullable_result;\n\n  case NullabilityKind::Unspecified:\n    if (!Ident__Null_unspecified)\n      Ident__Null_unspecified = PP.getIdentifierInfo(\"_Null_unspecified\");\n    return Ident__Null_unspecified;\n  }\n  llvm_unreachable(\"Unknown nullability kind.\");\n}\n\n/// Retrieve the identifier \"NSError\".\nIdentifierInfo *Sema::getNSErrorIdent() {\n  if (!Ident_NSError)\n    Ident_NSError = PP.getIdentifierInfo(\"NSError\");\n\n  return Ident_NSError;\n}\n\n/// Check whether there is a nullability attribute of any kind in the given\n/// attribute list.\nstatic bool hasNullabilityAttr(const ParsedAttributesView &attrs) {\n  for (const ParsedAttr &AL : attrs) {\n    if (AL.getKind() == ParsedAttr::AT_TypeNonNull ||\n        AL.getKind() == ParsedAttr::AT_TypeNullable ||\n        AL.getKind() == ParsedAttr::AT_TypeNullableResult ||\n        AL.getKind() == ParsedAttr::AT_TypeNullUnspecified)\n      return true;\n  }\n\n  return false;\n}\n\nnamespace {\n  /// Describes the kind of a pointer a declarator describes.\n  enum class PointerDeclaratorKind {\n    // Not a pointer.\n    NonPointer,\n    // Single-level pointer.\n    SingleLevelPointer,\n    // Multi-level pointer (of any pointer kind).\n    MultiLevelPointer,\n    // CFFooRef*\n    MaybePointerToCFRef,\n    // CFErrorRef*\n    CFErrorRefPointer,\n    // NSError**\n    NSErrorPointerPointer,\n  };\n\n  /// Describes a declarator chunk wrapping a pointer that marks inference as\n  /// unexpected.\n  // These values must be kept in sync with diagnostics.\n  enum class PointerWrappingDeclaratorKind {\n    /// Pointer is top-level.\n    None = -1,\n    /// Pointer is an array element.\n    Array = 0,\n    /// Pointer is the referent type of a C++ reference.\n    Reference = 1\n  };\n} // end anonymous namespace\n\n/// Classify the given declarator, whose type-specified is \\c type, based on\n/// what kind of pointer it refers to.\n///\n/// This is used to determine the default nullability.\nstatic PointerDeclaratorKind\nclassifyPointerDeclarator(Sema &S, QualType type, Declarator &declarator,\n                          PointerWrappingDeclaratorKind &wrappingKind) {\n  unsigned numNormalPointers = 0;\n\n  // For any dependent type, we consider it a non-pointer.\n  if (type->isDependentType())\n    return PointerDeclaratorKind::NonPointer;\n\n  // Look through the declarator chunks to identify pointers.\n  for (unsigned i = 0, n = declarator.getNumTypeObjects(); i != n; ++i) {\n    DeclaratorChunk &chunk = declarator.getTypeObject(i);\n    switch (chunk.Kind) {\n    case DeclaratorChunk::Array:\n      if (numNormalPointers == 0)\n        wrappingKind = PointerWrappingDeclaratorKind::Array;\n      break;\n\n    case DeclaratorChunk::Function:\n    case DeclaratorChunk::Pipe:\n      break;\n\n    case DeclaratorChunk::BlockPointer:\n    case DeclaratorChunk::MemberPointer:\n      return numNormalPointers > 0 ? PointerDeclaratorKind::MultiLevelPointer\n                                   : PointerDeclaratorKind::SingleLevelPointer;\n\n    case DeclaratorChunk::Paren:\n      break;\n\n    case DeclaratorChunk::Reference:\n      if (numNormalPointers == 0)\n        wrappingKind = PointerWrappingDeclaratorKind::Reference;\n      break;\n\n    case DeclaratorChunk::Pointer:\n      ++numNormalPointers;\n      if (numNormalPointers > 2)\n        return PointerDeclaratorKind::MultiLevelPointer;\n      break;\n    }\n  }\n\n  // Then, dig into the type specifier itself.\n  unsigned numTypeSpecifierPointers = 0;\n  do {\n    // Decompose normal pointers.\n    if (auto ptrType = type->getAs<PointerType>()) {\n      ++numNormalPointers;\n\n      if (numNormalPointers > 2)\n        return PointerDeclaratorKind::MultiLevelPointer;\n\n      type = ptrType->getPointeeType();\n      ++numTypeSpecifierPointers;\n      continue;\n    }\n\n    // Decompose block pointers.\n    if (type->getAs<BlockPointerType>()) {\n      return numNormalPointers > 0 ? PointerDeclaratorKind::MultiLevelPointer\n                                   : PointerDeclaratorKind::SingleLevelPointer;\n    }\n\n    // Decompose member pointers.\n    if (type->getAs<MemberPointerType>()) {\n      return numNormalPointers > 0 ? PointerDeclaratorKind::MultiLevelPointer\n                                   : PointerDeclaratorKind::SingleLevelPointer;\n    }\n\n    // Look at Objective-C object pointers.\n    if (auto objcObjectPtr = type->getAs<ObjCObjectPointerType>()) {\n      ++numNormalPointers;\n      ++numTypeSpecifierPointers;\n\n      // If this is NSError**, report that.\n      if (auto objcClassDecl = objcObjectPtr->getInterfaceDecl()) {\n        if (objcClassDecl->getIdentifier() == S.getNSErrorIdent() &&\n            numNormalPointers == 2 && numTypeSpecifierPointers < 2) {\n          return PointerDeclaratorKind::NSErrorPointerPointer;\n        }\n      }\n\n      break;\n    }\n\n    // Look at Objective-C class types.\n    if (auto objcClass = type->getAs<ObjCInterfaceType>()) {\n      if (objcClass->getInterface()->getIdentifier() == S.getNSErrorIdent()) {\n        if (numNormalPointers == 2 && numTypeSpecifierPointers < 2)\n          return PointerDeclaratorKind::NSErrorPointerPointer;\n      }\n\n      break;\n    }\n\n    // If at this point we haven't seen a pointer, we won't see one.\n    if (numNormalPointers == 0)\n      return PointerDeclaratorKind::NonPointer;\n\n    if (auto recordType = type->getAs<RecordType>()) {\n      RecordDecl *recordDecl = recordType->getDecl();\n\n      // If this is CFErrorRef*, report it as such.\n      if (numNormalPointers == 2 && numTypeSpecifierPointers < 2 &&\n          S.isCFError(recordDecl)) {\n        return PointerDeclaratorKind::CFErrorRefPointer;\n      }\n      break;\n    }\n\n    break;\n  } while (true);\n\n  switch (numNormalPointers) {\n  case 0:\n    return PointerDeclaratorKind::NonPointer;\n\n  case 1:\n    return PointerDeclaratorKind::SingleLevelPointer;\n\n  case 2:\n    return PointerDeclaratorKind::MaybePointerToCFRef;\n\n  default:\n    return PointerDeclaratorKind::MultiLevelPointer;\n  }\n}\n\nbool Sema::isCFError(RecordDecl *RD) {\n  // If we already know about CFError, test it directly.\n  if (CFError)\n    return CFError == RD;\n\n  // Check whether this is CFError, which we identify based on its bridge to\n  // NSError. CFErrorRef used to be declared with \"objc_bridge\" but is now\n  // declared with \"objc_bridge_mutable\", so look for either one of the two\n  // attributes.\n  if (RD->getTagKind() == TTK_Struct) {\n    IdentifierInfo *bridgedType = nullptr;\n    if (auto bridgeAttr = RD->getAttr<ObjCBridgeAttr>())\n      bridgedType = bridgeAttr->getBridgedType();\n    else if (auto bridgeAttr = RD->getAttr<ObjCBridgeMutableAttr>())\n      bridgedType = bridgeAttr->getBridgedType();\n\n    if (bridgedType == getNSErrorIdent()) {\n      CFError = RD;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nstatic FileID getNullabilityCompletenessCheckFileID(Sema &S,\n                                                    SourceLocation loc) {\n  // If we're anywhere in a function, method, or closure context, don't perform\n  // completeness checks.\n  for (DeclContext *ctx = S.CurContext; ctx; ctx = ctx->getParent()) {\n    if (ctx->isFunctionOrMethod())\n      return FileID();\n\n    if (ctx->isFileContext())\n      break;\n  }\n\n  // We only care about the expansion location.\n  loc = S.SourceMgr.getExpansionLoc(loc);\n  FileID file = S.SourceMgr.getFileID(loc);\n  if (file.isInvalid())\n    return FileID();\n\n  // Retrieve file information.\n  bool invalid = false;\n  const SrcMgr::SLocEntry &sloc = S.SourceMgr.getSLocEntry(file, &invalid);\n  if (invalid || !sloc.isFile())\n    return FileID();\n\n  // We don't want to perform completeness checks on the main file or in\n  // system headers.\n  const SrcMgr::FileInfo &fileInfo = sloc.getFile();\n  if (fileInfo.getIncludeLoc().isInvalid())\n    return FileID();\n  if (fileInfo.getFileCharacteristic() != SrcMgr::C_User &&\n      S.Diags.getSuppressSystemWarnings()) {\n    return FileID();\n  }\n\n  return file;\n}\n\n/// Creates a fix-it to insert a C-style nullability keyword at \\p pointerLoc,\n/// taking into account whitespace before and after.\ntemplate <typename DiagBuilderT>\nstatic void fixItNullability(Sema &S, DiagBuilderT &Diag,\n                             SourceLocation PointerLoc,\n                             NullabilityKind Nullability) {\n  assert(PointerLoc.isValid());\n  if (PointerLoc.isMacroID())\n    return;\n\n  SourceLocation FixItLoc = S.getLocForEndOfToken(PointerLoc);\n  if (!FixItLoc.isValid() || FixItLoc == PointerLoc)\n    return;\n\n  const char *NextChar = S.SourceMgr.getCharacterData(FixItLoc);\n  if (!NextChar)\n    return;\n\n  SmallString<32> InsertionTextBuf{\" \"};\n  InsertionTextBuf += getNullabilitySpelling(Nullability);\n  InsertionTextBuf += \" \";\n  StringRef InsertionText = InsertionTextBuf.str();\n\n  if (isWhitespace(*NextChar)) {\n    InsertionText = InsertionText.drop_back();\n  } else if (NextChar[-1] == '[') {\n    if (NextChar[0] == ']')\n      InsertionText = InsertionText.drop_back().drop_front();\n    else\n      InsertionText = InsertionText.drop_front();\n  } else if (!isIdentifierBody(NextChar[0], /*allow dollar*/true) &&\n             !isIdentifierBody(NextChar[-1], /*allow dollar*/true)) {\n    InsertionText = InsertionText.drop_back().drop_front();\n  }\n\n  Diag << FixItHint::CreateInsertion(FixItLoc, InsertionText);\n}\n\nstatic void emitNullabilityConsistencyWarning(Sema &S,\n                                              SimplePointerKind PointerKind,\n                                              SourceLocation PointerLoc,\n                                              SourceLocation PointerEndLoc) {\n  assert(PointerLoc.isValid());\n\n  if (PointerKind == SimplePointerKind::Array) {\n    S.Diag(PointerLoc, diag::warn_nullability_missing_array);\n  } else {\n    S.Diag(PointerLoc, diag::warn_nullability_missing)\n      << static_cast<unsigned>(PointerKind);\n  }\n\n  auto FixItLoc = PointerEndLoc.isValid() ? PointerEndLoc : PointerLoc;\n  if (FixItLoc.isMacroID())\n    return;\n\n  auto addFixIt = [&](NullabilityKind Nullability) {\n    auto Diag = S.Diag(FixItLoc, diag::note_nullability_fix_it);\n    Diag << static_cast<unsigned>(Nullability);\n    Diag << static_cast<unsigned>(PointerKind);\n    fixItNullability(S, Diag, FixItLoc, Nullability);\n  };\n  addFixIt(NullabilityKind::Nullable);\n  addFixIt(NullabilityKind::NonNull);\n}\n\n/// Complains about missing nullability if the file containing \\p pointerLoc\n/// has other uses of nullability (either the keywords or the \\c assume_nonnull\n/// pragma).\n///\n/// If the file has \\e not seen other uses of nullability, this particular\n/// pointer is saved for possible later diagnosis. See recordNullabilitySeen().\nstatic void\ncheckNullabilityConsistency(Sema &S, SimplePointerKind pointerKind,\n                            SourceLocation pointerLoc,\n                            SourceLocation pointerEndLoc = SourceLocation()) {\n  // Determine which file we're performing consistency checking for.\n  FileID file = getNullabilityCompletenessCheckFileID(S, pointerLoc);\n  if (file.isInvalid())\n    return;\n\n  // If we haven't seen any type nullability in this file, we won't warn now\n  // about anything.\n  FileNullability &fileNullability = S.NullabilityMap[file];\n  if (!fileNullability.SawTypeNullability) {\n    // If this is the first pointer declarator in the file, and the appropriate\n    // warning is on, record it in case we need to diagnose it retroactively.\n    diag::kind diagKind;\n    if (pointerKind == SimplePointerKind::Array)\n      diagKind = diag::warn_nullability_missing_array;\n    else\n      diagKind = diag::warn_nullability_missing;\n\n    if (fileNullability.PointerLoc.isInvalid() &&\n        !S.Context.getDiagnostics().isIgnored(diagKind, pointerLoc)) {\n      fileNullability.PointerLoc = pointerLoc;\n      fileNullability.PointerEndLoc = pointerEndLoc;\n      fileNullability.PointerKind = static_cast<unsigned>(pointerKind);\n    }\n\n    return;\n  }\n\n  // Complain about missing nullability.\n  emitNullabilityConsistencyWarning(S, pointerKind, pointerLoc, pointerEndLoc);\n}\n\n/// Marks that a nullability feature has been used in the file containing\n/// \\p loc.\n///\n/// If this file already had pointer types in it that were missing nullability,\n/// the first such instance is retroactively diagnosed.\n///\n/// \\sa checkNullabilityConsistency\nstatic void recordNullabilitySeen(Sema &S, SourceLocation loc) {\n  FileID file = getNullabilityCompletenessCheckFileID(S, loc);\n  if (file.isInvalid())\n    return;\n\n  FileNullability &fileNullability = S.NullabilityMap[file];\n  if (fileNullability.SawTypeNullability)\n    return;\n  fileNullability.SawTypeNullability = true;\n\n  // If we haven't seen any type nullability before, now we have. Retroactively\n  // diagnose the first unannotated pointer, if there was one.\n  if (fileNullability.PointerLoc.isInvalid())\n    return;\n\n  auto kind = static_cast<SimplePointerKind>(fileNullability.PointerKind);\n  emitNullabilityConsistencyWarning(S, kind, fileNullability.PointerLoc,\n                                    fileNullability.PointerEndLoc);\n}\n\n/// Returns true if any of the declarator chunks before \\p endIndex include a\n/// level of indirection: array, pointer, reference, or pointer-to-member.\n///\n/// Because declarator chunks are stored in outer-to-inner order, testing\n/// every chunk before \\p endIndex is testing all chunks that embed the current\n/// chunk as part of their type.\n///\n/// It is legal to pass the result of Declarator::getNumTypeObjects() as the\n/// end index, in which case all chunks are tested.\nstatic bool hasOuterPointerLikeChunk(const Declarator &D, unsigned endIndex) {\n  unsigned i = endIndex;\n  while (i != 0) {\n    // Walk outwards along the declarator chunks.\n    --i;\n    const DeclaratorChunk &DC = D.getTypeObject(i);\n    switch (DC.Kind) {\n    case DeclaratorChunk::Paren:\n      break;\n    case DeclaratorChunk::Array:\n    case DeclaratorChunk::Pointer:\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::MemberPointer:\n      return true;\n    case DeclaratorChunk::Function:\n    case DeclaratorChunk::BlockPointer:\n    case DeclaratorChunk::Pipe:\n      // These are invalid anyway, so just ignore.\n      break;\n    }\n  }\n  return false;\n}\n\nstatic bool IsNoDerefableChunk(DeclaratorChunk Chunk) {\n  return (Chunk.Kind == DeclaratorChunk::Pointer ||\n          Chunk.Kind == DeclaratorChunk::Array);\n}\n\ntemplate<typename AttrT>\nstatic AttrT *createSimpleAttr(ASTContext &Ctx, ParsedAttr &AL) {\n  AL.setUsedAsTypeAttr();\n  return ::new (Ctx) AttrT(Ctx, AL);\n}\n\nstatic Attr *createNullabilityAttr(ASTContext &Ctx, ParsedAttr &Attr,\n                                   NullabilityKind NK) {\n  switch (NK) {\n  case NullabilityKind::NonNull:\n    return createSimpleAttr<TypeNonNullAttr>(Ctx, Attr);\n\n  case NullabilityKind::Nullable:\n    return createSimpleAttr<TypeNullableAttr>(Ctx, Attr);\n\n  case NullabilityKind::NullableResult:\n    return createSimpleAttr<TypeNullableResultAttr>(Ctx, Attr);\n\n  case NullabilityKind::Unspecified:\n    return createSimpleAttr<TypeNullUnspecifiedAttr>(Ctx, Attr);\n  }\n  llvm_unreachable(\"unknown NullabilityKind\");\n}\n\n// Diagnose whether this is a case with the multiple addr spaces.\n// Returns true if this is an invalid case.\n// ISO/IEC TR 18037 S5.3 (amending C99 6.7.3): \"No type shall be qualified\n// by qualifiers for two or more different address spaces.\"\nstatic bool DiagnoseMultipleAddrSpaceAttributes(Sema &S, LangAS ASOld,\n                                                LangAS ASNew,\n                                                SourceLocation AttrLoc) {\n  if (ASOld != LangAS::Default) {\n    if (ASOld != ASNew) {\n      S.Diag(AttrLoc, diag::err_attribute_address_multiple_qualifiers);\n      return true;\n    }\n    // Emit a warning if they are identical; it's likely unintended.\n    S.Diag(AttrLoc,\n           diag::warn_attribute_address_multiple_identical_qualifiers);\n  }\n  return false;\n}\n\nstatic TypeSourceInfo *GetFullTypeForDeclarator(TypeProcessingState &state,\n                                                QualType declSpecType,\n                                                TypeSourceInfo *TInfo) {\n  // The TypeSourceInfo that this function returns will not be a null type.\n  // If there is an error, this function will fill in a dummy type as fallback.\n  QualType T = declSpecType;\n  Declarator &D = state.getDeclarator();\n  Sema &S = state.getSema();\n  ASTContext &Context = S.Context;\n  const LangOptions &LangOpts = S.getLangOpts();\n\n  // The name we're declaring, if any.\n  DeclarationName Name;\n  if (D.getIdentifier())\n    Name = D.getIdentifier();\n\n  // Does this declaration declare a typedef-name?\n  bool IsTypedefName =\n      D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef ||\n      D.getContext() == DeclaratorContext::AliasDecl ||\n      D.getContext() == DeclaratorContext::AliasTemplate;\n\n  // Does T refer to a function type with a cv-qualifier or a ref-qualifier?\n  bool IsQualifiedFunction = T->isFunctionProtoType() &&\n      (!T->castAs<FunctionProtoType>()->getMethodQuals().empty() ||\n       T->castAs<FunctionProtoType>()->getRefQualifier() != RQ_None);\n\n  // If T is 'decltype(auto)', the only declarators we can have are parens\n  // and at most one function declarator if this is a function declaration.\n  // If T is a deduced class template specialization type, we can have no\n  // declarator chunks at all.\n  if (auto *DT = T->getAs<DeducedType>()) {\n    const AutoType *AT = T->getAs<AutoType>();\n    bool IsClassTemplateDeduction = isa<DeducedTemplateSpecializationType>(DT);\n    if ((AT && AT->isDecltypeAuto()) || IsClassTemplateDeduction) {\n      for (unsigned I = 0, E = D.getNumTypeObjects(); I != E; ++I) {\n        unsigned Index = E - I - 1;\n        DeclaratorChunk &DeclChunk = D.getTypeObject(Index);\n        unsigned DiagId = IsClassTemplateDeduction\n                              ? diag::err_deduced_class_template_compound_type\n                              : diag::err_decltype_auto_compound_type;\n        unsigned DiagKind = 0;\n        switch (DeclChunk.Kind) {\n        case DeclaratorChunk::Paren:\n          // FIXME: Rejecting this is a little silly.\n          if (IsClassTemplateDeduction) {\n            DiagKind = 4;\n            break;\n          }\n          continue;\n        case DeclaratorChunk::Function: {\n          if (IsClassTemplateDeduction) {\n            DiagKind = 3;\n            break;\n          }\n          unsigned FnIndex;\n          if (D.isFunctionDeclarationContext() &&\n              D.isFunctionDeclarator(FnIndex) && FnIndex == Index)\n            continue;\n          DiagId = diag::err_decltype_auto_function_declarator_not_declaration;\n          break;\n        }\n        case DeclaratorChunk::Pointer:\n        case DeclaratorChunk::BlockPointer:\n        case DeclaratorChunk::MemberPointer:\n          DiagKind = 0;\n          break;\n        case DeclaratorChunk::Reference:\n          DiagKind = 1;\n          break;\n        case DeclaratorChunk::Array:\n          DiagKind = 2;\n          break;\n        case DeclaratorChunk::Pipe:\n          break;\n        }\n\n        S.Diag(DeclChunk.Loc, DiagId) << DiagKind;\n        D.setInvalidType(true);\n        break;\n      }\n    }\n  }\n\n  // Determine whether we should infer _Nonnull on pointer types.\n  Optional<NullabilityKind> inferNullability;\n  bool inferNullabilityCS = false;\n  bool inferNullabilityInnerOnly = false;\n  bool inferNullabilityInnerOnlyComplete = false;\n\n  // Are we in an assume-nonnull region?\n  bool inAssumeNonNullRegion = false;\n  SourceLocation assumeNonNullLoc = S.PP.getPragmaAssumeNonNullLoc();\n  if (assumeNonNullLoc.isValid()) {\n    inAssumeNonNullRegion = true;\n    recordNullabilitySeen(S, assumeNonNullLoc);\n  }\n\n  // Whether to complain about missing nullability specifiers or not.\n  enum {\n    /// Never complain.\n    CAMN_No,\n    /// Complain on the inner pointers (but not the outermost\n    /// pointer).\n    CAMN_InnerPointers,\n    /// Complain about any pointers that don't have nullability\n    /// specified or inferred.\n    CAMN_Yes\n  } complainAboutMissingNullability = CAMN_No;\n  unsigned NumPointersRemaining = 0;\n  auto complainAboutInferringWithinChunk = PointerWrappingDeclaratorKind::None;\n\n  if (IsTypedefName) {\n    // For typedefs, we do not infer any nullability (the default),\n    // and we only complain about missing nullability specifiers on\n    // inner pointers.\n    complainAboutMissingNullability = CAMN_InnerPointers;\n\n    if (T->canHaveNullability(/*ResultIfUnknown*/false) &&\n        !T->getNullability(S.Context)) {\n      // Note that we allow but don't require nullability on dependent types.\n      ++NumPointersRemaining;\n    }\n\n    for (unsigned i = 0, n = D.getNumTypeObjects(); i != n; ++i) {\n      DeclaratorChunk &chunk = D.getTypeObject(i);\n      switch (chunk.Kind) {\n      case DeclaratorChunk::Array:\n      case DeclaratorChunk::Function:\n      case DeclaratorChunk::Pipe:\n        break;\n\n      case DeclaratorChunk::BlockPointer:\n      case DeclaratorChunk::MemberPointer:\n        ++NumPointersRemaining;\n        break;\n\n      case DeclaratorChunk::Paren:\n      case DeclaratorChunk::Reference:\n        continue;\n\n      case DeclaratorChunk::Pointer:\n        ++NumPointersRemaining;\n        continue;\n      }\n    }\n  } else {\n    bool isFunctionOrMethod = false;\n    switch (auto context = state.getDeclarator().getContext()) {\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      isFunctionOrMethod = true;\n      LLVM_FALLTHROUGH;\n\n    case DeclaratorContext::Member:\n      if (state.getDeclarator().isObjCIvar() && !isFunctionOrMethod) {\n        complainAboutMissingNullability = CAMN_No;\n        break;\n      }\n\n      // Weak properties are inferred to be nullable.\n      if (state.getDeclarator().isObjCWeakProperty() && inAssumeNonNullRegion) {\n        inferNullability = NullabilityKind::Nullable;\n        break;\n      }\n\n      LLVM_FALLTHROUGH;\n\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList: {\n      complainAboutMissingNullability = CAMN_Yes;\n\n      // Nullability inference depends on the type and declarator.\n      auto wrappingKind = PointerWrappingDeclaratorKind::None;\n      switch (classifyPointerDeclarator(S, T, D, wrappingKind)) {\n      case PointerDeclaratorKind::NonPointer:\n      case PointerDeclaratorKind::MultiLevelPointer:\n        // Cannot infer nullability.\n        break;\n\n      case PointerDeclaratorKind::SingleLevelPointer:\n        // Infer _Nonnull if we are in an assumes-nonnull region.\n        if (inAssumeNonNullRegion) {\n          complainAboutInferringWithinChunk = wrappingKind;\n          inferNullability = NullabilityKind::NonNull;\n          inferNullabilityCS = (context == DeclaratorContext::ObjCParameter ||\n                                context == DeclaratorContext::ObjCResult);\n        }\n        break;\n\n      case PointerDeclaratorKind::CFErrorRefPointer:\n      case PointerDeclaratorKind::NSErrorPointerPointer:\n        // Within a function or method signature, infer _Nullable at both\n        // levels.\n        if (isFunctionOrMethod && inAssumeNonNullRegion)\n          inferNullability = NullabilityKind::Nullable;\n        break;\n\n      case PointerDeclaratorKind::MaybePointerToCFRef:\n        if (isFunctionOrMethod) {\n          // On pointer-to-pointer parameters marked cf_returns_retained or\n          // cf_returns_not_retained, if the outer pointer is explicit then\n          // infer the inner pointer as _Nullable.\n          auto hasCFReturnsAttr =\n              [](const ParsedAttributesView &AttrList) -> bool {\n            return AttrList.hasAttribute(ParsedAttr::AT_CFReturnsRetained) ||\n                   AttrList.hasAttribute(ParsedAttr::AT_CFReturnsNotRetained);\n          };\n          if (const auto *InnermostChunk = D.getInnermostNonParenChunk()) {\n            if (hasCFReturnsAttr(D.getAttributes()) ||\n                hasCFReturnsAttr(InnermostChunk->getAttrs()) ||\n                hasCFReturnsAttr(D.getDeclSpec().getAttributes())) {\n              inferNullability = NullabilityKind::Nullable;\n              inferNullabilityInnerOnly = true;\n            }\n          }\n        }\n        break;\n      }\n      break;\n    }\n\n    case DeclaratorContext::ConversionId:\n      complainAboutMissingNullability = CAMN_Yes;\n      break;\n\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::RequiresExpr:\n      // Don't infer in these contexts.\n      break;\n    }\n  }\n\n  // Local function that returns true if its argument looks like a va_list.\n  auto isVaList = [&S](QualType T) -> bool {\n    auto *typedefTy = T->getAs<TypedefType>();\n    if (!typedefTy)\n      return false;\n    TypedefDecl *vaListTypedef = S.Context.getBuiltinVaListDecl();\n    do {\n      if (typedefTy->getDecl() == vaListTypedef)\n        return true;\n      if (auto *name = typedefTy->getDecl()->getIdentifier())\n        if (name->isStr(\"va_list\"))\n          return true;\n      typedefTy = typedefTy->desugar()->getAs<TypedefType>();\n    } while (typedefTy);\n    return false;\n  };\n\n  // Local function that checks the nullability for a given pointer declarator.\n  // Returns true if _Nonnull was inferred.\n  auto inferPointerNullability =\n      [&](SimplePointerKind pointerKind, SourceLocation pointerLoc,\n          SourceLocation pointerEndLoc,\n          ParsedAttributesView &attrs, AttributePool &Pool) -> ParsedAttr * {\n    // We've seen a pointer.\n    if (NumPointersRemaining > 0)\n      --NumPointersRemaining;\n\n    // If a nullability attribute is present, there's nothing to do.\n    if (hasNullabilityAttr(attrs))\n      return nullptr;\n\n    // If we're supposed to infer nullability, do so now.\n    if (inferNullability && !inferNullabilityInnerOnlyComplete) {\n      ParsedAttr::Syntax syntax = inferNullabilityCS\n                                      ? ParsedAttr::AS_ContextSensitiveKeyword\n                                      : ParsedAttr::AS_Keyword;\n      ParsedAttr *nullabilityAttr = Pool.create(\n          S.getNullabilityKeyword(*inferNullability), SourceRange(pointerLoc),\n          nullptr, SourceLocation(), nullptr, 0, syntax);\n\n      attrs.addAtEnd(nullabilityAttr);\n\n      if (inferNullabilityCS) {\n        state.getDeclarator().getMutableDeclSpec().getObjCQualifiers()\n          ->setObjCDeclQualifier(ObjCDeclSpec::DQ_CSNullability);\n      }\n\n      if (pointerLoc.isValid() &&\n          complainAboutInferringWithinChunk !=\n            PointerWrappingDeclaratorKind::None) {\n        auto Diag =\n            S.Diag(pointerLoc, diag::warn_nullability_inferred_on_nested_type);\n        Diag << static_cast<int>(complainAboutInferringWithinChunk);\n        fixItNullability(S, Diag, pointerLoc, NullabilityKind::NonNull);\n      }\n\n      if (inferNullabilityInnerOnly)\n        inferNullabilityInnerOnlyComplete = true;\n      return nullabilityAttr;\n    }\n\n    // If we're supposed to complain about missing nullability, do so\n    // now if it's truly missing.\n    switch (complainAboutMissingNullability) {\n    case CAMN_No:\n      break;\n\n    case CAMN_InnerPointers:\n      if (NumPointersRemaining == 0)\n        break;\n      LLVM_FALLTHROUGH;\n\n    case CAMN_Yes:\n      checkNullabilityConsistency(S, pointerKind, pointerLoc, pointerEndLoc);\n    }\n    return nullptr;\n  };\n\n  // If the type itself could have nullability but does not, infer pointer\n  // nullability and perform consistency checking.\n  if (S.CodeSynthesisContexts.empty()) {\n    if (T->canHaveNullability(/*ResultIfUnknown*/false) &&\n        !T->getNullability(S.Context)) {\n      if (isVaList(T)) {\n        // Record that we've seen a pointer, but do nothing else.\n        if (NumPointersRemaining > 0)\n          --NumPointersRemaining;\n      } else {\n        SimplePointerKind pointerKind = SimplePointerKind::Pointer;\n        if (T->isBlockPointerType())\n          pointerKind = SimplePointerKind::BlockPointer;\n        else if (T->isMemberPointerType())\n          pointerKind = SimplePointerKind::MemberPointer;\n\n        if (auto *attr = inferPointerNullability(\n                pointerKind, D.getDeclSpec().getTypeSpecTypeLoc(),\n                D.getDeclSpec().getEndLoc(),\n                D.getMutableDeclSpec().getAttributes(),\n                D.getMutableDeclSpec().getAttributePool())) {\n          T = state.getAttributedType(\n              createNullabilityAttr(Context, *attr, *inferNullability), T, T);\n        }\n      }\n    }\n\n    if (complainAboutMissingNullability == CAMN_Yes &&\n        T->isArrayType() && !T->getNullability(S.Context) && !isVaList(T) &&\n        D.isPrototypeContext() &&\n        !hasOuterPointerLikeChunk(D, D.getNumTypeObjects())) {\n      checkNullabilityConsistency(S, SimplePointerKind::Array,\n                                  D.getDeclSpec().getTypeSpecTypeLoc());\n    }\n  }\n\n  bool ExpectNoDerefChunk =\n      state.getCurrentAttributes().hasAttribute(ParsedAttr::AT_NoDeref);\n\n  // Walk the DeclTypeInfo, building the recursive type as we go.\n  // DeclTypeInfos are ordered from the identifier out, which is\n  // opposite of what we want :).\n  for (unsigned i = 0, e = D.getNumTypeObjects(); i != e; ++i) {\n    unsigned chunkIndex = e - i - 1;\n    state.setCurrentChunkIndex(chunkIndex);\n    DeclaratorChunk &DeclType = D.getTypeObject(chunkIndex);\n    IsQualifiedFunction &= DeclType.Kind == DeclaratorChunk::Paren;\n    switch (DeclType.Kind) {\n    case DeclaratorChunk::Paren:\n      if (i == 0)\n        warnAboutRedundantParens(S, D, T);\n      T = S.BuildParenType(T);\n      break;\n    case DeclaratorChunk::BlockPointer:\n      // If blocks are disabled, emit an error.\n      if (!LangOpts.Blocks)\n        S.Diag(DeclType.Loc, diag::err_blocks_disable) << LangOpts.OpenCL;\n\n      // Handle pointer nullability.\n      inferPointerNullability(SimplePointerKind::BlockPointer, DeclType.Loc,\n                              DeclType.EndLoc, DeclType.getAttrs(),\n                              state.getDeclarator().getAttributePool());\n\n      T = S.BuildBlockPointerType(T, D.getIdentifierLoc(), Name);\n      if (DeclType.Cls.TypeQuals || LangOpts.OpenCL) {\n        // OpenCL v2.0, s6.12.5 - Block variable declarations are implicitly\n        // qualified with const.\n        if (LangOpts.OpenCL)\n          DeclType.Cls.TypeQuals |= DeclSpec::TQ_const;\n        T = S.BuildQualifiedType(T, DeclType.Loc, DeclType.Cls.TypeQuals);\n      }\n      break;\n    case DeclaratorChunk::Pointer:\n      // Verify that we're not building a pointer to pointer to function with\n      // exception specification.\n      if (LangOpts.CPlusPlus && S.CheckDistantExceptionSpec(T)) {\n        S.Diag(D.getIdentifierLoc(), diag::err_distant_exception_spec);\n        D.setInvalidType(true);\n        // Build the type anyway.\n      }\n\n      // Handle pointer nullability\n      inferPointerNullability(SimplePointerKind::Pointer, DeclType.Loc,\n                              DeclType.EndLoc, DeclType.getAttrs(),\n                              state.getDeclarator().getAttributePool());\n\n      if (LangOpts.ObjC && T->getAs<ObjCObjectType>()) {\n        T = Context.getObjCObjectPointerType(T);\n        if (DeclType.Ptr.TypeQuals)\n          T = S.BuildQualifiedType(T, DeclType.Loc, DeclType.Ptr.TypeQuals);\n        break;\n      }\n\n      // OpenCL v2.0 s6.9b - Pointer to image/sampler cannot be used.\n      // OpenCL v2.0 s6.13.16.1 - Pointer to pipe cannot be used.\n      // OpenCL v2.0 s6.12.5 - Pointers to Blocks are not allowed.\n      if (LangOpts.OpenCL) {\n        if (T->isImageType() || T->isSamplerT() || T->isPipeType() ||\n            T->isBlockPointerType()) {\n          S.Diag(D.getIdentifierLoc(), diag::err_opencl_pointer_to_type) << T;\n          D.setInvalidType(true);\n        }\n      }\n\n      T = S.BuildPointerType(T, DeclType.Loc, Name);\n      if (DeclType.Ptr.TypeQuals)\n        T = S.BuildQualifiedType(T, DeclType.Loc, DeclType.Ptr.TypeQuals);\n      break;\n    case DeclaratorChunk::Reference: {\n      // Verify that we're not building a reference to pointer to function with\n      // exception specification.\n      if (LangOpts.CPlusPlus && S.CheckDistantExceptionSpec(T)) {\n        S.Diag(D.getIdentifierLoc(), diag::err_distant_exception_spec);\n        D.setInvalidType(true);\n        // Build the type anyway.\n      }\n      T = S.BuildReferenceType(T, DeclType.Ref.LValueRef, DeclType.Loc, Name);\n\n      if (DeclType.Ref.HasRestrict)\n        T = S.BuildQualifiedType(T, DeclType.Loc, Qualifiers::Restrict);\n      break;\n    }\n    case DeclaratorChunk::Array: {\n      // Verify that we're not building an array of pointers to function with\n      // exception specification.\n      if (LangOpts.CPlusPlus && S.CheckDistantExceptionSpec(T)) {\n        S.Diag(D.getIdentifierLoc(), diag::err_distant_exception_spec);\n        D.setInvalidType(true);\n        // Build the type anyway.\n      }\n      DeclaratorChunk::ArrayTypeInfo &ATI = DeclType.Arr;\n      Expr *ArraySize = static_cast<Expr*>(ATI.NumElts);\n      ArrayType::ArraySizeModifier ASM;\n      if (ATI.isStar)\n        ASM = ArrayType::Star;\n      else if (ATI.hasStatic)\n        ASM = ArrayType::Static;\n      else\n        ASM = ArrayType::Normal;\n      if (ASM == ArrayType::Star && !D.isPrototypeContext()) {\n        // FIXME: This check isn't quite right: it allows star in prototypes\n        // for function definitions, and disallows some edge cases detailed\n        // in http://gcc.gnu.org/ml/gcc-patches/2009-02/msg00133.html\n        S.Diag(DeclType.Loc, diag::err_array_star_outside_prototype);\n        ASM = ArrayType::Normal;\n        D.setInvalidType(true);\n      }\n\n      // C99 6.7.5.2p1: The optional type qualifiers and the keyword static\n      // shall appear only in a declaration of a function parameter with an\n      // array type, ...\n      if (ASM == ArrayType::Static || ATI.TypeQuals) {\n        if (!(D.isPrototypeContext() ||\n              D.getContext() == DeclaratorContext::KNRTypeList)) {\n          S.Diag(DeclType.Loc, diag::err_array_static_outside_prototype) <<\n              (ASM == ArrayType::Static ? \"'static'\" : \"type qualifier\");\n          // Remove the 'static' and the type qualifiers.\n          if (ASM == ArrayType::Static)\n            ASM = ArrayType::Normal;\n          ATI.TypeQuals = 0;\n          D.setInvalidType(true);\n        }\n\n        // C99 6.7.5.2p1: ... and then only in the outermost array type\n        // derivation.\n        if (hasOuterPointerLikeChunk(D, chunkIndex)) {\n          S.Diag(DeclType.Loc, diag::err_array_static_not_outermost) <<\n            (ASM == ArrayType::Static ? \"'static'\" : \"type qualifier\");\n          if (ASM == ArrayType::Static)\n            ASM = ArrayType::Normal;\n          ATI.TypeQuals = 0;\n          D.setInvalidType(true);\n        }\n      }\n      const AutoType *AT = T->getContainedAutoType();\n      // Allow arrays of auto if we are a generic lambda parameter.\n      // i.e. [](auto (&array)[5]) { return array[0]; }; OK\n      if (AT && D.getContext() != DeclaratorContext::LambdaExprParameter) {\n        // We've already diagnosed this for decltype(auto).\n        if (!AT->isDecltypeAuto())\n          S.Diag(DeclType.Loc, diag::err_illegal_decl_array_of_auto)\n              << getPrintableNameForEntity(Name) << T;\n        T = QualType();\n        break;\n      }\n\n      // Array parameters can be marked nullable as well, although it's not\n      // necessary if they're marked 'static'.\n      if (complainAboutMissingNullability == CAMN_Yes &&\n          !hasNullabilityAttr(DeclType.getAttrs()) &&\n          ASM != ArrayType::Static &&\n          D.isPrototypeContext() &&\n          !hasOuterPointerLikeChunk(D, chunkIndex)) {\n        checkNullabilityConsistency(S, SimplePointerKind::Array, DeclType.Loc);\n      }\n\n      T = S.BuildArrayType(T, ASM, ArraySize, ATI.TypeQuals,\n                           SourceRange(DeclType.Loc, DeclType.EndLoc), Name);\n      break;\n    }\n    case DeclaratorChunk::Function: {\n      // If the function declarator has a prototype (i.e. it is not () and\n      // does not have a K&R-style identifier list), then the arguments are part\n      // of the type, otherwise the argument list is ().\n      DeclaratorChunk::FunctionTypeInfo &FTI = DeclType.Fun;\n      IsQualifiedFunction =\n          FTI.hasMethodTypeQualifiers() || FTI.hasRefQualifier();\n\n      // Check for auto functions and trailing return type and adjust the\n      // return type accordingly.\n      if (!D.isInvalidType()) {\n        // trailing-return-type is only required if we're declaring a function,\n        // and not, for instance, a pointer to a function.\n        if (D.getDeclSpec().hasAutoTypeSpec() &&\n            !FTI.hasTrailingReturnType() && chunkIndex == 0) {\n          if (!S.getLangOpts().CPlusPlus14) {\n            S.Diag(D.getDeclSpec().getTypeSpecTypeLoc(),\n                   D.getDeclSpec().getTypeSpecType() == DeclSpec::TST_auto\n                       ? diag::err_auto_missing_trailing_return\n                       : diag::err_deduced_return_type);\n            T = Context.IntTy;\n            D.setInvalidType(true);\n          } else {\n            S.Diag(D.getDeclSpec().getTypeSpecTypeLoc(),\n                   diag::warn_cxx11_compat_deduced_return_type);\n          }\n        } else if (FTI.hasTrailingReturnType()) {\n          // T must be exactly 'auto' at this point. See CWG issue 681.\n          if (isa<ParenType>(T)) {\n            S.Diag(D.getBeginLoc(), diag::err_trailing_return_in_parens)\n                << T << D.getSourceRange();\n            D.setInvalidType(true);\n          } else if (D.getName().getKind() ==\n                     UnqualifiedIdKind::IK_DeductionGuideName) {\n            if (T != Context.DependentTy) {\n              S.Diag(D.getDeclSpec().getBeginLoc(),\n                     diag::err_deduction_guide_with_complex_decl)\n                  << D.getSourceRange();\n              D.setInvalidType(true);\n            }\n          } else if (D.getContext() != DeclaratorContext::LambdaExpr &&\n                     (T.hasQualifiers() || !isa<AutoType>(T) ||\n                      cast<AutoType>(T)->getKeyword() !=\n                          AutoTypeKeyword::Auto ||\n                      cast<AutoType>(T)->isConstrained())) {\n            S.Diag(D.getDeclSpec().getTypeSpecTypeLoc(),\n                   diag::err_trailing_return_without_auto)\n                << T << D.getDeclSpec().getSourceRange();\n            D.setInvalidType(true);\n          }\n          T = S.GetTypeFromParser(FTI.getTrailingReturnType(), &TInfo);\n          if (T.isNull()) {\n            // An error occurred parsing the trailing return type.\n            T = Context.IntTy;\n            D.setInvalidType(true);\n          } else if (AutoType *Auto = T->getContainedAutoType()) {\n            // If the trailing return type contains an `auto`, we may need to\n            // invent a template parameter for it, for cases like\n            // `auto f() -> C auto` or `[](auto (*p) -> auto) {}`.\n            InventedTemplateParameterInfo *InventedParamInfo = nullptr;\n            if (D.getContext() == DeclaratorContext::Prototype)\n              InventedParamInfo = &S.InventedParameterInfos.back();\n            else if (D.getContext() == DeclaratorContext::LambdaExprParameter)\n              InventedParamInfo = S.getCurLambda();\n            if (InventedParamInfo) {\n              std::tie(T, TInfo) = InventTemplateParameter(\n                  state, T, TInfo, Auto, *InventedParamInfo);\n            }\n          }\n        } else {\n          // This function type is not the type of the entity being declared,\n          // so checking the 'auto' is not the responsibility of this chunk.\n        }\n      }\n\n      // C99 6.7.5.3p1: The return type may not be a function or array type.\n      // For conversion functions, we'll diagnose this particular error later.\n      if (!D.isInvalidType() && (T->isArrayType() || T->isFunctionType()) &&\n          (D.getName().getKind() !=\n           UnqualifiedIdKind::IK_ConversionFunctionId)) {\n        unsigned diagID = diag::err_func_returning_array_function;\n        // Last processing chunk in block context means this function chunk\n        // represents the block.\n        if (chunkIndex == 0 &&\n            D.getContext() == DeclaratorContext::BlockLiteral)\n          diagID = diag::err_block_returning_array_function;\n        S.Diag(DeclType.Loc, diagID) << T->isFunctionType() << T;\n        T = Context.IntTy;\n        D.setInvalidType(true);\n      }\n\n      // Do not allow returning half FP value.\n      // FIXME: This really should be in BuildFunctionType.\n      if (T->isHalfType()) {\n        if (S.getLangOpts().OpenCL) {\n          if (!S.getOpenCLOptions().isEnabled(\"cl_khr_fp16\")) {\n            S.Diag(D.getIdentifierLoc(), diag::err_opencl_invalid_return)\n                << T << 0 /*pointer hint*/;\n            D.setInvalidType(true);\n          }\n        } else if (!S.getLangOpts().HalfArgsAndReturns) {\n          S.Diag(D.getIdentifierLoc(),\n            diag::err_parameters_retval_cannot_have_fp16_type) << 1;\n          D.setInvalidType(true);\n        }\n      }\n\n      if (LangOpts.OpenCL) {\n        // OpenCL v2.0 s6.12.5 - A block cannot be the return value of a\n        // function.\n        if (T->isBlockPointerType() || T->isImageType() || T->isSamplerT() ||\n            T->isPipeType()) {\n          S.Diag(D.getIdentifierLoc(), diag::err_opencl_invalid_return)\n              << T << 1 /*hint off*/;\n          D.setInvalidType(true);\n        }\n        // OpenCL doesn't support variadic functions and blocks\n        // (s6.9.e and s6.12.5 OpenCL v2.0) except for printf.\n        // We also allow here any toolchain reserved identifiers.\n        if (FTI.isVariadic &&\n            !S.getOpenCLOptions().isEnabled(\"__cl_clang_variadic_functions\") &&\n            !(D.getIdentifier() &&\n              ((D.getIdentifier()->getName() == \"printf\" &&\n                (LangOpts.OpenCLCPlusPlus || LangOpts.OpenCLVersion >= 120)) ||\n               D.getIdentifier()->getName().startswith(\"__\")))) {\n          S.Diag(D.getIdentifierLoc(), diag::err_opencl_variadic_function);\n          D.setInvalidType(true);\n        }\n      }\n\n      // Methods cannot return interface types. All ObjC objects are\n      // passed by reference.\n      if (T->isObjCObjectType()) {\n        SourceLocation DiagLoc, FixitLoc;\n        if (TInfo) {\n          DiagLoc = TInfo->getTypeLoc().getBeginLoc();\n          FixitLoc = S.getLocForEndOfToken(TInfo->getTypeLoc().getEndLoc());\n        } else {\n          DiagLoc = D.getDeclSpec().getTypeSpecTypeLoc();\n          FixitLoc = S.getLocForEndOfToken(D.getDeclSpec().getEndLoc());\n        }\n        S.Diag(DiagLoc, diag::err_object_cannot_be_passed_returned_by_value)\n          << 0 << T\n          << FixItHint::CreateInsertion(FixitLoc, \"*\");\n\n        T = Context.getObjCObjectPointerType(T);\n        if (TInfo) {\n          TypeLocBuilder TLB;\n          TLB.pushFullCopy(TInfo->getTypeLoc());\n          ObjCObjectPointerTypeLoc TLoc = TLB.push<ObjCObjectPointerTypeLoc>(T);\n          TLoc.setStarLoc(FixitLoc);\n          TInfo = TLB.getTypeSourceInfo(Context, T);\n        }\n\n        D.setInvalidType(true);\n      }\n\n      // cv-qualifiers on return types are pointless except when the type is a\n      // class type in C++.\n      if ((T.getCVRQualifiers() || T->isAtomicType()) &&\n          !(S.getLangOpts().CPlusPlus &&\n            (T->isDependentType() || T->isRecordType()))) {\n        if (T->isVoidType() && !S.getLangOpts().CPlusPlus &&\n            D.getFunctionDefinitionKind() ==\n                FunctionDefinitionKind::Definition) {\n          // [6.9.1/3] qualified void return is invalid on a C\n          // function definition.  Apparently ok on declarations and\n          // in C++ though (!)\n          S.Diag(DeclType.Loc, diag::err_func_returning_qualified_void) << T;\n        } else\n          diagnoseRedundantReturnTypeQualifiers(S, T, D, chunkIndex);\n\n        // C++2a [dcl.fct]p12:\n        //   A volatile-qualified return type is deprecated\n        if (T.isVolatileQualified() && S.getLangOpts().CPlusPlus20)\n          S.Diag(DeclType.Loc, diag::warn_deprecated_volatile_return) << T;\n      }\n\n      // Objective-C ARC ownership qualifiers are ignored on the function\n      // return type (by type canonicalization). Complain if this attribute\n      // was written here.\n      if (T.getQualifiers().hasObjCLifetime()) {\n        SourceLocation AttrLoc;\n        if (chunkIndex + 1 < D.getNumTypeObjects()) {\n          DeclaratorChunk ReturnTypeChunk = D.getTypeObject(chunkIndex + 1);\n          for (const ParsedAttr &AL : ReturnTypeChunk.getAttrs()) {\n            if (AL.getKind() == ParsedAttr::AT_ObjCOwnership) {\n              AttrLoc = AL.getLoc();\n              break;\n            }\n          }\n        }\n        if (AttrLoc.isInvalid()) {\n          for (const ParsedAttr &AL : D.getDeclSpec().getAttributes()) {\n            if (AL.getKind() == ParsedAttr::AT_ObjCOwnership) {\n              AttrLoc = AL.getLoc();\n              break;\n            }\n          }\n        }\n\n        if (AttrLoc.isValid()) {\n          // The ownership attributes are almost always written via\n          // the predefined\n          // __strong/__weak/__autoreleasing/__unsafe_unretained.\n          if (AttrLoc.isMacroID())\n            AttrLoc =\n                S.SourceMgr.getImmediateExpansionRange(AttrLoc).getBegin();\n\n          S.Diag(AttrLoc, diag::warn_arc_lifetime_result_type)\n            << T.getQualifiers().getObjCLifetime();\n        }\n      }\n\n      if (LangOpts.CPlusPlus && D.getDeclSpec().hasTagDefinition()) {\n        // C++ [dcl.fct]p6:\n        //   Types shall not be defined in return or parameter types.\n        TagDecl *Tag = cast<TagDecl>(D.getDeclSpec().getRepAsDecl());\n        S.Diag(Tag->getLocation(), diag::err_type_defined_in_result_type)\n          << Context.getTypeDeclType(Tag);\n      }\n\n      // Exception specs are not allowed in typedefs. Complain, but add it\n      // anyway.\n      if (IsTypedefName && FTI.getExceptionSpecType() && !LangOpts.CPlusPlus17)\n        S.Diag(FTI.getExceptionSpecLocBeg(),\n               diag::err_exception_spec_in_typedef)\n            << (D.getContext() == DeclaratorContext::AliasDecl ||\n                D.getContext() == DeclaratorContext::AliasTemplate);\n\n      // If we see \"T var();\" or \"T var(T());\" at block scope, it is probably\n      // an attempt to initialize a variable, not a function declaration.\n      if (FTI.isAmbiguous)\n        warnAboutAmbiguousFunction(S, D, DeclType, T);\n\n      FunctionType::ExtInfo EI(\n          getCCForDeclaratorChunk(S, D, DeclType.getAttrs(), FTI, chunkIndex));\n\n      if (!FTI.NumParams && !FTI.isVariadic && !LangOpts.CPlusPlus\n                                            && !LangOpts.OpenCL) {\n        // Simple void foo(), where the incoming T is the result type.\n        T = Context.getFunctionNoProtoType(T, EI);\n      } else {\n        // We allow a zero-parameter variadic function in C if the\n        // function is marked with the \"overloadable\" attribute. Scan\n        // for this attribute now.\n        if (!FTI.NumParams && FTI.isVariadic && !LangOpts.CPlusPlus)\n          if (!D.getAttributes().hasAttribute(ParsedAttr::AT_Overloadable))\n            S.Diag(FTI.getEllipsisLoc(), diag::err_ellipsis_first_param);\n\n        if (FTI.NumParams && FTI.Params[0].Param == nullptr) {\n          // C99 6.7.5.3p3: Reject int(x,y,z) when it's not a function\n          // definition.\n          S.Diag(FTI.Params[0].IdentLoc,\n                 diag::err_ident_list_in_fn_declaration);\n          D.setInvalidType(true);\n          // Recover by creating a K&R-style function type.\n          T = Context.getFunctionNoProtoType(T, EI);\n          break;\n        }\n\n        FunctionProtoType::ExtProtoInfo EPI;\n        EPI.ExtInfo = EI;\n        EPI.Variadic = FTI.isVariadic;\n        EPI.EllipsisLoc = FTI.getEllipsisLoc();\n        EPI.HasTrailingReturn = FTI.hasTrailingReturnType();\n        EPI.TypeQuals.addCVRUQualifiers(\n            FTI.MethodQualifiers ? FTI.MethodQualifiers->getTypeQualifiers()\n                                 : 0);\n        EPI.RefQualifier = !FTI.hasRefQualifier()? RQ_None\n                    : FTI.RefQualifierIsLValueRef? RQ_LValue\n                    : RQ_RValue;\n\n        // Otherwise, we have a function with a parameter list that is\n        // potentially variadic.\n        SmallVector<QualType, 16> ParamTys;\n        ParamTys.reserve(FTI.NumParams);\n\n        SmallVector<FunctionProtoType::ExtParameterInfo, 16>\n          ExtParameterInfos(FTI.NumParams);\n        bool HasAnyInterestingExtParameterInfos = false;\n\n        for (unsigned i = 0, e = FTI.NumParams; i != e; ++i) {\n          ParmVarDecl *Param = cast<ParmVarDecl>(FTI.Params[i].Param);\n          QualType ParamTy = Param->getType();\n          assert(!ParamTy.isNull() && \"Couldn't parse type?\");\n\n          // Look for 'void'.  void is allowed only as a single parameter to a\n          // function with no other parameters (C99 6.7.5.3p10).  We record\n          // int(void) as a FunctionProtoType with an empty parameter list.\n          if (ParamTy->isVoidType()) {\n            // If this is something like 'float(int, void)', reject it.  'void'\n            // is an incomplete type (C99 6.2.5p19) and function decls cannot\n            // have parameters of incomplete type.\n            if (FTI.NumParams != 1 || FTI.isVariadic) {\n              S.Diag(FTI.Params[i].IdentLoc, diag::err_void_only_param);\n              ParamTy = Context.IntTy;\n              Param->setType(ParamTy);\n            } else if (FTI.Params[i].Ident) {\n              // Reject, but continue to parse 'int(void abc)'.\n              S.Diag(FTI.Params[i].IdentLoc, diag::err_param_with_void_type);\n              ParamTy = Context.IntTy;\n              Param->setType(ParamTy);\n            } else {\n              // Reject, but continue to parse 'float(const void)'.\n              if (ParamTy.hasQualifiers())\n                S.Diag(DeclType.Loc, diag::err_void_param_qualified);\n\n              // Do not add 'void' to the list.\n              break;\n            }\n          } else if (ParamTy->isHalfType()) {\n            // Disallow half FP parameters.\n            // FIXME: This really should be in BuildFunctionType.\n            if (S.getLangOpts().OpenCL) {\n              if (!S.getOpenCLOptions().isEnabled(\"cl_khr_fp16\")) {\n                S.Diag(Param->getLocation(), diag::err_opencl_invalid_param)\n                    << ParamTy << 0;\n                D.setInvalidType();\n                Param->setInvalidDecl();\n              }\n            } else if (!S.getLangOpts().HalfArgsAndReturns) {\n              S.Diag(Param->getLocation(),\n                diag::err_parameters_retval_cannot_have_fp16_type) << 0;\n              D.setInvalidType();\n            }\n          } else if (!FTI.hasPrototype) {\n            if (ParamTy->isPromotableIntegerType()) {\n              ParamTy = Context.getPromotedIntegerType(ParamTy);\n              Param->setKNRPromoted(true);\n            } else if (const BuiltinType* BTy = ParamTy->getAs<BuiltinType>()) {\n              if (BTy->getKind() == BuiltinType::Float) {\n                ParamTy = Context.DoubleTy;\n                Param->setKNRPromoted(true);\n              }\n            }\n          } else if (S.getLangOpts().OpenCL && ParamTy->isBlockPointerType()) {\n            // OpenCL 2.0 s6.12.5: A block cannot be a parameter of a function.\n            S.Diag(Param->getLocation(), diag::err_opencl_invalid_param)\n                << ParamTy << 1 /*hint off*/;\n            D.setInvalidType();\n          }\n\n          if (LangOpts.ObjCAutoRefCount && Param->hasAttr<NSConsumedAttr>()) {\n            ExtParameterInfos[i] = ExtParameterInfos[i].withIsConsumed(true);\n            HasAnyInterestingExtParameterInfos = true;\n          }\n\n          if (auto attr = Param->getAttr<ParameterABIAttr>()) {\n            ExtParameterInfos[i] =\n              ExtParameterInfos[i].withABI(attr->getABI());\n            HasAnyInterestingExtParameterInfos = true;\n          }\n\n          if (Param->hasAttr<PassObjectSizeAttr>()) {\n            ExtParameterInfos[i] = ExtParameterInfos[i].withHasPassObjectSize();\n            HasAnyInterestingExtParameterInfos = true;\n          }\n\n          if (Param->hasAttr<NoEscapeAttr>()) {\n            ExtParameterInfos[i] = ExtParameterInfos[i].withIsNoEscape(true);\n            HasAnyInterestingExtParameterInfos = true;\n          }\n\n          ParamTys.push_back(ParamTy);\n        }\n\n        if (HasAnyInterestingExtParameterInfos) {\n          EPI.ExtParameterInfos = ExtParameterInfos.data();\n          checkExtParameterInfos(S, ParamTys, EPI,\n              [&](unsigned i) { return FTI.Params[i].Param->getLocation(); });\n        }\n\n        SmallVector<QualType, 4> Exceptions;\n        SmallVector<ParsedType, 2> DynamicExceptions;\n        SmallVector<SourceRange, 2> DynamicExceptionRanges;\n        Expr *NoexceptExpr = nullptr;\n\n        if (FTI.getExceptionSpecType() == EST_Dynamic) {\n          // FIXME: It's rather inefficient to have to split into two vectors\n          // here.\n          unsigned N = FTI.getNumExceptions();\n          DynamicExceptions.reserve(N);\n          DynamicExceptionRanges.reserve(N);\n          for (unsigned I = 0; I != N; ++I) {\n            DynamicExceptions.push_back(FTI.Exceptions[I].Ty);\n            DynamicExceptionRanges.push_back(FTI.Exceptions[I].Range);\n          }\n        } else if (isComputedNoexcept(FTI.getExceptionSpecType())) {\n          NoexceptExpr = FTI.NoexceptExpr;\n        }\n\n        S.checkExceptionSpecification(D.isFunctionDeclarationContext(),\n                                      FTI.getExceptionSpecType(),\n                                      DynamicExceptions,\n                                      DynamicExceptionRanges,\n                                      NoexceptExpr,\n                                      Exceptions,\n                                      EPI.ExceptionSpec);\n\n        // FIXME: Set address space from attrs for C++ mode here.\n        // OpenCLCPlusPlus: A class member function has an address space.\n        auto IsClassMember = [&]() {\n          return (!state.getDeclarator().getCXXScopeSpec().isEmpty() &&\n                  state.getDeclarator()\n                          .getCXXScopeSpec()\n                          .getScopeRep()\n                          ->getKind() == NestedNameSpecifier::TypeSpec) ||\n                 state.getDeclarator().getContext() ==\n                     DeclaratorContext::Member ||\n                 state.getDeclarator().getContext() ==\n                     DeclaratorContext::LambdaExpr;\n        };\n\n        if (state.getSema().getLangOpts().OpenCLCPlusPlus && IsClassMember()) {\n          LangAS ASIdx = LangAS::Default;\n          // Take address space attr if any and mark as invalid to avoid adding\n          // them later while creating QualType.\n          if (FTI.MethodQualifiers)\n            for (ParsedAttr &attr : FTI.MethodQualifiers->getAttributes()) {\n              LangAS ASIdxNew = attr.asOpenCLLangAS();\n              if (DiagnoseMultipleAddrSpaceAttributes(S, ASIdx, ASIdxNew,\n                                                      attr.getLoc()))\n                D.setInvalidType(true);\n              else\n                ASIdx = ASIdxNew;\n            }\n          // If a class member function's address space is not set, set it to\n          // __generic.\n          LangAS AS =\n              (ASIdx == LangAS::Default ? S.getDefaultCXXMethodAddrSpace()\n                                        : ASIdx);\n          EPI.TypeQuals.addAddressSpace(AS);\n        }\n        T = Context.getFunctionType(T, ParamTys, EPI);\n      }\n      break;\n    }\n    case DeclaratorChunk::MemberPointer: {\n      // The scope spec must refer to a class, or be dependent.\n      CXXScopeSpec &SS = DeclType.Mem.Scope();\n      QualType ClsType;\n\n      // Handle pointer nullability.\n      inferPointerNullability(SimplePointerKind::MemberPointer, DeclType.Loc,\n                              DeclType.EndLoc, DeclType.getAttrs(),\n                              state.getDeclarator().getAttributePool());\n\n      if (SS.isInvalid()) {\n        // Avoid emitting extra errors if we already errored on the scope.\n        D.setInvalidType(true);\n      } else if (S.isDependentScopeSpecifier(SS) ||\n                 dyn_cast_or_null<CXXRecordDecl>(S.computeDeclContext(SS))) {\n        NestedNameSpecifier *NNS = SS.getScopeRep();\n        NestedNameSpecifier *NNSPrefix = NNS->getPrefix();\n        switch (NNS->getKind()) {\n        case NestedNameSpecifier::Identifier:\n          ClsType = Context.getDependentNameType(ETK_None, NNSPrefix,\n                                                 NNS->getAsIdentifier());\n          break;\n\n        case NestedNameSpecifier::Namespace:\n        case NestedNameSpecifier::NamespaceAlias:\n        case NestedNameSpecifier::Global:\n        case NestedNameSpecifier::Super:\n          llvm_unreachable(\"Nested-name-specifier must name a type\");\n\n        case NestedNameSpecifier::TypeSpec:\n        case NestedNameSpecifier::TypeSpecWithTemplate:\n          ClsType = QualType(NNS->getAsType(), 0);\n          // Note: if the NNS has a prefix and ClsType is a nondependent\n          // TemplateSpecializationType, then the NNS prefix is NOT included\n          // in ClsType; hence we wrap ClsType into an ElaboratedType.\n          // NOTE: in particular, no wrap occurs if ClsType already is an\n          // Elaborated, DependentName, or DependentTemplateSpecialization.\n          if (NNSPrefix && isa<TemplateSpecializationType>(NNS->getAsType()))\n            ClsType = Context.getElaboratedType(ETK_None, NNSPrefix, ClsType);\n          break;\n        }\n      } else {\n        S.Diag(DeclType.Mem.Scope().getBeginLoc(),\n             diag::err_illegal_decl_mempointer_in_nonclass)\n          << (D.getIdentifier() ? D.getIdentifier()->getName() : \"type name\")\n          << DeclType.Mem.Scope().getRange();\n        D.setInvalidType(true);\n      }\n\n      if (!ClsType.isNull())\n        T = S.BuildMemberPointerType(T, ClsType, DeclType.Loc,\n                                     D.getIdentifier());\n      if (T.isNull()) {\n        T = Context.IntTy;\n        D.setInvalidType(true);\n      } else if (DeclType.Mem.TypeQuals) {\n        T = S.BuildQualifiedType(T, DeclType.Loc, DeclType.Mem.TypeQuals);\n      }\n      break;\n    }\n\n    case DeclaratorChunk::Pipe: {\n      T = S.BuildReadPipeType(T, DeclType.Loc);\n      processTypeAttrs(state, T, TAL_DeclSpec,\n                       D.getMutableDeclSpec().getAttributes());\n      break;\n    }\n    }\n\n    if (T.isNull()) {\n      D.setInvalidType(true);\n      T = Context.IntTy;\n    }\n\n    // See if there are any attributes on this declarator chunk.\n    processTypeAttrs(state, T, TAL_DeclChunk, DeclType.getAttrs());\n\n    if (DeclType.Kind != DeclaratorChunk::Paren) {\n      if (ExpectNoDerefChunk && !IsNoDerefableChunk(DeclType))\n        S.Diag(DeclType.Loc, diag::warn_noderef_on_non_pointer_or_array);\n\n      ExpectNoDerefChunk = state.didParseNoDeref();\n    }\n  }\n\n  if (ExpectNoDerefChunk)\n    S.Diag(state.getDeclarator().getBeginLoc(),\n           diag::warn_noderef_on_non_pointer_or_array);\n\n  // GNU warning -Wstrict-prototypes\n  //   Warn if a function declaration is without a prototype.\n  //   This warning is issued for all kinds of unprototyped function\n  //   declarations (i.e. function type typedef, function pointer etc.)\n  //   C99 6.7.5.3p14:\n  //   The empty list in a function declarator that is not part of a definition\n  //   of that function specifies that no information about the number or types\n  //   of the parameters is supplied.\n  if (!LangOpts.CPlusPlus &&\n      D.getFunctionDefinitionKind() == FunctionDefinitionKind::Declaration) {\n    bool IsBlock = false;\n    for (const DeclaratorChunk &DeclType : D.type_objects()) {\n      switch (DeclType.Kind) {\n      case DeclaratorChunk::BlockPointer:\n        IsBlock = true;\n        break;\n      case DeclaratorChunk::Function: {\n        const DeclaratorChunk::FunctionTypeInfo &FTI = DeclType.Fun;\n        // We supress the warning when there's no LParen location, as this\n        // indicates the declaration was an implicit declaration, which gets\n        // warned about separately via -Wimplicit-function-declaration.\n        if (FTI.NumParams == 0 && !FTI.isVariadic && FTI.getLParenLoc().isValid())\n          S.Diag(DeclType.Loc, diag::warn_strict_prototypes)\n              << IsBlock\n              << FixItHint::CreateInsertion(FTI.getRParenLoc(), \"void\");\n        IsBlock = false;\n        break;\n      }\n      default:\n        break;\n      }\n    }\n  }\n\n  assert(!T.isNull() && \"T must not be null after this point\");\n\n  if (LangOpts.CPlusPlus && T->isFunctionType()) {\n    const FunctionProtoType *FnTy = T->getAs<FunctionProtoType>();\n    assert(FnTy && \"Why oh why is there not a FunctionProtoType here?\");\n\n    // C++ 8.3.5p4:\n    //   A cv-qualifier-seq shall only be part of the function type\n    //   for a nonstatic member function, the function type to which a pointer\n    //   to member refers, or the top-level function type of a function typedef\n    //   declaration.\n    //\n    // Core issue 547 also allows cv-qualifiers on function types that are\n    // top-level template type arguments.\n    enum { NonMember, Member, DeductionGuide } Kind = NonMember;\n    if (D.getName().getKind() == UnqualifiedIdKind::IK_DeductionGuideName)\n      Kind = DeductionGuide;\n    else if (!D.getCXXScopeSpec().isSet()) {\n      if ((D.getContext() == DeclaratorContext::Member ||\n           D.getContext() == DeclaratorContext::LambdaExpr) &&\n          !D.getDeclSpec().isFriendSpecified())\n        Kind = Member;\n    } else {\n      DeclContext *DC = S.computeDeclContext(D.getCXXScopeSpec());\n      if (!DC || DC->isRecord())\n        Kind = Member;\n    }\n\n    // C++11 [dcl.fct]p6 (w/DR1417):\n    // An attempt to specify a function type with a cv-qualifier-seq or a\n    // ref-qualifier (including by typedef-name) is ill-formed unless it is:\n    //  - the function type for a non-static member function,\n    //  - the function type to which a pointer to member refers,\n    //  - the top-level function type of a function typedef declaration or\n    //    alias-declaration,\n    //  - the type-id in the default argument of a type-parameter, or\n    //  - the type-id of a template-argument for a type-parameter\n    //\n    // FIXME: Checking this here is insufficient. We accept-invalid on:\n    //\n    //   template<typename T> struct S { void f(T); };\n    //   S<int() const> s;\n    //\n    // ... for instance.\n    if (IsQualifiedFunction &&\n        !(Kind == Member &&\n          D.getDeclSpec().getStorageClassSpec() != DeclSpec::SCS_static) &&\n        !IsTypedefName && D.getContext() != DeclaratorContext::TemplateArg &&\n        D.getContext() != DeclaratorContext::TemplateTypeArg) {\n      SourceLocation Loc = D.getBeginLoc();\n      SourceRange RemovalRange;\n      unsigned I;\n      if (D.isFunctionDeclarator(I)) {\n        SmallVector<SourceLocation, 4> RemovalLocs;\n        const DeclaratorChunk &Chunk = D.getTypeObject(I);\n        assert(Chunk.Kind == DeclaratorChunk::Function);\n\n        if (Chunk.Fun.hasRefQualifier())\n          RemovalLocs.push_back(Chunk.Fun.getRefQualifierLoc());\n\n        if (Chunk.Fun.hasMethodTypeQualifiers())\n          Chunk.Fun.MethodQualifiers->forEachQualifier(\n              [&](DeclSpec::TQ TypeQual, StringRef QualName,\n                  SourceLocation SL) { RemovalLocs.push_back(SL); });\n\n        if (!RemovalLocs.empty()) {\n          llvm::sort(RemovalLocs,\n                     BeforeThanCompare<SourceLocation>(S.getSourceManager()));\n          RemovalRange = SourceRange(RemovalLocs.front(), RemovalLocs.back());\n          Loc = RemovalLocs.front();\n        }\n      }\n\n      S.Diag(Loc, diag::err_invalid_qualified_function_type)\n        << Kind << D.isFunctionDeclarator() << T\n        << getFunctionQualifiersAsString(FnTy)\n        << FixItHint::CreateRemoval(RemovalRange);\n\n      // Strip the cv-qualifiers and ref-qualifiers from the type.\n      FunctionProtoType::ExtProtoInfo EPI = FnTy->getExtProtoInfo();\n      EPI.TypeQuals.removeCVRQualifiers();\n      EPI.RefQualifier = RQ_None;\n\n      T = Context.getFunctionType(FnTy->getReturnType(), FnTy->getParamTypes(),\n                                  EPI);\n      // Rebuild any parens around the identifier in the function type.\n      for (unsigned i = 0, e = D.getNumTypeObjects(); i != e; ++i) {\n        if (D.getTypeObject(i).Kind != DeclaratorChunk::Paren)\n          break;\n        T = S.BuildParenType(T);\n      }\n    }\n  }\n\n  // Apply any undistributed attributes from the declarator.\n  processTypeAttrs(state, T, TAL_DeclName, D.getAttributes());\n\n  // Diagnose any ignored type attributes.\n  state.diagnoseIgnoredTypeAttrs(T);\n\n  // C++0x [dcl.constexpr]p9:\n  //  A constexpr specifier used in an object declaration declares the object\n  //  as const.\n  if (D.getDeclSpec().getConstexprSpecifier() == ConstexprSpecKind::Constexpr &&\n      T->isObjectType())\n    T.addConst();\n\n  // C++2a [dcl.fct]p4:\n  //   A parameter with volatile-qualified type is deprecated\n  if (T.isVolatileQualified() && S.getLangOpts().CPlusPlus20 &&\n      (D.getContext() == DeclaratorContext::Prototype ||\n       D.getContext() == DeclaratorContext::LambdaExprParameter))\n    S.Diag(D.getIdentifierLoc(), diag::warn_deprecated_volatile_param) << T;\n\n  // If there was an ellipsis in the declarator, the declaration declares a\n  // parameter pack whose type may be a pack expansion type.\n  if (D.hasEllipsis()) {\n    // C++0x [dcl.fct]p13:\n    //   A declarator-id or abstract-declarator containing an ellipsis shall\n    //   only be used in a parameter-declaration. Such a parameter-declaration\n    //   is a parameter pack (14.5.3). [...]\n    switch (D.getContext()) {\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::RequiresExpr:\n      // C++0x [dcl.fct]p13:\n      //   [...] When it is part of a parameter-declaration-clause, the\n      //   parameter pack is a function parameter pack (14.5.3). The type T\n      //   of the declarator-id of the function parameter pack shall contain\n      //   a template parameter pack; each template parameter pack in T is\n      //   expanded by the function parameter pack.\n      //\n      // We represent function parameter packs as function parameters whose\n      // type is a pack expansion.\n      if (!T->containsUnexpandedParameterPack() &&\n          (!LangOpts.CPlusPlus20 || !T->getContainedAutoType())) {\n        S.Diag(D.getEllipsisLoc(),\n             diag::err_function_parameter_pack_without_parameter_packs)\n          << T <<  D.getSourceRange();\n        D.setEllipsisLoc(SourceLocation());\n      } else {\n        T = Context.getPackExpansionType(T, None, /*ExpectPackInType=*/false);\n      }\n      break;\n    case DeclaratorContext::TemplateParam:\n      // C++0x [temp.param]p15:\n      //   If a template-parameter is a [...] is a parameter-declaration that\n      //   declares a parameter pack (8.3.5), then the template-parameter is a\n      //   template parameter pack (14.5.3).\n      //\n      // Note: core issue 778 clarifies that, if there are any unexpanded\n      // parameter packs in the type of the non-type template parameter, then\n      // it expands those parameter packs.\n      if (T->containsUnexpandedParameterPack())\n        T = Context.getPackExpansionType(T, None);\n      else\n        S.Diag(D.getEllipsisLoc(),\n               LangOpts.CPlusPlus11\n                 ? diag::warn_cxx98_compat_variadic_templates\n                 : diag::ext_variadic_templates);\n      break;\n\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::ObjCParameter: // FIXME: special diagnostic here?\n    case DeclaratorContext::ObjCResult:    // FIXME: special diagnostic here?\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n      // FIXME: We may want to allow parameter packs in block-literal contexts\n      // in the future.\n      S.Diag(D.getEllipsisLoc(),\n             diag::err_ellipsis_in_declarator_not_parameter);\n      D.setEllipsisLoc(SourceLocation());\n      break;\n    }\n  }\n\n  assert(!T.isNull() && \"T must not be null at the end of this function\");\n  if (D.isInvalidType())\n    return Context.getTrivialTypeSourceInfo(T);\n\n  return GetTypeSourceInfoForDeclarator(state, T, TInfo);\n}\n\n/// GetTypeForDeclarator - Convert the type for the specified\n/// declarator to Type instances.\n///\n/// The result of this call will never be null, but the associated\n/// type may be a null type if there's an unrecoverable error.\nTypeSourceInfo *Sema::GetTypeForDeclarator(Declarator &D, Scope *S) {\n  // Determine the type of the declarator. Not all forms of declarator\n  // have a type.\n\n  TypeProcessingState state(*this, D);\n\n  TypeSourceInfo *ReturnTypeInfo = nullptr;\n  QualType T = GetDeclSpecTypeForDeclarator(state, ReturnTypeInfo);\n  if (D.isPrototypeContext() && getLangOpts().ObjCAutoRefCount)\n    inferARCWriteback(state, T);\n\n  return GetFullTypeForDeclarator(state, T, ReturnTypeInfo);\n}\n\nstatic void transferARCOwnershipToDeclSpec(Sema &S,\n                                           QualType &declSpecTy,\n                                           Qualifiers::ObjCLifetime ownership) {\n  if (declSpecTy->isObjCRetainableType() &&\n      declSpecTy.getObjCLifetime() == Qualifiers::OCL_None) {\n    Qualifiers qs;\n    qs.addObjCLifetime(ownership);\n    declSpecTy = S.Context.getQualifiedType(declSpecTy, qs);\n  }\n}\n\nstatic void transferARCOwnershipToDeclaratorChunk(TypeProcessingState &state,\n                                            Qualifiers::ObjCLifetime ownership,\n                                            unsigned chunkIndex) {\n  Sema &S = state.getSema();\n  Declarator &D = state.getDeclarator();\n\n  // Look for an explicit lifetime attribute.\n  DeclaratorChunk &chunk = D.getTypeObject(chunkIndex);\n  if (chunk.getAttrs().hasAttribute(ParsedAttr::AT_ObjCOwnership))\n    return;\n\n  const char *attrStr = nullptr;\n  switch (ownership) {\n  case Qualifiers::OCL_None: llvm_unreachable(\"no ownership!\");\n  case Qualifiers::OCL_ExplicitNone: attrStr = \"none\"; break;\n  case Qualifiers::OCL_Strong: attrStr = \"strong\"; break;\n  case Qualifiers::OCL_Weak: attrStr = \"weak\"; break;\n  case Qualifiers::OCL_Autoreleasing: attrStr = \"autoreleasing\"; break;\n  }\n\n  IdentifierLoc *Arg = new (S.Context) IdentifierLoc;\n  Arg->Ident = &S.Context.Idents.get(attrStr);\n  Arg->Loc = SourceLocation();\n\n  ArgsUnion Args(Arg);\n\n  // If there wasn't one, add one (with an invalid source location\n  // so that we don't make an AttributedType for it).\n  ParsedAttr *attr = D.getAttributePool().create(\n      &S.Context.Idents.get(\"objc_ownership\"), SourceLocation(),\n      /*scope*/ nullptr, SourceLocation(),\n      /*args*/ &Args, 1, ParsedAttr::AS_GNU);\n  chunk.getAttrs().addAtEnd(attr);\n  // TODO: mark whether we did this inference?\n}\n\n/// Used for transferring ownership in casts resulting in l-values.\nstatic void transferARCOwnership(TypeProcessingState &state,\n                                 QualType &declSpecTy,\n                                 Qualifiers::ObjCLifetime ownership) {\n  Sema &S = state.getSema();\n  Declarator &D = state.getDeclarator();\n\n  int inner = -1;\n  bool hasIndirection = false;\n  for (unsigned i = 0, e = D.getNumTypeObjects(); i != e; ++i) {\n    DeclaratorChunk &chunk = D.getTypeObject(i);\n    switch (chunk.Kind) {\n    case DeclaratorChunk::Paren:\n      // Ignore parens.\n      break;\n\n    case DeclaratorChunk::Array:\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::Pointer:\n      if (inner != -1)\n        hasIndirection = true;\n      inner = i;\n      break;\n\n    case DeclaratorChunk::BlockPointer:\n      if (inner != -1)\n        transferARCOwnershipToDeclaratorChunk(state, ownership, i);\n      return;\n\n    case DeclaratorChunk::Function:\n    case DeclaratorChunk::MemberPointer:\n    case DeclaratorChunk::Pipe:\n      return;\n    }\n  }\n\n  if (inner == -1)\n    return;\n\n  DeclaratorChunk &chunk = D.getTypeObject(inner);\n  if (chunk.Kind == DeclaratorChunk::Pointer) {\n    if (declSpecTy->isObjCRetainableType())\n      return transferARCOwnershipToDeclSpec(S, declSpecTy, ownership);\n    if (declSpecTy->isObjCObjectType() && hasIndirection)\n      return transferARCOwnershipToDeclaratorChunk(state, ownership, inner);\n  } else {\n    assert(chunk.Kind == DeclaratorChunk::Array ||\n           chunk.Kind == DeclaratorChunk::Reference);\n    return transferARCOwnershipToDeclSpec(S, declSpecTy, ownership);\n  }\n}\n\nTypeSourceInfo *Sema::GetTypeForDeclaratorCast(Declarator &D, QualType FromTy) {\n  TypeProcessingState state(*this, D);\n\n  TypeSourceInfo *ReturnTypeInfo = nullptr;\n  QualType declSpecTy = GetDeclSpecTypeForDeclarator(state, ReturnTypeInfo);\n\n  if (getLangOpts().ObjC) {\n    Qualifiers::ObjCLifetime ownership = Context.getInnerObjCOwnership(FromTy);\n    if (ownership != Qualifiers::OCL_None)\n      transferARCOwnership(state, declSpecTy, ownership);\n  }\n\n  return GetFullTypeForDeclarator(state, declSpecTy, ReturnTypeInfo);\n}\n\nstatic void fillAttributedTypeLoc(AttributedTypeLoc TL,\n                                  TypeProcessingState &State) {\n  TL.setAttr(State.takeAttrForAttributedType(TL.getTypePtr()));\n}\n\nnamespace {\n  class TypeSpecLocFiller : public TypeLocVisitor<TypeSpecLocFiller> {\n    Sema &SemaRef;\n    ASTContext &Context;\n    TypeProcessingState &State;\n    const DeclSpec &DS;\n\n  public:\n    TypeSpecLocFiller(Sema &S, ASTContext &Context, TypeProcessingState &State,\n                      const DeclSpec &DS)\n        : SemaRef(S), Context(Context), State(State), DS(DS) {}\n\n    void VisitAttributedTypeLoc(AttributedTypeLoc TL) {\n      Visit(TL.getModifiedLoc());\n      fillAttributedTypeLoc(TL, State);\n    }\n    void VisitMacroQualifiedTypeLoc(MacroQualifiedTypeLoc TL) {\n      Visit(TL.getInnerLoc());\n      TL.setExpansionLoc(\n          State.getExpansionLocForMacroQualifiedType(TL.getTypePtr()));\n    }\n    void VisitQualifiedTypeLoc(QualifiedTypeLoc TL) {\n      Visit(TL.getUnqualifiedLoc());\n    }\n    void VisitTypedefTypeLoc(TypedefTypeLoc TL) {\n      TL.setNameLoc(DS.getTypeSpecTypeLoc());\n    }\n    void VisitObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc TL) {\n      TL.setNameLoc(DS.getTypeSpecTypeLoc());\n      // FIXME. We should have DS.getTypeSpecTypeEndLoc(). But, it requires\n      // addition field. What we have is good enough for dispay of location\n      // of 'fixit' on interface name.\n      TL.setNameEndLoc(DS.getEndLoc());\n    }\n    void VisitObjCObjectTypeLoc(ObjCObjectTypeLoc TL) {\n      TypeSourceInfo *RepTInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &RepTInfo);\n      TL.copy(RepTInfo->getTypeLoc());\n    }\n    void VisitObjCObjectPointerTypeLoc(ObjCObjectPointerTypeLoc TL) {\n      TypeSourceInfo *RepTInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &RepTInfo);\n      TL.copy(RepTInfo->getTypeLoc());\n    }\n    void VisitTemplateSpecializationTypeLoc(TemplateSpecializationTypeLoc TL) {\n      TypeSourceInfo *TInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n\n      // If we got no declarator info from previous Sema routines,\n      // just fill with the typespec loc.\n      if (!TInfo) {\n        TL.initialize(Context, DS.getTypeSpecTypeNameLoc());\n        return;\n      }\n\n      TypeLoc OldTL = TInfo->getTypeLoc();\n      if (TInfo->getType()->getAs<ElaboratedType>()) {\n        ElaboratedTypeLoc ElabTL = OldTL.castAs<ElaboratedTypeLoc>();\n        TemplateSpecializationTypeLoc NamedTL = ElabTL.getNamedTypeLoc()\n            .castAs<TemplateSpecializationTypeLoc>();\n        TL.copy(NamedTL);\n      } else {\n        TL.copy(OldTL.castAs<TemplateSpecializationTypeLoc>());\n        assert(TL.getRAngleLoc() == OldTL.castAs<TemplateSpecializationTypeLoc>().getRAngleLoc());\n      }\n\n    }\n    void VisitTypeOfExprTypeLoc(TypeOfExprTypeLoc TL) {\n      assert(DS.getTypeSpecType() == DeclSpec::TST_typeofExpr);\n      TL.setTypeofLoc(DS.getTypeSpecTypeLoc());\n      TL.setParensRange(DS.getTypeofParensRange());\n    }\n    void VisitTypeOfTypeLoc(TypeOfTypeLoc TL) {\n      assert(DS.getTypeSpecType() == DeclSpec::TST_typeofType);\n      TL.setTypeofLoc(DS.getTypeSpecTypeLoc());\n      TL.setParensRange(DS.getTypeofParensRange());\n      assert(DS.getRepAsType());\n      TypeSourceInfo *TInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n      TL.setUnderlyingTInfo(TInfo);\n    }\n    void VisitUnaryTransformTypeLoc(UnaryTransformTypeLoc TL) {\n      // FIXME: This holds only because we only have one unary transform.\n      assert(DS.getTypeSpecType() == DeclSpec::TST_underlyingType);\n      TL.setKWLoc(DS.getTypeSpecTypeLoc());\n      TL.setParensRange(DS.getTypeofParensRange());\n      assert(DS.getRepAsType());\n      TypeSourceInfo *TInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n      TL.setUnderlyingTInfo(TInfo);\n    }\n    void VisitBuiltinTypeLoc(BuiltinTypeLoc TL) {\n      // By default, use the source location of the type specifier.\n      TL.setBuiltinLoc(DS.getTypeSpecTypeLoc());\n      if (TL.needsExtraLocalData()) {\n        // Set info for the written builtin specifiers.\n        TL.getWrittenBuiltinSpecs() = DS.getWrittenBuiltinSpecs();\n        // Try to have a meaningful source location.\n        if (TL.getWrittenSignSpec() != TypeSpecifierSign::Unspecified)\n          TL.expandBuiltinRange(DS.getTypeSpecSignLoc());\n        if (TL.getWrittenWidthSpec() != TypeSpecifierWidth::Unspecified)\n          TL.expandBuiltinRange(DS.getTypeSpecWidthRange());\n      }\n    }\n    void VisitElaboratedTypeLoc(ElaboratedTypeLoc TL) {\n      ElaboratedTypeKeyword Keyword\n        = TypeWithKeyword::getKeywordForTypeSpec(DS.getTypeSpecType());\n      if (DS.getTypeSpecType() == TST_typename) {\n        TypeSourceInfo *TInfo = nullptr;\n        Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n        if (TInfo) {\n          TL.copy(TInfo->getTypeLoc().castAs<ElaboratedTypeLoc>());\n          return;\n        }\n      }\n      TL.setElaboratedKeywordLoc(Keyword != ETK_None\n                                 ? DS.getTypeSpecTypeLoc()\n                                 : SourceLocation());\n      const CXXScopeSpec& SS = DS.getTypeSpecScope();\n      TL.setQualifierLoc(SS.getWithLocInContext(Context));\n      Visit(TL.getNextTypeLoc().getUnqualifiedLoc());\n    }\n    void VisitDependentNameTypeLoc(DependentNameTypeLoc TL) {\n      assert(DS.getTypeSpecType() == TST_typename);\n      TypeSourceInfo *TInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n      assert(TInfo);\n      TL.copy(TInfo->getTypeLoc().castAs<DependentNameTypeLoc>());\n    }\n    void VisitDependentTemplateSpecializationTypeLoc(\n                                 DependentTemplateSpecializationTypeLoc TL) {\n      assert(DS.getTypeSpecType() == TST_typename);\n      TypeSourceInfo *TInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n      assert(TInfo);\n      TL.copy(\n          TInfo->getTypeLoc().castAs<DependentTemplateSpecializationTypeLoc>());\n    }\n    void VisitAutoTypeLoc(AutoTypeLoc TL) {\n      assert(DS.getTypeSpecType() == TST_auto ||\n             DS.getTypeSpecType() == TST_decltype_auto ||\n             DS.getTypeSpecType() == TST_auto_type ||\n             DS.getTypeSpecType() == TST_unspecified);\n      TL.setNameLoc(DS.getTypeSpecTypeLoc());\n      if (!DS.isConstrainedAuto())\n        return;\n      TemplateIdAnnotation *TemplateId = DS.getRepAsTemplateId();\n      if (DS.getTypeSpecScope().isNotEmpty())\n        TL.setNestedNameSpecifierLoc(\n            DS.getTypeSpecScope().getWithLocInContext(Context));\n      else\n        TL.setNestedNameSpecifierLoc(NestedNameSpecifierLoc());\n      TL.setTemplateKWLoc(TemplateId->TemplateKWLoc);\n      TL.setConceptNameLoc(TemplateId->TemplateNameLoc);\n      TL.setFoundDecl(nullptr);\n      TL.setLAngleLoc(TemplateId->LAngleLoc);\n      TL.setRAngleLoc(TemplateId->RAngleLoc);\n      if (TemplateId->NumArgs == 0)\n        return;\n      TemplateArgumentListInfo TemplateArgsInfo;\n      ASTTemplateArgsPtr TemplateArgsPtr(TemplateId->getTemplateArgs(),\n                                         TemplateId->NumArgs);\n      SemaRef.translateTemplateArguments(TemplateArgsPtr, TemplateArgsInfo);\n      for (unsigned I = 0; I < TemplateId->NumArgs; ++I)\n        TL.setArgLocInfo(I, TemplateArgsInfo.arguments()[I].getLocInfo());\n    }\n    void VisitTagTypeLoc(TagTypeLoc TL) {\n      TL.setNameLoc(DS.getTypeSpecTypeNameLoc());\n    }\n    void VisitAtomicTypeLoc(AtomicTypeLoc TL) {\n      // An AtomicTypeLoc can come from either an _Atomic(...) type specifier\n      // or an _Atomic qualifier.\n      if (DS.getTypeSpecType() == DeclSpec::TST_atomic) {\n        TL.setKWLoc(DS.getTypeSpecTypeLoc());\n        TL.setParensRange(DS.getTypeofParensRange());\n\n        TypeSourceInfo *TInfo = nullptr;\n        Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n        assert(TInfo);\n        TL.getValueLoc().initializeFullCopy(TInfo->getTypeLoc());\n      } else {\n        TL.setKWLoc(DS.getAtomicSpecLoc());\n        // No parens, to indicate this was spelled as an _Atomic qualifier.\n        TL.setParensRange(SourceRange());\n        Visit(TL.getValueLoc());\n      }\n    }\n\n    void VisitPipeTypeLoc(PipeTypeLoc TL) {\n      TL.setKWLoc(DS.getTypeSpecTypeLoc());\n\n      TypeSourceInfo *TInfo = nullptr;\n      Sema::GetTypeFromParser(DS.getRepAsType(), &TInfo);\n      TL.getValueLoc().initializeFullCopy(TInfo->getTypeLoc());\n    }\n\n    void VisitExtIntTypeLoc(ExtIntTypeLoc TL) {\n      TL.setNameLoc(DS.getTypeSpecTypeLoc());\n    }\n\n    void VisitDependentExtIntTypeLoc(DependentExtIntTypeLoc TL) {\n      TL.setNameLoc(DS.getTypeSpecTypeLoc());\n    }\n\n    void VisitTypeLoc(TypeLoc TL) {\n      // FIXME: add other typespec types and change this to an assert.\n      TL.initialize(Context, DS.getTypeSpecTypeLoc());\n    }\n  };\n\n  class DeclaratorLocFiller : public TypeLocVisitor<DeclaratorLocFiller> {\n    ASTContext &Context;\n    TypeProcessingState &State;\n    const DeclaratorChunk &Chunk;\n\n  public:\n    DeclaratorLocFiller(ASTContext &Context, TypeProcessingState &State,\n                        const DeclaratorChunk &Chunk)\n        : Context(Context), State(State), Chunk(Chunk) {}\n\n    void VisitQualifiedTypeLoc(QualifiedTypeLoc TL) {\n      llvm_unreachable(\"qualified type locs not expected here!\");\n    }\n    void VisitDecayedTypeLoc(DecayedTypeLoc TL) {\n      llvm_unreachable(\"decayed type locs not expected here!\");\n    }\n\n    void VisitAttributedTypeLoc(AttributedTypeLoc TL) {\n      fillAttributedTypeLoc(TL, State);\n    }\n    void VisitAdjustedTypeLoc(AdjustedTypeLoc TL) {\n      // nothing\n    }\n    void VisitBlockPointerTypeLoc(BlockPointerTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::BlockPointer);\n      TL.setCaretLoc(Chunk.Loc);\n    }\n    void VisitPointerTypeLoc(PointerTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Pointer);\n      TL.setStarLoc(Chunk.Loc);\n    }\n    void VisitObjCObjectPointerTypeLoc(ObjCObjectPointerTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Pointer);\n      TL.setStarLoc(Chunk.Loc);\n    }\n    void VisitMemberPointerTypeLoc(MemberPointerTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::MemberPointer);\n      const CXXScopeSpec& SS = Chunk.Mem.Scope();\n      NestedNameSpecifierLoc NNSLoc = SS.getWithLocInContext(Context);\n\n      const Type* ClsTy = TL.getClass();\n      QualType ClsQT = QualType(ClsTy, 0);\n      TypeSourceInfo *ClsTInfo = Context.CreateTypeSourceInfo(ClsQT, 0);\n      // Now copy source location info into the type loc component.\n      TypeLoc ClsTL = ClsTInfo->getTypeLoc();\n      switch (NNSLoc.getNestedNameSpecifier()->getKind()) {\n      case NestedNameSpecifier::Identifier:\n        assert(isa<DependentNameType>(ClsTy) && \"Unexpected TypeLoc\");\n        {\n          DependentNameTypeLoc DNTLoc = ClsTL.castAs<DependentNameTypeLoc>();\n          DNTLoc.setElaboratedKeywordLoc(SourceLocation());\n          DNTLoc.setQualifierLoc(NNSLoc.getPrefix());\n          DNTLoc.setNameLoc(NNSLoc.getLocalBeginLoc());\n        }\n        break;\n\n      case NestedNameSpecifier::TypeSpec:\n      case NestedNameSpecifier::TypeSpecWithTemplate:\n        if (isa<ElaboratedType>(ClsTy)) {\n          ElaboratedTypeLoc ETLoc = ClsTL.castAs<ElaboratedTypeLoc>();\n          ETLoc.setElaboratedKeywordLoc(SourceLocation());\n          ETLoc.setQualifierLoc(NNSLoc.getPrefix());\n          TypeLoc NamedTL = ETLoc.getNamedTypeLoc();\n          NamedTL.initializeFullCopy(NNSLoc.getTypeLoc());\n        } else {\n          ClsTL.initializeFullCopy(NNSLoc.getTypeLoc());\n        }\n        break;\n\n      case NestedNameSpecifier::Namespace:\n      case NestedNameSpecifier::NamespaceAlias:\n      case NestedNameSpecifier::Global:\n      case NestedNameSpecifier::Super:\n        llvm_unreachable(\"Nested-name-specifier must name a type\");\n      }\n\n      // Finally fill in MemberPointerLocInfo fields.\n      TL.setStarLoc(Chunk.Mem.StarLoc);\n      TL.setClassTInfo(ClsTInfo);\n    }\n    void VisitLValueReferenceTypeLoc(LValueReferenceTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Reference);\n      // 'Amp' is misleading: this might have been originally\n      /// spelled with AmpAmp.\n      TL.setAmpLoc(Chunk.Loc);\n    }\n    void VisitRValueReferenceTypeLoc(RValueReferenceTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Reference);\n      assert(!Chunk.Ref.LValueRef);\n      TL.setAmpAmpLoc(Chunk.Loc);\n    }\n    void VisitArrayTypeLoc(ArrayTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Array);\n      TL.setLBracketLoc(Chunk.Loc);\n      TL.setRBracketLoc(Chunk.EndLoc);\n      TL.setSizeExpr(static_cast<Expr*>(Chunk.Arr.NumElts));\n    }\n    void VisitFunctionTypeLoc(FunctionTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Function);\n      TL.setLocalRangeBegin(Chunk.Loc);\n      TL.setLocalRangeEnd(Chunk.EndLoc);\n\n      const DeclaratorChunk::FunctionTypeInfo &FTI = Chunk.Fun;\n      TL.setLParenLoc(FTI.getLParenLoc());\n      TL.setRParenLoc(FTI.getRParenLoc());\n      for (unsigned i = 0, e = TL.getNumParams(), tpi = 0; i != e; ++i) {\n        ParmVarDecl *Param = cast<ParmVarDecl>(FTI.Params[i].Param);\n        TL.setParam(tpi++, Param);\n      }\n      TL.setExceptionSpecRange(FTI.getExceptionSpecRange());\n    }\n    void VisitParenTypeLoc(ParenTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Paren);\n      TL.setLParenLoc(Chunk.Loc);\n      TL.setRParenLoc(Chunk.EndLoc);\n    }\n    void VisitPipeTypeLoc(PipeTypeLoc TL) {\n      assert(Chunk.Kind == DeclaratorChunk::Pipe);\n      TL.setKWLoc(Chunk.Loc);\n    }\n    void VisitExtIntTypeLoc(ExtIntTypeLoc TL) {\n      TL.setNameLoc(Chunk.Loc);\n    }\n    void VisitMacroQualifiedTypeLoc(MacroQualifiedTypeLoc TL) {\n      TL.setExpansionLoc(Chunk.Loc);\n    }\n    void VisitVectorTypeLoc(VectorTypeLoc TL) { TL.setNameLoc(Chunk.Loc); }\n    void VisitDependentVectorTypeLoc(DependentVectorTypeLoc TL) {\n      TL.setNameLoc(Chunk.Loc);\n    }\n    void VisitExtVectorTypeLoc(ExtVectorTypeLoc TL) {\n      TL.setNameLoc(Chunk.Loc);\n    }\n    void\n    VisitDependentSizedExtVectorTypeLoc(DependentSizedExtVectorTypeLoc TL) {\n      TL.setNameLoc(Chunk.Loc);\n    }\n\n    void VisitTypeLoc(TypeLoc TL) {\n      llvm_unreachable(\"unsupported TypeLoc kind in declarator!\");\n    }\n  };\n} // end anonymous namespace\n\nstatic void fillAtomicQualLoc(AtomicTypeLoc ATL, const DeclaratorChunk &Chunk) {\n  SourceLocation Loc;\n  switch (Chunk.Kind) {\n  case DeclaratorChunk::Function:\n  case DeclaratorChunk::Array:\n  case DeclaratorChunk::Paren:\n  case DeclaratorChunk::Pipe:\n    llvm_unreachable(\"cannot be _Atomic qualified\");\n\n  case DeclaratorChunk::Pointer:\n    Loc = Chunk.Ptr.AtomicQualLoc;\n    break;\n\n  case DeclaratorChunk::BlockPointer:\n  case DeclaratorChunk::Reference:\n  case DeclaratorChunk::MemberPointer:\n    // FIXME: Provide a source location for the _Atomic keyword.\n    break;\n  }\n\n  ATL.setKWLoc(Loc);\n  ATL.setParensRange(SourceRange());\n}\n\nstatic void\nfillDependentAddressSpaceTypeLoc(DependentAddressSpaceTypeLoc DASTL,\n                                 const ParsedAttributesView &Attrs) {\n  for (const ParsedAttr &AL : Attrs) {\n    if (AL.getKind() == ParsedAttr::AT_AddressSpace) {\n      DASTL.setAttrNameLoc(AL.getLoc());\n      DASTL.setAttrExprOperand(AL.getArgAsExpr(0));\n      DASTL.setAttrOperandParensRange(SourceRange());\n      return;\n    }\n  }\n\n  llvm_unreachable(\n      \"no address_space attribute found at the expected location!\");\n}\n\nstatic void fillMatrixTypeLoc(MatrixTypeLoc MTL,\n                              const ParsedAttributesView &Attrs) {\n  for (const ParsedAttr &AL : Attrs) {\n    if (AL.getKind() == ParsedAttr::AT_MatrixType) {\n      MTL.setAttrNameLoc(AL.getLoc());\n      MTL.setAttrRowOperand(AL.getArgAsExpr(0));\n      MTL.setAttrColumnOperand(AL.getArgAsExpr(1));\n      MTL.setAttrOperandParensRange(SourceRange());\n      return;\n    }\n  }\n\n  llvm_unreachable(\"no matrix_type attribute found at the expected location!\");\n}\n\n/// Create and instantiate a TypeSourceInfo with type source information.\n///\n/// \\param T QualType referring to the type as written in source code.\n///\n/// \\param ReturnTypeInfo For declarators whose return type does not show\n/// up in the normal place in the declaration specifiers (such as a C++\n/// conversion function), this pointer will refer to a type source information\n/// for that return type.\nstatic TypeSourceInfo *\nGetTypeSourceInfoForDeclarator(TypeProcessingState &State,\n                               QualType T, TypeSourceInfo *ReturnTypeInfo) {\n  Sema &S = State.getSema();\n  Declarator &D = State.getDeclarator();\n\n  TypeSourceInfo *TInfo = S.Context.CreateTypeSourceInfo(T);\n  UnqualTypeLoc CurrTL = TInfo->getTypeLoc().getUnqualifiedLoc();\n\n  // Handle parameter packs whose type is a pack expansion.\n  if (isa<PackExpansionType>(T)) {\n    CurrTL.castAs<PackExpansionTypeLoc>().setEllipsisLoc(D.getEllipsisLoc());\n    CurrTL = CurrTL.getNextTypeLoc().getUnqualifiedLoc();\n  }\n\n  for (unsigned i = 0, e = D.getNumTypeObjects(); i != e; ++i) {\n    // An AtomicTypeLoc might be produced by an atomic qualifier in this\n    // declarator chunk.\n    if (AtomicTypeLoc ATL = CurrTL.getAs<AtomicTypeLoc>()) {\n      fillAtomicQualLoc(ATL, D.getTypeObject(i));\n      CurrTL = ATL.getValueLoc().getUnqualifiedLoc();\n    }\n\n    while (MacroQualifiedTypeLoc TL = CurrTL.getAs<MacroQualifiedTypeLoc>()) {\n      TL.setExpansionLoc(\n          State.getExpansionLocForMacroQualifiedType(TL.getTypePtr()));\n      CurrTL = TL.getNextTypeLoc().getUnqualifiedLoc();\n    }\n\n    while (AttributedTypeLoc TL = CurrTL.getAs<AttributedTypeLoc>()) {\n      fillAttributedTypeLoc(TL, State);\n      CurrTL = TL.getNextTypeLoc().getUnqualifiedLoc();\n    }\n\n    while (DependentAddressSpaceTypeLoc TL =\n               CurrTL.getAs<DependentAddressSpaceTypeLoc>()) {\n      fillDependentAddressSpaceTypeLoc(TL, D.getTypeObject(i).getAttrs());\n      CurrTL = TL.getPointeeTypeLoc().getUnqualifiedLoc();\n    }\n\n    if (MatrixTypeLoc TL = CurrTL.getAs<MatrixTypeLoc>())\n      fillMatrixTypeLoc(TL, D.getTypeObject(i).getAttrs());\n\n    // FIXME: Ordering here?\n    while (AdjustedTypeLoc TL = CurrTL.getAs<AdjustedTypeLoc>())\n      CurrTL = TL.getNextTypeLoc().getUnqualifiedLoc();\n\n    DeclaratorLocFiller(S.Context, State, D.getTypeObject(i)).Visit(CurrTL);\n    CurrTL = CurrTL.getNextTypeLoc().getUnqualifiedLoc();\n  }\n\n  // If we have different source information for the return type, use\n  // that.  This really only applies to C++ conversion functions.\n  if (ReturnTypeInfo) {\n    TypeLoc TL = ReturnTypeInfo->getTypeLoc();\n    assert(TL.getFullDataSize() == CurrTL.getFullDataSize());\n    memcpy(CurrTL.getOpaqueData(), TL.getOpaqueData(), TL.getFullDataSize());\n  } else {\n    TypeSpecLocFiller(S, S.Context, State, D.getDeclSpec()).Visit(CurrTL);\n  }\n\n  return TInfo;\n}\n\n/// Create a LocInfoType to hold the given QualType and TypeSourceInfo.\nParsedType Sema::CreateParsedType(QualType T, TypeSourceInfo *TInfo) {\n  // FIXME: LocInfoTypes are \"transient\", only needed for passing to/from Parser\n  // and Sema during declaration parsing. Try deallocating/caching them when\n  // it's appropriate, instead of allocating them and keeping them around.\n  LocInfoType *LocT = (LocInfoType*)BumpAlloc.Allocate(sizeof(LocInfoType),\n                                                       TypeAlignment);\n  new (LocT) LocInfoType(T, TInfo);\n  assert(LocT->getTypeClass() != T->getTypeClass() &&\n         \"LocInfoType's TypeClass conflicts with an existing Type class\");\n  return ParsedType::make(QualType(LocT, 0));\n}\n\nvoid LocInfoType::getAsStringInternal(std::string &Str,\n                                      const PrintingPolicy &Policy) const {\n  llvm_unreachable(\"LocInfoType leaked into the type system; an opaque TypeTy*\"\n         \" was used directly instead of getting the QualType through\"\n         \" GetTypeFromParser\");\n}\n\nTypeResult Sema::ActOnTypeName(Scope *S, Declarator &D) {\n  // C99 6.7.6: Type names have no identifier.  This is already validated by\n  // the parser.\n  assert(D.getIdentifier() == nullptr &&\n         \"Type name should have no identifier!\");\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType T = TInfo->getType();\n  if (D.isInvalidType())\n    return true;\n\n  // Make sure there are no unused decl attributes on the declarator.\n  // We don't want to do this for ObjC parameters because we're going\n  // to apply them to the actual parameter declaration.\n  // Likewise, we don't want to do this for alias declarations, because\n  // we are actually going to build a declaration from this eventually.\n  if (D.getContext() != DeclaratorContext::ObjCParameter &&\n      D.getContext() != DeclaratorContext::AliasDecl &&\n      D.getContext() != DeclaratorContext::AliasTemplate)\n    checkUnusedDeclAttributes(D);\n\n  if (getLangOpts().CPlusPlus) {\n    // Check that there are no default arguments (C++ only).\n    CheckExtraCXXDefaultArguments(D);\n  }\n\n  return CreateParsedType(T, TInfo);\n}\n\nParsedType Sema::ActOnObjCInstanceType(SourceLocation Loc) {\n  QualType T = Context.getObjCInstanceType();\n  TypeSourceInfo *TInfo = Context.getTrivialTypeSourceInfo(T, Loc);\n  return CreateParsedType(T, TInfo);\n}\n\n//===----------------------------------------------------------------------===//\n// Type Attribute Processing\n//===----------------------------------------------------------------------===//\n\n/// Build an AddressSpace index from a constant expression and diagnose any\n/// errors related to invalid address_spaces. Returns true on successfully\n/// building an AddressSpace index.\nstatic bool BuildAddressSpaceIndex(Sema &S, LangAS &ASIdx,\n                                   const Expr *AddrSpace,\n                                   SourceLocation AttrLoc) {\n  if (!AddrSpace->isValueDependent()) {\n    Optional<llvm::APSInt> OptAddrSpace =\n        AddrSpace->getIntegerConstantExpr(S.Context);\n    if (!OptAddrSpace) {\n      S.Diag(AttrLoc, diag::err_attribute_argument_type)\n          << \"'address_space'\" << AANT_ArgumentIntegerConstant\n          << AddrSpace->getSourceRange();\n      return false;\n    }\n    llvm::APSInt &addrSpace = *OptAddrSpace;\n\n    // Bounds checking.\n    if (addrSpace.isSigned()) {\n      if (addrSpace.isNegative()) {\n        S.Diag(AttrLoc, diag::err_attribute_address_space_negative)\n            << AddrSpace->getSourceRange();\n        return false;\n      }\n      addrSpace.setIsSigned(false);\n    }\n\n    llvm::APSInt max(addrSpace.getBitWidth());\n    max =\n        Qualifiers::MaxAddressSpace - (unsigned)LangAS::FirstTargetAddressSpace;\n    if (addrSpace > max) {\n      S.Diag(AttrLoc, diag::err_attribute_address_space_too_high)\n          << (unsigned)max.getZExtValue() << AddrSpace->getSourceRange();\n      return false;\n    }\n\n    ASIdx =\n        getLangASFromTargetAS(static_cast<unsigned>(addrSpace.getZExtValue()));\n    return true;\n  }\n\n  // Default value for DependentAddressSpaceTypes\n  ASIdx = LangAS::Default;\n  return true;\n}\n\n/// BuildAddressSpaceAttr - Builds a DependentAddressSpaceType if an expression\n/// is uninstantiated. If instantiated it will apply the appropriate address\n/// space to the type. This function allows dependent template variables to be\n/// used in conjunction with the address_space attribute\nQualType Sema::BuildAddressSpaceAttr(QualType &T, LangAS ASIdx, Expr *AddrSpace,\n                                     SourceLocation AttrLoc) {\n  if (!AddrSpace->isValueDependent()) {\n    if (DiagnoseMultipleAddrSpaceAttributes(*this, T.getAddressSpace(), ASIdx,\n                                            AttrLoc))\n      return QualType();\n\n    return Context.getAddrSpaceQualType(T, ASIdx);\n  }\n\n  // A check with similar intentions as checking if a type already has an\n  // address space except for on a dependent types, basically if the\n  // current type is already a DependentAddressSpaceType then its already\n  // lined up to have another address space on it and we can't have\n  // multiple address spaces on the one pointer indirection\n  if (T->getAs<DependentAddressSpaceType>()) {\n    Diag(AttrLoc, diag::err_attribute_address_multiple_qualifiers);\n    return QualType();\n  }\n\n  return Context.getDependentAddressSpaceType(T, AddrSpace, AttrLoc);\n}\n\nQualType Sema::BuildAddressSpaceAttr(QualType &T, Expr *AddrSpace,\n                                     SourceLocation AttrLoc) {\n  LangAS ASIdx;\n  if (!BuildAddressSpaceIndex(*this, ASIdx, AddrSpace, AttrLoc))\n    return QualType();\n  return BuildAddressSpaceAttr(T, ASIdx, AddrSpace, AttrLoc);\n}\n\n/// HandleAddressSpaceTypeAttribute - Process an address_space attribute on the\n/// specified type.  The attribute contains 1 argument, the id of the address\n/// space for the type.\nstatic void HandleAddressSpaceTypeAttribute(QualType &Type,\n                                            const ParsedAttr &Attr,\n                                            TypeProcessingState &State) {\n  Sema &S = State.getSema();\n\n  // ISO/IEC TR 18037 S5.3 (amending C99 6.7.3): \"A function type shall not be\n  // qualified by an address-space qualifier.\"\n  if (Type->isFunctionType()) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_address_function_type);\n    Attr.setInvalid();\n    return;\n  }\n\n  LangAS ASIdx;\n  if (Attr.getKind() == ParsedAttr::AT_AddressSpace) {\n\n    // Check the attribute arguments.\n    if (Attr.getNumArgs() != 1) {\n      S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments) << Attr\n                                                                        << 1;\n      Attr.setInvalid();\n      return;\n    }\n\n    Expr *ASArgExpr = static_cast<Expr *>(Attr.getArgAsExpr(0));\n    LangAS ASIdx;\n    if (!BuildAddressSpaceIndex(S, ASIdx, ASArgExpr, Attr.getLoc())) {\n      Attr.setInvalid();\n      return;\n    }\n\n    ASTContext &Ctx = S.Context;\n    auto *ASAttr =\n        ::new (Ctx) AddressSpaceAttr(Ctx, Attr, static_cast<unsigned>(ASIdx));\n\n    // If the expression is not value dependent (not templated), then we can\n    // apply the address space qualifiers just to the equivalent type.\n    // Otherwise, we make an AttributedType with the modified and equivalent\n    // type the same, and wrap it in a DependentAddressSpaceType. When this\n    // dependent type is resolved, the qualifier is added to the equivalent type\n    // later.\n    QualType T;\n    if (!ASArgExpr->isValueDependent()) {\n      QualType EquivType =\n          S.BuildAddressSpaceAttr(Type, ASIdx, ASArgExpr, Attr.getLoc());\n      if (EquivType.isNull()) {\n        Attr.setInvalid();\n        return;\n      }\n      T = State.getAttributedType(ASAttr, Type, EquivType);\n    } else {\n      T = State.getAttributedType(ASAttr, Type, Type);\n      T = S.BuildAddressSpaceAttr(T, ASIdx, ASArgExpr, Attr.getLoc());\n    }\n\n    if (!T.isNull())\n      Type = T;\n    else\n      Attr.setInvalid();\n  } else {\n    // The keyword-based type attributes imply which address space to use.\n    ASIdx = Attr.asOpenCLLangAS();\n    if (ASIdx == LangAS::Default)\n      llvm_unreachable(\"Invalid address space\");\n\n    if (DiagnoseMultipleAddrSpaceAttributes(S, Type.getAddressSpace(), ASIdx,\n                                            Attr.getLoc())) {\n      Attr.setInvalid();\n      return;\n    }\n\n    Type = S.Context.getAddrSpaceQualType(Type, ASIdx);\n  }\n}\n\n/// handleObjCOwnershipTypeAttr - Process an objc_ownership\n/// attribute on the specified type.\n///\n/// Returns 'true' if the attribute was handled.\nstatic bool handleObjCOwnershipTypeAttr(TypeProcessingState &state,\n                                        ParsedAttr &attr, QualType &type) {\n  bool NonObjCPointer = false;\n\n  if (!type->isDependentType() && !type->isUndeducedType()) {\n    if (const PointerType *ptr = type->getAs<PointerType>()) {\n      QualType pointee = ptr->getPointeeType();\n      if (pointee->isObjCRetainableType() || pointee->isPointerType())\n        return false;\n      // It is important not to lose the source info that there was an attribute\n      // applied to non-objc pointer. We will create an attributed type but\n      // its type will be the same as the original type.\n      NonObjCPointer = true;\n    } else if (!type->isObjCRetainableType()) {\n      return false;\n    }\n\n    // Don't accept an ownership attribute in the declspec if it would\n    // just be the return type of a block pointer.\n    if (state.isProcessingDeclSpec()) {\n      Declarator &D = state.getDeclarator();\n      if (maybeMovePastReturnType(D, D.getNumTypeObjects(),\n                                  /*onlyBlockPointers=*/true))\n        return false;\n    }\n  }\n\n  Sema &S = state.getSema();\n  SourceLocation AttrLoc = attr.getLoc();\n  if (AttrLoc.isMacroID())\n    AttrLoc =\n        S.getSourceManager().getImmediateExpansionRange(AttrLoc).getBegin();\n\n  if (!attr.isArgIdent(0)) {\n    S.Diag(AttrLoc, diag::err_attribute_argument_type) << attr\n                                                       << AANT_ArgumentString;\n    attr.setInvalid();\n    return true;\n  }\n\n  IdentifierInfo *II = attr.getArgAsIdent(0)->Ident;\n  Qualifiers::ObjCLifetime lifetime;\n  if (II->isStr(\"none\"))\n    lifetime = Qualifiers::OCL_ExplicitNone;\n  else if (II->isStr(\"strong\"))\n    lifetime = Qualifiers::OCL_Strong;\n  else if (II->isStr(\"weak\"))\n    lifetime = Qualifiers::OCL_Weak;\n  else if (II->isStr(\"autoreleasing\"))\n    lifetime = Qualifiers::OCL_Autoreleasing;\n  else {\n    S.Diag(AttrLoc, diag::warn_attribute_type_not_supported) << attr << II;\n    attr.setInvalid();\n    return true;\n  }\n\n  // Just ignore lifetime attributes other than __weak and __unsafe_unretained\n  // outside of ARC mode.\n  if (!S.getLangOpts().ObjCAutoRefCount &&\n      lifetime != Qualifiers::OCL_Weak &&\n      lifetime != Qualifiers::OCL_ExplicitNone) {\n    return true;\n  }\n\n  SplitQualType underlyingType = type.split();\n\n  // Check for redundant/conflicting ownership qualifiers.\n  if (Qualifiers::ObjCLifetime previousLifetime\n        = type.getQualifiers().getObjCLifetime()) {\n    // If it's written directly, that's an error.\n    if (S.Context.hasDirectOwnershipQualifier(type)) {\n      S.Diag(AttrLoc, diag::err_attr_objc_ownership_redundant)\n        << type;\n      return true;\n    }\n\n    // Otherwise, if the qualifiers actually conflict, pull sugar off\n    // and remove the ObjCLifetime qualifiers.\n    if (previousLifetime != lifetime) {\n      // It's possible to have multiple local ObjCLifetime qualifiers. We\n      // can't stop after we reach a type that is directly qualified.\n      const Type *prevTy = nullptr;\n      while (!prevTy || prevTy != underlyingType.Ty) {\n        prevTy = underlyingType.Ty;\n        underlyingType = underlyingType.getSingleStepDesugaredType();\n      }\n      underlyingType.Quals.removeObjCLifetime();\n    }\n  }\n\n  underlyingType.Quals.addObjCLifetime(lifetime);\n\n  if (NonObjCPointer) {\n    StringRef name = attr.getAttrName()->getName();\n    switch (lifetime) {\n    case Qualifiers::OCL_None:\n    case Qualifiers::OCL_ExplicitNone:\n      break;\n    case Qualifiers::OCL_Strong: name = \"__strong\"; break;\n    case Qualifiers::OCL_Weak: name = \"__weak\"; break;\n    case Qualifiers::OCL_Autoreleasing: name = \"__autoreleasing\"; break;\n    }\n    S.Diag(AttrLoc, diag::warn_type_attribute_wrong_type) << name\n      << TDS_ObjCObjOrBlock << type;\n  }\n\n  // Don't actually add the __unsafe_unretained qualifier in non-ARC files,\n  // because having both 'T' and '__unsafe_unretained T' exist in the type\n  // system causes unfortunate widespread consistency problems.  (For example,\n  // they're not considered compatible types, and we mangle them identicially\n  // as template arguments.)  These problems are all individually fixable,\n  // but it's easier to just not add the qualifier and instead sniff it out\n  // in specific places using isObjCInertUnsafeUnretainedType().\n  //\n  // Doing this does means we miss some trivial consistency checks that\n  // would've triggered in ARC, but that's better than trying to solve all\n  // the coexistence problems with __unsafe_unretained.\n  if (!S.getLangOpts().ObjCAutoRefCount &&\n      lifetime == Qualifiers::OCL_ExplicitNone) {\n    type = state.getAttributedType(\n        createSimpleAttr<ObjCInertUnsafeUnretainedAttr>(S.Context, attr),\n        type, type);\n    return true;\n  }\n\n  QualType origType = type;\n  if (!NonObjCPointer)\n    type = S.Context.getQualifiedType(underlyingType);\n\n  // If we have a valid source location for the attribute, use an\n  // AttributedType instead.\n  if (AttrLoc.isValid()) {\n    type = state.getAttributedType(::new (S.Context)\n                                       ObjCOwnershipAttr(S.Context, attr, II),\n                                   origType, type);\n  }\n\n  auto diagnoseOrDelay = [](Sema &S, SourceLocation loc,\n                            unsigned diagnostic, QualType type) {\n    if (S.DelayedDiagnostics.shouldDelayDiagnostics()) {\n      S.DelayedDiagnostics.add(\n          sema::DelayedDiagnostic::makeForbiddenType(\n              S.getSourceManager().getExpansionLoc(loc),\n              diagnostic, type, /*ignored*/ 0));\n    } else {\n      S.Diag(loc, diagnostic);\n    }\n  };\n\n  // Sometimes, __weak isn't allowed.\n  if (lifetime == Qualifiers::OCL_Weak &&\n      !S.getLangOpts().ObjCWeak && !NonObjCPointer) {\n\n    // Use a specialized diagnostic if the runtime just doesn't support them.\n    unsigned diagnostic =\n      (S.getLangOpts().ObjCWeakRuntime ? diag::err_arc_weak_disabled\n                                       : diag::err_arc_weak_no_runtime);\n\n    // In any case, delay the diagnostic until we know what we're parsing.\n    diagnoseOrDelay(S, AttrLoc, diagnostic, type);\n\n    attr.setInvalid();\n    return true;\n  }\n\n  // Forbid __weak for class objects marked as\n  // objc_arc_weak_reference_unavailable\n  if (lifetime == Qualifiers::OCL_Weak) {\n    if (const ObjCObjectPointerType *ObjT =\n          type->getAs<ObjCObjectPointerType>()) {\n      if (ObjCInterfaceDecl *Class = ObjT->getInterfaceDecl()) {\n        if (Class->isArcWeakrefUnavailable()) {\n          S.Diag(AttrLoc, diag::err_arc_unsupported_weak_class);\n          S.Diag(ObjT->getInterfaceDecl()->getLocation(),\n                 diag::note_class_declared);\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n/// handleObjCGCTypeAttr - Process the __attribute__((objc_gc)) type\n/// attribute on the specified type.  Returns true to indicate that\n/// the attribute was handled, false to indicate that the type does\n/// not permit the attribute.\nstatic bool handleObjCGCTypeAttr(TypeProcessingState &state, ParsedAttr &attr,\n                                 QualType &type) {\n  Sema &S = state.getSema();\n\n  // Delay if this isn't some kind of pointer.\n  if (!type->isPointerType() &&\n      !type->isObjCObjectPointerType() &&\n      !type->isBlockPointerType())\n    return false;\n\n  if (type.getObjCGCAttr() != Qualifiers::GCNone) {\n    S.Diag(attr.getLoc(), diag::err_attribute_multiple_objc_gc);\n    attr.setInvalid();\n    return true;\n  }\n\n  // Check the attribute arguments.\n  if (!attr.isArgIdent(0)) {\n    S.Diag(attr.getLoc(), diag::err_attribute_argument_type)\n        << attr << AANT_ArgumentString;\n    attr.setInvalid();\n    return true;\n  }\n  Qualifiers::GC GCAttr;\n  if (attr.getNumArgs() > 1) {\n    S.Diag(attr.getLoc(), diag::err_attribute_wrong_number_arguments) << attr\n                                                                      << 1;\n    attr.setInvalid();\n    return true;\n  }\n\n  IdentifierInfo *II = attr.getArgAsIdent(0)->Ident;\n  if (II->isStr(\"weak\"))\n    GCAttr = Qualifiers::Weak;\n  else if (II->isStr(\"strong\"))\n    GCAttr = Qualifiers::Strong;\n  else {\n    S.Diag(attr.getLoc(), diag::warn_attribute_type_not_supported)\n        << attr << II;\n    attr.setInvalid();\n    return true;\n  }\n\n  QualType origType = type;\n  type = S.Context.getObjCGCQualType(origType, GCAttr);\n\n  // Make an attributed type to preserve the source information.\n  if (attr.getLoc().isValid())\n    type = state.getAttributedType(\n        ::new (S.Context) ObjCGCAttr(S.Context, attr, II), origType, type);\n\n  return true;\n}\n\nnamespace {\n  /// A helper class to unwrap a type down to a function for the\n  /// purposes of applying attributes there.\n  ///\n  /// Use:\n  ///   FunctionTypeUnwrapper unwrapped(SemaRef, T);\n  ///   if (unwrapped.isFunctionType()) {\n  ///     const FunctionType *fn = unwrapped.get();\n  ///     // change fn somehow\n  ///     T = unwrapped.wrap(fn);\n  ///   }\n  struct FunctionTypeUnwrapper {\n    enum WrapKind {\n      Desugar,\n      Attributed,\n      Parens,\n      Array,\n      Pointer,\n      BlockPointer,\n      Reference,\n      MemberPointer,\n      MacroQualified,\n    };\n\n    QualType Original;\n    const FunctionType *Fn;\n    SmallVector<unsigned char /*WrapKind*/, 8> Stack;\n\n    FunctionTypeUnwrapper(Sema &S, QualType T) : Original(T) {\n      while (true) {\n        const Type *Ty = T.getTypePtr();\n        if (isa<FunctionType>(Ty)) {\n          Fn = cast<FunctionType>(Ty);\n          return;\n        } else if (isa<ParenType>(Ty)) {\n          T = cast<ParenType>(Ty)->getInnerType();\n          Stack.push_back(Parens);\n        } else if (isa<ConstantArrayType>(Ty) || isa<VariableArrayType>(Ty) ||\n                   isa<IncompleteArrayType>(Ty)) {\n          T = cast<ArrayType>(Ty)->getElementType();\n          Stack.push_back(Array);\n        } else if (isa<PointerType>(Ty)) {\n          T = cast<PointerType>(Ty)->getPointeeType();\n          Stack.push_back(Pointer);\n        } else if (isa<BlockPointerType>(Ty)) {\n          T = cast<BlockPointerType>(Ty)->getPointeeType();\n          Stack.push_back(BlockPointer);\n        } else if (isa<MemberPointerType>(Ty)) {\n          T = cast<MemberPointerType>(Ty)->getPointeeType();\n          Stack.push_back(MemberPointer);\n        } else if (isa<ReferenceType>(Ty)) {\n          T = cast<ReferenceType>(Ty)->getPointeeType();\n          Stack.push_back(Reference);\n        } else if (isa<AttributedType>(Ty)) {\n          T = cast<AttributedType>(Ty)->getEquivalentType();\n          Stack.push_back(Attributed);\n        } else if (isa<MacroQualifiedType>(Ty)) {\n          T = cast<MacroQualifiedType>(Ty)->getUnderlyingType();\n          Stack.push_back(MacroQualified);\n        } else {\n          const Type *DTy = Ty->getUnqualifiedDesugaredType();\n          if (Ty == DTy) {\n            Fn = nullptr;\n            return;\n          }\n\n          T = QualType(DTy, 0);\n          Stack.push_back(Desugar);\n        }\n      }\n    }\n\n    bool isFunctionType() const { return (Fn != nullptr); }\n    const FunctionType *get() const { return Fn; }\n\n    QualType wrap(Sema &S, const FunctionType *New) {\n      // If T wasn't modified from the unwrapped type, do nothing.\n      if (New == get()) return Original;\n\n      Fn = New;\n      return wrap(S.Context, Original, 0);\n    }\n\n  private:\n    QualType wrap(ASTContext &C, QualType Old, unsigned I) {\n      if (I == Stack.size())\n        return C.getQualifiedType(Fn, Old.getQualifiers());\n\n      // Build up the inner type, applying the qualifiers from the old\n      // type to the new type.\n      SplitQualType SplitOld = Old.split();\n\n      // As a special case, tail-recurse if there are no qualifiers.\n      if (SplitOld.Quals.empty())\n        return wrap(C, SplitOld.Ty, I);\n      return C.getQualifiedType(wrap(C, SplitOld.Ty, I), SplitOld.Quals);\n    }\n\n    QualType wrap(ASTContext &C, const Type *Old, unsigned I) {\n      if (I == Stack.size()) return QualType(Fn, 0);\n\n      switch (static_cast<WrapKind>(Stack[I++])) {\n      case Desugar:\n        // This is the point at which we potentially lose source\n        // information.\n        return wrap(C, Old->getUnqualifiedDesugaredType(), I);\n\n      case Attributed:\n        return wrap(C, cast<AttributedType>(Old)->getEquivalentType(), I);\n\n      case Parens: {\n        QualType New = wrap(C, cast<ParenType>(Old)->getInnerType(), I);\n        return C.getParenType(New);\n      }\n\n      case MacroQualified:\n        return wrap(C, cast<MacroQualifiedType>(Old)->getUnderlyingType(), I);\n\n      case Array: {\n        if (const auto *CAT = dyn_cast<ConstantArrayType>(Old)) {\n          QualType New = wrap(C, CAT->getElementType(), I);\n          return C.getConstantArrayType(New, CAT->getSize(), CAT->getSizeExpr(),\n                                        CAT->getSizeModifier(),\n                                        CAT->getIndexTypeCVRQualifiers());\n        }\n\n        if (const auto *VAT = dyn_cast<VariableArrayType>(Old)) {\n          QualType New = wrap(C, VAT->getElementType(), I);\n          return C.getVariableArrayType(\n              New, VAT->getSizeExpr(), VAT->getSizeModifier(),\n              VAT->getIndexTypeCVRQualifiers(), VAT->getBracketsRange());\n        }\n\n        const auto *IAT = cast<IncompleteArrayType>(Old);\n        QualType New = wrap(C, IAT->getElementType(), I);\n        return C.getIncompleteArrayType(New, IAT->getSizeModifier(),\n                                        IAT->getIndexTypeCVRQualifiers());\n      }\n\n      case Pointer: {\n        QualType New = wrap(C, cast<PointerType>(Old)->getPointeeType(), I);\n        return C.getPointerType(New);\n      }\n\n      case BlockPointer: {\n        QualType New = wrap(C, cast<BlockPointerType>(Old)->getPointeeType(),I);\n        return C.getBlockPointerType(New);\n      }\n\n      case MemberPointer: {\n        const MemberPointerType *OldMPT = cast<MemberPointerType>(Old);\n        QualType New = wrap(C, OldMPT->getPointeeType(), I);\n        return C.getMemberPointerType(New, OldMPT->getClass());\n      }\n\n      case Reference: {\n        const ReferenceType *OldRef = cast<ReferenceType>(Old);\n        QualType New = wrap(C, OldRef->getPointeeType(), I);\n        if (isa<LValueReferenceType>(OldRef))\n          return C.getLValueReferenceType(New, OldRef->isSpelledAsLValue());\n        else\n          return C.getRValueReferenceType(New);\n      }\n      }\n\n      llvm_unreachable(\"unknown wrapping kind\");\n    }\n  };\n} // end anonymous namespace\n\nstatic bool handleMSPointerTypeQualifierAttr(TypeProcessingState &State,\n                                             ParsedAttr &PAttr, QualType &Type) {\n  Sema &S = State.getSema();\n\n  Attr *A;\n  switch (PAttr.getKind()) {\n  default: llvm_unreachable(\"Unknown attribute kind\");\n  case ParsedAttr::AT_Ptr32:\n    A = createSimpleAttr<Ptr32Attr>(S.Context, PAttr);\n    break;\n  case ParsedAttr::AT_Ptr64:\n    A = createSimpleAttr<Ptr64Attr>(S.Context, PAttr);\n    break;\n  case ParsedAttr::AT_SPtr:\n    A = createSimpleAttr<SPtrAttr>(S.Context, PAttr);\n    break;\n  case ParsedAttr::AT_UPtr:\n    A = createSimpleAttr<UPtrAttr>(S.Context, PAttr);\n    break;\n  }\n\n  std::bitset<attr::LastAttr> Attrs;\n  attr::Kind NewAttrKind = A->getKind();\n  QualType Desugared = Type;\n  const AttributedType *AT = dyn_cast<AttributedType>(Type);\n  while (AT) {\n    Attrs[AT->getAttrKind()] = true;\n    Desugared = AT->getModifiedType();\n    AT = dyn_cast<AttributedType>(Desugared);\n  }\n\n  // You cannot specify duplicate type attributes, so if the attribute has\n  // already been applied, flag it.\n  if (Attrs[NewAttrKind]) {\n    S.Diag(PAttr.getLoc(), diag::warn_duplicate_attribute_exact) << PAttr;\n    return true;\n  }\n  Attrs[NewAttrKind] = true;\n\n  // You cannot have both __sptr and __uptr on the same type, nor can you\n  // have __ptr32 and __ptr64.\n  if (Attrs[attr::Ptr32] && Attrs[attr::Ptr64]) {\n    S.Diag(PAttr.getLoc(), diag::err_attributes_are_not_compatible)\n        << \"'__ptr32'\"\n        << \"'__ptr64'\";\n    return true;\n  } else if (Attrs[attr::SPtr] && Attrs[attr::UPtr]) {\n    S.Diag(PAttr.getLoc(), diag::err_attributes_are_not_compatible)\n        << \"'__sptr'\"\n        << \"'__uptr'\";\n    return true;\n  }\n\n  // Pointer type qualifiers can only operate on pointer types, but not\n  // pointer-to-member types.\n  //\n  // FIXME: Should we really be disallowing this attribute if there is any\n  // type sugar between it and the pointer (other than attributes)? Eg, this\n  // disallows the attribute on a parenthesized pointer.\n  // And if so, should we really allow *any* type attribute?\n  if (!isa<PointerType>(Desugared)) {\n    if (Type->isMemberPointerType())\n      S.Diag(PAttr.getLoc(), diag::err_attribute_no_member_pointers) << PAttr;\n    else\n      S.Diag(PAttr.getLoc(), diag::err_attribute_pointers_only) << PAttr << 0;\n    return true;\n  }\n\n  // Add address space to type based on its attributes.\n  LangAS ASIdx = LangAS::Default;\n  uint64_t PtrWidth = S.Context.getTargetInfo().getPointerWidth(0);\n  if (PtrWidth == 32) {\n    if (Attrs[attr::Ptr64])\n      ASIdx = LangAS::ptr64;\n    else if (Attrs[attr::UPtr])\n      ASIdx = LangAS::ptr32_uptr;\n  } else if (PtrWidth == 64 && Attrs[attr::Ptr32]) {\n    if (Attrs[attr::UPtr])\n      ASIdx = LangAS::ptr32_uptr;\n    else\n      ASIdx = LangAS::ptr32_sptr;\n  }\n\n  QualType Pointee = Type->getPointeeType();\n  if (ASIdx != LangAS::Default)\n    Pointee = S.Context.getAddrSpaceQualType(\n        S.Context.removeAddrSpaceQualType(Pointee), ASIdx);\n  Type = State.getAttributedType(A, Type, S.Context.getPointerType(Pointee));\n  return false;\n}\n\n/// Map a nullability attribute kind to a nullability kind.\nstatic NullabilityKind mapNullabilityAttrKind(ParsedAttr::Kind kind) {\n  switch (kind) {\n  case ParsedAttr::AT_TypeNonNull:\n    return NullabilityKind::NonNull;\n\n  case ParsedAttr::AT_TypeNullable:\n    return NullabilityKind::Nullable;\n\n  case ParsedAttr::AT_TypeNullableResult:\n    return NullabilityKind::NullableResult;\n\n  case ParsedAttr::AT_TypeNullUnspecified:\n    return NullabilityKind::Unspecified;\n\n  default:\n    llvm_unreachable(\"not a nullability attribute kind\");\n  }\n}\n\n/// Applies a nullability type specifier to the given type, if possible.\n///\n/// \\param state The type processing state.\n///\n/// \\param type The type to which the nullability specifier will be\n/// added. On success, this type will be updated appropriately.\n///\n/// \\param attr The attribute as written on the type.\n///\n/// \\param allowOnArrayType Whether to accept nullability specifiers on an\n/// array type (e.g., because it will decay to a pointer).\n///\n/// \\returns true if a problem has been diagnosed, false on success.\nstatic bool checkNullabilityTypeSpecifier(TypeProcessingState &state,\n                                          QualType &type,\n                                          ParsedAttr &attr,\n                                          bool allowOnArrayType) {\n  Sema &S = state.getSema();\n\n  NullabilityKind nullability = mapNullabilityAttrKind(attr.getKind());\n  SourceLocation nullabilityLoc = attr.getLoc();\n  bool isContextSensitive = attr.isContextSensitiveKeywordAttribute();\n\n  recordNullabilitySeen(S, nullabilityLoc);\n\n  // Check for existing nullability attributes on the type.\n  QualType desugared = type;\n  while (auto attributed = dyn_cast<AttributedType>(desugared.getTypePtr())) {\n    // Check whether there is already a null\n    if (auto existingNullability = attributed->getImmediateNullability()) {\n      // Duplicated nullability.\n      if (nullability == *existingNullability) {\n        S.Diag(nullabilityLoc, diag::warn_nullability_duplicate)\n          << DiagNullabilityKind(nullability, isContextSensitive)\n          << FixItHint::CreateRemoval(nullabilityLoc);\n\n        break;\n      }\n\n      // Conflicting nullability.\n      S.Diag(nullabilityLoc, diag::err_nullability_conflicting)\n        << DiagNullabilityKind(nullability, isContextSensitive)\n        << DiagNullabilityKind(*existingNullability, false);\n      return true;\n    }\n\n    desugared = attributed->getModifiedType();\n  }\n\n  // If there is already a different nullability specifier, complain.\n  // This (unlike the code above) looks through typedefs that might\n  // have nullability specifiers on them, which means we cannot\n  // provide a useful Fix-It.\n  if (auto existingNullability = desugared->getNullability(S.Context)) {\n    if (nullability != *existingNullability) {\n      S.Diag(nullabilityLoc, diag::err_nullability_conflicting)\n        << DiagNullabilityKind(nullability, isContextSensitive)\n        << DiagNullabilityKind(*existingNullability, false);\n\n      // Try to find the typedef with the existing nullability specifier.\n      if (auto typedefType = desugared->getAs<TypedefType>()) {\n        TypedefNameDecl *typedefDecl = typedefType->getDecl();\n        QualType underlyingType = typedefDecl->getUnderlyingType();\n        if (auto typedefNullability\n              = AttributedType::stripOuterNullability(underlyingType)) {\n          if (*typedefNullability == *existingNullability) {\n            S.Diag(typedefDecl->getLocation(), diag::note_nullability_here)\n              << DiagNullabilityKind(*existingNullability, false);\n          }\n        }\n      }\n\n      return true;\n    }\n  }\n\n  // If this definitely isn't a pointer type, reject the specifier.\n  if (!desugared->canHaveNullability() &&\n      !(allowOnArrayType && desugared->isArrayType())) {\n    S.Diag(nullabilityLoc, diag::err_nullability_nonpointer)\n      << DiagNullabilityKind(nullability, isContextSensitive) << type;\n    return true;\n  }\n\n  // For the context-sensitive keywords/Objective-C property\n  // attributes, require that the type be a single-level pointer.\n  if (isContextSensitive) {\n    // Make sure that the pointee isn't itself a pointer type.\n    const Type *pointeeType = nullptr;\n    if (desugared->isArrayType())\n      pointeeType = desugared->getArrayElementTypeNoTypeQual();\n    else if (desugared->isAnyPointerType())\n      pointeeType = desugared->getPointeeType().getTypePtr();\n\n    if (pointeeType && (pointeeType->isAnyPointerType() ||\n                        pointeeType->isObjCObjectPointerType() ||\n                        pointeeType->isMemberPointerType())) {\n      S.Diag(nullabilityLoc, diag::err_nullability_cs_multilevel)\n        << DiagNullabilityKind(nullability, true)\n        << type;\n      S.Diag(nullabilityLoc, diag::note_nullability_type_specifier)\n        << DiagNullabilityKind(nullability, false)\n        << type\n        << FixItHint::CreateReplacement(nullabilityLoc,\n                                        getNullabilitySpelling(nullability));\n      return true;\n    }\n  }\n\n  // Form the attributed type.\n  type = state.getAttributedType(\n      createNullabilityAttr(S.Context, attr, nullability), type, type);\n  return false;\n}\n\n/// Check the application of the Objective-C '__kindof' qualifier to\n/// the given type.\nstatic bool checkObjCKindOfType(TypeProcessingState &state, QualType &type,\n                                ParsedAttr &attr) {\n  Sema &S = state.getSema();\n\n  if (isa<ObjCTypeParamType>(type)) {\n    // Build the attributed type to record where __kindof occurred.\n    type = state.getAttributedType(\n        createSimpleAttr<ObjCKindOfAttr>(S.Context, attr), type, type);\n    return false;\n  }\n\n  // Find out if it's an Objective-C object or object pointer type;\n  const ObjCObjectPointerType *ptrType = type->getAs<ObjCObjectPointerType>();\n  const ObjCObjectType *objType = ptrType ? ptrType->getObjectType()\n                                          : type->getAs<ObjCObjectType>();\n\n  // If not, we can't apply __kindof.\n  if (!objType) {\n    // FIXME: Handle dependent types that aren't yet object types.\n    S.Diag(attr.getLoc(), diag::err_objc_kindof_nonobject)\n      << type;\n    return true;\n  }\n\n  // Rebuild the \"equivalent\" type, which pushes __kindof down into\n  // the object type.\n  // There is no need to apply kindof on an unqualified id type.\n  QualType equivType = S.Context.getObjCObjectType(\n      objType->getBaseType(), objType->getTypeArgsAsWritten(),\n      objType->getProtocols(),\n      /*isKindOf=*/objType->isObjCUnqualifiedId() ? false : true);\n\n  // If we started with an object pointer type, rebuild it.\n  if (ptrType) {\n    equivType = S.Context.getObjCObjectPointerType(equivType);\n    if (auto nullability = type->getNullability(S.Context)) {\n      // We create a nullability attribute from the __kindof attribute.\n      // Make sure that will make sense.\n      assert(attr.getAttributeSpellingListIndex() == 0 &&\n             \"multiple spellings for __kindof?\");\n      Attr *A = createNullabilityAttr(S.Context, attr, *nullability);\n      A->setImplicit(true);\n      equivType = state.getAttributedType(A, equivType, equivType);\n    }\n  }\n\n  // Build the attributed type to record where __kindof occurred.\n  type = state.getAttributedType(\n      createSimpleAttr<ObjCKindOfAttr>(S.Context, attr), type, equivType);\n  return false;\n}\n\n/// Distribute a nullability type attribute that cannot be applied to\n/// the type specifier to a pointer, block pointer, or member pointer\n/// declarator, complaining if necessary.\n///\n/// \\returns true if the nullability annotation was distributed, false\n/// otherwise.\nstatic bool distributeNullabilityTypeAttr(TypeProcessingState &state,\n                                          QualType type, ParsedAttr &attr) {\n  Declarator &declarator = state.getDeclarator();\n\n  /// Attempt to move the attribute to the specified chunk.\n  auto moveToChunk = [&](DeclaratorChunk &chunk, bool inFunction) -> bool {\n    // If there is already a nullability attribute there, don't add\n    // one.\n    if (hasNullabilityAttr(chunk.getAttrs()))\n      return false;\n\n    // Complain about the nullability qualifier being in the wrong\n    // place.\n    enum {\n      PK_Pointer,\n      PK_BlockPointer,\n      PK_MemberPointer,\n      PK_FunctionPointer,\n      PK_MemberFunctionPointer,\n    } pointerKind\n      = chunk.Kind == DeclaratorChunk::Pointer ? (inFunction ? PK_FunctionPointer\n                                                             : PK_Pointer)\n        : chunk.Kind == DeclaratorChunk::BlockPointer ? PK_BlockPointer\n        : inFunction? PK_MemberFunctionPointer : PK_MemberPointer;\n\n    auto diag = state.getSema().Diag(attr.getLoc(),\n                                     diag::warn_nullability_declspec)\n      << DiagNullabilityKind(mapNullabilityAttrKind(attr.getKind()),\n                             attr.isContextSensitiveKeywordAttribute())\n      << type\n      << static_cast<unsigned>(pointerKind);\n\n    // FIXME: MemberPointer chunks don't carry the location of the *.\n    if (chunk.Kind != DeclaratorChunk::MemberPointer) {\n      diag << FixItHint::CreateRemoval(attr.getLoc())\n           << FixItHint::CreateInsertion(\n                  state.getSema().getPreprocessor().getLocForEndOfToken(\n                      chunk.Loc),\n                  \" \" + attr.getAttrName()->getName().str() + \" \");\n    }\n\n    moveAttrFromListToList(attr, state.getCurrentAttributes(),\n                           chunk.getAttrs());\n    return true;\n  };\n\n  // Move it to the outermost pointer, member pointer, or block\n  // pointer declarator.\n  for (unsigned i = state.getCurrentChunkIndex(); i != 0; --i) {\n    DeclaratorChunk &chunk = declarator.getTypeObject(i-1);\n    switch (chunk.Kind) {\n    case DeclaratorChunk::Pointer:\n    case DeclaratorChunk::BlockPointer:\n    case DeclaratorChunk::MemberPointer:\n      return moveToChunk(chunk, false);\n\n    case DeclaratorChunk::Paren:\n    case DeclaratorChunk::Array:\n      continue;\n\n    case DeclaratorChunk::Function:\n      // Try to move past the return type to a function/block/member\n      // function pointer.\n      if (DeclaratorChunk *dest = maybeMovePastReturnType(\n                                    declarator, i,\n                                    /*onlyBlockPointers=*/false)) {\n        return moveToChunk(*dest, true);\n      }\n\n      return false;\n\n    // Don't walk through these.\n    case DeclaratorChunk::Reference:\n    case DeclaratorChunk::Pipe:\n      return false;\n    }\n  }\n\n  return false;\n}\n\nstatic Attr *getCCTypeAttr(ASTContext &Ctx, ParsedAttr &Attr) {\n  assert(!Attr.isInvalid());\n  switch (Attr.getKind()) {\n  default:\n    llvm_unreachable(\"not a calling convention attribute\");\n  case ParsedAttr::AT_CDecl:\n    return createSimpleAttr<CDeclAttr>(Ctx, Attr);\n  case ParsedAttr::AT_FastCall:\n    return createSimpleAttr<FastCallAttr>(Ctx, Attr);\n  case ParsedAttr::AT_StdCall:\n    return createSimpleAttr<StdCallAttr>(Ctx, Attr);\n  case ParsedAttr::AT_ThisCall:\n    return createSimpleAttr<ThisCallAttr>(Ctx, Attr);\n  case ParsedAttr::AT_RegCall:\n    return createSimpleAttr<RegCallAttr>(Ctx, Attr);\n  case ParsedAttr::AT_Pascal:\n    return createSimpleAttr<PascalAttr>(Ctx, Attr);\n  case ParsedAttr::AT_SwiftCall:\n    return createSimpleAttr<SwiftCallAttr>(Ctx, Attr);\n  case ParsedAttr::AT_VectorCall:\n    return createSimpleAttr<VectorCallAttr>(Ctx, Attr);\n  case ParsedAttr::AT_AArch64VectorPcs:\n    return createSimpleAttr<AArch64VectorPcsAttr>(Ctx, Attr);\n  case ParsedAttr::AT_Pcs: {\n    // The attribute may have had a fixit applied where we treated an\n    // identifier as a string literal.  The contents of the string are valid,\n    // but the form may not be.\n    StringRef Str;\n    if (Attr.isArgExpr(0))\n      Str = cast<StringLiteral>(Attr.getArgAsExpr(0))->getString();\n    else\n      Str = Attr.getArgAsIdent(0)->Ident->getName();\n    PcsAttr::PCSType Type;\n    if (!PcsAttr::ConvertStrToPCSType(Str, Type))\n      llvm_unreachable(\"already validated the attribute\");\n    return ::new (Ctx) PcsAttr(Ctx, Attr, Type);\n  }\n  case ParsedAttr::AT_IntelOclBicc:\n    return createSimpleAttr<IntelOclBiccAttr>(Ctx, Attr);\n  case ParsedAttr::AT_MSABI:\n    return createSimpleAttr<MSABIAttr>(Ctx, Attr);\n  case ParsedAttr::AT_SysVABI:\n    return createSimpleAttr<SysVABIAttr>(Ctx, Attr);\n  case ParsedAttr::AT_PreserveMost:\n    return createSimpleAttr<PreserveMostAttr>(Ctx, Attr);\n  case ParsedAttr::AT_PreserveAll:\n    return createSimpleAttr<PreserveAllAttr>(Ctx, Attr);\n  }\n  llvm_unreachable(\"unexpected attribute kind!\");\n}\n\n/// Process an individual function attribute.  Returns true to\n/// indicate that the attribute was handled, false if it wasn't.\nstatic bool handleFunctionTypeAttr(TypeProcessingState &state, ParsedAttr &attr,\n                                   QualType &type) {\n  Sema &S = state.getSema();\n\n  FunctionTypeUnwrapper unwrapped(S, type);\n\n  if (attr.getKind() == ParsedAttr::AT_NoReturn) {\n    if (S.CheckAttrNoArgs(attr))\n      return true;\n\n    // Delay if this is not a function type.\n    if (!unwrapped.isFunctionType())\n      return false;\n\n    // Otherwise we can process right away.\n    FunctionType::ExtInfo EI = unwrapped.get()->getExtInfo().withNoReturn(true);\n    type = unwrapped.wrap(S, S.Context.adjustFunctionType(unwrapped.get(), EI));\n    return true;\n  }\n\n  if (attr.getKind() == ParsedAttr::AT_CmseNSCall) {\n    // Delay if this is not a function type.\n    if (!unwrapped.isFunctionType())\n      return false;\n\n    // Ignore if we don't have CMSE enabled.\n    if (!S.getLangOpts().Cmse) {\n      S.Diag(attr.getLoc(), diag::warn_attribute_ignored) << attr;\n      attr.setInvalid();\n      return true;\n    }\n\n    // Otherwise we can process right away.\n    FunctionType::ExtInfo EI =\n        unwrapped.get()->getExtInfo().withCmseNSCall(true);\n    type = unwrapped.wrap(S, S.Context.adjustFunctionType(unwrapped.get(), EI));\n    return true;\n  }\n\n  // ns_returns_retained is not always a type attribute, but if we got\n  // here, we're treating it as one right now.\n  if (attr.getKind() == ParsedAttr::AT_NSReturnsRetained) {\n    if (attr.getNumArgs()) return true;\n\n    // Delay if this is not a function type.\n    if (!unwrapped.isFunctionType())\n      return false;\n\n    // Check whether the return type is reasonable.\n    if (S.checkNSReturnsRetainedReturnType(attr.getLoc(),\n                                           unwrapped.get()->getReturnType()))\n      return true;\n\n    // Only actually change the underlying type in ARC builds.\n    QualType origType = type;\n    if (state.getSema().getLangOpts().ObjCAutoRefCount) {\n      FunctionType::ExtInfo EI\n        = unwrapped.get()->getExtInfo().withProducesResult(true);\n      type = unwrapped.wrap(S, S.Context.adjustFunctionType(unwrapped.get(), EI));\n    }\n    type = state.getAttributedType(\n        createSimpleAttr<NSReturnsRetainedAttr>(S.Context, attr),\n        origType, type);\n    return true;\n  }\n\n  if (attr.getKind() == ParsedAttr::AT_AnyX86NoCallerSavedRegisters) {\n    if (S.CheckAttrTarget(attr) || S.CheckAttrNoArgs(attr))\n      return true;\n\n    // Delay if this is not a function type.\n    if (!unwrapped.isFunctionType())\n      return false;\n\n    FunctionType::ExtInfo EI =\n        unwrapped.get()->getExtInfo().withNoCallerSavedRegs(true);\n    type = unwrapped.wrap(S, S.Context.adjustFunctionType(unwrapped.get(), EI));\n    return true;\n  }\n\n  if (attr.getKind() == ParsedAttr::AT_AnyX86NoCfCheck) {\n    if (!S.getLangOpts().CFProtectionBranch) {\n      S.Diag(attr.getLoc(), diag::warn_nocf_check_attribute_ignored);\n      attr.setInvalid();\n      return true;\n    }\n\n    if (S.CheckAttrTarget(attr) || S.CheckAttrNoArgs(attr))\n      return true;\n\n    // If this is not a function type, warning will be asserted by subject\n    // check.\n    if (!unwrapped.isFunctionType())\n      return true;\n\n    FunctionType::ExtInfo EI =\n      unwrapped.get()->getExtInfo().withNoCfCheck(true);\n    type = unwrapped.wrap(S, S.Context.adjustFunctionType(unwrapped.get(), EI));\n    return true;\n  }\n\n  if (attr.getKind() == ParsedAttr::AT_Regparm) {\n    unsigned value;\n    if (S.CheckRegparmAttr(attr, value))\n      return true;\n\n    // Delay if this is not a function type.\n    if (!unwrapped.isFunctionType())\n      return false;\n\n    // Diagnose regparm with fastcall.\n    const FunctionType *fn = unwrapped.get();\n    CallingConv CC = fn->getCallConv();\n    if (CC == CC_X86FastCall) {\n      S.Diag(attr.getLoc(), diag::err_attributes_are_not_compatible)\n        << FunctionType::getNameForCallConv(CC)\n        << \"regparm\";\n      attr.setInvalid();\n      return true;\n    }\n\n    FunctionType::ExtInfo EI =\n      unwrapped.get()->getExtInfo().withRegParm(value);\n    type = unwrapped.wrap(S, S.Context.adjustFunctionType(unwrapped.get(), EI));\n    return true;\n  }\n\n  if (attr.getKind() == ParsedAttr::AT_NoThrow) {\n    // Delay if this is not a function type.\n    if (!unwrapped.isFunctionType())\n      return false;\n\n    if (S.CheckAttrNoArgs(attr)) {\n      attr.setInvalid();\n      return true;\n    }\n\n    // Otherwise we can process right away.\n    auto *Proto = unwrapped.get()->castAs<FunctionProtoType>();\n\n    // MSVC ignores nothrow if it is in conflict with an explicit exception\n    // specification.\n    if (Proto->hasExceptionSpec()) {\n      switch (Proto->getExceptionSpecType()) {\n      case EST_None:\n        llvm_unreachable(\"This doesn't have an exception spec!\");\n\n      case EST_DynamicNone:\n      case EST_BasicNoexcept:\n      case EST_NoexceptTrue:\n      case EST_NoThrow:\n        // Exception spec doesn't conflict with nothrow, so don't warn.\n        LLVM_FALLTHROUGH;\n      case EST_Unparsed:\n      case EST_Uninstantiated:\n      case EST_DependentNoexcept:\n      case EST_Unevaluated:\n        // We don't have enough information to properly determine if there is a\n        // conflict, so suppress the warning.\n        break;\n      case EST_Dynamic:\n      case EST_MSAny:\n      case EST_NoexceptFalse:\n        S.Diag(attr.getLoc(), diag::warn_nothrow_attribute_ignored);\n        break;\n      }\n      return true;\n    }\n\n    type = unwrapped.wrap(\n        S, S.Context\n               .getFunctionTypeWithExceptionSpec(\n                   QualType{Proto, 0},\n                   FunctionProtoType::ExceptionSpecInfo{EST_NoThrow})\n               ->getAs<FunctionType>());\n    return true;\n  }\n\n  // Delay if the type didn't work out to a function.\n  if (!unwrapped.isFunctionType()) return false;\n\n  // Otherwise, a calling convention.\n  CallingConv CC;\n  if (S.CheckCallingConvAttr(attr, CC))\n    return true;\n\n  const FunctionType *fn = unwrapped.get();\n  CallingConv CCOld = fn->getCallConv();\n  Attr *CCAttr = getCCTypeAttr(S.Context, attr);\n\n  if (CCOld != CC) {\n    // Error out on when there's already an attribute on the type\n    // and the CCs don't match.\n    if (S.getCallingConvAttributedType(type)) {\n      S.Diag(attr.getLoc(), diag::err_attributes_are_not_compatible)\n        << FunctionType::getNameForCallConv(CC)\n        << FunctionType::getNameForCallConv(CCOld);\n      attr.setInvalid();\n      return true;\n    }\n  }\n\n  // Diagnose use of variadic functions with calling conventions that\n  // don't support them (e.g. because they're callee-cleanup).\n  // We delay warning about this on unprototyped function declarations\n  // until after redeclaration checking, just in case we pick up a\n  // prototype that way.  And apparently we also \"delay\" warning about\n  // unprototyped function types in general, despite not necessarily having\n  // much ability to diagnose it later.\n  if (!supportsVariadicCall(CC)) {\n    const FunctionProtoType *FnP = dyn_cast<FunctionProtoType>(fn);\n    if (FnP && FnP->isVariadic()) {\n      // stdcall and fastcall are ignored with a warning for GCC and MS\n      // compatibility.\n      if (CC == CC_X86StdCall || CC == CC_X86FastCall)\n        return S.Diag(attr.getLoc(), diag::warn_cconv_unsupported)\n               << FunctionType::getNameForCallConv(CC)\n               << (int)Sema::CallingConventionIgnoredReason::VariadicFunction;\n\n      attr.setInvalid();\n      return S.Diag(attr.getLoc(), diag::err_cconv_varargs)\n             << FunctionType::getNameForCallConv(CC);\n    }\n  }\n\n  // Also diagnose fastcall with regparm.\n  if (CC == CC_X86FastCall && fn->getHasRegParm()) {\n    S.Diag(attr.getLoc(), diag::err_attributes_are_not_compatible)\n        << \"regparm\" << FunctionType::getNameForCallConv(CC_X86FastCall);\n    attr.setInvalid();\n    return true;\n  }\n\n  // Modify the CC from the wrapped function type, wrap it all back, and then\n  // wrap the whole thing in an AttributedType as written.  The modified type\n  // might have a different CC if we ignored the attribute.\n  QualType Equivalent;\n  if (CCOld == CC) {\n    Equivalent = type;\n  } else {\n    auto EI = unwrapped.get()->getExtInfo().withCallingConv(CC);\n    Equivalent =\n      unwrapped.wrap(S, S.Context.adjustFunctionType(unwrapped.get(), EI));\n  }\n  type = state.getAttributedType(CCAttr, type, Equivalent);\n  return true;\n}\n\nbool Sema::hasExplicitCallingConv(QualType T) {\n  const AttributedType *AT;\n\n  // Stop if we'd be stripping off a typedef sugar node to reach the\n  // AttributedType.\n  while ((AT = T->getAs<AttributedType>()) &&\n         AT->getAs<TypedefType>() == T->getAs<TypedefType>()) {\n    if (AT->isCallingConv())\n      return true;\n    T = AT->getModifiedType();\n  }\n  return false;\n}\n\nvoid Sema::adjustMemberFunctionCC(QualType &T, bool IsStatic, bool IsCtorOrDtor,\n                                  SourceLocation Loc) {\n  FunctionTypeUnwrapper Unwrapped(*this, T);\n  const FunctionType *FT = Unwrapped.get();\n  bool IsVariadic = (isa<FunctionProtoType>(FT) &&\n                     cast<FunctionProtoType>(FT)->isVariadic());\n  CallingConv CurCC = FT->getCallConv();\n  CallingConv ToCC = Context.getDefaultCallingConvention(IsVariadic, !IsStatic);\n\n  if (CurCC == ToCC)\n    return;\n\n  // MS compiler ignores explicit calling convention attributes on structors. We\n  // should do the same.\n  if (Context.getTargetInfo().getCXXABI().isMicrosoft() && IsCtorOrDtor) {\n    // Issue a warning on ignored calling convention -- except of __stdcall.\n    // Again, this is what MS compiler does.\n    if (CurCC != CC_X86StdCall)\n      Diag(Loc, diag::warn_cconv_unsupported)\n          << FunctionType::getNameForCallConv(CurCC)\n          << (int)Sema::CallingConventionIgnoredReason::ConstructorDestructor;\n  // Default adjustment.\n  } else {\n    // Only adjust types with the default convention.  For example, on Windows\n    // we should adjust a __cdecl type to __thiscall for instance methods, and a\n    // __thiscall type to __cdecl for static methods.\n    CallingConv DefaultCC =\n        Context.getDefaultCallingConvention(IsVariadic, IsStatic);\n\n    if (CurCC != DefaultCC || DefaultCC == ToCC)\n      return;\n\n    if (hasExplicitCallingConv(T))\n      return;\n  }\n\n  FT = Context.adjustFunctionType(FT, FT->getExtInfo().withCallingConv(ToCC));\n  QualType Wrapped = Unwrapped.wrap(*this, FT);\n  T = Context.getAdjustedType(T, Wrapped);\n}\n\n/// HandleVectorSizeAttribute - this attribute is only applicable to integral\n/// and float scalars, although arrays, pointers, and function return values are\n/// allowed in conjunction with this construct. Aggregates with this attribute\n/// are invalid, even if they are of the same size as a corresponding scalar.\n/// The raw attribute should contain precisely 1 argument, the vector size for\n/// the variable, measured in bytes. If curType and rawAttr are well formed,\n/// this routine will return a new vector type.\nstatic void HandleVectorSizeAttr(QualType &CurType, const ParsedAttr &Attr,\n                                 Sema &S) {\n  // Check the attribute arguments.\n  if (Attr.getNumArgs() != 1) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments) << Attr\n                                                                      << 1;\n    Attr.setInvalid();\n    return;\n  }\n\n  Expr *SizeExpr = Attr.getArgAsExpr(0);\n  QualType T = S.BuildVectorType(CurType, SizeExpr, Attr.getLoc());\n  if (!T.isNull())\n    CurType = T;\n  else\n    Attr.setInvalid();\n}\n\n/// Process the OpenCL-like ext_vector_type attribute when it occurs on\n/// a type.\nstatic void HandleExtVectorTypeAttr(QualType &CurType, const ParsedAttr &Attr,\n                                    Sema &S) {\n  // check the attribute arguments.\n  if (Attr.getNumArgs() != 1) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments) << Attr\n                                                                      << 1;\n    return;\n  }\n\n  Expr *SizeExpr = Attr.getArgAsExpr(0);\n  QualType T = S.BuildExtVectorType(CurType, SizeExpr, Attr.getLoc());\n  if (!T.isNull())\n    CurType = T;\n}\n\nstatic bool isPermittedNeonBaseType(QualType &Ty,\n                                    VectorType::VectorKind VecKind, Sema &S) {\n  const BuiltinType *BTy = Ty->getAs<BuiltinType>();\n  if (!BTy)\n    return false;\n\n  llvm::Triple Triple = S.Context.getTargetInfo().getTriple();\n\n  // Signed poly is mathematically wrong, but has been baked into some ABIs by\n  // now.\n  bool IsPolyUnsigned = Triple.getArch() == llvm::Triple::aarch64 ||\n                        Triple.getArch() == llvm::Triple::aarch64_32 ||\n                        Triple.getArch() == llvm::Triple::aarch64_be;\n  if (VecKind == VectorType::NeonPolyVector) {\n    if (IsPolyUnsigned) {\n      // AArch64 polynomial vectors are unsigned.\n      return BTy->getKind() == BuiltinType::UChar ||\n             BTy->getKind() == BuiltinType::UShort ||\n             BTy->getKind() == BuiltinType::ULong ||\n             BTy->getKind() == BuiltinType::ULongLong;\n    } else {\n      // AArch32 polynomial vectors are signed.\n      return BTy->getKind() == BuiltinType::SChar ||\n             BTy->getKind() == BuiltinType::Short ||\n             BTy->getKind() == BuiltinType::LongLong;\n    }\n  }\n\n  // Non-polynomial vector types: the usual suspects are allowed, as well as\n  // float64_t on AArch64.\n  if ((Triple.isArch64Bit() || Triple.getArch() == llvm::Triple::aarch64_32) &&\n      BTy->getKind() == BuiltinType::Double)\n    return true;\n\n  return BTy->getKind() == BuiltinType::SChar ||\n         BTy->getKind() == BuiltinType::UChar ||\n         BTy->getKind() == BuiltinType::Short ||\n         BTy->getKind() == BuiltinType::UShort ||\n         BTy->getKind() == BuiltinType::Int ||\n         BTy->getKind() == BuiltinType::UInt ||\n         BTy->getKind() == BuiltinType::Long ||\n         BTy->getKind() == BuiltinType::ULong ||\n         BTy->getKind() == BuiltinType::LongLong ||\n         BTy->getKind() == BuiltinType::ULongLong ||\n         BTy->getKind() == BuiltinType::Float ||\n         BTy->getKind() == BuiltinType::Half ||\n         BTy->getKind() == BuiltinType::BFloat16;\n}\n\nstatic bool verifyValidIntegerConstantExpr(Sema &S, const ParsedAttr &Attr,\n                                           llvm::APSInt &Result) {\n  const auto *AttrExpr = Attr.getArgAsExpr(0);\n  if (!AttrExpr->isTypeDependent() && !AttrExpr->isValueDependent()) {\n    if (Optional<llvm::APSInt> Res =\n            AttrExpr->getIntegerConstantExpr(S.Context)) {\n      Result = *Res;\n      return true;\n    }\n  }\n  S.Diag(Attr.getLoc(), diag::err_attribute_argument_type)\n      << Attr << AANT_ArgumentIntegerConstant << AttrExpr->getSourceRange();\n  Attr.setInvalid();\n  return false;\n}\n\n/// HandleNeonVectorTypeAttr - The \"neon_vector_type\" and\n/// \"neon_polyvector_type\" attributes are used to create vector types that\n/// are mangled according to ARM's ABI.  Otherwise, these types are identical\n/// to those created with the \"vector_size\" attribute.  Unlike \"vector_size\"\n/// the argument to these Neon attributes is the number of vector elements,\n/// not the vector size in bytes.  The vector width and element type must\n/// match one of the standard Neon vector types.\nstatic void HandleNeonVectorTypeAttr(QualType &CurType, const ParsedAttr &Attr,\n                                     Sema &S, VectorType::VectorKind VecKind) {\n  // Target must have NEON (or MVE, whose vectors are similar enough\n  // not to need a separate attribute)\n  if (!S.Context.getTargetInfo().hasFeature(\"neon\") &&\n      !S.Context.getTargetInfo().hasFeature(\"mve\")) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_unsupported)\n        << Attr << \"'neon' or 'mve'\";\n    Attr.setInvalid();\n    return;\n  }\n  // Check the attribute arguments.\n  if (Attr.getNumArgs() != 1) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments) << Attr\n                                                                      << 1;\n    Attr.setInvalid();\n    return;\n  }\n  // The number of elements must be an ICE.\n  llvm::APSInt numEltsInt(32);\n  if (!verifyValidIntegerConstantExpr(S, Attr, numEltsInt))\n    return;\n\n  // Only certain element types are supported for Neon vectors.\n  if (!isPermittedNeonBaseType(CurType, VecKind, S)) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_invalid_vector_type) << CurType;\n    Attr.setInvalid();\n    return;\n  }\n\n  // The total size of the vector must be 64 or 128 bits.\n  unsigned typeSize = static_cast<unsigned>(S.Context.getTypeSize(CurType));\n  unsigned numElts = static_cast<unsigned>(numEltsInt.getZExtValue());\n  unsigned vecSize = typeSize * numElts;\n  if (vecSize != 64 && vecSize != 128) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_bad_neon_vector_size) << CurType;\n    Attr.setInvalid();\n    return;\n  }\n\n  CurType = S.Context.getVectorType(CurType, numElts, VecKind);\n}\n\n/// HandleArmSveVectorBitsTypeAttr - The \"arm_sve_vector_bits\" attribute is\n/// used to create fixed-length versions of sizeless SVE types defined by\n/// the ACLE, such as svint32_t and svbool_t.\nstatic void HandleArmSveVectorBitsTypeAttr(QualType &CurType, ParsedAttr &Attr,\n                                           Sema &S) {\n  // Target must have SVE.\n  if (!S.Context.getTargetInfo().hasFeature(\"sve\")) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_unsupported) << Attr << \"'sve'\";\n    Attr.setInvalid();\n    return;\n  }\n\n  // Attribute is unsupported if '-msve-vector-bits=<bits>' isn't specified.\n  if (!S.getLangOpts().ArmSveVectorBits) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_arm_feature_sve_bits_unsupported)\n        << Attr;\n    Attr.setInvalid();\n    return;\n  }\n\n  // Check the attribute arguments.\n  if (Attr.getNumArgs() != 1) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments)\n        << Attr << 1;\n    Attr.setInvalid();\n    return;\n  }\n\n  // The vector size must be an integer constant expression.\n  llvm::APSInt SveVectorSizeInBits(32);\n  if (!verifyValidIntegerConstantExpr(S, Attr, SveVectorSizeInBits))\n    return;\n\n  unsigned VecSize = static_cast<unsigned>(SveVectorSizeInBits.getZExtValue());\n\n  // The attribute vector size must match -msve-vector-bits.\n  if (VecSize != S.getLangOpts().ArmSveVectorBits) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_bad_sve_vector_size)\n        << VecSize << S.getLangOpts().ArmSveVectorBits;\n    Attr.setInvalid();\n    return;\n  }\n\n  // Attribute can only be attached to a single SVE vector or predicate type.\n  if (!CurType->isVLSTBuiltinType()) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_invalid_sve_type)\n        << Attr << CurType;\n    Attr.setInvalid();\n    return;\n  }\n\n  const auto *BT = CurType->castAs<BuiltinType>();\n\n  QualType EltType = CurType->getSveEltType(S.Context);\n  unsigned TypeSize = S.Context.getTypeSize(EltType);\n  VectorType::VectorKind VecKind = VectorType::SveFixedLengthDataVector;\n  if (BT->getKind() == BuiltinType::SveBool) {\n    // Predicates are represented as i8.\n    VecSize /= S.Context.getCharWidth() * S.Context.getCharWidth();\n    VecKind = VectorType::SveFixedLengthPredicateVector;\n  } else\n    VecSize /= TypeSize;\n  CurType = S.Context.getVectorType(EltType, VecSize, VecKind);\n}\n\nstatic void HandleArmMveStrictPolymorphismAttr(TypeProcessingState &State,\n                                               QualType &CurType,\n                                               ParsedAttr &Attr) {\n  const VectorType *VT = dyn_cast<VectorType>(CurType);\n  if (!VT || VT->getVectorKind() != VectorType::NeonVector) {\n    State.getSema().Diag(Attr.getLoc(),\n                         diag::err_attribute_arm_mve_polymorphism);\n    Attr.setInvalid();\n    return;\n  }\n\n  CurType =\n      State.getAttributedType(createSimpleAttr<ArmMveStrictPolymorphismAttr>(\n                                  State.getSema().Context, Attr),\n                              CurType, CurType);\n}\n\n/// Handle OpenCL Access Qualifier Attribute.\nstatic void HandleOpenCLAccessAttr(QualType &CurType, const ParsedAttr &Attr,\n                                   Sema &S) {\n  // OpenCL v2.0 s6.6 - Access qualifier can be used only for image and pipe type.\n  if (!(CurType->isImageType() || CurType->isPipeType())) {\n    S.Diag(Attr.getLoc(), diag::err_opencl_invalid_access_qualifier);\n    Attr.setInvalid();\n    return;\n  }\n\n  if (const TypedefType* TypedefTy = CurType->getAs<TypedefType>()) {\n    QualType BaseTy = TypedefTy->desugar();\n\n    std::string PrevAccessQual;\n    if (BaseTy->isPipeType()) {\n      if (TypedefTy->getDecl()->hasAttr<OpenCLAccessAttr>()) {\n        OpenCLAccessAttr *Attr =\n            TypedefTy->getDecl()->getAttr<OpenCLAccessAttr>();\n        PrevAccessQual = Attr->getSpelling();\n      } else {\n        PrevAccessQual = \"read_only\";\n      }\n    } else if (const BuiltinType* ImgType = BaseTy->getAs<BuiltinType>()) {\n\n      switch (ImgType->getKind()) {\n        #define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n      case BuiltinType::Id:                                          \\\n        PrevAccessQual = #Access;                                    \\\n        break;\n        #include \"clang/Basic/OpenCLImageTypes.def\"\n      default:\n        llvm_unreachable(\"Unable to find corresponding image type.\");\n      }\n    } else {\n      llvm_unreachable(\"unexpected type\");\n    }\n    StringRef AttrName = Attr.getAttrName()->getName();\n    if (PrevAccessQual == AttrName.ltrim(\"_\")) {\n      // Duplicated qualifiers\n      S.Diag(Attr.getLoc(), diag::warn_duplicate_declspec)\n         << AttrName << Attr.getRange();\n    } else {\n      // Contradicting qualifiers\n      S.Diag(Attr.getLoc(), diag::err_opencl_multiple_access_qualifiers);\n    }\n\n    S.Diag(TypedefTy->getDecl()->getBeginLoc(),\n           diag::note_opencl_typedef_access_qualifier) << PrevAccessQual;\n  } else if (CurType->isPipeType()) {\n    if (Attr.getSemanticSpelling() == OpenCLAccessAttr::Keyword_write_only) {\n      QualType ElemType = CurType->castAs<PipeType>()->getElementType();\n      CurType = S.Context.getWritePipeType(ElemType);\n    }\n  }\n}\n\n/// HandleMatrixTypeAttr - \"matrix_type\" attribute, like ext_vector_type\nstatic void HandleMatrixTypeAttr(QualType &CurType, const ParsedAttr &Attr,\n                                 Sema &S) {\n  if (!S.getLangOpts().MatrixTypes) {\n    S.Diag(Attr.getLoc(), diag::err_builtin_matrix_disabled);\n    return;\n  }\n\n  if (Attr.getNumArgs() != 2) {\n    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments)\n        << Attr << 2;\n    return;\n  }\n\n  Expr *RowsExpr = Attr.getArgAsExpr(0);\n  Expr *ColsExpr = Attr.getArgAsExpr(1);\n  QualType T = S.BuildMatrixType(CurType, RowsExpr, ColsExpr, Attr.getLoc());\n  if (!T.isNull())\n    CurType = T;\n}\n\nstatic void HandleLifetimeBoundAttr(TypeProcessingState &State,\n                                    QualType &CurType,\n                                    ParsedAttr &Attr) {\n  if (State.getDeclarator().isDeclarationOfFunction()) {\n    CurType = State.getAttributedType(\n        createSimpleAttr<LifetimeBoundAttr>(State.getSema().Context, Attr),\n        CurType, CurType);\n  } else {\n    Attr.diagnoseAppertainsTo(State.getSema(), nullptr);\n  }\n}\n\nstatic bool isAddressSpaceKind(const ParsedAttr &attr) {\n  auto attrKind = attr.getKind();\n\n  return attrKind == ParsedAttr::AT_AddressSpace ||\n         attrKind == ParsedAttr::AT_OpenCLPrivateAddressSpace ||\n         attrKind == ParsedAttr::AT_OpenCLGlobalAddressSpace ||\n         attrKind == ParsedAttr::AT_OpenCLGlobalDeviceAddressSpace ||\n         attrKind == ParsedAttr::AT_OpenCLGlobalHostAddressSpace ||\n         attrKind == ParsedAttr::AT_OpenCLLocalAddressSpace ||\n         attrKind == ParsedAttr::AT_OpenCLConstantAddressSpace ||\n         attrKind == ParsedAttr::AT_OpenCLGenericAddressSpace;\n}\n\nstatic void processTypeAttrs(TypeProcessingState &state, QualType &type,\n                             TypeAttrLocation TAL,\n                             ParsedAttributesView &attrs) {\n  // Scan through and apply attributes to this type where it makes sense.  Some\n  // attributes (such as __address_space__, __vector_size__, etc) apply to the\n  // type, but others can be present in the type specifiers even though they\n  // apply to the decl.  Here we apply type attributes and ignore the rest.\n\n  // This loop modifies the list pretty frequently, but we still need to make\n  // sure we visit every element once. Copy the attributes list, and iterate\n  // over that.\n  ParsedAttributesView AttrsCopy{attrs};\n\n  state.setParsedNoDeref(false);\n\n  for (ParsedAttr &attr : AttrsCopy) {\n\n    // Skip attributes that were marked to be invalid.\n    if (attr.isInvalid())\n      continue;\n\n    if (attr.isCXX11Attribute()) {\n      // [[gnu::...]] attributes are treated as declaration attributes, so may\n      // not appertain to a DeclaratorChunk. If we handle them as type\n      // attributes, accept them in that position and diagnose the GCC\n      // incompatibility.\n      if (attr.isGNUScope()) {\n        bool IsTypeAttr = attr.isTypeAttr();\n        if (TAL == TAL_DeclChunk) {\n          state.getSema().Diag(attr.getLoc(),\n                               IsTypeAttr\n                                   ? diag::warn_gcc_ignores_type_attr\n                                   : diag::warn_cxx11_gnu_attribute_on_type)\n              << attr;\n          if (!IsTypeAttr)\n            continue;\n        }\n      } else if (TAL != TAL_DeclChunk && !isAddressSpaceKind(attr)) {\n        // Otherwise, only consider type processing for a C++11 attribute if\n        // it's actually been applied to a type.\n        // We also allow C++11 address_space and\n        // OpenCL language address space attributes to pass through.\n        continue;\n      }\n    }\n\n    // If this is an attribute we can handle, do so now,\n    // otherwise, add it to the FnAttrs list for rechaining.\n    switch (attr.getKind()) {\n    default:\n      // A C++11 attribute on a declarator chunk must appertain to a type.\n      if (attr.isCXX11Attribute() && TAL == TAL_DeclChunk) {\n        state.getSema().Diag(attr.getLoc(), diag::err_attribute_not_type_attr)\n            << attr;\n        attr.setUsedAsTypeAttr();\n      }\n      break;\n\n    case ParsedAttr::UnknownAttribute:\n      if (attr.isCXX11Attribute() && TAL == TAL_DeclChunk)\n        state.getSema().Diag(attr.getLoc(),\n                             diag::warn_unknown_attribute_ignored)\n            << attr << attr.getRange();\n      break;\n\n    case ParsedAttr::IgnoredAttribute:\n      break;\n\n    case ParsedAttr::AT_MayAlias:\n      // FIXME: This attribute needs to actually be handled, but if we ignore\n      // it it breaks large amounts of Linux software.\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_OpenCLPrivateAddressSpace:\n    case ParsedAttr::AT_OpenCLGlobalAddressSpace:\n    case ParsedAttr::AT_OpenCLGlobalDeviceAddressSpace:\n    case ParsedAttr::AT_OpenCLGlobalHostAddressSpace:\n    case ParsedAttr::AT_OpenCLLocalAddressSpace:\n    case ParsedAttr::AT_OpenCLConstantAddressSpace:\n    case ParsedAttr::AT_OpenCLGenericAddressSpace:\n    case ParsedAttr::AT_AddressSpace:\n      HandleAddressSpaceTypeAttribute(type, attr, state);\n      attr.setUsedAsTypeAttr();\n      break;\n    OBJC_POINTER_TYPE_ATTRS_CASELIST:\n      if (!handleObjCPointerTypeAttr(state, attr, type))\n        distributeObjCPointerTypeAttr(state, attr, type);\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_VectorSize:\n      HandleVectorSizeAttr(type, attr, state.getSema());\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_ExtVectorType:\n      HandleExtVectorTypeAttr(type, attr, state.getSema());\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_NeonVectorType:\n      HandleNeonVectorTypeAttr(type, attr, state.getSema(),\n                               VectorType::NeonVector);\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_NeonPolyVectorType:\n      HandleNeonVectorTypeAttr(type, attr, state.getSema(),\n                               VectorType::NeonPolyVector);\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_ArmSveVectorBits:\n      HandleArmSveVectorBitsTypeAttr(type, attr, state.getSema());\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_ArmMveStrictPolymorphism: {\n      HandleArmMveStrictPolymorphismAttr(state, type, attr);\n      attr.setUsedAsTypeAttr();\n      break;\n    }\n    case ParsedAttr::AT_OpenCLAccess:\n      HandleOpenCLAccessAttr(type, attr, state.getSema());\n      attr.setUsedAsTypeAttr();\n      break;\n    case ParsedAttr::AT_LifetimeBound:\n      if (TAL == TAL_DeclChunk)\n        HandleLifetimeBoundAttr(state, type, attr);\n      break;\n\n    case ParsedAttr::AT_NoDeref: {\n      ASTContext &Ctx = state.getSema().Context;\n      type = state.getAttributedType(createSimpleAttr<NoDerefAttr>(Ctx, attr),\n                                     type, type);\n      attr.setUsedAsTypeAttr();\n      state.setParsedNoDeref(true);\n      break;\n    }\n\n    case ParsedAttr::AT_MatrixType:\n      HandleMatrixTypeAttr(type, attr, state.getSema());\n      attr.setUsedAsTypeAttr();\n      break;\n\n    MS_TYPE_ATTRS_CASELIST:\n      if (!handleMSPointerTypeQualifierAttr(state, attr, type))\n        attr.setUsedAsTypeAttr();\n      break;\n\n\n    NULLABILITY_TYPE_ATTRS_CASELIST:\n      // Either add nullability here or try to distribute it.  We\n      // don't want to distribute the nullability specifier past any\n      // dependent type, because that complicates the user model.\n      if (type->canHaveNullability() || type->isDependentType() ||\n          type->isArrayType() ||\n          !distributeNullabilityTypeAttr(state, type, attr)) {\n        unsigned endIndex;\n        if (TAL == TAL_DeclChunk)\n          endIndex = state.getCurrentChunkIndex();\n        else\n          endIndex = state.getDeclarator().getNumTypeObjects();\n        bool allowOnArrayType =\n            state.getDeclarator().isPrototypeContext() &&\n            !hasOuterPointerLikeChunk(state.getDeclarator(), endIndex);\n        if (checkNullabilityTypeSpecifier(\n              state,\n              type,\n              attr,\n              allowOnArrayType)) {\n          attr.setInvalid();\n        }\n\n        attr.setUsedAsTypeAttr();\n      }\n      break;\n\n    case ParsedAttr::AT_ObjCKindOf:\n      // '__kindof' must be part of the decl-specifiers.\n      switch (TAL) {\n      case TAL_DeclSpec:\n        break;\n\n      case TAL_DeclChunk:\n      case TAL_DeclName:\n        state.getSema().Diag(attr.getLoc(),\n                             diag::err_objc_kindof_wrong_position)\n            << FixItHint::CreateRemoval(attr.getLoc())\n            << FixItHint::CreateInsertion(\n                   state.getDeclarator().getDeclSpec().getBeginLoc(),\n                   \"__kindof \");\n        break;\n      }\n\n      // Apply it regardless.\n      if (checkObjCKindOfType(state, type, attr))\n        attr.setInvalid();\n      break;\n\n    case ParsedAttr::AT_NoThrow:\n    // Exception Specifications aren't generally supported in C mode throughout\n    // clang, so revert to attribute-based handling for C.\n      if (!state.getSema().getLangOpts().CPlusPlus)\n        break;\n      LLVM_FALLTHROUGH;\n    FUNCTION_TYPE_ATTRS_CASELIST:\n      attr.setUsedAsTypeAttr();\n\n      // Never process function type attributes as part of the\n      // declaration-specifiers.\n      if (TAL == TAL_DeclSpec)\n        distributeFunctionTypeAttrFromDeclSpec(state, attr, type);\n\n      // Otherwise, handle the possible delays.\n      else if (!handleFunctionTypeAttr(state, attr, type))\n        distributeFunctionTypeAttr(state, attr, type);\n      break;\n    case ParsedAttr::AT_AcquireHandle: {\n      if (!type->isFunctionType())\n        return;\n\n      if (attr.getNumArgs() != 1) {\n        state.getSema().Diag(attr.getLoc(),\n                             diag::err_attribute_wrong_number_arguments)\n            << attr << 1;\n        attr.setInvalid();\n        return;\n      }\n\n      StringRef HandleType;\n      if (!state.getSema().checkStringLiteralArgumentAttr(attr, 0, HandleType))\n        return;\n      type = state.getAttributedType(\n          AcquireHandleAttr::Create(state.getSema().Context, HandleType, attr),\n          type, type);\n      attr.setUsedAsTypeAttr();\n      break;\n    }\n    }\n\n    // Handle attributes that are defined in a macro. We do not want this to be\n    // applied to ObjC builtin attributes.\n    if (isa<AttributedType>(type) && attr.hasMacroIdentifier() &&\n        !type.getQualifiers().hasObjCLifetime() &&\n        !type.getQualifiers().hasObjCGCAttr() &&\n        attr.getKind() != ParsedAttr::AT_ObjCGC &&\n        attr.getKind() != ParsedAttr::AT_ObjCOwnership) {\n      const IdentifierInfo *MacroII = attr.getMacroIdentifier();\n      type = state.getSema().Context.getMacroQualifiedType(type, MacroII);\n      state.setExpansionLocForMacroQualifiedType(\n          cast<MacroQualifiedType>(type.getTypePtr()),\n          attr.getMacroExpansionLoc());\n    }\n  }\n\n  if (!state.getSema().getLangOpts().OpenCL ||\n      type.getAddressSpace() != LangAS::Default)\n    return;\n}\n\nvoid Sema::completeExprArrayBound(Expr *E) {\n  if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParens())) {\n    if (VarDecl *Var = dyn_cast<VarDecl>(DRE->getDecl())) {\n      if (isTemplateInstantiation(Var->getTemplateSpecializationKind())) {\n        auto *Def = Var->getDefinition();\n        if (!Def) {\n          SourceLocation PointOfInstantiation = E->getExprLoc();\n          runWithSufficientStackSpace(PointOfInstantiation, [&] {\n            InstantiateVariableDefinition(PointOfInstantiation, Var);\n          });\n          Def = Var->getDefinition();\n\n          // If we don't already have a point of instantiation, and we managed\n          // to instantiate a definition, this is the point of instantiation.\n          // Otherwise, we don't request an end-of-TU instantiation, so this is\n          // not a point of instantiation.\n          // FIXME: Is this really the right behavior?\n          if (Var->getPointOfInstantiation().isInvalid() && Def) {\n            assert(Var->getTemplateSpecializationKind() ==\n                       TSK_ImplicitInstantiation &&\n                   \"explicit instantiation with no point of instantiation\");\n            Var->setTemplateSpecializationKind(\n                Var->getTemplateSpecializationKind(), PointOfInstantiation);\n          }\n        }\n\n        // Update the type to the definition's type both here and within the\n        // expression.\n        if (Def) {\n          DRE->setDecl(Def);\n          QualType T = Def->getType();\n          DRE->setType(T);\n          // FIXME: Update the type on all intervening expressions.\n          E->setType(T);\n        }\n\n        // We still go on to try to complete the type independently, as it\n        // may also require instantiations or diagnostics if it remains\n        // incomplete.\n      }\n    }\n  }\n}\n\nQualType Sema::getCompletedType(Expr *E) {\n  // Incomplete array types may be completed by the initializer attached to\n  // their definitions. For static data members of class templates and for\n  // variable templates, we need to instantiate the definition to get this\n  // initializer and complete the type.\n  if (E->getType()->isIncompleteArrayType())\n    completeExprArrayBound(E);\n\n  // FIXME: Are there other cases which require instantiating something other\n  // than the type to complete the type of an expression?\n\n  return E->getType();\n}\n\n/// Ensure that the type of the given expression is complete.\n///\n/// This routine checks whether the expression \\p E has a complete type. If the\n/// expression refers to an instantiable construct, that instantiation is\n/// performed as needed to complete its type. Furthermore\n/// Sema::RequireCompleteType is called for the expression's type (or in the\n/// case of a reference type, the referred-to type).\n///\n/// \\param E The expression whose type is required to be complete.\n/// \\param Kind Selects which completeness rules should be applied.\n/// \\param Diagnoser The object that will emit a diagnostic if the type is\n/// incomplete.\n///\n/// \\returns \\c true if the type of \\p E is incomplete and diagnosed, \\c false\n/// otherwise.\nbool Sema::RequireCompleteExprType(Expr *E, CompleteTypeKind Kind,\n                                   TypeDiagnoser &Diagnoser) {\n  return RequireCompleteType(E->getExprLoc(), getCompletedType(E), Kind,\n                             Diagnoser);\n}\n\nbool Sema::RequireCompleteExprType(Expr *E, unsigned DiagID) {\n  BoundTypeDiagnoser<> Diagnoser(DiagID);\n  return RequireCompleteExprType(E, CompleteTypeKind::Default, Diagnoser);\n}\n\n/// Ensure that the type T is a complete type.\n///\n/// This routine checks whether the type @p T is complete in any\n/// context where a complete type is required. If @p T is a complete\n/// type, returns false. If @p T is a class template specialization,\n/// this routine then attempts to perform class template\n/// instantiation. If instantiation fails, or if @p T is incomplete\n/// and cannot be completed, issues the diagnostic @p diag (giving it\n/// the type @p T) and returns true.\n///\n/// @param Loc  The location in the source that the incomplete type\n/// diagnostic should refer to.\n///\n/// @param T  The type that this routine is examining for completeness.\n///\n/// @param Kind Selects which completeness rules should be applied.\n///\n/// @returns @c true if @p T is incomplete and a diagnostic was emitted,\n/// @c false otherwise.\nbool Sema::RequireCompleteType(SourceLocation Loc, QualType T,\n                               CompleteTypeKind Kind,\n                               TypeDiagnoser &Diagnoser) {\n  if (RequireCompleteTypeImpl(Loc, T, Kind, &Diagnoser))\n    return true;\n  if (const TagType *Tag = T->getAs<TagType>()) {\n    if (!Tag->getDecl()->isCompleteDefinitionRequired()) {\n      Tag->getDecl()->setCompleteDefinitionRequired();\n      Consumer.HandleTagDeclRequiredDefinition(Tag->getDecl());\n    }\n  }\n  return false;\n}\n\nbool Sema::hasStructuralCompatLayout(Decl *D, Decl *Suggested) {\n  llvm::DenseSet<std::pair<Decl *, Decl *>> NonEquivalentDecls;\n  if (!Suggested)\n    return false;\n\n  // FIXME: Add a specific mode for C11 6.2.7/1 in StructuralEquivalenceContext\n  // and isolate from other C++ specific checks.\n  StructuralEquivalenceContext Ctx(\n      D->getASTContext(), Suggested->getASTContext(), NonEquivalentDecls,\n      StructuralEquivalenceKind::Default,\n      false /*StrictTypeSpelling*/, true /*Complain*/,\n      true /*ErrorOnTagTypeMismatch*/);\n  return Ctx.IsEquivalent(D, Suggested);\n}\n\n/// Determine whether there is any declaration of \\p D that was ever a\n///        definition (perhaps before module merging) and is currently visible.\n/// \\param D The definition of the entity.\n/// \\param Suggested Filled in with the declaration that should be made visible\n///        in order to provide a definition of this entity.\n/// \\param OnlyNeedComplete If \\c true, we only need the type to be complete,\n///        not defined. This only matters for enums with a fixed underlying\n///        type, since in all other cases, a type is complete if and only if it\n///        is defined.\nbool Sema::hasVisibleDefinition(NamedDecl *D, NamedDecl **Suggested,\n                                bool OnlyNeedComplete) {\n  // Easy case: if we don't have modules, all declarations are visible.\n  if (!getLangOpts().Modules && !getLangOpts().ModulesLocalVisibility)\n    return true;\n\n  // If this definition was instantiated from a template, map back to the\n  // pattern from which it was instantiated.\n  if (isa<TagDecl>(D) && cast<TagDecl>(D)->isBeingDefined()) {\n    // We're in the middle of defining it; this definition should be treated\n    // as visible.\n    return true;\n  } else if (auto *RD = dyn_cast<CXXRecordDecl>(D)) {\n    if (auto *Pattern = RD->getTemplateInstantiationPattern())\n      RD = Pattern;\n    D = RD->getDefinition();\n  } else if (auto *ED = dyn_cast<EnumDecl>(D)) {\n    if (auto *Pattern = ED->getTemplateInstantiationPattern())\n      ED = Pattern;\n    if (OnlyNeedComplete && (ED->isFixed() || getLangOpts().MSVCCompat)) {\n      // If the enum has a fixed underlying type, it may have been forward\n      // declared. In -fms-compatibility, `enum Foo;` will also forward declare\n      // the enum and assign it the underlying type of `int`. Since we're only\n      // looking for a complete type (not a definition), any visible declaration\n      // of it will do.\n      *Suggested = nullptr;\n      for (auto *Redecl : ED->redecls()) {\n        if (isVisible(Redecl))\n          return true;\n        if (Redecl->isThisDeclarationADefinition() ||\n            (Redecl->isCanonicalDecl() && !*Suggested))\n          *Suggested = Redecl;\n      }\n      return false;\n    }\n    D = ED->getDefinition();\n  } else if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n    if (auto *Pattern = FD->getTemplateInstantiationPattern())\n      FD = Pattern;\n    D = FD->getDefinition();\n  } else if (auto *VD = dyn_cast<VarDecl>(D)) {\n    if (auto *Pattern = VD->getTemplateInstantiationPattern())\n      VD = Pattern;\n    D = VD->getDefinition();\n  }\n  assert(D && \"missing definition for pattern of instantiated definition\");\n\n  *Suggested = D;\n\n  auto DefinitionIsVisible = [&] {\n    // The (primary) definition might be in a visible module.\n    if (isVisible(D))\n      return true;\n\n    // A visible module might have a merged definition instead.\n    if (D->isModulePrivate() ? hasMergedDefinitionInCurrentModule(D)\n                             : hasVisibleMergedDefinition(D)) {\n      if (CodeSynthesisContexts.empty() &&\n          !getLangOpts().ModulesLocalVisibility) {\n        // Cache the fact that this definition is implicitly visible because\n        // there is a visible merged definition.\n        D->setVisibleDespiteOwningModule();\n      }\n      return true;\n    }\n\n    return false;\n  };\n\n  if (DefinitionIsVisible())\n    return true;\n\n  // The external source may have additional definitions of this entity that are\n  // visible, so complete the redeclaration chain now and ask again.\n  if (auto *Source = Context.getExternalSource()) {\n    Source->CompleteRedeclChain(D);\n    return DefinitionIsVisible();\n  }\n\n  return false;\n}\n\n/// Locks in the inheritance model for the given class and all of its bases.\nstatic void assignInheritanceModel(Sema &S, CXXRecordDecl *RD) {\n  RD = RD->getMostRecentNonInjectedDecl();\n  if (!RD->hasAttr<MSInheritanceAttr>()) {\n    MSInheritanceModel IM;\n    bool BestCase = false;\n    switch (S.MSPointerToMemberRepresentationMethod) {\n    case LangOptions::PPTMK_BestCase:\n      BestCase = true;\n      IM = RD->calculateInheritanceModel();\n      break;\n    case LangOptions::PPTMK_FullGeneralitySingleInheritance:\n      IM = MSInheritanceModel::Single;\n      break;\n    case LangOptions::PPTMK_FullGeneralityMultipleInheritance:\n      IM = MSInheritanceModel::Multiple;\n      break;\n    case LangOptions::PPTMK_FullGeneralityVirtualInheritance:\n      IM = MSInheritanceModel::Unspecified;\n      break;\n    }\n\n    SourceRange Loc = S.ImplicitMSInheritanceAttrLoc.isValid()\n                          ? S.ImplicitMSInheritanceAttrLoc\n                          : RD->getSourceRange();\n    RD->addAttr(MSInheritanceAttr::CreateImplicit(\n        S.getASTContext(), BestCase, Loc, AttributeCommonInfo::AS_Microsoft,\n        MSInheritanceAttr::Spelling(IM)));\n    S.Consumer.AssignInheritanceModel(RD);\n  }\n}\n\n/// The implementation of RequireCompleteType\nbool Sema::RequireCompleteTypeImpl(SourceLocation Loc, QualType T,\n                                   CompleteTypeKind Kind,\n                                   TypeDiagnoser *Diagnoser) {\n  // FIXME: Add this assertion to make sure we always get instantiation points.\n  //  assert(!Loc.isInvalid() && \"Invalid location in RequireCompleteType\");\n  // FIXME: Add this assertion to help us flush out problems with\n  // checking for dependent types and type-dependent expressions.\n  //\n  //  assert(!T->isDependentType() &&\n  //         \"Can't ask whether a dependent type is complete\");\n\n  if (const MemberPointerType *MPTy = T->getAs<MemberPointerType>()) {\n    if (!MPTy->getClass()->isDependentType()) {\n      if (getLangOpts().CompleteMemberPointers &&\n          !MPTy->getClass()->getAsCXXRecordDecl()->isBeingDefined() &&\n          RequireCompleteType(Loc, QualType(MPTy->getClass(), 0), Kind,\n                              diag::err_memptr_incomplete))\n        return true;\n\n      // We lock in the inheritance model once somebody has asked us to ensure\n      // that a pointer-to-member type is complete.\n      if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n        (void)isCompleteType(Loc, QualType(MPTy->getClass(), 0));\n        assignInheritanceModel(*this, MPTy->getMostRecentCXXRecordDecl());\n      }\n    }\n  }\n\n  NamedDecl *Def = nullptr;\n  bool AcceptSizeless = (Kind == CompleteTypeKind::AcceptSizeless);\n  bool Incomplete = (T->isIncompleteType(&Def) ||\n                     (!AcceptSizeless && T->isSizelessBuiltinType()));\n\n  // Check that any necessary explicit specializations are visible. For an\n  // enum, we just need the declaration, so don't check this.\n  if (Def && !isa<EnumDecl>(Def))\n    checkSpecializationVisibility(Loc, Def);\n\n  // If we have a complete type, we're done.\n  if (!Incomplete) {\n    // If we know about the definition but it is not visible, complain.\n    NamedDecl *SuggestedDef = nullptr;\n    if (Def &&\n        !hasVisibleDefinition(Def, &SuggestedDef, /*OnlyNeedComplete*/true)) {\n      // If the user is going to see an error here, recover by making the\n      // definition visible.\n      bool TreatAsComplete = Diagnoser && !isSFINAEContext();\n      if (Diagnoser && SuggestedDef)\n        diagnoseMissingImport(Loc, SuggestedDef, MissingImportKind::Definition,\n                              /*Recover*/TreatAsComplete);\n      return !TreatAsComplete;\n    } else if (Def && !TemplateInstCallbacks.empty()) {\n      CodeSynthesisContext TempInst;\n      TempInst.Kind = CodeSynthesisContext::Memoization;\n      TempInst.Template = Def;\n      TempInst.Entity = Def;\n      TempInst.PointOfInstantiation = Loc;\n      atTemplateBegin(TemplateInstCallbacks, *this, TempInst);\n      atTemplateEnd(TemplateInstCallbacks, *this, TempInst);\n    }\n\n    return false;\n  }\n\n  TagDecl *Tag = dyn_cast_or_null<TagDecl>(Def);\n  ObjCInterfaceDecl *IFace = dyn_cast_or_null<ObjCInterfaceDecl>(Def);\n\n  // Give the external source a chance to provide a definition of the type.\n  // This is kept separate from completing the redeclaration chain so that\n  // external sources such as LLDB can avoid synthesizing a type definition\n  // unless it's actually needed.\n  if (Tag || IFace) {\n    // Avoid diagnosing invalid decls as incomplete.\n    if (Def->isInvalidDecl())\n      return true;\n\n    // Give the external AST source a chance to complete the type.\n    if (auto *Source = Context.getExternalSource()) {\n      if (Tag && Tag->hasExternalLexicalStorage())\n          Source->CompleteType(Tag);\n      if (IFace && IFace->hasExternalLexicalStorage())\n          Source->CompleteType(IFace);\n      // If the external source completed the type, go through the motions\n      // again to ensure we're allowed to use the completed type.\n      if (!T->isIncompleteType())\n        return RequireCompleteTypeImpl(Loc, T, Kind, Diagnoser);\n    }\n  }\n\n  // If we have a class template specialization or a class member of a\n  // class template specialization, or an array with known size of such,\n  // try to instantiate it.\n  if (auto *RD = dyn_cast_or_null<CXXRecordDecl>(Tag)) {\n    bool Instantiated = false;\n    bool Diagnosed = false;\n    if (RD->isDependentContext()) {\n      // Don't try to instantiate a dependent class (eg, a member template of\n      // an instantiated class template specialization).\n      // FIXME: Can this ever happen?\n    } else if (auto *ClassTemplateSpec =\n            dyn_cast<ClassTemplateSpecializationDecl>(RD)) {\n      if (ClassTemplateSpec->getSpecializationKind() == TSK_Undeclared) {\n        runWithSufficientStackSpace(Loc, [&] {\n          Diagnosed = InstantiateClassTemplateSpecialization(\n              Loc, ClassTemplateSpec, TSK_ImplicitInstantiation,\n              /*Complain=*/Diagnoser);\n        });\n        Instantiated = true;\n      }\n    } else {\n      CXXRecordDecl *Pattern = RD->getInstantiatedFromMemberClass();\n      if (!RD->isBeingDefined() && Pattern) {\n        MemberSpecializationInfo *MSI = RD->getMemberSpecializationInfo();\n        assert(MSI && \"Missing member specialization information?\");\n        // This record was instantiated from a class within a template.\n        if (MSI->getTemplateSpecializationKind() !=\n            TSK_ExplicitSpecialization) {\n          runWithSufficientStackSpace(Loc, [&] {\n            Diagnosed = InstantiateClass(Loc, RD, Pattern,\n                                         getTemplateInstantiationArgs(RD),\n                                         TSK_ImplicitInstantiation,\n                                         /*Complain=*/Diagnoser);\n          });\n          Instantiated = true;\n        }\n      }\n    }\n\n    if (Instantiated) {\n      // Instantiate* might have already complained that the template is not\n      // defined, if we asked it to.\n      if (Diagnoser && Diagnosed)\n        return true;\n      // If we instantiated a definition, check that it's usable, even if\n      // instantiation produced an error, so that repeated calls to this\n      // function give consistent answers.\n      if (!T->isIncompleteType())\n        return RequireCompleteTypeImpl(Loc, T, Kind, Diagnoser);\n    }\n  }\n\n  // FIXME: If we didn't instantiate a definition because of an explicit\n  // specialization declaration, check that it's visible.\n\n  if (!Diagnoser)\n    return true;\n\n  Diagnoser->diagnose(*this, Loc, T);\n\n  // If the type was a forward declaration of a class/struct/union\n  // type, produce a note.\n  if (Tag && !Tag->isInvalidDecl() && !Tag->getLocation().isInvalid())\n    Diag(Tag->getLocation(),\n         Tag->isBeingDefined() ? diag::note_type_being_defined\n                               : diag::note_forward_declaration)\n      << Context.getTagDeclType(Tag);\n\n  // If the Objective-C class was a forward declaration, produce a note.\n  if (IFace && !IFace->isInvalidDecl() && !IFace->getLocation().isInvalid())\n    Diag(IFace->getLocation(), diag::note_forward_class);\n\n  // If we have external information that we can use to suggest a fix,\n  // produce a note.\n  if (ExternalSource)\n    ExternalSource->MaybeDiagnoseMissingCompleteType(Loc, T);\n\n  return true;\n}\n\nbool Sema::RequireCompleteType(SourceLocation Loc, QualType T,\n                               CompleteTypeKind Kind, unsigned DiagID) {\n  BoundTypeDiagnoser<> Diagnoser(DiagID);\n  return RequireCompleteType(Loc, T, Kind, Diagnoser);\n}\n\n/// Get diagnostic %select index for tag kind for\n/// literal type diagnostic message.\n/// WARNING: Indexes apply to particular diagnostics only!\n///\n/// \\returns diagnostic %select index.\nstatic unsigned getLiteralDiagFromTagKind(TagTypeKind Tag) {\n  switch (Tag) {\n  case TTK_Struct: return 0;\n  case TTK_Interface: return 1;\n  case TTK_Class:  return 2;\n  default: llvm_unreachable(\"Invalid tag kind for literal type diagnostic!\");\n  }\n}\n\n/// Ensure that the type T is a literal type.\n///\n/// This routine checks whether the type @p T is a literal type. If @p T is an\n/// incomplete type, an attempt is made to complete it. If @p T is a literal\n/// type, or @p AllowIncompleteType is true and @p T is an incomplete type,\n/// returns false. Otherwise, this routine issues the diagnostic @p PD (giving\n/// it the type @p T), along with notes explaining why the type is not a\n/// literal type, and returns true.\n///\n/// @param Loc  The location in the source that the non-literal type\n/// diagnostic should refer to.\n///\n/// @param T  The type that this routine is examining for literalness.\n///\n/// @param Diagnoser Emits a diagnostic if T is not a literal type.\n///\n/// @returns @c true if @p T is not a literal type and a diagnostic was emitted,\n/// @c false otherwise.\nbool Sema::RequireLiteralType(SourceLocation Loc, QualType T,\n                              TypeDiagnoser &Diagnoser) {\n  assert(!T->isDependentType() && \"type should not be dependent\");\n\n  QualType ElemType = Context.getBaseElementType(T);\n  if ((isCompleteType(Loc, ElemType) || ElemType->isVoidType()) &&\n      T->isLiteralType(Context))\n    return false;\n\n  Diagnoser.diagnose(*this, Loc, T);\n\n  if (T->isVariableArrayType())\n    return true;\n\n  const RecordType *RT = ElemType->getAs<RecordType>();\n  if (!RT)\n    return true;\n\n  const CXXRecordDecl *RD = cast<CXXRecordDecl>(RT->getDecl());\n\n  // A partially-defined class type can't be a literal type, because a literal\n  // class type must have a trivial destructor (which can't be checked until\n  // the class definition is complete).\n  if (RequireCompleteType(Loc, ElemType, diag::note_non_literal_incomplete, T))\n    return true;\n\n  // [expr.prim.lambda]p3:\n  //   This class type is [not] a literal type.\n  if (RD->isLambda() && !getLangOpts().CPlusPlus17) {\n    Diag(RD->getLocation(), diag::note_non_literal_lambda);\n    return true;\n  }\n\n  // If the class has virtual base classes, then it's not an aggregate, and\n  // cannot have any constexpr constructors or a trivial default constructor,\n  // so is non-literal. This is better to diagnose than the resulting absence\n  // of constexpr constructors.\n  if (RD->getNumVBases()) {\n    Diag(RD->getLocation(), diag::note_non_literal_virtual_base)\n      << getLiteralDiagFromTagKind(RD->getTagKind()) << RD->getNumVBases();\n    for (const auto &I : RD->vbases())\n      Diag(I.getBeginLoc(), diag::note_constexpr_virtual_base_here)\n          << I.getSourceRange();\n  } else if (!RD->isAggregate() && !RD->hasConstexprNonCopyMoveConstructor() &&\n             !RD->hasTrivialDefaultConstructor()) {\n    Diag(RD->getLocation(), diag::note_non_literal_no_constexpr_ctors) << RD;\n  } else if (RD->hasNonLiteralTypeFieldsOrBases()) {\n    for (const auto &I : RD->bases()) {\n      if (!I.getType()->isLiteralType(Context)) {\n        Diag(I.getBeginLoc(), diag::note_non_literal_base_class)\n            << RD << I.getType() << I.getSourceRange();\n        return true;\n      }\n    }\n    for (const auto *I : RD->fields()) {\n      if (!I->getType()->isLiteralType(Context) ||\n          I->getType().isVolatileQualified()) {\n        Diag(I->getLocation(), diag::note_non_literal_field)\n          << RD << I << I->getType()\n          << I->getType().isVolatileQualified();\n        return true;\n      }\n    }\n  } else if (getLangOpts().CPlusPlus20 ? !RD->hasConstexprDestructor()\n                                       : !RD->hasTrivialDestructor()) {\n    // All fields and bases are of literal types, so have trivial or constexpr\n    // destructors. If this class's destructor is non-trivial / non-constexpr,\n    // it must be user-declared.\n    CXXDestructorDecl *Dtor = RD->getDestructor();\n    assert(Dtor && \"class has literal fields and bases but no dtor?\");\n    if (!Dtor)\n      return true;\n\n    if (getLangOpts().CPlusPlus20) {\n      Diag(Dtor->getLocation(), diag::note_non_literal_non_constexpr_dtor)\n          << RD;\n    } else {\n      Diag(Dtor->getLocation(), Dtor->isUserProvided()\n                                    ? diag::note_non_literal_user_provided_dtor\n                                    : diag::note_non_literal_nontrivial_dtor)\n          << RD;\n      if (!Dtor->isUserProvided())\n        SpecialMemberIsTrivial(Dtor, CXXDestructor, TAH_IgnoreTrivialABI,\n                               /*Diagnose*/ true);\n    }\n  }\n\n  return true;\n}\n\nbool Sema::RequireLiteralType(SourceLocation Loc, QualType T, unsigned DiagID) {\n  BoundTypeDiagnoser<> Diagnoser(DiagID);\n  return RequireLiteralType(Loc, T, Diagnoser);\n}\n\n/// Retrieve a version of the type 'T' that is elaborated by Keyword, qualified\n/// by the nested-name-specifier contained in SS, and that is (re)declared by\n/// OwnedTagDecl, which is nullptr if this is not a (re)declaration.\nQualType Sema::getElaboratedType(ElaboratedTypeKeyword Keyword,\n                                 const CXXScopeSpec &SS, QualType T,\n                                 TagDecl *OwnedTagDecl) {\n  if (T.isNull())\n    return T;\n  NestedNameSpecifier *NNS;\n  if (SS.isValid())\n    NNS = SS.getScopeRep();\n  else {\n    if (Keyword == ETK_None)\n      return T;\n    NNS = nullptr;\n  }\n  return Context.getElaboratedType(Keyword, NNS, T, OwnedTagDecl);\n}\n\nQualType Sema::BuildTypeofExprType(Expr *E, SourceLocation Loc) {\n  assert(!E->hasPlaceholderType() && \"unexpected placeholder\");\n\n  if (!getLangOpts().CPlusPlus && E->refersToBitField())\n    Diag(E->getExprLoc(), diag::err_sizeof_alignof_typeof_bitfield) << 2;\n\n  if (!E->isTypeDependent()) {\n    QualType T = E->getType();\n    if (const TagType *TT = T->getAs<TagType>())\n      DiagnoseUseOfDecl(TT->getDecl(), E->getExprLoc());\n  }\n  return Context.getTypeOfExprType(E);\n}\n\n/// getDecltypeForExpr - Given an expr, will return the decltype for\n/// that expression, according to the rules in C++11\n/// [dcl.type.simple]p4 and C++11 [expr.lambda.prim]p18.\nstatic QualType getDecltypeForExpr(Sema &S, Expr *E) {\n  if (E->isTypeDependent())\n    return S.Context.DependentTy;\n\n  // C++11 [dcl.type.simple]p4:\n  //   The type denoted by decltype(e) is defined as follows:\n\n  // C++20:\n  //     - if E is an unparenthesized id-expression naming a non-type\n  //       template-parameter (13.2), decltype(E) is the type of the\n  //       template-parameter after performing any necessary type deduction\n  // Note that this does not pick up the implicit 'const' for a template\n  // parameter object. This rule makes no difference before C++20 so we apply\n  // it unconditionally.\n  if (const auto *SNTTPE = dyn_cast<SubstNonTypeTemplateParmExpr>(E))\n    return SNTTPE->getParameterType(S.Context);\n\n  //     - if e is an unparenthesized id-expression or an unparenthesized class\n  //       member access (5.2.5), decltype(e) is the type of the entity named\n  //       by e. If there is no such entity, or if e names a set of overloaded\n  //       functions, the program is ill-formed;\n  //\n  // We apply the same rules for Objective-C ivar and property references.\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    const ValueDecl *VD = DRE->getDecl();\n    if (auto *TPO = dyn_cast<TemplateParamObjectDecl>(VD))\n      return TPO->getType().getUnqualifiedType();\n    return VD->getType();\n  } else if (const MemberExpr *ME = dyn_cast<MemberExpr>(E)) {\n    if (const ValueDecl *VD = ME->getMemberDecl())\n      if (isa<FieldDecl>(VD) || isa<VarDecl>(VD))\n        return VD->getType();\n  } else if (const ObjCIvarRefExpr *IR = dyn_cast<ObjCIvarRefExpr>(E)) {\n    return IR->getDecl()->getType();\n  } else if (const ObjCPropertyRefExpr *PR = dyn_cast<ObjCPropertyRefExpr>(E)) {\n    if (PR->isExplicitProperty())\n      return PR->getExplicitProperty()->getType();\n  } else if (auto *PE = dyn_cast<PredefinedExpr>(E)) {\n    return PE->getType();\n  }\n\n  // C++11 [expr.lambda.prim]p18:\n  //   Every occurrence of decltype((x)) where x is a possibly\n  //   parenthesized id-expression that names an entity of automatic\n  //   storage duration is treated as if x were transformed into an\n  //   access to a corresponding data member of the closure type that\n  //   would have been declared if x were an odr-use of the denoted\n  //   entity.\n  using namespace sema;\n  if (S.getCurLambda()) {\n    if (isa<ParenExpr>(E)) {\n      if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParens())) {\n        if (VarDecl *Var = dyn_cast<VarDecl>(DRE->getDecl())) {\n          QualType T = S.getCapturedDeclRefType(Var, DRE->getLocation());\n          if (!T.isNull())\n            return S.Context.getLValueReferenceType(T);\n        }\n      }\n    }\n  }\n\n\n  // C++11 [dcl.type.simple]p4:\n  //   [...]\n  QualType T = E->getType();\n  switch (E->getValueKind()) {\n  //     - otherwise, if e is an xvalue, decltype(e) is T&&, where T is the\n  //       type of e;\n  case VK_XValue: T = S.Context.getRValueReferenceType(T); break;\n  //     - otherwise, if e is an lvalue, decltype(e) is T&, where T is the\n  //       type of e;\n  case VK_LValue: T = S.Context.getLValueReferenceType(T); break;\n  //  - otherwise, decltype(e) is the type of e.\n  case VK_RValue: break;\n  }\n\n  return T;\n}\n\nQualType Sema::BuildDecltypeType(Expr *E, SourceLocation Loc,\n                                 bool AsUnevaluated) {\n  assert(!E->hasPlaceholderType() && \"unexpected placeholder\");\n\n  if (AsUnevaluated && CodeSynthesisContexts.empty() &&\n      !E->isInstantiationDependent() && E->HasSideEffects(Context, false)) {\n    // The expression operand for decltype is in an unevaluated expression\n    // context, so side effects could result in unintended consequences.\n    // Exclude instantiation-dependent expressions, because 'decltype' is often\n    // used to build SFINAE gadgets.\n    Diag(E->getExprLoc(), diag::warn_side_effects_unevaluated_context);\n  }\n\n  return Context.getDecltypeType(E, getDecltypeForExpr(*this, E));\n}\n\nQualType Sema::BuildUnaryTransformType(QualType BaseType,\n                                       UnaryTransformType::UTTKind UKind,\n                                       SourceLocation Loc) {\n  switch (UKind) {\n  case UnaryTransformType::EnumUnderlyingType:\n    if (!BaseType->isDependentType() && !BaseType->isEnumeralType()) {\n      Diag(Loc, diag::err_only_enums_have_underlying_types);\n      return QualType();\n    } else {\n      QualType Underlying = BaseType;\n      if (!BaseType->isDependentType()) {\n        // The enum could be incomplete if we're parsing its definition or\n        // recovering from an error.\n        NamedDecl *FwdDecl = nullptr;\n        if (BaseType->isIncompleteType(&FwdDecl)) {\n          Diag(Loc, diag::err_underlying_type_of_incomplete_enum) << BaseType;\n          Diag(FwdDecl->getLocation(), diag::note_forward_declaration) << FwdDecl;\n          return QualType();\n        }\n\n        EnumDecl *ED = BaseType->castAs<EnumType>()->getDecl();\n        assert(ED && \"EnumType has no EnumDecl\");\n\n        DiagnoseUseOfDecl(ED, Loc);\n\n        Underlying = ED->getIntegerType();\n        assert(!Underlying.isNull());\n      }\n      return Context.getUnaryTransformType(BaseType, Underlying,\n                                        UnaryTransformType::EnumUnderlyingType);\n    }\n  }\n  llvm_unreachable(\"unknown unary transform type\");\n}\n\nQualType Sema::BuildAtomicType(QualType T, SourceLocation Loc) {\n  if (!T->isDependentType()) {\n    // FIXME: It isn't entirely clear whether incomplete atomic types\n    // are allowed or not; for simplicity, ban them for the moment.\n    if (RequireCompleteType(Loc, T, diag::err_atomic_specifier_bad_type, 0))\n      return QualType();\n\n    int DisallowedKind = -1;\n    if (T->isArrayType())\n      DisallowedKind = 1;\n    else if (T->isFunctionType())\n      DisallowedKind = 2;\n    else if (T->isReferenceType())\n      DisallowedKind = 3;\n    else if (T->isAtomicType())\n      DisallowedKind = 4;\n    else if (T.hasQualifiers())\n      DisallowedKind = 5;\n    else if (T->isSizelessType())\n      DisallowedKind = 6;\n    else if (!T.isTriviallyCopyableType(Context))\n      // Some other non-trivially-copyable type (probably a C++ class)\n      DisallowedKind = 7;\n    else if (T->isExtIntType()) {\n        DisallowedKind = 8;\n    }\n\n    if (DisallowedKind != -1) {\n      Diag(Loc, diag::err_atomic_specifier_bad_type) << DisallowedKind << T;\n      return QualType();\n    }\n\n    // FIXME: Do we need any handling for ARC here?\n  }\n\n  // Build the pointer type.\n  return Context.getAtomicType(T);\n}\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 14, "line": 2272}, "message": "'VLADiagnoser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaType.cpp", "reportHash": "307bd30ef5b12dc4187acc0232f5f253", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
