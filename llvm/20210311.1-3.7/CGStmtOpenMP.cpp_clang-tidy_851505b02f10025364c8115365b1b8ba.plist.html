<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "content": "//===- StmtOpenMP.h - Classes for OpenMP directives  ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file defines OpenMP AST classes for executable directives and\n/// clauses.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMTOPENMP_H\n#define LLVM_CLANG_AST_STMTOPENMP_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n\nnamespace clang {\n\n//===----------------------------------------------------------------------===//\n// AST classes for directives.\n//===----------------------------------------------------------------------===//\n\n/// Representation of an OpenMP canonical loop.\n///\n/// OpenMP 1.0 C/C++, section 2.4.1 for Construct; canonical-shape\n/// OpenMP 2.0 C/C++, section 2.4.1 for Construct; canonical-shape\n/// OpenMP 2.5, section 2.5.1 Loop Construct; canonical form\n/// OpenMP 3.1, section 2.5.1 Loop Construct; canonical form\n/// OpenMP 4.0, section 2.6 Canonical Loop Form\n/// OpenMP 4.5, section 2.6 Canonical Loop Form\n/// OpenMP 5.0, section 2.9.1 Canonical Loop Form\n/// OpenMP 5.1, section 2.11.1 Canonical Loop Nest Form\n///\n/// An OpenMP canonical loop is a for-statement or range-based for-statement\n/// with additional requirements that ensure that the number of iterations is\n/// known before entering the loop and allow skipping to an arbitrary iteration.\n/// The OMPCanonicalLoop AST node wraps a ForStmt or CXXForRangeStmt that is\n/// known to fulfill OpenMP's canonical loop requirements because of being\n/// associated to an OMPLoopBasedDirective. That is, the general structure is:\n///\n///  OMPLoopBasedDirective\n/// [`- CapturedStmt   ]\n/// [   `- CapturedDecl]\n///        ` OMPCanonicalLoop\n///          `- ForStmt/CXXForRangeStmt\n///             `- Stmt\n///\n/// One or multiple CapturedStmt/CapturedDecl pairs may be inserted by some\n/// directives such as OMPParallelForDirective, but others do not need them\n/// (such as OMPTileDirective). In  The OMPCanonicalLoop and\n/// ForStmt/CXXForRangeStmt pair is repeated for loop associated with the\n/// directive. A OMPCanonicalLoop must not appear in the AST unless associated\n/// with a OMPLoopBasedDirective. In an imperfectly nested loop nest, the\n/// OMPCanonicalLoop may also be wrapped in a CompoundStmt:\n///\n/// [...]\n///  ` OMPCanonicalLoop\n///    `- ForStmt/CXXForRangeStmt\n///       `- CompoundStmt\n///          |- Leading in-between code (if any)\n///          |- OMPCanonicalLoop\n///          |  `- ForStmt/CXXForRangeStmt\n///          |     `- ...\n///          `- Trailing in-between code (if any)\n///\n/// The leading/trailing in-between code must not itself be a OMPCanonicalLoop\n/// to avoid confusion which loop belongs to the nesting.\n///\n/// There are three different kinds of iteration variables for different\n/// purposes:\n/// * Loop user variable: The user-accessible variable with different value for\n///   each iteration.\n/// * Loop iteration variable: The variable used to identify a loop iteration;\n///   for range-based for-statement, this is the hidden iterator '__begin'. For\n///   other loops, it is identical to the loop user variable. Must be a\n///   random-access iterator, pointer or integer type.\n/// * Logical iteration counter: Normalized loop counter starting at 0 and\n///   incrementing by one at each iteration. Allows abstracting over the type\n///   of the loop iteration variable and is always an unsigned integer type\n///   appropriate to represent the range of the loop iteration variable. Its\n///   value corresponds to the logical iteration number in the OpenMP\n///   specification.\n///\n/// This AST node provides two captured statements:\n/// * The distance function which computes the number of iterations.\n/// * The loop user variable function that computes the loop user variable when\n///   given a logical iteration number.\n///\n/// These captured statements provide the link between C/C++ semantics and the\n/// logical iteration counters used by the OpenMPIRBuilder which is\n/// language-agnostic and therefore does not know e.g. how to advance a\n/// random-access iterator. The OpenMPIRBuilder will use this information to\n/// apply simd, workshare-loop, distribute, taskloop and loop directives to the\n/// loop. For compatibility with the non-OpenMPIRBuilder codegen path, an\n/// OMPCanonicalLoop can itself also be wrapped into the CapturedStmts of an\n/// OMPLoopDirective and skipped when searching for the associated syntactical\n/// loop.\n///\n/// Example:\n/// <code>\n///   std::vector<std::string> Container{1,2,3};\n///   for (std::string Str : Container)\n///      Body(Str);\n/// </code>\n/// which is syntactic sugar for approximately:\n/// <code>\n///   auto &&__range = Container;\n///   auto __begin = std::begin(__range);\n///   auto __end = std::end(__range);\n///   for (; __begin != __end; ++__begin) {\n///     std::String Str = *__begin;\n///     Body(Str);\n///   }\n/// </code>\n/// In this example, the loop user variable is `Str`, the loop iteration\n/// variable is `__begin` of type `std::vector<std::string>::iterator` and the\n/// logical iteration number type is `size_t` (unsigned version of\n/// `std::vector<std::string>::iterator::difference_type` aka `ptrdiff_t`).\n/// Therefore, the distance function will be\n/// <code>\n///   [&](size_t &Result) { Result = __end - __begin; }\n/// </code>\n/// and the loop variable function is\n/// <code>\n///   [&,__begin](std::vector<std::string>::iterator &Result, size_t Logical) {\n///     Result = __begin + Logical;\n///   }\n/// </code>\n/// The variable `__begin`, aka the loop iteration variable, is captured by\n/// value because it is modified in the loop body, but both functions require\n/// the initial value. The OpenMP specification explicitly leaves unspecified\n/// when the loop expressions are evaluated such that a capture by reference is\n/// sufficient.\nclass OMPCanonicalLoop : public Stmt {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Children of this AST node.\n  enum {\n    LOOP_STMT,\n    DISTANCE_FUNC,\n    LOOPVAR_FUNC,\n    LOOPVAR_REF,\n    LastSubStmt = LOOPVAR_REF\n  };\n\nprivate:\n  /// This AST node's children.\n  Stmt *SubStmts[LastSubStmt + 1] = {};\n\n  OMPCanonicalLoop() : Stmt(StmtClass::OMPCanonicalLoopClass) {}\n\npublic:\n  /// Create a new OMPCanonicalLoop.\n  static OMPCanonicalLoop *create(const ASTContext &Ctx, Stmt *LoopStmt,\n                                  CapturedStmt *DistanceFunc,\n                                  CapturedStmt *LoopVarFunc,\n                                  DeclRefExpr *LoopVarRef) {\n    OMPCanonicalLoop *S = new (Ctx) OMPCanonicalLoop();\n    S->setLoopStmt(LoopStmt);\n    S->setDistanceFunc(DistanceFunc);\n    S->setLoopVarFunc(LoopVarFunc);\n    S->setLoopVarRef(LoopVarRef);\n    return S;\n  }\n\n  /// Create an empty OMPCanonicalLoop for deserialization.\n  static OMPCanonicalLoop *createEmpty(const ASTContext &Ctx) {\n    return new (Ctx) OMPCanonicalLoop();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == StmtClass::OMPCanonicalLoopClass;\n  }\n\n  SourceLocation getBeginLoc() const { return getLoopStmt()->getBeginLoc(); }\n  SourceLocation getEndLoc() const { return getLoopStmt()->getEndLoc(); }\n\n  /// Return this AST node's children.\n  /// @{\n  child_range children() {\n    return child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  /// @}\n\n  /// The wrapped syntactic loop statement (ForStmt or CXXForRangeStmt).\n  /// @{\n  Stmt *getLoopStmt() { return SubStmts[LOOP_STMT]; }\n  const Stmt *getLoopStmt() const { return SubStmts[LOOP_STMT]; }\n  void setLoopStmt(Stmt *S) {\n    assert((isa<ForStmt>(S) || isa<CXXForRangeStmt>(S)) &&\n           \"Canonical loop must be a for loop (range-based or otherwise)\");\n    SubStmts[LOOP_STMT] = S;\n  }\n  /// @}\n\n  /// The function that computes the number of loop iterations. Can be evaluated\n  /// before entering the loop but after the syntactical loop's init\n  /// statement(s).\n  ///\n  /// Function signature: void(LogicalTy &Result)\n  /// Any values necessary to compute the distance are captures of the closure.\n  /// @{\n  CapturedStmt *getDistanceFunc() {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  const CapturedStmt *getDistanceFunc() const {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  void setDistanceFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[DISTANCE_FUNC] = S;\n  }\n  /// @}\n\n  /// The function that computes the loop user variable from a logical iteration\n  /// counter. Can be evaluated as first statement in the loop.\n  ///\n  /// Function signature: void(LoopVarTy &Result, LogicalTy Number)\n  /// Any other values required to compute the loop user variable (such as start\n  /// value, step size) are captured by the closure. In particular, the initial\n  /// value of loop iteration variable is captured by value to be unaffected by\n  /// previous iterations.\n  /// @{\n  CapturedStmt *getLoopVarFunc() {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  const CapturedStmt *getLoopVarFunc() const {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  void setLoopVarFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[LOOPVAR_FUNC] = S;\n  }\n  /// @}\n\n  /// Reference to the loop user variable as accessed in the loop body.\n  /// @{\n  DeclRefExpr *getLoopVarRef() {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  const DeclRefExpr *getLoopVarRef() const {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  void setLoopVarRef(DeclRefExpr *E) {\n    assert(E && \"Expected non-null loop variable\");\n    SubStmts[LOOPVAR_REF] = E;\n  }\n  /// @}\n};\n\n/// This is a basic class for representing single OpenMP executable\n/// directive.\n///\nclass OMPExecutableDirective : public Stmt {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Kind of the directive.\n  OpenMPDirectiveKind Kind = llvm::omp::OMPD_unknown;\n  /// Starting location of the directive (directive keyword).\n  SourceLocation StartLoc;\n  /// Ending location of the directive.\n  SourceLocation EndLoc;\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\nprotected:\n  /// Data, associated with the directive.\n  OMPChildren *Data = nullptr;\n\n  /// Build instance of directive of class \\a K.\n  ///\n  /// \\param SC Statement class.\n  /// \\param K Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPExecutableDirective(StmtClass SC, OpenMPDirectiveKind K,\n                         SourceLocation StartLoc, SourceLocation EndLoc)\n      : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),\n        EndLoc(std::move(EndLoc)) {}\n\n  template <typename T, typename... Params>\n  static T *createDirective(const ASTContext &C, ArrayRef<OMPClause *> Clauses,\n                            Stmt *AssociatedStmt, unsigned NumChildren,\n                            Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(Clauses.size(), AssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n\n    auto *Data = OMPChildren::Create(reinterpret_cast<T *>(Mem) + 1, Clauses,\n                                     AssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T, typename... Params>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt, unsigned NumChildren,\n                                 Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt = false,\n                                 unsigned NumChildren = 0) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T;\n    Inst->Data = Data;\n    return Inst;\n  }\n\npublic:\n  /// Iterates over expressions/statements used in the construct.\n  class used_clauses_child_iterator\n      : public llvm::iterator_adaptor_base<\n            used_clauses_child_iterator, ArrayRef<OMPClause *>::iterator,\n            std::forward_iterator_tag, Stmt *, ptrdiff_t, Stmt *, Stmt *> {\n    ArrayRef<OMPClause *>::iterator End;\n    OMPClause::child_iterator ChildI, ChildEnd;\n\n    void MoveToNext() {\n      if (ChildI != ChildEnd)\n        return;\n      while (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n          if (ChildI != ChildEnd)\n            return;\n        }\n      }\n    }\n\n  public:\n    explicit used_clauses_child_iterator(ArrayRef<OMPClause *> Clauses)\n        : used_clauses_child_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      if (this->I != End) {\n        ChildI = (*this->I)->used_children().begin();\n        ChildEnd = (*this->I)->used_children().end();\n        MoveToNext();\n      }\n    }\n    Stmt *operator*() const { return *ChildI; }\n    Stmt *operator->() const { return **this; }\n\n    used_clauses_child_iterator &operator++() {\n      ++ChildI;\n      if (ChildI != ChildEnd)\n        return *this;\n      if (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n        }\n      }\n      MoveToNext();\n      return *this;\n    }\n  };\n\n  static llvm::iterator_range<used_clauses_child_iterator>\n  used_clauses_children(ArrayRef<OMPClause *> Clauses) {\n    return {used_clauses_child_iterator(Clauses),\n            used_clauses_child_iterator(llvm::makeArrayRef(Clauses.end(), 0))};\n  }\n\n  /// Iterates over a filtered subrange of clauses applied to a\n  /// directive.\n  ///\n  /// This iterator visits only clauses of type SpecificClause.\n  template <typename SpecificClause>\n  class specific_clause_iterator\n      : public llvm::iterator_adaptor_base<\n            specific_clause_iterator<SpecificClause>,\n            ArrayRef<OMPClause *>::const_iterator, std::forward_iterator_tag,\n            const SpecificClause *, ptrdiff_t, const SpecificClause *,\n            const SpecificClause *> {\n    ArrayRef<OMPClause *>::const_iterator End;\n\n    void SkipToNextClause() {\n      while (this->I != End && !isa<SpecificClause>(*this->I))\n        ++this->I;\n    }\n\n  public:\n    explicit specific_clause_iterator(ArrayRef<OMPClause *> Clauses)\n        : specific_clause_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      SkipToNextClause();\n    }\n\n    const SpecificClause *operator*() const {\n      return cast<SpecificClause>(*this->I);\n    }\n    const SpecificClause *operator->() const { return **this; }\n\n    specific_clause_iterator &operator++() {\n      ++this->I;\n      SkipToNextClause();\n      return *this;\n    }\n  };\n\n  template <typename SpecificClause>\n  static llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind(ArrayRef<OMPClause *> Clauses) {\n    return {specific_clause_iterator<SpecificClause>(Clauses),\n            specific_clause_iterator<SpecificClause>(\n                llvm::makeArrayRef(Clauses.end(), 0))};\n  }\n\n  template <typename SpecificClause>\n  llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind() const {\n    return getClausesOfKind<SpecificClause>(clauses());\n  }\n\n  /// Gets a single clause of the specified kind associated with the\n  /// current directive iff there is only one clause of this kind (and assertion\n  /// is fired if there is more than one clause is associated with the\n  /// directive). Returns nullptr if no clause of this kind is associated with\n  /// the directive.\n  template <typename SpecificClause>\n  const SpecificClause *getSingleClause() const {\n    auto Clauses = getClausesOfKind<SpecificClause>();\n\n    if (Clauses.begin() != Clauses.end()) {\n      assert(std::next(Clauses.begin()) == Clauses.end() &&\n             \"There are at least 2 clauses of the specified kind\");\n      return *Clauses.begin();\n    }\n    return nullptr;\n  }\n\n  /// Returns true if the current directive has one or more clauses of a\n  /// specific kind.\n  template <typename SpecificClause>\n  bool hasClausesOfKind() const {\n    auto Clauses = getClausesOfKind<SpecificClause>();\n    return Clauses.begin() != Clauses.end();\n  }\n\n  /// Returns starting location of directive kind.\n  SourceLocation getBeginLoc() const { return StartLoc; }\n  /// Returns ending location of directive.\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  /// Set starting location of directive kind.\n  ///\n  /// \\param Loc New starting location of directive.\n  ///\n  void setLocStart(SourceLocation Loc) { StartLoc = Loc; }\n  /// Set ending location of directive.\n  ///\n  /// \\param Loc New ending location of directive.\n  ///\n  void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }\n\n  /// Get number of clauses.\n  unsigned getNumClauses() const {\n    if (!Data)\n      return 0;\n    return Data->getNumClauses();\n  }\n\n  /// Returns specified clause.\n  ///\n  /// \\param I Number of clause.\n  ///\n  OMPClause *getClause(unsigned I) const { return clauses()[I]; }\n\n  /// Returns true if directive has associated statement.\n  bool hasAssociatedStmt() const { return Data && Data->hasAssociatedStmt(); }\n\n  /// Returns statement associated with the directive.\n  const Stmt *getAssociatedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getAssociatedStmt();\n  }\n  Stmt *getAssociatedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getAssociatedStmt();\n  }\n\n  /// Returns the captured statement associated with the\n  /// component region within the (combined) directive.\n  ///\n  /// \\param RegionKind Component region kind.\n  const CapturedStmt *getCapturedStmt(OpenMPDirectiveKind RegionKind) const {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getCapturedStmt(RegionKind, CaptureRegions);\n  }\n\n  /// Get innermost captured statement for the construct.\n  CapturedStmt *getInnermostCapturedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getInnermostCapturedStmt(CaptureRegions);\n  }\n\n  const CapturedStmt *getInnermostCapturedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)\n        ->getInnermostCapturedStmt();\n  }\n\n  OpenMPDirectiveKind getDirectiveKind() const { return Kind; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstOMPExecutableDirectiveConstant &&\n           S->getStmtClass() <= lastOMPExecutableDirectiveConstant;\n  }\n\n  child_range children() {\n    if (!Data)\n      return child_range(child_iterator(), child_iterator());\n    return Data->getAssociatedStmtAsRange();\n  }\n\n  const_child_range children() const {\n    return const_cast<OMPExecutableDirective *>(this)->children();\n  }\n\n  ArrayRef<OMPClause *> clauses() const {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\n  /// Returns whether or not this is a Standalone directive.\n  ///\n  /// Stand-alone directives are executable directives\n  /// that have no associated user code.\n  bool isStandaloneDirective() const;\n\n  /// Returns the AST node representing OpenMP structured-block of this\n  /// OpenMP executable directive,\n  /// Prerequisite: Executable Directive must not be Standalone directive.\n  const Stmt *getStructuredBlock() const {\n    return const_cast<OMPExecutableDirective *>(this)->getStructuredBlock();\n  }\n  Stmt *getStructuredBlock();\n\n  const Stmt *getRawStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getRawStmt();\n  }\n  Stmt *getRawStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getRawStmt();\n  }\n};\n\n/// This represents '#pragma omp parallel' directive.\n///\n/// \\code\n/// #pragma omp parallel private(a,b) reduction(+: c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clauses 'private'\n/// with the variables 'a' and 'b' and 'reduction' with operator '+' and\n/// variables 'c' and 'd'.\n///\nclass OMPParallelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPParallelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelDirectiveClass,\n                               llvm::omp::OMPD_parallel, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPParallelDirective()\n      : OMPExecutableDirective(OMPParallelDirectiveClass,\n                               llvm::omp::OMPD_parallel, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPParallelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelDirectiveClass;\n  }\n};\n\n/// The base class for all loop-based directives, including loop transformation\n/// directives.\nclass OMPLoopBasedDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n\nprotected:\n  /// Number of collapsed loops as specified by 'collapse' clause.\n  unsigned NumAssociatedLoops = 0;\n\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param NumAssociatedLoops Number of loops associated with the construct.\n  ///\n  OMPLoopBasedDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                        SourceLocation StartLoc, SourceLocation EndLoc,\n                        unsigned NumAssociatedLoops)\n      : OMPExecutableDirective(SC, Kind, StartLoc, EndLoc),\n        NumAssociatedLoops(NumAssociatedLoops) {}\n\npublic:\n  /// The expressions built to support OpenMP loops in combined/composite\n  /// pragmas (e.g. pragma omp distribute parallel for)\n  struct DistCombinedHelperExprs {\n    /// DistributeLowerBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *LB;\n    /// DistributeUpperBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *UB;\n    /// DistributeEnsureUpperBound - used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct, EUB depends on DistUB\n    Expr *EUB;\n    /// Distribute loop iteration variable init used when composing 'omp\n    /// distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Init;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Cond;\n    /// Update of LowerBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NUB;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct when schedule is chunked.\n    Expr *DistCond;\n    /// 'omp parallel for' loop condition used when composed with\n    /// 'omp distribute' in the same construct and when schedule is\n    /// chunked and the chunk size is 1.\n    Expr *ParForInDistCond;\n  };\n\n  /// The expressions built for the OpenMP loop CodeGen for the\n  /// whole collapsed loop nest.\n  struct HelperExprs {\n    /// Loop iteration variable.\n    Expr *IterationVarRef;\n    /// Loop last iteration number.\n    Expr *LastIteration;\n    /// Loop number of iterations.\n    Expr *NumIterations;\n    /// Calculation of last iteration.\n    Expr *CalcLastIteration;\n    /// Loop pre-condition.\n    Expr *PreCond;\n    /// Loop condition.\n    Expr *Cond;\n    /// Loop iteration variable init.\n    Expr *Init;\n    /// Loop increment.\n    Expr *Inc;\n    /// IsLastIteration - local flag variable passed to runtime.\n    Expr *IL;\n    /// LowerBound - local variable passed to runtime.\n    Expr *LB;\n    /// UpperBound - local variable passed to runtime.\n    Expr *UB;\n    /// Stride - local variable passed to runtime.\n    Expr *ST;\n    /// EnsureUpperBound -- expression UB = min(UB, NumIterations).\n    Expr *EUB;\n    /// Update of LowerBound for statically scheduled 'omp for' loops.\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled 'omp for' loops.\n    Expr *NUB;\n    /// PreviousLowerBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevLB;\n    /// PreviousUpperBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevUB;\n    /// DistInc - increment expression for distribute loop when found\n    /// combined with a further loop level (e.g. in 'distribute parallel for')\n    /// expression IV = IV + ST\n    Expr *DistInc;\n    /// PrevEUB - expression similar to EUB but to be used when loop\n    /// scheduling uses PrevLB and PrevUB (e.g.  in 'distribute parallel for'\n    /// when ensuring that the UB is either the calculated UB by the runtime or\n    /// the end of the assigned distribute chunk)\n    /// expression UB = min (UB, PrevUB)\n    Expr *PrevEUB;\n    /// Counters Loop counters.\n    SmallVector<Expr *, 4> Counters;\n    /// PrivateCounters Loop counters.\n    SmallVector<Expr *, 4> PrivateCounters;\n    /// Expressions for loop counters inits for CodeGen.\n    SmallVector<Expr *, 4> Inits;\n    /// Expressions for loop counters update for CodeGen.\n    SmallVector<Expr *, 4> Updates;\n    /// Final loop counter values for GodeGen.\n    SmallVector<Expr *, 4> Finals;\n    /// List of counters required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentCounters;\n    /// List of initializers required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentInits;\n    /// List of final conditions required for the generation of the\n    /// non-rectangular loops.\n    SmallVector<Expr *, 4> FinalsConditions;\n    /// Init statement for all captured expressions.\n    Stmt *PreInits;\n\n    /// Expressions used when combining OpenMP loop pragmas\n    DistCombinedHelperExprs DistCombinedFields;\n\n    /// Check if all the expressions are built (does not check the\n    /// worksharing ones).\n    bool builtAll() {\n      return IterationVarRef != nullptr && LastIteration != nullptr &&\n             NumIterations != nullptr && PreCond != nullptr &&\n             Cond != nullptr && Init != nullptr && Inc != nullptr;\n    }\n\n    /// Initialize all the fields to null.\n    /// \\param Size Number of elements in the\n    /// counters/finals/updates/dependent_counters/dependent_inits/finals_conditions\n    /// arrays.\n    void clear(unsigned Size) {\n      IterationVarRef = nullptr;\n      LastIteration = nullptr;\n      CalcLastIteration = nullptr;\n      PreCond = nullptr;\n      Cond = nullptr;\n      Init = nullptr;\n      Inc = nullptr;\n      IL = nullptr;\n      LB = nullptr;\n      UB = nullptr;\n      ST = nullptr;\n      EUB = nullptr;\n      NLB = nullptr;\n      NUB = nullptr;\n      NumIterations = nullptr;\n      PrevLB = nullptr;\n      PrevUB = nullptr;\n      DistInc = nullptr;\n      PrevEUB = nullptr;\n      Counters.resize(Size);\n      PrivateCounters.resize(Size);\n      Inits.resize(Size);\n      Updates.resize(Size);\n      Finals.resize(Size);\n      DependentCounters.resize(Size);\n      DependentInits.resize(Size);\n      FinalsConditions.resize(Size);\n      for (unsigned I = 0; I < Size; ++I) {\n        Counters[I] = nullptr;\n        PrivateCounters[I] = nullptr;\n        Inits[I] = nullptr;\n        Updates[I] = nullptr;\n        Finals[I] = nullptr;\n        DependentCounters[I] = nullptr;\n        DependentInits[I] = nullptr;\n        FinalsConditions[I] = nullptr;\n      }\n      PreInits = nullptr;\n      DistCombinedFields.LB = nullptr;\n      DistCombinedFields.UB = nullptr;\n      DistCombinedFields.EUB = nullptr;\n      DistCombinedFields.Init = nullptr;\n      DistCombinedFields.Cond = nullptr;\n      DistCombinedFields.NLB = nullptr;\n      DistCombinedFields.NUB = nullptr;\n      DistCombinedFields.DistCond = nullptr;\n      DistCombinedFields.ParForInDistCond = nullptr;\n    }\n  };\n\n  /// Get number of collapsed loops.\n  unsigned getLoopsNumber() const { return NumAssociatedLoops; }\n\n  /// Try to find the next loop sub-statement in the specified statement \\p\n  /// CurStmt.\n  /// \\param TryImperfectlyNestedLoops true, if we need to try to look for the\n  /// imperfectly nested loop.\n  static Stmt *tryToFindNextInnerLoop(Stmt *CurStmt,\n                                      bool TryImperfectlyNestedLoops);\n  static const Stmt *tryToFindNextInnerLoop(const Stmt *CurStmt,\n                                            bool TryImperfectlyNestedLoops) {\n    return tryToFindNextInnerLoop(const_cast<Stmt *>(CurStmt),\n                                  TryImperfectlyNestedLoops);\n  }\n\n  /// Calls the specified callback function for all the loops in \\p CurStmt,\n  /// from the outermost to the innermost.\n  static bool\n  doForAllLoops(Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, Stmt *)> Callback);\n  static bool\n  doForAllLoops(const Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *CurStmt) {\n      return Callback(Cnt, CurStmt);\n    };\n    return doForAllLoops(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                         NumLoops, NewCallback);\n  }\n\n  /// Calls the specified callback function for all the loop bodies in \\p\n  /// CurStmt, from the outermost loop to the innermost.\n  static void doForAllLoopsBodies(\n      Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, Stmt *, Stmt *)> Callback);\n  static void doForAllLoopsBodies(\n      const Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, const Stmt *, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *Loop, Stmt *Body) {\n      Callback(Cnt, Loop, Body);\n    };\n    doForAllLoopsBodies(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                        NumLoops, NewCallback);\n  }\n\n  static bool classof(const Stmt *T) {\n    if (auto *D = dyn_cast<OMPExecutableDirective>(T))\n      return isOpenMPLoopDirective(D->getDirectiveKind());\n    return false;\n  }\n};\n\n/// This is a common base class for loop directives ('omp simd', 'omp\n/// for', 'omp for simd' etc.). It is responsible for the loop code generation.\n///\nclass OMPLoopDirective : public OMPLoopBasedDirective {\n  friend class ASTStmtReader;\n\n  /// Offsets to the stored exprs.\n  /// This enumeration contains offsets to all the pointers to children\n  /// expressions stored in OMPLoopDirective.\n  /// The first 9 children are necessary for all the loop directives,\n  /// the next 8 are specific to the worksharing ones, and the next 11 are\n  /// used for combined constructs containing two pragmas associated to loops.\n  /// After the fixed children, three arrays of length NumAssociatedLoops are\n  /// allocated: loop counters, their updates and final values.\n  /// PrevLowerBound and PrevUpperBound are used to communicate blocking\n  /// information in composite constructs which require loop blocking\n  /// DistInc is used to generate the increment expression for the distribute\n  /// loop when combined with a further nested loop\n  /// PrevEnsureUpperBound is used as the EnsureUpperBound expression for the\n  /// for loop when combined with a previous distribute loop in the same pragma\n  /// (e.g. 'distribute parallel for')\n  ///\n  enum {\n    IterationVariableOffset = 0,\n    LastIterationOffset = 1,\n    CalcLastIterationOffset = 2,\n    PreConditionOffset = 3,\n    CondOffset = 4,\n    InitOffset = 5,\n    IncOffset = 6,\n    PreInitsOffset = 7,\n    // The '...End' enumerators do not correspond to child expressions - they\n    // specify the offset to the end (and start of the following counters/\n    // updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays).\n    DefaultEnd = 8,\n    // The following 8 exprs are used by worksharing and distribute loops only.\n    IsLastIterVariableOffset = 8,\n    LowerBoundVariableOffset = 9,\n    UpperBoundVariableOffset = 10,\n    StrideVariableOffset = 11,\n    EnsureUpperBoundOffset = 12,\n    NextLowerBoundOffset = 13,\n    NextUpperBoundOffset = 14,\n    NumIterationsOffset = 15,\n    // Offset to the end for worksharing loop directives.\n    WorksharingEnd = 16,\n    PrevLowerBoundVariableOffset = 16,\n    PrevUpperBoundVariableOffset = 17,\n    DistIncOffset = 18,\n    PrevEnsureUpperBoundOffset = 19,\n    CombinedLowerBoundVariableOffset = 20,\n    CombinedUpperBoundVariableOffset = 21,\n    CombinedEnsureUpperBoundOffset = 22,\n    CombinedInitOffset = 23,\n    CombinedConditionOffset = 24,\n    CombinedNextLowerBoundOffset = 25,\n    CombinedNextUpperBoundOffset = 26,\n    CombinedDistConditionOffset = 27,\n    CombinedParForInDistConditionOffset = 28,\n    // Offset to the end (and start of the following\n    // counters/updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays) for combined distribute loop directives.\n    CombinedDistributeEnd = 29,\n  };\n\n  /// Get the counters storage.\n  MutableArrayRef<Expr *> getCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind())]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the private counters storage.\n  MutableArrayRef<Expr *> getPrivateCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             2 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getUpdates() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             3 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the final counter updates storage.\n  MutableArrayRef<Expr *> getFinals() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             4 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent counters storage.\n  MutableArrayRef<Expr *> getDependentCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             5 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent inits storage.\n  MutableArrayRef<Expr *> getDependentInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             6 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the finals conditions storage.\n  MutableArrayRef<Expr *> getFinalsConditions() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             7 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\nprotected:\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops from 'collapse' clause.\n  ///\n  OMPLoopDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                   SourceLocation StartLoc, SourceLocation EndLoc,\n                   unsigned CollapsedNum)\n      : OMPLoopBasedDirective(SC, Kind, StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Offset to the start of children expression arrays.\n  static unsigned getArraysOffset(OpenMPDirectiveKind Kind) {\n    if (isOpenMPLoopBoundSharingDirective(Kind))\n      return CombinedDistributeEnd;\n    if (isOpenMPWorksharingDirective(Kind) || isOpenMPTaskLoopDirective(Kind) ||\n        isOpenMPDistributeDirective(Kind))\n      return WorksharingEnd;\n    return DefaultEnd;\n  }\n\n  /// Children number.\n  static unsigned numLoopChildren(unsigned CollapsedNum,\n                                  OpenMPDirectiveKind Kind) {\n    return getArraysOffset(Kind) +\n           8 * CollapsedNum; // Counters, PrivateCounters, Inits,\n                             // Updates, Finals, DependentCounters,\n                             // DependentInits, FinalsConditions.\n  }\n\n  void setIterationVariable(Expr *IV) {\n    Data->getChildren()[IterationVariableOffset] = IV;\n  }\n  void setLastIteration(Expr *LI) {\n    Data->getChildren()[LastIterationOffset] = LI;\n  }\n  void setCalcLastIteration(Expr *CLI) {\n    Data->getChildren()[CalcLastIterationOffset] = CLI;\n  }\n  void setPreCond(Expr *PC) { Data->getChildren()[PreConditionOffset] = PC; }\n  void setCond(Expr *Cond) { Data->getChildren()[CondOffset] = Cond; }\n  void setInit(Expr *Init) { Data->getChildren()[InitOffset] = Init; }\n  void setInc(Expr *Inc) { Data->getChildren()[IncOffset] = Inc; }\n  void setPreInits(Stmt *PreInits) {\n    Data->getChildren()[PreInitsOffset] = PreInits;\n  }\n  void setIsLastIterVariable(Expr *IL) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[IsLastIterVariableOffset] = IL;\n  }\n  void setLowerBoundVariable(Expr *LB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[LowerBoundVariableOffset] = LB;\n  }\n  void setUpperBoundVariable(Expr *UB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[UpperBoundVariableOffset] = UB;\n  }\n  void setStrideVariable(Expr *ST) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[StrideVariableOffset] = ST;\n  }\n  void setEnsureUpperBound(Expr *EUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[EnsureUpperBoundOffset] = EUB;\n  }\n  void setNextLowerBound(Expr *NLB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextLowerBoundOffset] = NLB;\n  }\n  void setNextUpperBound(Expr *NUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextUpperBoundOffset] = NUB;\n  }\n  void setNumIterations(Expr *NI) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NumIterationsOffset] = NI;\n  }\n  void setPrevLowerBoundVariable(Expr *PrevLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevLowerBoundVariableOffset] = PrevLB;\n  }\n  void setPrevUpperBoundVariable(Expr *PrevUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevUpperBoundVariableOffset] = PrevUB;\n  }\n  void setDistInc(Expr *DistInc) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[DistIncOffset] = DistInc;\n  }\n  void setPrevEnsureUpperBound(Expr *PrevEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevEnsureUpperBoundOffset] = PrevEUB;\n  }\n  void setCombinedLowerBoundVariable(Expr *CombLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedLowerBoundVariableOffset] = CombLB;\n  }\n  void setCombinedUpperBoundVariable(Expr *CombUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedUpperBoundVariableOffset] = CombUB;\n  }\n  void setCombinedEnsureUpperBound(Expr *CombEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedEnsureUpperBoundOffset] = CombEUB;\n  }\n  void setCombinedInit(Expr *CombInit) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedInitOffset] = CombInit;\n  }\n  void setCombinedCond(Expr *CombCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedConditionOffset] = CombCond;\n  }\n  void setCombinedNextLowerBound(Expr *CombNLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextLowerBoundOffset] = CombNLB;\n  }\n  void setCombinedNextUpperBound(Expr *CombNUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextUpperBoundOffset] = CombNUB;\n  }\n  void setCombinedDistCond(Expr *CombDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedDistConditionOffset] = CombDistCond;\n  }\n  void setCombinedParForInDistCond(Expr *CombParForInDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedParForInDistConditionOffset] =\n        CombParForInDistCond;\n  }\n  void setCounters(ArrayRef<Expr *> A);\n  void setPrivateCounters(ArrayRef<Expr *> A);\n  void setInits(ArrayRef<Expr *> A);\n  void setUpdates(ArrayRef<Expr *> A);\n  void setFinals(ArrayRef<Expr *> A);\n  void setDependentCounters(ArrayRef<Expr *> A);\n  void setDependentInits(ArrayRef<Expr *> A);\n  void setFinalsConditions(ArrayRef<Expr *> A);\n\npublic:\n  Expr *getIterationVariable() const {\n    return cast<Expr>(Data->getChildren()[IterationVariableOffset]);\n  }\n  Expr *getLastIteration() const {\n    return cast<Expr>(Data->getChildren()[LastIterationOffset]);\n  }\n  Expr *getCalcLastIteration() const {\n    return cast<Expr>(Data->getChildren()[CalcLastIterationOffset]);\n  }\n  Expr *getPreCond() const {\n    return cast<Expr>(Data->getChildren()[PreConditionOffset]);\n  }\n  Expr *getCond() const { return cast<Expr>(Data->getChildren()[CondOffset]); }\n  Expr *getInit() const { return cast<Expr>(Data->getChildren()[InitOffset]); }\n  Expr *getInc() const { return cast<Expr>(Data->getChildren()[IncOffset]); }\n  const Stmt *getPreInits() const {\n    return Data->getChildren()[PreInitsOffset];\n  }\n  Stmt *getPreInits() { return Data->getChildren()[PreInitsOffset]; }\n  Expr *getIsLastIterVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[IsLastIterVariableOffset]);\n  }\n  Expr *getLowerBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[LowerBoundVariableOffset]);\n  }\n  Expr *getUpperBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[UpperBoundVariableOffset]);\n  }\n  Expr *getStrideVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[StrideVariableOffset]);\n  }\n  Expr *getEnsureUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[EnsureUpperBoundOffset]);\n  }\n  Expr *getNextLowerBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextLowerBoundOffset]);\n  }\n  Expr *getNextUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextUpperBoundOffset]);\n  }\n  Expr *getNumIterations() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NumIterationsOffset]);\n  }\n  Expr *getPrevLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevLowerBoundVariableOffset]);\n  }\n  Expr *getPrevUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevUpperBoundVariableOffset]);\n  }\n  Expr *getDistInc() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[DistIncOffset]);\n  }\n  Expr *getPrevEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedLowerBoundVariableOffset]);\n  }\n  Expr *getCombinedUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedUpperBoundVariableOffset]);\n  }\n  Expr *getCombinedEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedInit() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedInitOffset]);\n  }\n  Expr *getCombinedCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedConditionOffset]);\n  }\n  Expr *getCombinedNextLowerBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextLowerBoundOffset]);\n  }\n  Expr *getCombinedNextUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextUpperBoundOffset]);\n  }\n  Expr *getCombinedDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedDistConditionOffset]);\n  }\n  Expr *getCombinedParForInDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedParForInDistConditionOffset]);\n  }\n  Stmt *getBody();\n  const Stmt *getBody() const {\n    return const_cast<OMPLoopDirective *>(this)->getBody();\n  }\n\n  ArrayRef<Expr *> counters() { return getCounters(); }\n\n  ArrayRef<Expr *> counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getCounters();\n  }\n\n  ArrayRef<Expr *> private_counters() { return getPrivateCounters(); }\n\n  ArrayRef<Expr *> private_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getPrivateCounters();\n  }\n\n  ArrayRef<Expr *> inits() { return getInits(); }\n\n  ArrayRef<Expr *> inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getInits();\n  }\n\n  ArrayRef<Expr *> updates() { return getUpdates(); }\n\n  ArrayRef<Expr *> updates() const {\n    return const_cast<OMPLoopDirective *>(this)->getUpdates();\n  }\n\n  ArrayRef<Expr *> finals() { return getFinals(); }\n\n  ArrayRef<Expr *> finals() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinals();\n  }\n\n  ArrayRef<Expr *> dependent_counters() { return getDependentCounters(); }\n\n  ArrayRef<Expr *> dependent_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentCounters();\n  }\n\n  ArrayRef<Expr *> dependent_inits() { return getDependentInits(); }\n\n  ArrayRef<Expr *> dependent_inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentInits();\n  }\n\n  ArrayRef<Expr *> finals_conditions() { return getFinalsConditions(); }\n\n  ArrayRef<Expr *> finals_conditions() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinalsConditions();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSimdDirectiveClass ||\n           T->getStmtClass() == OMPForDirectiveClass ||\n           T->getStmtClass() == OMPForSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelForDirectiveClass ||\n           T->getStmtClass() == OMPParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp simd' directive.\n///\n/// \\code\n/// #pragma omp simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and\n/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.\n///\nclass OMPSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                   unsigned CollapsedNum)\n      : OMPLoopDirective(OMPSimdDirectiveClass, llvm::omp::OMPD_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPSimdDirectiveClass, llvm::omp::OMPD_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPSimdDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc, unsigned CollapsedNum,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  Stmt *AssociatedStmt,\n                                  const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSimdDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp for' directive.\n///\n/// \\code\n/// #pragma omp for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp for' has clauses 'private' with the\n/// variables 'a' and 'b' and 'reduction' with operator '+' and variables 'c'\n/// and 'd'.\n///\nclass OMPForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                  unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(getLoopsNumber(),\n                                        llvm::omp::OMPD_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPForDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation EndLoc, unsigned CollapsedNum,\n                                 ArrayRef<OMPClause *> Clauses,\n                                 Stmt *AssociatedStmt, const HelperExprs &Exprs,\n                                 Expr *TaskRedRef, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPForDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                      unsigned CollapsedNum, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPForDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp for simd' directive.\n///\n/// \\code\n/// #pragma omp for simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp for simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and\n/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.\n///\nclass OMPForSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                      unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForSimdDirectiveClass, llvm::omp::OMPD_for_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForSimdDirectiveClass, llvm::omp::OMPD_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPForSimdDirective *CreateEmpty(const ASTContext &C,\n                                          unsigned NumClauses,\n                                          unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp sections' directive.\n///\n/// \\code\n/// #pragma omp sections private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp sections' has clauses 'private' with\n/// the variables 'a' and 'b' and 'reduction' with operator '+' and variables\n/// 'c' and 'd'.\n///\nclass OMPSectionsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSectionsDirectiveClass,\n                               llvm::omp::OMPD_sections, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSectionsDirective()\n      : OMPExecutableDirective(OMPSectionsDirectiveClass,\n                               llvm::omp::OMPD_sections, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner directive.\n  ///\n  static OMPSectionsDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSectionsDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPSectionsDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSectionsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp section' directive.\n///\n/// \\code\n/// #pragma omp section\n/// \\endcode\n///\nclass OMPSectionDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSectionDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSectionDirectiveClass,\n                               llvm::omp::OMPD_section, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSectionDirective()\n      : OMPExecutableDirective(OMPSectionDirectiveClass,\n                               llvm::omp::OMPD_section, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param HasCancel true if current directive has inner directive.\n  ///\n  static OMPSectionDirective *Create(const ASTContext &C,\n                                     SourceLocation StartLoc,\n                                     SourceLocation EndLoc,\n                                     Stmt *AssociatedStmt, bool HasCancel);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPSectionDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSectionDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp single' directive.\n///\n/// \\code\n/// #pragma omp single private(a,b) copyprivate(c,d)\n/// \\endcode\n/// In this example directive '#pragma omp single' has clauses 'private' with\n/// the variables 'a' and 'b' and 'copyprivate' with variables 'c' and 'd'.\n///\nclass OMPSingleDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSingleDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSingleDirectiveClass, llvm::omp::OMPD_single,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSingleDirective()\n      : OMPExecutableDirective(OMPSingleDirectiveClass, llvm::omp::OMPD_single,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPSingleDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSingleDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSingleDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master' directive.\n///\n/// \\code\n/// #pragma omp master\n/// \\endcode\n///\nclass OMPMasterDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPMasterDirectiveClass, llvm::omp::OMPD_master,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPMasterDirective()\n      : OMPExecutableDirective(OMPMasterDirectiveClass, llvm::omp::OMPD_master,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPMasterDirective *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPMasterDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp critical' directive.\n///\n/// \\code\n/// #pragma omp critical\n/// \\endcode\n///\nclass OMPCriticalDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Name of the directive.\n  DeclarationNameInfo DirName;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param Name Name of the directive.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPCriticalDirective(const DeclarationNameInfo &Name, SourceLocation StartLoc,\n                       SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCriticalDirectiveClass,\n                               llvm::omp::OMPD_critical, StartLoc, EndLoc),\n        DirName(Name) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPCriticalDirective()\n      : OMPExecutableDirective(OMPCriticalDirectiveClass,\n                               llvm::omp::OMPD_critical, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Set name of the directive.\n  ///\n  /// \\param Name Name of the directive.\n  ///\n  void setDirectiveName(const DeclarationNameInfo &Name) { DirName = Name; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param Name Name of the directive.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPCriticalDirective *\n  Create(const ASTContext &C, const DeclarationNameInfo &Name,\n         SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPCriticalDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Return name of the directive.\n  ///\n  DeclarationNameInfo getDirectiveName() const { return DirName; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCriticalDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel for' directive.\n///\n/// \\code\n/// #pragma omp parallel for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel for' has clauses 'private'\n/// with the variables 'a' and 'b' and 'reduction' with operator '+' and\n/// variables 'c' and 'd'.\n///\nclass OMPParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current region has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                          unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForDirectiveClass,\n                         llvm::omp::OMPD_parallel_for, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForDirectiveClass,\n                         llvm::omp::OMPD_parallel_for, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(getLoopsNumber(),\n                                        llvm::omp::OMPD_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelForDirective *CreateEmpty(const ASTContext &C,\n                                              unsigned NumClauses,\n                                              unsigned CollapsedNum,\n                                              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel for simd' directive.\n///\n/// \\code\n/// #pragma omp parallel for simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel for simd' has clauses\n/// 'private' with the variables 'a' and 'b', 'linear' with variables 'i', 'j'\n/// and linear step 's', 'reduction' with operator '+' and variables 'c' and\n/// 'd'.\n///\nclass OMPParallelForSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                              unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_for_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_for_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelForSimdDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned NumClauses,\n                                                  unsigned CollapsedNum,\n                                                  EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master' directive.\n///\n/// \\code\n/// #pragma omp parallel master private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master' has clauses\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPParallelMasterDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  OMPParallelMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelMasterDirectiveClass,\n                               llvm::omp::OMPD_parallel_master, StartLoc,\n                               EndLoc) {}\n\n  explicit OMPParallelMasterDirective()\n      : OMPExecutableDirective(OMPParallelMasterDirectiveClass,\n                               llvm::omp::OMPD_parallel_master,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  ///\n  static OMPParallelMasterDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelMasterDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel sections' directive.\n///\n/// \\code\n/// #pragma omp parallel sections private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel sections' has clauses\n/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'\n/// and variables 'c' and 'd'.\n///\nclass OMPParallelSectionsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPParallelSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelSectionsDirectiveClass,\n                               llvm::omp::OMPD_parallel_sections, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPParallelSectionsDirective()\n      : OMPExecutableDirective(OMPParallelSectionsDirectiveClass,\n                               llvm::omp::OMPD_parallel_sections,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPParallelSectionsDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelSectionsDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelSectionsDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelSectionsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp task' directive.\n///\n/// \\code\n/// #pragma omp task private(a,b) final(d)\n/// \\endcode\n/// In this example directive '#pragma omp task' has clauses 'private' with the\n/// variables 'a' and 'b' and 'final' with condition 'd'.\n///\nclass OMPTaskDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if this directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskDirectiveClass, llvm::omp::OMPD_task,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskDirective()\n      : OMPExecutableDirective(OMPTaskDirectiveClass, llvm::omp::OMPD_task,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param HasCancel true, if current directive has inner cancel directive.\n  ///\n  static OMPTaskDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  Stmt *AssociatedStmt, bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskyield' directive.\n///\n/// \\code\n/// #pragma omp taskyield\n/// \\endcode\n///\nclass OMPTaskyieldDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskyieldDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskyieldDirectiveClass,\n                               llvm::omp::OMPD_taskyield, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskyieldDirective()\n      : OMPExecutableDirective(OMPTaskyieldDirectiveClass,\n                               llvm::omp::OMPD_taskyield, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPTaskyieldDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPTaskyieldDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskyieldDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp barrier' directive.\n///\n/// \\code\n/// #pragma omp barrier\n/// \\endcode\n///\nclass OMPBarrierDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPBarrierDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPBarrierDirectiveClass,\n                               llvm::omp::OMPD_barrier, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPBarrierDirective()\n      : OMPExecutableDirective(OMPBarrierDirectiveClass,\n                               llvm::omp::OMPD_barrier, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPBarrierDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPBarrierDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPBarrierDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskwait' directive.\n///\n/// \\code\n/// #pragma omp taskwait\n/// \\endcode\n///\nclass OMPTaskwaitDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskwaitDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskwaitDirectiveClass,\n                               llvm::omp::OMPD_taskwait, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskwaitDirective()\n      : OMPExecutableDirective(OMPTaskwaitDirectiveClass,\n                               llvm::omp::OMPD_taskwait, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPTaskwaitDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPTaskwaitDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskwaitDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskgroup' directive.\n///\n/// \\code\n/// #pragma omp taskgroup\n/// \\endcode\n///\nclass OMPTaskgroupDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskgroupDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskgroupDirectiveClass,\n                               llvm::omp::OMPD_taskgroup, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskgroupDirective()\n      : OMPExecutableDirective(OMPTaskgroupDirectiveClass,\n                               llvm::omp::OMPD_taskgroup, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets the task_reduction return variable.\n  void setReductionRef(Expr *RR) { Data->getChildren()[0] = RR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param ReductionRef Reference to the task_reduction return variable.\n  ///\n  static OMPTaskgroupDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt,\n         Expr *ReductionRef);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskgroupDirective *CreateEmpty(const ASTContext &C,\n                                            unsigned NumClauses, EmptyShell);\n\n\n  /// Returns reference to the task_reduction return variable.\n  const Expr *getReductionRef() const {\n    return const_cast<OMPTaskgroupDirective *>(this)->getReductionRef();\n  }\n  Expr *getReductionRef() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskgroupDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp flush' directive.\n///\n/// \\code\n/// #pragma omp flush(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 2 arguments- variables 'a'\n/// and 'b'.\n/// 'omp flush' directive does not have clauses but have an optional list of\n/// variables to flush. This list of variables is stored within some fake clause\n/// FlushClause.\nclass OMPFlushDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPFlushDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPFlushDirectiveClass, llvm::omp::OMPD_flush,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPFlushDirective()\n      : OMPExecutableDirective(OMPFlushDirectiveClass, llvm::omp::OMPD_flush,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses (only single OMPFlushClause clause is\n  /// allowed).\n  ///\n  static OMPFlushDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation EndLoc,\n                                   ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPFlushDirective *CreateEmpty(const ASTContext &C,\n                                        unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPFlushDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp depobj' directive.\n///\n/// \\code\n/// #pragma omp depobj(a) depend(in:x,y)\n/// \\endcode\n/// In this example directive '#pragma omp  depobj' initializes a depobj object\n/// 'a' with dependence type 'in' and a list with 'x' and 'y' locators.\nclass OMPDepobjDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPDepobjDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPDepobjDirectiveClass, llvm::omp::OMPD_depobj,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPDepobjDirective()\n      : OMPExecutableDirective(OMPDepobjDirectiveClass, llvm::omp::OMPD_depobj,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  ///\n  static OMPDepobjDirective *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDepobjDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDepobjDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp ordered' directive.\n///\n/// \\code\n/// #pragma omp ordered\n/// \\endcode\n///\nclass OMPOrderedDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPOrderedDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPOrderedDirectiveClass,\n                               llvm::omp::OMPD_ordered, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPOrderedDirective()\n      : OMPExecutableDirective(OMPOrderedDirectiveClass,\n                               llvm::omp::OMPD_ordered, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPOrderedDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  /// \\param IsStandalone true, if the the standalone directive is created.\n  ///\n  static OMPOrderedDirective *CreateEmpty(const ASTContext &C,\n                                          unsigned NumClauses,\n                                          bool IsStandalone, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPOrderedDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp atomic' directive.\n///\n/// \\code\n/// #pragma omp atomic capture\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has clause 'capture'.\n///\nclass OMPAtomicDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Used for 'atomic update' or 'atomic capture' constructs. They may\n  /// have atomic expressions of forms\n  /// \\code\n  /// x = x binop expr;\n  /// x = expr binop x;\n  /// \\endcode\n  /// This field is true for the first form of the expression and false for the\n  /// second. Required for correct codegen of non-associative operations (like\n  /// << or >>).\n  bool IsXLHSInRHSPart = false;\n  /// Used for 'atomic update' or 'atomic capture' constructs. They may\n  /// have atomic expressions of forms\n  /// \\code\n  /// v = x; <update x>;\n  /// <update x>; v = x;\n  /// \\endcode\n  /// This field is true for the first(postfix) form of the expression and false\n  /// otherwise.\n  bool IsPostfixUpdate = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPAtomicDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPAtomicDirective()\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set 'x' part of the associated expression/statement.\n  void setX(Expr *X) { Data->getChildren()[0] = X; }\n  /// Set helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  void setUpdateExpr(Expr *UE) { Data->getChildren()[1] = UE; }\n  /// Set 'v' part of the associated expression/statement.\n  void setV(Expr *V) { Data->getChildren()[2] = V; }\n  /// Set 'expr' part of the associated expression/statement.\n  void setExpr(Expr *E) { Data->getChildren()[3] = E; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses and 'x', 'v' and 'expr'\n  /// parts of the atomic construct (see Section 2.12.6, atomic Construct, for\n  /// detailed description of 'x', 'v' and 'expr').\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param X 'x' part of the associated expression/statement.\n  /// \\param V 'v' part of the associated expression/statement.\n  /// \\param E 'expr' part of the associated expression/statement.\n  /// \\param UE Helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  /// \\param IsXLHSInRHSPart true if \\a UE has the first form and false if the\n  /// second.\n  /// \\param IsPostfixUpdate true if original value of 'x' must be stored in\n  /// 'v', not an updated one.\n  static OMPAtomicDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *X, Expr *V,\n         Expr *E, Expr *UE, bool IsXLHSInRHSPart, bool IsPostfixUpdate);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPAtomicDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  /// Get 'x' part of the associated expression/statement.\n  Expr *getX() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n  const Expr *getX() const {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  /// Get helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  Expr *getUpdateExpr() { return cast_or_null<Expr>(Data->getChildren()[1]); }\n  const Expr *getUpdateExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[1]);\n  }\n  /// Return true if helper update expression has form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' and false if it has form\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  bool isXLHSInRHSPart() const { return IsXLHSInRHSPart; }\n  /// Return true if 'v' expression must be updated to original value of\n  /// 'x', false if 'v' must be updated to the new value of 'x'.\n  bool isPostfixUpdate() const { return IsPostfixUpdate; }\n  /// Get 'v' part of the associated expression/statement.\n  Expr *getV() { return cast_or_null<Expr>(Data->getChildren()[2]); }\n  const Expr *getV() const {\n    return cast_or_null<Expr>(Data->getChildren()[2]);\n  }\n  /// Get 'expr' part of the associated expression/statement.\n  Expr *getExpr() { return cast_or_null<Expr>(Data->getChildren()[3]); }\n  const Expr *getExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[3]);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPAtomicDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target' directive.\n///\n/// \\code\n/// #pragma omp target if(a)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTargetDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetDirectiveClass, llvm::omp::OMPD_target,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetDirective()\n      : OMPExecutableDirective(OMPTargetDirectiveClass, llvm::omp::OMPD_target,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target data' directive.\n///\n/// \\code\n/// #pragma omp target data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target data' has clauses 'device'\n/// with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetDataDirectiveClass,\n                               llvm::omp::OMPD_target_data, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetDataDirective()\n      : OMPExecutableDirective(OMPTargetDataDirectiveClass,\n                               llvm::omp::OMPD_target_data, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetDataDirective *CreateEmpty(const ASTContext &C, unsigned N,\n                                             EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target enter data' directive.\n///\n/// \\code\n/// #pragma omp target enter data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target enter data' has clauses\n/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetEnterDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetEnterDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetEnterDataDirectiveClass,\n                               llvm::omp::OMPD_target_enter_data, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetEnterDataDirective()\n      : OMPExecutableDirective(OMPTargetEnterDataDirectiveClass,\n                               llvm::omp::OMPD_target_enter_data,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetEnterDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetEnterDataDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned N, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetEnterDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target exit data' directive.\n///\n/// \\code\n/// #pragma omp target exit data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target exit data' has clauses\n/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetExitDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetExitDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetExitDataDirectiveClass,\n                               llvm::omp::OMPD_target_exit_data, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetExitDataDirective()\n      : OMPExecutableDirective(OMPTargetExitDataDirectiveClass,\n                               llvm::omp::OMPD_target_exit_data,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetExitDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetExitDataDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned N, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetExitDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel' directive.\n///\n/// \\code\n/// #pragma omp target parallel if(a)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTargetParallelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetParallelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetParallelDirectiveClass,\n                               llvm::omp::OMPD_target_parallel, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetParallelDirective()\n      : OMPExecutableDirective(OMPTargetParallelDirectiveClass,\n                               llvm::omp::OMPD_target_parallel,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTargetParallelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetParallelDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel for' directive.\n///\n/// \\code\n/// #pragma omp target parallel for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel for' has clauses\n/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'\n/// and variables 'c' and 'd'.\n///\nclass OMPTargetParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current region has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                                unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_target_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPTargetParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelForDirective *CreateEmpty(const ASTContext &C,\n                                                    unsigned NumClauses,\n                                                    unsigned CollapsedNum,\n                                                    EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_target_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams' directive.\n///\n/// \\code\n/// #pragma omp teams if(a)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTeamsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTeamsDirectiveClass, llvm::omp::OMPD_teams,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTeamsDirective()\n      : OMPExecutableDirective(OMPTeamsDirectiveClass, llvm::omp::OMPD_teams,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTeamsDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation EndLoc,\n                                   ArrayRef<OMPClause *> Clauses,\n                                   Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDirective *CreateEmpty(const ASTContext &C,\n                                        unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp cancellation point' directive.\n///\n/// \\code\n/// #pragma omp cancellation point for\n/// \\endcode\n///\n/// In this example a cancellation point is created for innermost 'for' region.\nclass OMPCancellationPointDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  OpenMPDirectiveKind CancelRegion = llvm::omp::OMPD_unknown;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// statements and child expressions.\n  ///\n  OMPCancellationPointDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,\n                               llvm::omp::OMPD_cancellation_point, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  explicit OMPCancellationPointDirective()\n      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,\n                               llvm::omp::OMPD_cancellation_point,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel region for current cancellation point.\n  /// \\param CR Cancellation region.\n  void setCancelRegion(OpenMPDirectiveKind CR) { CancelRegion = CR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPCancellationPointDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         OpenMPDirectiveKind CancelRegion);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPCancellationPointDirective *CreateEmpty(const ASTContext &C,\n                                                    EmptyShell);\n\n  /// Get cancellation region for the current cancellation point.\n  OpenMPDirectiveKind getCancelRegion() const { return CancelRegion; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCancellationPointDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp cancel' directive.\n///\n/// \\code\n/// #pragma omp cancel for\n/// \\endcode\n///\n/// In this example a cancel is created for innermost 'for' region.\nclass OMPCancelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  OpenMPDirectiveKind CancelRegion = llvm::omp::OMPD_unknown;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPCancelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCancelDirectiveClass, llvm::omp::OMPD_cancel,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPCancelDirective()\n      : OMPExecutableDirective(OMPCancelDirectiveClass, llvm::omp::OMPD_cancel,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel region for current cancellation point.\n  /// \\param CR Cancellation region.\n  void setCancelRegion(OpenMPDirectiveKind CR) { CancelRegion = CR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  ///\n  static OMPCancelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, OpenMPDirectiveKind CancelRegion);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPCancelDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  /// Get cancellation region for the current cancellation point.\n  OpenMPDirectiveKind getCancelRegion() const { return CancelRegion; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCancelDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskloop' directive.\n///\n/// \\code\n/// #pragma omp taskloop private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has clauses 'private'\n/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and\n/// 'num_tasks' with expression 'num'.\n///\nclass OMPTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTaskLoopDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                       unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopDirectiveClass, llvm::omp::OMPD_taskloop,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopDirectiveClass, llvm::omp::OMPD_taskloop,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses,\n                                           unsigned CollapsedNum, EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp taskloop simd private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and\n/// 'num_tasks' with expression 'num'.\n///\nclass OMPTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTaskLoopSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                           unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_taskloop_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_taskloop_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskLoopSimdDirective *CreateEmpty(const ASTContext &C,\n                                               unsigned NumClauses,\n                                               unsigned CollapsedNum,\n                                               EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master taskloop' directive.\n///\n/// \\code\n/// #pragma omp master taskloop private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp master taskloop' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPMasterTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPMasterTaskLoopDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPMasterTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPMasterTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPMasterTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned NumClauses,\n                                                 unsigned CollapsedNum,\n                                                 EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp master taskloop simd private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp master taskloop simd' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPMasterTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPMasterTaskLoopSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                                 unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPMasterTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\p Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPMasterTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\p NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPMasterTaskLoopSimdDirective *CreateEmpty(const ASTContext &C,\n                                                     unsigned NumClauses,\n                                                     unsigned CollapsedNum,\n                                                     EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master taskloop' directive.\n///\n/// \\code\n/// #pragma omp parallel master taskloop private(a,b) grainsize(val)\n/// num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master taskloop' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPParallelMasterTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelMasterTaskLoopDirective(SourceLocation StartLoc,\n                                     SourceLocation EndLoc,\n                                     unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelMasterTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPParallelMasterTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                                         unsigned NumClauses,\n                                                         unsigned CollapsedNum,\n                                                         EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp parallel master taskloop simd private(a,b) grainsize(val)\n/// num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master taskloop simd' has\n/// clauses 'private' with the variables 'a' and 'b', 'grainsize' with\n/// expression 'val' and 'num_tasks' with expression 'num'.\n///\nclass OMPParallelMasterTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelMasterTaskLoopSimdDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelMasterTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\p Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPParallelMasterTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterTaskLoopSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute' directive.\n///\n/// \\code\n/// #pragma omp distribute private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp distribute' has clauses 'private'\n/// with the variables 'a' and 'b'\n///\nclass OMPDistributeDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeDirectiveClass,\n                         llvm::omp::OMPD_distribute, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeDirectiveClass,\n                         llvm::omp::OMPD_distribute, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeDirective *CreateEmpty(const ASTContext &C,\n                                             unsigned NumClauses,\n                                             unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target update' directive.\n///\n/// \\code\n/// #pragma omp target update to(a) from(b) device(1)\n/// \\endcode\n/// In this example directive '#pragma omp target update' has clause 'to' with\n/// argument 'a', clause 'from' with argument 'b' and clause 'device' with\n/// argument '1'.\n///\nclass OMPTargetUpdateDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetUpdateDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetUpdateDirectiveClass,\n                               llvm::omp::OMPD_target_update, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetUpdateDirective()\n      : OMPExecutableDirective(OMPTargetUpdateDirectiveClass,\n                               llvm::omp::OMPD_target_update, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetUpdateDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses The number of clauses.\n  ///\n  static OMPTargetUpdateDirective *CreateEmpty(const ASTContext &C,\n                                               unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetUpdateDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute parallel for' composite\n///  directive.\n///\n/// \\code\n/// #pragma omp distribute parallel for private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp distribute parallel for' has clause\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPDistributeParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeParallelForDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeParallelForDirective *CreateEmpty(const ASTContext &C,\n                                                        unsigned NumClauses,\n                                                        unsigned CollapsedNum,\n                                                        EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute parallel for simd' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp distribute parallel for simd' has\n/// clause 'private' with the variables 'x'\n///\nclass OMPDistributeParallelForSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeParallelForSimdDirective *Create(\n      const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n      unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n      Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeParallelForSimdDirective *CreateEmpty(\n      const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n      EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute simd' composite directive.\n///\n/// \\code\n/// #pragma omp distribute simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp distribute simd' has clause\n/// 'private' with the variables 'x'\n///\nclass OMPDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeSimdDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned NumClauses,\n                                                 unsigned CollapsedNum,\n                                                 EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel for simd' directive.\n///\n/// \\code\n/// #pragma omp target parallel for simd private(a) map(b) safelen(c)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel for simd' has clauses\n/// 'private' with the variable 'a', 'map' with the variable 'b' and 'safelen'\n/// with the variable 'c'.\n///\nclass OMPTargetParallelForSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetParallelForSimdDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelForSimdDirective *CreateEmpty(const ASTContext &C,\n                                                        unsigned NumClauses,\n                                                        unsigned CollapsedNum,\n                                                        EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target simd' directive.\n///\n/// \\code\n/// #pragma omp target simd private(a) map(b) safelen(c)\n/// \\endcode\n/// In this example directive '#pragma omp target simd' has clauses 'private'\n/// with the variable 'a', 'map' with the variable 'b' and 'safelen' with\n/// the variable 'c'.\n///\nclass OMPTargetSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetSimdDirectiveClass,\n                         llvm::omp::OMPD_target_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetSimdDirectiveClass,\n                         llvm::omp::OMPD_target_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetSimdDirective *CreateEmpty(const ASTContext &C,\n                                             unsigned NumClauses,\n                                             unsigned CollapsedNum,\n                                             EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute' directive.\n///\n/// \\code\n/// #pragma omp teams distribute private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute' has clauses\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPTeamsDistributeDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                              unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned NumClauses,\n                                                  unsigned CollapsedNum,\n                                                  EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute simd'\n/// combined directive.\n///\n/// \\code\n/// #pragma omp teams distribute simd private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute simd'\n/// has clause 'private' with the variables 'a' and 'b'\n///\nclass OMPTeamsDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeSimdDirective(SourceLocation StartLoc,\n                                  SourceLocation EndLoc, unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeSimdDirective *CreateEmpty(const ASTContext &C,\n                                                      unsigned NumClauses,\n                                                      unsigned CollapsedNum,\n                                                      EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute parallel for simd' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp teams distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute parallel for simd'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTeamsDistributeParallelForSimdDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                             SourceLocation EndLoc,\n                                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeParallelForSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute parallel for' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp teams distribute parallel for private(x)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute parallel for'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTeamsDistributeParallelForDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeParallelForDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_teams_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTeamsDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeParallelForDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_teams_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTeamsDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams' directive.\n///\n/// \\code\n/// #pragma omp target teams if(a>0)\n/// \\endcode\n/// In this example directive '#pragma omp target teams' has clause 'if' with\n/// condition 'a>0'.\n///\nclass OMPTargetTeamsDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetTeamsDirectiveClass,\n                               llvm::omp::OMPD_target_teams, StartLoc, EndLoc) {\n  }\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetTeamsDirective()\n      : OMPExecutableDirective(OMPTargetTeamsDirectiveClass,\n                               llvm::omp::OMPD_target_teams, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetTeamsDirective *Create(const ASTContext &C,\n                                         SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDirective *CreateEmpty(const ASTContext &C,\n                                              unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute' combined directive.\n///\n/// \\code\n/// #pragma omp target teams distribute private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute' has clause\n/// 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute parallel for' combined\n/// directive.\n///\n/// \\code\n/// #pragma omp target teams distribute parallel for private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute parallel\n/// for' has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeParallelForDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeParallelForDirective(SourceLocation StartLoc,\n                                               SourceLocation EndLoc,\n                                               unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_parallel_for,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(),\n        llvm::omp::OMPD_target_teams_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTargetTeamsDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeParallelForDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(),\n        llvm::omp::OMPD_target_teams_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetTeamsDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() ==\n           OMPTargetTeamsDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute parallel for simd'\n/// combined directive.\n///\n/// \\code\n/// #pragma omp target teams distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute parallel\n/// for simd' has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeParallelForSimdDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                                   SourceLocation EndLoc,\n                                                   unsigned CollapsedNum)\n      : OMPLoopDirective(\n            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,\n            llvm::omp::OMPD_target_teams_distribute_parallel_for_simd, StartLoc,\n            EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeParallelForSimdDirective(\n      unsigned CollapsedNum)\n      : OMPLoopDirective(\n            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,\n            llvm::omp::OMPD_target_teams_distribute_parallel_for_simd,\n            SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeParallelForSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() ==\n           OMPTargetTeamsDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute simd' combined\n/// directive.\n///\n/// \\code\n/// #pragma omp target teams distribute simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute simd'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeSimdDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents the '#pragma omp tile' loop transformation directive.\nclass OMPTileDirective final : public OMPLoopBasedDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Default list of offsets.\n  enum {\n    PreInitsOffset = 0,\n    TransformedStmtOffset,\n  };\n\n  explicit OMPTileDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                            unsigned NumLoops)\n      : OMPLoopBasedDirective(OMPTileDirectiveClass, llvm::omp::OMPD_tile,\n                              StartLoc, EndLoc, NumLoops) {}\n\n  void setPreInits(Stmt *PreInits) {\n    Data->getChildren()[PreInitsOffset] = PreInits;\n  }\n\n  void setTransformedStmt(Stmt *S) {\n    Data->getChildren()[TransformedStmtOffset] = S;\n  }\n\npublic:\n  /// Create a new AST node representation for '#pragma omp tile'.\n  ///\n  /// \\param C         Context of the AST.\n  /// \\param StartLoc  Location of the introducer (e.g. the 'omp' token).\n  /// \\param EndLoc    Location of the directive's end (e.g. the tok::eod).\n  /// \\param Clauses   The directive's clauses.\n  /// \\param NumLoops  Number of associated loops (number of items in the\n  ///                  'sizes' clause).\n  /// \\param AssociatedStmt The outermost associated loop.\n  /// \\param TransformedStmt The loop nest after tiling, or nullptr in\n  ///                        dependent contexts.\n  /// \\param PreInits Helper preinits statements for the loop nest.\n  static OMPTileDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  unsigned NumLoops, Stmt *AssociatedStmt,\n                                  Stmt *TransformedStmt, Stmt *PreInits);\n\n  /// Build an empty '#pragma omp tile' AST node for deserialization.\n  ///\n  /// \\param C          Context of the AST.\n  /// \\param NumClauses Number of clauses to allocate.\n  /// \\param NumLoops   Number of associated loops to allocate.\n  static OMPTileDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       unsigned NumLoops);\n\n  unsigned getNumAssociatedLoops() const { return getLoopsNumber(); }\n\n  /// Gets/sets the associated loops after tiling.\n  ///\n  /// This is in de-sugared format stored as a CompoundStmt.\n  ///\n  /// \\code\n  ///   for (...)\n  ///     ...\n  /// \\endcode\n  ///\n  /// Note that if the generated loops a become associated loops of another\n  /// directive, they may need to be hoisted before them.\n  Stmt *getTransformedStmt() const {\n    return Data->getChildren()[TransformedStmtOffset];\n  }\n\n  /// Return preinits statement.\n  Stmt *getPreInits() const { return Data->getChildren()[PreInitsOffset]; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTileDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp scan' directive.\n///\n/// \\code\n/// #pragma omp scan inclusive(a)\n/// \\endcode\n/// In this example directive '#pragma omp scan' has clause 'inclusive' with\n/// list item 'a'.\nclass OMPScanDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPScanDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPScanDirectiveClass, llvm::omp::OMPD_scan,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPScanDirective()\n      : OMPExecutableDirective(OMPScanDirectiveClass, llvm::omp::OMPD_scan,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses (only single OMPFlushClause clause is\n  /// allowed).\n  ///\n  static OMPScanDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPScanDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPScanDirectiveClass;\n  }\n};\n\n} // end namespace clang\n\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "content": "//===----- CGOpenMPRuntime.h - Interface to OpenMP Runtimes -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This provides a class for OpenMP runtime code generation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIME_H\n#define LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIME_H\n\n#include \"CGValue.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include \"llvm/Frontend/OpenMP/OMPIRBuilder.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n\nnamespace llvm {\nclass ArrayType;\nclass Constant;\nclass FunctionType;\nclass GlobalVariable;\nclass StructType;\nclass Type;\nclass Value;\nclass OpenMPIRBuilder;\n} // namespace llvm\n\nnamespace clang {\nclass Expr;\nclass OMPDependClause;\nclass OMPExecutableDirective;\nclass OMPLoopDirective;\nclass VarDecl;\nclass OMPDeclareReductionDecl;\nclass IdentifierInfo;\n\nnamespace CodeGen {\nclass Address;\nclass CodeGenFunction;\nclass CodeGenModule;\n\n/// A basic class for pre|post-action for advanced codegen sequence for OpenMP\n/// region.\nclass PrePostActionTy {\npublic:\n  explicit PrePostActionTy() {}\n  virtual void Enter(CodeGenFunction &CGF) {}\n  virtual void Exit(CodeGenFunction &CGF) {}\n  virtual ~PrePostActionTy() {}\n};\n\n/// Class provides a way to call simple version of codegen for OpenMP region, or\n/// an advanced with possible pre|post-actions in codegen.\nclass RegionCodeGenTy final {\n  intptr_t CodeGen;\n  typedef void (*CodeGenTy)(intptr_t, CodeGenFunction &, PrePostActionTy &);\n  CodeGenTy Callback;\n  mutable PrePostActionTy *PrePostAction;\n  RegionCodeGenTy() = delete;\n  RegionCodeGenTy &operator=(const RegionCodeGenTy &) = delete;\n  template <typename Callable>\n  static void CallbackFn(intptr_t CodeGen, CodeGenFunction &CGF,\n                         PrePostActionTy &Action) {\n    return (*reinterpret_cast<Callable *>(CodeGen))(CGF, Action);\n  }\n\npublic:\n  template <typename Callable>\n  RegionCodeGenTy(\n      Callable &&CodeGen,\n      std::enable_if_t<!std::is_same<std::remove_reference_t<Callable>,\n                                     RegionCodeGenTy>::value> * = nullptr)\n      : CodeGen(reinterpret_cast<intptr_t>(&CodeGen)),\n        Callback(CallbackFn<std::remove_reference_t<Callable>>),\n        PrePostAction(nullptr) {}\n  void setAction(PrePostActionTy &Action) const { PrePostAction = &Action; }\n  void operator()(CodeGenFunction &CGF) const;\n};\n\nstruct OMPTaskDataTy final {\n  SmallVector<const Expr *, 4> PrivateVars;\n  SmallVector<const Expr *, 4> PrivateCopies;\n  SmallVector<const Expr *, 4> FirstprivateVars;\n  SmallVector<const Expr *, 4> FirstprivateCopies;\n  SmallVector<const Expr *, 4> FirstprivateInits;\n  SmallVector<const Expr *, 4> LastprivateVars;\n  SmallVector<const Expr *, 4> LastprivateCopies;\n  SmallVector<const Expr *, 4> ReductionVars;\n  SmallVector<const Expr *, 4> ReductionOrigs;\n  SmallVector<const Expr *, 4> ReductionCopies;\n  SmallVector<const Expr *, 4> ReductionOps;\n  SmallVector<CanonicalDeclPtr<const VarDecl>, 4> PrivateLocals;\n  struct DependData {\n    OpenMPDependClauseKind DepKind = OMPC_DEPEND_unknown;\n    const Expr *IteratorExpr = nullptr;\n    SmallVector<const Expr *, 4> DepExprs;\n    explicit DependData() = default;\n    DependData(OpenMPDependClauseKind DepKind, const Expr *IteratorExpr)\n        : DepKind(DepKind), IteratorExpr(IteratorExpr) {}\n  };\n  SmallVector<DependData, 4> Dependences;\n  llvm::PointerIntPair<llvm::Value *, 1, bool> Final;\n  llvm::PointerIntPair<llvm::Value *, 1, bool> Schedule;\n  llvm::PointerIntPair<llvm::Value *, 1, bool> Priority;\n  llvm::Value *Reductions = nullptr;\n  unsigned NumberOfParts = 0;\n  bool Tied = true;\n  bool Nogroup = false;\n  bool IsReductionWithTaskMod = false;\n  bool IsWorksharingReduction = false;\n};\n\n/// Class intended to support codegen of all kind of the reduction clauses.\nclass ReductionCodeGen {\nprivate:\n  /// Data required for codegen of reduction clauses.\n  struct ReductionData {\n    /// Reference to the item shared between tasks to reduce into.\n    const Expr *Shared = nullptr;\n    /// Reference to the original item.\n    const Expr *Ref = nullptr;\n    /// Helper expression for generation of private copy.\n    const Expr *Private = nullptr;\n    /// Helper expression for generation reduction operation.\n    const Expr *ReductionOp = nullptr;\n    ReductionData(const Expr *Shared, const Expr *Ref, const Expr *Private,\n                  const Expr *ReductionOp)\n        : Shared(Shared), Ref(Ref), Private(Private), ReductionOp(ReductionOp) {\n    }\n  };\n  /// List of reduction-based clauses.\n  SmallVector<ReductionData, 4> ClausesData;\n\n  /// List of addresses of shared variables/expressions.\n  SmallVector<std::pair<LValue, LValue>, 4> SharedAddresses;\n  /// List of addresses of original variables/expressions.\n  SmallVector<std::pair<LValue, LValue>, 4> OrigAddresses;\n  /// Sizes of the reduction items in chars.\n  SmallVector<std::pair<llvm::Value *, llvm::Value *>, 4> Sizes;\n  /// Base declarations for the reduction items.\n  SmallVector<const VarDecl *, 4> BaseDecls;\n\n  /// Emits lvalue for shared expression.\n  LValue emitSharedLValue(CodeGenFunction &CGF, const Expr *E);\n  /// Emits upper bound for shared expression (if array section).\n  LValue emitSharedLValueUB(CodeGenFunction &CGF, const Expr *E);\n  /// Performs aggregate initialization.\n  /// \\param N Number of reduction item in the common list.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  /// \\param SharedLVal Address of the original shared variable.\n  /// \\param DRD Declare reduction construct used for reduction item.\n  void emitAggregateInitialization(CodeGenFunction &CGF, unsigned N,\n                                   Address PrivateAddr, LValue SharedLVal,\n                                   const OMPDeclareReductionDecl *DRD);\n\npublic:\n  ReductionCodeGen(ArrayRef<const Expr *> Shareds, ArrayRef<const Expr *> Origs,\n                   ArrayRef<const Expr *> Privates,\n                   ArrayRef<const Expr *> ReductionOps);\n  /// Emits lvalue for the shared and original reduction item.\n  /// \\param N Number of the reduction item.\n  void emitSharedOrigLValue(CodeGenFunction &CGF, unsigned N);\n  /// Emits the code for the variable-modified type, if required.\n  /// \\param N Number of the reduction item.\n  void emitAggregateType(CodeGenFunction &CGF, unsigned N);\n  /// Emits the code for the variable-modified type, if required.\n  /// \\param N Number of the reduction item.\n  /// \\param Size Size of the type in chars.\n  void emitAggregateType(CodeGenFunction &CGF, unsigned N, llvm::Value *Size);\n  /// Performs initialization of the private copy for the reduction item.\n  /// \\param N Number of the reduction item.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  /// \\param DefaultInit Default initialization sequence that should be\n  /// performed if no reduction specific initialization is found.\n  /// \\param SharedLVal Address of the original shared variable.\n  void\n  emitInitialization(CodeGenFunction &CGF, unsigned N, Address PrivateAddr,\n                     LValue SharedLVal,\n                     llvm::function_ref<bool(CodeGenFunction &)> DefaultInit);\n  /// Returns true if the private copy requires cleanups.\n  bool needCleanups(unsigned N);\n  /// Emits cleanup code for the reduction item.\n  /// \\param N Number of the reduction item.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  void emitCleanups(CodeGenFunction &CGF, unsigned N, Address PrivateAddr);\n  /// Adjusts \\p PrivatedAddr for using instead of the original variable\n  /// address in normal operations.\n  /// \\param N Number of the reduction item.\n  /// \\param PrivateAddr Address of the corresponding private item.\n  Address adjustPrivateAddress(CodeGenFunction &CGF, unsigned N,\n                               Address PrivateAddr);\n  /// Returns LValue for the reduction item.\n  LValue getSharedLValue(unsigned N) const { return SharedAddresses[N].first; }\n  /// Returns LValue for the original reduction item.\n  LValue getOrigLValue(unsigned N) const { return OrigAddresses[N].first; }\n  /// Returns the size of the reduction item (in chars and total number of\n  /// elements in the item), or nullptr, if the size is a constant.\n  std::pair<llvm::Value *, llvm::Value *> getSizes(unsigned N) const {\n    return Sizes[N];\n  }\n  /// Returns the base declaration of the reduction item.\n  const VarDecl *getBaseDecl(unsigned N) const { return BaseDecls[N]; }\n  /// Returns the base declaration of the reduction item.\n  const Expr *getRefExpr(unsigned N) const { return ClausesData[N].Ref; }\n  /// Returns true if the initialization of the reduction item uses initializer\n  /// from declare reduction construct.\n  bool usesReductionInitializer(unsigned N) const;\n};\n\nclass CGOpenMPRuntime {\npublic:\n  /// Allows to disable automatic handling of functions used in target regions\n  /// as those marked as `omp declare target`.\n  class DisableAutoDeclareTargetRAII {\n    CodeGenModule &CGM;\n    bool SavedShouldMarkAsGlobal;\n\n  public:\n    DisableAutoDeclareTargetRAII(CodeGenModule &CGM);\n    ~DisableAutoDeclareTargetRAII();\n  };\n\n  /// Manages list of nontemporal decls for the specified directive.\n  class NontemporalDeclsRAII {\n    CodeGenModule &CGM;\n    const bool NeedToPush;\n\n  public:\n    NontemporalDeclsRAII(CodeGenModule &CGM, const OMPLoopDirective &S);\n    ~NontemporalDeclsRAII();\n  };\n\n  /// Manages list of nontemporal decls for the specified directive.\n  class UntiedTaskLocalDeclsRAII {\n    CodeGenModule &CGM;\n    const bool NeedToPush;\n\n  public:\n    UntiedTaskLocalDeclsRAII(\n        CodeGenFunction &CGF,\n        const llvm::DenseMap<CanonicalDeclPtr<const VarDecl>,\n                             std::pair<Address, Address>> &LocalVars);\n    ~UntiedTaskLocalDeclsRAII();\n  };\n\n  /// Maps the expression for the lastprivate variable to the global copy used\n  /// to store new value because original variables are not mapped in inner\n  /// parallel regions. Only private copies are captured but we need also to\n  /// store private copy in shared address.\n  /// Also, stores the expression for the private loop counter and it\n  /// threaprivate name.\n  struct LastprivateConditionalData {\n    llvm::MapVector<CanonicalDeclPtr<const Decl>, SmallString<16>>\n        DeclToUniqueName;\n    LValue IVLVal;\n    llvm::Function *Fn = nullptr;\n    bool Disabled = false;\n  };\n  /// Manages list of lastprivate conditional decls for the specified directive.\n  class LastprivateConditionalRAII {\n    enum class ActionToDo {\n      DoNotPush,\n      PushAsLastprivateConditional,\n      DisableLastprivateConditional,\n    };\n    CodeGenModule &CGM;\n    ActionToDo Action = ActionToDo::DoNotPush;\n\n    /// Check and try to disable analysis of inner regions for changes in\n    /// lastprivate conditional.\n    void tryToDisableInnerAnalysis(const OMPExecutableDirective &S,\n                                   llvm::DenseSet<CanonicalDeclPtr<const Decl>>\n                                       &NeedToAddForLPCsAsDisabled) const;\n\n    LastprivateConditionalRAII(CodeGenFunction &CGF,\n                               const OMPExecutableDirective &S);\n\n  public:\n    explicit LastprivateConditionalRAII(CodeGenFunction &CGF,\n                                        const OMPExecutableDirective &S,\n                                        LValue IVLVal);\n    static LastprivateConditionalRAII disable(CodeGenFunction &CGF,\n                                              const OMPExecutableDirective &S);\n    ~LastprivateConditionalRAII();\n  };\n\n  llvm::OpenMPIRBuilder &getOMPBuilder() { return OMPBuilder; }\n\nprotected:\n  CodeGenModule &CGM;\n  StringRef FirstSeparator, Separator;\n\n  /// An OpenMP-IR-Builder instance.\n  llvm::OpenMPIRBuilder OMPBuilder;\n\n  /// Constructor allowing to redefine the name separator for the variables.\n  explicit CGOpenMPRuntime(CodeGenModule &CGM, StringRef FirstSeparator,\n                           StringRef Separator);\n\n  /// Creates offloading entry for the provided entry ID \\a ID,\n  /// address \\a Addr, size \\a Size, and flags \\a Flags.\n  virtual void createOffloadEntry(llvm::Constant *ID, llvm::Constant *Addr,\n                                  uint64_t Size, int32_t Flags,\n                                  llvm::GlobalValue::LinkageTypes Linkage);\n\n  /// Helper to emit outlined function for 'target' directive.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// \\param CodeGen Lambda codegen specific to an accelerator device.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  virtual void emitTargetOutlinedFunctionHelper(const OMPExecutableDirective &D,\n                                                StringRef ParentName,\n                                                llvm::Function *&OutlinedFn,\n                                                llvm::Constant *&OutlinedFnID,\n                                                bool IsOffloadEntry,\n                                                const RegionCodeGenTy &CodeGen);\n\n  /// Emits object of ident_t type with info for source location.\n  /// \\param Flags Flags for OpenMP location.\n  ///\n  llvm::Value *emitUpdateLocation(CodeGenFunction &CGF, SourceLocation Loc,\n                                  unsigned Flags = 0);\n\n  /// Returns pointer to ident_t type.\n  llvm::Type *getIdentTyPointerTy();\n\n  /// Gets thread id value for the current thread.\n  ///\n  llvm::Value *getThreadID(CodeGenFunction &CGF, SourceLocation Loc);\n\n  /// Get the function name of an outlined region.\n  //  The name can be customized depending on the target.\n  //\n  virtual StringRef getOutlinedHelperName() const { return \".omp_outlined.\"; }\n\n  /// Emits \\p Callee function call with arguments \\p Args with location \\p Loc.\n  void emitCall(CodeGenFunction &CGF, SourceLocation Loc,\n                llvm::FunctionCallee Callee,\n                ArrayRef<llvm::Value *> Args = llvm::None) const;\n\n  /// Emits address of the word in a memory where current thread id is\n  /// stored.\n  virtual Address emitThreadIDAddress(CodeGenFunction &CGF, SourceLocation Loc);\n\n  void setLocThreadIdInsertPt(CodeGenFunction &CGF,\n                              bool AtCurrentPoint = false);\n  void clearLocThreadIdInsertPt(CodeGenFunction &CGF);\n\n  /// Check if the default location must be constant.\n  /// Default is false to support OMPT/OMPD.\n  virtual bool isDefaultLocationConstant() const { return false; }\n\n  /// Returns additional flags that can be stored in reserved_2 field of the\n  /// default location.\n  virtual unsigned getDefaultLocationReserved2Flags() const { return 0; }\n\n  /// Returns default flags for the barriers depending on the directive, for\n  /// which this barier is going to be emitted.\n  static unsigned getDefaultFlagsForBarriers(OpenMPDirectiveKind Kind);\n\n  /// Get the LLVM type for the critical name.\n  llvm::ArrayType *getKmpCriticalNameTy() const {return KmpCriticalNameTy;}\n\n  /// Returns corresponding lock object for the specified critical region\n  /// name. If the lock object does not exist it is created, otherwise the\n  /// reference to the existing copy is returned.\n  /// \\param CriticalName Name of the critical region.\n  ///\n  llvm::Value *getCriticalRegionLock(StringRef CriticalName);\n\nprivate:\n\n  /// Map for SourceLocation and OpenMP runtime library debug locations.\n  typedef llvm::DenseMap<SourceLocation, llvm::Value *> OpenMPDebugLocMapTy;\n  OpenMPDebugLocMapTy OpenMPDebugLocMap;\n  /// The type for a microtask which gets passed to __kmpc_fork_call().\n  /// Original representation is:\n  /// typedef void (kmpc_micro)(kmp_int32 global_tid, kmp_int32 bound_tid,...);\n  llvm::FunctionType *Kmpc_MicroTy = nullptr;\n  /// Stores debug location and ThreadID for the function.\n  struct DebugLocThreadIdTy {\n    llvm::Value *DebugLoc;\n    llvm::Value *ThreadID;\n    /// Insert point for the service instructions.\n    llvm::AssertingVH<llvm::Instruction> ServiceInsertPt = nullptr;\n  };\n  /// Map of local debug location, ThreadId and functions.\n  typedef llvm::DenseMap<llvm::Function *, DebugLocThreadIdTy>\n      OpenMPLocThreadIDMapTy;\n  OpenMPLocThreadIDMapTy OpenMPLocThreadIDMap;\n  /// Map of UDRs and corresponding combiner/initializer.\n  typedef llvm::DenseMap<const OMPDeclareReductionDecl *,\n                         std::pair<llvm::Function *, llvm::Function *>>\n      UDRMapTy;\n  UDRMapTy UDRMap;\n  /// Map of functions and locally defined UDRs.\n  typedef llvm::DenseMap<llvm::Function *,\n                         SmallVector<const OMPDeclareReductionDecl *, 4>>\n      FunctionUDRMapTy;\n  FunctionUDRMapTy FunctionUDRMap;\n  /// Map from the user-defined mapper declaration to its corresponding\n  /// functions.\n  llvm::DenseMap<const OMPDeclareMapperDecl *, llvm::Function *> UDMMap;\n  /// Map of functions and their local user-defined mappers.\n  using FunctionUDMMapTy =\n      llvm::DenseMap<llvm::Function *,\n                     SmallVector<const OMPDeclareMapperDecl *, 4>>;\n  FunctionUDMMapTy FunctionUDMMap;\n  /// Maps local variables marked as lastprivate conditional to their internal\n  /// types.\n  llvm::DenseMap<llvm::Function *,\n                 llvm::DenseMap<CanonicalDeclPtr<const Decl>,\n                                std::tuple<QualType, const FieldDecl *,\n                                           const FieldDecl *, LValue>>>\n      LastprivateConditionalToTypes;\n  /// Maps function to the position of the untied task locals stack.\n  llvm::DenseMap<llvm::Function *, unsigned> FunctionToUntiedTaskStackMap;\n  /// Type kmp_critical_name, originally defined as typedef kmp_int32\n  /// kmp_critical_name[8];\n  llvm::ArrayType *KmpCriticalNameTy;\n  /// An ordered map of auto-generated variables to their unique names.\n  /// It stores variables with the following names: 1) \".gomp_critical_user_\" +\n  /// <critical_section_name> + \".var\" for \"omp critical\" directives; 2)\n  /// <mangled_name_for_global_var> + \".cache.\" for cache for threadprivate\n  /// variables.\n  llvm::StringMap<llvm::AssertingVH<llvm::Constant>, llvm::BumpPtrAllocator>\n      InternalVars;\n  /// Type typedef kmp_int32 (* kmp_routine_entry_t)(kmp_int32, void *);\n  llvm::Type *KmpRoutineEntryPtrTy = nullptr;\n  QualType KmpRoutineEntryPtrQTy;\n  /// Type typedef struct kmp_task {\n  ///    void *              shareds; /**< pointer to block of pointers to\n  ///    shared vars   */\n  ///    kmp_routine_entry_t routine; /**< pointer to routine to call for\n  ///    executing task */\n  ///    kmp_int32           part_id; /**< part id for the task */\n  ///    kmp_routine_entry_t destructors; /* pointer to function to invoke\n  ///    deconstructors of firstprivate C++ objects */\n  /// } kmp_task_t;\n  QualType KmpTaskTQTy;\n  /// Saved kmp_task_t for task directive.\n  QualType SavedKmpTaskTQTy;\n  /// Saved kmp_task_t for taskloop-based directive.\n  QualType SavedKmpTaskloopTQTy;\n  /// Type typedef struct kmp_depend_info {\n  ///    kmp_intptr_t               base_addr;\n  ///    size_t                     len;\n  ///    struct {\n  ///             bool                   in:1;\n  ///             bool                   out:1;\n  ///    } flags;\n  /// } kmp_depend_info_t;\n  QualType KmpDependInfoTy;\n  /// Type typedef struct kmp_task_affinity_info {\n  ///    kmp_intptr_t base_addr;\n  ///    size_t len;\n  ///    struct {\n  ///      bool flag1 : 1;\n  ///      bool flag2 : 1;\n  ///      kmp_int32 reserved : 30;\n  ///   } flags;\n  /// } kmp_task_affinity_info_t;\n  QualType KmpTaskAffinityInfoTy;\n  /// struct kmp_dim {  // loop bounds info casted to kmp_int64\n  ///  kmp_int64 lo; // lower\n  ///  kmp_int64 up; // upper\n  ///  kmp_int64 st; // stride\n  /// };\n  QualType KmpDimTy;\n  /// Type struct __tgt_offload_entry{\n  ///   void      *addr;       // Pointer to the offload entry info.\n  ///                          // (function or global)\n  ///   char      *name;       // Name of the function or global.\n  ///   size_t     size;       // Size of the entry info (0 if it a function).\n  ///   int32_t flags;\n  ///   int32_t reserved;\n  /// };\n  QualType TgtOffloadEntryQTy;\n  /// Entity that registers the offloading constants that were emitted so\n  /// far.\n  class OffloadEntriesInfoManagerTy {\n    CodeGenModule &CGM;\n\n    /// Number of entries registered so far.\n    unsigned OffloadingEntriesNum = 0;\n\n  public:\n    /// Base class of the entries info.\n    class OffloadEntryInfo {\n    public:\n      /// Kind of a given entry.\n      enum OffloadingEntryInfoKinds : unsigned {\n        /// Entry is a target region.\n        OffloadingEntryInfoTargetRegion = 0,\n        /// Entry is a declare target variable.\n        OffloadingEntryInfoDeviceGlobalVar = 1,\n        /// Invalid entry info.\n        OffloadingEntryInfoInvalid = ~0u\n      };\n\n    protected:\n      OffloadEntryInfo() = delete;\n      explicit OffloadEntryInfo(OffloadingEntryInfoKinds Kind) : Kind(Kind) {}\n      explicit OffloadEntryInfo(OffloadingEntryInfoKinds Kind, unsigned Order,\n                                uint32_t Flags)\n          : Flags(Flags), Order(Order), Kind(Kind) {}\n      ~OffloadEntryInfo() = default;\n\n    public:\n      bool isValid() const { return Order != ~0u; }\n      unsigned getOrder() const { return Order; }\n      OffloadingEntryInfoKinds getKind() const { return Kind; }\n      uint32_t getFlags() const { return Flags; }\n      void setFlags(uint32_t NewFlags) { Flags = NewFlags; }\n      llvm::Constant *getAddress() const {\n        return cast_or_null<llvm::Constant>(Addr);\n      }\n      void setAddress(llvm::Constant *V) {\n        assert(!Addr.pointsToAliveValue() && \"Address has been set before!\");\n        Addr = V;\n      }\n      static bool classof(const OffloadEntryInfo *Info) { return true; }\n\n    private:\n      /// Address of the entity that has to be mapped for offloading.\n      llvm::WeakTrackingVH Addr;\n\n      /// Flags associated with the device global.\n      uint32_t Flags = 0u;\n\n      /// Order this entry was emitted.\n      unsigned Order = ~0u;\n\n      OffloadingEntryInfoKinds Kind = OffloadingEntryInfoInvalid;\n    };\n\n    /// Return true if a there are no entries defined.\n    bool empty() const;\n    /// Return number of entries defined so far.\n    unsigned size() const { return OffloadingEntriesNum; }\n    OffloadEntriesInfoManagerTy(CodeGenModule &CGM) : CGM(CGM) {}\n\n    //\n    // Target region entries related.\n    //\n\n    /// Kind of the target registry entry.\n    enum OMPTargetRegionEntryKind : uint32_t {\n      /// Mark the entry as target region.\n      OMPTargetRegionEntryTargetRegion = 0x0,\n      /// Mark the entry as a global constructor.\n      OMPTargetRegionEntryCtor = 0x02,\n      /// Mark the entry as a global destructor.\n      OMPTargetRegionEntryDtor = 0x04,\n    };\n\n    /// Target region entries info.\n    class OffloadEntryInfoTargetRegion final : public OffloadEntryInfo {\n      /// Address that can be used as the ID of the entry.\n      llvm::Constant *ID = nullptr;\n\n    public:\n      OffloadEntryInfoTargetRegion()\n          : OffloadEntryInfo(OffloadingEntryInfoTargetRegion) {}\n      explicit OffloadEntryInfoTargetRegion(unsigned Order,\n                                            llvm::Constant *Addr,\n                                            llvm::Constant *ID,\n                                            OMPTargetRegionEntryKind Flags)\n          : OffloadEntryInfo(OffloadingEntryInfoTargetRegion, Order, Flags),\n            ID(ID) {\n        setAddress(Addr);\n      }\n\n      llvm::Constant *getID() const { return ID; }\n      void setID(llvm::Constant *V) {\n        assert(!ID && \"ID has been set before!\");\n        ID = V;\n      }\n      static bool classof(const OffloadEntryInfo *Info) {\n        return Info->getKind() == OffloadingEntryInfoTargetRegion;\n      }\n    };\n\n    /// Initialize target region entry.\n    void initializeTargetRegionEntryInfo(unsigned DeviceID, unsigned FileID,\n                                         StringRef ParentName, unsigned LineNum,\n                                         unsigned Order);\n    /// Register target region entry.\n    void registerTargetRegionEntryInfo(unsigned DeviceID, unsigned FileID,\n                                       StringRef ParentName, unsigned LineNum,\n                                       llvm::Constant *Addr, llvm::Constant *ID,\n                                       OMPTargetRegionEntryKind Flags);\n    /// Return true if a target region entry with the provided information\n    /// exists.\n    bool hasTargetRegionEntryInfo(unsigned DeviceID, unsigned FileID,\n                                  StringRef ParentName, unsigned LineNum,\n                                  bool IgnoreAddressId = false) const;\n    /// brief Applies action \\a Action on all registered entries.\n    typedef llvm::function_ref<void(unsigned, unsigned, StringRef, unsigned,\n                                    const OffloadEntryInfoTargetRegion &)>\n        OffloadTargetRegionEntryInfoActTy;\n    void actOnTargetRegionEntriesInfo(\n        const OffloadTargetRegionEntryInfoActTy &Action);\n\n    //\n    // Device global variable entries related.\n    //\n\n    /// Kind of the global variable entry..\n    enum OMPTargetGlobalVarEntryKind : uint32_t {\n      /// Mark the entry as a to declare target.\n      OMPTargetGlobalVarEntryTo = 0x0,\n      /// Mark the entry as a to declare target link.\n      OMPTargetGlobalVarEntryLink = 0x1,\n    };\n\n    /// Device global variable entries info.\n    class OffloadEntryInfoDeviceGlobalVar final : public OffloadEntryInfo {\n      /// Type of the global variable.\n     CharUnits VarSize;\n     llvm::GlobalValue::LinkageTypes Linkage;\n\n   public:\n     OffloadEntryInfoDeviceGlobalVar()\n         : OffloadEntryInfo(OffloadingEntryInfoDeviceGlobalVar) {}\n     explicit OffloadEntryInfoDeviceGlobalVar(unsigned Order,\n                                              OMPTargetGlobalVarEntryKind Flags)\n         : OffloadEntryInfo(OffloadingEntryInfoDeviceGlobalVar, Order, Flags) {}\n     explicit OffloadEntryInfoDeviceGlobalVar(\n         unsigned Order, llvm::Constant *Addr, CharUnits VarSize,\n         OMPTargetGlobalVarEntryKind Flags,\n         llvm::GlobalValue::LinkageTypes Linkage)\n         : OffloadEntryInfo(OffloadingEntryInfoDeviceGlobalVar, Order, Flags),\n           VarSize(VarSize), Linkage(Linkage) {\n       setAddress(Addr);\n      }\n\n      CharUnits getVarSize() const { return VarSize; }\n      void setVarSize(CharUnits Size) { VarSize = Size; }\n      llvm::GlobalValue::LinkageTypes getLinkage() const { return Linkage; }\n      void setLinkage(llvm::GlobalValue::LinkageTypes LT) { Linkage = LT; }\n      static bool classof(const OffloadEntryInfo *Info) {\n        return Info->getKind() == OffloadingEntryInfoDeviceGlobalVar;\n      }\n    };\n\n    /// Initialize device global variable entry.\n    void initializeDeviceGlobalVarEntryInfo(StringRef Name,\n                                            OMPTargetGlobalVarEntryKind Flags,\n                                            unsigned Order);\n\n    /// Register device global variable entry.\n    void\n    registerDeviceGlobalVarEntryInfo(StringRef VarName, llvm::Constant *Addr,\n                                     CharUnits VarSize,\n                                     OMPTargetGlobalVarEntryKind Flags,\n                                     llvm::GlobalValue::LinkageTypes Linkage);\n    /// Checks if the variable with the given name has been registered already.\n    bool hasDeviceGlobalVarEntryInfo(StringRef VarName) const {\n      return OffloadEntriesDeviceGlobalVar.count(VarName) > 0;\n    }\n    /// Applies action \\a Action on all registered entries.\n    typedef llvm::function_ref<void(StringRef,\n                                    const OffloadEntryInfoDeviceGlobalVar &)>\n        OffloadDeviceGlobalVarEntryInfoActTy;\n    void actOnDeviceGlobalVarEntriesInfo(\n        const OffloadDeviceGlobalVarEntryInfoActTy &Action);\n\n  private:\n    // Storage for target region entries kind. The storage is to be indexed by\n    // file ID, device ID, parent function name and line number.\n    typedef llvm::DenseMap<unsigned, OffloadEntryInfoTargetRegion>\n        OffloadEntriesTargetRegionPerLine;\n    typedef llvm::StringMap<OffloadEntriesTargetRegionPerLine>\n        OffloadEntriesTargetRegionPerParentName;\n    typedef llvm::DenseMap<unsigned, OffloadEntriesTargetRegionPerParentName>\n        OffloadEntriesTargetRegionPerFile;\n    typedef llvm::DenseMap<unsigned, OffloadEntriesTargetRegionPerFile>\n        OffloadEntriesTargetRegionPerDevice;\n    typedef OffloadEntriesTargetRegionPerDevice OffloadEntriesTargetRegionTy;\n    OffloadEntriesTargetRegionTy OffloadEntriesTargetRegion;\n    /// Storage for device global variable entries kind. The storage is to be\n    /// indexed by mangled name.\n    typedef llvm::StringMap<OffloadEntryInfoDeviceGlobalVar>\n        OffloadEntriesDeviceGlobalVarTy;\n    OffloadEntriesDeviceGlobalVarTy OffloadEntriesDeviceGlobalVar;\n  };\n  OffloadEntriesInfoManagerTy OffloadEntriesInfoManager;\n\n  bool ShouldMarkAsGlobal = true;\n  /// List of the emitted declarations.\n  llvm::DenseSet<CanonicalDeclPtr<const Decl>> AlreadyEmittedTargetDecls;\n  /// List of the global variables with their addresses that should not be\n  /// emitted for the target.\n  llvm::StringMap<llvm::WeakTrackingVH> EmittedNonTargetVariables;\n\n  /// List of variables that can become declare target implicitly and, thus,\n  /// must be emitted.\n  llvm::SmallDenseSet<const VarDecl *> DeferredGlobalVariables;\n\n  using NontemporalDeclsSet = llvm::SmallDenseSet<CanonicalDeclPtr<const Decl>>;\n  /// Stack for list of declarations in current context marked as nontemporal.\n  /// The set is the union of all current stack elements.\n  llvm::SmallVector<NontemporalDeclsSet, 4> NontemporalDeclsStack;\n\n  using UntiedLocalVarsAddressesMap =\n      llvm::DenseMap<CanonicalDeclPtr<const VarDecl>,\n                     std::pair<Address, Address>>;\n  llvm::SmallVector<UntiedLocalVarsAddressesMap, 4> UntiedLocalVarsStack;\n\n  /// Stack for list of addresses of declarations in current context marked as\n  /// lastprivate conditional. The set is the union of all current stack\n  /// elements.\n  llvm::SmallVector<LastprivateConditionalData, 4> LastprivateConditionalStack;\n\n  /// Flag for keeping track of weather a requires unified_shared_memory\n  /// directive is present.\n  bool HasRequiresUnifiedSharedMemory = false;\n\n  /// Atomic ordering from the omp requires directive.\n  llvm::AtomicOrdering RequiresAtomicOrdering = llvm::AtomicOrdering::Monotonic;\n\n  /// Flag for keeping track of weather a target region has been emitted.\n  bool HasEmittedTargetRegion = false;\n\n  /// Flag for keeping track of weather a device routine has been emitted.\n  /// Device routines are specific to the\n  bool HasEmittedDeclareTargetRegion = false;\n\n  /// Loads all the offload entries information from the host IR\n  /// metadata.\n  void loadOffloadInfoMetadata();\n\n  /// Returns __tgt_offload_entry type.\n  QualType getTgtOffloadEntryQTy();\n\n  /// Start scanning from statement \\a S and and emit all target regions\n  /// found along the way.\n  /// \\param S Starting statement.\n  /// \\param ParentName Name of the function declaration that is being scanned.\n  void scanForTargetRegionsFunctions(const Stmt *S, StringRef ParentName);\n\n  /// Build type kmp_routine_entry_t (if not built yet).\n  void emitKmpRoutineEntryT(QualType KmpInt32Ty);\n\n  /// Returns pointer to kmpc_micro type.\n  llvm::Type *getKmpc_MicroPointerTy();\n\n  /// Returns __kmpc_for_static_init_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createForStaticInitFunction(unsigned IVSize,\n                                                   bool IVSigned);\n\n  /// Returns __kmpc_dispatch_init_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createDispatchInitFunction(unsigned IVSize,\n                                                  bool IVSigned);\n\n  /// Returns __kmpc_dispatch_next_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createDispatchNextFunction(unsigned IVSize,\n                                                  bool IVSigned);\n\n  /// Returns __kmpc_dispatch_fini_* runtime function for the specified\n  /// size \\a IVSize and sign \\a IVSigned.\n  llvm::FunctionCallee createDispatchFiniFunction(unsigned IVSize,\n                                                  bool IVSigned);\n\n  /// If the specified mangled name is not in the module, create and\n  /// return threadprivate cache object. This object is a pointer's worth of\n  /// storage that's reserved for use by the OpenMP runtime.\n  /// \\param VD Threadprivate variable.\n  /// \\return Cache variable for the specified threadprivate.\n  llvm::Constant *getOrCreateThreadPrivateCache(const VarDecl *VD);\n\n  /// Gets (if variable with the given name already exist) or creates\n  /// internal global variable with the specified Name. The created variable has\n  /// linkage CommonLinkage by default and is initialized by null value.\n  /// \\param Ty Type of the global variable. If it is exist already the type\n  /// must be the same.\n  /// \\param Name Name of the variable.\n  llvm::Constant *getOrCreateInternalVariable(llvm::Type *Ty,\n                                              const llvm::Twine &Name,\n                                              unsigned AddressSpace = 0);\n\n  /// Set of threadprivate variables with the generated initializer.\n  llvm::StringSet<> ThreadPrivateWithDefinition;\n\n  /// Set of declare target variables with the generated initializer.\n  llvm::StringSet<> DeclareTargetWithDefinition;\n\n  /// Emits initialization code for the threadprivate variables.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Ctor Pointer to a global init function for \\a VD.\n  /// \\param CopyCtor Pointer to a global copy function for \\a VD.\n  /// \\param Dtor Pointer to a global destructor function for \\a VD.\n  /// \\param Loc Location of threadprivate declaration.\n  void emitThreadPrivateVarInit(CodeGenFunction &CGF, Address VDAddr,\n                                llvm::Value *Ctor, llvm::Value *CopyCtor,\n                                llvm::Value *Dtor, SourceLocation Loc);\n\n  /// Emit the array initialization or deletion portion for user-defined mapper\n  /// code generation.\n  void emitUDMapperArrayInitOrDel(CodeGenFunction &MapperCGF,\n                                  llvm::Value *Handle, llvm::Value *BasePtr,\n                                  llvm::Value *Ptr, llvm::Value *Size,\n                                  llvm::Value *MapType, CharUnits ElementSize,\n                                  llvm::BasicBlock *ExitBB, bool IsInit);\n\n  struct TaskResultTy {\n    llvm::Value *NewTask = nullptr;\n    llvm::Function *TaskEntry = nullptr;\n    llvm::Value *NewTaskNewTaskTTy = nullptr;\n    LValue TDBase;\n    const RecordDecl *KmpTaskTQTyRD = nullptr;\n    llvm::Value *TaskDupFn = nullptr;\n  };\n  /// Emit task region for the task directive. The task region is emitted in\n  /// several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  TaskResultTy emitTaskInit(CodeGenFunction &CGF, SourceLocation Loc,\n                            const OMPExecutableDirective &D,\n                            llvm::Function *TaskFunction, QualType SharedsTy,\n                            Address Shareds, const OMPTaskDataTy &Data);\n\n  /// Returns default address space for the constant firstprivates, 0 by\n  /// default.\n  virtual unsigned getDefaultFirstprivateAddressSpace() const { return 0; }\n\n  /// Emit code that pushes the trip count of loops associated with constructs\n  /// 'target teams distribute' and 'teams distribute parallel for'.\n  /// \\param SizeEmitter Emits the int64 value for the number of iterations of\n  /// the associated loop.\n  void emitTargetNumIterationsCall(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      llvm::Value *DeviceID,\n      llvm::function_ref<llvm::Value *(CodeGenFunction &CGF,\n                                       const OMPLoopDirective &D)>\n          SizeEmitter);\n\n  /// Emit update for lastprivate conditional data.\n  void emitLastprivateConditionalUpdate(CodeGenFunction &CGF, LValue IVLVal,\n                                        StringRef UniqueDeclName, LValue LVal,\n                                        SourceLocation Loc);\n\n  /// Returns the number of the elements and the address of the depobj\n  /// dependency array.\n  /// \\return Number of elements in depobj array and the pointer to the array of\n  /// dependencies.\n  std::pair<llvm::Value *, LValue> getDepobjElements(CodeGenFunction &CGF,\n                                                     LValue DepobjLVal,\n                                                     SourceLocation Loc);\n\npublic:\n  explicit CGOpenMPRuntime(CodeGenModule &CGM)\n      : CGOpenMPRuntime(CGM, \".\", \".\") {}\n  virtual ~CGOpenMPRuntime() {}\n  virtual void clear();\n\n  /// Emits code for OpenMP 'if' clause using specified \\a CodeGen\n  /// function. Here is the logic:\n  /// if (Cond) {\n  ///   ThenGen();\n  /// } else {\n  ///   ElseGen();\n  /// }\n  void emitIfClause(CodeGenFunction &CGF, const Expr *Cond,\n                    const RegionCodeGenTy &ThenGen,\n                    const RegionCodeGenTy &ElseGen);\n\n  /// Checks if the \\p Body is the \\a CompoundStmt and returns its child\n  /// statement iff there is only one that is not evaluatable at the compile\n  /// time.\n  static const Stmt *getSingleCompoundChild(ASTContext &Ctx, const Stmt *Body);\n\n  /// Get the platform-specific name separator.\n  std::string getName(ArrayRef<StringRef> Parts) const;\n\n  /// Emit code for the specified user defined reduction construct.\n  virtual void emitUserDefinedReduction(CodeGenFunction *CGF,\n                                        const OMPDeclareReductionDecl *D);\n  /// Get combiner/initializer for the specified user-defined reduction, if any.\n  virtual std::pair<llvm::Function *, llvm::Function *>\n  getUserDefinedReduction(const OMPDeclareReductionDecl *D);\n\n  /// Emit the function for the user defined mapper construct.\n  void emitUserDefinedMapper(const OMPDeclareMapperDecl *D,\n                             CodeGenFunction *CGF = nullptr);\n  /// Get the function for the specified user-defined mapper. If it does not\n  /// exist, create one.\n  llvm::Function *\n  getOrCreateUserDefinedMapperFunc(const OMPDeclareMapperDecl *D);\n\n  /// Emits outlined function for the specified OpenMP parallel directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  virtual llvm::Function *emitParallelOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen);\n\n  /// Emits outlined function for the specified OpenMP teams directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  virtual llvm::Function *emitTeamsOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen);\n\n  /// Emits outlined function for the OpenMP task directive \\a D. This\n  /// outlined function has type void(*)(kmp_int32 ThreadID, struct task_t*\n  /// TaskT).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param PartIDVar Variable for partition id in the current OpenMP untied\n  /// task region.\n  /// \\param TaskTVar Variable for task_t argument.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// \\param Tied true if task is generated for tied task, false otherwise.\n  /// \\param NumberOfParts Number of parts in untied task. Ignored for tied\n  /// tasks.\n  ///\n  virtual llvm::Function *emitTaskOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      const VarDecl *PartIDVar, const VarDecl *TaskTVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen,\n      bool Tied, unsigned &NumberOfParts);\n\n  /// Cleans up references to the objects in finished function.\n  ///\n  virtual void functionFinished(CodeGenFunction &CGF);\n\n  /// Emits code for parallel or serial call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run in parallel threads. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  ///\n  virtual void emitParallelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                                llvm::Function *OutlinedFn,\n                                ArrayRef<llvm::Value *> CapturedVars,\n                                const Expr *IfCond);\n\n  /// Emits a critical region.\n  /// \\param CriticalName Name of the critical region.\n  /// \\param CriticalOpGen Generator for the statement associated with the given\n  /// critical region.\n  /// \\param Hint Value of the 'hint' clause (optional).\n  virtual void emitCriticalRegion(CodeGenFunction &CGF, StringRef CriticalName,\n                                  const RegionCodeGenTy &CriticalOpGen,\n                                  SourceLocation Loc,\n                                  const Expr *Hint = nullptr);\n\n  /// Emits a master region.\n  /// \\param MasterOpGen Generator for the statement associated with the given\n  /// master region.\n  virtual void emitMasterRegion(CodeGenFunction &CGF,\n                                const RegionCodeGenTy &MasterOpGen,\n                                SourceLocation Loc);\n\n  /// Emits code for a taskyield directive.\n  virtual void emitTaskyieldCall(CodeGenFunction &CGF, SourceLocation Loc);\n\n  /// Emit a taskgroup region.\n  /// \\param TaskgroupOpGen Generator for the statement associated with the\n  /// given taskgroup region.\n  virtual void emitTaskgroupRegion(CodeGenFunction &CGF,\n                                   const RegionCodeGenTy &TaskgroupOpGen,\n                                   SourceLocation Loc);\n\n  /// Emits a single region.\n  /// \\param SingleOpGen Generator for the statement associated with the given\n  /// single region.\n  virtual void emitSingleRegion(CodeGenFunction &CGF,\n                                const RegionCodeGenTy &SingleOpGen,\n                                SourceLocation Loc,\n                                ArrayRef<const Expr *> CopyprivateVars,\n                                ArrayRef<const Expr *> DestExprs,\n                                ArrayRef<const Expr *> SrcExprs,\n                                ArrayRef<const Expr *> AssignmentOps);\n\n  /// Emit an ordered region.\n  /// \\param OrderedOpGen Generator for the statement associated with the given\n  /// ordered region.\n  virtual void emitOrderedRegion(CodeGenFunction &CGF,\n                                 const RegionCodeGenTy &OrderedOpGen,\n                                 SourceLocation Loc, bool IsThreads);\n\n  /// Emit an implicit/explicit barrier for OpenMP threads.\n  /// \\param Kind Directive for which this implicit barrier call must be\n  /// generated. Must be OMPD_barrier for explicit barrier generation.\n  /// \\param EmitChecks true if need to emit checks for cancellation barriers.\n  /// \\param ForceSimpleCall true simple barrier call must be emitted, false if\n  /// runtime class decides which one to emit (simple or with cancellation\n  /// checks).\n  ///\n  virtual void emitBarrierCall(CodeGenFunction &CGF, SourceLocation Loc,\n                               OpenMPDirectiveKind Kind,\n                               bool EmitChecks = true,\n                               bool ForceSimpleCall = false);\n\n  /// Check if the specified \\a ScheduleKind is static non-chunked.\n  /// This kind of worksharing directive is emitted without outer loop.\n  /// \\param ScheduleKind Schedule kind specified in the 'schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticNonchunked(OpenMPScheduleClauseKind ScheduleKind,\n                                  bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is static non-chunked.\n  /// This kind of distribute directive is emitted without outer loop.\n  /// \\param ScheduleKind Schedule kind specified in the 'dist_schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticNonchunked(OpenMPDistScheduleClauseKind ScheduleKind,\n                                  bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is static chunked.\n  /// \\param ScheduleKind Schedule kind specified in the 'schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticChunked(OpenMPScheduleClauseKind ScheduleKind,\n                               bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is static non-chunked.\n  /// \\param ScheduleKind Schedule kind specified in the 'dist_schedule' clause.\n  /// \\param Chunked True if chunk is specified in the clause.\n  ///\n  virtual bool isStaticChunked(OpenMPDistScheduleClauseKind ScheduleKind,\n                               bool Chunked) const;\n\n  /// Check if the specified \\a ScheduleKind is dynamic.\n  /// This kind of worksharing directive is emitted without outer loop.\n  /// \\param ScheduleKind Schedule Kind specified in the 'schedule' clause.\n  ///\n  virtual bool isDynamic(OpenMPScheduleClauseKind ScheduleKind) const;\n\n  /// struct with the values to be passed to the dispatch runtime function\n  struct DispatchRTInput {\n    /// Loop lower bound\n    llvm::Value *LB = nullptr;\n    /// Loop upper bound\n    llvm::Value *UB = nullptr;\n    /// Chunk size specified using 'schedule' clause (nullptr if chunk\n    /// was not specified)\n    llvm::Value *Chunk = nullptr;\n    DispatchRTInput() = default;\n    DispatchRTInput(llvm::Value *LB, llvm::Value *UB, llvm::Value *Chunk)\n        : LB(LB), UB(UB), Chunk(Chunk) {}\n  };\n\n  /// Call the appropriate runtime routine to initialize it before start\n  /// of loop.\n\n  /// This is used for non static scheduled types and when the ordered\n  /// clause is present on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds \\a LB and \\a UB and stride \\a ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param Ordered true if loop is ordered, false otherwise.\n  /// \\param DispatchValues struct containing llvm values for lower bound, upper\n  /// bound, and chunk expression.\n  /// For the default (nullptr) value, the chunk 1 will be used.\n  ///\n  virtual void emitForDispatchInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                   const OpenMPScheduleTy &ScheduleKind,\n                                   unsigned IVSize, bool IVSigned, bool Ordered,\n                                   const DispatchRTInput &DispatchValues);\n\n  /// Struct with the values to be passed to the static runtime function\n  struct StaticRTInput {\n    /// Size of the iteration variable in bits.\n    unsigned IVSize = 0;\n    /// Sign of the iteration variable.\n    bool IVSigned = false;\n    /// true if loop is ordered, false otherwise.\n    bool Ordered = false;\n    /// Address of the output variable in which the flag of the last iteration\n    /// is returned.\n    Address IL = Address::invalid();\n    /// Address of the output variable in which the lower iteration number is\n    /// returned.\n    Address LB = Address::invalid();\n    /// Address of the output variable in which the upper iteration number is\n    /// returned.\n    Address UB = Address::invalid();\n    /// Address of the output variable in which the stride value is returned\n    /// necessary to generated the static_chunked scheduled loop.\n    Address ST = Address::invalid();\n    /// Value of the chunk for the static_chunked scheduled loop. For the\n    /// default (nullptr) value, the chunk 1 will be used.\n    llvm::Value *Chunk = nullptr;\n    StaticRTInput(unsigned IVSize, bool IVSigned, bool Ordered, Address IL,\n                  Address LB, Address UB, Address ST,\n                  llvm::Value *Chunk = nullptr)\n        : IVSize(IVSize), IVSigned(IVSigned), Ordered(Ordered), IL(IL), LB(LB),\n          UB(UB), ST(ST), Chunk(Chunk) {}\n  };\n  /// Call the appropriate runtime routine to initialize it before start\n  /// of loop.\n  ///\n  /// This is used only in case of static schedule, when the user did not\n  /// specify a ordered clause on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds LB and UB and stride ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  virtual void emitForStaticInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                 OpenMPDirectiveKind DKind,\n                                 const OpenMPScheduleTy &ScheduleKind,\n                                 const StaticRTInput &Values);\n\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param SchedKind Schedule kind, specified by the 'dist_schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  virtual void emitDistributeStaticInit(CodeGenFunction &CGF,\n                                        SourceLocation Loc,\n                                        OpenMPDistScheduleClauseKind SchedKind,\n                                        const StaticRTInput &Values);\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// iteration of the ordered loop with the dynamic scheduling.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  ///\n  virtual void emitForOrderedIterationEnd(CodeGenFunction &CGF,\n                                          SourceLocation Loc, unsigned IVSize,\n                                          bool IVSigned);\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// all the work with current loop.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive for which the static finish is emitted.\n  ///\n  virtual void emitForStaticFinish(CodeGenFunction &CGF, SourceLocation Loc,\n                                   OpenMPDirectiveKind DKind);\n\n  /// Call __kmpc_dispatch_next(\n  ///          ident_t *loc, kmp_int32 tid, kmp_int32 *p_lastiter,\n  ///          kmp_int[32|64] *p_lower, kmp_int[32|64] *p_upper,\n  ///          kmp_int[32|64] *p_stride);\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param IL Address of the output variable in which the flag of the\n  /// last iteration is returned.\n  /// \\param LB Address of the output variable in which the lower iteration\n  /// number is returned.\n  /// \\param UB Address of the output variable in which the upper iteration\n  /// number is returned.\n  /// \\param ST Address of the output variable in which the stride value is\n  /// returned.\n  virtual llvm::Value *emitForNext(CodeGenFunction &CGF, SourceLocation Loc,\n                                   unsigned IVSize, bool IVSigned,\n                                   Address IL, Address LB,\n                                   Address UB, Address ST);\n\n  /// Emits call to void __kmpc_push_num_threads(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_threads) to generate code for 'num_threads'\n  /// clause.\n  /// \\param NumThreads An integer value of threads.\n  virtual void emitNumThreadsClause(CodeGenFunction &CGF,\n                                    llvm::Value *NumThreads,\n                                    SourceLocation Loc);\n\n  /// Emit call to void __kmpc_push_proc_bind(ident_t *loc, kmp_int32\n  /// global_tid, int proc_bind) to generate code for 'proc_bind' clause.\n  virtual void emitProcBindClause(CodeGenFunction &CGF,\n                                  llvm::omp::ProcBindKind ProcBind,\n                                  SourceLocation Loc);\n\n  /// Returns address of the threadprivate variable for the current\n  /// thread.\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of the reference to threadprivate var.\n  /// \\return Address of the threadprivate variable for the current thread.\n  virtual Address getAddrOfThreadPrivate(CodeGenFunction &CGF,\n                                         const VarDecl *VD,\n                                         Address VDAddr,\n                                         SourceLocation Loc);\n\n  /// Returns the address of the variable marked as declare target with link\n  /// clause OR as declare target with to clause and unified memory.\n  virtual Address getAddrOfDeclareTargetVar(const VarDecl *VD);\n\n  /// Emit a code for initialization of threadprivate variable. It emits\n  /// a call to runtime library which adds initial value to the newly created\n  /// threadprivate variable (if it is not constant) and registers destructor\n  /// for the variable (if any).\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of threadprivate declaration.\n  /// \\param PerformInit true if initialization expression is not constant.\n  virtual llvm::Function *\n  emitThreadPrivateVarDefinition(const VarDecl *VD, Address VDAddr,\n                                 SourceLocation Loc, bool PerformInit,\n                                 CodeGenFunction *CGF = nullptr);\n\n  /// Emit a code for initialization of declare target variable.\n  /// \\param VD Declare target variable.\n  /// \\param Addr Address of the global variable \\a VD.\n  /// \\param PerformInit true if initialization expression is not constant.\n  virtual bool emitDeclareTargetVarDefinition(const VarDecl *VD,\n                                              llvm::GlobalVariable *Addr,\n                                              bool PerformInit);\n\n  /// Creates artificial threadprivate variable with name \\p Name and type \\p\n  /// VarType.\n  /// \\param VarType Type of the artificial threadprivate variable.\n  /// \\param Name Name of the artificial threadprivate variable.\n  virtual Address getAddrOfArtificialThreadPrivate(CodeGenFunction &CGF,\n                                                   QualType VarType,\n                                                   StringRef Name);\n\n  /// Emit flush of the variables specified in 'omp flush' directive.\n  /// \\param Vars List of variables to flush.\n  virtual void emitFlush(CodeGenFunction &CGF, ArrayRef<const Expr *> Vars,\n                         SourceLocation Loc, llvm::AtomicOrdering AO);\n\n  /// Emit task region for the task directive. The task region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to kmp_int32 __kmpc_omp_task(ident_t *, kmp_int32 gtid,\n  /// kmp_task_t *new_task), where new_task is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  virtual void emitTaskCall(CodeGenFunction &CGF, SourceLocation Loc,\n                            const OMPExecutableDirective &D,\n                            llvm::Function *TaskFunction, QualType SharedsTy,\n                            Address Shareds, const Expr *IfCond,\n                            const OMPTaskDataTy &Data);\n\n  /// Emit task region for the taskloop directive. The taskloop region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to void __kmpc_taskloop(ident_t *loc, int gtid, kmp_task_t\n  /// *task, int if_val, kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st, int\n  /// nogroup, int sched, kmp_uint64 grainsize, void *task_dup ), where new_task\n  /// is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  virtual void emitTaskLoopCall(CodeGenFunction &CGF, SourceLocation Loc,\n                                const OMPLoopDirective &D,\n                                llvm::Function *TaskFunction,\n                                QualType SharedsTy, Address Shareds,\n                                const Expr *IfCond, const OMPTaskDataTy &Data);\n\n  /// Emit code for the directive that does not require outlining.\n  ///\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// \\param HasCancel true if region has inner cancel directive, false\n  /// otherwise.\n  virtual void emitInlinedDirective(CodeGenFunction &CGF,\n                                    OpenMPDirectiveKind InnermostKind,\n                                    const RegionCodeGenTy &CodeGen,\n                                    bool HasCancel = false);\n\n  /// Emits reduction function.\n  /// \\param ArgsType Array type containing pointers to reduction variables.\n  /// \\param Privates List of private copies for original reduction arguments.\n  /// \\param LHSExprs List of LHS in \\a ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a ReductionOps reduction operations.\n  /// \\param ReductionOps List of reduction operations in form 'LHS binop RHS'\n  /// or 'operator binop(LHS, RHS)'.\n  llvm::Function *emitReductionFunction(SourceLocation Loc,\n                                        llvm::Type *ArgsType,\n                                        ArrayRef<const Expr *> Privates,\n                                        ArrayRef<const Expr *> LHSExprs,\n                                        ArrayRef<const Expr *> RHSExprs,\n                                        ArrayRef<const Expr *> ReductionOps);\n\n  /// Emits single reduction combiner\n  void emitSingleReductionCombiner(CodeGenFunction &CGF,\n                                   const Expr *ReductionOp,\n                                   const Expr *PrivateRef,\n                                   const DeclRefExpr *LHS,\n                                   const DeclRefExpr *RHS);\n\n  struct ReductionOptionsTy {\n    bool WithNowait;\n    bool SimpleReduction;\n    OpenMPDirectiveKind ReductionKind;\n  };\n  /// Emit a code for reduction clause. Next code should be emitted for\n  /// reduction:\n  /// \\code\n  ///\n  /// static kmp_critical_name lock = { 0 };\n  ///\n  /// void reduce_func(void *lhs[<n>], void *rhs[<n>]) {\n  ///  ...\n  ///  *(Type<i>*)lhs[i] = RedOp<i>(*(Type<i>*)lhs[i], *(Type<i>*)rhs[i]);\n  ///  ...\n  /// }\n  ///\n  /// ...\n  /// void *RedList[<n>] = {&<RHSExprs>[0], ..., &<RHSExprs>[<n>-1]};\n  /// switch (__kmpc_reduce{_nowait}(<loc>, <gtid>, <n>, sizeof(RedList),\n  /// RedList, reduce_func, &<lock>)) {\n  /// case 1:\n  ///  ...\n  ///  <LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]);\n  ///  ...\n  /// __kmpc_end_reduce{_nowait}(<loc>, <gtid>, &<lock>);\n  /// break;\n  /// case 2:\n  ///  ...\n  ///  Atomic(<LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]));\n  ///  ...\n  /// break;\n  /// default:;\n  /// }\n  /// \\endcode\n  ///\n  /// \\param Privates List of private copies for original reduction arguments.\n  /// \\param LHSExprs List of LHS in \\a ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a ReductionOps reduction operations.\n  /// \\param ReductionOps List of reduction operations in form 'LHS binop RHS'\n  /// or 'operator binop(LHS, RHS)'.\n  /// \\param Options List of options for reduction codegen:\n  ///     WithNowait true if parent directive has also nowait clause, false\n  ///     otherwise.\n  ///     SimpleReduction Emit reduction operation only. Used for omp simd\n  ///     directive on the host.\n  ///     ReductionKind The kind of reduction to perform.\n  virtual void emitReduction(CodeGenFunction &CGF, SourceLocation Loc,\n                             ArrayRef<const Expr *> Privates,\n                             ArrayRef<const Expr *> LHSExprs,\n                             ArrayRef<const Expr *> RHSExprs,\n                             ArrayRef<const Expr *> ReductionOps,\n                             ReductionOptionsTy Options);\n\n  /// Emit a code for initialization of task reduction clause. Next code\n  /// should be emitted for reduction:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_init(gtid, n, red_data);\n  /// \\endcode\n  /// For reduction clause with task modifier it emits the next call:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_modifier_init(loc, gtid, is_worksharing, n,\n  /// red_data);\n  /// \\endcode\n  /// \\param LHSExprs List of LHS in \\a Data.ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a Data.ReductionOps reduction operations.\n  /// \\param Data Additional data for task generation like tiedness, final\n  /// state, list of privates, reductions etc.\n  virtual llvm::Value *emitTaskReductionInit(CodeGenFunction &CGF,\n                                             SourceLocation Loc,\n                                             ArrayRef<const Expr *> LHSExprs,\n                                             ArrayRef<const Expr *> RHSExprs,\n                                             const OMPTaskDataTy &Data);\n\n  /// Emits the following code for reduction clause with task modifier:\n  /// \\code\n  /// __kmpc_task_reduction_modifier_fini(loc, gtid, is_worksharing);\n  /// \\endcode\n  virtual void emitTaskReductionFini(CodeGenFunction &CGF, SourceLocation Loc,\n                                     bool IsWorksharingReduction);\n\n  /// Required to resolve existing problems in the runtime. Emits threadprivate\n  /// variables to store the size of the VLAs/array sections for\n  /// initializer/combiner/finalizer functions.\n  /// \\param RCG Allows to reuse an existing data for the reductions.\n  /// \\param N Reduction item for which fixups must be emitted.\n  virtual void emitTaskReductionFixups(CodeGenFunction &CGF, SourceLocation Loc,\n                                       ReductionCodeGen &RCG, unsigned N);\n\n  /// Get the address of `void *` type of the privatue copy of the reduction\n  /// item specified by the \\p SharedLVal.\n  /// \\param ReductionsPtr Pointer to the reduction data returned by the\n  /// emitTaskReductionInit function.\n  /// \\param SharedLVal Address of the original reduction item.\n  virtual Address getTaskReductionItem(CodeGenFunction &CGF, SourceLocation Loc,\n                                       llvm::Value *ReductionsPtr,\n                                       LValue SharedLVal);\n\n  /// Emit code for 'taskwait' directive.\n  virtual void emitTaskwaitCall(CodeGenFunction &CGF, SourceLocation Loc);\n\n  /// Emit code for 'cancellation point' construct.\n  /// \\param CancelRegion Region kind for which the cancellation point must be\n  /// emitted.\n  ///\n  virtual void emitCancellationPointCall(CodeGenFunction &CGF,\n                                         SourceLocation Loc,\n                                         OpenMPDirectiveKind CancelRegion);\n\n  /// Emit code for 'cancel' construct.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  /// \\param CancelRegion Region kind for which the cancel must be emitted.\n  ///\n  virtual void emitCancelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                              const Expr *IfCond,\n                              OpenMPDirectiveKind CancelRegion);\n\n  /// Emit outilined function for 'target' directive.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  virtual void emitTargetOutlinedFunction(const OMPExecutableDirective &D,\n                                          StringRef ParentName,\n                                          llvm::Function *&OutlinedFn,\n                                          llvm::Constant *&OutlinedFnID,\n                                          bool IsOffloadEntry,\n                                          const RegionCodeGenTy &CodeGen);\n\n  /// Emit the target offloading code associated with \\a D. The emitted\n  /// code attempts offloading the execution to the device, an the event of\n  /// a failure it executes the host version outlined in \\a OutlinedFn.\n  /// \\param D Directive to emit.\n  /// \\param OutlinedFn Host version of the code to be offloaded.\n  /// \\param OutlinedFnID ID of host version of the code to be offloaded.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used and device modifier.\n  /// \\param SizeEmitter Callback to emit number of iterations for loop-based\n  /// directives.\n  virtual void emitTargetCall(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      llvm::Function *OutlinedFn, llvm::Value *OutlinedFnID, const Expr *IfCond,\n      llvm::PointerIntPair<const Expr *, 2, OpenMPDeviceClauseModifier> Device,\n      llvm::function_ref<llvm::Value *(CodeGenFunction &CGF,\n                                       const OMPLoopDirective &D)>\n          SizeEmitter);\n\n  /// Emit the target regions enclosed in \\a GD function definition or\n  /// the function itself in case it is a valid device function. Returns true if\n  /// \\a GD was dealt with successfully.\n  /// \\param GD Function to scan.\n  virtual bool emitTargetFunctions(GlobalDecl GD);\n\n  /// Emit the global variable if it is a valid device global variable.\n  /// Returns true if \\a GD was dealt with successfully.\n  /// \\param GD Variable declaration to emit.\n  virtual bool emitTargetGlobalVariable(GlobalDecl GD);\n\n  /// Checks if the provided global decl \\a GD is a declare target variable and\n  /// registers it when emitting code for the host.\n  virtual void registerTargetGlobalVariable(const VarDecl *VD,\n                                            llvm::Constant *Addr);\n\n  /// Registers provided target firstprivate variable as global on the\n  /// target.\n  llvm::Constant *registerTargetFirstprivateCopy(CodeGenFunction &CGF,\n                                                 const VarDecl *VD);\n\n  /// Emit the global \\a GD if it is meaningful for the target. Returns\n  /// if it was emitted successfully.\n  /// \\param GD Global to scan.\n  virtual bool emitTargetGlobal(GlobalDecl GD);\n\n  /// Creates and returns a registration function for when at least one\n  /// requires directives was used in the current module.\n  llvm::Function *emitRequiresDirectiveRegFun();\n\n  /// Creates all the offload entries in the current compilation unit\n  /// along with the associated metadata.\n  void createOffloadEntriesAndInfoMetadata();\n\n  /// Emits code for teams call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run by team masters. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  ///\n  virtual void emitTeamsCall(CodeGenFunction &CGF,\n                             const OMPExecutableDirective &D,\n                             SourceLocation Loc, llvm::Function *OutlinedFn,\n                             ArrayRef<llvm::Value *> CapturedVars);\n\n  /// Emits call to void __kmpc_push_num_teams(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_teams, kmp_int32 thread_limit) to generate code\n  /// for num_teams clause.\n  /// \\param NumTeams An integer expression of teams.\n  /// \\param ThreadLimit An integer expression of threads.\n  virtual void emitNumTeamsClause(CodeGenFunction &CGF, const Expr *NumTeams,\n                                  const Expr *ThreadLimit, SourceLocation Loc);\n\n  /// Struct that keeps all the relevant information that should be kept\n  /// throughout a 'target data' region.\n  class TargetDataInfo {\n    /// Set to true if device pointer information have to be obtained.\n    bool RequiresDevicePointerInfo = false;\n    /// Set to true if Clang emits separate runtime calls for the beginning and\n    /// end of the region.  These calls might have separate map type arrays.\n    bool SeparateBeginEndCalls = false;\n\n  public:\n    /// The array of base pointer passed to the runtime library.\n    llvm::Value *BasePointersArray = nullptr;\n    /// The array of section pointers passed to the runtime library.\n    llvm::Value *PointersArray = nullptr;\n    /// The array of sizes passed to the runtime library.\n    llvm::Value *SizesArray = nullptr;\n    /// The array of map types passed to the runtime library for the beginning\n    /// of the region or for the entire region if there are no separate map\n    /// types for the region end.\n    llvm::Value *MapTypesArray = nullptr;\n    /// The array of map types passed to the runtime library for the end of the\n    /// region, or nullptr if there are no separate map types for the region\n    /// end.\n    llvm::Value *MapTypesArrayEnd = nullptr;\n    /// The array of user-defined mappers passed to the runtime library.\n    llvm::Value *MappersArray = nullptr;\n    /// The array of original declaration names of mapped pointers sent to the\n    /// runtime library for debugging\n    llvm::Value *MapNamesArray = nullptr;\n    /// Indicate whether any user-defined mapper exists.\n    bool HasMapper = false;\n    /// The total number of pointers passed to the runtime library.\n    unsigned NumberOfPtrs = 0u;\n    /// Map between the a declaration of a capture and the corresponding base\n    /// pointer address where the runtime returns the device pointers.\n    llvm::DenseMap<const ValueDecl *, Address> CaptureDeviceAddrMap;\n\n    explicit TargetDataInfo() {}\n    explicit TargetDataInfo(bool RequiresDevicePointerInfo,\n                            bool SeparateBeginEndCalls)\n        : RequiresDevicePointerInfo(RequiresDevicePointerInfo),\n          SeparateBeginEndCalls(SeparateBeginEndCalls) {}\n    /// Clear information about the data arrays.\n    void clearArrayInfo() {\n      BasePointersArray = nullptr;\n      PointersArray = nullptr;\n      SizesArray = nullptr;\n      MapTypesArray = nullptr;\n      MapTypesArrayEnd = nullptr;\n      MapNamesArray = nullptr;\n      MappersArray = nullptr;\n      HasMapper = false;\n      NumberOfPtrs = 0u;\n    }\n    /// Return true if the current target data information has valid arrays.\n    bool isValid() {\n      return BasePointersArray && PointersArray && SizesArray &&\n             MapTypesArray && (!HasMapper || MappersArray) && NumberOfPtrs;\n    }\n    bool requiresDevicePointerInfo() { return RequiresDevicePointerInfo; }\n    bool separateBeginEndCalls() { return SeparateBeginEndCalls; }\n  };\n\n  /// Emit the target data mapping code associated with \\a D.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Info A record used to store information that needs to be preserved\n  /// until the region is closed.\n  virtual void emitTargetDataCalls(CodeGenFunction &CGF,\n                                   const OMPExecutableDirective &D,\n                                   const Expr *IfCond, const Expr *Device,\n                                   const RegionCodeGenTy &CodeGen,\n                                   TargetDataInfo &Info);\n\n  /// Emit the data mapping/movement code associated with the directive\n  /// \\a D that should be of the form 'target [{enter|exit} data | update]'.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  virtual void emitTargetDataStandAloneCall(CodeGenFunction &CGF,\n                                            const OMPExecutableDirective &D,\n                                            const Expr *IfCond,\n                                            const Expr *Device);\n\n  /// Marks function \\a Fn with properly mangled versions of vector functions.\n  /// \\param FD Function marked as 'declare simd'.\n  /// \\param Fn LLVM function that must be marked with 'declare simd'\n  /// attributes.\n  virtual void emitDeclareSimdFunction(const FunctionDecl *FD,\n                                       llvm::Function *Fn);\n\n  /// Emit initialization for doacross loop nesting support.\n  /// \\param D Loop-based construct used in doacross nesting construct.\n  virtual void emitDoacrossInit(CodeGenFunction &CGF, const OMPLoopDirective &D,\n                                ArrayRef<Expr *> NumIterations);\n\n  /// Emit code for doacross ordered directive with 'depend' clause.\n  /// \\param C 'depend' clause with 'sink|source' dependency kind.\n  virtual void emitDoacrossOrdered(CodeGenFunction &CGF,\n                                   const OMPDependClause *C);\n\n  /// Translates the native parameter of outlined function if this is required\n  /// for target.\n  /// \\param FD Field decl from captured record for the parameter.\n  /// \\param NativeParam Parameter itself.\n  virtual const VarDecl *translateParameter(const FieldDecl *FD,\n                                            const VarDecl *NativeParam) const {\n    return NativeParam;\n  }\n\n  /// Gets the address of the native argument basing on the address of the\n  /// target-specific parameter.\n  /// \\param NativeParam Parameter itself.\n  /// \\param TargetParam Corresponding target-specific parameter.\n  virtual Address getParameterAddress(CodeGenFunction &CGF,\n                                      const VarDecl *NativeParam,\n                                      const VarDecl *TargetParam) const;\n\n  /// Choose default schedule type and chunk value for the\n  /// dist_schedule clause.\n  virtual void getDefaultDistScheduleAndChunk(CodeGenFunction &CGF,\n      const OMPLoopDirective &S, OpenMPDistScheduleClauseKind &ScheduleKind,\n      llvm::Value *&Chunk) const {}\n\n  /// Choose default schedule type and chunk value for the\n  /// schedule clause.\n  virtual void getDefaultScheduleAndChunk(CodeGenFunction &CGF,\n      const OMPLoopDirective &S, OpenMPScheduleClauseKind &ScheduleKind,\n      const Expr *&ChunkExpr) const;\n\n  /// Emits call of the outlined function with the provided arguments,\n  /// translating these arguments to correct target-specific arguments.\n  virtual void\n  emitOutlinedFunctionCall(CodeGenFunction &CGF, SourceLocation Loc,\n                           llvm::FunctionCallee OutlinedFn,\n                           ArrayRef<llvm::Value *> Args = llvm::None) const;\n\n  /// Emits OpenMP-specific function prolog.\n  /// Required for device constructs.\n  virtual void emitFunctionProlog(CodeGenFunction &CGF, const Decl *D);\n\n  /// Gets the OpenMP-specific address of the local variable.\n  virtual Address getAddressOfLocalVariable(CodeGenFunction &CGF,\n                                            const VarDecl *VD);\n\n  /// Marks the declaration as already emitted for the device code and returns\n  /// true, if it was marked already, and false, otherwise.\n  bool markAsGlobalTarget(GlobalDecl GD);\n\n  /// Emit deferred declare target variables marked for deferred emission.\n  void emitDeferredTargetDecls() const;\n\n  /// Adjust some parameters for the target-based directives, like addresses of\n  /// the variables captured by reference in lambdas.\n  virtual void\n  adjustTargetSpecificDataForLambdas(CodeGenFunction &CGF,\n                                     const OMPExecutableDirective &D) const;\n\n  /// Perform check on requires decl to ensure that target architecture\n  /// supports unified addressing\n  virtual void processRequiresDirective(const OMPRequiresDecl *D);\n\n  /// Gets default memory ordering as specified in requires directive.\n  llvm::AtomicOrdering getDefaultMemoryOrdering() const;\n\n  /// Checks if the variable has associated OMPAllocateDeclAttr attribute with\n  /// the predefined allocator and translates it into the corresponding address\n  /// space.\n  virtual bool hasAllocateAttributeForGlobalVar(const VarDecl *VD, LangAS &AS);\n\n  /// Return whether the unified_shared_memory has been specified.\n  bool hasRequiresUnifiedSharedMemory() const;\n\n  /// Checks if the \\p VD variable is marked as nontemporal declaration in\n  /// current context.\n  bool isNontemporalDecl(const ValueDecl *VD) const;\n\n  /// Create specialized alloca to handle lastprivate conditionals.\n  Address emitLastprivateConditionalInit(CodeGenFunction &CGF,\n                                         const VarDecl *VD);\n\n  /// Checks if the provided \\p LVal is lastprivate conditional and emits the\n  /// code to update the value of the original variable.\n  /// \\code\n  /// lastprivate(conditional: a)\n  /// ...\n  /// <type> a;\n  /// lp_a = ...;\n  /// #pragma omp critical(a)\n  /// if (last_iv_a <= iv) {\n  ///   last_iv_a = iv;\n  ///   global_a = lp_a;\n  /// }\n  /// \\endcode\n  virtual void checkAndEmitLastprivateConditional(CodeGenFunction &CGF,\n                                                  const Expr *LHS);\n\n  /// Checks if the lastprivate conditional was updated in inner region and\n  /// writes the value.\n  /// \\code\n  /// lastprivate(conditional: a)\n  /// ...\n  /// <type> a;bool Fired = false;\n  /// #pragma omp ... shared(a)\n  /// {\n  ///   lp_a = ...;\n  ///   Fired = true;\n  /// }\n  /// if (Fired) {\n  ///   #pragma omp critical(a)\n  ///   if (last_iv_a <= iv) {\n  ///     last_iv_a = iv;\n  ///     global_a = lp_a;\n  ///   }\n  ///   Fired = false;\n  /// }\n  /// \\endcode\n  virtual void checkAndEmitSharedLastprivateConditional(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      const llvm::DenseSet<CanonicalDeclPtr<const VarDecl>> &IgnoredDecls);\n\n  /// Gets the address of the global copy used for lastprivate conditional\n  /// update, if any.\n  /// \\param PrivLVal LValue for the private copy.\n  /// \\param VD Original lastprivate declaration.\n  virtual void emitLastprivateConditionalFinalUpdate(CodeGenFunction &CGF,\n                                                     LValue PrivLVal,\n                                                     const VarDecl *VD,\n                                                     SourceLocation Loc);\n\n  /// Emits list of dependecies based on the provided data (array of\n  /// dependence/expression pairs).\n  /// \\returns Pointer to the first element of the array casted to VoidPtr type.\n  std::pair<llvm::Value *, Address>\n  emitDependClause(CodeGenFunction &CGF,\n                   ArrayRef<OMPTaskDataTy::DependData> Dependencies,\n                   SourceLocation Loc);\n\n  /// Emits list of dependecies based on the provided data (array of\n  /// dependence/expression pairs) for depobj construct. In this case, the\n  /// variable is allocated in dynamically. \\returns Pointer to the first\n  /// element of the array casted to VoidPtr type.\n  Address emitDepobjDependClause(CodeGenFunction &CGF,\n                                 const OMPTaskDataTy::DependData &Dependencies,\n                                 SourceLocation Loc);\n\n  /// Emits the code to destroy the dependency object provided in depobj\n  /// directive.\n  void emitDestroyClause(CodeGenFunction &CGF, LValue DepobjLVal,\n                         SourceLocation Loc);\n\n  /// Updates the dependency kind in the specified depobj object.\n  /// \\param DepobjLVal LValue for the main depobj object.\n  /// \\param NewDepKind New dependency kind.\n  void emitUpdateClause(CodeGenFunction &CGF, LValue DepobjLVal,\n                        OpenMPDependClauseKind NewDepKind, SourceLocation Loc);\n\n  /// Initializes user defined allocators specified in the uses_allocators\n  /// clauses.\n  void emitUsesAllocatorsInit(CodeGenFunction &CGF, const Expr *Allocator,\n                              const Expr *AllocatorTraits);\n\n  /// Destroys user defined allocators specified in the uses_allocators clause.\n  void emitUsesAllocatorsFini(CodeGenFunction &CGF, const Expr *Allocator);\n\n  /// Returns true if the variable is a local variable in untied task.\n  bool isLocalVarInUntiedTask(CodeGenFunction &CGF, const VarDecl *VD) const;\n};\n\n/// Class supports emissionof SIMD-only code.\nclass CGOpenMPSIMDRuntime final : public CGOpenMPRuntime {\npublic:\n  explicit CGOpenMPSIMDRuntime(CodeGenModule &CGM) : CGOpenMPRuntime(CGM) {}\n  ~CGOpenMPSIMDRuntime() override {}\n\n  /// Emits outlined function for the specified OpenMP parallel directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  llvm::Function *\n  emitParallelOutlinedFunction(const OMPExecutableDirective &D,\n                               const VarDecl *ThreadIDVar,\n                               OpenMPDirectiveKind InnermostKind,\n                               const RegionCodeGenTy &CodeGen) override;\n\n  /// Emits outlined function for the specified OpenMP teams directive\n  /// \\a D. This outlined function has type void(*)(kmp_int32 *ThreadID,\n  /// kmp_int32 BoundID, struct context_vars*).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  llvm::Function *\n  emitTeamsOutlinedFunction(const OMPExecutableDirective &D,\n                            const VarDecl *ThreadIDVar,\n                            OpenMPDirectiveKind InnermostKind,\n                            const RegionCodeGenTy &CodeGen) override;\n\n  /// Emits outlined function for the OpenMP task directive \\a D. This\n  /// outlined function has type void(*)(kmp_int32 ThreadID, struct task_t*\n  /// TaskT).\n  /// \\param D OpenMP directive.\n  /// \\param ThreadIDVar Variable for thread id in the current OpenMP region.\n  /// \\param PartIDVar Variable for partition id in the current OpenMP untied\n  /// task region.\n  /// \\param TaskTVar Variable for task_t argument.\n  /// \\param InnermostKind Kind of innermost directive (for simple directives it\n  /// is a directive itself, for combined - its innermost directive).\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// \\param Tied true if task is generated for tied task, false otherwise.\n  /// \\param NumberOfParts Number of parts in untied task. Ignored for tied\n  /// tasks.\n  ///\n  llvm::Function *emitTaskOutlinedFunction(\n      const OMPExecutableDirective &D, const VarDecl *ThreadIDVar,\n      const VarDecl *PartIDVar, const VarDecl *TaskTVar,\n      OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen,\n      bool Tied, unsigned &NumberOfParts) override;\n\n  /// Emits code for parallel or serial call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run in parallel threads. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  ///\n  void emitParallelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                        llvm::Function *OutlinedFn,\n                        ArrayRef<llvm::Value *> CapturedVars,\n                        const Expr *IfCond) override;\n\n  /// Emits a critical region.\n  /// \\param CriticalName Name of the critical region.\n  /// \\param CriticalOpGen Generator for the statement associated with the given\n  /// critical region.\n  /// \\param Hint Value of the 'hint' clause (optional).\n  void emitCriticalRegion(CodeGenFunction &CGF, StringRef CriticalName,\n                          const RegionCodeGenTy &CriticalOpGen,\n                          SourceLocation Loc,\n                          const Expr *Hint = nullptr) override;\n\n  /// Emits a master region.\n  /// \\param MasterOpGen Generator for the statement associated with the given\n  /// master region.\n  void emitMasterRegion(CodeGenFunction &CGF,\n                        const RegionCodeGenTy &MasterOpGen,\n                        SourceLocation Loc) override;\n\n  /// Emits code for a taskyield directive.\n  void emitTaskyieldCall(CodeGenFunction &CGF, SourceLocation Loc) override;\n\n  /// Emit a taskgroup region.\n  /// \\param TaskgroupOpGen Generator for the statement associated with the\n  /// given taskgroup region.\n  void emitTaskgroupRegion(CodeGenFunction &CGF,\n                           const RegionCodeGenTy &TaskgroupOpGen,\n                           SourceLocation Loc) override;\n\n  /// Emits a single region.\n  /// \\param SingleOpGen Generator for the statement associated with the given\n  /// single region.\n  void emitSingleRegion(CodeGenFunction &CGF,\n                        const RegionCodeGenTy &SingleOpGen, SourceLocation Loc,\n                        ArrayRef<const Expr *> CopyprivateVars,\n                        ArrayRef<const Expr *> DestExprs,\n                        ArrayRef<const Expr *> SrcExprs,\n                        ArrayRef<const Expr *> AssignmentOps) override;\n\n  /// Emit an ordered region.\n  /// \\param OrderedOpGen Generator for the statement associated with the given\n  /// ordered region.\n  void emitOrderedRegion(CodeGenFunction &CGF,\n                         const RegionCodeGenTy &OrderedOpGen,\n                         SourceLocation Loc, bool IsThreads) override;\n\n  /// Emit an implicit/explicit barrier for OpenMP threads.\n  /// \\param Kind Directive for which this implicit barrier call must be\n  /// generated. Must be OMPD_barrier for explicit barrier generation.\n  /// \\param EmitChecks true if need to emit checks for cancellation barriers.\n  /// \\param ForceSimpleCall true simple barrier call must be emitted, false if\n  /// runtime class decides which one to emit (simple or with cancellation\n  /// checks).\n  ///\n  void emitBarrierCall(CodeGenFunction &CGF, SourceLocation Loc,\n                       OpenMPDirectiveKind Kind, bool EmitChecks = true,\n                       bool ForceSimpleCall = false) override;\n\n  /// This is used for non static scheduled types and when the ordered\n  /// clause is present on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds \\a LB and \\a UB and stride \\a ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param Ordered true if loop is ordered, false otherwise.\n  /// \\param DispatchValues struct containing llvm values for lower bound, upper\n  /// bound, and chunk expression.\n  /// For the default (nullptr) value, the chunk 1 will be used.\n  ///\n  void emitForDispatchInit(CodeGenFunction &CGF, SourceLocation Loc,\n                           const OpenMPScheduleTy &ScheduleKind,\n                           unsigned IVSize, bool IVSigned, bool Ordered,\n                           const DispatchRTInput &DispatchValues) override;\n\n  /// Call the appropriate runtime routine to initialize it before start\n  /// of loop.\n  ///\n  /// This is used only in case of static schedule, when the user did not\n  /// specify a ordered clause on the loop construct.\n  /// Depending on the loop schedule, it is necessary to call some runtime\n  /// routine before start of the OpenMP loop to get the loop upper / lower\n  /// bounds LB and UB and stride ST.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive.\n  /// \\param ScheduleKind Schedule kind, specified by the 'schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  void emitForStaticInit(CodeGenFunction &CGF, SourceLocation Loc,\n                         OpenMPDirectiveKind DKind,\n                         const OpenMPScheduleTy &ScheduleKind,\n                         const StaticRTInput &Values) override;\n\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param SchedKind Schedule kind, specified by the 'dist_schedule' clause.\n  /// \\param Values Input arguments for the construct.\n  ///\n  void emitDistributeStaticInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                OpenMPDistScheduleClauseKind SchedKind,\n                                const StaticRTInput &Values) override;\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// iteration of the ordered loop with the dynamic scheduling.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  ///\n  void emitForOrderedIterationEnd(CodeGenFunction &CGF, SourceLocation Loc,\n                                  unsigned IVSize, bool IVSigned) override;\n\n  /// Call the appropriate runtime routine to notify that we finished\n  /// all the work with current loop.\n  ///\n  /// \\param CGF Reference to current CodeGenFunction.\n  /// \\param Loc Clang source location.\n  /// \\param DKind Kind of the directive for which the static finish is emitted.\n  ///\n  void emitForStaticFinish(CodeGenFunction &CGF, SourceLocation Loc,\n                           OpenMPDirectiveKind DKind) override;\n\n  /// Call __kmpc_dispatch_next(\n  ///          ident_t *loc, kmp_int32 tid, kmp_int32 *p_lastiter,\n  ///          kmp_int[32|64] *p_lower, kmp_int[32|64] *p_upper,\n  ///          kmp_int[32|64] *p_stride);\n  /// \\param IVSize Size of the iteration variable in bits.\n  /// \\param IVSigned Sign of the iteration variable.\n  /// \\param IL Address of the output variable in which the flag of the\n  /// last iteration is returned.\n  /// \\param LB Address of the output variable in which the lower iteration\n  /// number is returned.\n  /// \\param UB Address of the output variable in which the upper iteration\n  /// number is returned.\n  /// \\param ST Address of the output variable in which the stride value is\n  /// returned.\n  llvm::Value *emitForNext(CodeGenFunction &CGF, SourceLocation Loc,\n                           unsigned IVSize, bool IVSigned, Address IL,\n                           Address LB, Address UB, Address ST) override;\n\n  /// Emits call to void __kmpc_push_num_threads(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_threads) to generate code for 'num_threads'\n  /// clause.\n  /// \\param NumThreads An integer value of threads.\n  void emitNumThreadsClause(CodeGenFunction &CGF, llvm::Value *NumThreads,\n                            SourceLocation Loc) override;\n\n  /// Emit call to void __kmpc_push_proc_bind(ident_t *loc, kmp_int32\n  /// global_tid, int proc_bind) to generate code for 'proc_bind' clause.\n  void emitProcBindClause(CodeGenFunction &CGF,\n                          llvm::omp::ProcBindKind ProcBind,\n                          SourceLocation Loc) override;\n\n  /// Returns address of the threadprivate variable for the current\n  /// thread.\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of the reference to threadprivate var.\n  /// \\return Address of the threadprivate variable for the current thread.\n  Address getAddrOfThreadPrivate(CodeGenFunction &CGF, const VarDecl *VD,\n                                 Address VDAddr, SourceLocation Loc) override;\n\n  /// Emit a code for initialization of threadprivate variable. It emits\n  /// a call to runtime library which adds initial value to the newly created\n  /// threadprivate variable (if it is not constant) and registers destructor\n  /// for the variable (if any).\n  /// \\param VD Threadprivate variable.\n  /// \\param VDAddr Address of the global variable \\a VD.\n  /// \\param Loc Location of threadprivate declaration.\n  /// \\param PerformInit true if initialization expression is not constant.\n  llvm::Function *\n  emitThreadPrivateVarDefinition(const VarDecl *VD, Address VDAddr,\n                                 SourceLocation Loc, bool PerformInit,\n                                 CodeGenFunction *CGF = nullptr) override;\n\n  /// Creates artificial threadprivate variable with name \\p Name and type \\p\n  /// VarType.\n  /// \\param VarType Type of the artificial threadprivate variable.\n  /// \\param Name Name of the artificial threadprivate variable.\n  Address getAddrOfArtificialThreadPrivate(CodeGenFunction &CGF,\n                                           QualType VarType,\n                                           StringRef Name) override;\n\n  /// Emit flush of the variables specified in 'omp flush' directive.\n  /// \\param Vars List of variables to flush.\n  void emitFlush(CodeGenFunction &CGF, ArrayRef<const Expr *> Vars,\n                 SourceLocation Loc, llvm::AtomicOrdering AO) override;\n\n  /// Emit task region for the task directive. The task region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to kmp_int32 __kmpc_omp_task(ident_t *, kmp_int32 gtid,\n  /// kmp_task_t *new_task), where new_task is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  void emitTaskCall(CodeGenFunction &CGF, SourceLocation Loc,\n                    const OMPExecutableDirective &D,\n                    llvm::Function *TaskFunction, QualType SharedsTy,\n                    Address Shareds, const Expr *IfCond,\n                    const OMPTaskDataTy &Data) override;\n\n  /// Emit task region for the taskloop directive. The taskloop region is\n  /// emitted in several steps:\n  /// 1. Emit a call to kmp_task_t *__kmpc_omp_task_alloc(ident_t *, kmp_int32\n  /// gtid, kmp_int32 flags, size_t sizeof_kmp_task_t, size_t sizeof_shareds,\n  /// kmp_routine_entry_t *task_entry). Here task_entry is a pointer to the\n  /// function:\n  /// kmp_int32 .omp_task_entry.(kmp_int32 gtid, kmp_task_t *tt) {\n  ///   TaskFunction(gtid, tt->part_id, tt->shareds);\n  ///   return 0;\n  /// }\n  /// 2. Copy a list of shared variables to field shareds of the resulting\n  /// structure kmp_task_t returned by the previous call (if any).\n  /// 3. Copy a pointer to destructions function to field destructions of the\n  /// resulting structure kmp_task_t.\n  /// 4. Emit a call to void __kmpc_taskloop(ident_t *loc, int gtid, kmp_task_t\n  /// *task, int if_val, kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st, int\n  /// nogroup, int sched, kmp_uint64 grainsize, void *task_dup ), where new_task\n  /// is a resulting structure from\n  /// previous items.\n  /// \\param D Current task directive.\n  /// \\param TaskFunction An LLVM function with type void (*)(i32 /*gtid*/, i32\n  /// /*part_id*/, captured_struct */*__context*/);\n  /// \\param SharedsTy A type which contains references the shared variables.\n  /// \\param Shareds Context with the list of shared variables from the \\p\n  /// TaskFunction.\n  /// \\param IfCond Not a nullptr if 'if' clause was specified, nullptr\n  /// otherwise.\n  /// \\param Data Additional data for task generation like tiednsee, final\n  /// state, list of privates etc.\n  void emitTaskLoopCall(CodeGenFunction &CGF, SourceLocation Loc,\n                        const OMPLoopDirective &D, llvm::Function *TaskFunction,\n                        QualType SharedsTy, Address Shareds, const Expr *IfCond,\n                        const OMPTaskDataTy &Data) override;\n\n  /// Emit a code for reduction clause. Next code should be emitted for\n  /// reduction:\n  /// \\code\n  ///\n  /// static kmp_critical_name lock = { 0 };\n  ///\n  /// void reduce_func(void *lhs[<n>], void *rhs[<n>]) {\n  ///  ...\n  ///  *(Type<i>*)lhs[i] = RedOp<i>(*(Type<i>*)lhs[i], *(Type<i>*)rhs[i]);\n  ///  ...\n  /// }\n  ///\n  /// ...\n  /// void *RedList[<n>] = {&<RHSExprs>[0], ..., &<RHSExprs>[<n>-1]};\n  /// switch (__kmpc_reduce{_nowait}(<loc>, <gtid>, <n>, sizeof(RedList),\n  /// RedList, reduce_func, &<lock>)) {\n  /// case 1:\n  ///  ...\n  ///  <LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]);\n  ///  ...\n  /// __kmpc_end_reduce{_nowait}(<loc>, <gtid>, &<lock>);\n  /// break;\n  /// case 2:\n  ///  ...\n  ///  Atomic(<LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]));\n  ///  ...\n  /// break;\n  /// default:;\n  /// }\n  /// \\endcode\n  ///\n  /// \\param Privates List of private copies for original reduction arguments.\n  /// \\param LHSExprs List of LHS in \\a ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a ReductionOps reduction operations.\n  /// \\param ReductionOps List of reduction operations in form 'LHS binop RHS'\n  /// or 'operator binop(LHS, RHS)'.\n  /// \\param Options List of options for reduction codegen:\n  ///     WithNowait true if parent directive has also nowait clause, false\n  ///     otherwise.\n  ///     SimpleReduction Emit reduction operation only. Used for omp simd\n  ///     directive on the host.\n  ///     ReductionKind The kind of reduction to perform.\n  void emitReduction(CodeGenFunction &CGF, SourceLocation Loc,\n                     ArrayRef<const Expr *> Privates,\n                     ArrayRef<const Expr *> LHSExprs,\n                     ArrayRef<const Expr *> RHSExprs,\n                     ArrayRef<const Expr *> ReductionOps,\n                     ReductionOptionsTy Options) override;\n\n  /// Emit a code for initialization of task reduction clause. Next code\n  /// should be emitted for reduction:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_init(gtid, n, red_data);\n  /// \\endcode\n  /// For reduction clause with task modifier it emits the next call:\n  /// \\code\n  ///\n  /// _taskred_item_t red_data[n];\n  /// ...\n  /// red_data[i].shar = &shareds[i];\n  /// red_data[i].orig = &origs[i];\n  /// red_data[i].size = sizeof(origs[i]);\n  /// red_data[i].f_init = (void*)RedInit<i>;\n  /// red_data[i].f_fini = (void*)RedDest<i>;\n  /// red_data[i].f_comb = (void*)RedOp<i>;\n  /// red_data[i].flags = <Flag_i>;\n  /// ...\n  /// void* tg1 = __kmpc_taskred_modifier_init(loc, gtid, is_worksharing, n,\n  /// red_data);\n  /// \\endcode\n  /// \\param LHSExprs List of LHS in \\a Data.ReductionOps reduction operations.\n  /// \\param RHSExprs List of RHS in \\a Data.ReductionOps reduction operations.\n  /// \\param Data Additional data for task generation like tiedness, final\n  /// state, list of privates, reductions etc.\n  llvm::Value *emitTaskReductionInit(CodeGenFunction &CGF, SourceLocation Loc,\n                                     ArrayRef<const Expr *> LHSExprs,\n                                     ArrayRef<const Expr *> RHSExprs,\n                                     const OMPTaskDataTy &Data) override;\n\n  /// Emits the following code for reduction clause with task modifier:\n  /// \\code\n  /// __kmpc_task_reduction_modifier_fini(loc, gtid, is_worksharing);\n  /// \\endcode\n  void emitTaskReductionFini(CodeGenFunction &CGF, SourceLocation Loc,\n                             bool IsWorksharingReduction) override;\n\n  /// Required to resolve existing problems in the runtime. Emits threadprivate\n  /// variables to store the size of the VLAs/array sections for\n  /// initializer/combiner/finalizer functions + emits threadprivate variable to\n  /// store the pointer to the original reduction item for the custom\n  /// initializer defined by declare reduction construct.\n  /// \\param RCG Allows to reuse an existing data for the reductions.\n  /// \\param N Reduction item for which fixups must be emitted.\n  void emitTaskReductionFixups(CodeGenFunction &CGF, SourceLocation Loc,\n                               ReductionCodeGen &RCG, unsigned N) override;\n\n  /// Get the address of `void *` type of the privatue copy of the reduction\n  /// item specified by the \\p SharedLVal.\n  /// \\param ReductionsPtr Pointer to the reduction data returned by the\n  /// emitTaskReductionInit function.\n  /// \\param SharedLVal Address of the original reduction item.\n  Address getTaskReductionItem(CodeGenFunction &CGF, SourceLocation Loc,\n                               llvm::Value *ReductionsPtr,\n                               LValue SharedLVal) override;\n\n  /// Emit code for 'taskwait' directive.\n  void emitTaskwaitCall(CodeGenFunction &CGF, SourceLocation Loc) override;\n\n  /// Emit code for 'cancellation point' construct.\n  /// \\param CancelRegion Region kind for which the cancellation point must be\n  /// emitted.\n  ///\n  void emitCancellationPointCall(CodeGenFunction &CGF, SourceLocation Loc,\n                                 OpenMPDirectiveKind CancelRegion) override;\n\n  /// Emit code for 'cancel' construct.\n  /// \\param IfCond Condition in the associated 'if' clause, if it was\n  /// specified, nullptr otherwise.\n  /// \\param CancelRegion Region kind for which the cancel must be emitted.\n  ///\n  void emitCancelCall(CodeGenFunction &CGF, SourceLocation Loc,\n                      const Expr *IfCond,\n                      OpenMPDirectiveKind CancelRegion) override;\n\n  /// Emit outilined function for 'target' directive.\n  /// \\param D Directive to emit.\n  /// \\param ParentName Name of the function that encloses the target region.\n  /// \\param OutlinedFn Outlined function value to be defined by this call.\n  /// \\param OutlinedFnID Outlined function ID value to be defined by this call.\n  /// \\param IsOffloadEntry True if the outlined function is an offload entry.\n  /// \\param CodeGen Code generation sequence for the \\a D directive.\n  /// An outlined function may not be an entry if, e.g. the if clause always\n  /// evaluates to false.\n  void emitTargetOutlinedFunction(const OMPExecutableDirective &D,\n                                  StringRef ParentName,\n                                  llvm::Function *&OutlinedFn,\n                                  llvm::Constant *&OutlinedFnID,\n                                  bool IsOffloadEntry,\n                                  const RegionCodeGenTy &CodeGen) override;\n\n  /// Emit the target offloading code associated with \\a D. The emitted\n  /// code attempts offloading the execution to the device, an the event of\n  /// a failure it executes the host version outlined in \\a OutlinedFn.\n  /// \\param D Directive to emit.\n  /// \\param OutlinedFn Host version of the code to be offloaded.\n  /// \\param OutlinedFnID ID of host version of the code to be offloaded.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used and device modifier.\n  void emitTargetCall(\n      CodeGenFunction &CGF, const OMPExecutableDirective &D,\n      llvm::Function *OutlinedFn, llvm::Value *OutlinedFnID, const Expr *IfCond,\n      llvm::PointerIntPair<const Expr *, 2, OpenMPDeviceClauseModifier> Device,\n      llvm::function_ref<llvm::Value *(CodeGenFunction &CGF,\n                                       const OMPLoopDirective &D)>\n          SizeEmitter) override;\n\n  /// Emit the target regions enclosed in \\a GD function definition or\n  /// the function itself in case it is a valid device function. Returns true if\n  /// \\a GD was dealt with successfully.\n  /// \\param GD Function to scan.\n  bool emitTargetFunctions(GlobalDecl GD) override;\n\n  /// Emit the global variable if it is a valid device global variable.\n  /// Returns true if \\a GD was dealt with successfully.\n  /// \\param GD Variable declaration to emit.\n  bool emitTargetGlobalVariable(GlobalDecl GD) override;\n\n  /// Emit the global \\a GD if it is meaningful for the target. Returns\n  /// if it was emitted successfully.\n  /// \\param GD Global to scan.\n  bool emitTargetGlobal(GlobalDecl GD) override;\n\n  /// Emits code for teams call of the \\a OutlinedFn with\n  /// variables captured in a record which address is stored in \\a\n  /// CapturedStruct.\n  /// \\param OutlinedFn Outlined function to be run by team masters. Type of\n  /// this function is void(*)(kmp_int32 *, kmp_int32, struct context_vars*).\n  /// \\param CapturedVars A pointer to the record with the references to\n  /// variables used in \\a OutlinedFn function.\n  ///\n  void emitTeamsCall(CodeGenFunction &CGF, const OMPExecutableDirective &D,\n                     SourceLocation Loc, llvm::Function *OutlinedFn,\n                     ArrayRef<llvm::Value *> CapturedVars) override;\n\n  /// Emits call to void __kmpc_push_num_teams(ident_t *loc, kmp_int32\n  /// global_tid, kmp_int32 num_teams, kmp_int32 thread_limit) to generate code\n  /// for num_teams clause.\n  /// \\param NumTeams An integer expression of teams.\n  /// \\param ThreadLimit An integer expression of threads.\n  void emitNumTeamsClause(CodeGenFunction &CGF, const Expr *NumTeams,\n                          const Expr *ThreadLimit, SourceLocation Loc) override;\n\n  /// Emit the target data mapping code associated with \\a D.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  /// \\param Info A record used to store information that needs to be preserved\n  /// until the region is closed.\n  void emitTargetDataCalls(CodeGenFunction &CGF,\n                           const OMPExecutableDirective &D, const Expr *IfCond,\n                           const Expr *Device, const RegionCodeGenTy &CodeGen,\n                           TargetDataInfo &Info) override;\n\n  /// Emit the data mapping/movement code associated with the directive\n  /// \\a D that should be of the form 'target [{enter|exit} data | update]'.\n  /// \\param D Directive to emit.\n  /// \\param IfCond Expression evaluated in if clause associated with the target\n  /// directive, or null if no if clause is used.\n  /// \\param Device Expression evaluated in device clause associated with the\n  /// target directive, or null if no device clause is used.\n  void emitTargetDataStandAloneCall(CodeGenFunction &CGF,\n                                    const OMPExecutableDirective &D,\n                                    const Expr *IfCond,\n                                    const Expr *Device) override;\n\n  /// Emit initialization for doacross loop nesting support.\n  /// \\param D Loop-based construct used in doacross nesting construct.\n  void emitDoacrossInit(CodeGenFunction &CGF, const OMPLoopDirective &D,\n                        ArrayRef<Expr *> NumIterations) override;\n\n  /// Emit code for doacross ordered directive with 'depend' clause.\n  /// \\param C 'depend' clause with 'sink|source' dependency kind.\n  void emitDoacrossOrdered(CodeGenFunction &CGF,\n                           const OMPDependClause *C) override;\n\n  /// Translates the native parameter of outlined function if this is required\n  /// for target.\n  /// \\param FD Field decl from captured record for the parameter.\n  /// \\param NativeParam Parameter itself.\n  const VarDecl *translateParameter(const FieldDecl *FD,\n                                    const VarDecl *NativeParam) const override;\n\n  /// Gets the address of the native argument basing on the address of the\n  /// target-specific parameter.\n  /// \\param NativeParam Parameter itself.\n  /// \\param TargetParam Corresponding target-specific parameter.\n  Address getParameterAddress(CodeGenFunction &CGF, const VarDecl *NativeParam,\n                              const VarDecl *TargetParam) const override;\n\n  /// Gets the OpenMP-specific address of the local variable.\n  Address getAddressOfLocalVariable(CodeGenFunction &CGF,\n                                    const VarDecl *VD) override {\n    return Address::invalid();\n  }\n};\n\n} // namespace CodeGen\n} // namespace clang\n\n#endif\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "content": "//===--- CGStmtOpenMP.cpp - Emit LLVM Code from Statements ----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This contains code to emit OpenMP nodes as LLVM code.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CGCleanup.h\"\n#include \"CGOpenMPRuntime.h\"\n#include \"CodeGenFunction.h\"\n#include \"CodeGenModule.h\"\n#include \"TargetInfo.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/PrettyStackTrace.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include \"llvm/Frontend/OpenMP/OMPIRBuilder.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\nusing namespace clang;\nusing namespace CodeGen;\nusing namespace llvm::omp;\n\nstatic const VarDecl *getBaseDecl(const Expr *Ref);\n\nnamespace {\n/// Lexical scope for OpenMP executable constructs, that handles correct codegen\n/// for captured expressions.\nclass OMPLexicalScope : public CodeGenFunction::LexicalScope {\n  void emitPreInitStmt(CodeGenFunction &CGF, const OMPExecutableDirective &S) {\n    for (const auto *C : S.clauses()) {\n      if (const auto *CPI = OMPClauseWithPreInit::get(C)) {\n        if (const auto *PreInit =\n                cast_or_null<DeclStmt>(CPI->getPreInitStmt())) {\n          for (const auto *I : PreInit->decls()) {\n            if (!I->hasAttr<OMPCaptureNoInitAttr>()) {\n              CGF.EmitVarDecl(cast<VarDecl>(*I));\n            } else {\n              CodeGenFunction::AutoVarEmission Emission =\n                  CGF.EmitAutoVarAlloca(cast<VarDecl>(*I));\n              CGF.EmitAutoVarCleanups(Emission);\n            }\n          }\n        }\n      }\n    }\n  }\n  CodeGenFunction::OMPPrivateScope InlinedShareds;\n\n  static bool isCapturedVar(CodeGenFunction &CGF, const VarDecl *VD) {\n    return CGF.LambdaCaptureFields.lookup(VD) ||\n           (CGF.CapturedStmtInfo && CGF.CapturedStmtInfo->lookup(VD)) ||\n           (CGF.CurCodeDecl && isa<BlockDecl>(CGF.CurCodeDecl) &&\n            cast<BlockDecl>(CGF.CurCodeDecl)->capturesVariable(VD));\n  }\n\npublic:\n  OMPLexicalScope(\n      CodeGenFunction &CGF, const OMPExecutableDirective &S,\n      const llvm::Optional<OpenMPDirectiveKind> CapturedRegion = llvm::None,\n      const bool EmitPreInitStmt = true)\n      : CodeGenFunction::LexicalScope(CGF, S.getSourceRange()),\n        InlinedShareds(CGF) {\n    if (EmitPreInitStmt)\n      emitPreInitStmt(CGF, S);\n    if (!CapturedRegion.hasValue())\n      return;\n    assert(S.hasAssociatedStmt() &&\n           \"Expected associated statement for inlined directive.\");\n    const CapturedStmt *CS = S.getCapturedStmt(*CapturedRegion);\n    for (const auto &C : CS->captures()) {\n      if (C.capturesVariable() || C.capturesVariableByCopy()) {\n        auto *VD = C.getCapturedVar();\n        assert(VD == VD->getCanonicalDecl() &&\n               \"Canonical decl must be captured.\");\n        DeclRefExpr DRE(\n            CGF.getContext(), const_cast<VarDecl *>(VD),\n            isCapturedVar(CGF, VD) || (CGF.CapturedStmtInfo &&\n                                       InlinedShareds.isGlobalVarCaptured(VD)),\n            VD->getType().getNonReferenceType(), VK_LValue, C.getLocation());\n        InlinedShareds.addPrivate(VD, [&CGF, &DRE]() -> Address {\n          return CGF.EmitLValue(&DRE).getAddress(CGF);\n        });\n      }\n    }\n    (void)InlinedShareds.Privatize();\n  }\n};\n\n/// Lexical scope for OpenMP parallel construct, that handles correct codegen\n/// for captured expressions.\nclass OMPParallelScope final : public OMPLexicalScope {\n  bool EmitPreInitStmt(const OMPExecutableDirective &S) {\n    OpenMPDirectiveKind Kind = S.getDirectiveKind();\n    return !(isOpenMPTargetExecutionDirective(Kind) ||\n             isOpenMPLoopBoundSharingDirective(Kind)) &&\n           isOpenMPParallelDirective(Kind);\n  }\n\npublic:\n  OMPParallelScope(CodeGenFunction &CGF, const OMPExecutableDirective &S)\n      : OMPLexicalScope(CGF, S, /*CapturedRegion=*/llvm::None,\n                        EmitPreInitStmt(S)) {}\n};\n\n/// Lexical scope for OpenMP teams construct, that handles correct codegen\n/// for captured expressions.\nclass OMPTeamsScope final : public OMPLexicalScope {\n  bool EmitPreInitStmt(const OMPExecutableDirective &S) {\n    OpenMPDirectiveKind Kind = S.getDirectiveKind();\n    return !isOpenMPTargetExecutionDirective(Kind) &&\n           isOpenMPTeamsDirective(Kind);\n  }\n\npublic:\n  OMPTeamsScope(CodeGenFunction &CGF, const OMPExecutableDirective &S)\n      : OMPLexicalScope(CGF, S, /*CapturedRegion=*/llvm::None,\n                        EmitPreInitStmt(S)) {}\n};\n\n/// Private scope for OpenMP loop-based directives, that supports capturing\n/// of used expression from loop statement.\nclass OMPLoopScope : public CodeGenFunction::RunCleanupsScope {\n  void emitPreInitStmt(CodeGenFunction &CGF, const OMPLoopBasedDirective &S) {\n    const DeclStmt *PreInits;\n    CodeGenFunction::OMPMapVars PreCondVars;\n    if (auto *LD = dyn_cast<OMPLoopDirective>(&S)) {\n      llvm::DenseSet<const VarDecl *> EmittedAsPrivate;\n      for (const auto *E : LD->counters()) {\n        const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n        EmittedAsPrivate.insert(VD->getCanonicalDecl());\n        (void)PreCondVars.setVarAddr(\n            CGF, VD, CGF.CreateMemTemp(VD->getType().getNonReferenceType()));\n      }\n      // Mark private vars as undefs.\n      for (const auto *C : LD->getClausesOfKind<OMPPrivateClause>()) {\n        for (const Expr *IRef : C->varlists()) {\n          const auto *OrigVD =\n              cast<VarDecl>(cast<DeclRefExpr>(IRef)->getDecl());\n          if (EmittedAsPrivate.insert(OrigVD->getCanonicalDecl()).second) {\n            (void)PreCondVars.setVarAddr(\n                CGF, OrigVD,\n                Address(llvm::UndefValue::get(CGF.ConvertTypeForMem(\n                            CGF.getContext().getPointerType(\n                                OrigVD->getType().getNonReferenceType()))),\n                        CGF.getContext().getDeclAlign(OrigVD)));\n          }\n        }\n      }\n      (void)PreCondVars.apply(CGF);\n      // Emit init, __range and __end variables for C++ range loops.\n      (void)OMPLoopBasedDirective::doForAllLoops(\n          LD->getInnermostCapturedStmt()->getCapturedStmt(),\n          /*TryImperfectlyNestedLoops=*/true, LD->getLoopsNumber(),\n          [&CGF](unsigned Cnt, const Stmt *CurStmt) {\n            if (const auto *CXXFor = dyn_cast<CXXForRangeStmt>(CurStmt)) {\n              if (const Stmt *Init = CXXFor->getInit())\n                CGF.EmitStmt(Init);\n              CGF.EmitStmt(CXXFor->getRangeStmt());\n              CGF.EmitStmt(CXXFor->getEndStmt());\n            }\n            return false;\n          });\n      PreInits = cast_or_null<DeclStmt>(LD->getPreInits());\n    } else if (const auto *Tile = dyn_cast<OMPTileDirective>(&S)) {\n      PreInits = cast_or_null<DeclStmt>(Tile->getPreInits());\n    } else {\n      llvm_unreachable(\"Unknown loop-based directive kind.\");\n    }\n    if (PreInits) {\n      for (const auto *I : PreInits->decls())\n        CGF.EmitVarDecl(cast<VarDecl>(*I));\n    }\n    PreCondVars.restore(CGF);\n  }\n\npublic:\n  OMPLoopScope(CodeGenFunction &CGF, const OMPLoopBasedDirective &S)\n      : CodeGenFunction::RunCleanupsScope(CGF) {\n    emitPreInitStmt(CGF, S);\n  }\n};\n\nclass OMPSimdLexicalScope : public CodeGenFunction::LexicalScope {\n  CodeGenFunction::OMPPrivateScope InlinedShareds;\n\n  static bool isCapturedVar(CodeGenFunction &CGF, const VarDecl *VD) {\n    return CGF.LambdaCaptureFields.lookup(VD) ||\n           (CGF.CapturedStmtInfo && CGF.CapturedStmtInfo->lookup(VD)) ||\n           (CGF.CurCodeDecl && isa<BlockDecl>(CGF.CurCodeDecl) &&\n            cast<BlockDecl>(CGF.CurCodeDecl)->capturesVariable(VD));\n  }\n\npublic:\n  OMPSimdLexicalScope(CodeGenFunction &CGF, const OMPExecutableDirective &S)\n      : CodeGenFunction::LexicalScope(CGF, S.getSourceRange()),\n        InlinedShareds(CGF) {\n    for (const auto *C : S.clauses()) {\n      if (const auto *CPI = OMPClauseWithPreInit::get(C)) {\n        if (const auto *PreInit =\n                cast_or_null<DeclStmt>(CPI->getPreInitStmt())) {\n          for (const auto *I : PreInit->decls()) {\n            if (!I->hasAttr<OMPCaptureNoInitAttr>()) {\n              CGF.EmitVarDecl(cast<VarDecl>(*I));\n            } else {\n              CodeGenFunction::AutoVarEmission Emission =\n                  CGF.EmitAutoVarAlloca(cast<VarDecl>(*I));\n              CGF.EmitAutoVarCleanups(Emission);\n            }\n          }\n        }\n      } else if (const auto *UDP = dyn_cast<OMPUseDevicePtrClause>(C)) {\n        for (const Expr *E : UDP->varlists()) {\n          const Decl *D = cast<DeclRefExpr>(E)->getDecl();\n          if (const auto *OED = dyn_cast<OMPCapturedExprDecl>(D))\n            CGF.EmitVarDecl(*OED);\n        }\n      } else if (const auto *UDP = dyn_cast<OMPUseDeviceAddrClause>(C)) {\n        for (const Expr *E : UDP->varlists()) {\n          const Decl *D = getBaseDecl(E);\n          if (const auto *OED = dyn_cast<OMPCapturedExprDecl>(D))\n            CGF.EmitVarDecl(*OED);\n        }\n      }\n    }\n    if (!isOpenMPSimdDirective(S.getDirectiveKind()))\n      CGF.EmitOMPPrivateClause(S, InlinedShareds);\n    if (const auto *TG = dyn_cast<OMPTaskgroupDirective>(&S)) {\n      if (const Expr *E = TG->getReductionRef())\n        CGF.EmitVarDecl(*cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl()));\n    }\n    const auto *CS = cast_or_null<CapturedStmt>(S.getAssociatedStmt());\n    while (CS) {\n      for (auto &C : CS->captures()) {\n        if (C.capturesVariable() || C.capturesVariableByCopy()) {\n          auto *VD = C.getCapturedVar();\n          assert(VD == VD->getCanonicalDecl() &&\n                 \"Canonical decl must be captured.\");\n          DeclRefExpr DRE(CGF.getContext(), const_cast<VarDecl *>(VD),\n                          isCapturedVar(CGF, VD) ||\n                              (CGF.CapturedStmtInfo &&\n                               InlinedShareds.isGlobalVarCaptured(VD)),\n                          VD->getType().getNonReferenceType(), VK_LValue,\n                          C.getLocation());\n          InlinedShareds.addPrivate(VD, [&CGF, &DRE]() -> Address {\n            return CGF.EmitLValue(&DRE).getAddress(CGF);\n          });\n        }\n      }\n      CS = dyn_cast<CapturedStmt>(CS->getCapturedStmt());\n    }\n    (void)InlinedShareds.Privatize();\n  }\n};\n\n} // namespace\n\nstatic void emitCommonOMPTargetDirective(CodeGenFunction &CGF,\n                                         const OMPExecutableDirective &S,\n                                         const RegionCodeGenTy &CodeGen);\n\nLValue CodeGenFunction::EmitOMPSharedLValue(const Expr *E) {\n  if (const auto *OrigDRE = dyn_cast<DeclRefExpr>(E)) {\n    if (const auto *OrigVD = dyn_cast<VarDecl>(OrigDRE->getDecl())) {\n      OrigVD = OrigVD->getCanonicalDecl();\n      bool IsCaptured =\n          LambdaCaptureFields.lookup(OrigVD) ||\n          (CapturedStmtInfo && CapturedStmtInfo->lookup(OrigVD)) ||\n          (CurCodeDecl && isa<BlockDecl>(CurCodeDecl));\n      DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(OrigVD), IsCaptured,\n                      OrigDRE->getType(), VK_LValue, OrigDRE->getExprLoc());\n      return EmitLValue(&DRE);\n    }\n  }\n  return EmitLValue(E);\n}\n\nllvm::Value *CodeGenFunction::getTypeSize(QualType Ty) {\n  ASTContext &C = getContext();\n  llvm::Value *Size = nullptr;\n  auto SizeInChars = C.getTypeSizeInChars(Ty);\n  if (SizeInChars.isZero()) {\n    // getTypeSizeInChars() returns 0 for a VLA.\n    while (const VariableArrayType *VAT = C.getAsVariableArrayType(Ty)) {\n      VlaSizePair VlaSize = getVLASize(VAT);\n      Ty = VlaSize.Type;\n      Size = Size ? Builder.CreateNUWMul(Size, VlaSize.NumElts)\n                  : VlaSize.NumElts;\n    }\n    SizeInChars = C.getTypeSizeInChars(Ty);\n    if (SizeInChars.isZero())\n      return llvm::ConstantInt::get(SizeTy, /*V=*/0);\n    return Builder.CreateNUWMul(Size, CGM.getSize(SizeInChars));\n  }\n  return CGM.getSize(SizeInChars);\n}\n\nvoid CodeGenFunction::GenerateOpenMPCapturedVars(\n    const CapturedStmt &S, SmallVectorImpl<llvm::Value *> &CapturedVars) {\n  const RecordDecl *RD = S.getCapturedRecordDecl();\n  auto CurField = RD->field_begin();\n  auto CurCap = S.captures().begin();\n  for (CapturedStmt::const_capture_init_iterator I = S.capture_init_begin(),\n                                                 E = S.capture_init_end();\n       I != E; ++I, ++CurField, ++CurCap) {\n    if (CurField->hasCapturedVLAType()) {\n      const VariableArrayType *VAT = CurField->getCapturedVLAType();\n      llvm::Value *Val = VLASizeMap[VAT->getSizeExpr()];\n      CapturedVars.push_back(Val);\n    } else if (CurCap->capturesThis()) {\n      CapturedVars.push_back(CXXThisValue);\n    } else if (CurCap->capturesVariableByCopy()) {\n      llvm::Value *CV = EmitLoadOfScalar(EmitLValue(*I), CurCap->getLocation());\n\n      // If the field is not a pointer, we need to save the actual value\n      // and load it as a void pointer.\n      if (!CurField->getType()->isAnyPointerType()) {\n        ASTContext &Ctx = getContext();\n        Address DstAddr = CreateMemTemp(\n            Ctx.getUIntPtrType(),\n            Twine(CurCap->getCapturedVar()->getName(), \".casted\"));\n        LValue DstLV = MakeAddrLValue(DstAddr, Ctx.getUIntPtrType());\n\n        llvm::Value *SrcAddrVal = EmitScalarConversion(\n            DstAddr.getPointer(), Ctx.getPointerType(Ctx.getUIntPtrType()),\n            Ctx.getPointerType(CurField->getType()), CurCap->getLocation());\n        LValue SrcLV =\n            MakeNaturalAlignAddrLValue(SrcAddrVal, CurField->getType());\n\n        // Store the value using the source type pointer.\n        EmitStoreThroughLValue(RValue::get(CV), SrcLV);\n\n        // Load the value using the destination type pointer.\n        CV = EmitLoadOfScalar(DstLV, CurCap->getLocation());\n      }\n      CapturedVars.push_back(CV);\n    } else {\n      assert(CurCap->capturesVariable() && \"Expected capture by reference.\");\n      CapturedVars.push_back(EmitLValue(*I).getAddress(*this).getPointer());\n    }\n  }\n}\n\nstatic Address castValueFromUintptr(CodeGenFunction &CGF, SourceLocation Loc,\n                                    QualType DstType, StringRef Name,\n                                    LValue AddrLV) {\n  ASTContext &Ctx = CGF.getContext();\n\n  llvm::Value *CastedPtr = CGF.EmitScalarConversion(\n      AddrLV.getAddress(CGF).getPointer(), Ctx.getUIntPtrType(),\n      Ctx.getPointerType(DstType), Loc);\n  Address TmpAddr =\n      CGF.MakeNaturalAlignAddrLValue(CastedPtr, Ctx.getPointerType(DstType))\n          .getAddress(CGF);\n  return TmpAddr;\n}\n\nstatic QualType getCanonicalParamType(ASTContext &C, QualType T) {\n  if (T->isLValueReferenceType())\n    return C.getLValueReferenceType(\n        getCanonicalParamType(C, T.getNonReferenceType()),\n        /*SpelledAsLValue=*/false);\n  if (T->isPointerType())\n    return C.getPointerType(getCanonicalParamType(C, T->getPointeeType()));\n  if (const ArrayType *A = T->getAsArrayTypeUnsafe()) {\n    if (const auto *VLA = dyn_cast<VariableArrayType>(A))\n      return getCanonicalParamType(C, VLA->getElementType());\n    if (!A->isVariablyModifiedType())\n      return C.getCanonicalType(T);\n  }\n  return C.getCanonicalParamType(T);\n}\n\nnamespace {\n/// Contains required data for proper outlined function codegen.\nstruct FunctionOptions {\n  /// Captured statement for which the function is generated.\n  const CapturedStmt *S = nullptr;\n  /// true if cast to/from  UIntPtr is required for variables captured by\n  /// value.\n  const bool UIntPtrCastRequired = true;\n  /// true if only casted arguments must be registered as local args or VLA\n  /// sizes.\n  const bool RegisterCastedArgsOnly = false;\n  /// Name of the generated function.\n  const StringRef FunctionName;\n  /// Location of the non-debug version of the outlined function.\n  SourceLocation Loc;\n  explicit FunctionOptions(const CapturedStmt *S, bool UIntPtrCastRequired,\n                           bool RegisterCastedArgsOnly, StringRef FunctionName,\n                           SourceLocation Loc)\n      : S(S), UIntPtrCastRequired(UIntPtrCastRequired),\n        RegisterCastedArgsOnly(UIntPtrCastRequired && RegisterCastedArgsOnly),\n        FunctionName(FunctionName), Loc(Loc) {}\n};\n} // namespace\n\nstatic llvm::Function *emitOutlinedFunctionPrologue(\n    CodeGenFunction &CGF, FunctionArgList &Args,\n    llvm::MapVector<const Decl *, std::pair<const VarDecl *, Address>>\n        &LocalAddrs,\n    llvm::DenseMap<const Decl *, std::pair<const Expr *, llvm::Value *>>\n        &VLASizes,\n    llvm::Value *&CXXThisValue, const FunctionOptions &FO) {\n  const CapturedDecl *CD = FO.S->getCapturedDecl();\n  const RecordDecl *RD = FO.S->getCapturedRecordDecl();\n  assert(CD->hasBody() && \"missing CapturedDecl body\");\n\n  CXXThisValue = nullptr;\n  // Build the argument list.\n  CodeGenModule &CGM = CGF.CGM;\n  ASTContext &Ctx = CGM.getContext();\n  FunctionArgList TargetArgs;\n  Args.append(CD->param_begin(),\n              std::next(CD->param_begin(), CD->getContextParamPosition()));\n  TargetArgs.append(\n      CD->param_begin(),\n      std::next(CD->param_begin(), CD->getContextParamPosition()));\n  auto I = FO.S->captures().begin();\n  FunctionDecl *DebugFunctionDecl = nullptr;\n  if (!FO.UIntPtrCastRequired) {\n    FunctionProtoType::ExtProtoInfo EPI;\n    QualType FunctionTy = Ctx.getFunctionType(Ctx.VoidTy, llvm::None, EPI);\n    DebugFunctionDecl = FunctionDecl::Create(\n        Ctx, Ctx.getTranslationUnitDecl(), FO.S->getBeginLoc(),\n        SourceLocation(), DeclarationName(), FunctionTy,\n        Ctx.getTrivialTypeSourceInfo(FunctionTy), SC_Static,\n        /*isInlineSpecified=*/false, /*hasWrittenPrototype=*/false);\n  }\n  for (const FieldDecl *FD : RD->fields()) {\n    QualType ArgType = FD->getType();\n    IdentifierInfo *II = nullptr;\n    VarDecl *CapVar = nullptr;\n\n    // If this is a capture by copy and the type is not a pointer, the outlined\n    // function argument type should be uintptr and the value properly casted to\n    // uintptr. This is necessary given that the runtime library is only able to\n    // deal with pointers. We can pass in the same way the VLA type sizes to the\n    // outlined function.\n    if (FO.UIntPtrCastRequired &&\n        ((I->capturesVariableByCopy() && !ArgType->isAnyPointerType()) ||\n         I->capturesVariableArrayType()))\n      ArgType = Ctx.getUIntPtrType();\n\n    if (I->capturesVariable() || I->capturesVariableByCopy()) {\n      CapVar = I->getCapturedVar();\n      II = CapVar->getIdentifier();\n    } else if (I->capturesThis()) {\n      II = &Ctx.Idents.get(\"this\");\n    } else {\n      assert(I->capturesVariableArrayType());\n      II = &Ctx.Idents.get(\"vla\");\n    }\n    if (ArgType->isVariablyModifiedType())\n      ArgType = getCanonicalParamType(Ctx, ArgType);\n    VarDecl *Arg;\n    if (DebugFunctionDecl && (CapVar || I->capturesThis())) {\n      Arg = ParmVarDecl::Create(\n          Ctx, DebugFunctionDecl,\n          CapVar ? CapVar->getBeginLoc() : FD->getBeginLoc(),\n          CapVar ? CapVar->getLocation() : FD->getLocation(), II, ArgType,\n          /*TInfo=*/nullptr, SC_None, /*DefArg=*/nullptr);\n    } else {\n      Arg = ImplicitParamDecl::Create(Ctx, /*DC=*/nullptr, FD->getLocation(),\n                                      II, ArgType, ImplicitParamDecl::Other);\n    }\n    Args.emplace_back(Arg);\n    // Do not cast arguments if we emit function with non-original types.\n    TargetArgs.emplace_back(\n        FO.UIntPtrCastRequired\n            ? Arg\n            : CGM.getOpenMPRuntime().translateParameter(FD, Arg));\n    ++I;\n  }\n  Args.append(\n      std::next(CD->param_begin(), CD->getContextParamPosition() + 1),\n      CD->param_end());\n  TargetArgs.append(\n      std::next(CD->param_begin(), CD->getContextParamPosition() + 1),\n      CD->param_end());\n\n  // Create the function declaration.\n  const CGFunctionInfo &FuncInfo =\n      CGM.getTypes().arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, TargetArgs);\n  llvm::FunctionType *FuncLLVMTy = CGM.getTypes().GetFunctionType(FuncInfo);\n\n  auto *F =\n      llvm::Function::Create(FuncLLVMTy, llvm::GlobalValue::InternalLinkage,\n                             FO.FunctionName, &CGM.getModule());\n  CGM.SetInternalFunctionAttributes(CD, F, FuncInfo);\n  if (CD->isNothrow())\n    F->setDoesNotThrow();\n  F->setDoesNotRecurse();\n\n  // Generate the function.\n  CGF.StartFunction(CD, Ctx.VoidTy, F, FuncInfo, TargetArgs,\n                    FO.UIntPtrCastRequired ? FO.Loc : FO.S->getBeginLoc(),\n                    FO.UIntPtrCastRequired ? FO.Loc\n                                           : CD->getBody()->getBeginLoc());\n  unsigned Cnt = CD->getContextParamPosition();\n  I = FO.S->captures().begin();\n  for (const FieldDecl *FD : RD->fields()) {\n    // Do not map arguments if we emit function with non-original types.\n    Address LocalAddr(Address::invalid());\n    if (!FO.UIntPtrCastRequired && Args[Cnt] != TargetArgs[Cnt]) {\n      LocalAddr = CGM.getOpenMPRuntime().getParameterAddress(CGF, Args[Cnt],\n                                                             TargetArgs[Cnt]);\n    } else {\n      LocalAddr = CGF.GetAddrOfLocalVar(Args[Cnt]);\n    }\n    // If we are capturing a pointer by copy we don't need to do anything, just\n    // use the value that we get from the arguments.\n    if (I->capturesVariableByCopy() && FD->getType()->isAnyPointerType()) {\n      const VarDecl *CurVD = I->getCapturedVar();\n      if (!FO.RegisterCastedArgsOnly)\n        LocalAddrs.insert({Args[Cnt], {CurVD, LocalAddr}});\n      ++Cnt;\n      ++I;\n      continue;\n    }\n\n    LValue ArgLVal = CGF.MakeAddrLValue(LocalAddr, Args[Cnt]->getType(),\n                                        AlignmentSource::Decl);\n    if (FD->hasCapturedVLAType()) {\n      if (FO.UIntPtrCastRequired) {\n        ArgLVal = CGF.MakeAddrLValue(\n            castValueFromUintptr(CGF, I->getLocation(), FD->getType(),\n                                 Args[Cnt]->getName(), ArgLVal),\n            FD->getType(), AlignmentSource::Decl);\n      }\n      llvm::Value *ExprArg = CGF.EmitLoadOfScalar(ArgLVal, I->getLocation());\n      const VariableArrayType *VAT = FD->getCapturedVLAType();\n      VLASizes.try_emplace(Args[Cnt], VAT->getSizeExpr(), ExprArg);\n    } else if (I->capturesVariable()) {\n      const VarDecl *Var = I->getCapturedVar();\n      QualType VarTy = Var->getType();\n      Address ArgAddr = ArgLVal.getAddress(CGF);\n      if (ArgLVal.getType()->isLValueReferenceType()) {\n        ArgAddr = CGF.EmitLoadOfReference(ArgLVal);\n      } else if (!VarTy->isVariablyModifiedType() || !VarTy->isPointerType()) {\n        assert(ArgLVal.getType()->isPointerType());\n        ArgAddr = CGF.EmitLoadOfPointer(\n            ArgAddr, ArgLVal.getType()->castAs<PointerType>());\n      }\n      if (!FO.RegisterCastedArgsOnly) {\n        LocalAddrs.insert(\n            {Args[Cnt],\n             {Var, Address(ArgAddr.getPointer(), Ctx.getDeclAlign(Var))}});\n      }\n    } else if (I->capturesVariableByCopy()) {\n      assert(!FD->getType()->isAnyPointerType() &&\n             \"Not expecting a captured pointer.\");\n      const VarDecl *Var = I->getCapturedVar();\n      LocalAddrs.insert({Args[Cnt],\n                         {Var, FO.UIntPtrCastRequired\n                                   ? castValueFromUintptr(\n                                         CGF, I->getLocation(), FD->getType(),\n                                         Args[Cnt]->getName(), ArgLVal)\n                                   : ArgLVal.getAddress(CGF)}});\n    } else {\n      // If 'this' is captured, load it into CXXThisValue.\n      assert(I->capturesThis());\n      CXXThisValue = CGF.EmitLoadOfScalar(ArgLVal, I->getLocation());\n      LocalAddrs.insert({Args[Cnt], {nullptr, ArgLVal.getAddress(CGF)}});\n    }\n    ++Cnt;\n    ++I;\n  }\n\n  return F;\n}\n\nllvm::Function *\nCodeGenFunction::GenerateOpenMPCapturedStmtFunction(const CapturedStmt &S,\n                                                    SourceLocation Loc) {\n  assert(\n      CapturedStmtInfo &&\n      \"CapturedStmtInfo should be set when generating the captured function\");\n  const CapturedDecl *CD = S.getCapturedDecl();\n  // Build the argument list.\n  bool NeedWrapperFunction =\n      getDebugInfo() && CGM.getCodeGenOpts().hasReducedDebugInfo();\n  FunctionArgList Args;\n  llvm::MapVector<const Decl *, std::pair<const VarDecl *, Address>> LocalAddrs;\n  llvm::DenseMap<const Decl *, std::pair<const Expr *, llvm::Value *>> VLASizes;\n  SmallString<256> Buffer;\n  llvm::raw_svector_ostream Out(Buffer);\n  Out << CapturedStmtInfo->getHelperName();\n  if (NeedWrapperFunction)\n    Out << \"_debug__\";\n  FunctionOptions FO(&S, !NeedWrapperFunction, /*RegisterCastedArgsOnly=*/false,\n                     Out.str(), Loc);\n  llvm::Function *F = emitOutlinedFunctionPrologue(*this, Args, LocalAddrs,\n                                                   VLASizes, CXXThisValue, FO);\n  CodeGenFunction::OMPPrivateScope LocalScope(*this);\n  for (const auto &LocalAddrPair : LocalAddrs) {\n    if (LocalAddrPair.second.first) {\n      LocalScope.addPrivate(LocalAddrPair.second.first, [&LocalAddrPair]() {\n        return LocalAddrPair.second.second;\n      });\n    }\n  }\n  (void)LocalScope.Privatize();\n  for (const auto &VLASizePair : VLASizes)\n    VLASizeMap[VLASizePair.second.first] = VLASizePair.second.second;\n  PGO.assignRegionCounters(GlobalDecl(CD), F);\n  CapturedStmtInfo->EmitBody(*this, CD->getBody());\n  (void)LocalScope.ForceCleanup();\n  FinishFunction(CD->getBodyRBrace());\n  if (!NeedWrapperFunction)\n    return F;\n\n  FunctionOptions WrapperFO(&S, /*UIntPtrCastRequired=*/true,\n                            /*RegisterCastedArgsOnly=*/true,\n                            CapturedStmtInfo->getHelperName(), Loc);\n  CodeGenFunction WrapperCGF(CGM, /*suppressNewContext=*/true);\n  WrapperCGF.CapturedStmtInfo = CapturedStmtInfo;\n  Args.clear();\n  LocalAddrs.clear();\n  VLASizes.clear();\n  llvm::Function *WrapperF =\n      emitOutlinedFunctionPrologue(WrapperCGF, Args, LocalAddrs, VLASizes,\n                                   WrapperCGF.CXXThisValue, WrapperFO);\n  llvm::SmallVector<llvm::Value *, 4> CallArgs;\n  for (const auto *Arg : Args) {\n    llvm::Value *CallArg;\n    auto I = LocalAddrs.find(Arg);\n    if (I != LocalAddrs.end()) {\n      LValue LV = WrapperCGF.MakeAddrLValue(\n          I->second.second,\n          I->second.first ? I->second.first->getType() : Arg->getType(),\n          AlignmentSource::Decl);\n      CallArg = WrapperCGF.EmitLoadOfScalar(LV, S.getBeginLoc());\n    } else {\n      auto EI = VLASizes.find(Arg);\n      if (EI != VLASizes.end()) {\n        CallArg = EI->second.second;\n      } else {\n        LValue LV = WrapperCGF.MakeAddrLValue(WrapperCGF.GetAddrOfLocalVar(Arg),\n                                              Arg->getType(),\n                                              AlignmentSource::Decl);\n        CallArg = WrapperCGF.EmitLoadOfScalar(LV, S.getBeginLoc());\n      }\n    }\n    CallArgs.emplace_back(WrapperCGF.EmitFromMemory(CallArg, Arg->getType()));\n  }\n  CGM.getOpenMPRuntime().emitOutlinedFunctionCall(WrapperCGF, Loc, F, CallArgs);\n  WrapperCGF.FinishFunction();\n  return WrapperF;\n}\n\n//===----------------------------------------------------------------------===//\n//                              OpenMP Directive Emission\n//===----------------------------------------------------------------------===//\nvoid CodeGenFunction::EmitOMPAggregateAssign(\n    Address DestAddr, Address SrcAddr, QualType OriginalType,\n    const llvm::function_ref<void(Address, Address)> CopyGen) {\n  // Perform element-by-element initialization.\n  QualType ElementTy;\n\n  // Drill down to the base element type on both arrays.\n  const ArrayType *ArrayTy = OriginalType->getAsArrayTypeUnsafe();\n  llvm::Value *NumElements = emitArrayLength(ArrayTy, ElementTy, DestAddr);\n  SrcAddr = Builder.CreateElementBitCast(SrcAddr, DestAddr.getElementType());\n\n  llvm::Value *SrcBegin = SrcAddr.getPointer();\n  llvm::Value *DestBegin = DestAddr.getPointer();\n  // Cast from pointer to array type to pointer to single element.\n  llvm::Value *DestEnd = Builder.CreateGEP(DestBegin, NumElements);\n  // The basic structure here is a while-do loop.\n  llvm::BasicBlock *BodyBB = createBasicBlock(\"omp.arraycpy.body\");\n  llvm::BasicBlock *DoneBB = createBasicBlock(\"omp.arraycpy.done\");\n  llvm::Value *IsEmpty =\n      Builder.CreateICmpEQ(DestBegin, DestEnd, \"omp.arraycpy.isempty\");\n  Builder.CreateCondBr(IsEmpty, DoneBB, BodyBB);\n\n  // Enter the loop body, making that address the current address.\n  llvm::BasicBlock *EntryBB = Builder.GetInsertBlock();\n  EmitBlock(BodyBB);\n\n  CharUnits ElementSize = getContext().getTypeSizeInChars(ElementTy);\n\n  llvm::PHINode *SrcElementPHI =\n    Builder.CreatePHI(SrcBegin->getType(), 2, \"omp.arraycpy.srcElementPast\");\n  SrcElementPHI->addIncoming(SrcBegin, EntryBB);\n  Address SrcElementCurrent =\n      Address(SrcElementPHI,\n              SrcAddr.getAlignment().alignmentOfArrayElement(ElementSize));\n\n  llvm::PHINode *DestElementPHI =\n    Builder.CreatePHI(DestBegin->getType(), 2, \"omp.arraycpy.destElementPast\");\n  DestElementPHI->addIncoming(DestBegin, EntryBB);\n  Address DestElementCurrent =\n    Address(DestElementPHI,\n            DestAddr.getAlignment().alignmentOfArrayElement(ElementSize));\n\n  // Emit copy.\n  CopyGen(DestElementCurrent, SrcElementCurrent);\n\n  // Shift the address forward by one element.\n  llvm::Value *DestElementNext = Builder.CreateConstGEP1_32(\n      DestElementPHI, /*Idx0=*/1, \"omp.arraycpy.dest.element\");\n  llvm::Value *SrcElementNext = Builder.CreateConstGEP1_32(\n      SrcElementPHI, /*Idx0=*/1, \"omp.arraycpy.src.element\");\n  // Check whether we've reached the end.\n  llvm::Value *Done =\n      Builder.CreateICmpEQ(DestElementNext, DestEnd, \"omp.arraycpy.done\");\n  Builder.CreateCondBr(Done, DoneBB, BodyBB);\n  DestElementPHI->addIncoming(DestElementNext, Builder.GetInsertBlock());\n  SrcElementPHI->addIncoming(SrcElementNext, Builder.GetInsertBlock());\n\n  // Done.\n  EmitBlock(DoneBB, /*IsFinished=*/true);\n}\n\nvoid CodeGenFunction::EmitOMPCopy(QualType OriginalType, Address DestAddr,\n                                  Address SrcAddr, const VarDecl *DestVD,\n                                  const VarDecl *SrcVD, const Expr *Copy) {\n  if (OriginalType->isArrayType()) {\n    const auto *BO = dyn_cast<BinaryOperator>(Copy);\n    if (BO && BO->getOpcode() == BO_Assign) {\n      // Perform simple memcpy for simple copying.\n      LValue Dest = MakeAddrLValue(DestAddr, OriginalType);\n      LValue Src = MakeAddrLValue(SrcAddr, OriginalType);\n      EmitAggregateAssign(Dest, Src, OriginalType);\n    } else {\n      // For arrays with complex element types perform element by element\n      // copying.\n      EmitOMPAggregateAssign(\n          DestAddr, SrcAddr, OriginalType,\n          [this, Copy, SrcVD, DestVD](Address DestElement, Address SrcElement) {\n            // Working with the single array element, so have to remap\n            // destination and source variables to corresponding array\n            // elements.\n            CodeGenFunction::OMPPrivateScope Remap(*this);\n            Remap.addPrivate(DestVD, [DestElement]() { return DestElement; });\n            Remap.addPrivate(SrcVD, [SrcElement]() { return SrcElement; });\n            (void)Remap.Privatize();\n            EmitIgnoredExpr(Copy);\n          });\n    }\n  } else {\n    // Remap pseudo source variable to private copy.\n    CodeGenFunction::OMPPrivateScope Remap(*this);\n    Remap.addPrivate(SrcVD, [SrcAddr]() { return SrcAddr; });\n    Remap.addPrivate(DestVD, [DestAddr]() { return DestAddr; });\n    (void)Remap.Privatize();\n    // Emit copying of the whole variable.\n    EmitIgnoredExpr(Copy);\n  }\n}\n\nbool CodeGenFunction::EmitOMPFirstprivateClause(const OMPExecutableDirective &D,\n                                                OMPPrivateScope &PrivateScope) {\n  if (!HaveInsertPoint())\n    return false;\n  bool DeviceConstTarget =\n      getLangOpts().OpenMPIsDevice &&\n      isOpenMPTargetExecutionDirective(D.getDirectiveKind());\n  bool FirstprivateIsLastprivate = false;\n  llvm::DenseMap<const VarDecl *, OpenMPLastprivateModifier> Lastprivates;\n  for (const auto *C : D.getClausesOfKind<OMPLastprivateClause>()) {\n    for (const auto *D : C->varlists())\n      Lastprivates.try_emplace(\n          cast<VarDecl>(cast<DeclRefExpr>(D)->getDecl())->getCanonicalDecl(),\n          C->getKind());\n  }\n  llvm::DenseSet<const VarDecl *> EmittedAsFirstprivate;\n  llvm::SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n  getOpenMPCaptureRegions(CaptureRegions, D.getDirectiveKind());\n  // Force emission of the firstprivate copy if the directive does not emit\n  // outlined function, like omp for, omp simd, omp distribute etc.\n  bool MustEmitFirstprivateCopy =\n      CaptureRegions.size() == 1 && CaptureRegions.back() == OMPD_unknown;\n  for (const auto *C : D.getClausesOfKind<OMPFirstprivateClause>()) {\n    const auto *IRef = C->varlist_begin();\n    const auto *InitsRef = C->inits().begin();\n    for (const Expr *IInit : C->private_copies()) {\n      const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      bool ThisFirstprivateIsLastprivate =\n          Lastprivates.count(OrigVD->getCanonicalDecl()) > 0;\n      const FieldDecl *FD = CapturedStmtInfo->lookup(OrigVD);\n      const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(IInit)->getDecl());\n      if (!MustEmitFirstprivateCopy && !ThisFirstprivateIsLastprivate && FD &&\n          !FD->getType()->isReferenceType() &&\n          (!VD || !VD->hasAttr<OMPAllocateDeclAttr>())) {\n        EmittedAsFirstprivate.insert(OrigVD->getCanonicalDecl());\n        ++IRef;\n        ++InitsRef;\n        continue;\n      }\n      // Do not emit copy for firstprivate constant variables in target regions,\n      // captured by reference.\n      if (DeviceConstTarget && OrigVD->getType().isConstant(getContext()) &&\n          FD && FD->getType()->isReferenceType() &&\n          (!VD || !VD->hasAttr<OMPAllocateDeclAttr>())) {\n        (void)CGM.getOpenMPRuntime().registerTargetFirstprivateCopy(*this,\n                                                                    OrigVD);\n        ++IRef;\n        ++InitsRef;\n        continue;\n      }\n      FirstprivateIsLastprivate =\n          FirstprivateIsLastprivate || ThisFirstprivateIsLastprivate;\n      if (EmittedAsFirstprivate.insert(OrigVD->getCanonicalDecl()).second) {\n        const auto *VDInit =\n            cast<VarDecl>(cast<DeclRefExpr>(*InitsRef)->getDecl());\n        bool IsRegistered;\n        DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(OrigVD),\n                        /*RefersToEnclosingVariableOrCapture=*/FD != nullptr,\n                        (*IRef)->getType(), VK_LValue, (*IRef)->getExprLoc());\n        LValue OriginalLVal;\n        if (!FD) {\n          // Check if the firstprivate variable is just a constant value.\n          ConstantEmission CE = tryEmitAsConstant(&DRE);\n          if (CE && !CE.isReference()) {\n            // Constant value, no need to create a copy.\n            ++IRef;\n            ++InitsRef;\n            continue;\n          }\n          if (CE && CE.isReference()) {\n            OriginalLVal = CE.getReferenceLValue(*this, &DRE);\n          } else {\n            assert(!CE && \"Expected non-constant firstprivate.\");\n            OriginalLVal = EmitLValue(&DRE);\n          }\n        } else {\n          OriginalLVal = EmitLValue(&DRE);\n        }\n        QualType Type = VD->getType();\n        if (Type->isArrayType()) {\n          // Emit VarDecl with copy init for arrays.\n          // Get the address of the original variable captured in current\n          // captured region.\n          IsRegistered = PrivateScope.addPrivate(\n              OrigVD, [this, VD, Type, OriginalLVal, VDInit]() {\n                AutoVarEmission Emission = EmitAutoVarAlloca(*VD);\n                const Expr *Init = VD->getInit();\n                if (!isa<CXXConstructExpr>(Init) ||\n                    isTrivialInitializer(Init)) {\n                  // Perform simple memcpy.\n                  LValue Dest =\n                      MakeAddrLValue(Emission.getAllocatedAddress(), Type);\n                  EmitAggregateAssign(Dest, OriginalLVal, Type);\n                } else {\n                  EmitOMPAggregateAssign(\n                      Emission.getAllocatedAddress(),\n                      OriginalLVal.getAddress(*this), Type,\n                      [this, VDInit, Init](Address DestElement,\n                                           Address SrcElement) {\n                        // Clean up any temporaries needed by the\n                        // initialization.\n                        RunCleanupsScope InitScope(*this);\n                        // Emit initialization for single element.\n                        setAddrOfLocalVar(VDInit, SrcElement);\n                        EmitAnyExprToMem(Init, DestElement,\n                                         Init->getType().getQualifiers(),\n                                         /*IsInitializer*/ false);\n                        LocalDeclMap.erase(VDInit);\n                      });\n                }\n                EmitAutoVarCleanups(Emission);\n                return Emission.getAllocatedAddress();\n              });\n        } else {\n          Address OriginalAddr = OriginalLVal.getAddress(*this);\n          IsRegistered =\n              PrivateScope.addPrivate(OrigVD, [this, VDInit, OriginalAddr, VD,\n                                               ThisFirstprivateIsLastprivate,\n                                               OrigVD, &Lastprivates, IRef]() {\n                // Emit private VarDecl with copy init.\n                // Remap temp VDInit variable to the address of the original\n                // variable (for proper handling of captured global variables).\n                setAddrOfLocalVar(VDInit, OriginalAddr);\n                EmitDecl(*VD);\n                LocalDeclMap.erase(VDInit);\n                if (ThisFirstprivateIsLastprivate &&\n                    Lastprivates[OrigVD->getCanonicalDecl()] ==\n                        OMPC_LASTPRIVATE_conditional) {\n                  // Create/init special variable for lastprivate conditionals.\n                  Address VDAddr =\n                      CGM.getOpenMPRuntime().emitLastprivateConditionalInit(\n                          *this, OrigVD);\n                  llvm::Value *V = EmitLoadOfScalar(\n                      MakeAddrLValue(GetAddrOfLocalVar(VD), (*IRef)->getType(),\n                                     AlignmentSource::Decl),\n                      (*IRef)->getExprLoc());\n                  EmitStoreOfScalar(V,\n                                    MakeAddrLValue(VDAddr, (*IRef)->getType(),\n                                                   AlignmentSource::Decl));\n                  LocalDeclMap.erase(VD);\n                  setAddrOfLocalVar(VD, VDAddr);\n                  return VDAddr;\n                }\n                return GetAddrOfLocalVar(VD);\n              });\n        }\n        assert(IsRegistered &&\n               \"firstprivate var already registered as private\");\n        // Silence the warning about unused variable.\n        (void)IsRegistered;\n      }\n      ++IRef;\n      ++InitsRef;\n    }\n  }\n  return FirstprivateIsLastprivate && !EmittedAsFirstprivate.empty();\n}\n\nvoid CodeGenFunction::EmitOMPPrivateClause(\n    const OMPExecutableDirective &D,\n    CodeGenFunction::OMPPrivateScope &PrivateScope) {\n  if (!HaveInsertPoint())\n    return;\n  llvm::DenseSet<const VarDecl *> EmittedAsPrivate;\n  for (const auto *C : D.getClausesOfKind<OMPPrivateClause>()) {\n    auto IRef = C->varlist_begin();\n    for (const Expr *IInit : C->private_copies()) {\n      const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      if (EmittedAsPrivate.insert(OrigVD->getCanonicalDecl()).second) {\n        const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(IInit)->getDecl());\n        bool IsRegistered = PrivateScope.addPrivate(OrigVD, [this, VD]() {\n          // Emit private VarDecl with copy init.\n          EmitDecl(*VD);\n          return GetAddrOfLocalVar(VD);\n        });\n        assert(IsRegistered && \"private var already registered as private\");\n        // Silence the warning about unused variable.\n        (void)IsRegistered;\n      }\n      ++IRef;\n    }\n  }\n}\n\nbool CodeGenFunction::EmitOMPCopyinClause(const OMPExecutableDirective &D) {\n  if (!HaveInsertPoint())\n    return false;\n  // threadprivate_var1 = master_threadprivate_var1;\n  // operator=(threadprivate_var2, master_threadprivate_var2);\n  // ...\n  // __kmpc_barrier(&loc, global_tid);\n  llvm::DenseSet<const VarDecl *> CopiedVars;\n  llvm::BasicBlock *CopyBegin = nullptr, *CopyEnd = nullptr;\n  for (const auto *C : D.getClausesOfKind<OMPCopyinClause>()) {\n    auto IRef = C->varlist_begin();\n    auto ISrcRef = C->source_exprs().begin();\n    auto IDestRef = C->destination_exprs().begin();\n    for (const Expr *AssignOp : C->assignment_ops()) {\n      const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      QualType Type = VD->getType();\n      if (CopiedVars.insert(VD->getCanonicalDecl()).second) {\n        // Get the address of the master variable. If we are emitting code with\n        // TLS support, the address is passed from the master as field in the\n        // captured declaration.\n        Address MasterAddr = Address::invalid();\n        if (getLangOpts().OpenMPUseTLS &&\n            getContext().getTargetInfo().isTLSSupported()) {\n          assert(CapturedStmtInfo->lookup(VD) &&\n                 \"Copyin threadprivates should have been captured!\");\n          DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(VD), true,\n                          (*IRef)->getType(), VK_LValue, (*IRef)->getExprLoc());\n          MasterAddr = EmitLValue(&DRE).getAddress(*this);\n          LocalDeclMap.erase(VD);\n        } else {\n          MasterAddr =\n            Address(VD->isStaticLocal() ? CGM.getStaticLocalDeclAddress(VD)\n                                        : CGM.GetAddrOfGlobal(VD),\n                    getContext().getDeclAlign(VD));\n        }\n        // Get the address of the threadprivate variable.\n        Address PrivateAddr = EmitLValue(*IRef).getAddress(*this);\n        if (CopiedVars.size() == 1) {\n          // At first check if current thread is a master thread. If it is, no\n          // need to copy data.\n          CopyBegin = createBasicBlock(\"copyin.not.master\");\n          CopyEnd = createBasicBlock(\"copyin.not.master.end\");\n          Builder.CreateCondBr(\n              Builder.CreateICmpNE(\n                  Builder.CreatePtrToInt(MasterAddr.getPointer(), CGM.IntPtrTy),\n                  Builder.CreatePtrToInt(PrivateAddr.getPointer(),\n                                         CGM.IntPtrTy)),\n              CopyBegin, CopyEnd);\n          EmitBlock(CopyBegin);\n        }\n        const auto *SrcVD =\n            cast<VarDecl>(cast<DeclRefExpr>(*ISrcRef)->getDecl());\n        const auto *DestVD =\n            cast<VarDecl>(cast<DeclRefExpr>(*IDestRef)->getDecl());\n        EmitOMPCopy(Type, PrivateAddr, MasterAddr, DestVD, SrcVD, AssignOp);\n      }\n      ++IRef;\n      ++ISrcRef;\n      ++IDestRef;\n    }\n  }\n  if (CopyEnd) {\n    // Exit out of copying procedure for non-master thread.\n    EmitBlock(CopyEnd, /*IsFinished=*/true);\n    return true;\n  }\n  return false;\n}\n\nbool CodeGenFunction::EmitOMPLastprivateClauseInit(\n    const OMPExecutableDirective &D, OMPPrivateScope &PrivateScope) {\n  if (!HaveInsertPoint())\n    return false;\n  bool HasAtLeastOneLastprivate = false;\n  llvm::DenseSet<const VarDecl *> SIMDLCVs;\n  if (isOpenMPSimdDirective(D.getDirectiveKind())) {\n    const auto *LoopDirective = cast<OMPLoopDirective>(&D);\n    for (const Expr *C : LoopDirective->counters()) {\n      SIMDLCVs.insert(\n          cast<VarDecl>(cast<DeclRefExpr>(C)->getDecl())->getCanonicalDecl());\n    }\n  }\n  llvm::DenseSet<const VarDecl *> AlreadyEmittedVars;\n  for (const auto *C : D.getClausesOfKind<OMPLastprivateClause>()) {\n    HasAtLeastOneLastprivate = true;\n    if (isOpenMPTaskLoopDirective(D.getDirectiveKind()) &&\n        !getLangOpts().OpenMPSimd)\n      break;\n    const auto *IRef = C->varlist_begin();\n    const auto *IDestRef = C->destination_exprs().begin();\n    for (const Expr *IInit : C->private_copies()) {\n      // Keep the address of the original variable for future update at the end\n      // of the loop.\n      const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      // Taskloops do not require additional initialization, it is done in\n      // runtime support library.\n      if (AlreadyEmittedVars.insert(OrigVD->getCanonicalDecl()).second) {\n        const auto *DestVD =\n            cast<VarDecl>(cast<DeclRefExpr>(*IDestRef)->getDecl());\n        PrivateScope.addPrivate(DestVD, [this, OrigVD, IRef]() {\n          DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(OrigVD),\n                          /*RefersToEnclosingVariableOrCapture=*/\n                              CapturedStmtInfo->lookup(OrigVD) != nullptr,\n                          (*IRef)->getType(), VK_LValue, (*IRef)->getExprLoc());\n          return EmitLValue(&DRE).getAddress(*this);\n        });\n        // Check if the variable is also a firstprivate: in this case IInit is\n        // not generated. Initialization of this variable will happen in codegen\n        // for 'firstprivate' clause.\n        if (IInit && !SIMDLCVs.count(OrigVD->getCanonicalDecl())) {\n          const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(IInit)->getDecl());\n          bool IsRegistered = PrivateScope.addPrivate(OrigVD, [this, VD, C,\n                                                               OrigVD]() {\n            if (C->getKind() == OMPC_LASTPRIVATE_conditional) {\n              Address VDAddr =\n                  CGM.getOpenMPRuntime().emitLastprivateConditionalInit(*this,\n                                                                        OrigVD);\n              setAddrOfLocalVar(VD, VDAddr);\n              return VDAddr;\n            }\n            // Emit private VarDecl with copy init.\n            EmitDecl(*VD);\n            return GetAddrOfLocalVar(VD);\n          });\n          assert(IsRegistered &&\n                 \"lastprivate var already registered as private\");\n          (void)IsRegistered;\n        }\n      }\n      ++IRef;\n      ++IDestRef;\n    }\n  }\n  return HasAtLeastOneLastprivate;\n}\n\nvoid CodeGenFunction::EmitOMPLastprivateClauseFinal(\n    const OMPExecutableDirective &D, bool NoFinals,\n    llvm::Value *IsLastIterCond) {\n  if (!HaveInsertPoint())\n    return;\n  // Emit following code:\n  // if (<IsLastIterCond>) {\n  //   orig_var1 = private_orig_var1;\n  //   ...\n  //   orig_varn = private_orig_varn;\n  // }\n  llvm::BasicBlock *ThenBB = nullptr;\n  llvm::BasicBlock *DoneBB = nullptr;\n  if (IsLastIterCond) {\n    // Emit implicit barrier if at least one lastprivate conditional is found\n    // and this is not a simd mode.\n    if (!getLangOpts().OpenMPSimd &&\n        llvm::any_of(D.getClausesOfKind<OMPLastprivateClause>(),\n                     [](const OMPLastprivateClause *C) {\n                       return C->getKind() == OMPC_LASTPRIVATE_conditional;\n                     })) {\n      CGM.getOpenMPRuntime().emitBarrierCall(*this, D.getBeginLoc(),\n                                             OMPD_unknown,\n                                             /*EmitChecks=*/false,\n                                             /*ForceSimpleCall=*/true);\n    }\n    ThenBB = createBasicBlock(\".omp.lastprivate.then\");\n    DoneBB = createBasicBlock(\".omp.lastprivate.done\");\n    Builder.CreateCondBr(IsLastIterCond, ThenBB, DoneBB);\n    EmitBlock(ThenBB);\n  }\n  llvm::DenseSet<const VarDecl *> AlreadyEmittedVars;\n  llvm::DenseMap<const VarDecl *, const Expr *> LoopCountersAndUpdates;\n  if (const auto *LoopDirective = dyn_cast<OMPLoopDirective>(&D)) {\n    auto IC = LoopDirective->counters().begin();\n    for (const Expr *F : LoopDirective->finals()) {\n      const auto *D =\n          cast<VarDecl>(cast<DeclRefExpr>(*IC)->getDecl())->getCanonicalDecl();\n      if (NoFinals)\n        AlreadyEmittedVars.insert(D);\n      else\n        LoopCountersAndUpdates[D] = F;\n      ++IC;\n    }\n  }\n  for (const auto *C : D.getClausesOfKind<OMPLastprivateClause>()) {\n    auto IRef = C->varlist_begin();\n    auto ISrcRef = C->source_exprs().begin();\n    auto IDestRef = C->destination_exprs().begin();\n    for (const Expr *AssignOp : C->assignment_ops()) {\n      const auto *PrivateVD =\n          cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      QualType Type = PrivateVD->getType();\n      const auto *CanonicalVD = PrivateVD->getCanonicalDecl();\n      if (AlreadyEmittedVars.insert(CanonicalVD).second) {\n        // If lastprivate variable is a loop control variable for loop-based\n        // directive, update its value before copyin back to original\n        // variable.\n        if (const Expr *FinalExpr = LoopCountersAndUpdates.lookup(CanonicalVD))\n          EmitIgnoredExpr(FinalExpr);\n        const auto *SrcVD =\n            cast<VarDecl>(cast<DeclRefExpr>(*ISrcRef)->getDecl());\n        const auto *DestVD =\n            cast<VarDecl>(cast<DeclRefExpr>(*IDestRef)->getDecl());\n        // Get the address of the private variable.\n        Address PrivateAddr = GetAddrOfLocalVar(PrivateVD);\n        if (const auto *RefTy = PrivateVD->getType()->getAs<ReferenceType>())\n          PrivateAddr =\n              Address(Builder.CreateLoad(PrivateAddr),\n                      CGM.getNaturalTypeAlignment(RefTy->getPointeeType()));\n        // Store the last value to the private copy in the last iteration.\n        if (C->getKind() == OMPC_LASTPRIVATE_conditional)\n          CGM.getOpenMPRuntime().emitLastprivateConditionalFinalUpdate(\n              *this, MakeAddrLValue(PrivateAddr, (*IRef)->getType()), PrivateVD,\n              (*IRef)->getExprLoc());\n        // Get the address of the original variable.\n        Address OriginalAddr = GetAddrOfLocalVar(DestVD);\n        EmitOMPCopy(Type, OriginalAddr, PrivateAddr, DestVD, SrcVD, AssignOp);\n      }\n      ++IRef;\n      ++ISrcRef;\n      ++IDestRef;\n    }\n    if (const Expr *PostUpdate = C->getPostUpdateExpr())\n      EmitIgnoredExpr(PostUpdate);\n  }\n  if (IsLastIterCond)\n    EmitBlock(DoneBB, /*IsFinished=*/true);\n}\n\nvoid CodeGenFunction::EmitOMPReductionClauseInit(\n    const OMPExecutableDirective &D,\n    CodeGenFunction::OMPPrivateScope &PrivateScope, bool ForInscan) {\n  if (!HaveInsertPoint())\n    return;\n  SmallVector<const Expr *, 4> Shareds;\n  SmallVector<const Expr *, 4> Privates;\n  SmallVector<const Expr *, 4> ReductionOps;\n  SmallVector<const Expr *, 4> LHSs;\n  SmallVector<const Expr *, 4> RHSs;\n  OMPTaskDataTy Data;\n  SmallVector<const Expr *, 4> TaskLHSs;\n  SmallVector<const Expr *, 4> TaskRHSs;\n  for (const auto *C : D.getClausesOfKind<OMPReductionClause>()) {\n    if (ForInscan != (C->getModifier() == OMPC_REDUCTION_inscan))\n      continue;\n    Shareds.append(C->varlist_begin(), C->varlist_end());\n    Privates.append(C->privates().begin(), C->privates().end());\n    ReductionOps.append(C->reduction_ops().begin(), C->reduction_ops().end());\n    LHSs.append(C->lhs_exprs().begin(), C->lhs_exprs().end());\n    RHSs.append(C->rhs_exprs().begin(), C->rhs_exprs().end());\n    if (C->getModifier() == OMPC_REDUCTION_task) {\n      Data.ReductionVars.append(C->privates().begin(), C->privates().end());\n      Data.ReductionOrigs.append(C->varlist_begin(), C->varlist_end());\n      Data.ReductionCopies.append(C->privates().begin(), C->privates().end());\n      Data.ReductionOps.append(C->reduction_ops().begin(),\n                               C->reduction_ops().end());\n      TaskLHSs.append(C->lhs_exprs().begin(), C->lhs_exprs().end());\n      TaskRHSs.append(C->rhs_exprs().begin(), C->rhs_exprs().end());\n    }\n  }\n  ReductionCodeGen RedCG(Shareds, Shareds, Privates, ReductionOps);\n  unsigned Count = 0;\n  auto *ILHS = LHSs.begin();\n  auto *IRHS = RHSs.begin();\n  auto *IPriv = Privates.begin();\n  for (const Expr *IRef : Shareds) {\n    const auto *PrivateVD = cast<VarDecl>(cast<DeclRefExpr>(*IPriv)->getDecl());\n    // Emit private VarDecl with reduction init.\n    RedCG.emitSharedOrigLValue(*this, Count);\n    RedCG.emitAggregateType(*this, Count);\n    AutoVarEmission Emission = EmitAutoVarAlloca(*PrivateVD);\n    RedCG.emitInitialization(*this, Count, Emission.getAllocatedAddress(),\n                             RedCG.getSharedLValue(Count),\n                             [&Emission](CodeGenFunction &CGF) {\n                               CGF.EmitAutoVarInit(Emission);\n                               return true;\n                             });\n    EmitAutoVarCleanups(Emission);\n    Address BaseAddr = RedCG.adjustPrivateAddress(\n        *this, Count, Emission.getAllocatedAddress());\n    bool IsRegistered = PrivateScope.addPrivate(\n        RedCG.getBaseDecl(Count), [BaseAddr]() { return BaseAddr; });\n    assert(IsRegistered && \"private var already registered as private\");\n    // Silence the warning about unused variable.\n    (void)IsRegistered;\n\n    const auto *LHSVD = cast<VarDecl>(cast<DeclRefExpr>(*ILHS)->getDecl());\n    const auto *RHSVD = cast<VarDecl>(cast<DeclRefExpr>(*IRHS)->getDecl());\n    QualType Type = PrivateVD->getType();\n    bool isaOMPArraySectionExpr = isa<OMPArraySectionExpr>(IRef);\n    if (isaOMPArraySectionExpr && Type->isVariablyModifiedType()) {\n      // Store the address of the original variable associated with the LHS\n      // implicit variable.\n      PrivateScope.addPrivate(LHSVD, [&RedCG, Count, this]() {\n        return RedCG.getSharedLValue(Count).getAddress(*this);\n      });\n      PrivateScope.addPrivate(\n          RHSVD, [this, PrivateVD]() { return GetAddrOfLocalVar(PrivateVD); });\n    } else if ((isaOMPArraySectionExpr && Type->isScalarType()) ||\n               isa<ArraySubscriptExpr>(IRef)) {\n      // Store the address of the original variable associated with the LHS\n      // implicit variable.\n      PrivateScope.addPrivate(LHSVD, [&RedCG, Count, this]() {\n        return RedCG.getSharedLValue(Count).getAddress(*this);\n      });\n      PrivateScope.addPrivate(RHSVD, [this, PrivateVD, RHSVD]() {\n        return Builder.CreateElementBitCast(GetAddrOfLocalVar(PrivateVD),\n                                            ConvertTypeForMem(RHSVD->getType()),\n                                            \"rhs.begin\");\n      });\n    } else {\n      QualType Type = PrivateVD->getType();\n      bool IsArray = getContext().getAsArrayType(Type) != nullptr;\n      Address OriginalAddr = RedCG.getSharedLValue(Count).getAddress(*this);\n      // Store the address of the original variable associated with the LHS\n      // implicit variable.\n      if (IsArray) {\n        OriginalAddr = Builder.CreateElementBitCast(\n            OriginalAddr, ConvertTypeForMem(LHSVD->getType()), \"lhs.begin\");\n      }\n      PrivateScope.addPrivate(LHSVD, [OriginalAddr]() { return OriginalAddr; });\n      PrivateScope.addPrivate(\n          RHSVD, [this, PrivateVD, RHSVD, IsArray]() {\n            return IsArray\n                       ? Builder.CreateElementBitCast(\n                             GetAddrOfLocalVar(PrivateVD),\n                             ConvertTypeForMem(RHSVD->getType()), \"rhs.begin\")\n                       : GetAddrOfLocalVar(PrivateVD);\n          });\n    }\n    ++ILHS;\n    ++IRHS;\n    ++IPriv;\n    ++Count;\n  }\n  if (!Data.ReductionVars.empty()) {\n    Data.IsReductionWithTaskMod = true;\n    Data.IsWorksharingReduction =\n        isOpenMPWorksharingDirective(D.getDirectiveKind());\n    llvm::Value *ReductionDesc = CGM.getOpenMPRuntime().emitTaskReductionInit(\n        *this, D.getBeginLoc(), TaskLHSs, TaskRHSs, Data);\n    const Expr *TaskRedRef = nullptr;\n    switch (D.getDirectiveKind()) {\n    case OMPD_parallel:\n      TaskRedRef = cast<OMPParallelDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_for:\n      TaskRedRef = cast<OMPForDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_sections:\n      TaskRedRef = cast<OMPSectionsDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_parallel_for:\n      TaskRedRef = cast<OMPParallelForDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_parallel_master:\n      TaskRedRef =\n          cast<OMPParallelMasterDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_parallel_sections:\n      TaskRedRef =\n          cast<OMPParallelSectionsDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_target_parallel:\n      TaskRedRef =\n          cast<OMPTargetParallelDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_target_parallel_for:\n      TaskRedRef =\n          cast<OMPTargetParallelForDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_distribute_parallel_for:\n      TaskRedRef =\n          cast<OMPDistributeParallelForDirective>(D).getTaskReductionRefExpr();\n      break;\n    case OMPD_teams_distribute_parallel_for:\n      TaskRedRef = cast<OMPTeamsDistributeParallelForDirective>(D)\n                       .getTaskReductionRefExpr();\n      break;\n    case OMPD_target_teams_distribute_parallel_for:\n      TaskRedRef = cast<OMPTargetTeamsDistributeParallelForDirective>(D)\n                       .getTaskReductionRefExpr();\n      break;\n    case OMPD_simd:\n    case OMPD_for_simd:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_parallel_for_simd:\n    case OMPD_task:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_taskgroup:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_teams:\n    case OMPD_target:\n    case OMPD_cancellation_point:\n    case OMPD_cancel:\n    case OMPD_target_data:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n    case OMPD_distribute:\n    case OMPD_target_update:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_distribute_simd:\n    case OMPD_target_parallel_for_simd:\n    case OMPD_target_simd:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_target_teams:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n    case OMPD_target_teams_distribute_simd:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_requires:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Enexpected directive with task reductions.\");\n    }\n\n    const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(TaskRedRef)->getDecl());\n    EmitVarDecl(*VD);\n    EmitStoreOfScalar(ReductionDesc, GetAddrOfLocalVar(VD),\n                      /*Volatile=*/false, TaskRedRef->getType());\n  }\n}\n\nvoid CodeGenFunction::EmitOMPReductionClauseFinal(\n    const OMPExecutableDirective &D, const OpenMPDirectiveKind ReductionKind) {\n  if (!HaveInsertPoint())\n    return;\n  llvm::SmallVector<const Expr *, 8> Privates;\n  llvm::SmallVector<const Expr *, 8> LHSExprs;\n  llvm::SmallVector<const Expr *, 8> RHSExprs;\n  llvm::SmallVector<const Expr *, 8> ReductionOps;\n  bool HasAtLeastOneReduction = false;\n  bool IsReductionWithTaskMod = false;\n  for (const auto *C : D.getClausesOfKind<OMPReductionClause>()) {\n    // Do not emit for inscan reductions.\n    if (C->getModifier() == OMPC_REDUCTION_inscan)\n      continue;\n    HasAtLeastOneReduction = true;\n    Privates.append(C->privates().begin(), C->privates().end());\n    LHSExprs.append(C->lhs_exprs().begin(), C->lhs_exprs().end());\n    RHSExprs.append(C->rhs_exprs().begin(), C->rhs_exprs().end());\n    ReductionOps.append(C->reduction_ops().begin(), C->reduction_ops().end());\n    IsReductionWithTaskMod =\n        IsReductionWithTaskMod || C->getModifier() == OMPC_REDUCTION_task;\n  }\n  if (HasAtLeastOneReduction) {\n    if (IsReductionWithTaskMod) {\n      CGM.getOpenMPRuntime().emitTaskReductionFini(\n          *this, D.getBeginLoc(),\n          isOpenMPWorksharingDirective(D.getDirectiveKind()));\n    }\n    bool WithNowait = D.getSingleClause<OMPNowaitClause>() ||\n                      isOpenMPParallelDirective(D.getDirectiveKind()) ||\n                      ReductionKind == OMPD_simd;\n    bool SimpleReduction = ReductionKind == OMPD_simd;\n    // Emit nowait reduction if nowait clause is present or directive is a\n    // parallel directive (it always has implicit barrier).\n    CGM.getOpenMPRuntime().emitReduction(\n        *this, D.getEndLoc(), Privates, LHSExprs, RHSExprs, ReductionOps,\n        {WithNowait, SimpleReduction, ReductionKind});\n  }\n}\n\nstatic void emitPostUpdateForReductionClause(\n    CodeGenFunction &CGF, const OMPExecutableDirective &D,\n    const llvm::function_ref<llvm::Value *(CodeGenFunction &)> CondGen) {\n  if (!CGF.HaveInsertPoint())\n    return;\n  llvm::BasicBlock *DoneBB = nullptr;\n  for (const auto *C : D.getClausesOfKind<OMPReductionClause>()) {\n    if (const Expr *PostUpdate = C->getPostUpdateExpr()) {\n      if (!DoneBB) {\n        if (llvm::Value *Cond = CondGen(CGF)) {\n          // If the first post-update expression is found, emit conditional\n          // block if it was requested.\n          llvm::BasicBlock *ThenBB = CGF.createBasicBlock(\".omp.reduction.pu\");\n          DoneBB = CGF.createBasicBlock(\".omp.reduction.pu.done\");\n          CGF.Builder.CreateCondBr(Cond, ThenBB, DoneBB);\n          CGF.EmitBlock(ThenBB);\n        }\n      }\n      CGF.EmitIgnoredExpr(PostUpdate);\n    }\n  }\n  if (DoneBB)\n    CGF.EmitBlock(DoneBB, /*IsFinished=*/true);\n}\n\nnamespace {\n/// Codegen lambda for appending distribute lower and upper bounds to outlined\n/// parallel function. This is necessary for combined constructs such as\n/// 'distribute parallel for'\ntypedef llvm::function_ref<void(CodeGenFunction &,\n                                const OMPExecutableDirective &,\n                                llvm::SmallVectorImpl<llvm::Value *> &)>\n    CodeGenBoundParametersTy;\n} // anonymous namespace\n\nstatic void\ncheckForLastprivateConditionalUpdate(CodeGenFunction &CGF,\n                                     const OMPExecutableDirective &S) {\n  if (CGF.getLangOpts().OpenMP < 50)\n    return;\n  llvm::DenseSet<CanonicalDeclPtr<const VarDecl>> PrivateDecls;\n  for (const auto *C : S.getClausesOfKind<OMPReductionClause>()) {\n    for (const Expr *Ref : C->varlists()) {\n      if (!Ref->getType()->isScalarType())\n        continue;\n      const auto *DRE = dyn_cast<DeclRefExpr>(Ref->IgnoreParenImpCasts());\n      if (!DRE)\n        continue;\n      PrivateDecls.insert(cast<VarDecl>(DRE->getDecl()));\n      CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, Ref);\n    }\n  }\n  for (const auto *C : S.getClausesOfKind<OMPLastprivateClause>()) {\n    for (const Expr *Ref : C->varlists()) {\n      if (!Ref->getType()->isScalarType())\n        continue;\n      const auto *DRE = dyn_cast<DeclRefExpr>(Ref->IgnoreParenImpCasts());\n      if (!DRE)\n        continue;\n      PrivateDecls.insert(cast<VarDecl>(DRE->getDecl()));\n      CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, Ref);\n    }\n  }\n  for (const auto *C : S.getClausesOfKind<OMPLinearClause>()) {\n    for (const Expr *Ref : C->varlists()) {\n      if (!Ref->getType()->isScalarType())\n        continue;\n      const auto *DRE = dyn_cast<DeclRefExpr>(Ref->IgnoreParenImpCasts());\n      if (!DRE)\n        continue;\n      PrivateDecls.insert(cast<VarDecl>(DRE->getDecl()));\n      CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, Ref);\n    }\n  }\n  // Privates should ne analyzed since they are not captured at all.\n  // Task reductions may be skipped - tasks are ignored.\n  // Firstprivates do not return value but may be passed by reference - no need\n  // to check for updated lastprivate conditional.\n  for (const auto *C : S.getClausesOfKind<OMPFirstprivateClause>()) {\n    for (const Expr *Ref : C->varlists()) {\n      if (!Ref->getType()->isScalarType())\n        continue;\n      const auto *DRE = dyn_cast<DeclRefExpr>(Ref->IgnoreParenImpCasts());\n      if (!DRE)\n        continue;\n      PrivateDecls.insert(cast<VarDecl>(DRE->getDecl()));\n    }\n  }\n  CGF.CGM.getOpenMPRuntime().checkAndEmitSharedLastprivateConditional(\n      CGF, S, PrivateDecls);\n}\n\nstatic void emitCommonOMPParallelDirective(\n    CodeGenFunction &CGF, const OMPExecutableDirective &S,\n    OpenMPDirectiveKind InnermostKind, const RegionCodeGenTy &CodeGen,\n    const CodeGenBoundParametersTy &CodeGenBoundParameters) {\n  const CapturedStmt *CS = S.getCapturedStmt(OMPD_parallel);\n  llvm::Function *OutlinedFn =\n      CGF.CGM.getOpenMPRuntime().emitParallelOutlinedFunction(\n          S, *CS->getCapturedDecl()->param_begin(), InnermostKind, CodeGen);\n  if (const auto *NumThreadsClause = S.getSingleClause<OMPNumThreadsClause>()) {\n    CodeGenFunction::RunCleanupsScope NumThreadsScope(CGF);\n    llvm::Value *NumThreads =\n        CGF.EmitScalarExpr(NumThreadsClause->getNumThreads(),\n                           /*IgnoreResultAssign=*/true);\n    CGF.CGM.getOpenMPRuntime().emitNumThreadsClause(\n        CGF, NumThreads, NumThreadsClause->getBeginLoc());\n  }\n  if (const auto *ProcBindClause = S.getSingleClause<OMPProcBindClause>()) {\n    CodeGenFunction::RunCleanupsScope ProcBindScope(CGF);\n    CGF.CGM.getOpenMPRuntime().emitProcBindClause(\n        CGF, ProcBindClause->getProcBindKind(), ProcBindClause->getBeginLoc());\n  }\n  const Expr *IfCond = nullptr;\n  for (const auto *C : S.getClausesOfKind<OMPIfClause>()) {\n    if (C->getNameModifier() == OMPD_unknown ||\n        C->getNameModifier() == OMPD_parallel) {\n      IfCond = C->getCondition();\n      break;\n    }\n  }\n\n  OMPParallelScope Scope(CGF, S);\n  llvm::SmallVector<llvm::Value *, 16> CapturedVars;\n  // Combining 'distribute' with 'for' requires sharing each 'distribute' chunk\n  // lower and upper bounds with the pragma 'for' chunking mechanism.\n  // The following lambda takes care of appending the lower and upper bound\n  // parameters when necessary\n  CodeGenBoundParameters(CGF, S, CapturedVars);\n  CGF.GenerateOpenMPCapturedVars(*CS, CapturedVars);\n  CGF.CGM.getOpenMPRuntime().emitParallelCall(CGF, S.getBeginLoc(), OutlinedFn,\n                                              CapturedVars, IfCond);\n}\n\nstatic bool isAllocatableDecl(const VarDecl *VD) {\n  const VarDecl *CVD = VD->getCanonicalDecl();\n  if (!CVD->hasAttr<OMPAllocateDeclAttr>())\n    return false;\n  const auto *AA = CVD->getAttr<OMPAllocateDeclAttr>();\n  // Use the default allocation.\n  return !((AA->getAllocatorType() == OMPAllocateDeclAttr::OMPDefaultMemAlloc ||\n            AA->getAllocatorType() == OMPAllocateDeclAttr::OMPNullMemAlloc) &&\n           !AA->getAllocator());\n}\n\nstatic void emitEmptyBoundParameters(CodeGenFunction &,\n                                     const OMPExecutableDirective &,\n                                     llvm::SmallVectorImpl<llvm::Value *> &) {}\n\nAddress CodeGenFunction::OMPBuilderCBHelpers::getAddressOfLocalVariable(\n    CodeGenFunction &CGF, const VarDecl *VD) {\n  CodeGenModule &CGM = CGF.CGM;\n  auto &OMPBuilder = CGM.getOpenMPRuntime().getOMPBuilder();\n\n  if (!VD)\n    return Address::invalid();\n  const VarDecl *CVD = VD->getCanonicalDecl();\n  if (!isAllocatableDecl(CVD))\n    return Address::invalid();\n  llvm::Value *Size;\n  CharUnits Align = CGM.getContext().getDeclAlign(CVD);\n  if (CVD->getType()->isVariablyModifiedType()) {\n    Size = CGF.getTypeSize(CVD->getType());\n    // Align the size: ((size + align - 1) / align) * align\n    Size = CGF.Builder.CreateNUWAdd(\n        Size, CGM.getSize(Align - CharUnits::fromQuantity(1)));\n    Size = CGF.Builder.CreateUDiv(Size, CGM.getSize(Align));\n    Size = CGF.Builder.CreateNUWMul(Size, CGM.getSize(Align));\n  } else {\n    CharUnits Sz = CGM.getContext().getTypeSizeInChars(CVD->getType());\n    Size = CGM.getSize(Sz.alignTo(Align));\n  }\n\n  const auto *AA = CVD->getAttr<OMPAllocateDeclAttr>();\n  assert(AA->getAllocator() &&\n         \"Expected allocator expression for non-default allocator.\");\n  llvm::Value *Allocator = CGF.EmitScalarExpr(AA->getAllocator());\n  // According to the standard, the original allocator type is a enum (integer).\n  // Convert to pointer type, if required.\n  if (Allocator->getType()->isIntegerTy())\n    Allocator = CGF.Builder.CreateIntToPtr(Allocator, CGM.VoidPtrTy);\n  else if (Allocator->getType()->isPointerTy())\n    Allocator = CGF.Builder.CreatePointerBitCastOrAddrSpaceCast(Allocator,\n                                                                CGM.VoidPtrTy);\n\n  llvm::Value *Addr = OMPBuilder.createOMPAlloc(\n      CGF.Builder, Size, Allocator,\n      getNameWithSeparators({CVD->getName(), \".void.addr\"}, \".\", \".\"));\n  llvm::CallInst *FreeCI =\n      OMPBuilder.createOMPFree(CGF.Builder, Addr, Allocator);\n\n  CGF.EHStack.pushCleanup<OMPAllocateCleanupTy>(NormalAndEHCleanup, FreeCI);\n  Addr = CGF.Builder.CreatePointerBitCastOrAddrSpaceCast(\n      Addr,\n      CGF.ConvertTypeForMem(CGM.getContext().getPointerType(CVD->getType())),\n      getNameWithSeparators({CVD->getName(), \".addr\"}, \".\", \".\"));\n  return Address(Addr, Align);\n}\n\nAddress CodeGenFunction::OMPBuilderCBHelpers::getAddrOfThreadPrivate(\n    CodeGenFunction &CGF, const VarDecl *VD, Address VDAddr,\n    SourceLocation Loc) {\n  CodeGenModule &CGM = CGF.CGM;\n  if (CGM.getLangOpts().OpenMPUseTLS &&\n      CGM.getContext().getTargetInfo().isTLSSupported())\n    return VDAddr;\n\n  llvm::OpenMPIRBuilder &OMPBuilder = CGM.getOpenMPRuntime().getOMPBuilder();\n\n  llvm::Type *VarTy = VDAddr.getElementType();\n  llvm::Value *Data =\n      CGF.Builder.CreatePointerCast(VDAddr.getPointer(), CGM.Int8PtrTy);\n  llvm::ConstantInt *Size = CGM.getSize(CGM.GetTargetTypeStoreSize(VarTy));\n  std::string Suffix = getNameWithSeparators({\"cache\", \"\"});\n  llvm::Twine CacheName = Twine(CGM.getMangledName(VD)).concat(Suffix);\n\n  llvm::CallInst *ThreadPrivateCacheCall =\n      OMPBuilder.createCachedThreadPrivate(CGF.Builder, Data, Size, CacheName);\n\n  return Address(ThreadPrivateCacheCall, VDAddr.getAlignment());\n}\n\nstd::string CodeGenFunction::OMPBuilderCBHelpers::getNameWithSeparators(\n    ArrayRef<StringRef> Parts, StringRef FirstSeparator, StringRef Separator) {\n  SmallString<128> Buffer;\n  llvm::raw_svector_ostream OS(Buffer);\n  StringRef Sep = FirstSeparator;\n  for (StringRef Part : Parts) {\n    OS << Sep << Part;\n    Sep = Separator;\n  }\n  return OS.str().str();\n}\nvoid CodeGenFunction::EmitOMPParallelDirective(const OMPParallelDirective &S) {\n  if (CGM.getLangOpts().OpenMPIRBuilder) {\n    llvm::OpenMPIRBuilder &OMPBuilder = CGM.getOpenMPRuntime().getOMPBuilder();\n    // Check if we have any if clause associated with the directive.\n    llvm::Value *IfCond = nullptr;\n    if (const auto *C = S.getSingleClause<OMPIfClause>())\n      IfCond = EmitScalarExpr(C->getCondition(),\n                              /*IgnoreResultAssign=*/true);\n\n    llvm::Value *NumThreads = nullptr;\n    if (const auto *NumThreadsClause = S.getSingleClause<OMPNumThreadsClause>())\n      NumThreads = EmitScalarExpr(NumThreadsClause->getNumThreads(),\n                                  /*IgnoreResultAssign=*/true);\n\n    ProcBindKind ProcBind = OMP_PROC_BIND_default;\n    if (const auto *ProcBindClause = S.getSingleClause<OMPProcBindClause>())\n      ProcBind = ProcBindClause->getProcBindKind();\n\n    using InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;\n\n    // The cleanup callback that finalizes all variabels at the given location,\n    // thus calls destructors etc.\n    auto FiniCB = [this](InsertPointTy IP) {\n      OMPBuilderCBHelpers::FinalizeOMPRegion(*this, IP);\n    };\n\n    // Privatization callback that performs appropriate action for\n    // shared/private/firstprivate/lastprivate/copyin/... variables.\n    //\n    // TODO: This defaults to shared right now.\n    auto PrivCB = [](InsertPointTy AllocaIP, InsertPointTy CodeGenIP,\n                     llvm::Value &, llvm::Value &Val, llvm::Value *&ReplVal) {\n      // The next line is appropriate only for variables (Val) with the\n      // data-sharing attribute \"shared\".\n      ReplVal = &Val;\n\n      return CodeGenIP;\n    };\n\n    const CapturedStmt *CS = S.getCapturedStmt(OMPD_parallel);\n    const Stmt *ParallelRegionBodyStmt = CS->getCapturedStmt();\n\n    auto BodyGenCB = [ParallelRegionBodyStmt,\n                      this](InsertPointTy AllocaIP, InsertPointTy CodeGenIP,\n                            llvm::BasicBlock &ContinuationBB) {\n      OMPBuilderCBHelpers::OutlinedRegionBodyRAII ORB(*this, AllocaIP,\n                                                      ContinuationBB);\n      OMPBuilderCBHelpers::EmitOMPRegionBody(*this, ParallelRegionBodyStmt,\n                                             CodeGenIP, ContinuationBB);\n    };\n\n    CGCapturedStmtInfo CGSI(*CS, CR_OpenMP);\n    CodeGenFunction::CGCapturedStmtRAII CapInfoRAII(*this, &CGSI);\n    llvm::OpenMPIRBuilder::InsertPointTy AllocaIP(\n        AllocaInsertPt->getParent(), AllocaInsertPt->getIterator());\n    Builder.restoreIP(\n        OMPBuilder.createParallel(Builder, AllocaIP, BodyGenCB, PrivCB, FiniCB,\n                                  IfCond, NumThreads, ProcBind, S.hasCancel()));\n    return;\n  }\n\n  // Emit parallel region as a standalone region.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope PrivateScope(CGF);\n    bool Copyins = CGF.EmitOMPCopyinClause(S);\n    (void)CGF.EmitOMPFirstprivateClause(S, PrivateScope);\n    if (Copyins) {\n      // Emit implicit barrier to synchronize threads and avoid data races on\n      // propagation master's thread values of threadprivate variables to local\n      // instances of that variables of all other implicit threads.\n      CGF.CGM.getOpenMPRuntime().emitBarrierCall(\n          CGF, S.getBeginLoc(), OMPD_unknown, /*EmitChecks=*/false,\n          /*ForceSimpleCall=*/true);\n    }\n    CGF.EmitOMPPrivateClause(S, PrivateScope);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.EmitStmt(S.getCapturedStmt(OMPD_parallel)->getCapturedStmt());\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_parallel);\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    emitCommonOMPParallelDirective(*this, S, OMPD_parallel, CodeGen,\n                                   emitEmptyBoundParameters);\n    emitPostUpdateForReductionClause(*this, S,\n                                     [](CodeGenFunction &) { return nullptr; });\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nnamespace {\n/// RAII to handle scopes for loop transformation directives.\nclass OMPTransformDirectiveScopeRAII {\n  OMPLoopScope *Scope = nullptr;\n  CodeGenFunction::CGCapturedStmtInfo *CGSI = nullptr;\n  CodeGenFunction::CGCapturedStmtRAII *CapInfoRAII = nullptr;\n\npublic:\n  OMPTransformDirectiveScopeRAII(CodeGenFunction &CGF, const Stmt *S) {\n    if (const auto *Dir = dyn_cast<OMPLoopBasedDirective>(S)) {\n      Scope = new OMPLoopScope(CGF, *Dir);\n      CGSI = new CodeGenFunction::CGCapturedStmtInfo(CR_OpenMP);\n      CapInfoRAII = new CodeGenFunction::CGCapturedStmtRAII(CGF, CGSI);\n    }\n  }\n  ~OMPTransformDirectiveScopeRAII() {\n    if (!Scope)\n      return;\n    delete CapInfoRAII;\n    delete CGSI;\n    delete Scope;\n  }\n};\n} // namespace\n\nstatic void emitBody(CodeGenFunction &CGF, const Stmt *S, const Stmt *NextLoop,\n                     int MaxLevel, int Level = 0) {\n  assert(Level < MaxLevel && \"Too deep lookup during loop body codegen.\");\n  const Stmt *SimplifiedS = S->IgnoreContainers();\n  if (const auto *CS = dyn_cast<CompoundStmt>(SimplifiedS)) {\n    PrettyStackTraceLoc CrashInfo(\n        CGF.getContext().getSourceManager(), CS->getLBracLoc(),\n        \"LLVM IR generation of compound statement ('{}')\");\n\n    // Keep track of the current cleanup stack depth, including debug scopes.\n    CodeGenFunction::LexicalScope Scope(CGF, S->getSourceRange());\n    for (const Stmt *CurStmt : CS->body())\n      emitBody(CGF, CurStmt, NextLoop, MaxLevel, Level);\n    return;\n  }\n  if (SimplifiedS == NextLoop) {\n    OMPTransformDirectiveScopeRAII PossiblyTransformDirectiveScope(CGF,\n                                                                   SimplifiedS);\n    if (auto *Dir = dyn_cast<OMPTileDirective>(SimplifiedS))\n      SimplifiedS = Dir->getTransformedStmt();\n    if (const auto *CanonLoop = dyn_cast<OMPCanonicalLoop>(SimplifiedS))\n      SimplifiedS = CanonLoop->getLoopStmt();\n    if (const auto *For = dyn_cast<ForStmt>(SimplifiedS)) {\n      S = For->getBody();\n    } else {\n      assert(isa<CXXForRangeStmt>(SimplifiedS) &&\n             \"Expected canonical for loop or range-based for loop.\");\n      const auto *CXXFor = cast<CXXForRangeStmt>(SimplifiedS);\n      CGF.EmitStmt(CXXFor->getLoopVarStmt());\n      S = CXXFor->getBody();\n    }\n    if (Level + 1 < MaxLevel) {\n      NextLoop = OMPLoopDirective::tryToFindNextInnerLoop(\n          S, /*TryImperfectlyNestedLoops=*/true);\n      emitBody(CGF, S, NextLoop, MaxLevel, Level + 1);\n      return;\n    }\n  }\n  CGF.EmitStmt(S);\n}\n\nvoid CodeGenFunction::EmitOMPLoopBody(const OMPLoopDirective &D,\n                                      JumpDest LoopExit) {\n  RunCleanupsScope BodyScope(*this);\n  // Update counters values on current iteration.\n  for (const Expr *UE : D.updates())\n    EmitIgnoredExpr(UE);\n  // Update the linear variables.\n  // In distribute directives only loop counters may be marked as linear, no\n  // need to generate the code for them.\n  if (!isOpenMPDistributeDirective(D.getDirectiveKind())) {\n    for (const auto *C : D.getClausesOfKind<OMPLinearClause>()) {\n      for (const Expr *UE : C->updates())\n        EmitIgnoredExpr(UE);\n    }\n  }\n\n  // On a continue in the body, jump to the end.\n  JumpDest Continue = getJumpDestInCurrentScope(\"omp.body.continue\");\n  BreakContinueStack.push_back(BreakContinue(LoopExit, Continue));\n  for (const Expr *E : D.finals_conditions()) {\n    if (!E)\n      continue;\n    // Check that loop counter in non-rectangular nest fits into the iteration\n    // space.\n    llvm::BasicBlock *NextBB = createBasicBlock(\"omp.body.next\");\n    EmitBranchOnBoolExpr(E, NextBB, Continue.getBlock(),\n                         getProfileCount(D.getBody()));\n    EmitBlock(NextBB);\n  }\n\n  OMPPrivateScope InscanScope(*this);\n  EmitOMPReductionClauseInit(D, InscanScope, /*ForInscan=*/true);\n  bool IsInscanRegion = InscanScope.Privatize();\n  if (IsInscanRegion) {\n    // Need to remember the block before and after scan directive\n    // to dispatch them correctly depending on the clause used in\n    // this directive, inclusive or exclusive. For inclusive scan the natural\n    // order of the blocks is used, for exclusive clause the blocks must be\n    // executed in reverse order.\n    OMPBeforeScanBlock = createBasicBlock(\"omp.before.scan.bb\");\n    OMPAfterScanBlock = createBasicBlock(\"omp.after.scan.bb\");\n    // No need to allocate inscan exit block, in simd mode it is selected in the\n    // codegen for the scan directive.\n    if (D.getDirectiveKind() != OMPD_simd && !getLangOpts().OpenMPSimd)\n      OMPScanExitBlock = createBasicBlock(\"omp.exit.inscan.bb\");\n    OMPScanDispatch = createBasicBlock(\"omp.inscan.dispatch\");\n    EmitBranch(OMPScanDispatch);\n    EmitBlock(OMPBeforeScanBlock);\n  }\n\n  // Emit loop variables for C++ range loops.\n  const Stmt *Body =\n      D.getInnermostCapturedStmt()->getCapturedStmt()->IgnoreContainers();\n  // Emit loop body.\n  emitBody(*this, Body,\n           OMPLoopBasedDirective::tryToFindNextInnerLoop(\n               Body, /*TryImperfectlyNestedLoops=*/true),\n           D.getLoopsNumber());\n\n  // Jump to the dispatcher at the end of the loop body.\n  if (IsInscanRegion)\n    EmitBranch(OMPScanExitBlock);\n\n  // The end (updates/cleanups).\n  EmitBlock(Continue.getBlock());\n  BreakContinueStack.pop_back();\n}\n\nusing EmittedClosureTy = std::pair<llvm::Function *, llvm::Value *>;\n\n/// Emit a captured statement and return the function as well as its captured\n/// closure context.\nstatic EmittedClosureTy emitCapturedStmtFunc(CodeGenFunction &ParentCGF,\n                                             const CapturedStmt *S) {\n  LValue CapStruct = ParentCGF.InitCapturedStruct(*S);\n  CodeGenFunction CGF(ParentCGF.CGM, /*suppressNewContext=*/true);\n  std::unique_ptr<CodeGenFunction::CGCapturedStmtInfo> CSI =\n      std::make_unique<CodeGenFunction::CGCapturedStmtInfo>(*S);\n  CodeGenFunction::CGCapturedStmtRAII CapInfoRAII(CGF, CSI.get());\n  llvm::Function *F = CGF.GenerateCapturedStmtFunction(*S);\n\n  return {F, CapStruct.getPointer(ParentCGF)};\n}\n\n/// Emit a call to a previously captured closure.\nstatic llvm::CallInst *\nemitCapturedStmtCall(CodeGenFunction &ParentCGF, EmittedClosureTy Cap,\n                     llvm::ArrayRef<llvm::Value *> Args) {\n  // Append the closure context to the argument.\n  llvm::SmallVector<llvm::Value *> EffectiveArgs;\n  EffectiveArgs.reserve(Args.size() + 1);\n  llvm::append_range(EffectiveArgs, Args);\n  EffectiveArgs.push_back(Cap.second);\n\n  return ParentCGF.Builder.CreateCall(Cap.first, EffectiveArgs);\n}\n\nllvm::CanonicalLoopInfo *\nCodeGenFunction::EmitOMPCollapsedCanonicalLoopNest(const Stmt *S, int Depth) {\n  assert(Depth == 1 && \"Nested loops with OpenMPIRBuilder not yet implemented\");\n\n  EmitStmt(S);\n  assert(OMPLoopNestStack.size() >= (size_t)Depth && \"Found too few loops\");\n\n  // The last added loop is the outermost one.\n  return OMPLoopNestStack.back();\n}\n\nvoid CodeGenFunction::EmitOMPCanonicalLoop(const OMPCanonicalLoop *S) {\n  const Stmt *SyntacticalLoop = S->getLoopStmt();\n  if (!getLangOpts().OpenMPIRBuilder) {\n    // Ignore if OpenMPIRBuilder is not enabled.\n    EmitStmt(SyntacticalLoop);\n    return;\n  }\n\n  LexicalScope ForScope(*this, S->getSourceRange());\n\n  // Emit init statements. The Distance/LoopVar funcs may reference variable\n  // declarations they contain.\n  const Stmt *BodyStmt;\n  if (const auto *For = dyn_cast<ForStmt>(SyntacticalLoop)) {\n    if (const Stmt *InitStmt = For->getInit())\n      EmitStmt(InitStmt);\n    BodyStmt = For->getBody();\n  } else if (const auto *RangeFor =\n                 dyn_cast<CXXForRangeStmt>(SyntacticalLoop)) {\n    if (const DeclStmt *RangeStmt = RangeFor->getRangeStmt())\n      EmitStmt(RangeStmt);\n    if (const DeclStmt *BeginStmt = RangeFor->getBeginStmt())\n      EmitStmt(BeginStmt);\n    if (const DeclStmt *EndStmt = RangeFor->getEndStmt())\n      EmitStmt(EndStmt);\n    if (const DeclStmt *LoopVarStmt = RangeFor->getLoopVarStmt())\n      EmitStmt(LoopVarStmt);\n    BodyStmt = RangeFor->getBody();\n  } else\n    llvm_unreachable(\"Expected for-stmt or range-based for-stmt\");\n\n  // Emit closure for later use. By-value captures will be captured here.\n  const CapturedStmt *DistanceFunc = S->getDistanceFunc();\n  EmittedClosureTy DistanceClosure = emitCapturedStmtFunc(*this, DistanceFunc);\n  const CapturedStmt *LoopVarFunc = S->getLoopVarFunc();\n  EmittedClosureTy LoopVarClosure = emitCapturedStmtFunc(*this, LoopVarFunc);\n\n  // Call the distance function to get the number of iterations of the loop to\n  // come.\n  QualType LogicalTy = DistanceFunc->getCapturedDecl()\n                           ->getParam(0)\n                           ->getType()\n                           .getNonReferenceType();\n  Address CountAddr = CreateMemTemp(LogicalTy, \".count.addr\");\n  emitCapturedStmtCall(*this, DistanceClosure, {CountAddr.getPointer()});\n  llvm::Value *DistVal = Builder.CreateLoad(CountAddr, \".count\");\n\n  // Emit the loop structure.\n  llvm::OpenMPIRBuilder &OMPBuilder = CGM.getOpenMPRuntime().getOMPBuilder();\n  auto BodyGen = [&, this](llvm::OpenMPIRBuilder::InsertPointTy CodeGenIP,\n                           llvm::Value *IndVar) {\n    Builder.restoreIP(CodeGenIP);\n\n    // Emit the loop body: Convert the logical iteration number to the loop\n    // variable and emit the body.\n    const DeclRefExpr *LoopVarRef = S->getLoopVarRef();\n    LValue LCVal = EmitLValue(LoopVarRef);\n    Address LoopVarAddress = LCVal.getAddress(*this);\n    emitCapturedStmtCall(*this, LoopVarClosure,\n                         {LoopVarAddress.getPointer(), IndVar});\n\n    RunCleanupsScope BodyScope(*this);\n    EmitStmt(BodyStmt);\n  };\n  llvm::CanonicalLoopInfo *CL =\n      OMPBuilder.createCanonicalLoop(Builder, BodyGen, DistVal);\n\n  // Finish up the loop.\n  Builder.restoreIP(CL->getAfterIP());\n  ForScope.ForceCleanup();\n\n  // Remember the CanonicalLoopInfo for parent AST nodes consuming it.\n  OMPLoopNestStack.push_back(CL);\n}\n\nvoid CodeGenFunction::EmitOMPInnerLoop(\n    const OMPExecutableDirective &S, bool RequiresCleanup, const Expr *LoopCond,\n    const Expr *IncExpr,\n    const llvm::function_ref<void(CodeGenFunction &)> BodyGen,\n    const llvm::function_ref<void(CodeGenFunction &)> PostIncGen) {\n  auto LoopExit = getJumpDestInCurrentScope(\"omp.inner.for.end\");\n\n  // Start the loop with a block that tests the condition.\n  auto CondBlock = createBasicBlock(\"omp.inner.for.cond\");\n  EmitBlock(CondBlock);\n  const SourceRange R = S.getSourceRange();\n\n  // If attributes are attached, push to the basic block with them.\n  const auto &OMPED = cast<OMPExecutableDirective>(S);\n  const CapturedStmt *ICS = OMPED.getInnermostCapturedStmt();\n  const Stmt *SS = ICS->getCapturedStmt();\n  const AttributedStmt *AS = dyn_cast_or_null<AttributedStmt>(SS);\n  OMPLoopNestStack.clear();\n  if (AS)\n    LoopStack.push(CondBlock, CGM.getContext(), CGM.getCodeGenOpts(),\n                   AS->getAttrs(), SourceLocToDebugLoc(R.getBegin()),\n                   SourceLocToDebugLoc(R.getEnd()));\n  else\n    LoopStack.push(CondBlock, SourceLocToDebugLoc(R.getBegin()),\n                   SourceLocToDebugLoc(R.getEnd()));\n\n  // If there are any cleanups between here and the loop-exit scope,\n  // create a block to stage a loop exit along.\n  llvm::BasicBlock *ExitBlock = LoopExit.getBlock();\n  if (RequiresCleanup)\n    ExitBlock = createBasicBlock(\"omp.inner.for.cond.cleanup\");\n\n  llvm::BasicBlock *LoopBody = createBasicBlock(\"omp.inner.for.body\");\n\n  // Emit condition.\n  EmitBranchOnBoolExpr(LoopCond, LoopBody, ExitBlock, getProfileCount(&S));\n  if (ExitBlock != LoopExit.getBlock()) {\n    EmitBlock(ExitBlock);\n    EmitBranchThroughCleanup(LoopExit);\n  }\n\n  EmitBlock(LoopBody);\n  incrementProfileCounter(&S);\n\n  // Create a block for the increment.\n  JumpDest Continue = getJumpDestInCurrentScope(\"omp.inner.for.inc\");\n  BreakContinueStack.push_back(BreakContinue(LoopExit, Continue));\n\n  BodyGen(*this);\n\n  // Emit \"IV = IV + 1\" and a back-edge to the condition block.\n  EmitBlock(Continue.getBlock());\n  EmitIgnoredExpr(IncExpr);\n  PostIncGen(*this);\n  BreakContinueStack.pop_back();\n  EmitBranch(CondBlock);\n  LoopStack.pop();\n  // Emit the fall-through block.\n  EmitBlock(LoopExit.getBlock());\n}\n\nbool CodeGenFunction::EmitOMPLinearClauseInit(const OMPLoopDirective &D) {\n  if (!HaveInsertPoint())\n    return false;\n  // Emit inits for the linear variables.\n  bool HasLinears = false;\n  for (const auto *C : D.getClausesOfKind<OMPLinearClause>()) {\n    for (const Expr *Init : C->inits()) {\n      HasLinears = true;\n      const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(Init)->getDecl());\n      if (const auto *Ref =\n              dyn_cast<DeclRefExpr>(VD->getInit()->IgnoreImpCasts())) {\n        AutoVarEmission Emission = EmitAutoVarAlloca(*VD);\n        const auto *OrigVD = cast<VarDecl>(Ref->getDecl());\n        DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(OrigVD),\n                        CapturedStmtInfo->lookup(OrigVD) != nullptr,\n                        VD->getInit()->getType(), VK_LValue,\n                        VD->getInit()->getExprLoc());\n        EmitExprAsInit(&DRE, VD, MakeAddrLValue(Emission.getAllocatedAddress(),\n                                                VD->getType()),\n                       /*capturedByInit=*/false);\n        EmitAutoVarCleanups(Emission);\n      } else {\n        EmitVarDecl(*VD);\n      }\n    }\n    // Emit the linear steps for the linear clauses.\n    // If a step is not constant, it is pre-calculated before the loop.\n    if (const auto *CS = cast_or_null<BinaryOperator>(C->getCalcStep()))\n      if (const auto *SaveRef = cast<DeclRefExpr>(CS->getLHS())) {\n        EmitVarDecl(*cast<VarDecl>(SaveRef->getDecl()));\n        // Emit calculation of the linear step.\n        EmitIgnoredExpr(CS);\n      }\n  }\n  return HasLinears;\n}\n\nvoid CodeGenFunction::EmitOMPLinearClauseFinal(\n    const OMPLoopDirective &D,\n    const llvm::function_ref<llvm::Value *(CodeGenFunction &)> CondGen) {\n  if (!HaveInsertPoint())\n    return;\n  llvm::BasicBlock *DoneBB = nullptr;\n  // Emit the final values of the linear variables.\n  for (const auto *C : D.getClausesOfKind<OMPLinearClause>()) {\n    auto IC = C->varlist_begin();\n    for (const Expr *F : C->finals()) {\n      if (!DoneBB) {\n        if (llvm::Value *Cond = CondGen(*this)) {\n          // If the first post-update expression is found, emit conditional\n          // block if it was requested.\n          llvm::BasicBlock *ThenBB = createBasicBlock(\".omp.linear.pu\");\n          DoneBB = createBasicBlock(\".omp.linear.pu.done\");\n          Builder.CreateCondBr(Cond, ThenBB, DoneBB);\n          EmitBlock(ThenBB);\n        }\n      }\n      const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*IC)->getDecl());\n      DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(OrigVD),\n                      CapturedStmtInfo->lookup(OrigVD) != nullptr,\n                      (*IC)->getType(), VK_LValue, (*IC)->getExprLoc());\n      Address OrigAddr = EmitLValue(&DRE).getAddress(*this);\n      CodeGenFunction::OMPPrivateScope VarScope(*this);\n      VarScope.addPrivate(OrigVD, [OrigAddr]() { return OrigAddr; });\n      (void)VarScope.Privatize();\n      EmitIgnoredExpr(F);\n      ++IC;\n    }\n    if (const Expr *PostUpdate = C->getPostUpdateExpr())\n      EmitIgnoredExpr(PostUpdate);\n  }\n  if (DoneBB)\n    EmitBlock(DoneBB, /*IsFinished=*/true);\n}\n\nstatic void emitAlignedClause(CodeGenFunction &CGF,\n                              const OMPExecutableDirective &D) {\n  if (!CGF.HaveInsertPoint())\n    return;\n  for (const auto *Clause : D.getClausesOfKind<OMPAlignedClause>()) {\n    llvm::APInt ClauseAlignment(64, 0);\n    if (const Expr *AlignmentExpr = Clause->getAlignment()) {\n      auto *AlignmentCI =\n          cast<llvm::ConstantInt>(CGF.EmitScalarExpr(AlignmentExpr));\n      ClauseAlignment = AlignmentCI->getValue();\n    }\n    for (const Expr *E : Clause->varlists()) {\n      llvm::APInt Alignment(ClauseAlignment);\n      if (Alignment == 0) {\n        // OpenMP [2.8.1, Description]\n        // If no optional parameter is specified, implementation-defined default\n        // alignments for SIMD instructions on the target platforms are assumed.\n        Alignment =\n            CGF.getContext()\n                .toCharUnitsFromBits(CGF.getContext().getOpenMPDefaultSimdAlign(\n                    E->getType()->getPointeeType()))\n                .getQuantity();\n      }\n      assert((Alignment == 0 || Alignment.isPowerOf2()) &&\n             \"alignment is not power of 2\");\n      if (Alignment != 0) {\n        llvm::Value *PtrValue = CGF.EmitScalarExpr(E);\n        CGF.emitAlignmentAssumption(\n            PtrValue, E, /*No second loc needed*/ SourceLocation(),\n            llvm::ConstantInt::get(CGF.getLLVMContext(), Alignment));\n      }\n    }\n  }\n}\n\nvoid CodeGenFunction::EmitOMPPrivateLoopCounters(\n    const OMPLoopDirective &S, CodeGenFunction::OMPPrivateScope &LoopScope) {\n  if (!HaveInsertPoint())\n    return;\n  auto I = S.private_counters().begin();\n  for (const Expr *E : S.counters()) {\n    const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n    const auto *PrivateVD = cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl());\n    // Emit var without initialization.\n    AutoVarEmission VarEmission = EmitAutoVarAlloca(*PrivateVD);\n    EmitAutoVarCleanups(VarEmission);\n    LocalDeclMap.erase(PrivateVD);\n    (void)LoopScope.addPrivate(VD, [&VarEmission]() {\n      return VarEmission.getAllocatedAddress();\n    });\n    if (LocalDeclMap.count(VD) || CapturedStmtInfo->lookup(VD) ||\n        VD->hasGlobalStorage()) {\n      (void)LoopScope.addPrivate(PrivateVD, [this, VD, E]() {\n        DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(VD),\n                        LocalDeclMap.count(VD) || CapturedStmtInfo->lookup(VD),\n                        E->getType(), VK_LValue, E->getExprLoc());\n        return EmitLValue(&DRE).getAddress(*this);\n      });\n    } else {\n      (void)LoopScope.addPrivate(PrivateVD, [&VarEmission]() {\n        return VarEmission.getAllocatedAddress();\n      });\n    }\n    ++I;\n  }\n  // Privatize extra loop counters used in loops for ordered(n) clauses.\n  for (const auto *C : S.getClausesOfKind<OMPOrderedClause>()) {\n    if (!C->getNumForLoops())\n      continue;\n    for (unsigned I = S.getLoopsNumber(), E = C->getLoopNumIterations().size();\n         I < E; ++I) {\n      const auto *DRE = cast<DeclRefExpr>(C->getLoopCounter(I));\n      const auto *VD = cast<VarDecl>(DRE->getDecl());\n      // Override only those variables that can be captured to avoid re-emission\n      // of the variables declared within the loops.\n      if (DRE->refersToEnclosingVariableOrCapture()) {\n        (void)LoopScope.addPrivate(VD, [this, DRE, VD]() {\n          return CreateMemTemp(DRE->getType(), VD->getName());\n        });\n      }\n    }\n  }\n}\n\nstatic void emitPreCond(CodeGenFunction &CGF, const OMPLoopDirective &S,\n                        const Expr *Cond, llvm::BasicBlock *TrueBlock,\n                        llvm::BasicBlock *FalseBlock, uint64_t TrueCount) {\n  if (!CGF.HaveInsertPoint())\n    return;\n  {\n    CodeGenFunction::OMPPrivateScope PreCondScope(CGF);\n    CGF.EmitOMPPrivateLoopCounters(S, PreCondScope);\n    (void)PreCondScope.Privatize();\n    // Get initial values of real counters.\n    for (const Expr *I : S.inits()) {\n      CGF.EmitIgnoredExpr(I);\n    }\n  }\n  // Create temp loop control variables with their init values to support\n  // non-rectangular loops.\n  CodeGenFunction::OMPMapVars PreCondVars;\n  for (const Expr * E: S.dependent_counters()) {\n    if (!E)\n      continue;\n    assert(!E->getType().getNonReferenceType()->isRecordType() &&\n           \"dependent counter must not be an iterator.\");\n    const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n    Address CounterAddr =\n        CGF.CreateMemTemp(VD->getType().getNonReferenceType());\n    (void)PreCondVars.setVarAddr(CGF, VD, CounterAddr);\n  }\n  (void)PreCondVars.apply(CGF);\n  for (const Expr *E : S.dependent_inits()) {\n    if (!E)\n      continue;\n    CGF.EmitIgnoredExpr(E);\n  }\n  // Check that loop is executed at least one time.\n  CGF.EmitBranchOnBoolExpr(Cond, TrueBlock, FalseBlock, TrueCount);\n  PreCondVars.restore(CGF);\n}\n\nvoid CodeGenFunction::EmitOMPLinearClause(\n    const OMPLoopDirective &D, CodeGenFunction::OMPPrivateScope &PrivateScope) {\n  if (!HaveInsertPoint())\n    return;\n  llvm::DenseSet<const VarDecl *> SIMDLCVs;\n  if (isOpenMPSimdDirective(D.getDirectiveKind())) {\n    const auto *LoopDirective = cast<OMPLoopDirective>(&D);\n    for (const Expr *C : LoopDirective->counters()) {\n      SIMDLCVs.insert(\n          cast<VarDecl>(cast<DeclRefExpr>(C)->getDecl())->getCanonicalDecl());\n    }\n  }\n  for (const auto *C : D.getClausesOfKind<OMPLinearClause>()) {\n    auto CurPrivate = C->privates().begin();\n    for (const Expr *E : C->varlists()) {\n      const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n      const auto *PrivateVD =\n          cast<VarDecl>(cast<DeclRefExpr>(*CurPrivate)->getDecl());\n      if (!SIMDLCVs.count(VD->getCanonicalDecl())) {\n        bool IsRegistered = PrivateScope.addPrivate(VD, [this, PrivateVD]() {\n          // Emit private VarDecl with copy init.\n          EmitVarDecl(*PrivateVD);\n          return GetAddrOfLocalVar(PrivateVD);\n        });\n        assert(IsRegistered && \"linear var already registered as private\");\n        // Silence the warning about unused variable.\n        (void)IsRegistered;\n      } else {\n        EmitVarDecl(*PrivateVD);\n      }\n      ++CurPrivate;\n    }\n  }\n}\n\nstatic void emitSimdlenSafelenClause(CodeGenFunction &CGF,\n                                     const OMPExecutableDirective &D,\n                                     bool IsMonotonic) {\n  if (!CGF.HaveInsertPoint())\n    return;\n  if (const auto *C = D.getSingleClause<OMPSimdlenClause>()) {\n    RValue Len = CGF.EmitAnyExpr(C->getSimdlen(), AggValueSlot::ignored(),\n                                 /*ignoreResult=*/true);\n    auto *Val = cast<llvm::ConstantInt>(Len.getScalarVal());\n    CGF.LoopStack.setVectorizeWidth(Val->getZExtValue());\n    // In presence of finite 'safelen', it may be unsafe to mark all\n    // the memory instructions parallel, because loop-carried\n    // dependences of 'safelen' iterations are possible.\n    if (!IsMonotonic)\n      CGF.LoopStack.setParallel(!D.getSingleClause<OMPSafelenClause>());\n  } else if (const auto *C = D.getSingleClause<OMPSafelenClause>()) {\n    RValue Len = CGF.EmitAnyExpr(C->getSafelen(), AggValueSlot::ignored(),\n                                 /*ignoreResult=*/true);\n    auto *Val = cast<llvm::ConstantInt>(Len.getScalarVal());\n    CGF.LoopStack.setVectorizeWidth(Val->getZExtValue());\n    // In presence of finite 'safelen', it may be unsafe to mark all\n    // the memory instructions parallel, because loop-carried\n    // dependences of 'safelen' iterations are possible.\n    CGF.LoopStack.setParallel(/*Enable=*/false);\n  }\n}\n\nvoid CodeGenFunction::EmitOMPSimdInit(const OMPLoopDirective &D,\n                                      bool IsMonotonic) {\n  // Walk clauses and process safelen/lastprivate.\n  LoopStack.setParallel(!IsMonotonic);\n  LoopStack.setVectorizeEnable();\n  emitSimdlenSafelenClause(*this, D, IsMonotonic);\n  if (const auto *C = D.getSingleClause<OMPOrderClause>())\n    if (C->getKind() == OMPC_ORDER_concurrent)\n      LoopStack.setParallel(/*Enable=*/true);\n  if ((D.getDirectiveKind() == OMPD_simd ||\n       (getLangOpts().OpenMPSimd &&\n        isOpenMPSimdDirective(D.getDirectiveKind()))) &&\n      llvm::any_of(D.getClausesOfKind<OMPReductionClause>(),\n                   [](const OMPReductionClause *C) {\n                     return C->getModifier() == OMPC_REDUCTION_inscan;\n                   }))\n    // Disable parallel access in case of prefix sum.\n    LoopStack.setParallel(/*Enable=*/false);\n}\n\nvoid CodeGenFunction::EmitOMPSimdFinal(\n    const OMPLoopDirective &D,\n    const llvm::function_ref<llvm::Value *(CodeGenFunction &)> CondGen) {\n  if (!HaveInsertPoint())\n    return;\n  llvm::BasicBlock *DoneBB = nullptr;\n  auto IC = D.counters().begin();\n  auto IPC = D.private_counters().begin();\n  for (const Expr *F : D.finals()) {\n    const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>((*IC))->getDecl());\n    const auto *PrivateVD = cast<VarDecl>(cast<DeclRefExpr>((*IPC))->getDecl());\n    const auto *CED = dyn_cast<OMPCapturedExprDecl>(OrigVD);\n    if (LocalDeclMap.count(OrigVD) || CapturedStmtInfo->lookup(OrigVD) ||\n        OrigVD->hasGlobalStorage() || CED) {\n      if (!DoneBB) {\n        if (llvm::Value *Cond = CondGen(*this)) {\n          // If the first post-update expression is found, emit conditional\n          // block if it was requested.\n          llvm::BasicBlock *ThenBB = createBasicBlock(\".omp.final.then\");\n          DoneBB = createBasicBlock(\".omp.final.done\");\n          Builder.CreateCondBr(Cond, ThenBB, DoneBB);\n          EmitBlock(ThenBB);\n        }\n      }\n      Address OrigAddr = Address::invalid();\n      if (CED) {\n        OrigAddr =\n            EmitLValue(CED->getInit()->IgnoreImpCasts()).getAddress(*this);\n      } else {\n        DeclRefExpr DRE(getContext(), const_cast<VarDecl *>(PrivateVD),\n                        /*RefersToEnclosingVariableOrCapture=*/false,\n                        (*IPC)->getType(), VK_LValue, (*IPC)->getExprLoc());\n        OrigAddr = EmitLValue(&DRE).getAddress(*this);\n      }\n      OMPPrivateScope VarScope(*this);\n      VarScope.addPrivate(OrigVD, [OrigAddr]() { return OrigAddr; });\n      (void)VarScope.Privatize();\n      EmitIgnoredExpr(F);\n    }\n    ++IC;\n    ++IPC;\n  }\n  if (DoneBB)\n    EmitBlock(DoneBB, /*IsFinished=*/true);\n}\n\nstatic void emitOMPLoopBodyWithStopPoint(CodeGenFunction &CGF,\n                                         const OMPLoopDirective &S,\n                                         CodeGenFunction::JumpDest LoopExit) {\n  CGF.EmitOMPLoopBody(S, LoopExit);\n  CGF.EmitStopPoint(&S);\n}\n\n/// Emit a helper variable and return corresponding lvalue.\nstatic LValue EmitOMPHelperVar(CodeGenFunction &CGF,\n                               const DeclRefExpr *Helper) {\n  auto VDecl = cast<VarDecl>(Helper->getDecl());\n  CGF.EmitVarDecl(*VDecl);\n  return CGF.EmitLValue(Helper);\n}\n\nstatic void emitCommonSimdLoop(CodeGenFunction &CGF, const OMPLoopDirective &S,\n                               const RegionCodeGenTy &SimdInitGen,\n                               const RegionCodeGenTy &BodyCodeGen) {\n  auto &&ThenGen = [&S, &SimdInitGen, &BodyCodeGen](CodeGenFunction &CGF,\n                                                    PrePostActionTy &) {\n    CGOpenMPRuntime::NontemporalDeclsRAII NontemporalsRegion(CGF.CGM, S);\n    CodeGenFunction::OMPLocalDeclMapRAII Scope(CGF);\n    SimdInitGen(CGF);\n\n    BodyCodeGen(CGF);\n  };\n  auto &&ElseGen = [&BodyCodeGen](CodeGenFunction &CGF, PrePostActionTy &) {\n    CodeGenFunction::OMPLocalDeclMapRAII Scope(CGF);\n    CGF.LoopStack.setVectorizeEnable(/*Enable=*/false);\n\n    BodyCodeGen(CGF);\n  };\n  const Expr *IfCond = nullptr;\n  if (isOpenMPSimdDirective(S.getDirectiveKind())) {\n    for (const auto *C : S.getClausesOfKind<OMPIfClause>()) {\n      if (CGF.getLangOpts().OpenMP >= 50 &&\n          (C->getNameModifier() == OMPD_unknown ||\n           C->getNameModifier() == OMPD_simd)) {\n        IfCond = C->getCondition();\n        break;\n      }\n    }\n  }\n  if (IfCond) {\n    CGF.CGM.getOpenMPRuntime().emitIfClause(CGF, IfCond, ThenGen, ElseGen);\n  } else {\n    RegionCodeGenTy ThenRCG(ThenGen);\n    ThenRCG(CGF);\n  }\n}\n\nstatic void emitOMPSimdRegion(CodeGenFunction &CGF, const OMPLoopDirective &S,\n                              PrePostActionTy &Action) {\n  Action.Enter(CGF);\n  assert(isOpenMPSimdDirective(S.getDirectiveKind()) &&\n         \"Expected simd directive\");\n  OMPLoopScope PreInitScope(CGF, S);\n  // if (PreCond) {\n  //   for (IV in 0..LastIteration) BODY;\n  //   <Final counter/linear vars updates>;\n  // }\n  //\n  if (isOpenMPDistributeDirective(S.getDirectiveKind()) ||\n      isOpenMPWorksharingDirective(S.getDirectiveKind()) ||\n      isOpenMPTaskLoopDirective(S.getDirectiveKind())) {\n    (void)EmitOMPHelperVar(CGF, cast<DeclRefExpr>(S.getLowerBoundVariable()));\n    (void)EmitOMPHelperVar(CGF, cast<DeclRefExpr>(S.getUpperBoundVariable()));\n  }\n\n  // Emit: if (PreCond) - begin.\n  // If the condition constant folds and can be elided, avoid emitting the\n  // whole loop.\n  bool CondConstant;\n  llvm::BasicBlock *ContBlock = nullptr;\n  if (CGF.ConstantFoldsToSimpleInteger(S.getPreCond(), CondConstant)) {\n    if (!CondConstant)\n      return;\n  } else {\n    llvm::BasicBlock *ThenBlock = CGF.createBasicBlock(\"simd.if.then\");\n    ContBlock = CGF.createBasicBlock(\"simd.if.end\");\n    emitPreCond(CGF, S, S.getPreCond(), ThenBlock, ContBlock,\n                CGF.getProfileCount(&S));\n    CGF.EmitBlock(ThenBlock);\n    CGF.incrementProfileCounter(&S);\n  }\n\n  // Emit the loop iteration variable.\n  const Expr *IVExpr = S.getIterationVariable();\n  const auto *IVDecl = cast<VarDecl>(cast<DeclRefExpr>(IVExpr)->getDecl());\n  CGF.EmitVarDecl(*IVDecl);\n  CGF.EmitIgnoredExpr(S.getInit());\n\n  // Emit the iterations count variable.\n  // If it is not a variable, Sema decided to calculate iterations count on\n  // each iteration (e.g., it is foldable into a constant).\n  if (const auto *LIExpr = dyn_cast<DeclRefExpr>(S.getLastIteration())) {\n    CGF.EmitVarDecl(*cast<VarDecl>(LIExpr->getDecl()));\n    // Emit calculation of the iterations count.\n    CGF.EmitIgnoredExpr(S.getCalcLastIteration());\n  }\n\n  emitAlignedClause(CGF, S);\n  (void)CGF.EmitOMPLinearClauseInit(S);\n  {\n    CodeGenFunction::OMPPrivateScope LoopScope(CGF);\n    CGF.EmitOMPPrivateLoopCounters(S, LoopScope);\n    CGF.EmitOMPLinearClause(S, LoopScope);\n    CGF.EmitOMPPrivateClause(S, LoopScope);\n    CGF.EmitOMPReductionClauseInit(S, LoopScope);\n    CGOpenMPRuntime::LastprivateConditionalRAII LPCRegion(\n        CGF, S, CGF.EmitLValue(S.getIterationVariable()));\n    bool HasLastprivateClause = CGF.EmitOMPLastprivateClauseInit(S, LoopScope);\n    (void)LoopScope.Privatize();\n    if (isOpenMPTargetExecutionDirective(S.getDirectiveKind()))\n      CGF.CGM.getOpenMPRuntime().adjustTargetSpecificDataForLambdas(CGF, S);\n\n    emitCommonSimdLoop(\n        CGF, S,\n        [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n          CGF.EmitOMPSimdInit(S);\n        },\n        [&S, &LoopScope](CodeGenFunction &CGF, PrePostActionTy &) {\n          CGF.EmitOMPInnerLoop(\n              S, LoopScope.requiresCleanups(), S.getCond(), S.getInc(),\n              [&S](CodeGenFunction &CGF) {\n                emitOMPLoopBodyWithStopPoint(CGF, S,\n                                             CodeGenFunction::JumpDest());\n              },\n              [](CodeGenFunction &) {});\n        });\n    CGF.EmitOMPSimdFinal(S, [](CodeGenFunction &) { return nullptr; });\n    // Emit final copy of the lastprivate variables at the end of loops.\n    if (HasLastprivateClause)\n      CGF.EmitOMPLastprivateClauseFinal(S, /*NoFinals=*/true);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_simd);\n    emitPostUpdateForReductionClause(CGF, S,\n                                     [](CodeGenFunction &) { return nullptr; });\n  }\n  CGF.EmitOMPLinearClauseFinal(S, [](CodeGenFunction &) { return nullptr; });\n  // Emit: if (PreCond) - end.\n  if (ContBlock) {\n    CGF.EmitBranch(ContBlock);\n    CGF.EmitBlock(ContBlock, true);\n  }\n}\n\nvoid CodeGenFunction::EmitOMPSimdDirective(const OMPSimdDirective &S) {\n  ParentLoopDirectiveForScanRegion ScanRegion(*this, S);\n  OMPFirstScanLoop = true;\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitOMPSimdRegion(CGF, S, Action);\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    OMPLexicalScope Scope(*this, S, OMPD_unknown);\n    CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_simd, CodeGen);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nvoid CodeGenFunction::EmitOMPTileDirective(const OMPTileDirective &S) {\n  // Emit the de-sugared statement.\n  OMPTransformDirectiveScopeRAII TileScope(*this, &S);\n  EmitStmt(S.getTransformedStmt());\n}\n\nvoid CodeGenFunction::EmitOMPOuterLoop(\n    bool DynamicOrOrdered, bool IsMonotonic, const OMPLoopDirective &S,\n    CodeGenFunction::OMPPrivateScope &LoopScope,\n    const CodeGenFunction::OMPLoopArguments &LoopArgs,\n    const CodeGenFunction::CodeGenLoopTy &CodeGenLoop,\n    const CodeGenFunction::CodeGenOrderedTy &CodeGenOrdered) {\n  CGOpenMPRuntime &RT = CGM.getOpenMPRuntime();\n\n  const Expr *IVExpr = S.getIterationVariable();\n  const unsigned IVSize = getContext().getTypeSize(IVExpr->getType());\n  const bool IVSigned = IVExpr->getType()->hasSignedIntegerRepresentation();\n\n  JumpDest LoopExit = getJumpDestInCurrentScope(\"omp.dispatch.end\");\n\n  // Start the loop with a block that tests the condition.\n  llvm::BasicBlock *CondBlock = createBasicBlock(\"omp.dispatch.cond\");\n  EmitBlock(CondBlock);\n  const SourceRange R = S.getSourceRange();\n  OMPLoopNestStack.clear();\n  LoopStack.push(CondBlock, SourceLocToDebugLoc(R.getBegin()),\n                 SourceLocToDebugLoc(R.getEnd()));\n\n  llvm::Value *BoolCondVal = nullptr;\n  if (!DynamicOrOrdered) {\n    // UB = min(UB, GlobalUB) or\n    // UB = min(UB, PrevUB) for combined loop sharing constructs (e.g.\n    // 'distribute parallel for')\n    EmitIgnoredExpr(LoopArgs.EUB);\n    // IV = LB\n    EmitIgnoredExpr(LoopArgs.Init);\n    // IV < UB\n    BoolCondVal = EvaluateExprAsBool(LoopArgs.Cond);\n  } else {\n    BoolCondVal =\n        RT.emitForNext(*this, S.getBeginLoc(), IVSize, IVSigned, LoopArgs.IL,\n                       LoopArgs.LB, LoopArgs.UB, LoopArgs.ST);\n  }\n\n  // If there are any cleanups between here and the loop-exit scope,\n  // create a block to stage a loop exit along.\n  llvm::BasicBlock *ExitBlock = LoopExit.getBlock();\n  if (LoopScope.requiresCleanups())\n    ExitBlock = createBasicBlock(\"omp.dispatch.cleanup\");\n\n  llvm::BasicBlock *LoopBody = createBasicBlock(\"omp.dispatch.body\");\n  Builder.CreateCondBr(BoolCondVal, LoopBody, ExitBlock);\n  if (ExitBlock != LoopExit.getBlock()) {\n    EmitBlock(ExitBlock);\n    EmitBranchThroughCleanup(LoopExit);\n  }\n  EmitBlock(LoopBody);\n\n  // Emit \"IV = LB\" (in case of static schedule, we have already calculated new\n  // LB for loop condition and emitted it above).\n  if (DynamicOrOrdered)\n    EmitIgnoredExpr(LoopArgs.Init);\n\n  // Create a block for the increment.\n  JumpDest Continue = getJumpDestInCurrentScope(\"omp.dispatch.inc\");\n  BreakContinueStack.push_back(BreakContinue(LoopExit, Continue));\n\n  emitCommonSimdLoop(\n      *this, S,\n      [&S, IsMonotonic](CodeGenFunction &CGF, PrePostActionTy &) {\n        // Generate !llvm.loop.parallel metadata for loads and stores for loops\n        // with dynamic/guided scheduling and without ordered clause.\n        if (!isOpenMPSimdDirective(S.getDirectiveKind())) {\n          CGF.LoopStack.setParallel(!IsMonotonic);\n          if (const auto *C = S.getSingleClause<OMPOrderClause>())\n            if (C->getKind() == OMPC_ORDER_concurrent)\n              CGF.LoopStack.setParallel(/*Enable=*/true);\n        } else {\n          CGF.EmitOMPSimdInit(S, IsMonotonic);\n        }\n      },\n      [&S, &LoopArgs, LoopExit, &CodeGenLoop, IVSize, IVSigned, &CodeGenOrdered,\n       &LoopScope](CodeGenFunction &CGF, PrePostActionTy &) {\n        SourceLocation Loc = S.getBeginLoc();\n        // when 'distribute' is not combined with a 'for':\n        // while (idx <= UB) { BODY; ++idx; }\n        // when 'distribute' is combined with a 'for'\n        // (e.g. 'distribute parallel for')\n        // while (idx <= UB) { <CodeGen rest of pragma>; idx += ST; }\n        CGF.EmitOMPInnerLoop(\n            S, LoopScope.requiresCleanups(), LoopArgs.Cond, LoopArgs.IncExpr,\n            [&S, LoopExit, &CodeGenLoop](CodeGenFunction &CGF) {\n              CodeGenLoop(CGF, S, LoopExit);\n            },\n            [IVSize, IVSigned, Loc, &CodeGenOrdered](CodeGenFunction &CGF) {\n              CodeGenOrdered(CGF, Loc, IVSize, IVSigned);\n            });\n      });\n\n  EmitBlock(Continue.getBlock());\n  BreakContinueStack.pop_back();\n  if (!DynamicOrOrdered) {\n    // Emit \"LB = LB + Stride\", \"UB = UB + Stride\".\n    EmitIgnoredExpr(LoopArgs.NextLB);\n    EmitIgnoredExpr(LoopArgs.NextUB);\n  }\n\n  EmitBranch(CondBlock);\n  OMPLoopNestStack.clear();\n  LoopStack.pop();\n  // Emit the fall-through block.\n  EmitBlock(LoopExit.getBlock());\n\n  // Tell the runtime we are done.\n  auto &&CodeGen = [DynamicOrOrdered, &S](CodeGenFunction &CGF) {\n    if (!DynamicOrOrdered)\n      CGF.CGM.getOpenMPRuntime().emitForStaticFinish(CGF, S.getEndLoc(),\n                                                     S.getDirectiveKind());\n  };\n  OMPCancelStack.emitExit(*this, S.getDirectiveKind(), CodeGen);\n}\n\nvoid CodeGenFunction::EmitOMPForOuterLoop(\n    const OpenMPScheduleTy &ScheduleKind, bool IsMonotonic,\n    const OMPLoopDirective &S, OMPPrivateScope &LoopScope, bool Ordered,\n    const OMPLoopArguments &LoopArgs,\n    const CodeGenDispatchBoundsTy &CGDispatchBounds) {\n  CGOpenMPRuntime &RT = CGM.getOpenMPRuntime();\n\n  // Dynamic scheduling of the outer loop (dynamic, guided, auto, runtime).\n  const bool DynamicOrOrdered =\n      Ordered || RT.isDynamic(ScheduleKind.Schedule);\n\n  assert((Ordered ||\n          !RT.isStaticNonchunked(ScheduleKind.Schedule,\n                                 LoopArgs.Chunk != nullptr)) &&\n         \"static non-chunked schedule does not need outer loop\");\n\n  // Emit outer loop.\n  //\n  // OpenMP [2.7.1, Loop Construct, Description, table 2-1]\n  // When schedule(dynamic,chunk_size) is specified, the iterations are\n  // distributed to threads in the team in chunks as the threads request them.\n  // Each thread executes a chunk of iterations, then requests another chunk,\n  // until no chunks remain to be distributed. Each chunk contains chunk_size\n  // iterations, except for the last chunk to be distributed, which may have\n  // fewer iterations. When no chunk_size is specified, it defaults to 1.\n  //\n  // When schedule(guided,chunk_size) is specified, the iterations are assigned\n  // to threads in the team in chunks as the executing threads request them.\n  // Each thread executes a chunk of iterations, then requests another chunk,\n  // until no chunks remain to be assigned. For a chunk_size of 1, the size of\n  // each chunk is proportional to the number of unassigned iterations divided\n  // by the number of threads in the team, decreasing to 1. For a chunk_size\n  // with value k (greater than 1), the size of each chunk is determined in the\n  // same way, with the restriction that the chunks do not contain fewer than k\n  // iterations (except for the last chunk to be assigned, which may have fewer\n  // than k iterations).\n  //\n  // When schedule(auto) is specified, the decision regarding scheduling is\n  // delegated to the compiler and/or runtime system. The programmer gives the\n  // implementation the freedom to choose any possible mapping of iterations to\n  // threads in the team.\n  //\n  // When schedule(runtime) is specified, the decision regarding scheduling is\n  // deferred until run time, and the schedule and chunk size are taken from the\n  // run-sched-var ICV. If the ICV is set to auto, the schedule is\n  // implementation defined\n  //\n  // while(__kmpc_dispatch_next(&LB, &UB)) {\n  //   idx = LB;\n  //   while (idx <= UB) { BODY; ++idx;\n  //   __kmpc_dispatch_fini_(4|8)[u](); // For ordered loops only.\n  //   } // inner loop\n  // }\n  //\n  // OpenMP [2.7.1, Loop Construct, Description, table 2-1]\n  // When schedule(static, chunk_size) is specified, iterations are divided into\n  // chunks of size chunk_size, and the chunks are assigned to the threads in\n  // the team in a round-robin fashion in the order of the thread number.\n  //\n  // while(UB = min(UB, GlobalUB), idx = LB, idx < UB) {\n  //   while (idx <= UB) { BODY; ++idx; } // inner loop\n  //   LB = LB + ST;\n  //   UB = UB + ST;\n  // }\n  //\n\n  const Expr *IVExpr = S.getIterationVariable();\n  const unsigned IVSize = getContext().getTypeSize(IVExpr->getType());\n  const bool IVSigned = IVExpr->getType()->hasSignedIntegerRepresentation();\n\n  if (DynamicOrOrdered) {\n    const std::pair<llvm::Value *, llvm::Value *> DispatchBounds =\n        CGDispatchBounds(*this, S, LoopArgs.LB, LoopArgs.UB);\n    llvm::Value *LBVal = DispatchBounds.first;\n    llvm::Value *UBVal = DispatchBounds.second;\n    CGOpenMPRuntime::DispatchRTInput DipatchRTInputValues = {LBVal, UBVal,\n                                                             LoopArgs.Chunk};\n    RT.emitForDispatchInit(*this, S.getBeginLoc(), ScheduleKind, IVSize,\n                           IVSigned, Ordered, DipatchRTInputValues);\n  } else {\n    CGOpenMPRuntime::StaticRTInput StaticInit(\n        IVSize, IVSigned, Ordered, LoopArgs.IL, LoopArgs.LB, LoopArgs.UB,\n        LoopArgs.ST, LoopArgs.Chunk);\n    RT.emitForStaticInit(*this, S.getBeginLoc(), S.getDirectiveKind(),\n                         ScheduleKind, StaticInit);\n  }\n\n  auto &&CodeGenOrdered = [Ordered](CodeGenFunction &CGF, SourceLocation Loc,\n                                    const unsigned IVSize,\n                                    const bool IVSigned) {\n    if (Ordered) {\n      CGF.CGM.getOpenMPRuntime().emitForOrderedIterationEnd(CGF, Loc, IVSize,\n                                                            IVSigned);\n    }\n  };\n\n  OMPLoopArguments OuterLoopArgs(LoopArgs.LB, LoopArgs.UB, LoopArgs.ST,\n                                 LoopArgs.IL, LoopArgs.Chunk, LoopArgs.EUB);\n  OuterLoopArgs.IncExpr = S.getInc();\n  OuterLoopArgs.Init = S.getInit();\n  OuterLoopArgs.Cond = S.getCond();\n  OuterLoopArgs.NextLB = S.getNextLowerBound();\n  OuterLoopArgs.NextUB = S.getNextUpperBound();\n  EmitOMPOuterLoop(DynamicOrOrdered, IsMonotonic, S, LoopScope, OuterLoopArgs,\n                   emitOMPLoopBodyWithStopPoint, CodeGenOrdered);\n}\n\nstatic void emitEmptyOrdered(CodeGenFunction &, SourceLocation Loc,\n                             const unsigned IVSize, const bool IVSigned) {}\n\nvoid CodeGenFunction::EmitOMPDistributeOuterLoop(\n    OpenMPDistScheduleClauseKind ScheduleKind, const OMPLoopDirective &S,\n    OMPPrivateScope &LoopScope, const OMPLoopArguments &LoopArgs,\n    const CodeGenLoopTy &CodeGenLoopContent) {\n\n  CGOpenMPRuntime &RT = CGM.getOpenMPRuntime();\n\n  // Emit outer loop.\n  // Same behavior as a OMPForOuterLoop, except that schedule cannot be\n  // dynamic\n  //\n\n  const Expr *IVExpr = S.getIterationVariable();\n  const unsigned IVSize = getContext().getTypeSize(IVExpr->getType());\n  const bool IVSigned = IVExpr->getType()->hasSignedIntegerRepresentation();\n\n  CGOpenMPRuntime::StaticRTInput StaticInit(\n      IVSize, IVSigned, /* Ordered = */ false, LoopArgs.IL, LoopArgs.LB,\n      LoopArgs.UB, LoopArgs.ST, LoopArgs.Chunk);\n  RT.emitDistributeStaticInit(*this, S.getBeginLoc(), ScheduleKind, StaticInit);\n\n  // for combined 'distribute' and 'for' the increment expression of distribute\n  // is stored in DistInc. For 'distribute' alone, it is in Inc.\n  Expr *IncExpr;\n  if (isOpenMPLoopBoundSharingDirective(S.getDirectiveKind()))\n    IncExpr = S.getDistInc();\n  else\n    IncExpr = S.getInc();\n\n  // this routine is shared by 'omp distribute parallel for' and\n  // 'omp distribute': select the right EUB expression depending on the\n  // directive\n  OMPLoopArguments OuterLoopArgs;\n  OuterLoopArgs.LB = LoopArgs.LB;\n  OuterLoopArgs.UB = LoopArgs.UB;\n  OuterLoopArgs.ST = LoopArgs.ST;\n  OuterLoopArgs.IL = LoopArgs.IL;\n  OuterLoopArgs.Chunk = LoopArgs.Chunk;\n  OuterLoopArgs.EUB = isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                          ? S.getCombinedEnsureUpperBound()\n                          : S.getEnsureUpperBound();\n  OuterLoopArgs.IncExpr = IncExpr;\n  OuterLoopArgs.Init = isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                           ? S.getCombinedInit()\n                           : S.getInit();\n  OuterLoopArgs.Cond = isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                           ? S.getCombinedCond()\n                           : S.getCond();\n  OuterLoopArgs.NextLB = isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                             ? S.getCombinedNextLowerBound()\n                             : S.getNextLowerBound();\n  OuterLoopArgs.NextUB = isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                             ? S.getCombinedNextUpperBound()\n                             : S.getNextUpperBound();\n\n  EmitOMPOuterLoop(/* DynamicOrOrdered = */ false, /* IsMonotonic = */ false, S,\n                   LoopScope, OuterLoopArgs, CodeGenLoopContent,\n                   emitEmptyOrdered);\n}\n\nstatic std::pair<LValue, LValue>\nemitDistributeParallelForInnerBounds(CodeGenFunction &CGF,\n                                     const OMPExecutableDirective &S) {\n  const OMPLoopDirective &LS = cast<OMPLoopDirective>(S);\n  LValue LB =\n      EmitOMPHelperVar(CGF, cast<DeclRefExpr>(LS.getLowerBoundVariable()));\n  LValue UB =\n      EmitOMPHelperVar(CGF, cast<DeclRefExpr>(LS.getUpperBoundVariable()));\n\n  // When composing 'distribute' with 'for' (e.g. as in 'distribute\n  // parallel for') we need to use the 'distribute'\n  // chunk lower and upper bounds rather than the whole loop iteration\n  // space. These are parameters to the outlined function for 'parallel'\n  // and we copy the bounds of the previous schedule into the\n  // the current ones.\n  LValue PrevLB = CGF.EmitLValue(LS.getPrevLowerBoundVariable());\n  LValue PrevUB = CGF.EmitLValue(LS.getPrevUpperBoundVariable());\n  llvm::Value *PrevLBVal = CGF.EmitLoadOfScalar(\n      PrevLB, LS.getPrevLowerBoundVariable()->getExprLoc());\n  PrevLBVal = CGF.EmitScalarConversion(\n      PrevLBVal, LS.getPrevLowerBoundVariable()->getType(),\n      LS.getIterationVariable()->getType(),\n      LS.getPrevLowerBoundVariable()->getExprLoc());\n  llvm::Value *PrevUBVal = CGF.EmitLoadOfScalar(\n      PrevUB, LS.getPrevUpperBoundVariable()->getExprLoc());\n  PrevUBVal = CGF.EmitScalarConversion(\n      PrevUBVal, LS.getPrevUpperBoundVariable()->getType(),\n      LS.getIterationVariable()->getType(),\n      LS.getPrevUpperBoundVariable()->getExprLoc());\n\n  CGF.EmitStoreOfScalar(PrevLBVal, LB);\n  CGF.EmitStoreOfScalar(PrevUBVal, UB);\n\n  return {LB, UB};\n}\n\n/// if the 'for' loop has a dispatch schedule (e.g. dynamic, guided) then\n/// we need to use the LB and UB expressions generated by the worksharing\n/// code generation support, whereas in non combined situations we would\n/// just emit 0 and the LastIteration expression\n/// This function is necessary due to the difference of the LB and UB\n/// types for the RT emission routines for 'for_static_init' and\n/// 'for_dispatch_init'\nstatic std::pair<llvm::Value *, llvm::Value *>\nemitDistributeParallelForDispatchBounds(CodeGenFunction &CGF,\n                                        const OMPExecutableDirective &S,\n                                        Address LB, Address UB) {\n  const OMPLoopDirective &LS = cast<OMPLoopDirective>(S);\n  const Expr *IVExpr = LS.getIterationVariable();\n  // when implementing a dynamic schedule for a 'for' combined with a\n  // 'distribute' (e.g. 'distribute parallel for'), the 'for' loop\n  // is not normalized as each team only executes its own assigned\n  // distribute chunk\n  QualType IteratorTy = IVExpr->getType();\n  llvm::Value *LBVal =\n      CGF.EmitLoadOfScalar(LB, /*Volatile=*/false, IteratorTy, S.getBeginLoc());\n  llvm::Value *UBVal =\n      CGF.EmitLoadOfScalar(UB, /*Volatile=*/false, IteratorTy, S.getBeginLoc());\n  return {LBVal, UBVal};\n}\n\nstatic void emitDistributeParallelForDistributeInnerBoundParams(\n    CodeGenFunction &CGF, const OMPExecutableDirective &S,\n    llvm::SmallVectorImpl<llvm::Value *> &CapturedVars) {\n  const auto &Dir = cast<OMPLoopDirective>(S);\n  LValue LB =\n      CGF.EmitLValue(cast<DeclRefExpr>(Dir.getCombinedLowerBoundVariable()));\n  llvm::Value *LBCast =\n      CGF.Builder.CreateIntCast(CGF.Builder.CreateLoad(LB.getAddress(CGF)),\n                                CGF.SizeTy, /*isSigned=*/false);\n  CapturedVars.push_back(LBCast);\n  LValue UB =\n      CGF.EmitLValue(cast<DeclRefExpr>(Dir.getCombinedUpperBoundVariable()));\n\n  llvm::Value *UBCast =\n      CGF.Builder.CreateIntCast(CGF.Builder.CreateLoad(UB.getAddress(CGF)),\n                                CGF.SizeTy, /*isSigned=*/false);\n  CapturedVars.push_back(UBCast);\n}\n\nstatic void\nemitInnerParallelForWhenCombined(CodeGenFunction &CGF,\n                                 const OMPLoopDirective &S,\n                                 CodeGenFunction::JumpDest LoopExit) {\n  auto &&CGInlinedWorksharingLoop = [&S](CodeGenFunction &CGF,\n                                         PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    bool HasCancel = false;\n    if (!isOpenMPSimdDirective(S.getDirectiveKind())) {\n      if (const auto *D = dyn_cast<OMPTeamsDistributeParallelForDirective>(&S))\n        HasCancel = D->hasCancel();\n      else if (const auto *D = dyn_cast<OMPDistributeParallelForDirective>(&S))\n        HasCancel = D->hasCancel();\n      else if (const auto *D =\n                   dyn_cast<OMPTargetTeamsDistributeParallelForDirective>(&S))\n        HasCancel = D->hasCancel();\n    }\n    CodeGenFunction::OMPCancelStackRAII CancelRegion(CGF, S.getDirectiveKind(),\n                                                     HasCancel);\n    CGF.EmitOMPWorksharingLoop(S, S.getPrevEnsureUpperBound(),\n                               emitDistributeParallelForInnerBounds,\n                               emitDistributeParallelForDispatchBounds);\n  };\n\n  emitCommonOMPParallelDirective(\n      CGF, S,\n      isOpenMPSimdDirective(S.getDirectiveKind()) ? OMPD_for_simd : OMPD_for,\n      CGInlinedWorksharingLoop,\n      emitDistributeParallelForDistributeInnerBoundParams);\n}\n\nvoid CodeGenFunction::EmitOMPDistributeParallelForDirective(\n    const OMPDistributeParallelForDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitInnerParallelForWhenCombined,\n                              S.getDistInc());\n  };\n  OMPLexicalScope Scope(*this, S, OMPD_parallel);\n  CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_distribute, CodeGen);\n}\n\nvoid CodeGenFunction::EmitOMPDistributeParallelForSimdDirective(\n    const OMPDistributeParallelForSimdDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitInnerParallelForWhenCombined,\n                              S.getDistInc());\n  };\n  OMPLexicalScope Scope(*this, S, OMPD_parallel);\n  CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_distribute, CodeGen);\n}\n\nvoid CodeGenFunction::EmitOMPDistributeSimdDirective(\n    const OMPDistributeSimdDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitOMPLoopBodyWithStopPoint, S.getInc());\n  };\n  OMPLexicalScope Scope(*this, S, OMPD_unknown);\n  CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_simd, CodeGen);\n}\n\nvoid CodeGenFunction::EmitOMPTargetSimdDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName, const OMPTargetSimdDirective &S) {\n  // Emit SPMD target parallel for region as a standalone region.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitOMPSimdRegion(CGF, S, Action);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetSimdDirective(\n    const OMPTargetSimdDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitOMPSimdRegion(CGF, S, Action);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nnamespace {\n  struct ScheduleKindModifiersTy {\n    OpenMPScheduleClauseKind Kind;\n    OpenMPScheduleClauseModifier M1;\n    OpenMPScheduleClauseModifier M2;\n    ScheduleKindModifiersTy(OpenMPScheduleClauseKind Kind,\n                            OpenMPScheduleClauseModifier M1,\n                            OpenMPScheduleClauseModifier M2)\n        : Kind(Kind), M1(M1), M2(M2) {}\n  };\n} // namespace\n\nbool CodeGenFunction::EmitOMPWorksharingLoop(\n    const OMPLoopDirective &S, Expr *EUB,\n    const CodeGenLoopBoundsTy &CodeGenLoopBounds,\n    const CodeGenDispatchBoundsTy &CGDispatchBounds) {\n  // Emit the loop iteration variable.\n  const auto *IVExpr = cast<DeclRefExpr>(S.getIterationVariable());\n  const auto *IVDecl = cast<VarDecl>(IVExpr->getDecl());\n  EmitVarDecl(*IVDecl);\n\n  // Emit the iterations count variable.\n  // If it is not a variable, Sema decided to calculate iterations count on each\n  // iteration (e.g., it is foldable into a constant).\n  if (const auto *LIExpr = dyn_cast<DeclRefExpr>(S.getLastIteration())) {\n    EmitVarDecl(*cast<VarDecl>(LIExpr->getDecl()));\n    // Emit calculation of the iterations count.\n    EmitIgnoredExpr(S.getCalcLastIteration());\n  }\n\n  CGOpenMPRuntime &RT = CGM.getOpenMPRuntime();\n\n  bool HasLastprivateClause;\n  // Check pre-condition.\n  {\n    OMPLoopScope PreInitScope(*this, S);\n    // Skip the entire loop if we don't meet the precondition.\n    // If the condition constant folds and can be elided, avoid emitting the\n    // whole loop.\n    bool CondConstant;\n    llvm::BasicBlock *ContBlock = nullptr;\n    if (ConstantFoldsToSimpleInteger(S.getPreCond(), CondConstant)) {\n      if (!CondConstant)\n        return false;\n    } else {\n      llvm::BasicBlock *ThenBlock = createBasicBlock(\"omp.precond.then\");\n      ContBlock = createBasicBlock(\"omp.precond.end\");\n      emitPreCond(*this, S, S.getPreCond(), ThenBlock, ContBlock,\n                  getProfileCount(&S));\n      EmitBlock(ThenBlock);\n      incrementProfileCounter(&S);\n    }\n\n    RunCleanupsScope DoacrossCleanupScope(*this);\n    bool Ordered = false;\n    if (const auto *OrderedClause = S.getSingleClause<OMPOrderedClause>()) {\n      if (OrderedClause->getNumForLoops())\n        RT.emitDoacrossInit(*this, S, OrderedClause->getLoopNumIterations());\n      else\n        Ordered = true;\n    }\n\n    llvm::DenseSet<const Expr *> EmittedFinals;\n    emitAlignedClause(*this, S);\n    bool HasLinears = EmitOMPLinearClauseInit(S);\n    // Emit helper vars inits.\n\n    std::pair<LValue, LValue> Bounds = CodeGenLoopBounds(*this, S);\n    LValue LB = Bounds.first;\n    LValue UB = Bounds.second;\n    LValue ST =\n        EmitOMPHelperVar(*this, cast<DeclRefExpr>(S.getStrideVariable()));\n    LValue IL =\n        EmitOMPHelperVar(*this, cast<DeclRefExpr>(S.getIsLastIterVariable()));\n\n    // Emit 'then' code.\n    {\n      OMPPrivateScope LoopScope(*this);\n      if (EmitOMPFirstprivateClause(S, LoopScope) || HasLinears) {\n        // Emit implicit barrier to synchronize threads and avoid data races on\n        // initialization of firstprivate variables and post-update of\n        // lastprivate variables.\n        CGM.getOpenMPRuntime().emitBarrierCall(\n            *this, S.getBeginLoc(), OMPD_unknown, /*EmitChecks=*/false,\n            /*ForceSimpleCall=*/true);\n      }\n      EmitOMPPrivateClause(S, LoopScope);\n      CGOpenMPRuntime::LastprivateConditionalRAII LPCRegion(\n          *this, S, EmitLValue(S.getIterationVariable()));\n      HasLastprivateClause = EmitOMPLastprivateClauseInit(S, LoopScope);\n      EmitOMPReductionClauseInit(S, LoopScope);\n      EmitOMPPrivateLoopCounters(S, LoopScope);\n      EmitOMPLinearClause(S, LoopScope);\n      (void)LoopScope.Privatize();\n      if (isOpenMPTargetExecutionDirective(S.getDirectiveKind()))\n        CGM.getOpenMPRuntime().adjustTargetSpecificDataForLambdas(*this, S);\n\n      // Detect the loop schedule kind and chunk.\n      const Expr *ChunkExpr = nullptr;\n      OpenMPScheduleTy ScheduleKind;\n      if (const auto *C = S.getSingleClause<OMPScheduleClause>()) {\n        ScheduleKind.Schedule = C->getScheduleKind();\n        ScheduleKind.M1 = C->getFirstScheduleModifier();\n        ScheduleKind.M2 = C->getSecondScheduleModifier();\n        ChunkExpr = C->getChunkSize();\n      } else {\n        // Default behaviour for schedule clause.\n        CGM.getOpenMPRuntime().getDefaultScheduleAndChunk(\n            *this, S, ScheduleKind.Schedule, ChunkExpr);\n      }\n      bool HasChunkSizeOne = false;\n      llvm::Value *Chunk = nullptr;\n      if (ChunkExpr) {\n        Chunk = EmitScalarExpr(ChunkExpr);\n        Chunk = EmitScalarConversion(Chunk, ChunkExpr->getType(),\n                                     S.getIterationVariable()->getType(),\n                                     S.getBeginLoc());\n        Expr::EvalResult Result;\n        if (ChunkExpr->EvaluateAsInt(Result, getContext())) {\n          llvm::APSInt EvaluatedChunk = Result.Val.getInt();\n          HasChunkSizeOne = (EvaluatedChunk.getLimitedValue() == 1);\n        }\n      }\n      const unsigned IVSize = getContext().getTypeSize(IVExpr->getType());\n      const bool IVSigned = IVExpr->getType()->hasSignedIntegerRepresentation();\n      // OpenMP 4.5, 2.7.1 Loop Construct, Description.\n      // If the static schedule kind is specified or if the ordered clause is\n      // specified, and if no monotonic modifier is specified, the effect will\n      // be as if the monotonic modifier was specified.\n      bool StaticChunkedOne = RT.isStaticChunked(ScheduleKind.Schedule,\n          /* Chunked */ Chunk != nullptr) && HasChunkSizeOne &&\n          isOpenMPLoopBoundSharingDirective(S.getDirectiveKind());\n      bool IsMonotonic =\n          Ordered ||\n          ((ScheduleKind.Schedule == OMPC_SCHEDULE_static ||\n            ScheduleKind.Schedule == OMPC_SCHEDULE_unknown) &&\n           !(ScheduleKind.M1 == OMPC_SCHEDULE_MODIFIER_nonmonotonic ||\n             ScheduleKind.M2 == OMPC_SCHEDULE_MODIFIER_nonmonotonic)) ||\n          ScheduleKind.M1 == OMPC_SCHEDULE_MODIFIER_monotonic ||\n          ScheduleKind.M2 == OMPC_SCHEDULE_MODIFIER_monotonic;\n      if ((RT.isStaticNonchunked(ScheduleKind.Schedule,\n                                 /* Chunked */ Chunk != nullptr) ||\n           StaticChunkedOne) &&\n          !Ordered) {\n        JumpDest LoopExit =\n            getJumpDestInCurrentScope(createBasicBlock(\"omp.loop.exit\"));\n        emitCommonSimdLoop(\n            *this, S,\n            [&S, IsMonotonic](CodeGenFunction &CGF, PrePostActionTy &) {\n              if (isOpenMPSimdDirective(S.getDirectiveKind())) {\n                CGF.EmitOMPSimdInit(S, IsMonotonic);\n              } else if (const auto *C = S.getSingleClause<OMPOrderClause>()) {\n                if (C->getKind() == OMPC_ORDER_concurrent)\n                  CGF.LoopStack.setParallel(/*Enable=*/true);\n              }\n            },\n            [IVSize, IVSigned, Ordered, IL, LB, UB, ST, StaticChunkedOne, Chunk,\n             &S, ScheduleKind, LoopExit,\n             &LoopScope](CodeGenFunction &CGF, PrePostActionTy &) {\n              // OpenMP [2.7.1, Loop Construct, Description, table 2-1]\n              // When no chunk_size is specified, the iteration space is divided\n              // into chunks that are approximately equal in size, and at most\n              // one chunk is distributed to each thread. Note that the size of\n              // the chunks is unspecified in this case.\n              CGOpenMPRuntime::StaticRTInput StaticInit(\n                  IVSize, IVSigned, Ordered, IL.getAddress(CGF),\n                  LB.getAddress(CGF), UB.getAddress(CGF), ST.getAddress(CGF),\n                  StaticChunkedOne ? Chunk : nullptr);\n              CGF.CGM.getOpenMPRuntime().emitForStaticInit(\n                  CGF, S.getBeginLoc(), S.getDirectiveKind(), ScheduleKind,\n                  StaticInit);\n              // UB = min(UB, GlobalUB);\n              if (!StaticChunkedOne)\n                CGF.EmitIgnoredExpr(S.getEnsureUpperBound());\n              // IV = LB;\n              CGF.EmitIgnoredExpr(S.getInit());\n              // For unchunked static schedule generate:\n              //\n              // while (idx <= UB) {\n              //   BODY;\n              //   ++idx;\n              // }\n              //\n              // For static schedule with chunk one:\n              //\n              // while (IV <= PrevUB) {\n              //   BODY;\n              //   IV += ST;\n              // }\n              CGF.EmitOMPInnerLoop(\n                  S, LoopScope.requiresCleanups(),\n                  StaticChunkedOne ? S.getCombinedParForInDistCond()\n                                   : S.getCond(),\n                  StaticChunkedOne ? S.getDistInc() : S.getInc(),\n                  [&S, LoopExit](CodeGenFunction &CGF) {\n                    emitOMPLoopBodyWithStopPoint(CGF, S, LoopExit);\n                  },\n                  [](CodeGenFunction &) {});\n            });\n        EmitBlock(LoopExit.getBlock());\n        // Tell the runtime we are done.\n        auto &&CodeGen = [&S](CodeGenFunction &CGF) {\n          CGF.CGM.getOpenMPRuntime().emitForStaticFinish(CGF, S.getEndLoc(),\n                                                         S.getDirectiveKind());\n        };\n        OMPCancelStack.emitExit(*this, S.getDirectiveKind(), CodeGen);\n      } else {\n        // Emit the outer loop, which requests its work chunk [LB..UB] from\n        // runtime and runs the inner loop to process it.\n        const OMPLoopArguments LoopArguments(\n            LB.getAddress(*this), UB.getAddress(*this), ST.getAddress(*this),\n            IL.getAddress(*this), Chunk, EUB);\n        EmitOMPForOuterLoop(ScheduleKind, IsMonotonic, S, LoopScope, Ordered,\n                            LoopArguments, CGDispatchBounds);\n      }\n      if (isOpenMPSimdDirective(S.getDirectiveKind())) {\n        EmitOMPSimdFinal(S, [IL, &S](CodeGenFunction &CGF) {\n          return CGF.Builder.CreateIsNotNull(\n              CGF.EmitLoadOfScalar(IL, S.getBeginLoc()));\n        });\n      }\n      EmitOMPReductionClauseFinal(\n          S, /*ReductionKind=*/isOpenMPSimdDirective(S.getDirectiveKind())\n                 ? /*Parallel and Simd*/ OMPD_parallel_for_simd\n                 : /*Parallel only*/ OMPD_parallel);\n      // Emit post-update of the reduction variables if IsLastIter != 0.\n      emitPostUpdateForReductionClause(\n          *this, S, [IL, &S](CodeGenFunction &CGF) {\n            return CGF.Builder.CreateIsNotNull(\n                CGF.EmitLoadOfScalar(IL, S.getBeginLoc()));\n          });\n      // Emit final copy of the lastprivate variables if IsLastIter != 0.\n      if (HasLastprivateClause)\n        EmitOMPLastprivateClauseFinal(\n            S, isOpenMPSimdDirective(S.getDirectiveKind()),\n            Builder.CreateIsNotNull(EmitLoadOfScalar(IL, S.getBeginLoc())));\n    }\n    EmitOMPLinearClauseFinal(S, [IL, &S](CodeGenFunction &CGF) {\n      return CGF.Builder.CreateIsNotNull(\n          CGF.EmitLoadOfScalar(IL, S.getBeginLoc()));\n    });\n    DoacrossCleanupScope.ForceCleanup();\n    // We're now done with the loop, so jump to the continuation block.\n    if (ContBlock) {\n      EmitBranch(ContBlock);\n      EmitBlock(ContBlock, /*IsFinished=*/true);\n    }\n  }\n  return HasLastprivateClause;\n}\n\n/// The following two functions generate expressions for the loop lower\n/// and upper bounds in case of static and dynamic (dispatch) schedule\n/// of the associated 'for' or 'distribute' loop.\nstatic std::pair<LValue, LValue>\nemitForLoopBounds(CodeGenFunction &CGF, const OMPExecutableDirective &S) {\n  const auto &LS = cast<OMPLoopDirective>(S);\n  LValue LB =\n      EmitOMPHelperVar(CGF, cast<DeclRefExpr>(LS.getLowerBoundVariable()));\n  LValue UB =\n      EmitOMPHelperVar(CGF, cast<DeclRefExpr>(LS.getUpperBoundVariable()));\n  return {LB, UB};\n}\n\n/// When dealing with dispatch schedules (e.g. dynamic, guided) we do not\n/// consider the lower and upper bound expressions generated by the\n/// worksharing loop support, but we use 0 and the iteration space size as\n/// constants\nstatic std::pair<llvm::Value *, llvm::Value *>\nemitDispatchForLoopBounds(CodeGenFunction &CGF, const OMPExecutableDirective &S,\n                          Address LB, Address UB) {\n  const auto &LS = cast<OMPLoopDirective>(S);\n  const Expr *IVExpr = LS.getIterationVariable();\n  const unsigned IVSize = CGF.getContext().getTypeSize(IVExpr->getType());\n  llvm::Value *LBVal = CGF.Builder.getIntN(IVSize, 0);\n  llvm::Value *UBVal = CGF.EmitScalarExpr(LS.getLastIteration());\n  return {LBVal, UBVal};\n}\n\n/// Emits the code for the directive with inscan reductions.\n/// The code is the following:\n/// \\code\n/// size num_iters = <num_iters>;\n/// <type> buffer[num_iters];\n/// #pragma omp ...\n/// for (i: 0..<num_iters>) {\n///   <input phase>;\n///   buffer[i] = red;\n/// }\n/// for (int k = 0; k != ceil(log2(num_iters)); ++k)\n/// for (size cnt = last_iter; cnt >= pow(2, k); --k)\n///   buffer[i] op= buffer[i-pow(2,k)];\n/// #pragma omp ...\n/// for (0..<num_iters>) {\n///   red = InclusiveScan ? buffer[i] : buffer[i-1];\n///   <scan phase>;\n/// }\n/// \\endcode\nstatic void emitScanBasedDirective(\n    CodeGenFunction &CGF, const OMPLoopDirective &S,\n    llvm::function_ref<llvm::Value *(CodeGenFunction &)> NumIteratorsGen,\n    llvm::function_ref<void(CodeGenFunction &)> FirstGen,\n    llvm::function_ref<void(CodeGenFunction &)> SecondGen) {\n  llvm::Value *OMPScanNumIterations = CGF.Builder.CreateIntCast(\n      NumIteratorsGen(CGF), CGF.SizeTy, /*isSigned=*/false);\n  SmallVector<const Expr *, 4> Shareds;\n  SmallVector<const Expr *, 4> Privates;\n  SmallVector<const Expr *, 4> ReductionOps;\n  SmallVector<const Expr *, 4> LHSs;\n  SmallVector<const Expr *, 4> RHSs;\n  SmallVector<const Expr *, 4> CopyOps;\n  SmallVector<const Expr *, 4> CopyArrayTemps;\n  SmallVector<const Expr *, 4> CopyArrayElems;\n  for (const auto *C : S.getClausesOfKind<OMPReductionClause>()) {\n    assert(C->getModifier() == OMPC_REDUCTION_inscan &&\n           \"Only inscan reductions are expected.\");\n    Shareds.append(C->varlist_begin(), C->varlist_end());\n    Privates.append(C->privates().begin(), C->privates().end());\n    ReductionOps.append(C->reduction_ops().begin(), C->reduction_ops().end());\n    LHSs.append(C->lhs_exprs().begin(), C->lhs_exprs().end());\n    RHSs.append(C->rhs_exprs().begin(), C->rhs_exprs().end());\n    CopyOps.append(C->copy_ops().begin(), C->copy_ops().end());\n    CopyArrayTemps.append(C->copy_array_temps().begin(),\n                          C->copy_array_temps().end());\n    CopyArrayElems.append(C->copy_array_elems().begin(),\n                          C->copy_array_elems().end());\n  }\n  {\n    // Emit buffers for each reduction variables.\n    // ReductionCodeGen is required to emit correctly the code for array\n    // reductions.\n    ReductionCodeGen RedCG(Shareds, Shareds, Privates, ReductionOps);\n    unsigned Count = 0;\n    auto *ITA = CopyArrayTemps.begin();\n    for (const Expr *IRef : Privates) {\n      const auto *PrivateVD = cast<VarDecl>(cast<DeclRefExpr>(IRef)->getDecl());\n      // Emit variably modified arrays, used for arrays/array sections\n      // reductions.\n      if (PrivateVD->getType()->isVariablyModifiedType()) {\n        RedCG.emitSharedOrigLValue(CGF, Count);\n        RedCG.emitAggregateType(CGF, Count);\n      }\n      CodeGenFunction::OpaqueValueMapping DimMapping(\n          CGF,\n          cast<OpaqueValueExpr>(\n              cast<VariableArrayType>((*ITA)->getType()->getAsArrayTypeUnsafe())\n                  ->getSizeExpr()),\n          RValue::get(OMPScanNumIterations));\n      // Emit temp buffer.\n      CGF.EmitVarDecl(*cast<VarDecl>(cast<DeclRefExpr>(*ITA)->getDecl()));\n      ++ITA;\n      ++Count;\n    }\n  }\n  CodeGenFunction::ParentLoopDirectiveForScanRegion ScanRegion(CGF, S);\n  {\n    // Emit loop with input phase:\n    // #pragma omp ...\n    // for (i: 0..<num_iters>) {\n    //   <input phase>;\n    //   buffer[i] = red;\n    // }\n    CGF.OMPFirstScanLoop = true;\n    CodeGenFunction::OMPLocalDeclMapRAII Scope(CGF);\n    FirstGen(CGF);\n  }\n  // Emit prefix reduction:\n  // for (int k = 0; k <= ceil(log2(n)); ++k)\n  llvm::BasicBlock *InputBB = CGF.Builder.GetInsertBlock();\n  llvm::BasicBlock *LoopBB = CGF.createBasicBlock(\"omp.outer.log.scan.body\");\n  llvm::BasicBlock *ExitBB = CGF.createBasicBlock(\"omp.outer.log.scan.exit\");\n  llvm::Function *F = CGF.CGM.getIntrinsic(llvm::Intrinsic::log2, CGF.DoubleTy);\n  llvm::Value *Arg =\n      CGF.Builder.CreateUIToFP(OMPScanNumIterations, CGF.DoubleTy);\n  llvm::Value *LogVal = CGF.EmitNounwindRuntimeCall(F, Arg);\n  F = CGF.CGM.getIntrinsic(llvm::Intrinsic::ceil, CGF.DoubleTy);\n  LogVal = CGF.EmitNounwindRuntimeCall(F, LogVal);\n  LogVal = CGF.Builder.CreateFPToUI(LogVal, CGF.IntTy);\n  llvm::Value *NMin1 = CGF.Builder.CreateNUWSub(\n      OMPScanNumIterations, llvm::ConstantInt::get(CGF.SizeTy, 1));\n  auto DL = ApplyDebugLocation::CreateDefaultArtificial(CGF, S.getBeginLoc());\n  CGF.EmitBlock(LoopBB);\n  auto *Counter = CGF.Builder.CreatePHI(CGF.IntTy, 2);\n  // size pow2k = 1;\n  auto *Pow2K = CGF.Builder.CreatePHI(CGF.SizeTy, 2);\n  Counter->addIncoming(llvm::ConstantInt::get(CGF.IntTy, 0), InputBB);\n  Pow2K->addIncoming(llvm::ConstantInt::get(CGF.SizeTy, 1), InputBB);\n  // for (size i = n - 1; i >= 2 ^ k; --i)\n  //   tmp[i] op= tmp[i-pow2k];\n  llvm::BasicBlock *InnerLoopBB =\n      CGF.createBasicBlock(\"omp.inner.log.scan.body\");\n  llvm::BasicBlock *InnerExitBB =\n      CGF.createBasicBlock(\"omp.inner.log.scan.exit\");\n  llvm::Value *CmpI = CGF.Builder.CreateICmpUGE(NMin1, Pow2K);\n  CGF.Builder.CreateCondBr(CmpI, InnerLoopBB, InnerExitBB);\n  CGF.EmitBlock(InnerLoopBB);\n  auto *IVal = CGF.Builder.CreatePHI(CGF.SizeTy, 2);\n  IVal->addIncoming(NMin1, LoopBB);\n  {\n    CodeGenFunction::OMPPrivateScope PrivScope(CGF);\n    auto *ILHS = LHSs.begin();\n    auto *IRHS = RHSs.begin();\n    for (const Expr *CopyArrayElem : CopyArrayElems) {\n      const auto *LHSVD = cast<VarDecl>(cast<DeclRefExpr>(*ILHS)->getDecl());\n      const auto *RHSVD = cast<VarDecl>(cast<DeclRefExpr>(*IRHS)->getDecl());\n      Address LHSAddr = Address::invalid();\n      {\n        CodeGenFunction::OpaqueValueMapping IdxMapping(\n            CGF,\n            cast<OpaqueValueExpr>(\n                cast<ArraySubscriptExpr>(CopyArrayElem)->getIdx()),\n            RValue::get(IVal));\n        LHSAddr = CGF.EmitLValue(CopyArrayElem).getAddress(CGF);\n      }\n      PrivScope.addPrivate(LHSVD, [LHSAddr]() { return LHSAddr; });\n      Address RHSAddr = Address::invalid();\n      {\n        llvm::Value *OffsetIVal = CGF.Builder.CreateNUWSub(IVal, Pow2K);\n        CodeGenFunction::OpaqueValueMapping IdxMapping(\n            CGF,\n            cast<OpaqueValueExpr>(\n                cast<ArraySubscriptExpr>(CopyArrayElem)->getIdx()),\n            RValue::get(OffsetIVal));\n        RHSAddr = CGF.EmitLValue(CopyArrayElem).getAddress(CGF);\n      }\n      PrivScope.addPrivate(RHSVD, [RHSAddr]() { return RHSAddr; });\n      ++ILHS;\n      ++IRHS;\n    }\n    PrivScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitReduction(\n        CGF, S.getEndLoc(), Privates, LHSs, RHSs, ReductionOps,\n        {/*WithNowait=*/true, /*SimpleReduction=*/true, OMPD_unknown});\n  }\n  llvm::Value *NextIVal =\n      CGF.Builder.CreateNUWSub(IVal, llvm::ConstantInt::get(CGF.SizeTy, 1));\n  IVal->addIncoming(NextIVal, CGF.Builder.GetInsertBlock());\n  CmpI = CGF.Builder.CreateICmpUGE(NextIVal, Pow2K);\n  CGF.Builder.CreateCondBr(CmpI, InnerLoopBB, InnerExitBB);\n  CGF.EmitBlock(InnerExitBB);\n  llvm::Value *Next =\n      CGF.Builder.CreateNUWAdd(Counter, llvm::ConstantInt::get(CGF.IntTy, 1));\n  Counter->addIncoming(Next, CGF.Builder.GetInsertBlock());\n  // pow2k <<= 1;\n  llvm::Value *NextPow2K = CGF.Builder.CreateShl(Pow2K, 1, \"\", /*HasNUW=*/true);\n  Pow2K->addIncoming(NextPow2K, CGF.Builder.GetInsertBlock());\n  llvm::Value *Cmp = CGF.Builder.CreateICmpNE(Next, LogVal);\n  CGF.Builder.CreateCondBr(Cmp, LoopBB, ExitBB);\n  auto DL1 = ApplyDebugLocation::CreateDefaultArtificial(CGF, S.getEndLoc());\n  CGF.EmitBlock(ExitBB);\n\n  CGF.OMPFirstScanLoop = false;\n  SecondGen(CGF);\n}\n\nstatic bool emitWorksharingDirective(CodeGenFunction &CGF,\n                                     const OMPLoopDirective &S,\n                                     bool HasCancel) {\n  bool HasLastprivates;\n  if (llvm::any_of(S.getClausesOfKind<OMPReductionClause>(),\n                   [](const OMPReductionClause *C) {\n                     return C->getModifier() == OMPC_REDUCTION_inscan;\n                   })) {\n    const auto &&NumIteratorsGen = [&S](CodeGenFunction &CGF) {\n      CodeGenFunction::OMPLocalDeclMapRAII Scope(CGF);\n      OMPLoopScope LoopScope(CGF, S);\n      return CGF.EmitScalarExpr(S.getNumIterations());\n    };\n    const auto &&FirstGen = [&S, HasCancel](CodeGenFunction &CGF) {\n      CodeGenFunction::OMPCancelStackRAII CancelRegion(\n          CGF, S.getDirectiveKind(), HasCancel);\n      (void)CGF.EmitOMPWorksharingLoop(S, S.getEnsureUpperBound(),\n                                       emitForLoopBounds,\n                                       emitDispatchForLoopBounds);\n      // Emit an implicit barrier at the end.\n      CGF.CGM.getOpenMPRuntime().emitBarrierCall(CGF, S.getBeginLoc(),\n                                                 OMPD_for);\n    };\n    const auto &&SecondGen = [&S, HasCancel,\n                              &HasLastprivates](CodeGenFunction &CGF) {\n      CodeGenFunction::OMPCancelStackRAII CancelRegion(\n          CGF, S.getDirectiveKind(), HasCancel);\n      HasLastprivates = CGF.EmitOMPWorksharingLoop(S, S.getEnsureUpperBound(),\n                                                   emitForLoopBounds,\n                                                   emitDispatchForLoopBounds);\n    };\n    emitScanBasedDirective(CGF, S, NumIteratorsGen, FirstGen, SecondGen);\n  } else {\n    CodeGenFunction::OMPCancelStackRAII CancelRegion(CGF, S.getDirectiveKind(),\n                                                     HasCancel);\n    HasLastprivates = CGF.EmitOMPWorksharingLoop(S, S.getEnsureUpperBound(),\n                                                 emitForLoopBounds,\n                                                 emitDispatchForLoopBounds);\n  }\n  return HasLastprivates;\n}\n\nstatic bool isSupportedByOpenMPIRBuilder(const OMPForDirective &S) {\n  if (S.hasCancel())\n    return false;\n  for (OMPClause *C : S.clauses())\n    if (!isa<OMPNowaitClause>(C))\n      return false;\n\n  return true;\n}\n\nvoid CodeGenFunction::EmitOMPForDirective(const OMPForDirective &S) {\n  bool HasLastprivates = false;\n  bool UseOMPIRBuilder =\n      CGM.getLangOpts().OpenMPIRBuilder && isSupportedByOpenMPIRBuilder(S);\n  auto &&CodeGen = [this, &S, &HasLastprivates,\n                    UseOMPIRBuilder](CodeGenFunction &CGF, PrePostActionTy &) {\n    // Use the OpenMPIRBuilder if enabled.\n    if (UseOMPIRBuilder) {\n      // Emit the associated statement and get its loop representation.\n      const Stmt *Inner = S.getRawStmt();\n      llvm::CanonicalLoopInfo *CLI =\n          EmitOMPCollapsedCanonicalLoopNest(Inner, 1);\n\n      bool NeedsBarrier = !S.getSingleClause<OMPNowaitClause>();\n      llvm::OpenMPIRBuilder &OMPBuilder =\n          CGM.getOpenMPRuntime().getOMPBuilder();\n      llvm::OpenMPIRBuilder::InsertPointTy AllocaIP(\n          AllocaInsertPt->getParent(), AllocaInsertPt->getIterator());\n      OMPBuilder.createWorkshareLoop(Builder, CLI, AllocaIP, NeedsBarrier);\n      return;\n    }\n\n    HasLastprivates = emitWorksharingDirective(CGF, S, S.hasCancel());\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    OMPLexicalScope Scope(*this, S, OMPD_unknown);\n    CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_for, CodeGen,\n                                                S.hasCancel());\n  }\n\n  if (!UseOMPIRBuilder) {\n    // Emit an implicit barrier at the end.\n    if (!S.getSingleClause<OMPNowaitClause>() || HasLastprivates)\n      CGM.getOpenMPRuntime().emitBarrierCall(*this, S.getBeginLoc(), OMPD_for);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nvoid CodeGenFunction::EmitOMPForSimdDirective(const OMPForSimdDirective &S) {\n  bool HasLastprivates = false;\n  auto &&CodeGen = [&S, &HasLastprivates](CodeGenFunction &CGF,\n                                          PrePostActionTy &) {\n    HasLastprivates = emitWorksharingDirective(CGF, S, /*HasCancel=*/false);\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    OMPLexicalScope Scope(*this, S, OMPD_unknown);\n    CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_simd, CodeGen);\n  }\n\n  // Emit an implicit barrier at the end.\n  if (!S.getSingleClause<OMPNowaitClause>() || HasLastprivates)\n    CGM.getOpenMPRuntime().emitBarrierCall(*this, S.getBeginLoc(), OMPD_for);\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nstatic LValue createSectionLVal(CodeGenFunction &CGF, QualType Ty,\n                                const Twine &Name,\n                                llvm::Value *Init = nullptr) {\n  LValue LVal = CGF.MakeAddrLValue(CGF.CreateMemTemp(Ty, Name), Ty);\n  if (Init)\n    CGF.EmitStoreThroughLValue(RValue::get(Init), LVal, /*isInit*/ true);\n  return LVal;\n}\n\nvoid CodeGenFunction::EmitSections(const OMPExecutableDirective &S) {\n  const Stmt *CapturedStmt = S.getInnermostCapturedStmt()->getCapturedStmt();\n  const auto *CS = dyn_cast<CompoundStmt>(CapturedStmt);\n  bool HasLastprivates = false;\n  auto &&CodeGen = [&S, CapturedStmt, CS,\n                    &HasLastprivates](CodeGenFunction &CGF, PrePostActionTy &) {\n    const ASTContext &C = CGF.getContext();\n    QualType KmpInt32Ty =\n        C.getIntTypeForBitwidth(/*DestWidth=*/32, /*Signed=*/1);\n    // Emit helper vars inits.\n    LValue LB = createSectionLVal(CGF, KmpInt32Ty, \".omp.sections.lb.\",\n                                  CGF.Builder.getInt32(0));\n    llvm::ConstantInt *GlobalUBVal = CS != nullptr\n                                         ? CGF.Builder.getInt32(CS->size() - 1)\n                                         : CGF.Builder.getInt32(0);\n    LValue UB =\n        createSectionLVal(CGF, KmpInt32Ty, \".omp.sections.ub.\", GlobalUBVal);\n    LValue ST = createSectionLVal(CGF, KmpInt32Ty, \".omp.sections.st.\",\n                                  CGF.Builder.getInt32(1));\n    LValue IL = createSectionLVal(CGF, KmpInt32Ty, \".omp.sections.il.\",\n                                  CGF.Builder.getInt32(0));\n    // Loop counter.\n    LValue IV = createSectionLVal(CGF, KmpInt32Ty, \".omp.sections.iv.\");\n    OpaqueValueExpr IVRefExpr(S.getBeginLoc(), KmpInt32Ty, VK_LValue);\n    CodeGenFunction::OpaqueValueMapping OpaqueIV(CGF, &IVRefExpr, IV);\n    OpaqueValueExpr UBRefExpr(S.getBeginLoc(), KmpInt32Ty, VK_LValue);\n    CodeGenFunction::OpaqueValueMapping OpaqueUB(CGF, &UBRefExpr, UB);\n    // Generate condition for loop.\n    BinaryOperator *Cond = BinaryOperator::Create(\n        C, &IVRefExpr, &UBRefExpr, BO_LE, C.BoolTy, VK_RValue, OK_Ordinary,\n        S.getBeginLoc(), FPOptionsOverride());\n    // Increment for loop counter.\n    UnaryOperator *Inc = UnaryOperator::Create(\n        C, &IVRefExpr, UO_PreInc, KmpInt32Ty, VK_RValue, OK_Ordinary,\n        S.getBeginLoc(), true, FPOptionsOverride());\n    auto &&BodyGen = [CapturedStmt, CS, &S, &IV](CodeGenFunction &CGF) {\n      // Iterate through all sections and emit a switch construct:\n      // switch (IV) {\n      //   case 0:\n      //     <SectionStmt[0]>;\n      //     break;\n      // ...\n      //   case <NumSection> - 1:\n      //     <SectionStmt[<NumSection> - 1]>;\n      //     break;\n      // }\n      // .omp.sections.exit:\n      llvm::BasicBlock *ExitBB = CGF.createBasicBlock(\".omp.sections.exit\");\n      llvm::SwitchInst *SwitchStmt =\n          CGF.Builder.CreateSwitch(CGF.EmitLoadOfScalar(IV, S.getBeginLoc()),\n                                   ExitBB, CS == nullptr ? 1 : CS->size());\n      if (CS) {\n        unsigned CaseNumber = 0;\n        for (const Stmt *SubStmt : CS->children()) {\n          auto CaseBB = CGF.createBasicBlock(\".omp.sections.case\");\n          CGF.EmitBlock(CaseBB);\n          SwitchStmt->addCase(CGF.Builder.getInt32(CaseNumber), CaseBB);\n          CGF.EmitStmt(SubStmt);\n          CGF.EmitBranch(ExitBB);\n          ++CaseNumber;\n        }\n      } else {\n        llvm::BasicBlock *CaseBB = CGF.createBasicBlock(\".omp.sections.case\");\n        CGF.EmitBlock(CaseBB);\n        SwitchStmt->addCase(CGF.Builder.getInt32(0), CaseBB);\n        CGF.EmitStmt(CapturedStmt);\n        CGF.EmitBranch(ExitBB);\n      }\n      CGF.EmitBlock(ExitBB, /*IsFinished=*/true);\n    };\n\n    CodeGenFunction::OMPPrivateScope LoopScope(CGF);\n    if (CGF.EmitOMPFirstprivateClause(S, LoopScope)) {\n      // Emit implicit barrier to synchronize threads and avoid data races on\n      // initialization of firstprivate variables and post-update of lastprivate\n      // variables.\n      CGF.CGM.getOpenMPRuntime().emitBarrierCall(\n          CGF, S.getBeginLoc(), OMPD_unknown, /*EmitChecks=*/false,\n          /*ForceSimpleCall=*/true);\n    }\n    CGF.EmitOMPPrivateClause(S, LoopScope);\n    CGOpenMPRuntime::LastprivateConditionalRAII LPCRegion(CGF, S, IV);\n    HasLastprivates = CGF.EmitOMPLastprivateClauseInit(S, LoopScope);\n    CGF.EmitOMPReductionClauseInit(S, LoopScope);\n    (void)LoopScope.Privatize();\n    if (isOpenMPTargetExecutionDirective(S.getDirectiveKind()))\n      CGF.CGM.getOpenMPRuntime().adjustTargetSpecificDataForLambdas(CGF, S);\n\n    // Emit static non-chunked loop.\n    OpenMPScheduleTy ScheduleKind;\n    ScheduleKind.Schedule = OMPC_SCHEDULE_static;\n    CGOpenMPRuntime::StaticRTInput StaticInit(\n        /*IVSize=*/32, /*IVSigned=*/true, /*Ordered=*/false, IL.getAddress(CGF),\n        LB.getAddress(CGF), UB.getAddress(CGF), ST.getAddress(CGF));\n    CGF.CGM.getOpenMPRuntime().emitForStaticInit(\n        CGF, S.getBeginLoc(), S.getDirectiveKind(), ScheduleKind, StaticInit);\n    // UB = min(UB, GlobalUB);\n    llvm::Value *UBVal = CGF.EmitLoadOfScalar(UB, S.getBeginLoc());\n    llvm::Value *MinUBGlobalUB = CGF.Builder.CreateSelect(\n        CGF.Builder.CreateICmpSLT(UBVal, GlobalUBVal), UBVal, GlobalUBVal);\n    CGF.EmitStoreOfScalar(MinUBGlobalUB, UB);\n    // IV = LB;\n    CGF.EmitStoreOfScalar(CGF.EmitLoadOfScalar(LB, S.getBeginLoc()), IV);\n    // while (idx <= UB) { BODY; ++idx; }\n    CGF.EmitOMPInnerLoop(S, /*RequiresCleanup=*/false, Cond, Inc, BodyGen,\n                         [](CodeGenFunction &) {});\n    // Tell the runtime we are done.\n    auto &&CodeGen = [&S](CodeGenFunction &CGF) {\n      CGF.CGM.getOpenMPRuntime().emitForStaticFinish(CGF, S.getEndLoc(),\n                                                     S.getDirectiveKind());\n    };\n    CGF.OMPCancelStack.emitExit(CGF, S.getDirectiveKind(), CodeGen);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_parallel);\n    // Emit post-update of the reduction variables if IsLastIter != 0.\n    emitPostUpdateForReductionClause(CGF, S, [IL, &S](CodeGenFunction &CGF) {\n      return CGF.Builder.CreateIsNotNull(\n          CGF.EmitLoadOfScalar(IL, S.getBeginLoc()));\n    });\n\n    // Emit final copy of the lastprivate variables if IsLastIter != 0.\n    if (HasLastprivates)\n      CGF.EmitOMPLastprivateClauseFinal(\n          S, /*NoFinals=*/false,\n          CGF.Builder.CreateIsNotNull(\n              CGF.EmitLoadOfScalar(IL, S.getBeginLoc())));\n  };\n\n  bool HasCancel = false;\n  if (auto *OSD = dyn_cast<OMPSectionsDirective>(&S))\n    HasCancel = OSD->hasCancel();\n  else if (auto *OPSD = dyn_cast<OMPParallelSectionsDirective>(&S))\n    HasCancel = OPSD->hasCancel();\n  OMPCancelStackRAII CancelRegion(*this, S.getDirectiveKind(), HasCancel);\n  CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_sections, CodeGen,\n                                              HasCancel);\n  // Emit barrier for lastprivates only if 'sections' directive has 'nowait'\n  // clause. Otherwise the barrier will be generated by the codegen for the\n  // directive.\n  if (HasLastprivates && S.getSingleClause<OMPNowaitClause>()) {\n    // Emit implicit barrier to synchronize threads and avoid data races on\n    // initialization of firstprivate variables.\n    CGM.getOpenMPRuntime().emitBarrierCall(*this, S.getBeginLoc(),\n                                           OMPD_unknown);\n  }\n}\n\nvoid CodeGenFunction::EmitOMPSectionsDirective(const OMPSectionsDirective &S) {\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    OMPLexicalScope Scope(*this, S, OMPD_unknown);\n    EmitSections(S);\n  }\n  // Emit an implicit barrier at the end.\n  if (!S.getSingleClause<OMPNowaitClause>()) {\n    CGM.getOpenMPRuntime().emitBarrierCall(*this, S.getBeginLoc(),\n                                           OMPD_sections);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nvoid CodeGenFunction::EmitOMPSectionDirective(const OMPSectionDirective &S) {\n  LexicalScope Scope(*this, S.getSourceRange());\n  EmitStopPoint(&S);\n  EmitStmt(S.getAssociatedStmt());\n}\n\nvoid CodeGenFunction::EmitOMPSingleDirective(const OMPSingleDirective &S) {\n  llvm::SmallVector<const Expr *, 8> CopyprivateVars;\n  llvm::SmallVector<const Expr *, 8> DestExprs;\n  llvm::SmallVector<const Expr *, 8> SrcExprs;\n  llvm::SmallVector<const Expr *, 8> AssignmentOps;\n  // Check if there are any 'copyprivate' clauses associated with this\n  // 'single' construct.\n  // Build a list of copyprivate variables along with helper expressions\n  // (<source>, <destination>, <destination>=<source> expressions)\n  for (const auto *C : S.getClausesOfKind<OMPCopyprivateClause>()) {\n    CopyprivateVars.append(C->varlists().begin(), C->varlists().end());\n    DestExprs.append(C->destination_exprs().begin(),\n                     C->destination_exprs().end());\n    SrcExprs.append(C->source_exprs().begin(), C->source_exprs().end());\n    AssignmentOps.append(C->assignment_ops().begin(),\n                         C->assignment_ops().end());\n  }\n  // Emit code for 'single' region along with 'copyprivate' clauses\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope SingleScope(CGF);\n    (void)CGF.EmitOMPFirstprivateClause(S, SingleScope);\n    CGF.EmitOMPPrivateClause(S, SingleScope);\n    (void)SingleScope.Privatize();\n    CGF.EmitStmt(S.getInnermostCapturedStmt()->getCapturedStmt());\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    OMPLexicalScope Scope(*this, S, OMPD_unknown);\n    CGM.getOpenMPRuntime().emitSingleRegion(*this, CodeGen, S.getBeginLoc(),\n                                            CopyprivateVars, DestExprs,\n                                            SrcExprs, AssignmentOps);\n  }\n  // Emit an implicit barrier at the end (to avoid data race on firstprivate\n  // init or if no 'nowait' clause was specified and no 'copyprivate' clause).\n  if (!S.getSingleClause<OMPNowaitClause>() && CopyprivateVars.empty()) {\n    CGM.getOpenMPRuntime().emitBarrierCall(\n        *this, S.getBeginLoc(),\n        S.getSingleClause<OMPNowaitClause>() ? OMPD_unknown : OMPD_single);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nstatic void emitMaster(CodeGenFunction &CGF, const OMPExecutableDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CGF.EmitStmt(S.getRawStmt());\n  };\n  CGF.CGM.getOpenMPRuntime().emitMasterRegion(CGF, CodeGen, S.getBeginLoc());\n}\n\nvoid CodeGenFunction::EmitOMPMasterDirective(const OMPMasterDirective &S) {\n  if (CGM.getLangOpts().OpenMPIRBuilder) {\n    llvm::OpenMPIRBuilder &OMPBuilder = CGM.getOpenMPRuntime().getOMPBuilder();\n    using InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;\n\n    const Stmt *MasterRegionBodyStmt = S.getAssociatedStmt();\n\n    auto FiniCB = [this](InsertPointTy IP) {\n      OMPBuilderCBHelpers::FinalizeOMPRegion(*this, IP);\n    };\n\n    auto BodyGenCB = [MasterRegionBodyStmt, this](InsertPointTy AllocaIP,\n                                                  InsertPointTy CodeGenIP,\n                                                  llvm::BasicBlock &FiniBB) {\n      OMPBuilderCBHelpers::InlinedRegionBodyRAII IRB(*this, AllocaIP, FiniBB);\n      OMPBuilderCBHelpers::EmitOMPRegionBody(*this, MasterRegionBodyStmt,\n                                             CodeGenIP, FiniBB);\n    };\n\n    LexicalScope Scope(*this, S.getSourceRange());\n    EmitStopPoint(&S);\n    Builder.restoreIP(OMPBuilder.createMaster(Builder, BodyGenCB, FiniCB));\n\n    return;\n  }\n  LexicalScope Scope(*this, S.getSourceRange());\n  EmitStopPoint(&S);\n  emitMaster(*this, S);\n}\n\nvoid CodeGenFunction::EmitOMPCriticalDirective(const OMPCriticalDirective &S) {\n  if (CGM.getLangOpts().OpenMPIRBuilder) {\n    llvm::OpenMPIRBuilder &OMPBuilder = CGM.getOpenMPRuntime().getOMPBuilder();\n    using InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;\n\n    const Stmt *CriticalRegionBodyStmt = S.getAssociatedStmt();\n    const Expr *Hint = nullptr;\n    if (const auto *HintClause = S.getSingleClause<OMPHintClause>())\n      Hint = HintClause->getHint();\n\n    // TODO: This is slightly different from what's currently being done in\n    // clang. Fix the Int32Ty to IntPtrTy (pointer width size) when everything\n    // about typing is final.\n    llvm::Value *HintInst = nullptr;\n    if (Hint)\n      HintInst =\n          Builder.CreateIntCast(EmitScalarExpr(Hint), CGM.Int32Ty, false);\n\n    auto FiniCB = [this](InsertPointTy IP) {\n      OMPBuilderCBHelpers::FinalizeOMPRegion(*this, IP);\n    };\n\n    auto BodyGenCB = [CriticalRegionBodyStmt, this](InsertPointTy AllocaIP,\n                                                    InsertPointTy CodeGenIP,\n                                                    llvm::BasicBlock &FiniBB) {\n      OMPBuilderCBHelpers::InlinedRegionBodyRAII IRB(*this, AllocaIP, FiniBB);\n      OMPBuilderCBHelpers::EmitOMPRegionBody(*this, CriticalRegionBodyStmt,\n                                             CodeGenIP, FiniBB);\n    };\n\n    LexicalScope Scope(*this, S.getSourceRange());\n    EmitStopPoint(&S);\n    Builder.restoreIP(OMPBuilder.createCritical(\n        Builder, BodyGenCB, FiniCB, S.getDirectiveName().getAsString(),\n        HintInst));\n\n    return;\n  }\n\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CGF.EmitStmt(S.getAssociatedStmt());\n  };\n  const Expr *Hint = nullptr;\n  if (const auto *HintClause = S.getSingleClause<OMPHintClause>())\n    Hint = HintClause->getHint();\n  LexicalScope Scope(*this, S.getSourceRange());\n  EmitStopPoint(&S);\n  CGM.getOpenMPRuntime().emitCriticalRegion(*this,\n                                            S.getDirectiveName().getAsString(),\n                                            CodeGen, S.getBeginLoc(), Hint);\n}\n\nvoid CodeGenFunction::EmitOMPParallelForDirective(\n    const OMPParallelForDirective &S) {\n  // Emit directive as a combined directive that consists of two implicit\n  // directives: 'parallel' with 'for' directive.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    (void)emitWorksharingDirective(CGF, S, S.hasCancel());\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    emitCommonOMPParallelDirective(*this, S, OMPD_for, CodeGen,\n                                   emitEmptyBoundParameters);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nvoid CodeGenFunction::EmitOMPParallelForSimdDirective(\n    const OMPParallelForSimdDirective &S) {\n  // Emit directive as a combined directive that consists of two implicit\n  // directives: 'parallel' with 'for' directive.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    (void)emitWorksharingDirective(CGF, S, /*HasCancel=*/false);\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    emitCommonOMPParallelDirective(*this, S, OMPD_for_simd, CodeGen,\n                                   emitEmptyBoundParameters);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nvoid CodeGenFunction::EmitOMPParallelMasterDirective(\n    const OMPParallelMasterDirective &S) {\n  // Emit directive as a combined directive that consists of two implicit\n  // directives: 'parallel' with 'master' directive.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope PrivateScope(CGF);\n    bool Copyins = CGF.EmitOMPCopyinClause(S);\n    (void)CGF.EmitOMPFirstprivateClause(S, PrivateScope);\n    if (Copyins) {\n      // Emit implicit barrier to synchronize threads and avoid data races on\n      // propagation master's thread values of threadprivate variables to local\n      // instances of that variables of all other implicit threads.\n      CGF.CGM.getOpenMPRuntime().emitBarrierCall(\n          CGF, S.getBeginLoc(), OMPD_unknown, /*EmitChecks=*/false,\n          /*ForceSimpleCall=*/true);\n    }\n    CGF.EmitOMPPrivateClause(S, PrivateScope);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    emitMaster(CGF, S);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_parallel);\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    emitCommonOMPParallelDirective(*this, S, OMPD_master, CodeGen,\n                                   emitEmptyBoundParameters);\n    emitPostUpdateForReductionClause(*this, S,\n                                     [](CodeGenFunction &) { return nullptr; });\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nvoid CodeGenFunction::EmitOMPParallelSectionsDirective(\n    const OMPParallelSectionsDirective &S) {\n  // Emit directive as a combined directive that consists of two implicit\n  // directives: 'parallel' with 'sections' directive.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CGF.EmitSections(S);\n  };\n  {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n    emitCommonOMPParallelDirective(*this, S, OMPD_sections, CodeGen,\n                                   emitEmptyBoundParameters);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, S);\n}\n\nnamespace {\n/// Get the list of variables declared in the context of the untied tasks.\nclass CheckVarsEscapingUntiedTaskDeclContext final\n    : public ConstStmtVisitor<CheckVarsEscapingUntiedTaskDeclContext> {\n  llvm::SmallVector<const VarDecl *, 4> PrivateDecls;\n\npublic:\n  explicit CheckVarsEscapingUntiedTaskDeclContext() = default;\n  virtual ~CheckVarsEscapingUntiedTaskDeclContext() = default;\n  void VisitDeclStmt(const DeclStmt *S) {\n    if (!S)\n      return;\n    // Need to privatize only local vars, static locals can be processed as is.\n    for (const Decl *D : S->decls()) {\n      if (const auto *VD = dyn_cast_or_null<VarDecl>(D))\n        if (VD->hasLocalStorage())\n          PrivateDecls.push_back(VD);\n    }\n  }\n  void VisitOMPExecutableDirective(const OMPExecutableDirective *) { return; }\n  void VisitCapturedStmt(const CapturedStmt *) { return; }\n  void VisitLambdaExpr(const LambdaExpr *) { return; }\n  void VisitBlockExpr(const BlockExpr *) { return; }\n  void VisitStmt(const Stmt *S) {\n    if (!S)\n      return;\n    for (const Stmt *Child : S->children())\n      if (Child)\n        Visit(Child);\n  }\n\n  /// Swaps list of vars with the provided one.\n  ArrayRef<const VarDecl *> getPrivateDecls() const { return PrivateDecls; }\n};\n} // anonymous namespace\n\nvoid CodeGenFunction::EmitOMPTaskBasedDirective(\n    const OMPExecutableDirective &S, const OpenMPDirectiveKind CapturedRegion,\n    const RegionCodeGenTy &BodyGen, const TaskGenTy &TaskGen,\n    OMPTaskDataTy &Data) {\n  // Emit outlined function for task construct.\n  const CapturedStmt *CS = S.getCapturedStmt(CapturedRegion);\n  auto I = CS->getCapturedDecl()->param_begin();\n  auto PartId = std::next(I);\n  auto TaskT = std::next(I, 4);\n  // Check if the task is final\n  if (const auto *Clause = S.getSingleClause<OMPFinalClause>()) {\n    // If the condition constant folds and can be elided, try to avoid emitting\n    // the condition and the dead arm of the if/else.\n    const Expr *Cond = Clause->getCondition();\n    bool CondConstant;\n    if (ConstantFoldsToSimpleInteger(Cond, CondConstant))\n      Data.Final.setInt(CondConstant);\n    else\n      Data.Final.setPointer(EvaluateExprAsBool(Cond));\n  } else {\n    // By default the task is not final.\n    Data.Final.setInt(/*IntVal=*/false);\n  }\n  // Check if the task has 'priority' clause.\n  if (const auto *Clause = S.getSingleClause<OMPPriorityClause>()) {\n    const Expr *Prio = Clause->getPriority();\n    Data.Priority.setInt(/*IntVal=*/true);\n    Data.Priority.setPointer(EmitScalarConversion(\n        EmitScalarExpr(Prio), Prio->getType(),\n        getContext().getIntTypeForBitwidth(/*DestWidth=*/32, /*Signed=*/1),\n        Prio->getExprLoc()));\n  }\n  // The first function argument for tasks is a thread id, the second one is a\n  // part id (0 for tied tasks, >=0 for untied task).\n  llvm::DenseSet<const VarDecl *> EmittedAsPrivate;\n  // Get list of private variables.\n  for (const auto *C : S.getClausesOfKind<OMPPrivateClause>()) {\n    auto IRef = C->varlist_begin();\n    for (const Expr *IInit : C->private_copies()) {\n      const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      if (EmittedAsPrivate.insert(OrigVD->getCanonicalDecl()).second) {\n        Data.PrivateVars.push_back(*IRef);\n        Data.PrivateCopies.push_back(IInit);\n      }\n      ++IRef;\n    }\n  }\n  EmittedAsPrivate.clear();\n  // Get list of firstprivate variables.\n  for (const auto *C : S.getClausesOfKind<OMPFirstprivateClause>()) {\n    auto IRef = C->varlist_begin();\n    auto IElemInitRef = C->inits().begin();\n    for (const Expr *IInit : C->private_copies()) {\n      const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      if (EmittedAsPrivate.insert(OrigVD->getCanonicalDecl()).second) {\n        Data.FirstprivateVars.push_back(*IRef);\n        Data.FirstprivateCopies.push_back(IInit);\n        Data.FirstprivateInits.push_back(*IElemInitRef);\n      }\n      ++IRef;\n      ++IElemInitRef;\n    }\n  }\n  // Get list of lastprivate variables (for taskloops).\n  llvm::DenseMap<const VarDecl *, const DeclRefExpr *> LastprivateDstsOrigs;\n  for (const auto *C : S.getClausesOfKind<OMPLastprivateClause>()) {\n    auto IRef = C->varlist_begin();\n    auto ID = C->destination_exprs().begin();\n    for (const Expr *IInit : C->private_copies()) {\n      const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*IRef)->getDecl());\n      if (EmittedAsPrivate.insert(OrigVD->getCanonicalDecl()).second) {\n        Data.LastprivateVars.push_back(*IRef);\n        Data.LastprivateCopies.push_back(IInit);\n      }\n      LastprivateDstsOrigs.insert(\n          {cast<VarDecl>(cast<DeclRefExpr>(*ID)->getDecl()),\n           cast<DeclRefExpr>(*IRef)});\n      ++IRef;\n      ++ID;\n    }\n  }\n  SmallVector<const Expr *, 4> LHSs;\n  SmallVector<const Expr *, 4> RHSs;\n  for (const auto *C : S.getClausesOfKind<OMPReductionClause>()) {\n    Data.ReductionVars.append(C->varlist_begin(), C->varlist_end());\n    Data.ReductionOrigs.append(C->varlist_begin(), C->varlist_end());\n    Data.ReductionCopies.append(C->privates().begin(), C->privates().end());\n    Data.ReductionOps.append(C->reduction_ops().begin(),\n                             C->reduction_ops().end());\n    LHSs.append(C->lhs_exprs().begin(), C->lhs_exprs().end());\n    RHSs.append(C->rhs_exprs().begin(), C->rhs_exprs().end());\n  }\n  Data.Reductions = CGM.getOpenMPRuntime().emitTaskReductionInit(\n      *this, S.getBeginLoc(), LHSs, RHSs, Data);\n  // Build list of dependences.\n  for (const auto *C : S.getClausesOfKind<OMPDependClause>()) {\n    OMPTaskDataTy::DependData &DD =\n        Data.Dependences.emplace_back(C->getDependencyKind(), C->getModifier());\n    DD.DepExprs.append(C->varlist_begin(), C->varlist_end());\n  }\n  // Get list of local vars for untied tasks.\n  if (!Data.Tied) {\n    CheckVarsEscapingUntiedTaskDeclContext Checker;\n    Checker.Visit(S.getInnermostCapturedStmt()->getCapturedStmt());\n    Data.PrivateLocals.append(Checker.getPrivateDecls().begin(),\n                              Checker.getPrivateDecls().end());\n  }\n  auto &&CodeGen = [&Data, &S, CS, &BodyGen, &LastprivateDstsOrigs,\n                    CapturedRegion](CodeGenFunction &CGF,\n                                    PrePostActionTy &Action) {\n    llvm::DenseMap<CanonicalDeclPtr<const VarDecl>, std::pair<Address, Address>>\n        UntiedLocalVars;\n    // Set proper addresses for generated private copies.\n    OMPPrivateScope Scope(CGF);\n    llvm::SmallVector<std::pair<const VarDecl *, Address>, 16> FirstprivatePtrs;\n    if (!Data.PrivateVars.empty() || !Data.FirstprivateVars.empty() ||\n        !Data.LastprivateVars.empty() || !Data.PrivateLocals.empty()) {\n      llvm::FunctionType *CopyFnTy = llvm::FunctionType::get(\n          CGF.Builder.getVoidTy(), {CGF.Builder.getInt8PtrTy()}, true);\n      enum { PrivatesParam = 2, CopyFnParam = 3 };\n      llvm::Value *CopyFn = CGF.Builder.CreateLoad(\n          CGF.GetAddrOfLocalVar(CS->getCapturedDecl()->getParam(CopyFnParam)));\n      llvm::Value *PrivatesPtr = CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(\n          CS->getCapturedDecl()->getParam(PrivatesParam)));\n      // Map privates.\n      llvm::SmallVector<std::pair<const VarDecl *, Address>, 16> PrivatePtrs;\n      llvm::SmallVector<llvm::Value *, 16> CallArgs;\n      CallArgs.push_back(PrivatesPtr);\n      for (const Expr *E : Data.PrivateVars) {\n        const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n        Address PrivatePtr = CGF.CreateMemTemp(\n            CGF.getContext().getPointerType(E->getType()), \".priv.ptr.addr\");\n        PrivatePtrs.emplace_back(VD, PrivatePtr);\n        CallArgs.push_back(PrivatePtr.getPointer());\n      }\n      for (const Expr *E : Data.FirstprivateVars) {\n        const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n        Address PrivatePtr =\n            CGF.CreateMemTemp(CGF.getContext().getPointerType(E->getType()),\n                              \".firstpriv.ptr.addr\");\n        PrivatePtrs.emplace_back(VD, PrivatePtr);\n        FirstprivatePtrs.emplace_back(VD, PrivatePtr);\n        CallArgs.push_back(PrivatePtr.getPointer());\n      }\n      for (const Expr *E : Data.LastprivateVars) {\n        const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n        Address PrivatePtr =\n            CGF.CreateMemTemp(CGF.getContext().getPointerType(E->getType()),\n                              \".lastpriv.ptr.addr\");\n        PrivatePtrs.emplace_back(VD, PrivatePtr);\n        CallArgs.push_back(PrivatePtr.getPointer());\n      }\n      for (const VarDecl *VD : Data.PrivateLocals) {\n        QualType Ty = VD->getType().getNonReferenceType();\n        if (VD->getType()->isLValueReferenceType())\n          Ty = CGF.getContext().getPointerType(Ty);\n        if (isAllocatableDecl(VD))\n          Ty = CGF.getContext().getPointerType(Ty);\n        Address PrivatePtr = CGF.CreateMemTemp(\n            CGF.getContext().getPointerType(Ty), \".local.ptr.addr\");\n        UntiedLocalVars.try_emplace(VD, PrivatePtr, Address::invalid());\n        CallArgs.push_back(PrivatePtr.getPointer());\n      }\n      CGF.CGM.getOpenMPRuntime().emitOutlinedFunctionCall(\n          CGF, S.getBeginLoc(), {CopyFnTy, CopyFn}, CallArgs);\n      for (const auto &Pair : LastprivateDstsOrigs) {\n        const auto *OrigVD = cast<VarDecl>(Pair.second->getDecl());\n        DeclRefExpr DRE(CGF.getContext(), const_cast<VarDecl *>(OrigVD),\n                        /*RefersToEnclosingVariableOrCapture=*/\n                            CGF.CapturedStmtInfo->lookup(OrigVD) != nullptr,\n                        Pair.second->getType(), VK_LValue,\n                        Pair.second->getExprLoc());\n        Scope.addPrivate(Pair.first, [&CGF, &DRE]() {\n          return CGF.EmitLValue(&DRE).getAddress(CGF);\n        });\n      }\n      for (const auto &Pair : PrivatePtrs) {\n        Address Replacement(CGF.Builder.CreateLoad(Pair.second),\n                            CGF.getContext().getDeclAlign(Pair.first));\n        Scope.addPrivate(Pair.first, [Replacement]() { return Replacement; });\n      }\n      // Adjust mapping for internal locals by mapping actual memory instead of\n      // a pointer to this memory.\n      for (auto &Pair : UntiedLocalVars) {\n        if (isAllocatableDecl(Pair.first)) {\n          llvm::Value *Ptr = CGF.Builder.CreateLoad(Pair.second.first);\n          Address Replacement(Ptr, CGF.getPointerAlign());\n          Pair.getSecond().first = Replacement;\n          Ptr = CGF.Builder.CreateLoad(Replacement);\n          Replacement = Address(Ptr, CGF.getContext().getDeclAlign(Pair.first));\n          Pair.getSecond().second = Replacement;\n        } else {\n          llvm::Value *Ptr = CGF.Builder.CreateLoad(Pair.second.first);\n          Address Replacement(Ptr, CGF.getContext().getDeclAlign(Pair.first));\n          Pair.getSecond().first = Replacement;\n        }\n      }\n    }\n    if (Data.Reductions) {\n      OMPPrivateScope FirstprivateScope(CGF);\n      for (const auto &Pair : FirstprivatePtrs) {\n        Address Replacement(CGF.Builder.CreateLoad(Pair.second),\n                            CGF.getContext().getDeclAlign(Pair.first));\n        FirstprivateScope.addPrivate(Pair.first,\n                                     [Replacement]() { return Replacement; });\n      }\n      (void)FirstprivateScope.Privatize();\n      OMPLexicalScope LexScope(CGF, S, CapturedRegion);\n      ReductionCodeGen RedCG(Data.ReductionVars, Data.ReductionVars,\n                             Data.ReductionCopies, Data.ReductionOps);\n      llvm::Value *ReductionsPtr = CGF.Builder.CreateLoad(\n          CGF.GetAddrOfLocalVar(CS->getCapturedDecl()->getParam(9)));\n      for (unsigned Cnt = 0, E = Data.ReductionVars.size(); Cnt < E; ++Cnt) {\n        RedCG.emitSharedOrigLValue(CGF, Cnt);\n        RedCG.emitAggregateType(CGF, Cnt);\n        // FIXME: This must removed once the runtime library is fixed.\n        // Emit required threadprivate variables for\n        // initializer/combiner/finalizer.\n        CGF.CGM.getOpenMPRuntime().emitTaskReductionFixups(CGF, S.getBeginLoc(),\n                                                           RedCG, Cnt);\n        Address Replacement = CGF.CGM.getOpenMPRuntime().getTaskReductionItem(\n            CGF, S.getBeginLoc(), ReductionsPtr, RedCG.getSharedLValue(Cnt));\n        Replacement =\n            Address(CGF.EmitScalarConversion(\n                        Replacement.getPointer(), CGF.getContext().VoidPtrTy,\n                        CGF.getContext().getPointerType(\n                            Data.ReductionCopies[Cnt]->getType()),\n                        Data.ReductionCopies[Cnt]->getExprLoc()),\n                    Replacement.getAlignment());\n        Replacement = RedCG.adjustPrivateAddress(CGF, Cnt, Replacement);\n        Scope.addPrivate(RedCG.getBaseDecl(Cnt),\n                         [Replacement]() { return Replacement; });\n      }\n    }\n    // Privatize all private variables except for in_reduction items.\n    (void)Scope.Privatize();\n    SmallVector<const Expr *, 4> InRedVars;\n    SmallVector<const Expr *, 4> InRedPrivs;\n    SmallVector<const Expr *, 4> InRedOps;\n    SmallVector<const Expr *, 4> TaskgroupDescriptors;\n    for (const auto *C : S.getClausesOfKind<OMPInReductionClause>()) {\n      auto IPriv = C->privates().begin();\n      auto IRed = C->reduction_ops().begin();\n      auto ITD = C->taskgroup_descriptors().begin();\n      for (const Expr *Ref : C->varlists()) {\n        InRedVars.emplace_back(Ref);\n        InRedPrivs.emplace_back(*IPriv);\n        InRedOps.emplace_back(*IRed);\n        TaskgroupDescriptors.emplace_back(*ITD);\n        std::advance(IPriv, 1);\n        std::advance(IRed, 1);\n        std::advance(ITD, 1);\n      }\n    }\n    // Privatize in_reduction items here, because taskgroup descriptors must be\n    // privatized earlier.\n    OMPPrivateScope InRedScope(CGF);\n    if (!InRedVars.empty()) {\n      ReductionCodeGen RedCG(InRedVars, InRedVars, InRedPrivs, InRedOps);\n      for (unsigned Cnt = 0, E = InRedVars.size(); Cnt < E; ++Cnt) {\n        RedCG.emitSharedOrigLValue(CGF, Cnt);\n        RedCG.emitAggregateType(CGF, Cnt);\n        // The taskgroup descriptor variable is always implicit firstprivate and\n        // privatized already during processing of the firstprivates.\n        // FIXME: This must removed once the runtime library is fixed.\n        // Emit required threadprivate variables for\n        // initializer/combiner/finalizer.\n        CGF.CGM.getOpenMPRuntime().emitTaskReductionFixups(CGF, S.getBeginLoc(),\n                                                           RedCG, Cnt);\n        llvm::Value *ReductionsPtr;\n        if (const Expr *TRExpr = TaskgroupDescriptors[Cnt]) {\n          ReductionsPtr = CGF.EmitLoadOfScalar(CGF.EmitLValue(TRExpr),\n                                               TRExpr->getExprLoc());\n        } else {\n          ReductionsPtr = llvm::ConstantPointerNull::get(CGF.VoidPtrTy);\n        }\n        Address Replacement = CGF.CGM.getOpenMPRuntime().getTaskReductionItem(\n            CGF, S.getBeginLoc(), ReductionsPtr, RedCG.getSharedLValue(Cnt));\n        Replacement = Address(\n            CGF.EmitScalarConversion(\n                Replacement.getPointer(), CGF.getContext().VoidPtrTy,\n                CGF.getContext().getPointerType(InRedPrivs[Cnt]->getType()),\n                InRedPrivs[Cnt]->getExprLoc()),\n            Replacement.getAlignment());\n        Replacement = RedCG.adjustPrivateAddress(CGF, Cnt, Replacement);\n        InRedScope.addPrivate(RedCG.getBaseDecl(Cnt),\n                              [Replacement]() { return Replacement; });\n      }\n    }\n    (void)InRedScope.Privatize();\n\n    CGOpenMPRuntime::UntiedTaskLocalDeclsRAII LocalVarsScope(CGF,\n                                                             UntiedLocalVars);\n    Action.Enter(CGF);\n    BodyGen(CGF);\n  };\n  llvm::Function *OutlinedFn = CGM.getOpenMPRuntime().emitTaskOutlinedFunction(\n      S, *I, *PartId, *TaskT, S.getDirectiveKind(), CodeGen, Data.Tied,\n      Data.NumberOfParts);\n  OMPLexicalScope Scope(*this, S, llvm::None,\n                        !isOpenMPParallelDirective(S.getDirectiveKind()) &&\n                            !isOpenMPSimdDirective(S.getDirectiveKind()));\n  TaskGen(*this, OutlinedFn, Data);\n}\n\nstatic ImplicitParamDecl *\ncreateImplicitFirstprivateForType(ASTContext &C, OMPTaskDataTy &Data,\n                                  QualType Ty, CapturedDecl *CD,\n                                  SourceLocation Loc) {\n  auto *OrigVD = ImplicitParamDecl::Create(C, CD, Loc, /*Id=*/nullptr, Ty,\n                                           ImplicitParamDecl::Other);\n  auto *OrigRef = DeclRefExpr::Create(\n      C, NestedNameSpecifierLoc(), SourceLocation(), OrigVD,\n      /*RefersToEnclosingVariableOrCapture=*/false, Loc, Ty, VK_LValue);\n  auto *PrivateVD = ImplicitParamDecl::Create(C, CD, Loc, /*Id=*/nullptr, Ty,\n                                              ImplicitParamDecl::Other);\n  auto *PrivateRef = DeclRefExpr::Create(\n      C, NestedNameSpecifierLoc(), SourceLocation(), PrivateVD,\n      /*RefersToEnclosingVariableOrCapture=*/false, Loc, Ty, VK_LValue);\n  QualType ElemType = C.getBaseElementType(Ty);\n  auto *InitVD = ImplicitParamDecl::Create(C, CD, Loc, /*Id=*/nullptr, ElemType,\n                                           ImplicitParamDecl::Other);\n  auto *InitRef = DeclRefExpr::Create(\n      C, NestedNameSpecifierLoc(), SourceLocation(), InitVD,\n      /*RefersToEnclosingVariableOrCapture=*/false, Loc, ElemType, VK_LValue);\n  PrivateVD->setInitStyle(VarDecl::CInit);\n  PrivateVD->setInit(ImplicitCastExpr::Create(C, ElemType, CK_LValueToRValue,\n                                              InitRef, /*BasePath=*/nullptr,\n                                              VK_RValue, FPOptionsOverride()));\n  Data.FirstprivateVars.emplace_back(OrigRef);\n  Data.FirstprivateCopies.emplace_back(PrivateRef);\n  Data.FirstprivateInits.emplace_back(InitRef);\n  return OrigVD;\n}\n\nvoid CodeGenFunction::EmitOMPTargetTaskBasedDirective(\n    const OMPExecutableDirective &S, const RegionCodeGenTy &BodyGen,\n    OMPTargetDataInfo &InputInfo) {\n  // Emit outlined function for task construct.\n  const CapturedStmt *CS = S.getCapturedStmt(OMPD_task);\n  Address CapturedStruct = GenerateCapturedStmtArgument(*CS);\n  QualType SharedsTy = getContext().getRecordType(CS->getCapturedRecordDecl());\n  auto I = CS->getCapturedDecl()->param_begin();\n  auto PartId = std::next(I);\n  auto TaskT = std::next(I, 4);\n  OMPTaskDataTy Data;\n  // The task is not final.\n  Data.Final.setInt(/*IntVal=*/false);\n  // Get list of firstprivate variables.\n  for (const auto *C : S.getClausesOfKind<OMPFirstprivateClause>()) {\n    auto IRef = C->varlist_begin();\n    auto IElemInitRef = C->inits().begin();\n    for (auto *IInit : C->private_copies()) {\n      Data.FirstprivateVars.push_back(*IRef);\n      Data.FirstprivateCopies.push_back(IInit);\n      Data.FirstprivateInits.push_back(*IElemInitRef);\n      ++IRef;\n      ++IElemInitRef;\n    }\n  }\n  OMPPrivateScope TargetScope(*this);\n  VarDecl *BPVD = nullptr;\n  VarDecl *PVD = nullptr;\n  VarDecl *SVD = nullptr;\n  VarDecl *MVD = nullptr;\n  if (InputInfo.NumberOfTargetItems > 0) {\n    auto *CD = CapturedDecl::Create(\n        getContext(), getContext().getTranslationUnitDecl(), /*NumParams=*/0);\n    llvm::APInt ArrSize(/*numBits=*/32, InputInfo.NumberOfTargetItems);\n    QualType BaseAndPointerAndMapperType = getContext().getConstantArrayType(\n        getContext().VoidPtrTy, ArrSize, nullptr, ArrayType::Normal,\n        /*IndexTypeQuals=*/0);\n    BPVD = createImplicitFirstprivateForType(\n        getContext(), Data, BaseAndPointerAndMapperType, CD, S.getBeginLoc());\n    PVD = createImplicitFirstprivateForType(\n        getContext(), Data, BaseAndPointerAndMapperType, CD, S.getBeginLoc());\n    QualType SizesType = getContext().getConstantArrayType(\n        getContext().getIntTypeForBitwidth(/*DestWidth=*/64, /*Signed=*/1),\n        ArrSize, nullptr, ArrayType::Normal,\n        /*IndexTypeQuals=*/0);\n    SVD = createImplicitFirstprivateForType(getContext(), Data, SizesType, CD,\n                                            S.getBeginLoc());\n    TargetScope.addPrivate(\n        BPVD, [&InputInfo]() { return InputInfo.BasePointersArray; });\n    TargetScope.addPrivate(PVD,\n                           [&InputInfo]() { return InputInfo.PointersArray; });\n    TargetScope.addPrivate(SVD,\n                           [&InputInfo]() { return InputInfo.SizesArray; });\n    // If there is no user-defined mapper, the mapper array will be nullptr. In\n    // this case, we don't need to privatize it.\n    if (!dyn_cast_or_null<llvm::ConstantPointerNull>(\n            InputInfo.MappersArray.getPointer())) {\n      MVD = createImplicitFirstprivateForType(\n          getContext(), Data, BaseAndPointerAndMapperType, CD, S.getBeginLoc());\n      TargetScope.addPrivate(MVD,\n                             [&InputInfo]() { return InputInfo.MappersArray; });\n    }\n  }\n  (void)TargetScope.Privatize();\n  // Build list of dependences.\n  for (const auto *C : S.getClausesOfKind<OMPDependClause>()) {\n    OMPTaskDataTy::DependData &DD =\n        Data.Dependences.emplace_back(C->getDependencyKind(), C->getModifier());\n    DD.DepExprs.append(C->varlist_begin(), C->varlist_end());\n  }\n  auto &&CodeGen = [&Data, &S, CS, &BodyGen, BPVD, PVD, SVD, MVD,\n                    &InputInfo](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    // Set proper addresses for generated private copies.\n    OMPPrivateScope Scope(CGF);\n    if (!Data.FirstprivateVars.empty()) {\n      llvm::FunctionType *CopyFnTy = llvm::FunctionType::get(\n          CGF.Builder.getVoidTy(), {CGF.Builder.getInt8PtrTy()}, true);\n      enum { PrivatesParam = 2, CopyFnParam = 3 };\n      llvm::Value *CopyFn = CGF.Builder.CreateLoad(\n          CGF.GetAddrOfLocalVar(CS->getCapturedDecl()->getParam(CopyFnParam)));\n      llvm::Value *PrivatesPtr = CGF.Builder.CreateLoad(CGF.GetAddrOfLocalVar(\n          CS->getCapturedDecl()->getParam(PrivatesParam)));\n      // Map privates.\n      llvm::SmallVector<std::pair<const VarDecl *, Address>, 16> PrivatePtrs;\n      llvm::SmallVector<llvm::Value *, 16> CallArgs;\n      CallArgs.push_back(PrivatesPtr);\n      for (const Expr *E : Data.FirstprivateVars) {\n        const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n        Address PrivatePtr =\n            CGF.CreateMemTemp(CGF.getContext().getPointerType(E->getType()),\n                              \".firstpriv.ptr.addr\");\n        PrivatePtrs.emplace_back(VD, PrivatePtr);\n        CallArgs.push_back(PrivatePtr.getPointer());\n      }\n      CGF.CGM.getOpenMPRuntime().emitOutlinedFunctionCall(\n          CGF, S.getBeginLoc(), {CopyFnTy, CopyFn}, CallArgs);\n      for (const auto &Pair : PrivatePtrs) {\n        Address Replacement(CGF.Builder.CreateLoad(Pair.second),\n                            CGF.getContext().getDeclAlign(Pair.first));\n        Scope.addPrivate(Pair.first, [Replacement]() { return Replacement; });\n      }\n    }\n    // Privatize all private variables except for in_reduction items.\n    (void)Scope.Privatize();\n    if (InputInfo.NumberOfTargetItems > 0) {\n      InputInfo.BasePointersArray = CGF.Builder.CreateConstArrayGEP(\n          CGF.GetAddrOfLocalVar(BPVD), /*Index=*/0);\n      InputInfo.PointersArray = CGF.Builder.CreateConstArrayGEP(\n          CGF.GetAddrOfLocalVar(PVD), /*Index=*/0);\n      InputInfo.SizesArray = CGF.Builder.CreateConstArrayGEP(\n          CGF.GetAddrOfLocalVar(SVD), /*Index=*/0);\n      // If MVD is nullptr, the mapper array is not privatized\n      if (MVD)\n        InputInfo.MappersArray = CGF.Builder.CreateConstArrayGEP(\n            CGF.GetAddrOfLocalVar(MVD), /*Index=*/0);\n    }\n\n    Action.Enter(CGF);\n    OMPLexicalScope LexScope(CGF, S, OMPD_task, /*EmitPreInitStmt=*/false);\n    BodyGen(CGF);\n  };\n  llvm::Function *OutlinedFn = CGM.getOpenMPRuntime().emitTaskOutlinedFunction(\n      S, *I, *PartId, *TaskT, S.getDirectiveKind(), CodeGen, /*Tied=*/true,\n      Data.NumberOfParts);\n  llvm::APInt TrueOrFalse(32, S.hasClausesOfKind<OMPNowaitClause>() ? 1 : 0);\n  IntegerLiteral IfCond(getContext(), TrueOrFalse,\n                        getContext().getIntTypeForBitwidth(32, /*Signed=*/0),\n                        SourceLocation());\n\n  CGM.getOpenMPRuntime().emitTaskCall(*this, S.getBeginLoc(), S, OutlinedFn,\n                                      SharedsTy, CapturedStruct, &IfCond, Data);\n}\n\nvoid CodeGenFunction::EmitOMPTaskDirective(const OMPTaskDirective &S) {\n  // Emit outlined function for task construct.\n  const CapturedStmt *CS = S.getCapturedStmt(OMPD_task);\n  Address CapturedStruct = GenerateCapturedStmtArgument(*CS);\n  QualType SharedsTy = getContext().getRecordType(CS->getCapturedRecordDecl());\n  const Expr *IfCond = nullptr;\n  for (const auto *C : S.getClausesOfKind<OMPIfClause>()) {\n    if (C->getNameModifier() == OMPD_unknown ||\n        C->getNameModifier() == OMPD_task) {\n      IfCond = C->getCondition();\n      break;\n    }\n  }\n\n  OMPTaskDataTy Data;\n  // Check if we should emit tied or untied task.\n  Data.Tied = !S.getSingleClause<OMPUntiedClause>();\n  auto &&BodyGen = [CS](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitStmt(CS->getCapturedStmt());\n  };\n  auto &&TaskGen = [&S, SharedsTy, CapturedStruct,\n                    IfCond](CodeGenFunction &CGF, llvm::Function *OutlinedFn,\n                            const OMPTaskDataTy &Data) {\n    CGF.CGM.getOpenMPRuntime().emitTaskCall(CGF, S.getBeginLoc(), S, OutlinedFn,\n                                            SharedsTy, CapturedStruct, IfCond,\n                                            Data);\n  };\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n  EmitOMPTaskBasedDirective(S, OMPD_task, BodyGen, TaskGen, Data);\n}\n\nvoid CodeGenFunction::EmitOMPTaskyieldDirective(\n    const OMPTaskyieldDirective &S) {\n  CGM.getOpenMPRuntime().emitTaskyieldCall(*this, S.getBeginLoc());\n}\n\nvoid CodeGenFunction::EmitOMPBarrierDirective(const OMPBarrierDirective &S) {\n  CGM.getOpenMPRuntime().emitBarrierCall(*this, S.getBeginLoc(), OMPD_barrier);\n}\n\nvoid CodeGenFunction::EmitOMPTaskwaitDirective(const OMPTaskwaitDirective &S) {\n  CGM.getOpenMPRuntime().emitTaskwaitCall(*this, S.getBeginLoc());\n}\n\nvoid CodeGenFunction::EmitOMPTaskgroupDirective(\n    const OMPTaskgroupDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    if (const Expr *E = S.getReductionRef()) {\n      SmallVector<const Expr *, 4> LHSs;\n      SmallVector<const Expr *, 4> RHSs;\n      OMPTaskDataTy Data;\n      for (const auto *C : S.getClausesOfKind<OMPTaskReductionClause>()) {\n        Data.ReductionVars.append(C->varlist_begin(), C->varlist_end());\n        Data.ReductionOrigs.append(C->varlist_begin(), C->varlist_end());\n        Data.ReductionCopies.append(C->privates().begin(), C->privates().end());\n        Data.ReductionOps.append(C->reduction_ops().begin(),\n                                 C->reduction_ops().end());\n        LHSs.append(C->lhs_exprs().begin(), C->lhs_exprs().end());\n        RHSs.append(C->rhs_exprs().begin(), C->rhs_exprs().end());\n      }\n      llvm::Value *ReductionDesc =\n          CGF.CGM.getOpenMPRuntime().emitTaskReductionInit(CGF, S.getBeginLoc(),\n                                                           LHSs, RHSs, Data);\n      const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n      CGF.EmitVarDecl(*VD);\n      CGF.EmitStoreOfScalar(ReductionDesc, CGF.GetAddrOfLocalVar(VD),\n                            /*Volatile=*/false, E->getType());\n    }\n    CGF.EmitStmt(S.getInnermostCapturedStmt()->getCapturedStmt());\n  };\n  OMPLexicalScope Scope(*this, S, OMPD_unknown);\n  CGM.getOpenMPRuntime().emitTaskgroupRegion(*this, CodeGen, S.getBeginLoc());\n}\n\nvoid CodeGenFunction::EmitOMPFlushDirective(const OMPFlushDirective &S) {\n  llvm::AtomicOrdering AO = S.getSingleClause<OMPFlushClause>()\n                                ? llvm::AtomicOrdering::NotAtomic\n                                : llvm::AtomicOrdering::AcquireRelease;\n  CGM.getOpenMPRuntime().emitFlush(\n      *this,\n      [&S]() -> ArrayRef<const Expr *> {\n        if (const auto *FlushClause = S.getSingleClause<OMPFlushClause>())\n          return llvm::makeArrayRef(FlushClause->varlist_begin(),\n                                    FlushClause->varlist_end());\n        return llvm::None;\n      }(),\n      S.getBeginLoc(), AO);\n}\n\nvoid CodeGenFunction::EmitOMPDepobjDirective(const OMPDepobjDirective &S) {\n  const auto *DO = S.getSingleClause<OMPDepobjClause>();\n  LValue DOLVal = EmitLValue(DO->getDepobj());\n  if (const auto *DC = S.getSingleClause<OMPDependClause>()) {\n    OMPTaskDataTy::DependData Dependencies(DC->getDependencyKind(),\n                                           DC->getModifier());\n    Dependencies.DepExprs.append(DC->varlist_begin(), DC->varlist_end());\n    Address DepAddr = CGM.getOpenMPRuntime().emitDepobjDependClause(\n        *this, Dependencies, DC->getBeginLoc());\n    EmitStoreOfScalar(DepAddr.getPointer(), DOLVal);\n    return;\n  }\n  if (const auto *DC = S.getSingleClause<OMPDestroyClause>()) {\n    CGM.getOpenMPRuntime().emitDestroyClause(*this, DOLVal, DC->getBeginLoc());\n    return;\n  }\n  if (const auto *UC = S.getSingleClause<OMPUpdateClause>()) {\n    CGM.getOpenMPRuntime().emitUpdateClause(\n        *this, DOLVal, UC->getDependencyKind(), UC->getBeginLoc());\n    return;\n  }\n}\n\nvoid CodeGenFunction::EmitOMPScanDirective(const OMPScanDirective &S) {\n  if (!OMPParentLoopDirectiveForScan)\n    return;\n  const OMPExecutableDirective &ParentDir = *OMPParentLoopDirectiveForScan;\n  bool IsInclusive = S.hasClausesOfKind<OMPInclusiveClause>();\n  SmallVector<const Expr *, 4> Shareds;\n  SmallVector<const Expr *, 4> Privates;\n  SmallVector<const Expr *, 4> LHSs;\n  SmallVector<const Expr *, 4> RHSs;\n  SmallVector<const Expr *, 4> ReductionOps;\n  SmallVector<const Expr *, 4> CopyOps;\n  SmallVector<const Expr *, 4> CopyArrayTemps;\n  SmallVector<const Expr *, 4> CopyArrayElems;\n  for (const auto *C : ParentDir.getClausesOfKind<OMPReductionClause>()) {\n    if (C->getModifier() != OMPC_REDUCTION_inscan)\n      continue;\n    Shareds.append(C->varlist_begin(), C->varlist_end());\n    Privates.append(C->privates().begin(), C->privates().end());\n    LHSs.append(C->lhs_exprs().begin(), C->lhs_exprs().end());\n    RHSs.append(C->rhs_exprs().begin(), C->rhs_exprs().end());\n    ReductionOps.append(C->reduction_ops().begin(), C->reduction_ops().end());\n    CopyOps.append(C->copy_ops().begin(), C->copy_ops().end());\n    CopyArrayTemps.append(C->copy_array_temps().begin(),\n                          C->copy_array_temps().end());\n    CopyArrayElems.append(C->copy_array_elems().begin(),\n                          C->copy_array_elems().end());\n  }\n  if (ParentDir.getDirectiveKind() == OMPD_simd ||\n      (getLangOpts().OpenMPSimd &&\n       isOpenMPSimdDirective(ParentDir.getDirectiveKind()))) {\n    // For simd directive and simd-based directives in simd only mode, use the\n    // following codegen:\n    // int x = 0;\n    // #pragma omp simd reduction(inscan, +: x)\n    // for (..) {\n    //   <first part>\n    //   #pragma omp scan inclusive(x)\n    //   <second part>\n    //  }\n    // is transformed to:\n    // int x = 0;\n    // for (..) {\n    //   int x_priv = 0;\n    //   <first part>\n    //   x = x_priv + x;\n    //   x_priv = x;\n    //   <second part>\n    // }\n    // and\n    // int x = 0;\n    // #pragma omp simd reduction(inscan, +: x)\n    // for (..) {\n    //   <first part>\n    //   #pragma omp scan exclusive(x)\n    //   <second part>\n    // }\n    // to\n    // int x = 0;\n    // for (..) {\n    //   int x_priv = 0;\n    //   <second part>\n    //   int temp = x;\n    //   x = x_priv + x;\n    //   x_priv = temp;\n    //   <first part>\n    // }\n    llvm::BasicBlock *OMPScanReduce = createBasicBlock(\"omp.inscan.reduce\");\n    EmitBranch(IsInclusive\n                   ? OMPScanReduce\n                   : BreakContinueStack.back().ContinueBlock.getBlock());\n    EmitBlock(OMPScanDispatch);\n    {\n      // New scope for correct construction/destruction of temp variables for\n      // exclusive scan.\n      LexicalScope Scope(*this, S.getSourceRange());\n      EmitBranch(IsInclusive ? OMPBeforeScanBlock : OMPAfterScanBlock);\n      EmitBlock(OMPScanReduce);\n      if (!IsInclusive) {\n        // Create temp var and copy LHS value to this temp value.\n        // TMP = LHS;\n        for (unsigned I = 0, E = CopyArrayElems.size(); I < E; ++I) {\n          const Expr *PrivateExpr = Privates[I];\n          const Expr *TempExpr = CopyArrayTemps[I];\n          EmitAutoVarDecl(\n              *cast<VarDecl>(cast<DeclRefExpr>(TempExpr)->getDecl()));\n          LValue DestLVal = EmitLValue(TempExpr);\n          LValue SrcLVal = EmitLValue(LHSs[I]);\n          EmitOMPCopy(PrivateExpr->getType(), DestLVal.getAddress(*this),\n                      SrcLVal.getAddress(*this),\n                      cast<VarDecl>(cast<DeclRefExpr>(LHSs[I])->getDecl()),\n                      cast<VarDecl>(cast<DeclRefExpr>(RHSs[I])->getDecl()),\n                      CopyOps[I]);\n        }\n      }\n      CGM.getOpenMPRuntime().emitReduction(\n          *this, ParentDir.getEndLoc(), Privates, LHSs, RHSs, ReductionOps,\n          {/*WithNowait=*/true, /*SimpleReduction=*/true, OMPD_simd});\n      for (unsigned I = 0, E = CopyArrayElems.size(); I < E; ++I) {\n        const Expr *PrivateExpr = Privates[I];\n        LValue DestLVal;\n        LValue SrcLVal;\n        if (IsInclusive) {\n          DestLVal = EmitLValue(RHSs[I]);\n          SrcLVal = EmitLValue(LHSs[I]);\n        } else {\n          const Expr *TempExpr = CopyArrayTemps[I];\n          DestLVal = EmitLValue(RHSs[I]);\n          SrcLVal = EmitLValue(TempExpr);\n        }\n        EmitOMPCopy(PrivateExpr->getType(), DestLVal.getAddress(*this),\n                    SrcLVal.getAddress(*this),\n                    cast<VarDecl>(cast<DeclRefExpr>(LHSs[I])->getDecl()),\n                    cast<VarDecl>(cast<DeclRefExpr>(RHSs[I])->getDecl()),\n                    CopyOps[I]);\n      }\n    }\n    EmitBranch(IsInclusive ? OMPAfterScanBlock : OMPBeforeScanBlock);\n    OMPScanExitBlock = IsInclusive\n                           ? BreakContinueStack.back().ContinueBlock.getBlock()\n                           : OMPScanReduce;\n    EmitBlock(OMPAfterScanBlock);\n    return;\n  }\n  if (!IsInclusive) {\n    EmitBranch(BreakContinueStack.back().ContinueBlock.getBlock());\n    EmitBlock(OMPScanExitBlock);\n  }\n  if (OMPFirstScanLoop) {\n    // Emit buffer[i] = red; at the end of the input phase.\n    const auto *IVExpr = cast<OMPLoopDirective>(ParentDir)\n                             .getIterationVariable()\n                             ->IgnoreParenImpCasts();\n    LValue IdxLVal = EmitLValue(IVExpr);\n    llvm::Value *IdxVal = EmitLoadOfScalar(IdxLVal, IVExpr->getExprLoc());\n    IdxVal = Builder.CreateIntCast(IdxVal, SizeTy, /*isSigned=*/false);\n    for (unsigned I = 0, E = CopyArrayElems.size(); I < E; ++I) {\n      const Expr *PrivateExpr = Privates[I];\n      const Expr *OrigExpr = Shareds[I];\n      const Expr *CopyArrayElem = CopyArrayElems[I];\n      OpaqueValueMapping IdxMapping(\n          *this,\n          cast<OpaqueValueExpr>(\n              cast<ArraySubscriptExpr>(CopyArrayElem)->getIdx()),\n          RValue::get(IdxVal));\n      LValue DestLVal = EmitLValue(CopyArrayElem);\n      LValue SrcLVal = EmitLValue(OrigExpr);\n      EmitOMPCopy(PrivateExpr->getType(), DestLVal.getAddress(*this),\n                  SrcLVal.getAddress(*this),\n                  cast<VarDecl>(cast<DeclRefExpr>(LHSs[I])->getDecl()),\n                  cast<VarDecl>(cast<DeclRefExpr>(RHSs[I])->getDecl()),\n                  CopyOps[I]);\n    }\n  }\n  EmitBranch(BreakContinueStack.back().ContinueBlock.getBlock());\n  if (IsInclusive) {\n    EmitBlock(OMPScanExitBlock);\n    EmitBranch(BreakContinueStack.back().ContinueBlock.getBlock());\n  }\n  EmitBlock(OMPScanDispatch);\n  if (!OMPFirstScanLoop) {\n    // Emit red = buffer[i]; at the entrance to the scan phase.\n    const auto *IVExpr = cast<OMPLoopDirective>(ParentDir)\n                             .getIterationVariable()\n                             ->IgnoreParenImpCasts();\n    LValue IdxLVal = EmitLValue(IVExpr);\n    llvm::Value *IdxVal = EmitLoadOfScalar(IdxLVal, IVExpr->getExprLoc());\n    IdxVal = Builder.CreateIntCast(IdxVal, SizeTy, /*isSigned=*/false);\n    llvm::BasicBlock *ExclusiveExitBB = nullptr;\n    if (!IsInclusive) {\n      llvm::BasicBlock *ContBB = createBasicBlock(\"omp.exclusive.dec\");\n      ExclusiveExitBB = createBasicBlock(\"omp.exclusive.copy.exit\");\n      llvm::Value *Cmp = Builder.CreateIsNull(IdxVal);\n      Builder.CreateCondBr(Cmp, ExclusiveExitBB, ContBB);\n      EmitBlock(ContBB);\n      // Use idx - 1 iteration for exclusive scan.\n      IdxVal = Builder.CreateNUWSub(IdxVal, llvm::ConstantInt::get(SizeTy, 1));\n    }\n    for (unsigned I = 0, E = CopyArrayElems.size(); I < E; ++I) {\n      const Expr *PrivateExpr = Privates[I];\n      const Expr *OrigExpr = Shareds[I];\n      const Expr *CopyArrayElem = CopyArrayElems[I];\n      OpaqueValueMapping IdxMapping(\n          *this,\n          cast<OpaqueValueExpr>(\n              cast<ArraySubscriptExpr>(CopyArrayElem)->getIdx()),\n          RValue::get(IdxVal));\n      LValue SrcLVal = EmitLValue(CopyArrayElem);\n      LValue DestLVal = EmitLValue(OrigExpr);\n      EmitOMPCopy(PrivateExpr->getType(), DestLVal.getAddress(*this),\n                  SrcLVal.getAddress(*this),\n                  cast<VarDecl>(cast<DeclRefExpr>(LHSs[I])->getDecl()),\n                  cast<VarDecl>(cast<DeclRefExpr>(RHSs[I])->getDecl()),\n                  CopyOps[I]);\n    }\n    if (!IsInclusive) {\n      EmitBlock(ExclusiveExitBB);\n    }\n  }\n  EmitBranch((OMPFirstScanLoop == IsInclusive) ? OMPBeforeScanBlock\n                                               : OMPAfterScanBlock);\n  EmitBlock(OMPAfterScanBlock);\n}\n\nvoid CodeGenFunction::EmitOMPDistributeLoop(const OMPLoopDirective &S,\n                                            const CodeGenLoopTy &CodeGenLoop,\n                                            Expr *IncExpr) {\n  // Emit the loop iteration variable.\n  const auto *IVExpr = cast<DeclRefExpr>(S.getIterationVariable());\n  const auto *IVDecl = cast<VarDecl>(IVExpr->getDecl());\n  EmitVarDecl(*IVDecl);\n\n  // Emit the iterations count variable.\n  // If it is not a variable, Sema decided to calculate iterations count on each\n  // iteration (e.g., it is foldable into a constant).\n  if (const auto *LIExpr = dyn_cast<DeclRefExpr>(S.getLastIteration())) {\n    EmitVarDecl(*cast<VarDecl>(LIExpr->getDecl()));\n    // Emit calculation of the iterations count.\n    EmitIgnoredExpr(S.getCalcLastIteration());\n  }\n\n  CGOpenMPRuntime &RT = CGM.getOpenMPRuntime();\n\n  bool HasLastprivateClause = false;\n  // Check pre-condition.\n  {\n    OMPLoopScope PreInitScope(*this, S);\n    // Skip the entire loop if we don't meet the precondition.\n    // If the condition constant folds and can be elided, avoid emitting the\n    // whole loop.\n    bool CondConstant;\n    llvm::BasicBlock *ContBlock = nullptr;\n    if (ConstantFoldsToSimpleInteger(S.getPreCond(), CondConstant)) {\n      if (!CondConstant)\n        return;\n    } else {\n      llvm::BasicBlock *ThenBlock = createBasicBlock(\"omp.precond.then\");\n      ContBlock = createBasicBlock(\"omp.precond.end\");\n      emitPreCond(*this, S, S.getPreCond(), ThenBlock, ContBlock,\n                  getProfileCount(&S));\n      EmitBlock(ThenBlock);\n      incrementProfileCounter(&S);\n    }\n\n    emitAlignedClause(*this, S);\n    // Emit 'then' code.\n    {\n      // Emit helper vars inits.\n\n      LValue LB = EmitOMPHelperVar(\n          *this, cast<DeclRefExpr>(\n                     (isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                          ? S.getCombinedLowerBoundVariable()\n                          : S.getLowerBoundVariable())));\n      LValue UB = EmitOMPHelperVar(\n          *this, cast<DeclRefExpr>(\n                     (isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                          ? S.getCombinedUpperBoundVariable()\n                          : S.getUpperBoundVariable())));\n      LValue ST =\n          EmitOMPHelperVar(*this, cast<DeclRefExpr>(S.getStrideVariable()));\n      LValue IL =\n          EmitOMPHelperVar(*this, cast<DeclRefExpr>(S.getIsLastIterVariable()));\n\n      OMPPrivateScope LoopScope(*this);\n      if (EmitOMPFirstprivateClause(S, LoopScope)) {\n        // Emit implicit barrier to synchronize threads and avoid data races\n        // on initialization of firstprivate variables and post-update of\n        // lastprivate variables.\n        CGM.getOpenMPRuntime().emitBarrierCall(\n            *this, S.getBeginLoc(), OMPD_unknown, /*EmitChecks=*/false,\n            /*ForceSimpleCall=*/true);\n      }\n      EmitOMPPrivateClause(S, LoopScope);\n      if (isOpenMPSimdDirective(S.getDirectiveKind()) &&\n          !isOpenMPParallelDirective(S.getDirectiveKind()) &&\n          !isOpenMPTeamsDirective(S.getDirectiveKind()))\n        EmitOMPReductionClauseInit(S, LoopScope);\n      HasLastprivateClause = EmitOMPLastprivateClauseInit(S, LoopScope);\n      EmitOMPPrivateLoopCounters(S, LoopScope);\n      (void)LoopScope.Privatize();\n      if (isOpenMPTargetExecutionDirective(S.getDirectiveKind()))\n        CGM.getOpenMPRuntime().adjustTargetSpecificDataForLambdas(*this, S);\n\n      // Detect the distribute schedule kind and chunk.\n      llvm::Value *Chunk = nullptr;\n      OpenMPDistScheduleClauseKind ScheduleKind = OMPC_DIST_SCHEDULE_unknown;\n      if (const auto *C = S.getSingleClause<OMPDistScheduleClause>()) {\n        ScheduleKind = C->getDistScheduleKind();\n        if (const Expr *Ch = C->getChunkSize()) {\n          Chunk = EmitScalarExpr(Ch);\n          Chunk = EmitScalarConversion(Chunk, Ch->getType(),\n                                       S.getIterationVariable()->getType(),\n                                       S.getBeginLoc());\n        }\n      } else {\n        // Default behaviour for dist_schedule clause.\n        CGM.getOpenMPRuntime().getDefaultDistScheduleAndChunk(\n            *this, S, ScheduleKind, Chunk);\n      }\n      const unsigned IVSize = getContext().getTypeSize(IVExpr->getType());\n      const bool IVSigned = IVExpr->getType()->hasSignedIntegerRepresentation();\n\n      // OpenMP [2.10.8, distribute Construct, Description]\n      // If dist_schedule is specified, kind must be static. If specified,\n      // iterations are divided into chunks of size chunk_size, chunks are\n      // assigned to the teams of the league in a round-robin fashion in the\n      // order of the team number. When no chunk_size is specified, the\n      // iteration space is divided into chunks that are approximately equal\n      // in size, and at most one chunk is distributed to each team of the\n      // league. The size of the chunks is unspecified in this case.\n      bool StaticChunked = RT.isStaticChunked(\n          ScheduleKind, /* Chunked */ Chunk != nullptr) &&\n          isOpenMPLoopBoundSharingDirective(S.getDirectiveKind());\n      if (RT.isStaticNonchunked(ScheduleKind,\n                                /* Chunked */ Chunk != nullptr) ||\n          StaticChunked) {\n        CGOpenMPRuntime::StaticRTInput StaticInit(\n            IVSize, IVSigned, /* Ordered = */ false, IL.getAddress(*this),\n            LB.getAddress(*this), UB.getAddress(*this), ST.getAddress(*this),\n            StaticChunked ? Chunk : nullptr);\n        RT.emitDistributeStaticInit(*this, S.getBeginLoc(), ScheduleKind,\n                                    StaticInit);\n        JumpDest LoopExit =\n            getJumpDestInCurrentScope(createBasicBlock(\"omp.loop.exit\"));\n        // UB = min(UB, GlobalUB);\n        EmitIgnoredExpr(isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                            ? S.getCombinedEnsureUpperBound()\n                            : S.getEnsureUpperBound());\n        // IV = LB;\n        EmitIgnoredExpr(isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                            ? S.getCombinedInit()\n                            : S.getInit());\n\n        const Expr *Cond =\n            isOpenMPLoopBoundSharingDirective(S.getDirectiveKind())\n                ? S.getCombinedCond()\n                : S.getCond();\n\n        if (StaticChunked)\n          Cond = S.getCombinedDistCond();\n\n        // For static unchunked schedules generate:\n        //\n        //  1. For distribute alone, codegen\n        //    while (idx <= UB) {\n        //      BODY;\n        //      ++idx;\n        //    }\n        //\n        //  2. When combined with 'for' (e.g. as in 'distribute parallel for')\n        //    while (idx <= UB) {\n        //      <CodeGen rest of pragma>(LB, UB);\n        //      idx += ST;\n        //    }\n        //\n        // For static chunk one schedule generate:\n        //\n        // while (IV <= GlobalUB) {\n        //   <CodeGen rest of pragma>(LB, UB);\n        //   LB += ST;\n        //   UB += ST;\n        //   UB = min(UB, GlobalUB);\n        //   IV = LB;\n        // }\n        //\n        emitCommonSimdLoop(\n            *this, S,\n            [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n              if (isOpenMPSimdDirective(S.getDirectiveKind()))\n                CGF.EmitOMPSimdInit(S, /*IsMonotonic=*/true);\n            },\n            [&S, &LoopScope, Cond, IncExpr, LoopExit, &CodeGenLoop,\n             StaticChunked](CodeGenFunction &CGF, PrePostActionTy &) {\n              CGF.EmitOMPInnerLoop(\n                  S, LoopScope.requiresCleanups(), Cond, IncExpr,\n                  [&S, LoopExit, &CodeGenLoop](CodeGenFunction &CGF) {\n                    CodeGenLoop(CGF, S, LoopExit);\n                  },\n                  [&S, StaticChunked](CodeGenFunction &CGF) {\n                    if (StaticChunked) {\n                      CGF.EmitIgnoredExpr(S.getCombinedNextLowerBound());\n                      CGF.EmitIgnoredExpr(S.getCombinedNextUpperBound());\n                      CGF.EmitIgnoredExpr(S.getCombinedEnsureUpperBound());\n                      CGF.EmitIgnoredExpr(S.getCombinedInit());\n                    }\n                  });\n            });\n        EmitBlock(LoopExit.getBlock());\n        // Tell the runtime we are done.\n        RT.emitForStaticFinish(*this, S.getEndLoc(), S.getDirectiveKind());\n      } else {\n        // Emit the outer loop, which requests its work chunk [LB..UB] from\n        // runtime and runs the inner loop to process it.\n        const OMPLoopArguments LoopArguments = {\n            LB.getAddress(*this), UB.getAddress(*this), ST.getAddress(*this),\n            IL.getAddress(*this), Chunk};\n        EmitOMPDistributeOuterLoop(ScheduleKind, S, LoopScope, LoopArguments,\n                                   CodeGenLoop);\n      }\n      if (isOpenMPSimdDirective(S.getDirectiveKind())) {\n        EmitOMPSimdFinal(S, [IL, &S](CodeGenFunction &CGF) {\n          return CGF.Builder.CreateIsNotNull(\n              CGF.EmitLoadOfScalar(IL, S.getBeginLoc()));\n        });\n      }\n      if (isOpenMPSimdDirective(S.getDirectiveKind()) &&\n          !isOpenMPParallelDirective(S.getDirectiveKind()) &&\n          !isOpenMPTeamsDirective(S.getDirectiveKind())) {\n        EmitOMPReductionClauseFinal(S, OMPD_simd);\n        // Emit post-update of the reduction variables if IsLastIter != 0.\n        emitPostUpdateForReductionClause(\n            *this, S, [IL, &S](CodeGenFunction &CGF) {\n              return CGF.Builder.CreateIsNotNull(\n                  CGF.EmitLoadOfScalar(IL, S.getBeginLoc()));\n            });\n      }\n      // Emit final copy of the lastprivate variables if IsLastIter != 0.\n      if (HasLastprivateClause) {\n        EmitOMPLastprivateClauseFinal(\n            S, /*NoFinals=*/false,\n            Builder.CreateIsNotNull(EmitLoadOfScalar(IL, S.getBeginLoc())));\n      }\n    }\n\n    // We're now done with the loop, so jump to the continuation block.\n    if (ContBlock) {\n      EmitBranch(ContBlock);\n      EmitBlock(ContBlock, true);\n    }\n  }\n}\n\nvoid CodeGenFunction::EmitOMPDistributeDirective(\n    const OMPDistributeDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitOMPLoopBodyWithStopPoint, S.getInc());\n  };\n  OMPLexicalScope Scope(*this, S, OMPD_unknown);\n  CGM.getOpenMPRuntime().emitInlinedDirective(*this, OMPD_distribute, CodeGen);\n}\n\nstatic llvm::Function *emitOutlinedOrderedFunction(CodeGenModule &CGM,\n                                                   const CapturedStmt *S,\n                                                   SourceLocation Loc) {\n  CodeGenFunction CGF(CGM, /*suppressNewContext=*/true);\n  CodeGenFunction::CGCapturedStmtInfo CapStmtInfo;\n  CGF.CapturedStmtInfo = &CapStmtInfo;\n  llvm::Function *Fn = CGF.GenerateOpenMPCapturedStmtFunction(*S, Loc);\n  Fn->setDoesNotRecurse();\n  return Fn;\n}\n\nvoid CodeGenFunction::EmitOMPOrderedDirective(const OMPOrderedDirective &S) {\n  if (S.hasClausesOfKind<OMPDependClause>()) {\n    assert(!S.hasAssociatedStmt() &&\n           \"No associated statement must be in ordered depend construct.\");\n    for (const auto *DC : S.getClausesOfKind<OMPDependClause>())\n      CGM.getOpenMPRuntime().emitDoacrossOrdered(*this, DC);\n    return;\n  }\n  const auto *C = S.getSingleClause<OMPSIMDClause>();\n  auto &&CodeGen = [&S, C, this](CodeGenFunction &CGF,\n                                 PrePostActionTy &Action) {\n    const CapturedStmt *CS = S.getInnermostCapturedStmt();\n    if (C) {\n      llvm::SmallVector<llvm::Value *, 16> CapturedVars;\n      CGF.GenerateOpenMPCapturedVars(*CS, CapturedVars);\n      llvm::Function *OutlinedFn =\n          emitOutlinedOrderedFunction(CGM, CS, S.getBeginLoc());\n      CGM.getOpenMPRuntime().emitOutlinedFunctionCall(CGF, S.getBeginLoc(),\n                                                      OutlinedFn, CapturedVars);\n    } else {\n      Action.Enter(CGF);\n      CGF.EmitStmt(CS->getCapturedStmt());\n    }\n  };\n  OMPLexicalScope Scope(*this, S, OMPD_unknown);\n  CGM.getOpenMPRuntime().emitOrderedRegion(*this, CodeGen, S.getBeginLoc(), !C);\n}\n\nstatic llvm::Value *convertToScalarValue(CodeGenFunction &CGF, RValue Val,\n                                         QualType SrcType, QualType DestType,\n                                         SourceLocation Loc) {\n  assert(CGF.hasScalarEvaluationKind(DestType) &&\n         \"DestType must have scalar evaluation kind.\");\n  assert(!Val.isAggregate() && \"Must be a scalar or complex.\");\n  return Val.isScalar() ? CGF.EmitScalarConversion(Val.getScalarVal(), SrcType,\n                                                   DestType, Loc)\n                        : CGF.EmitComplexToScalarConversion(\n                              Val.getComplexVal(), SrcType, DestType, Loc);\n}\n\nstatic CodeGenFunction::ComplexPairTy\nconvertToComplexValue(CodeGenFunction &CGF, RValue Val, QualType SrcType,\n                      QualType DestType, SourceLocation Loc) {\n  assert(CGF.getEvaluationKind(DestType) == TEK_Complex &&\n         \"DestType must have complex evaluation kind.\");\n  CodeGenFunction::ComplexPairTy ComplexVal;\n  if (Val.isScalar()) {\n    // Convert the input element to the element type of the complex.\n    QualType DestElementType =\n        DestType->castAs<ComplexType>()->getElementType();\n    llvm::Value *ScalarVal = CGF.EmitScalarConversion(\n        Val.getScalarVal(), SrcType, DestElementType, Loc);\n    ComplexVal = CodeGenFunction::ComplexPairTy(\n        ScalarVal, llvm::Constant::getNullValue(ScalarVal->getType()));\n  } else {\n    assert(Val.isComplex() && \"Must be a scalar or complex.\");\n    QualType SrcElementType = SrcType->castAs<ComplexType>()->getElementType();\n    QualType DestElementType =\n        DestType->castAs<ComplexType>()->getElementType();\n    ComplexVal.first = CGF.EmitScalarConversion(\n        Val.getComplexVal().first, SrcElementType, DestElementType, Loc);\n    ComplexVal.second = CGF.EmitScalarConversion(\n        Val.getComplexVal().second, SrcElementType, DestElementType, Loc);\n  }\n  return ComplexVal;\n}\n\nstatic void emitSimpleAtomicStore(CodeGenFunction &CGF, llvm::AtomicOrdering AO,\n                                  LValue LVal, RValue RVal) {\n  if (LVal.isGlobalReg())\n    CGF.EmitStoreThroughGlobalRegLValue(RVal, LVal);\n  else\n    CGF.EmitAtomicStore(RVal, LVal, AO, LVal.isVolatile(), /*isInit=*/false);\n}\n\nstatic RValue emitSimpleAtomicLoad(CodeGenFunction &CGF,\n                                   llvm::AtomicOrdering AO, LValue LVal,\n                                   SourceLocation Loc) {\n  if (LVal.isGlobalReg())\n    return CGF.EmitLoadOfLValue(LVal, Loc);\n  return CGF.EmitAtomicLoad(\n      LVal, Loc, llvm::AtomicCmpXchgInst::getStrongestFailureOrdering(AO),\n      LVal.isVolatile());\n}\n\nvoid CodeGenFunction::emitOMPSimpleStore(LValue LVal, RValue RVal,\n                                         QualType RValTy, SourceLocation Loc) {\n  switch (getEvaluationKind(LVal.getType())) {\n  case TEK_Scalar:\n    EmitStoreThroughLValue(RValue::get(convertToScalarValue(\n                               *this, RVal, RValTy, LVal.getType(), Loc)),\n                           LVal);\n    break;\n  case TEK_Complex:\n    EmitStoreOfComplex(\n        convertToComplexValue(*this, RVal, RValTy, LVal.getType(), Loc), LVal,\n        /*isInit=*/false);\n    break;\n  case TEK_Aggregate:\n    llvm_unreachable(\"Must be a scalar or complex.\");\n  }\n}\n\nstatic void emitOMPAtomicReadExpr(CodeGenFunction &CGF, llvm::AtomicOrdering AO,\n                                  const Expr *X, const Expr *V,\n                                  SourceLocation Loc) {\n  // v = x;\n  assert(V->isLValue() && \"V of 'omp atomic read' is not lvalue\");\n  assert(X->isLValue() && \"X of 'omp atomic read' is not lvalue\");\n  LValue XLValue = CGF.EmitLValue(X);\n  LValue VLValue = CGF.EmitLValue(V);\n  RValue Res = emitSimpleAtomicLoad(CGF, AO, XLValue, Loc);\n  // OpenMP, 2.17.7, atomic Construct\n  // If the read or capture clause is specified and the acquire, acq_rel, or\n  // seq_cst clause is specified then the strong flush on exit from the atomic\n  // operation is also an acquire flush.\n  switch (AO) {\n  case llvm::AtomicOrdering::Acquire:\n  case llvm::AtomicOrdering::AcquireRelease:\n  case llvm::AtomicOrdering::SequentiallyConsistent:\n    CGF.CGM.getOpenMPRuntime().emitFlush(CGF, llvm::None, Loc,\n                                         llvm::AtomicOrdering::Acquire);\n    break;\n  case llvm::AtomicOrdering::Monotonic:\n  case llvm::AtomicOrdering::Release:\n    break;\n  case llvm::AtomicOrdering::NotAtomic:\n  case llvm::AtomicOrdering::Unordered:\n    llvm_unreachable(\"Unexpected ordering.\");\n  }\n  CGF.emitOMPSimpleStore(VLValue, Res, X->getType().getNonReferenceType(), Loc);\n  CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, V);\n}\n\nstatic void emitOMPAtomicWriteExpr(CodeGenFunction &CGF,\n                                   llvm::AtomicOrdering AO, const Expr *X,\n                                   const Expr *E, SourceLocation Loc) {\n  // x = expr;\n  assert(X->isLValue() && \"X of 'omp atomic write' is not lvalue\");\n  emitSimpleAtomicStore(CGF, AO, CGF.EmitLValue(X), CGF.EmitAnyExpr(E));\n  CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, X);\n  // OpenMP, 2.17.7, atomic Construct\n  // If the write, update, or capture clause is specified and the release,\n  // acq_rel, or seq_cst clause is specified then the strong flush on entry to\n  // the atomic operation is also a release flush.\n  switch (AO) {\n  case llvm::AtomicOrdering::Release:\n  case llvm::AtomicOrdering::AcquireRelease:\n  case llvm::AtomicOrdering::SequentiallyConsistent:\n    CGF.CGM.getOpenMPRuntime().emitFlush(CGF, llvm::None, Loc,\n                                         llvm::AtomicOrdering::Release);\n    break;\n  case llvm::AtomicOrdering::Acquire:\n  case llvm::AtomicOrdering::Monotonic:\n    break;\n  case llvm::AtomicOrdering::NotAtomic:\n  case llvm::AtomicOrdering::Unordered:\n    llvm_unreachable(\"Unexpected ordering.\");\n  }\n}\n\nstatic std::pair<bool, RValue> emitOMPAtomicRMW(CodeGenFunction &CGF, LValue X,\n                                                RValue Update,\n                                                BinaryOperatorKind BO,\n                                                llvm::AtomicOrdering AO,\n                                                bool IsXLHSInRHSPart) {\n  ASTContext &Context = CGF.getContext();\n  // Allow atomicrmw only if 'x' and 'update' are integer values, lvalue for 'x'\n  // expression is simple and atomic is allowed for the given type for the\n  // target platform.\n  if (BO == BO_Comma || !Update.isScalar() ||\n      !Update.getScalarVal()->getType()->isIntegerTy() || !X.isSimple() ||\n      (!isa<llvm::ConstantInt>(Update.getScalarVal()) &&\n       (Update.getScalarVal()->getType() !=\n        X.getAddress(CGF).getElementType())) ||\n      !X.getAddress(CGF).getElementType()->isIntegerTy() ||\n      !Context.getTargetInfo().hasBuiltinAtomic(\n          Context.getTypeSize(X.getType()), Context.toBits(X.getAlignment())))\n    return std::make_pair(false, RValue::get(nullptr));\n\n  llvm::AtomicRMWInst::BinOp RMWOp;\n  switch (BO) {\n  case BO_Add:\n    RMWOp = llvm::AtomicRMWInst::Add;\n    break;\n  case BO_Sub:\n    if (!IsXLHSInRHSPart)\n      return std::make_pair(false, RValue::get(nullptr));\n    RMWOp = llvm::AtomicRMWInst::Sub;\n    break;\n  case BO_And:\n    RMWOp = llvm::AtomicRMWInst::And;\n    break;\n  case BO_Or:\n    RMWOp = llvm::AtomicRMWInst::Or;\n    break;\n  case BO_Xor:\n    RMWOp = llvm::AtomicRMWInst::Xor;\n    break;\n  case BO_LT:\n    RMWOp = X.getType()->hasSignedIntegerRepresentation()\n                ? (IsXLHSInRHSPart ? llvm::AtomicRMWInst::Min\n                                   : llvm::AtomicRMWInst::Max)\n                : (IsXLHSInRHSPart ? llvm::AtomicRMWInst::UMin\n                                   : llvm::AtomicRMWInst::UMax);\n    break;\n  case BO_GT:\n    RMWOp = X.getType()->hasSignedIntegerRepresentation()\n                ? (IsXLHSInRHSPart ? llvm::AtomicRMWInst::Max\n                                   : llvm::AtomicRMWInst::Min)\n                : (IsXLHSInRHSPart ? llvm::AtomicRMWInst::UMax\n                                   : llvm::AtomicRMWInst::UMin);\n    break;\n  case BO_Assign:\n    RMWOp = llvm::AtomicRMWInst::Xchg;\n    break;\n  case BO_Mul:\n  case BO_Div:\n  case BO_Rem:\n  case BO_Shl:\n  case BO_Shr:\n  case BO_LAnd:\n  case BO_LOr:\n    return std::make_pair(false, RValue::get(nullptr));\n  case BO_PtrMemD:\n  case BO_PtrMemI:\n  case BO_LE:\n  case BO_GE:\n  case BO_EQ:\n  case BO_NE:\n  case BO_Cmp:\n  case BO_AddAssign:\n  case BO_SubAssign:\n  case BO_AndAssign:\n  case BO_OrAssign:\n  case BO_XorAssign:\n  case BO_MulAssign:\n  case BO_DivAssign:\n  case BO_RemAssign:\n  case BO_ShlAssign:\n  case BO_ShrAssign:\n  case BO_Comma:\n    llvm_unreachable(\"Unsupported atomic update operation\");\n  }\n  llvm::Value *UpdateVal = Update.getScalarVal();\n  if (auto *IC = dyn_cast<llvm::ConstantInt>(UpdateVal)) {\n    UpdateVal = CGF.Builder.CreateIntCast(\n        IC, X.getAddress(CGF).getElementType(),\n        X.getType()->hasSignedIntegerRepresentation());\n  }\n  llvm::Value *Res =\n      CGF.Builder.CreateAtomicRMW(RMWOp, X.getPointer(CGF), UpdateVal, AO);\n  return std::make_pair(true, RValue::get(Res));\n}\n\nstd::pair<bool, RValue> CodeGenFunction::EmitOMPAtomicSimpleUpdateExpr(\n    LValue X, RValue E, BinaryOperatorKind BO, bool IsXLHSInRHSPart,\n    llvm::AtomicOrdering AO, SourceLocation Loc,\n    const llvm::function_ref<RValue(RValue)> CommonGen) {\n  // Update expressions are allowed to have the following forms:\n  // x binop= expr; -> xrval + expr;\n  // x++, ++x -> xrval + 1;\n  // x--, --x -> xrval - 1;\n  // x = x binop expr; -> xrval binop expr\n  // x = expr Op x; - > expr binop xrval;\n  auto Res = emitOMPAtomicRMW(*this, X, E, BO, AO, IsXLHSInRHSPart);\n  if (!Res.first) {\n    if (X.isGlobalReg()) {\n      // Emit an update expression: 'xrval' binop 'expr' or 'expr' binop\n      // 'xrval'.\n      EmitStoreThroughLValue(CommonGen(EmitLoadOfLValue(X, Loc)), X);\n    } else {\n      // Perform compare-and-swap procedure.\n      EmitAtomicUpdate(X, AO, CommonGen, X.getType().isVolatileQualified());\n    }\n  }\n  return Res;\n}\n\nstatic void emitOMPAtomicUpdateExpr(CodeGenFunction &CGF,\n                                    llvm::AtomicOrdering AO, const Expr *X,\n                                    const Expr *E, const Expr *UE,\n                                    bool IsXLHSInRHSPart, SourceLocation Loc) {\n  assert(isa<BinaryOperator>(UE->IgnoreImpCasts()) &&\n         \"Update expr in 'atomic update' must be a binary operator.\");\n  const auto *BOUE = cast<BinaryOperator>(UE->IgnoreImpCasts());\n  // Update expressions are allowed to have the following forms:\n  // x binop= expr; -> xrval + expr;\n  // x++, ++x -> xrval + 1;\n  // x--, --x -> xrval - 1;\n  // x = x binop expr; -> xrval binop expr\n  // x = expr Op x; - > expr binop xrval;\n  assert(X->isLValue() && \"X of 'omp atomic update' is not lvalue\");\n  LValue XLValue = CGF.EmitLValue(X);\n  RValue ExprRValue = CGF.EmitAnyExpr(E);\n  const auto *LHS = cast<OpaqueValueExpr>(BOUE->getLHS()->IgnoreImpCasts());\n  const auto *RHS = cast<OpaqueValueExpr>(BOUE->getRHS()->IgnoreImpCasts());\n  const OpaqueValueExpr *XRValExpr = IsXLHSInRHSPart ? LHS : RHS;\n  const OpaqueValueExpr *ERValExpr = IsXLHSInRHSPart ? RHS : LHS;\n  auto &&Gen = [&CGF, UE, ExprRValue, XRValExpr, ERValExpr](RValue XRValue) {\n    CodeGenFunction::OpaqueValueMapping MapExpr(CGF, ERValExpr, ExprRValue);\n    CodeGenFunction::OpaqueValueMapping MapX(CGF, XRValExpr, XRValue);\n    return CGF.EmitAnyExpr(UE);\n  };\n  (void)CGF.EmitOMPAtomicSimpleUpdateExpr(\n      XLValue, ExprRValue, BOUE->getOpcode(), IsXLHSInRHSPart, AO, Loc, Gen);\n  CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, X);\n  // OpenMP, 2.17.7, atomic Construct\n  // If the write, update, or capture clause is specified and the release,\n  // acq_rel, or seq_cst clause is specified then the strong flush on entry to\n  // the atomic operation is also a release flush.\n  switch (AO) {\n  case llvm::AtomicOrdering::Release:\n  case llvm::AtomicOrdering::AcquireRelease:\n  case llvm::AtomicOrdering::SequentiallyConsistent:\n    CGF.CGM.getOpenMPRuntime().emitFlush(CGF, llvm::None, Loc,\n                                         llvm::AtomicOrdering::Release);\n    break;\n  case llvm::AtomicOrdering::Acquire:\n  case llvm::AtomicOrdering::Monotonic:\n    break;\n  case llvm::AtomicOrdering::NotAtomic:\n  case llvm::AtomicOrdering::Unordered:\n    llvm_unreachable(\"Unexpected ordering.\");\n  }\n}\n\nstatic RValue convertToType(CodeGenFunction &CGF, RValue Value,\n                            QualType SourceType, QualType ResType,\n                            SourceLocation Loc) {\n  switch (CGF.getEvaluationKind(ResType)) {\n  case TEK_Scalar:\n    return RValue::get(\n        convertToScalarValue(CGF, Value, SourceType, ResType, Loc));\n  case TEK_Complex: {\n    auto Res = convertToComplexValue(CGF, Value, SourceType, ResType, Loc);\n    return RValue::getComplex(Res.first, Res.second);\n  }\n  case TEK_Aggregate:\n    break;\n  }\n  llvm_unreachable(\"Must be a scalar or complex.\");\n}\n\nstatic void emitOMPAtomicCaptureExpr(CodeGenFunction &CGF,\n                                     llvm::AtomicOrdering AO,\n                                     bool IsPostfixUpdate, const Expr *V,\n                                     const Expr *X, const Expr *E,\n                                     const Expr *UE, bool IsXLHSInRHSPart,\n                                     SourceLocation Loc) {\n  assert(X->isLValue() && \"X of 'omp atomic capture' is not lvalue\");\n  assert(V->isLValue() && \"V of 'omp atomic capture' is not lvalue\");\n  RValue NewVVal;\n  LValue VLValue = CGF.EmitLValue(V);\n  LValue XLValue = CGF.EmitLValue(X);\n  RValue ExprRValue = CGF.EmitAnyExpr(E);\n  QualType NewVValType;\n  if (UE) {\n    // 'x' is updated with some additional value.\n    assert(isa<BinaryOperator>(UE->IgnoreImpCasts()) &&\n           \"Update expr in 'atomic capture' must be a binary operator.\");\n    const auto *BOUE = cast<BinaryOperator>(UE->IgnoreImpCasts());\n    // Update expressions are allowed to have the following forms:\n    // x binop= expr; -> xrval + expr;\n    // x++, ++x -> xrval + 1;\n    // x--, --x -> xrval - 1;\n    // x = x binop expr; -> xrval binop expr\n    // x = expr Op x; - > expr binop xrval;\n    const auto *LHS = cast<OpaqueValueExpr>(BOUE->getLHS()->IgnoreImpCasts());\n    const auto *RHS = cast<OpaqueValueExpr>(BOUE->getRHS()->IgnoreImpCasts());\n    const OpaqueValueExpr *XRValExpr = IsXLHSInRHSPart ? LHS : RHS;\n    NewVValType = XRValExpr->getType();\n    const OpaqueValueExpr *ERValExpr = IsXLHSInRHSPart ? RHS : LHS;\n    auto &&Gen = [&CGF, &NewVVal, UE, ExprRValue, XRValExpr, ERValExpr,\n                  IsPostfixUpdate](RValue XRValue) {\n      CodeGenFunction::OpaqueValueMapping MapExpr(CGF, ERValExpr, ExprRValue);\n      CodeGenFunction::OpaqueValueMapping MapX(CGF, XRValExpr, XRValue);\n      RValue Res = CGF.EmitAnyExpr(UE);\n      NewVVal = IsPostfixUpdate ? XRValue : Res;\n      return Res;\n    };\n    auto Res = CGF.EmitOMPAtomicSimpleUpdateExpr(\n        XLValue, ExprRValue, BOUE->getOpcode(), IsXLHSInRHSPart, AO, Loc, Gen);\n    CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, X);\n    if (Res.first) {\n      // 'atomicrmw' instruction was generated.\n      if (IsPostfixUpdate) {\n        // Use old value from 'atomicrmw'.\n        NewVVal = Res.second;\n      } else {\n        // 'atomicrmw' does not provide new value, so evaluate it using old\n        // value of 'x'.\n        CodeGenFunction::OpaqueValueMapping MapExpr(CGF, ERValExpr, ExprRValue);\n        CodeGenFunction::OpaqueValueMapping MapX(CGF, XRValExpr, Res.second);\n        NewVVal = CGF.EmitAnyExpr(UE);\n      }\n    }\n  } else {\n    // 'x' is simply rewritten with some 'expr'.\n    NewVValType = X->getType().getNonReferenceType();\n    ExprRValue = convertToType(CGF, ExprRValue, E->getType(),\n                               X->getType().getNonReferenceType(), Loc);\n    auto &&Gen = [&NewVVal, ExprRValue](RValue XRValue) {\n      NewVVal = XRValue;\n      return ExprRValue;\n    };\n    // Try to perform atomicrmw xchg, otherwise simple exchange.\n    auto Res = CGF.EmitOMPAtomicSimpleUpdateExpr(\n        XLValue, ExprRValue, /*BO=*/BO_Assign, /*IsXLHSInRHSPart=*/false, AO,\n        Loc, Gen);\n    CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, X);\n    if (Res.first) {\n      // 'atomicrmw' instruction was generated.\n      NewVVal = IsPostfixUpdate ? Res.second : ExprRValue;\n    }\n  }\n  // Emit post-update store to 'v' of old/new 'x' value.\n  CGF.emitOMPSimpleStore(VLValue, NewVVal, NewVValType, Loc);\n  CGF.CGM.getOpenMPRuntime().checkAndEmitLastprivateConditional(CGF, V);\n  // OpenMP, 2.17.7, atomic Construct\n  // If the write, update, or capture clause is specified and the release,\n  // acq_rel, or seq_cst clause is specified then the strong flush on entry to\n  // the atomic operation is also a release flush.\n  // If the read or capture clause is specified and the acquire, acq_rel, or\n  // seq_cst clause is specified then the strong flush on exit from the atomic\n  // operation is also an acquire flush.\n  switch (AO) {\n  case llvm::AtomicOrdering::Release:\n    CGF.CGM.getOpenMPRuntime().emitFlush(CGF, llvm::None, Loc,\n                                         llvm::AtomicOrdering::Release);\n    break;\n  case llvm::AtomicOrdering::Acquire:\n    CGF.CGM.getOpenMPRuntime().emitFlush(CGF, llvm::None, Loc,\n                                         llvm::AtomicOrdering::Acquire);\n    break;\n  case llvm::AtomicOrdering::AcquireRelease:\n  case llvm::AtomicOrdering::SequentiallyConsistent:\n    CGF.CGM.getOpenMPRuntime().emitFlush(CGF, llvm::None, Loc,\n                                         llvm::AtomicOrdering::AcquireRelease);\n    break;\n  case llvm::AtomicOrdering::Monotonic:\n    break;\n  case llvm::AtomicOrdering::NotAtomic:\n  case llvm::AtomicOrdering::Unordered:\n    llvm_unreachable(\"Unexpected ordering.\");\n  }\n}\n\nstatic void emitOMPAtomicExpr(CodeGenFunction &CGF, OpenMPClauseKind Kind,\n                              llvm::AtomicOrdering AO, bool IsPostfixUpdate,\n                              const Expr *X, const Expr *V, const Expr *E,\n                              const Expr *UE, bool IsXLHSInRHSPart,\n                              SourceLocation Loc) {\n  switch (Kind) {\n  case OMPC_read:\n    emitOMPAtomicReadExpr(CGF, AO, X, V, Loc);\n    break;\n  case OMPC_write:\n    emitOMPAtomicWriteExpr(CGF, AO, X, E, Loc);\n    break;\n  case OMPC_unknown:\n  case OMPC_update:\n    emitOMPAtomicUpdateExpr(CGF, AO, X, E, UE, IsXLHSInRHSPart, Loc);\n    break;\n  case OMPC_capture:\n    emitOMPAtomicCaptureExpr(CGF, AO, IsPostfixUpdate, V, X, E, UE,\n                             IsXLHSInRHSPart, Loc);\n    break;\n  case OMPC_if:\n  case OMPC_final:\n  case OMPC_num_threads:\n  case OMPC_private:\n  case OMPC_firstprivate:\n  case OMPC_lastprivate:\n  case OMPC_reduction:\n  case OMPC_task_reduction:\n  case OMPC_in_reduction:\n  case OMPC_safelen:\n  case OMPC_simdlen:\n  case OMPC_sizes:\n  case OMPC_allocator:\n  case OMPC_allocate:\n  case OMPC_collapse:\n  case OMPC_default:\n  case OMPC_seq_cst:\n  case OMPC_acq_rel:\n  case OMPC_acquire:\n  case OMPC_release:\n  case OMPC_relaxed:\n  case OMPC_shared:\n  case OMPC_linear:\n  case OMPC_aligned:\n  case OMPC_copyin:\n  case OMPC_copyprivate:\n  case OMPC_flush:\n  case OMPC_depobj:\n  case OMPC_proc_bind:\n  case OMPC_schedule:\n  case OMPC_ordered:\n  case OMPC_nowait:\n  case OMPC_untied:\n  case OMPC_threadprivate:\n  case OMPC_depend:\n  case OMPC_mergeable:\n  case OMPC_device:\n  case OMPC_threads:\n  case OMPC_simd:\n  case OMPC_map:\n  case OMPC_num_teams:\n  case OMPC_thread_limit:\n  case OMPC_priority:\n  case OMPC_grainsize:\n  case OMPC_nogroup:\n  case OMPC_num_tasks:\n  case OMPC_hint:\n  case OMPC_dist_schedule:\n  case OMPC_defaultmap:\n  case OMPC_uniform:\n  case OMPC_to:\n  case OMPC_from:\n  case OMPC_use_device_ptr:\n  case OMPC_use_device_addr:\n  case OMPC_is_device_ptr:\n  case OMPC_unified_address:\n  case OMPC_unified_shared_memory:\n  case OMPC_reverse_offload:\n  case OMPC_dynamic_allocators:\n  case OMPC_atomic_default_mem_order:\n  case OMPC_device_type:\n  case OMPC_match:\n  case OMPC_nontemporal:\n  case OMPC_order:\n  case OMPC_destroy:\n  case OMPC_detach:\n  case OMPC_inclusive:\n  case OMPC_exclusive:\n  case OMPC_uses_allocators:\n  case OMPC_affinity:\n  default:\n    llvm_unreachable(\"Clause is not allowed in 'omp atomic'.\");\n  }\n}\n\nvoid CodeGenFunction::EmitOMPAtomicDirective(const OMPAtomicDirective &S) {\n  llvm::AtomicOrdering AO = llvm::AtomicOrdering::Monotonic;\n  bool MemOrderingSpecified = false;\n  if (S.getSingleClause<OMPSeqCstClause>()) {\n    AO = llvm::AtomicOrdering::SequentiallyConsistent;\n    MemOrderingSpecified = true;\n  } else if (S.getSingleClause<OMPAcqRelClause>()) {\n    AO = llvm::AtomicOrdering::AcquireRelease;\n    MemOrderingSpecified = true;\n  } else if (S.getSingleClause<OMPAcquireClause>()) {\n    AO = llvm::AtomicOrdering::Acquire;\n    MemOrderingSpecified = true;\n  } else if (S.getSingleClause<OMPReleaseClause>()) {\n    AO = llvm::AtomicOrdering::Release;\n    MemOrderingSpecified = true;\n  } else if (S.getSingleClause<OMPRelaxedClause>()) {\n    AO = llvm::AtomicOrdering::Monotonic;\n    MemOrderingSpecified = true;\n  }\n  OpenMPClauseKind Kind = OMPC_unknown;\n  for (const OMPClause *C : S.clauses()) {\n    // Find first clause (skip seq_cst|acq_rel|aqcuire|release|relaxed clause,\n    // if it is first).\n    if (C->getClauseKind() != OMPC_seq_cst &&\n        C->getClauseKind() != OMPC_acq_rel &&\n        C->getClauseKind() != OMPC_acquire &&\n        C->getClauseKind() != OMPC_release &&\n        C->getClauseKind() != OMPC_relaxed) {\n      Kind = C->getClauseKind();\n      break;\n    }\n  }\n  if (!MemOrderingSpecified) {\n    llvm::AtomicOrdering DefaultOrder =\n        CGM.getOpenMPRuntime().getDefaultMemoryOrdering();\n    if (DefaultOrder == llvm::AtomicOrdering::Monotonic ||\n        DefaultOrder == llvm::AtomicOrdering::SequentiallyConsistent ||\n        (DefaultOrder == llvm::AtomicOrdering::AcquireRelease &&\n         Kind == OMPC_capture)) {\n      AO = DefaultOrder;\n    } else if (DefaultOrder == llvm::AtomicOrdering::AcquireRelease) {\n      if (Kind == OMPC_unknown || Kind == OMPC_update || Kind == OMPC_write) {\n        AO = llvm::AtomicOrdering::Release;\n      } else if (Kind == OMPC_read) {\n        assert(Kind == OMPC_read && \"Unexpected atomic kind.\");\n        AO = llvm::AtomicOrdering::Acquire;\n      }\n    }\n  }\n\n  LexicalScope Scope(*this, S.getSourceRange());\n  EmitStopPoint(S.getAssociatedStmt());\n  emitOMPAtomicExpr(*this, Kind, AO, S.isPostfixUpdate(), S.getX(), S.getV(),\n                    S.getExpr(), S.getUpdateExpr(), S.isXLHSInRHSPart(),\n                    S.getBeginLoc());\n}\n\nstatic void emitCommonOMPTargetDirective(CodeGenFunction &CGF,\n                                         const OMPExecutableDirective &S,\n                                         const RegionCodeGenTy &CodeGen) {\n  assert(isOpenMPTargetExecutionDirective(S.getDirectiveKind()));\n  CodeGenModule &CGM = CGF.CGM;\n\n  // On device emit this construct as inlined code.\n  if (CGM.getLangOpts().OpenMPIsDevice) {\n    OMPLexicalScope Scope(CGF, S, OMPD_target);\n    CGM.getOpenMPRuntime().emitInlinedDirective(\n        CGF, OMPD_target, [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n          CGF.EmitStmt(S.getInnermostCapturedStmt()->getCapturedStmt());\n        });\n    return;\n  }\n\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(CGF, S);\n  llvm::Function *Fn = nullptr;\n  llvm::Constant *FnID = nullptr;\n\n  const Expr *IfCond = nullptr;\n  // Check for the at most one if clause associated with the target region.\n  for (const auto *C : S.getClausesOfKind<OMPIfClause>()) {\n    if (C->getNameModifier() == OMPD_unknown ||\n        C->getNameModifier() == OMPD_target) {\n      IfCond = C->getCondition();\n      break;\n    }\n  }\n\n  // Check if we have any device clause associated with the directive.\n  llvm::PointerIntPair<const Expr *, 2, OpenMPDeviceClauseModifier> Device(\n      nullptr, OMPC_DEVICE_unknown);\n  if (auto *C = S.getSingleClause<OMPDeviceClause>())\n    Device.setPointerAndInt(C->getDevice(), C->getModifier());\n\n  // Check if we have an if clause whose conditional always evaluates to false\n  // or if we do not have any targets specified. If so the target region is not\n  // an offload entry point.\n  bool IsOffloadEntry = true;\n  if (IfCond) {\n    bool Val;\n    if (CGF.ConstantFoldsToSimpleInteger(IfCond, Val) && !Val)\n      IsOffloadEntry = false;\n  }\n  if (CGM.getLangOpts().OMPTargetTriples.empty())\n    IsOffloadEntry = false;\n\n  assert(CGF.CurFuncDecl && \"No parent declaration for target region!\");\n  StringRef ParentName;\n  // In case we have Ctors/Dtors we use the complete type variant to produce\n  // the mangling of the device outlined kernel.\n  if (const auto *D = dyn_cast<CXXConstructorDecl>(CGF.CurFuncDecl))\n    ParentName = CGM.getMangledName(GlobalDecl(D, Ctor_Complete));\n  else if (const auto *D = dyn_cast<CXXDestructorDecl>(CGF.CurFuncDecl))\n    ParentName = CGM.getMangledName(GlobalDecl(D, Dtor_Complete));\n  else\n    ParentName =\n        CGM.getMangledName(GlobalDecl(cast<FunctionDecl>(CGF.CurFuncDecl)));\n\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(S, ParentName, Fn, FnID,\n                                                    IsOffloadEntry, CodeGen);\n  OMPLexicalScope Scope(CGF, S, OMPD_task);\n  auto &&SizeEmitter =\n      [IsOffloadEntry](CodeGenFunction &CGF,\n                       const OMPLoopDirective &D) -> llvm::Value * {\n    if (IsOffloadEntry) {\n      OMPLoopScope(CGF, D);\n      // Emit calculation of the iterations count.\n      llvm::Value *NumIterations = CGF.EmitScalarExpr(D.getNumIterations());\n      NumIterations = CGF.Builder.CreateIntCast(NumIterations, CGF.Int64Ty,\n                                                /*isSigned=*/false);\n      return NumIterations;\n    }\n    return nullptr;\n  };\n  CGM.getOpenMPRuntime().emitTargetCall(CGF, S, Fn, FnID, IfCond, Device,\n                                        SizeEmitter);\n}\n\nstatic void emitTargetRegion(CodeGenFunction &CGF, const OMPTargetDirective &S,\n                             PrePostActionTy &Action) {\n  Action.Enter(CGF);\n  CodeGenFunction::OMPPrivateScope PrivateScope(CGF);\n  (void)CGF.EmitOMPFirstprivateClause(S, PrivateScope);\n  CGF.EmitOMPPrivateClause(S, PrivateScope);\n  (void)PrivateScope.Privatize();\n  if (isOpenMPTargetExecutionDirective(S.getDirectiveKind()))\n    CGF.CGM.getOpenMPRuntime().adjustTargetSpecificDataForLambdas(CGF, S);\n\n  CGF.EmitStmt(S.getCapturedStmt(OMPD_target)->getCapturedStmt());\n}\n\nvoid CodeGenFunction::EmitOMPTargetDeviceFunction(CodeGenModule &CGM,\n                                                  StringRef ParentName,\n                                                  const OMPTargetDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetRegion(CGF, S, Action);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetDirective(const OMPTargetDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetRegion(CGF, S, Action);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nstatic void emitCommonOMPTeamsDirective(CodeGenFunction &CGF,\n                                        const OMPExecutableDirective &S,\n                                        OpenMPDirectiveKind InnermostKind,\n                                        const RegionCodeGenTy &CodeGen) {\n  const CapturedStmt *CS = S.getCapturedStmt(OMPD_teams);\n  llvm::Function *OutlinedFn =\n      CGF.CGM.getOpenMPRuntime().emitTeamsOutlinedFunction(\n          S, *CS->getCapturedDecl()->param_begin(), InnermostKind, CodeGen);\n\n  const auto *NT = S.getSingleClause<OMPNumTeamsClause>();\n  const auto *TL = S.getSingleClause<OMPThreadLimitClause>();\n  if (NT || TL) {\n    const Expr *NumTeams = NT ? NT->getNumTeams() : nullptr;\n    const Expr *ThreadLimit = TL ? TL->getThreadLimit() : nullptr;\n\n    CGF.CGM.getOpenMPRuntime().emitNumTeamsClause(CGF, NumTeams, ThreadLimit,\n                                                  S.getBeginLoc());\n  }\n\n  OMPTeamsScope Scope(CGF, S);\n  llvm::SmallVector<llvm::Value *, 16> CapturedVars;\n  CGF.GenerateOpenMPCapturedVars(*CS, CapturedVars);\n  CGF.CGM.getOpenMPRuntime().emitTeamsCall(CGF, S, S.getBeginLoc(), OutlinedFn,\n                                           CapturedVars);\n}\n\nvoid CodeGenFunction::EmitOMPTeamsDirective(const OMPTeamsDirective &S) {\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope PrivateScope(CGF);\n    (void)CGF.EmitOMPFirstprivateClause(S, PrivateScope);\n    CGF.EmitOMPPrivateClause(S, PrivateScope);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.EmitStmt(S.getCapturedStmt(OMPD_teams)->getCapturedStmt());\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(*this, S, OMPD_distribute, CodeGen);\n  emitPostUpdateForReductionClause(*this, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nstatic void emitTargetTeamsRegion(CodeGenFunction &CGF, PrePostActionTy &Action,\n                                  const OMPTargetTeamsDirective &S) {\n  auto *CS = S.getCapturedStmt(OMPD_teams);\n  Action.Enter(CGF);\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S, CS](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CodeGenFunction::OMPPrivateScope PrivateScope(CGF);\n    (void)CGF.EmitOMPFirstprivateClause(S, PrivateScope);\n    CGF.EmitOMPPrivateClause(S, PrivateScope);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    if (isOpenMPTargetExecutionDirective(S.getDirectiveKind()))\n      CGF.CGM.getOpenMPRuntime().adjustTargetSpecificDataForLambdas(CGF, S);\n    CGF.EmitStmt(CS->getCapturedStmt());\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(CGF, S, OMPD_teams, CodeGen);\n  emitPostUpdateForReductionClause(CGF, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetTeamsDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsRegion(CGF, Action, S);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDirective(\n    const OMPTargetTeamsDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsRegion(CGF, Action, S);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nstatic void\nemitTargetTeamsDistributeRegion(CodeGenFunction &CGF, PrePostActionTy &Action,\n                                const OMPTargetTeamsDistributeDirective &S) {\n  Action.Enter(CGF);\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitOMPLoopBodyWithStopPoint, S.getInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                            PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CodeGenFunction::OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(CGF, OMPD_distribute,\n                                                    CodeGenDistribute);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(CGF, S, OMPD_distribute, CodeGen);\n  emitPostUpdateForReductionClause(CGF, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetTeamsDistributeDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeRegion(CGF, Action, S);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeDirective(\n    const OMPTargetTeamsDistributeDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeRegion(CGF, Action, S);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nstatic void emitTargetTeamsDistributeSimdRegion(\n    CodeGenFunction &CGF, PrePostActionTy &Action,\n    const OMPTargetTeamsDistributeSimdDirective &S) {\n  Action.Enter(CGF);\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitOMPLoopBodyWithStopPoint, S.getInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                            PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CodeGenFunction::OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(CGF, OMPD_distribute,\n                                                    CodeGenDistribute);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(CGF, S, OMPD_distribute_simd, CodeGen);\n  emitPostUpdateForReductionClause(CGF, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeSimdDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetTeamsDistributeSimdDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeSimdRegion(CGF, Action, S);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeSimdDirective(\n    const OMPTargetTeamsDistributeSimdDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeSimdRegion(CGF, Action, S);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nvoid CodeGenFunction::EmitOMPTeamsDistributeDirective(\n    const OMPTeamsDistributeDirective &S) {\n\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitOMPLoopBodyWithStopPoint, S.getInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                            PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(CGF, OMPD_distribute,\n                                                    CodeGenDistribute);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(*this, S, OMPD_distribute, CodeGen);\n  emitPostUpdateForReductionClause(*this, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTeamsDistributeSimdDirective(\n    const OMPTeamsDistributeSimdDirective &S) {\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitOMPLoopBodyWithStopPoint, S.getInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                            PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(CGF, OMPD_simd,\n                                                    CodeGenDistribute);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(*this, S, OMPD_distribute_simd, CodeGen);\n  emitPostUpdateForReductionClause(*this, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTeamsDistributeParallelForDirective(\n    const OMPTeamsDistributeParallelForDirective &S) {\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitInnerParallelForWhenCombined,\n                              S.getDistInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                            PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(CGF, OMPD_distribute,\n                                                    CodeGenDistribute);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(*this, S, OMPD_distribute_parallel_for, CodeGen);\n  emitPostUpdateForReductionClause(*this, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTeamsDistributeParallelForSimdDirective(\n    const OMPTeamsDistributeParallelForSimdDirective &S) {\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitInnerParallelForWhenCombined,\n                              S.getDistInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGen = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                            PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(\n        CGF, OMPD_distribute, CodeGenDistribute, /*HasCancel=*/false);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n  emitCommonOMPTeamsDirective(*this, S, OMPD_distribute_parallel_for_simd,\n                              CodeGen);\n  emitPostUpdateForReductionClause(*this, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nstatic void emitTargetTeamsDistributeParallelForRegion(\n    CodeGenFunction &CGF, const OMPTargetTeamsDistributeParallelForDirective &S,\n    PrePostActionTy &Action) {\n  Action.Enter(CGF);\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitInnerParallelForWhenCombined,\n                              S.getDistInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGenTeams = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                                 PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CodeGenFunction::OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(\n        CGF, OMPD_distribute, CodeGenDistribute, /*HasCancel=*/false);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n\n  emitCommonOMPTeamsDirective(CGF, S, OMPD_distribute_parallel_for,\n                              CodeGenTeams);\n  emitPostUpdateForReductionClause(CGF, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeParallelForDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetTeamsDistributeParallelForDirective &S) {\n  // Emit SPMD target teams distribute parallel for region as a standalone\n  // region.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeParallelForRegion(CGF, S, Action);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeParallelForDirective(\n    const OMPTargetTeamsDistributeParallelForDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeParallelForRegion(CGF, S, Action);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nstatic void emitTargetTeamsDistributeParallelForSimdRegion(\n    CodeGenFunction &CGF,\n    const OMPTargetTeamsDistributeParallelForSimdDirective &S,\n    PrePostActionTy &Action) {\n  Action.Enter(CGF);\n  auto &&CodeGenDistribute = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n    CGF.EmitOMPDistributeLoop(S, emitInnerParallelForWhenCombined,\n                              S.getDistInc());\n  };\n\n  // Emit teams region as a standalone region.\n  auto &&CodeGenTeams = [&S, &CodeGenDistribute](CodeGenFunction &CGF,\n                                                 PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CodeGenFunction::OMPPrivateScope PrivateScope(CGF);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(\n        CGF, OMPD_distribute, CodeGenDistribute, /*HasCancel=*/false);\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_teams);\n  };\n\n  emitCommonOMPTeamsDirective(CGF, S, OMPD_distribute_parallel_for_simd,\n                              CodeGenTeams);\n  emitPostUpdateForReductionClause(CGF, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeParallelForSimdDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetTeamsDistributeParallelForSimdDirective &S) {\n  // Emit SPMD target teams distribute parallel for simd region as a standalone\n  // region.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeParallelForSimdRegion(CGF, S, Action);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetTeamsDistributeParallelForSimdDirective(\n    const OMPTargetTeamsDistributeParallelForSimdDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetTeamsDistributeParallelForSimdRegion(CGF, S, Action);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nvoid CodeGenFunction::EmitOMPCancellationPointDirective(\n    const OMPCancellationPointDirective &S) {\n  CGM.getOpenMPRuntime().emitCancellationPointCall(*this, S.getBeginLoc(),\n                                                   S.getCancelRegion());\n}\n\nvoid CodeGenFunction::EmitOMPCancelDirective(const OMPCancelDirective &S) {\n  const Expr *IfCond = nullptr;\n  for (const auto *C : S.getClausesOfKind<OMPIfClause>()) {\n    if (C->getNameModifier() == OMPD_unknown ||\n        C->getNameModifier() == OMPD_cancel) {\n      IfCond = C->getCondition();\n      break;\n    }\n  }\n  if (CGM.getLangOpts().OpenMPIRBuilder) {\n    llvm::OpenMPIRBuilder &OMPBuilder = CGM.getOpenMPRuntime().getOMPBuilder();\n    // TODO: This check is necessary as we only generate `omp parallel` through\n    // the OpenMPIRBuilder for now.\n    if (S.getCancelRegion() == OMPD_parallel) {\n      llvm::Value *IfCondition = nullptr;\n      if (IfCond)\n        IfCondition = EmitScalarExpr(IfCond,\n                                     /*IgnoreResultAssign=*/true);\n      return Builder.restoreIP(\n          OMPBuilder.createCancel(Builder, IfCondition, S.getCancelRegion()));\n    }\n  }\n\n  CGM.getOpenMPRuntime().emitCancelCall(*this, S.getBeginLoc(), IfCond,\n                                        S.getCancelRegion());\n}\n\nCodeGenFunction::JumpDest\nCodeGenFunction::getOMPCancelDestination(OpenMPDirectiveKind Kind) {\n  if (Kind == OMPD_parallel || Kind == OMPD_task ||\n      Kind == OMPD_target_parallel || Kind == OMPD_taskloop ||\n      Kind == OMPD_master_taskloop || Kind == OMPD_parallel_master_taskloop)\n    return ReturnBlock;\n  assert(Kind == OMPD_for || Kind == OMPD_section || Kind == OMPD_sections ||\n         Kind == OMPD_parallel_sections || Kind == OMPD_parallel_for ||\n         Kind == OMPD_distribute_parallel_for ||\n         Kind == OMPD_target_parallel_for ||\n         Kind == OMPD_teams_distribute_parallel_for ||\n         Kind == OMPD_target_teams_distribute_parallel_for);\n  return OMPCancelStack.getExitBlock();\n}\n\nvoid CodeGenFunction::EmitOMPUseDevicePtrClause(\n    const OMPUseDevicePtrClause &C, OMPPrivateScope &PrivateScope,\n    const llvm::DenseMap<const ValueDecl *, Address> &CaptureDeviceAddrMap) {\n  auto OrigVarIt = C.varlist_begin();\n  auto InitIt = C.inits().begin();\n  for (const Expr *PvtVarIt : C.private_copies()) {\n    const auto *OrigVD = cast<VarDecl>(cast<DeclRefExpr>(*OrigVarIt)->getDecl());\n    const auto *InitVD = cast<VarDecl>(cast<DeclRefExpr>(*InitIt)->getDecl());\n    const auto *PvtVD = cast<VarDecl>(cast<DeclRefExpr>(PvtVarIt)->getDecl());\n\n    // In order to identify the right initializer we need to match the\n    // declaration used by the mapping logic. In some cases we may get\n    // OMPCapturedExprDecl that refers to the original declaration.\n    const ValueDecl *MatchingVD = OrigVD;\n    if (const auto *OED = dyn_cast<OMPCapturedExprDecl>(MatchingVD)) {\n      // OMPCapturedExprDecl are used to privative fields of the current\n      // structure.\n      const auto *ME = cast<MemberExpr>(OED->getInit());\n      assert(isa<CXXThisExpr>(ME->getBase()) &&\n             \"Base should be the current struct!\");\n      MatchingVD = ME->getMemberDecl();\n    }\n\n    // If we don't have information about the current list item, move on to\n    // the next one.\n    auto InitAddrIt = CaptureDeviceAddrMap.find(MatchingVD);\n    if (InitAddrIt == CaptureDeviceAddrMap.end())\n      continue;\n\n    bool IsRegistered = PrivateScope.addPrivate(OrigVD, [this, OrigVD,\n                                                         InitAddrIt, InitVD,\n                                                         PvtVD]() {\n      // Initialize the temporary initialization variable with the address we\n      // get from the runtime library. We have to cast the source address\n      // because it is always a void *. References are materialized in the\n      // privatization scope, so the initialization here disregards the fact\n      // the original variable is a reference.\n      QualType AddrQTy =\n          getContext().getPointerType(OrigVD->getType().getNonReferenceType());\n      llvm::Type *AddrTy = ConvertTypeForMem(AddrQTy);\n      Address InitAddr = Builder.CreateBitCast(InitAddrIt->second, AddrTy);\n      setAddrOfLocalVar(InitVD, InitAddr);\n\n      // Emit private declaration, it will be initialized by the value we\n      // declaration we just added to the local declarations map.\n      EmitDecl(*PvtVD);\n\n      // The initialization variables reached its purpose in the emission\n      // of the previous declaration, so we don't need it anymore.\n      LocalDeclMap.erase(InitVD);\n\n      // Return the address of the private variable.\n      return GetAddrOfLocalVar(PvtVD);\n    });\n    assert(IsRegistered && \"firstprivate var already registered as private\");\n    // Silence the warning about unused variable.\n    (void)IsRegistered;\n\n    ++OrigVarIt;\n    ++InitIt;\n  }\n}\n\nstatic const VarDecl *getBaseDecl(const Expr *Ref) {\n  const Expr *Base = Ref->IgnoreParenImpCasts();\n  while (const auto *OASE = dyn_cast<OMPArraySectionExpr>(Base))\n    Base = OASE->getBase()->IgnoreParenImpCasts();\n  while (const auto *ASE = dyn_cast<ArraySubscriptExpr>(Base))\n    Base = ASE->getBase()->IgnoreParenImpCasts();\n  return cast<VarDecl>(cast<DeclRefExpr>(Base)->getDecl());\n}\n\nvoid CodeGenFunction::EmitOMPUseDeviceAddrClause(\n    const OMPUseDeviceAddrClause &C, OMPPrivateScope &PrivateScope,\n    const llvm::DenseMap<const ValueDecl *, Address> &CaptureDeviceAddrMap) {\n  llvm::SmallDenseSet<CanonicalDeclPtr<const Decl>, 4> Processed;\n  for (const Expr *Ref : C.varlists()) {\n    const VarDecl *OrigVD = getBaseDecl(Ref);\n    if (!Processed.insert(OrigVD).second)\n      continue;\n    // In order to identify the right initializer we need to match the\n    // declaration used by the mapping logic. In some cases we may get\n    // OMPCapturedExprDecl that refers to the original declaration.\n    const ValueDecl *MatchingVD = OrigVD;\n    if (const auto *OED = dyn_cast<OMPCapturedExprDecl>(MatchingVD)) {\n      // OMPCapturedExprDecl are used to privative fields of the current\n      // structure.\n      const auto *ME = cast<MemberExpr>(OED->getInit());\n      assert(isa<CXXThisExpr>(ME->getBase()) &&\n             \"Base should be the current struct!\");\n      MatchingVD = ME->getMemberDecl();\n    }\n\n    // If we don't have information about the current list item, move on to\n    // the next one.\n    auto InitAddrIt = CaptureDeviceAddrMap.find(MatchingVD);\n    if (InitAddrIt == CaptureDeviceAddrMap.end())\n      continue;\n\n    Address PrivAddr = InitAddrIt->getSecond();\n    // For declrefs and variable length array need to load the pointer for\n    // correct mapping, since the pointer to the data was passed to the runtime.\n    if (isa<DeclRefExpr>(Ref->IgnoreParenImpCasts()) ||\n        MatchingVD->getType()->isArrayType())\n      PrivAddr =\n          EmitLoadOfPointer(PrivAddr, getContext()\n                                          .getPointerType(OrigVD->getType())\n                                          ->castAs<PointerType>());\n    llvm::Type *RealTy =\n        ConvertTypeForMem(OrigVD->getType().getNonReferenceType())\n            ->getPointerTo();\n    PrivAddr = Builder.CreatePointerBitCastOrAddrSpaceCast(PrivAddr, RealTy);\n\n    (void)PrivateScope.addPrivate(OrigVD, [PrivAddr]() { return PrivAddr; });\n  }\n}\n\n// Generate the instructions for '#pragma omp target data' directive.\nvoid CodeGenFunction::EmitOMPTargetDataDirective(\n    const OMPTargetDataDirective &S) {\n  CGOpenMPRuntime::TargetDataInfo Info(/*RequiresDevicePointerInfo=*/true,\n                                       /*SeparateBeginEndCalls=*/true);\n\n  // Create a pre/post action to signal the privatization of the device pointer.\n  // This action can be replaced by the OpenMP runtime code generation to\n  // deactivate privatization.\n  bool PrivatizeDevicePointers = false;\n  class DevicePointerPrivActionTy : public PrePostActionTy {\n    bool &PrivatizeDevicePointers;\n\n  public:\n    explicit DevicePointerPrivActionTy(bool &PrivatizeDevicePointers)\n        : PrePostActionTy(), PrivatizeDevicePointers(PrivatizeDevicePointers) {}\n    void Enter(CodeGenFunction &CGF) override {\n      PrivatizeDevicePointers = true;\n    }\n  };\n  DevicePointerPrivActionTy PrivAction(PrivatizeDevicePointers);\n\n  auto &&CodeGen = [&S, &Info, &PrivatizeDevicePointers](\n                       CodeGenFunction &CGF, PrePostActionTy &Action) {\n    auto &&InnermostCodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n      CGF.EmitStmt(S.getInnermostCapturedStmt()->getCapturedStmt());\n    };\n\n    // Codegen that selects whether to generate the privatization code or not.\n    auto &&PrivCodeGen = [&S, &Info, &PrivatizeDevicePointers,\n                          &InnermostCodeGen](CodeGenFunction &CGF,\n                                             PrePostActionTy &Action) {\n      RegionCodeGenTy RCG(InnermostCodeGen);\n      PrivatizeDevicePointers = false;\n\n      // Call the pre-action to change the status of PrivatizeDevicePointers if\n      // needed.\n      Action.Enter(CGF);\n\n      if (PrivatizeDevicePointers) {\n        OMPPrivateScope PrivateScope(CGF);\n        // Emit all instances of the use_device_ptr clause.\n        for (const auto *C : S.getClausesOfKind<OMPUseDevicePtrClause>())\n          CGF.EmitOMPUseDevicePtrClause(*C, PrivateScope,\n                                        Info.CaptureDeviceAddrMap);\n        for (const auto *C : S.getClausesOfKind<OMPUseDeviceAddrClause>())\n          CGF.EmitOMPUseDeviceAddrClause(*C, PrivateScope,\n                                         Info.CaptureDeviceAddrMap);\n        (void)PrivateScope.Privatize();\n        RCG(CGF);\n      } else {\n        OMPLexicalScope Scope(CGF, S, OMPD_unknown);\n        RCG(CGF);\n      }\n    };\n\n    // Forward the provided action to the privatization codegen.\n    RegionCodeGenTy PrivRCG(PrivCodeGen);\n    PrivRCG.setAction(Action);\n\n    // Notwithstanding the body of the region is emitted as inlined directive,\n    // we don't use an inline scope as changes in the references inside the\n    // region are expected to be visible outside, so we do not privative them.\n    OMPLexicalScope Scope(CGF, S);\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(CGF, OMPD_target_data,\n                                                    PrivRCG);\n  };\n\n  RegionCodeGenTy RCG(CodeGen);\n\n  // If we don't have target devices, don't bother emitting the data mapping\n  // code.\n  if (CGM.getLangOpts().OMPTargetTriples.empty()) {\n    RCG(*this);\n    return;\n  }\n\n  // Check if we have any if clause associated with the directive.\n  const Expr *IfCond = nullptr;\n  if (const auto *C = S.getSingleClause<OMPIfClause>())\n    IfCond = C->getCondition();\n\n  // Check if we have any device clause associated with the directive.\n  const Expr *Device = nullptr;\n  if (const auto *C = S.getSingleClause<OMPDeviceClause>())\n    Device = C->getDevice();\n\n  // Set the action to signal privatization of device pointers.\n  RCG.setAction(PrivAction);\n\n  // Emit region code.\n  CGM.getOpenMPRuntime().emitTargetDataCalls(*this, S, IfCond, Device, RCG,\n                                             Info);\n}\n\nvoid CodeGenFunction::EmitOMPTargetEnterDataDirective(\n    const OMPTargetEnterDataDirective &S) {\n  // If we don't have target devices, don't bother emitting the data mapping\n  // code.\n  if (CGM.getLangOpts().OMPTargetTriples.empty())\n    return;\n\n  // Check if we have any if clause associated with the directive.\n  const Expr *IfCond = nullptr;\n  if (const auto *C = S.getSingleClause<OMPIfClause>())\n    IfCond = C->getCondition();\n\n  // Check if we have any device clause associated with the directive.\n  const Expr *Device = nullptr;\n  if (const auto *C = S.getSingleClause<OMPDeviceClause>())\n    Device = C->getDevice();\n\n  OMPLexicalScope Scope(*this, S, OMPD_task);\n  CGM.getOpenMPRuntime().emitTargetDataStandAloneCall(*this, S, IfCond, Device);\n}\n\nvoid CodeGenFunction::EmitOMPTargetExitDataDirective(\n    const OMPTargetExitDataDirective &S) {\n  // If we don't have target devices, don't bother emitting the data mapping\n  // code.\n  if (CGM.getLangOpts().OMPTargetTriples.empty())\n    return;\n\n  // Check if we have any if clause associated with the directive.\n  const Expr *IfCond = nullptr;\n  if (const auto *C = S.getSingleClause<OMPIfClause>())\n    IfCond = C->getCondition();\n\n  // Check if we have any device clause associated with the directive.\n  const Expr *Device = nullptr;\n  if (const auto *C = S.getSingleClause<OMPDeviceClause>())\n    Device = C->getDevice();\n\n  OMPLexicalScope Scope(*this, S, OMPD_task);\n  CGM.getOpenMPRuntime().emitTargetDataStandAloneCall(*this, S, IfCond, Device);\n}\n\nstatic void emitTargetParallelRegion(CodeGenFunction &CGF,\n                                     const OMPTargetParallelDirective &S,\n                                     PrePostActionTy &Action) {\n  // Get the captured statement associated with the 'parallel' region.\n  const CapturedStmt *CS = S.getCapturedStmt(OMPD_parallel);\n  Action.Enter(CGF);\n  auto &&CodeGen = [&S, CS](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CodeGenFunction::OMPPrivateScope PrivateScope(CGF);\n    (void)CGF.EmitOMPFirstprivateClause(S, PrivateScope);\n    CGF.EmitOMPPrivateClause(S, PrivateScope);\n    CGF.EmitOMPReductionClauseInit(S, PrivateScope);\n    (void)PrivateScope.Privatize();\n    if (isOpenMPTargetExecutionDirective(S.getDirectiveKind()))\n      CGF.CGM.getOpenMPRuntime().adjustTargetSpecificDataForLambdas(CGF, S);\n    // TODO: Add support for clauses.\n    CGF.EmitStmt(CS->getCapturedStmt());\n    CGF.EmitOMPReductionClauseFinal(S, /*ReductionKind=*/OMPD_parallel);\n  };\n  emitCommonOMPParallelDirective(CGF, S, OMPD_parallel, CodeGen,\n                                 emitEmptyBoundParameters);\n  emitPostUpdateForReductionClause(CGF, S,\n                                   [](CodeGenFunction &) { return nullptr; });\n}\n\nvoid CodeGenFunction::EmitOMPTargetParallelDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetParallelDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetParallelRegion(CGF, S, Action);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetParallelDirective(\n    const OMPTargetParallelDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetParallelRegion(CGF, S, Action);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nstatic void emitTargetParallelForRegion(CodeGenFunction &CGF,\n                                        const OMPTargetParallelForDirective &S,\n                                        PrePostActionTy &Action) {\n  Action.Enter(CGF);\n  // Emit directive as a combined directive that consists of two implicit\n  // directives: 'parallel' with 'for' directive.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CodeGenFunction::OMPCancelStackRAII CancelRegion(\n        CGF, OMPD_target_parallel_for, S.hasCancel());\n    CGF.EmitOMPWorksharingLoop(S, S.getEnsureUpperBound(), emitForLoopBounds,\n                               emitDispatchForLoopBounds);\n  };\n  emitCommonOMPParallelDirective(CGF, S, OMPD_for, CodeGen,\n                                 emitEmptyBoundParameters);\n}\n\nvoid CodeGenFunction::EmitOMPTargetParallelForDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetParallelForDirective &S) {\n  // Emit SPMD target parallel for region as a standalone region.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetParallelForRegion(CGF, S, Action);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetParallelForDirective(\n    const OMPTargetParallelForDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetParallelForRegion(CGF, S, Action);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\nstatic void\nemitTargetParallelForSimdRegion(CodeGenFunction &CGF,\n                                const OMPTargetParallelForSimdDirective &S,\n                                PrePostActionTy &Action) {\n  Action.Enter(CGF);\n  // Emit directive as a combined directive that consists of two implicit\n  // directives: 'parallel' with 'for' directive.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    CGF.EmitOMPWorksharingLoop(S, S.getEnsureUpperBound(), emitForLoopBounds,\n                               emitDispatchForLoopBounds);\n  };\n  emitCommonOMPParallelDirective(CGF, S, OMPD_simd, CodeGen,\n                                 emitEmptyBoundParameters);\n}\n\nvoid CodeGenFunction::EmitOMPTargetParallelForSimdDeviceFunction(\n    CodeGenModule &CGM, StringRef ParentName,\n    const OMPTargetParallelForSimdDirective &S) {\n  // Emit SPMD target parallel for region as a standalone region.\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetParallelForSimdRegion(CGF, S, Action);\n  };\n  llvm::Function *Fn;\n  llvm::Constant *Addr;\n  // Emit target region as a standalone region.\n  CGM.getOpenMPRuntime().emitTargetOutlinedFunction(\n      S, ParentName, Fn, Addr, /*IsOffloadEntry=*/true, CodeGen);\n  assert(Fn && Addr && \"Target device function emission failed.\");\n}\n\nvoid CodeGenFunction::EmitOMPTargetParallelForSimdDirective(\n    const OMPTargetParallelForSimdDirective &S) {\n  auto &&CodeGen = [&S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    emitTargetParallelForSimdRegion(CGF, S, Action);\n  };\n  emitCommonOMPTargetDirective(*this, S, CodeGen);\n}\n\n/// Emit a helper variable and return corresponding lvalue.\nstatic void mapParam(CodeGenFunction &CGF, const DeclRefExpr *Helper,\n                     const ImplicitParamDecl *PVD,\n                     CodeGenFunction::OMPPrivateScope &Privates) {\n  const auto *VDecl = cast<VarDecl>(Helper->getDecl());\n  Privates.addPrivate(VDecl,\n                      [&CGF, PVD]() { return CGF.GetAddrOfLocalVar(PVD); });\n}\n\nvoid CodeGenFunction::EmitOMPTaskLoopBasedDirective(const OMPLoopDirective &S) {\n  assert(isOpenMPTaskLoopDirective(S.getDirectiveKind()));\n  // Emit outlined function for task construct.\n  const CapturedStmt *CS = S.getCapturedStmt(OMPD_taskloop);\n  Address CapturedStruct = Address::invalid();\n  {\n    OMPLexicalScope Scope(*this, S, OMPD_taskloop, /*EmitPreInitStmt=*/false);\n    CapturedStruct = GenerateCapturedStmtArgument(*CS);\n  }\n  QualType SharedsTy = getContext().getRecordType(CS->getCapturedRecordDecl());\n  const Expr *IfCond = nullptr;\n  for (const auto *C : S.getClausesOfKind<OMPIfClause>()) {\n    if (C->getNameModifier() == OMPD_unknown ||\n        C->getNameModifier() == OMPD_taskloop) {\n      IfCond = C->getCondition();\n      break;\n    }\n  }\n\n  OMPTaskDataTy Data;\n  // Check if taskloop must be emitted without taskgroup.\n  Data.Nogroup = S.getSingleClause<OMPNogroupClause>();\n  // TODO: Check if we should emit tied or untied task.\n  Data.Tied = true;\n  // Set scheduling for taskloop\n  if (const auto* Clause = S.getSingleClause<OMPGrainsizeClause>()) {\n    // grainsize clause\n    Data.Schedule.setInt(/*IntVal=*/false);\n    Data.Schedule.setPointer(EmitScalarExpr(Clause->getGrainsize()));\n  } else if (const auto* Clause = S.getSingleClause<OMPNumTasksClause>()) {\n    // num_tasks clause\n    Data.Schedule.setInt(/*IntVal=*/true);\n    Data.Schedule.setPointer(EmitScalarExpr(Clause->getNumTasks()));\n  }\n\n  auto &&BodyGen = [CS, &S](CodeGenFunction &CGF, PrePostActionTy &) {\n    // if (PreCond) {\n    //   for (IV in 0..LastIteration) BODY;\n    //   <Final counter/linear vars updates>;\n    // }\n    //\n\n    // Emit: if (PreCond) - begin.\n    // If the condition constant folds and can be elided, avoid emitting the\n    // whole loop.\n    bool CondConstant;\n    llvm::BasicBlock *ContBlock = nullptr;\n    OMPLoopScope PreInitScope(CGF, S);\n    if (CGF.ConstantFoldsToSimpleInteger(S.getPreCond(), CondConstant)) {\n      if (!CondConstant)\n        return;\n    } else {\n      llvm::BasicBlock *ThenBlock = CGF.createBasicBlock(\"taskloop.if.then\");\n      ContBlock = CGF.createBasicBlock(\"taskloop.if.end\");\n      emitPreCond(CGF, S, S.getPreCond(), ThenBlock, ContBlock,\n                  CGF.getProfileCount(&S));\n      CGF.EmitBlock(ThenBlock);\n      CGF.incrementProfileCounter(&S);\n    }\n\n    (void)CGF.EmitOMPLinearClauseInit(S);\n\n    OMPPrivateScope LoopScope(CGF);\n    // Emit helper vars inits.\n    enum { LowerBound = 5, UpperBound, Stride, LastIter };\n    auto *I = CS->getCapturedDecl()->param_begin();\n    auto *LBP = std::next(I, LowerBound);\n    auto *UBP = std::next(I, UpperBound);\n    auto *STP = std::next(I, Stride);\n    auto *LIP = std::next(I, LastIter);\n    mapParam(CGF, cast<DeclRefExpr>(S.getLowerBoundVariable()), *LBP,\n             LoopScope);\n    mapParam(CGF, cast<DeclRefExpr>(S.getUpperBoundVariable()), *UBP,\n             LoopScope);\n    mapParam(CGF, cast<DeclRefExpr>(S.getStrideVariable()), *STP, LoopScope);\n    mapParam(CGF, cast<DeclRefExpr>(S.getIsLastIterVariable()), *LIP,\n             LoopScope);\n    CGF.EmitOMPPrivateLoopCounters(S, LoopScope);\n    CGF.EmitOMPLinearClause(S, LoopScope);\n    bool HasLastprivateClause = CGF.EmitOMPLastprivateClauseInit(S, LoopScope);\n    (void)LoopScope.Privatize();\n    // Emit the loop iteration variable.\n    const Expr *IVExpr = S.getIterationVariable();\n    const auto *IVDecl = cast<VarDecl>(cast<DeclRefExpr>(IVExpr)->getDecl());\n    CGF.EmitVarDecl(*IVDecl);\n    CGF.EmitIgnoredExpr(S.getInit());\n\n    // Emit the iterations count variable.\n    // If it is not a variable, Sema decided to calculate iterations count on\n    // each iteration (e.g., it is foldable into a constant).\n    if (const auto *LIExpr = dyn_cast<DeclRefExpr>(S.getLastIteration())) {\n      CGF.EmitVarDecl(*cast<VarDecl>(LIExpr->getDecl()));\n      // Emit calculation of the iterations count.\n      CGF.EmitIgnoredExpr(S.getCalcLastIteration());\n    }\n\n    {\n      OMPLexicalScope Scope(CGF, S, OMPD_taskloop, /*EmitPreInitStmt=*/false);\n      emitCommonSimdLoop(\n          CGF, S,\n          [&S](CodeGenFunction &CGF, PrePostActionTy &) {\n            if (isOpenMPSimdDirective(S.getDirectiveKind()))\n              CGF.EmitOMPSimdInit(S);\n          },\n          [&S, &LoopScope](CodeGenFunction &CGF, PrePostActionTy &) {\n            CGF.EmitOMPInnerLoop(\n                S, LoopScope.requiresCleanups(), S.getCond(), S.getInc(),\n                [&S](CodeGenFunction &CGF) {\n                  emitOMPLoopBodyWithStopPoint(CGF, S,\n                                               CodeGenFunction::JumpDest());\n                },\n                [](CodeGenFunction &) {});\n          });\n    }\n    // Emit: if (PreCond) - end.\n    if (ContBlock) {\n      CGF.EmitBranch(ContBlock);\n      CGF.EmitBlock(ContBlock, true);\n    }\n    // Emit final copy of the lastprivate variables if IsLastIter != 0.\n    if (HasLastprivateClause) {\n      CGF.EmitOMPLastprivateClauseFinal(\n          S, isOpenMPSimdDirective(S.getDirectiveKind()),\n          CGF.Builder.CreateIsNotNull(CGF.EmitLoadOfScalar(\n              CGF.GetAddrOfLocalVar(*LIP), /*Volatile=*/false,\n              (*LIP)->getType(), S.getBeginLoc())));\n    }\n    CGF.EmitOMPLinearClauseFinal(S, [LIP, &S](CodeGenFunction &CGF) {\n      return CGF.Builder.CreateIsNotNull(\n          CGF.EmitLoadOfScalar(CGF.GetAddrOfLocalVar(*LIP), /*Volatile=*/false,\n                               (*LIP)->getType(), S.getBeginLoc()));\n    });\n  };\n  auto &&TaskGen = [&S, SharedsTy, CapturedStruct,\n                    IfCond](CodeGenFunction &CGF, llvm::Function *OutlinedFn,\n                            const OMPTaskDataTy &Data) {\n    auto &&CodeGen = [&S, OutlinedFn, SharedsTy, CapturedStruct, IfCond,\n                      &Data](CodeGenFunction &CGF, PrePostActionTy &) {\n      OMPLoopScope PreInitScope(CGF, S);\n      CGF.CGM.getOpenMPRuntime().emitTaskLoopCall(CGF, S.getBeginLoc(), S,\n                                                  OutlinedFn, SharedsTy,\n                                                  CapturedStruct, IfCond, Data);\n    };\n    CGF.CGM.getOpenMPRuntime().emitInlinedDirective(CGF, OMPD_taskloop,\n                                                    CodeGen);\n  };\n  if (Data.Nogroup) {\n    EmitOMPTaskBasedDirective(S, OMPD_taskloop, BodyGen, TaskGen, Data);\n  } else {\n    CGM.getOpenMPRuntime().emitTaskgroupRegion(\n        *this,\n        [&S, &BodyGen, &TaskGen, &Data](CodeGenFunction &CGF,\n                                        PrePostActionTy &Action) {\n          Action.Enter(CGF);\n          CGF.EmitOMPTaskBasedDirective(S, OMPD_taskloop, BodyGen, TaskGen,\n                                        Data);\n        },\n        S.getBeginLoc());\n  }\n}\n\nvoid CodeGenFunction::EmitOMPTaskLoopDirective(const OMPTaskLoopDirective &S) {\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n  EmitOMPTaskLoopBasedDirective(S);\n}\n\nvoid CodeGenFunction::EmitOMPTaskLoopSimdDirective(\n    const OMPTaskLoopSimdDirective &S) {\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n  OMPLexicalScope Scope(*this, S);\n  EmitOMPTaskLoopBasedDirective(S);\n}\n\nvoid CodeGenFunction::EmitOMPMasterTaskLoopDirective(\n    const OMPMasterTaskLoopDirective &S) {\n  auto &&CodeGen = [this, &S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    EmitOMPTaskLoopBasedDirective(S);\n  };\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n  OMPLexicalScope Scope(*this, S, llvm::None, /*EmitPreInitStmt=*/false);\n  CGM.getOpenMPRuntime().emitMasterRegion(*this, CodeGen, S.getBeginLoc());\n}\n\nvoid CodeGenFunction::EmitOMPMasterTaskLoopSimdDirective(\n    const OMPMasterTaskLoopSimdDirective &S) {\n  auto &&CodeGen = [this, &S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    Action.Enter(CGF);\n    EmitOMPTaskLoopBasedDirective(S);\n  };\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n  OMPLexicalScope Scope(*this, S);\n  CGM.getOpenMPRuntime().emitMasterRegion(*this, CodeGen, S.getBeginLoc());\n}\n\nvoid CodeGenFunction::EmitOMPParallelMasterTaskLoopDirective(\n    const OMPParallelMasterTaskLoopDirective &S) {\n  auto &&CodeGen = [this, &S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    auto &&TaskLoopCodeGen = [&S](CodeGenFunction &CGF,\n                                  PrePostActionTy &Action) {\n      Action.Enter(CGF);\n      CGF.EmitOMPTaskLoopBasedDirective(S);\n    };\n    OMPLexicalScope Scope(CGF, S, OMPD_parallel, /*EmitPreInitStmt=*/false);\n    CGM.getOpenMPRuntime().emitMasterRegion(CGF, TaskLoopCodeGen,\n                                            S.getBeginLoc());\n  };\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n  emitCommonOMPParallelDirective(*this, S, OMPD_master_taskloop, CodeGen,\n                                 emitEmptyBoundParameters);\n}\n\nvoid CodeGenFunction::EmitOMPParallelMasterTaskLoopSimdDirective(\n    const OMPParallelMasterTaskLoopSimdDirective &S) {\n  auto &&CodeGen = [this, &S](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    auto &&TaskLoopCodeGen = [&S](CodeGenFunction &CGF,\n                                  PrePostActionTy &Action) {\n      Action.Enter(CGF);\n      CGF.EmitOMPTaskLoopBasedDirective(S);\n    };\n    OMPLexicalScope Scope(CGF, S, OMPD_parallel, /*EmitPreInitStmt=*/false);\n    CGM.getOpenMPRuntime().emitMasterRegion(CGF, TaskLoopCodeGen,\n                                            S.getBeginLoc());\n  };\n  auto LPCRegion =\n      CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, S);\n  emitCommonOMPParallelDirective(*this, S, OMPD_master_taskloop_simd, CodeGen,\n                                 emitEmptyBoundParameters);\n}\n\n// Generate the instructions for '#pragma omp target update' directive.\nvoid CodeGenFunction::EmitOMPTargetUpdateDirective(\n    const OMPTargetUpdateDirective &S) {\n  // If we don't have target devices, don't bother emitting the data mapping\n  // code.\n  if (CGM.getLangOpts().OMPTargetTriples.empty())\n    return;\n\n  // Check if we have any if clause associated with the directive.\n  const Expr *IfCond = nullptr;\n  if (const auto *C = S.getSingleClause<OMPIfClause>())\n    IfCond = C->getCondition();\n\n  // Check if we have any device clause associated with the directive.\n  const Expr *Device = nullptr;\n  if (const auto *C = S.getSingleClause<OMPDeviceClause>())\n    Device = C->getDevice();\n\n  OMPLexicalScope Scope(*this, S, OMPD_task);\n  CGM.getOpenMPRuntime().emitTargetDataStandAloneCall(*this, S, IfCond, Device);\n}\n\nvoid CodeGenFunction::EmitSimpleOMPExecutableDirective(\n    const OMPExecutableDirective &D) {\n  if (const auto *SD = dyn_cast<OMPScanDirective>(&D)) {\n    EmitOMPScanDirective(*SD);\n    return;\n  }\n  if (!D.hasAssociatedStmt() || !D.getAssociatedStmt())\n    return;\n  auto &&CodeGen = [&D](CodeGenFunction &CGF, PrePostActionTy &Action) {\n    OMPPrivateScope GlobalsScope(CGF);\n    if (isOpenMPTaskingDirective(D.getDirectiveKind())) {\n      // Capture global firstprivates to avoid crash.\n      for (const auto *C : D.getClausesOfKind<OMPFirstprivateClause>()) {\n        for (const Expr *Ref : C->varlists()) {\n          const auto *DRE = cast<DeclRefExpr>(Ref->IgnoreParenImpCasts());\n          if (!DRE)\n            continue;\n          const auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n          if (!VD || VD->hasLocalStorage())\n            continue;\n          if (!CGF.LocalDeclMap.count(VD)) {\n            LValue GlobLVal = CGF.EmitLValue(Ref);\n            GlobalsScope.addPrivate(\n                VD, [&GlobLVal, &CGF]() { return GlobLVal.getAddress(CGF); });\n          }\n        }\n      }\n    }\n    if (isOpenMPSimdDirective(D.getDirectiveKind())) {\n      (void)GlobalsScope.Privatize();\n      ParentLoopDirectiveForScanRegion ScanRegion(CGF, D);\n      emitOMPSimdRegion(CGF, cast<OMPLoopDirective>(D), Action);\n    } else {\n      if (const auto *LD = dyn_cast<OMPLoopDirective>(&D)) {\n        for (const Expr *E : LD->counters()) {\n          const auto *VD = cast<VarDecl>(cast<DeclRefExpr>(E)->getDecl());\n          if (!VD->hasLocalStorage() && !CGF.LocalDeclMap.count(VD)) {\n            LValue GlobLVal = CGF.EmitLValue(E);\n            GlobalsScope.addPrivate(\n                VD, [&GlobLVal, &CGF]() { return GlobLVal.getAddress(CGF); });\n          }\n          if (isa<OMPCapturedExprDecl>(VD)) {\n            // Emit only those that were not explicitly referenced in clauses.\n            if (!CGF.LocalDeclMap.count(VD))\n              CGF.EmitVarDecl(*VD);\n          }\n        }\n        for (const auto *C : D.getClausesOfKind<OMPOrderedClause>()) {\n          if (!C->getNumForLoops())\n            continue;\n          for (unsigned I = LD->getLoopsNumber(),\n                        E = C->getLoopNumIterations().size();\n               I < E; ++I) {\n            if (const auto *VD = dyn_cast<OMPCapturedExprDecl>(\n                    cast<DeclRefExpr>(C->getLoopCounter(I))->getDecl())) {\n              // Emit only those that were not explicitly referenced in clauses.\n              if (!CGF.LocalDeclMap.count(VD))\n                CGF.EmitVarDecl(*VD);\n            }\n          }\n        }\n      }\n      (void)GlobalsScope.Privatize();\n      CGF.EmitStmt(D.getInnermostCapturedStmt()->getCapturedStmt());\n    }\n  };\n  if (D.getDirectiveKind() == OMPD_atomic ||\n      D.getDirectiveKind() == OMPD_critical ||\n      D.getDirectiveKind() == OMPD_section ||\n      D.getDirectiveKind() == OMPD_master) {\n    EmitStmt(D.getAssociatedStmt());\n  } else {\n    auto LPCRegion =\n        CGOpenMPRuntime::LastprivateConditionalRAII::disable(*this, D);\n    OMPSimdLexicalScope Scope(*this, D);\n    CGM.getOpenMPRuntime().emitInlinedDirective(\n        *this,\n        isOpenMPSimdDirective(D.getDirectiveKind()) ? OMPD_simd\n                                                    : D.getDirectiveKind(),\n        CodeGen);\n  }\n  // Check for outer lastprivate conditional update.\n  checkForLastprivateConditionalUpdate(*this, D);\n}\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "content": "//===-- CodeGenFunction.h - Per-Function state for LLVM CodeGen -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This is the internal per-function state used for llvm translation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CODEGENFUNCTION_H\n#define LLVM_CLANG_LIB_CODEGEN_CODEGENFUNCTION_H\n\n#include \"CGBuilder.h\"\n#include \"CGDebugInfo.h\"\n#include \"CGLoopInfo.h\"\n#include \"CGValue.h\"\n#include \"CodeGenModule.h\"\n#include \"CodeGenPGO.h\"\n#include \"EHScopeStack.h\"\n#include \"VarBypassDetector.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/CurrentSourceLocExprScope.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"clang/Basic/CapturedStmt.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Frontend/OpenMP/OMPIRBuilder.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Transforms/Utils/SanitizerStats.h\"\n\nnamespace llvm {\nclass BasicBlock;\nclass LLVMContext;\nclass MDNode;\nclass Module;\nclass SwitchInst;\nclass Twine;\nclass Value;\nclass CanonicalLoopInfo;\n}\n\nnamespace clang {\nclass ASTContext;\nclass BlockDecl;\nclass CXXDestructorDecl;\nclass CXXForRangeStmt;\nclass CXXTryStmt;\nclass Decl;\nclass LabelDecl;\nclass EnumConstantDecl;\nclass FunctionDecl;\nclass FunctionProtoType;\nclass LabelStmt;\nclass ObjCContainerDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCMethodDecl;\nclass ObjCImplementationDecl;\nclass ObjCPropertyImplDecl;\nclass TargetInfo;\nclass VarDecl;\nclass ObjCForCollectionStmt;\nclass ObjCAtTryStmt;\nclass ObjCAtThrowStmt;\nclass ObjCAtSynchronizedStmt;\nclass ObjCAutoreleasePoolStmt;\nclass OMPUseDevicePtrClause;\nclass OMPUseDeviceAddrClause;\nclass ReturnsNonNullAttr;\nclass SVETypeFlags;\nclass OMPExecutableDirective;\n\nnamespace analyze_os_log {\nclass OSLogBufferLayout;\n}\n\nnamespace CodeGen {\nclass CodeGenTypes;\nclass CGCallee;\nclass CGFunctionInfo;\nclass CGRecordLayout;\nclass CGBlockInfo;\nclass CGCXXABI;\nclass BlockByrefHelpers;\nclass BlockByrefInfo;\nclass BlockFlags;\nclass BlockFieldFlags;\nclass RegionCodeGenTy;\nclass TargetCodeGenInfo;\nstruct OMPTaskDataTy;\nstruct CGCoroData;\n\n/// The kind of evaluation to perform on values of a particular\n/// type.  Basically, is the code in CGExprScalar, CGExprComplex, or\n/// CGExprAgg?\n///\n/// TODO: should vectors maybe be split out into their own thing?\nenum TypeEvaluationKind {\n  TEK_Scalar,\n  TEK_Complex,\n  TEK_Aggregate\n};\n\n#define LIST_SANITIZER_CHECKS                                                  \\\n  SANITIZER_CHECK(AddOverflow, add_overflow, 0)                                \\\n  SANITIZER_CHECK(BuiltinUnreachable, builtin_unreachable, 0)                  \\\n  SANITIZER_CHECK(CFICheckFail, cfi_check_fail, 0)                             \\\n  SANITIZER_CHECK(DivremOverflow, divrem_overflow, 0)                          \\\n  SANITIZER_CHECK(DynamicTypeCacheMiss, dynamic_type_cache_miss, 0)            \\\n  SANITIZER_CHECK(FloatCastOverflow, float_cast_overflow, 0)                   \\\n  SANITIZER_CHECK(FunctionTypeMismatch, function_type_mismatch, 1)             \\\n  SANITIZER_CHECK(ImplicitConversion, implicit_conversion, 0)                  \\\n  SANITIZER_CHECK(InvalidBuiltin, invalid_builtin, 0)                          \\\n  SANITIZER_CHECK(InvalidObjCCast, invalid_objc_cast, 0)                       \\\n  SANITIZER_CHECK(LoadInvalidValue, load_invalid_value, 0)                     \\\n  SANITIZER_CHECK(MissingReturn, missing_return, 0)                            \\\n  SANITIZER_CHECK(MulOverflow, mul_overflow, 0)                                \\\n  SANITIZER_CHECK(NegateOverflow, negate_overflow, 0)                          \\\n  SANITIZER_CHECK(NullabilityArg, nullability_arg, 0)                          \\\n  SANITIZER_CHECK(NullabilityReturn, nullability_return, 1)                    \\\n  SANITIZER_CHECK(NonnullArg, nonnull_arg, 0)                                  \\\n  SANITIZER_CHECK(NonnullReturn, nonnull_return, 1)                            \\\n  SANITIZER_CHECK(OutOfBounds, out_of_bounds, 0)                               \\\n  SANITIZER_CHECK(PointerOverflow, pointer_overflow, 0)                        \\\n  SANITIZER_CHECK(ShiftOutOfBounds, shift_out_of_bounds, 0)                    \\\n  SANITIZER_CHECK(SubOverflow, sub_overflow, 0)                                \\\n  SANITIZER_CHECK(TypeMismatch, type_mismatch, 1)                              \\\n  SANITIZER_CHECK(AlignmentAssumption, alignment_assumption, 0)                \\\n  SANITIZER_CHECK(VLABoundNotPositive, vla_bound_not_positive, 0)\n\nenum SanitizerHandler {\n#define SANITIZER_CHECK(Enum, Name, Version) Enum,\n  LIST_SANITIZER_CHECKS\n#undef SANITIZER_CHECK\n};\n\n/// Helper class with most of the code for saving a value for a\n/// conditional expression cleanup.\nstruct DominatingLLVMValue {\n  typedef llvm::PointerIntPair<llvm::Value*, 1, bool> saved_type;\n\n  /// Answer whether the given value needs extra work to be saved.\n  static bool needsSaving(llvm::Value *value) {\n    // If it's not an instruction, we don't need to save.\n    if (!isa<llvm::Instruction>(value)) return false;\n\n    // If it's an instruction in the entry block, we don't need to save.\n    llvm::BasicBlock *block = cast<llvm::Instruction>(value)->getParent();\n    return (block != &block->getParent()->getEntryBlock());\n  }\n\n  static saved_type save(CodeGenFunction &CGF, llvm::Value *value);\n  static llvm::Value *restore(CodeGenFunction &CGF, saved_type value);\n};\n\n/// A partial specialization of DominatingValue for llvm::Values that\n/// might be llvm::Instructions.\ntemplate <class T> struct DominatingPointer<T,true> : DominatingLLVMValue {\n  typedef T *type;\n  static type restore(CodeGenFunction &CGF, saved_type value) {\n    return static_cast<T*>(DominatingLLVMValue::restore(CGF, value));\n  }\n};\n\n/// A specialization of DominatingValue for Address.\ntemplate <> struct DominatingValue<Address> {\n  typedef Address type;\n\n  struct saved_type {\n    DominatingLLVMValue::saved_type SavedValue;\n    CharUnits Alignment;\n  };\n\n  static bool needsSaving(type value) {\n    return DominatingLLVMValue::needsSaving(value.getPointer());\n  }\n  static saved_type save(CodeGenFunction &CGF, type value) {\n    return { DominatingLLVMValue::save(CGF, value.getPointer()),\n             value.getAlignment() };\n  }\n  static type restore(CodeGenFunction &CGF, saved_type value) {\n    return Address(DominatingLLVMValue::restore(CGF, value.SavedValue),\n                   value.Alignment);\n  }\n};\n\n/// A specialization of DominatingValue for RValue.\ntemplate <> struct DominatingValue<RValue> {\n  typedef RValue type;\n  class saved_type {\n    enum Kind { ScalarLiteral, ScalarAddress, AggregateLiteral,\n                AggregateAddress, ComplexAddress };\n\n    llvm::Value *Value;\n    unsigned K : 3;\n    unsigned Align : 29;\n    saved_type(llvm::Value *v, Kind k, unsigned a = 0)\n      : Value(v), K(k), Align(a) {}\n\n  public:\n    static bool needsSaving(RValue value);\n    static saved_type save(CodeGenFunction &CGF, RValue value);\n    RValue restore(CodeGenFunction &CGF);\n\n    // implementations in CGCleanup.cpp\n  };\n\n  static bool needsSaving(type value) {\n    return saved_type::needsSaving(value);\n  }\n  static saved_type save(CodeGenFunction &CGF, type value) {\n    return saved_type::save(CGF, value);\n  }\n  static type restore(CodeGenFunction &CGF, saved_type value) {\n    return value.restore(CGF);\n  }\n};\n\n/// CodeGenFunction - This class organizes the per-function state that is used\n/// while generating LLVM code.\nclass CodeGenFunction : public CodeGenTypeCache {\n  CodeGenFunction(const CodeGenFunction &) = delete;\n  void operator=(const CodeGenFunction &) = delete;\n\n  friend class CGCXXABI;\npublic:\n  /// A jump destination is an abstract label, branching to which may\n  /// require a jump out through normal cleanups.\n  struct JumpDest {\n    JumpDest() : Block(nullptr), ScopeDepth(), Index(0) {}\n    JumpDest(llvm::BasicBlock *Block,\n             EHScopeStack::stable_iterator Depth,\n             unsigned Index)\n      : Block(Block), ScopeDepth(Depth), Index(Index) {}\n\n    bool isValid() const { return Block != nullptr; }\n    llvm::BasicBlock *getBlock() const { return Block; }\n    EHScopeStack::stable_iterator getScopeDepth() const { return ScopeDepth; }\n    unsigned getDestIndex() const { return Index; }\n\n    // This should be used cautiously.\n    void setScopeDepth(EHScopeStack::stable_iterator depth) {\n      ScopeDepth = depth;\n    }\n\n  private:\n    llvm::BasicBlock *Block;\n    EHScopeStack::stable_iterator ScopeDepth;\n    unsigned Index;\n  };\n\n  CodeGenModule &CGM;  // Per-module state.\n  const TargetInfo &Target;\n\n  // For EH/SEH outlined funclets, this field points to parent's CGF\n  CodeGenFunction *ParentCGF = nullptr;\n\n  typedef std::pair<llvm::Value *, llvm::Value *> ComplexPairTy;\n  LoopInfoStack LoopStack;\n  CGBuilderTy Builder;\n\n  // Stores variables for which we can't generate correct lifetime markers\n  // because of jumps.\n  VarBypassDetector Bypasses;\n\n  /// List of recently emitted OMPCanonicalLoops.\n  ///\n  /// Since OMPCanonicalLoops are nested inside other statements (in particular\n  /// CapturedStmt generated by OMPExecutableDirective and non-perfectly nested\n  /// loops), we cannot directly call OMPEmitOMPCanonicalLoop and receive its\n  /// llvm::CanonicalLoopInfo. Instead, we call EmitStmt and any\n  /// OMPEmitOMPCanonicalLoop called by it will add its CanonicalLoopInfo to\n  /// this stack when done. Entering a new loop requires clearing this list; it\n  /// either means we start parsing a new loop nest (in which case the previous\n  /// loop nest goes out of scope) or a second loop in the same level in which\n  /// case it would be ambiguous into which of the two (or more) loops the loop\n  /// nest would extend.\n  SmallVector<llvm::CanonicalLoopInfo *, 4> OMPLoopNestStack;\n\n  // CodeGen lambda for loops and support for ordered clause\n  typedef llvm::function_ref<void(CodeGenFunction &, const OMPLoopDirective &,\n                                  JumpDest)>\n      CodeGenLoopTy;\n  typedef llvm::function_ref<void(CodeGenFunction &, SourceLocation,\n                                  const unsigned, const bool)>\n      CodeGenOrderedTy;\n\n  // Codegen lambda for loop bounds in worksharing loop constructs\n  typedef llvm::function_ref<std::pair<LValue, LValue>(\n      CodeGenFunction &, const OMPExecutableDirective &S)>\n      CodeGenLoopBoundsTy;\n\n  // Codegen lambda for loop bounds in dispatch-based loop implementation\n  typedef llvm::function_ref<std::pair<llvm::Value *, llvm::Value *>(\n      CodeGenFunction &, const OMPExecutableDirective &S, Address LB,\n      Address UB)>\n      CodeGenDispatchBoundsTy;\n\n  /// CGBuilder insert helper. This function is called after an\n  /// instruction is created using Builder.\n  void InsertHelper(llvm::Instruction *I, const llvm::Twine &Name,\n                    llvm::BasicBlock *BB,\n                    llvm::BasicBlock::iterator InsertPt) const;\n\n  /// CurFuncDecl - Holds the Decl for the current outermost\n  /// non-closure context.\n  const Decl *CurFuncDecl;\n  /// CurCodeDecl - This is the inner-most code context, which includes blocks.\n  const Decl *CurCodeDecl;\n  const CGFunctionInfo *CurFnInfo;\n  QualType FnRetTy;\n  llvm::Function *CurFn = nullptr;\n\n  // Holds coroutine data if the current function is a coroutine. We use a\n  // wrapper to manage its lifetime, so that we don't have to define CGCoroData\n  // in this header.\n  struct CGCoroInfo {\n    std::unique_ptr<CGCoroData> Data;\n    CGCoroInfo();\n    ~CGCoroInfo();\n  };\n  CGCoroInfo CurCoro;\n\n  bool isCoroutine() const {\n    return CurCoro.Data != nullptr;\n  }\n\n  /// CurGD - The GlobalDecl for the current function being compiled.\n  GlobalDecl CurGD;\n\n  /// PrologueCleanupDepth - The cleanup depth enclosing all the\n  /// cleanups associated with the parameters.\n  EHScopeStack::stable_iterator PrologueCleanupDepth;\n\n  /// ReturnBlock - Unified return block.\n  JumpDest ReturnBlock;\n\n  /// ReturnValue - The temporary alloca to hold the return\n  /// value. This is invalid iff the function has no return value.\n  Address ReturnValue = Address::invalid();\n\n  /// ReturnValuePointer - The temporary alloca to hold a pointer to sret.\n  /// This is invalid if sret is not in use.\n  Address ReturnValuePointer = Address::invalid();\n\n  /// If a return statement is being visited, this holds the return statment's\n  /// result expression.\n  const Expr *RetExpr = nullptr;\n\n  /// Return true if a label was seen in the current scope.\n  bool hasLabelBeenSeenInCurrentScope() const {\n    if (CurLexicalScope)\n      return CurLexicalScope->hasLabels();\n    return !LabelMap.empty();\n  }\n\n  /// AllocaInsertPoint - This is an instruction in the entry block before which\n  /// we prefer to insert allocas.\n  llvm::AssertingVH<llvm::Instruction> AllocaInsertPt;\n\n  /// API for captured statement code generation.\n  class CGCapturedStmtInfo {\n  public:\n    explicit CGCapturedStmtInfo(CapturedRegionKind K = CR_Default)\n        : Kind(K), ThisValue(nullptr), CXXThisFieldDecl(nullptr) {}\n    explicit CGCapturedStmtInfo(const CapturedStmt &S,\n                                CapturedRegionKind K = CR_Default)\n      : Kind(K), ThisValue(nullptr), CXXThisFieldDecl(nullptr) {\n\n      RecordDecl::field_iterator Field =\n        S.getCapturedRecordDecl()->field_begin();\n      for (CapturedStmt::const_capture_iterator I = S.capture_begin(),\n                                                E = S.capture_end();\n           I != E; ++I, ++Field) {\n        if (I->capturesThis())\n          CXXThisFieldDecl = *Field;\n        else if (I->capturesVariable())\n          CaptureFields[I->getCapturedVar()->getCanonicalDecl()] = *Field;\n        else if (I->capturesVariableByCopy())\n          CaptureFields[I->getCapturedVar()->getCanonicalDecl()] = *Field;\n      }\n    }\n\n    virtual ~CGCapturedStmtInfo();\n\n    CapturedRegionKind getKind() const { return Kind; }\n\n    virtual void setContextValue(llvm::Value *V) { ThisValue = V; }\n    // Retrieve the value of the context parameter.\n    virtual llvm::Value *getContextValue() const { return ThisValue; }\n\n    /// Lookup the captured field decl for a variable.\n    virtual const FieldDecl *lookup(const VarDecl *VD) const {\n      return CaptureFields.lookup(VD->getCanonicalDecl());\n    }\n\n    bool isCXXThisExprCaptured() const { return getThisFieldDecl() != nullptr; }\n    virtual FieldDecl *getThisFieldDecl() const { return CXXThisFieldDecl; }\n\n    static bool classof(const CGCapturedStmtInfo *) {\n      return true;\n    }\n\n    /// Emit the captured statement body.\n    virtual void EmitBody(CodeGenFunction &CGF, const Stmt *S) {\n      CGF.incrementProfileCounter(S);\n      CGF.EmitStmt(S);\n    }\n\n    /// Get the name of the capture helper.\n    virtual StringRef getHelperName() const { return \"__captured_stmt\"; }\n\n  private:\n    /// The kind of captured statement being generated.\n    CapturedRegionKind Kind;\n\n    /// Keep the map between VarDecl and FieldDecl.\n    llvm::SmallDenseMap<const VarDecl *, FieldDecl *> CaptureFields;\n\n    /// The base address of the captured record, passed in as the first\n    /// argument of the parallel region function.\n    llvm::Value *ThisValue;\n\n    /// Captured 'this' type.\n    FieldDecl *CXXThisFieldDecl;\n  };\n  CGCapturedStmtInfo *CapturedStmtInfo = nullptr;\n\n  /// RAII for correct setting/restoring of CapturedStmtInfo.\n  class CGCapturedStmtRAII {\n  private:\n    CodeGenFunction &CGF;\n    CGCapturedStmtInfo *PrevCapturedStmtInfo;\n  public:\n    CGCapturedStmtRAII(CodeGenFunction &CGF,\n                       CGCapturedStmtInfo *NewCapturedStmtInfo)\n        : CGF(CGF), PrevCapturedStmtInfo(CGF.CapturedStmtInfo) {\n      CGF.CapturedStmtInfo = NewCapturedStmtInfo;\n    }\n    ~CGCapturedStmtRAII() { CGF.CapturedStmtInfo = PrevCapturedStmtInfo; }\n  };\n\n  /// An abstract representation of regular/ObjC call/message targets.\n  class AbstractCallee {\n    /// The function declaration of the callee.\n    const Decl *CalleeDecl;\n\n  public:\n    AbstractCallee() : CalleeDecl(nullptr) {}\n    AbstractCallee(const FunctionDecl *FD) : CalleeDecl(FD) {}\n    AbstractCallee(const ObjCMethodDecl *OMD) : CalleeDecl(OMD) {}\n    bool hasFunctionDecl() const {\n      return dyn_cast_or_null<FunctionDecl>(CalleeDecl);\n    }\n    const Decl *getDecl() const { return CalleeDecl; }\n    unsigned getNumParams() const {\n      if (const auto *FD = dyn_cast<FunctionDecl>(CalleeDecl))\n        return FD->getNumParams();\n      return cast<ObjCMethodDecl>(CalleeDecl)->param_size();\n    }\n    const ParmVarDecl *getParamDecl(unsigned I) const {\n      if (const auto *FD = dyn_cast<FunctionDecl>(CalleeDecl))\n        return FD->getParamDecl(I);\n      return *(cast<ObjCMethodDecl>(CalleeDecl)->param_begin() + I);\n    }\n  };\n\n  /// Sanitizers enabled for this function.\n  SanitizerSet SanOpts;\n\n  /// True if CodeGen currently emits code implementing sanitizer checks.\n  bool IsSanitizerScope = false;\n\n  /// RAII object to set/unset CodeGenFunction::IsSanitizerScope.\n  class SanitizerScope {\n    CodeGenFunction *CGF;\n  public:\n    SanitizerScope(CodeGenFunction *CGF);\n    ~SanitizerScope();\n  };\n\n  /// In C++, whether we are code generating a thunk.  This controls whether we\n  /// should emit cleanups.\n  bool CurFuncIsThunk = false;\n\n  /// In ARC, whether we should autorelease the return value.\n  bool AutoreleaseResult = false;\n\n  /// Whether we processed a Microsoft-style asm block during CodeGen. These can\n  /// potentially set the return value.\n  bool SawAsmBlock = false;\n\n  const NamedDecl *CurSEHParent = nullptr;\n\n  /// True if the current function is an outlined SEH helper. This can be a\n  /// finally block or filter expression.\n  bool IsOutlinedSEHHelper = false;\n\n  /// True if CodeGen currently emits code inside presereved access index\n  /// region.\n  bool IsInPreservedAIRegion = false;\n\n  /// True if the current statement has nomerge attribute.\n  bool InNoMergeAttributedStmt = false;\n\n  /// True if the current function should be marked mustprogress.\n  bool FnIsMustProgress = false;\n\n  /// True if the C++ Standard Requires Progress.\n  bool CPlusPlusWithProgress() {\n    if (CGM.getCodeGenOpts().getFiniteLoops() ==\n        CodeGenOptions::FiniteLoopsKind::Never)\n      return false;\n\n    return getLangOpts().CPlusPlus11 || getLangOpts().CPlusPlus14 ||\n           getLangOpts().CPlusPlus17 || getLangOpts().CPlusPlus20;\n  }\n\n  /// True if the C Standard Requires Progress.\n  bool CWithProgress() {\n    if (CGM.getCodeGenOpts().getFiniteLoops() ==\n        CodeGenOptions::FiniteLoopsKind::Always)\n      return true;\n    if (CGM.getCodeGenOpts().getFiniteLoops() ==\n        CodeGenOptions::FiniteLoopsKind::Never)\n      return false;\n\n    return getLangOpts().C11 || getLangOpts().C17 || getLangOpts().C2x;\n  }\n\n  /// True if the language standard requires progress in functions or\n  /// in infinite loops with non-constant conditionals.\n  bool LanguageRequiresProgress() {\n    return CWithProgress() || CPlusPlusWithProgress();\n  }\n\n  const CodeGen::CGBlockInfo *BlockInfo = nullptr;\n  llvm::Value *BlockPointer = nullptr;\n\n  llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;\n  FieldDecl *LambdaThisCaptureField = nullptr;\n\n  /// A mapping from NRVO variables to the flags used to indicate\n  /// when the NRVO has been applied to this variable.\n  llvm::DenseMap<const VarDecl *, llvm::Value *> NRVOFlags;\n\n  EHScopeStack EHStack;\n  llvm::SmallVector<char, 256> LifetimeExtendedCleanupStack;\n  llvm::SmallVector<const JumpDest *, 2> SEHTryEpilogueStack;\n\n  llvm::Instruction *CurrentFuncletPad = nullptr;\n\n  class CallLifetimeEnd final : public EHScopeStack::Cleanup {\n    llvm::Value *Addr;\n    llvm::Value *Size;\n\n  public:\n    CallLifetimeEnd(Address addr, llvm::Value *size)\n        : Addr(addr.getPointer()), Size(size) {}\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      CGF.EmitLifetimeEnd(Size, Addr);\n    }\n  };\n\n  /// Header for data within LifetimeExtendedCleanupStack.\n  struct LifetimeExtendedCleanupHeader {\n    /// The size of the following cleanup object.\n    unsigned Size;\n    /// The kind of cleanup to push: a value from the CleanupKind enumeration.\n    unsigned Kind : 31;\n    /// Whether this is a conditional cleanup.\n    unsigned IsConditional : 1;\n\n    size_t getSize() const { return Size; }\n    CleanupKind getKind() const { return (CleanupKind)Kind; }\n    bool isConditional() const { return IsConditional; }\n  };\n\n  /// i32s containing the indexes of the cleanup destinations.\n  Address NormalCleanupDest = Address::invalid();\n\n  unsigned NextCleanupDestIndex = 1;\n\n  /// EHResumeBlock - Unified block containing a call to llvm.eh.resume.\n  llvm::BasicBlock *EHResumeBlock = nullptr;\n\n  /// The exception slot.  All landing pads write the current exception pointer\n  /// into this alloca.\n  llvm::Value *ExceptionSlot = nullptr;\n\n  /// The selector slot.  Under the MandatoryCleanup model, all landing pads\n  /// write the current selector value into this alloca.\n  llvm::AllocaInst *EHSelectorSlot = nullptr;\n\n  /// A stack of exception code slots. Entering an __except block pushes a slot\n  /// on the stack and leaving pops one. The __exception_code() intrinsic loads\n  /// a value from the top of the stack.\n  SmallVector<Address, 1> SEHCodeSlotStack;\n\n  /// Value returned by __exception_info intrinsic.\n  llvm::Value *SEHInfo = nullptr;\n\n  /// Emits a landing pad for the current EH stack.\n  llvm::BasicBlock *EmitLandingPad();\n\n  llvm::BasicBlock *getInvokeDestImpl();\n\n  /// Parent loop-based directive for scan directive.\n  const OMPExecutableDirective *OMPParentLoopDirectiveForScan = nullptr;\n  llvm::BasicBlock *OMPBeforeScanBlock = nullptr;\n  llvm::BasicBlock *OMPAfterScanBlock = nullptr;\n  llvm::BasicBlock *OMPScanExitBlock = nullptr;\n  llvm::BasicBlock *OMPScanDispatch = nullptr;\n  bool OMPFirstScanLoop = false;\n\n  /// Manages parent directive for scan directives.\n  class ParentLoopDirectiveForScanRegion {\n    CodeGenFunction &CGF;\n    const OMPExecutableDirective *ParentLoopDirectiveForScan;\n\n  public:\n    ParentLoopDirectiveForScanRegion(\n        CodeGenFunction &CGF,\n        const OMPExecutableDirective &ParentLoopDirectiveForScan)\n        : CGF(CGF),\n          ParentLoopDirectiveForScan(CGF.OMPParentLoopDirectiveForScan) {\n      CGF.OMPParentLoopDirectiveForScan = &ParentLoopDirectiveForScan;\n    }\n    ~ParentLoopDirectiveForScanRegion() {\n      CGF.OMPParentLoopDirectiveForScan = ParentLoopDirectiveForScan;\n    }\n  };\n\n  template <class T>\n  typename DominatingValue<T>::saved_type saveValueInCond(T value) {\n    return DominatingValue<T>::save(*this, value);\n  }\n\n  class CGFPOptionsRAII {\n  public:\n    CGFPOptionsRAII(CodeGenFunction &CGF, FPOptions FPFeatures);\n    CGFPOptionsRAII(CodeGenFunction &CGF, const Expr *E);\n    ~CGFPOptionsRAII();\n\n  private:\n    void ConstructorHelper(FPOptions FPFeatures);\n    CodeGenFunction &CGF;\n    FPOptions OldFPFeatures;\n    llvm::fp::ExceptionBehavior OldExcept;\n    llvm::RoundingMode OldRounding;\n    Optional<CGBuilderTy::FastMathFlagGuard> FMFGuard;\n  };\n  FPOptions CurFPFeatures;\n\npublic:\n  /// ObjCEHValueStack - Stack of Objective-C exception values, used for\n  /// rethrows.\n  SmallVector<llvm::Value*, 8> ObjCEHValueStack;\n\n  /// A class controlling the emission of a finally block.\n  class FinallyInfo {\n    /// Where the catchall's edge through the cleanup should go.\n    JumpDest RethrowDest;\n\n    /// A function to call to enter the catch.\n    llvm::FunctionCallee BeginCatchFn;\n\n    /// An i1 variable indicating whether or not the @finally is\n    /// running for an exception.\n    llvm::AllocaInst *ForEHVar;\n\n    /// An i8* variable into which the exception pointer to rethrow\n    /// has been saved.\n    llvm::AllocaInst *SavedExnVar;\n\n  public:\n    void enter(CodeGenFunction &CGF, const Stmt *Finally,\n               llvm::FunctionCallee beginCatchFn,\n               llvm::FunctionCallee endCatchFn, llvm::FunctionCallee rethrowFn);\n    void exit(CodeGenFunction &CGF);\n  };\n\n  /// Returns true inside SEH __try blocks.\n  bool isSEHTryScope() const { return !SEHTryEpilogueStack.empty(); }\n\n  /// Returns true while emitting a cleanuppad.\n  bool isCleanupPadScope() const {\n    return CurrentFuncletPad && isa<llvm::CleanupPadInst>(CurrentFuncletPad);\n  }\n\n  /// pushFullExprCleanup - Push a cleanup to be run at the end of the\n  /// current full-expression.  Safe against the possibility that\n  /// we're currently inside a conditionally-evaluated expression.\n  template <class T, class... As>\n  void pushFullExprCleanup(CleanupKind kind, As... A) {\n    // If we're not in a conditional branch, or if none of the\n    // arguments requires saving, then use the unconditional cleanup.\n    if (!isInConditionalBranch())\n      return EHStack.pushCleanup<T>(kind, A...);\n\n    // Stash values in a tuple so we can guarantee the order of saves.\n    typedef std::tuple<typename DominatingValue<As>::saved_type...> SavedTuple;\n    SavedTuple Saved{saveValueInCond(A)...};\n\n    typedef EHScopeStack::ConditionalCleanup<T, As...> CleanupType;\n    EHStack.pushCleanupTuple<CleanupType>(kind, Saved);\n    initFullExprCleanup();\n  }\n\n  /// Queue a cleanup to be pushed after finishing the current full-expression,\n  /// potentially with an active flag.\n  template <class T, class... As>\n  void pushCleanupAfterFullExpr(CleanupKind Kind, As... A) {\n    if (!isInConditionalBranch())\n      return pushCleanupAfterFullExprWithActiveFlag<T>(Kind, Address::invalid(),\n                                                       A...);\n\n    Address ActiveFlag = createCleanupActiveFlag();\n    assert(!DominatingValue<Address>::needsSaving(ActiveFlag) &&\n           \"cleanup active flag should never need saving\");\n\n    typedef std::tuple<typename DominatingValue<As>::saved_type...> SavedTuple;\n    SavedTuple Saved{saveValueInCond(A)...};\n\n    typedef EHScopeStack::ConditionalCleanup<T, As...> CleanupType;\n    pushCleanupAfterFullExprWithActiveFlag<CleanupType>(Kind, ActiveFlag, Saved);\n  }\n\n  template <class T, class... As>\n  void pushCleanupAfterFullExprWithActiveFlag(CleanupKind Kind,\n                                              Address ActiveFlag, As... A) {\n    LifetimeExtendedCleanupHeader Header = {sizeof(T), Kind,\n                                            ActiveFlag.isValid()};\n\n    size_t OldSize = LifetimeExtendedCleanupStack.size();\n    LifetimeExtendedCleanupStack.resize(\n        LifetimeExtendedCleanupStack.size() + sizeof(Header) + Header.Size +\n        (Header.IsConditional ? sizeof(ActiveFlag) : 0));\n\n    static_assert(sizeof(Header) % alignof(T) == 0,\n                  \"Cleanup will be allocated on misaligned address\");\n    char *Buffer = &LifetimeExtendedCleanupStack[OldSize];\n    new (Buffer) LifetimeExtendedCleanupHeader(Header);\n    new (Buffer + sizeof(Header)) T(A...);\n    if (Header.IsConditional)\n      new (Buffer + sizeof(Header) + sizeof(T)) Address(ActiveFlag);\n  }\n\n  /// Set up the last cleanup that was pushed as a conditional\n  /// full-expression cleanup.\n  void initFullExprCleanup() {\n    initFullExprCleanupWithFlag(createCleanupActiveFlag());\n  }\n\n  void initFullExprCleanupWithFlag(Address ActiveFlag);\n  Address createCleanupActiveFlag();\n\n  /// PushDestructorCleanup - Push a cleanup to call the\n  /// complete-object destructor of an object of the given type at the\n  /// given address.  Does nothing if T is not a C++ class type with a\n  /// non-trivial destructor.\n  void PushDestructorCleanup(QualType T, Address Addr);\n\n  /// PushDestructorCleanup - Push a cleanup to call the\n  /// complete-object variant of the given destructor on the object at\n  /// the given address.\n  void PushDestructorCleanup(const CXXDestructorDecl *Dtor, QualType T,\n                             Address Addr);\n\n  /// PopCleanupBlock - Will pop the cleanup entry on the stack and\n  /// process all branch fixups.\n  void PopCleanupBlock(bool FallThroughIsBranchThrough = false);\n\n  /// DeactivateCleanupBlock - Deactivates the given cleanup block.\n  /// The block cannot be reactivated.  Pops it if it's the top of the\n  /// stack.\n  ///\n  /// \\param DominatingIP - An instruction which is known to\n  ///   dominate the current IP (if set) and which lies along\n  ///   all paths of execution between the current IP and the\n  ///   the point at which the cleanup comes into scope.\n  void DeactivateCleanupBlock(EHScopeStack::stable_iterator Cleanup,\n                              llvm::Instruction *DominatingIP);\n\n  /// ActivateCleanupBlock - Activates an initially-inactive cleanup.\n  /// Cannot be used to resurrect a deactivated cleanup.\n  ///\n  /// \\param DominatingIP - An instruction which is known to\n  ///   dominate the current IP (if set) and which lies along\n  ///   all paths of execution between the current IP and the\n  ///   the point at which the cleanup comes into scope.\n  void ActivateCleanupBlock(EHScopeStack::stable_iterator Cleanup,\n                            llvm::Instruction *DominatingIP);\n\n  /// Enters a new scope for capturing cleanups, all of which\n  /// will be executed once the scope is exited.\n  class RunCleanupsScope {\n    EHScopeStack::stable_iterator CleanupStackDepth, OldCleanupScopeDepth;\n    size_t LifetimeExtendedCleanupStackSize;\n    bool OldDidCallStackSave;\n  protected:\n    bool PerformCleanup;\n  private:\n\n    RunCleanupsScope(const RunCleanupsScope &) = delete;\n    void operator=(const RunCleanupsScope &) = delete;\n\n  protected:\n    CodeGenFunction& CGF;\n\n  public:\n    /// Enter a new cleanup scope.\n    explicit RunCleanupsScope(CodeGenFunction &CGF)\n      : PerformCleanup(true), CGF(CGF)\n    {\n      CleanupStackDepth = CGF.EHStack.stable_begin();\n      LifetimeExtendedCleanupStackSize =\n          CGF.LifetimeExtendedCleanupStack.size();\n      OldDidCallStackSave = CGF.DidCallStackSave;\n      CGF.DidCallStackSave = false;\n      OldCleanupScopeDepth = CGF.CurrentCleanupScopeDepth;\n      CGF.CurrentCleanupScopeDepth = CleanupStackDepth;\n    }\n\n    /// Exit this cleanup scope, emitting any accumulated cleanups.\n    ~RunCleanupsScope() {\n      if (PerformCleanup)\n        ForceCleanup();\n    }\n\n    /// Determine whether this scope requires any cleanups.\n    bool requiresCleanups() const {\n      return CGF.EHStack.stable_begin() != CleanupStackDepth;\n    }\n\n    /// Force the emission of cleanups now, instead of waiting\n    /// until this object is destroyed.\n    /// \\param ValuesToReload - A list of values that need to be available at\n    /// the insertion point after cleanup emission. If cleanup emission created\n    /// a shared cleanup block, these value pointers will be rewritten.\n    /// Otherwise, they not will be modified.\n    void ForceCleanup(std::initializer_list<llvm::Value**> ValuesToReload = {}) {\n      assert(PerformCleanup && \"Already forced cleanup\");\n      CGF.DidCallStackSave = OldDidCallStackSave;\n      CGF.PopCleanupBlocks(CleanupStackDepth, LifetimeExtendedCleanupStackSize,\n                           ValuesToReload);\n      PerformCleanup = false;\n      CGF.CurrentCleanupScopeDepth = OldCleanupScopeDepth;\n    }\n  };\n\n  // Cleanup stack depth of the RunCleanupsScope that was pushed most recently.\n  EHScopeStack::stable_iterator CurrentCleanupScopeDepth =\n      EHScopeStack::stable_end();\n\n  class LexicalScope : public RunCleanupsScope {\n    SourceRange Range;\n    SmallVector<const LabelDecl*, 4> Labels;\n    LexicalScope *ParentScope;\n\n    LexicalScope(const LexicalScope &) = delete;\n    void operator=(const LexicalScope &) = delete;\n\n  public:\n    /// Enter a new cleanup scope.\n    explicit LexicalScope(CodeGenFunction &CGF, SourceRange Range)\n      : RunCleanupsScope(CGF), Range(Range), ParentScope(CGF.CurLexicalScope) {\n      CGF.CurLexicalScope = this;\n      if (CGDebugInfo *DI = CGF.getDebugInfo())\n        DI->EmitLexicalBlockStart(CGF.Builder, Range.getBegin());\n    }\n\n    void addLabel(const LabelDecl *label) {\n      assert(PerformCleanup && \"adding label to dead scope?\");\n      Labels.push_back(label);\n    }\n\n    /// Exit this cleanup scope, emitting any accumulated\n    /// cleanups.\n    ~LexicalScope() {\n      if (CGDebugInfo *DI = CGF.getDebugInfo())\n        DI->EmitLexicalBlockEnd(CGF.Builder, Range.getEnd());\n\n      // If we should perform a cleanup, force them now.  Note that\n      // this ends the cleanup scope before rescoping any labels.\n      if (PerformCleanup) {\n        ApplyDebugLocation DL(CGF, Range.getEnd());\n        ForceCleanup();\n      }\n    }\n\n    /// Force the emission of cleanups now, instead of waiting\n    /// until this object is destroyed.\n    void ForceCleanup() {\n      CGF.CurLexicalScope = ParentScope;\n      RunCleanupsScope::ForceCleanup();\n\n      if (!Labels.empty())\n        rescopeLabels();\n    }\n\n    bool hasLabels() const {\n      return !Labels.empty();\n    }\n\n    void rescopeLabels();\n  };\n\n  typedef llvm::DenseMap<const Decl *, Address> DeclMapTy;\n\n  /// The class used to assign some variables some temporarily addresses.\n  class OMPMapVars {\n    DeclMapTy SavedLocals;\n    DeclMapTy SavedTempAddresses;\n    OMPMapVars(const OMPMapVars &) = delete;\n    void operator=(const OMPMapVars &) = delete;\n\n  public:\n    explicit OMPMapVars() = default;\n    ~OMPMapVars() {\n      assert(SavedLocals.empty() && \"Did not restored original addresses.\");\n    };\n\n    /// Sets the address of the variable \\p LocalVD to be \\p TempAddr in\n    /// function \\p CGF.\n    /// \\return true if at least one variable was set already, false otherwise.\n    bool setVarAddr(CodeGenFunction &CGF, const VarDecl *LocalVD,\n                    Address TempAddr) {\n      LocalVD = LocalVD->getCanonicalDecl();\n      // Only save it once.\n      if (SavedLocals.count(LocalVD)) return false;\n\n      // Copy the existing local entry to SavedLocals.\n      auto it = CGF.LocalDeclMap.find(LocalVD);\n      if (it != CGF.LocalDeclMap.end())\n        SavedLocals.try_emplace(LocalVD, it->second);\n      else\n        SavedLocals.try_emplace(LocalVD, Address::invalid());\n\n      // Generate the private entry.\n      QualType VarTy = LocalVD->getType();\n      if (VarTy->isReferenceType()) {\n        Address Temp = CGF.CreateMemTemp(VarTy);\n        CGF.Builder.CreateStore(TempAddr.getPointer(), Temp);\n        TempAddr = Temp;\n      }\n      SavedTempAddresses.try_emplace(LocalVD, TempAddr);\n\n      return true;\n    }\n\n    /// Applies new addresses to the list of the variables.\n    /// \\return true if at least one variable is using new address, false\n    /// otherwise.\n    bool apply(CodeGenFunction &CGF) {\n      copyInto(SavedTempAddresses, CGF.LocalDeclMap);\n      SavedTempAddresses.clear();\n      return !SavedLocals.empty();\n    }\n\n    /// Restores original addresses of the variables.\n    void restore(CodeGenFunction &CGF) {\n      if (!SavedLocals.empty()) {\n        copyInto(SavedLocals, CGF.LocalDeclMap);\n        SavedLocals.clear();\n      }\n    }\n\n  private:\n    /// Copy all the entries in the source map over the corresponding\n    /// entries in the destination, which must exist.\n    static void copyInto(const DeclMapTy &Src, DeclMapTy &Dest) {\n      for (auto &Pair : Src) {\n        if (!Pair.second.isValid()) {\n          Dest.erase(Pair.first);\n          continue;\n        }\n\n        auto I = Dest.find(Pair.first);\n        if (I != Dest.end())\n          I->second = Pair.second;\n        else\n          Dest.insert(Pair);\n      }\n    }\n  };\n\n  /// The scope used to remap some variables as private in the OpenMP loop body\n  /// (or other captured region emitted without outlining), and to restore old\n  /// vars back on exit.\n  class OMPPrivateScope : public RunCleanupsScope {\n    OMPMapVars MappedVars;\n    OMPPrivateScope(const OMPPrivateScope &) = delete;\n    void operator=(const OMPPrivateScope &) = delete;\n\n  public:\n    /// Enter a new OpenMP private scope.\n    explicit OMPPrivateScope(CodeGenFunction &CGF) : RunCleanupsScope(CGF) {}\n\n    /// Registers \\p LocalVD variable as a private and apply \\p PrivateGen\n    /// function for it to generate corresponding private variable. \\p\n    /// PrivateGen returns an address of the generated private variable.\n    /// \\return true if the variable is registered as private, false if it has\n    /// been privatized already.\n    bool addPrivate(const VarDecl *LocalVD,\n                    const llvm::function_ref<Address()> PrivateGen) {\n      assert(PerformCleanup && \"adding private to dead scope\");\n      return MappedVars.setVarAddr(CGF, LocalVD, PrivateGen());\n    }\n\n    /// Privatizes local variables previously registered as private.\n    /// Registration is separate from the actual privatization to allow\n    /// initializers use values of the original variables, not the private one.\n    /// This is important, for example, if the private variable is a class\n    /// variable initialized by a constructor that references other private\n    /// variables. But at initialization original variables must be used, not\n    /// private copies.\n    /// \\return true if at least one variable was privatized, false otherwise.\n    bool Privatize() { return MappedVars.apply(CGF); }\n\n    void ForceCleanup() {\n      RunCleanupsScope::ForceCleanup();\n      MappedVars.restore(CGF);\n    }\n\n    /// Exit scope - all the mapped variables are restored.\n    ~OMPPrivateScope() {\n      if (PerformCleanup)\n        ForceCleanup();\n    }\n\n    /// Checks if the global variable is captured in current function.\n    bool isGlobalVarCaptured(const VarDecl *VD) const {\n      VD = VD->getCanonicalDecl();\n      return !VD->isLocalVarDeclOrParm() && CGF.LocalDeclMap.count(VD) > 0;\n    }\n  };\n\n  /// Save/restore original map of previously emitted local vars in case when we\n  /// need to duplicate emission of the same code several times in the same\n  /// function for OpenMP code.\n  class OMPLocalDeclMapRAII {\n    CodeGenFunction &CGF;\n    DeclMapTy SavedMap;\n\n  public:\n    OMPLocalDeclMapRAII(CodeGenFunction &CGF)\n        : CGF(CGF), SavedMap(CGF.LocalDeclMap) {}\n    ~OMPLocalDeclMapRAII() { SavedMap.swap(CGF.LocalDeclMap); }\n  };\n\n  /// Takes the old cleanup stack size and emits the cleanup blocks\n  /// that have been added.\n  void\n  PopCleanupBlocks(EHScopeStack::stable_iterator OldCleanupStackSize,\n                   std::initializer_list<llvm::Value **> ValuesToReload = {});\n\n  /// Takes the old cleanup stack size and emits the cleanup blocks\n  /// that have been added, then adds all lifetime-extended cleanups from\n  /// the given position to the stack.\n  void\n  PopCleanupBlocks(EHScopeStack::stable_iterator OldCleanupStackSize,\n                   size_t OldLifetimeExtendedStackSize,\n                   std::initializer_list<llvm::Value **> ValuesToReload = {});\n\n  void ResolveBranchFixups(llvm::BasicBlock *Target);\n\n  /// The given basic block lies in the current EH scope, but may be a\n  /// target of a potentially scope-crossing jump; get a stable handle\n  /// to which we can perform this jump later.\n  JumpDest getJumpDestInCurrentScope(llvm::BasicBlock *Target) {\n    return JumpDest(Target,\n                    EHStack.getInnermostNormalCleanup(),\n                    NextCleanupDestIndex++);\n  }\n\n  /// The given basic block lies in the current EH scope, but may be a\n  /// target of a potentially scope-crossing jump; get a stable handle\n  /// to which we can perform this jump later.\n  JumpDest getJumpDestInCurrentScope(StringRef Name = StringRef()) {\n    return getJumpDestInCurrentScope(createBasicBlock(Name));\n  }\n\n  /// EmitBranchThroughCleanup - Emit a branch from the current insert\n  /// block through the normal cleanup handling code (if any) and then\n  /// on to \\arg Dest.\n  void EmitBranchThroughCleanup(JumpDest Dest);\n\n  /// isObviouslyBranchWithoutCleanups - Return true if a branch to the\n  /// specified destination obviously has no cleanups to run.  'false' is always\n  /// a conservatively correct answer for this method.\n  bool isObviouslyBranchWithoutCleanups(JumpDest Dest) const;\n\n  /// popCatchScope - Pops the catch scope at the top of the EHScope\n  /// stack, emitting any required code (other than the catch handlers\n  /// themselves).\n  void popCatchScope();\n\n  llvm::BasicBlock *getEHResumeBlock(bool isCleanup);\n  llvm::BasicBlock *getEHDispatchBlock(EHScopeStack::stable_iterator scope);\n  llvm::BasicBlock *\n  getFuncletEHDispatchBlock(EHScopeStack::stable_iterator scope);\n\n  /// An object to manage conditionally-evaluated expressions.\n  class ConditionalEvaluation {\n    llvm::BasicBlock *StartBB;\n\n  public:\n    ConditionalEvaluation(CodeGenFunction &CGF)\n      : StartBB(CGF.Builder.GetInsertBlock()) {}\n\n    void begin(CodeGenFunction &CGF) {\n      assert(CGF.OutermostConditional != this);\n      if (!CGF.OutermostConditional)\n        CGF.OutermostConditional = this;\n    }\n\n    void end(CodeGenFunction &CGF) {\n      assert(CGF.OutermostConditional != nullptr);\n      if (CGF.OutermostConditional == this)\n        CGF.OutermostConditional = nullptr;\n    }\n\n    /// Returns a block which will be executed prior to each\n    /// evaluation of the conditional code.\n    llvm::BasicBlock *getStartingBlock() const {\n      return StartBB;\n    }\n  };\n\n  /// isInConditionalBranch - Return true if we're currently emitting\n  /// one branch or the other of a conditional expression.\n  bool isInConditionalBranch() const { return OutermostConditional != nullptr; }\n\n  void setBeforeOutermostConditional(llvm::Value *value, Address addr) {\n    assert(isInConditionalBranch());\n    llvm::BasicBlock *block = OutermostConditional->getStartingBlock();\n    auto store = new llvm::StoreInst(value, addr.getPointer(), &block->back());\n    store->setAlignment(addr.getAlignment().getAsAlign());\n  }\n\n  /// An RAII object to record that we're evaluating a statement\n  /// expression.\n  class StmtExprEvaluation {\n    CodeGenFunction &CGF;\n\n    /// We have to save the outermost conditional: cleanups in a\n    /// statement expression aren't conditional just because the\n    /// StmtExpr is.\n    ConditionalEvaluation *SavedOutermostConditional;\n\n  public:\n    StmtExprEvaluation(CodeGenFunction &CGF)\n      : CGF(CGF), SavedOutermostConditional(CGF.OutermostConditional) {\n      CGF.OutermostConditional = nullptr;\n    }\n\n    ~StmtExprEvaluation() {\n      CGF.OutermostConditional = SavedOutermostConditional;\n      CGF.EnsureInsertPoint();\n    }\n  };\n\n  /// An object which temporarily prevents a value from being\n  /// destroyed by aggressive peephole optimizations that assume that\n  /// all uses of a value have been realized in the IR.\n  class PeepholeProtection {\n    llvm::Instruction *Inst;\n    friend class CodeGenFunction;\n\n  public:\n    PeepholeProtection() : Inst(nullptr) {}\n  };\n\n  /// A non-RAII class containing all the information about a bound\n  /// opaque value.  OpaqueValueMapping, below, is a RAII wrapper for\n  /// this which makes individual mappings very simple; using this\n  /// class directly is useful when you have a variable number of\n  /// opaque values or don't want the RAII functionality for some\n  /// reason.\n  class OpaqueValueMappingData {\n    const OpaqueValueExpr *OpaqueValue;\n    bool BoundLValue;\n    CodeGenFunction::PeepholeProtection Protection;\n\n    OpaqueValueMappingData(const OpaqueValueExpr *ov,\n                           bool boundLValue)\n      : OpaqueValue(ov), BoundLValue(boundLValue) {}\n  public:\n    OpaqueValueMappingData() : OpaqueValue(nullptr) {}\n\n    static bool shouldBindAsLValue(const Expr *expr) {\n      // gl-values should be bound as l-values for obvious reasons.\n      // Records should be bound as l-values because IR generation\n      // always keeps them in memory.  Expressions of function type\n      // act exactly like l-values but are formally required to be\n      // r-values in C.\n      return expr->isGLValue() ||\n             expr->getType()->isFunctionType() ||\n             hasAggregateEvaluationKind(expr->getType());\n    }\n\n    static OpaqueValueMappingData bind(CodeGenFunction &CGF,\n                                       const OpaqueValueExpr *ov,\n                                       const Expr *e) {\n      if (shouldBindAsLValue(ov))\n        return bind(CGF, ov, CGF.EmitLValue(e));\n      return bind(CGF, ov, CGF.EmitAnyExpr(e));\n    }\n\n    static OpaqueValueMappingData bind(CodeGenFunction &CGF,\n                                       const OpaqueValueExpr *ov,\n                                       const LValue &lv) {\n      assert(shouldBindAsLValue(ov));\n      CGF.OpaqueLValues.insert(std::make_pair(ov, lv));\n      return OpaqueValueMappingData(ov, true);\n    }\n\n    static OpaqueValueMappingData bind(CodeGenFunction &CGF,\n                                       const OpaqueValueExpr *ov,\n                                       const RValue &rv) {\n      assert(!shouldBindAsLValue(ov));\n      CGF.OpaqueRValues.insert(std::make_pair(ov, rv));\n\n      OpaqueValueMappingData data(ov, false);\n\n      // Work around an extremely aggressive peephole optimization in\n      // EmitScalarConversion which assumes that all other uses of a\n      // value are extant.\n      data.Protection = CGF.protectFromPeepholes(rv);\n\n      return data;\n    }\n\n    bool isValid() const { return OpaqueValue != nullptr; }\n    void clear() { OpaqueValue = nullptr; }\n\n    void unbind(CodeGenFunction &CGF) {\n      assert(OpaqueValue && \"no data to unbind!\");\n\n      if (BoundLValue) {\n        CGF.OpaqueLValues.erase(OpaqueValue);\n      } else {\n        CGF.OpaqueRValues.erase(OpaqueValue);\n        CGF.unprotectFromPeepholes(Protection);\n      }\n    }\n  };\n\n  /// An RAII object to set (and then clear) a mapping for an OpaqueValueExpr.\n  class OpaqueValueMapping {\n    CodeGenFunction &CGF;\n    OpaqueValueMappingData Data;\n\n  public:\n    static bool shouldBindAsLValue(const Expr *expr) {\n      return OpaqueValueMappingData::shouldBindAsLValue(expr);\n    }\n\n    /// Build the opaque value mapping for the given conditional\n    /// operator if it's the GNU ?: extension.  This is a common\n    /// enough pattern that the convenience operator is really\n    /// helpful.\n    ///\n    OpaqueValueMapping(CodeGenFunction &CGF,\n                       const AbstractConditionalOperator *op) : CGF(CGF) {\n      if (isa<ConditionalOperator>(op))\n        // Leave Data empty.\n        return;\n\n      const BinaryConditionalOperator *e = cast<BinaryConditionalOperator>(op);\n      Data = OpaqueValueMappingData::bind(CGF, e->getOpaqueValue(),\n                                          e->getCommon());\n    }\n\n    /// Build the opaque value mapping for an OpaqueValueExpr whose source\n    /// expression is set to the expression the OVE represents.\n    OpaqueValueMapping(CodeGenFunction &CGF, const OpaqueValueExpr *OV)\n        : CGF(CGF) {\n      if (OV) {\n        assert(OV->getSourceExpr() && \"wrong form of OpaqueValueMapping used \"\n                                      \"for OVE with no source expression\");\n        Data = OpaqueValueMappingData::bind(CGF, OV, OV->getSourceExpr());\n      }\n    }\n\n    OpaqueValueMapping(CodeGenFunction &CGF,\n                       const OpaqueValueExpr *opaqueValue,\n                       LValue lvalue)\n      : CGF(CGF), Data(OpaqueValueMappingData::bind(CGF, opaqueValue, lvalue)) {\n    }\n\n    OpaqueValueMapping(CodeGenFunction &CGF,\n                       const OpaqueValueExpr *opaqueValue,\n                       RValue rvalue)\n      : CGF(CGF), Data(OpaqueValueMappingData::bind(CGF, opaqueValue, rvalue)) {\n    }\n\n    void pop() {\n      Data.unbind(CGF);\n      Data.clear();\n    }\n\n    ~OpaqueValueMapping() {\n      if (Data.isValid()) Data.unbind(CGF);\n    }\n  };\n\nprivate:\n  CGDebugInfo *DebugInfo;\n  /// Used to create unique names for artificial VLA size debug info variables.\n  unsigned VLAExprCounter = 0;\n  bool DisableDebugInfo = false;\n\n  /// DidCallStackSave - Whether llvm.stacksave has been called. Used to avoid\n  /// calling llvm.stacksave for multiple VLAs in the same scope.\n  bool DidCallStackSave = false;\n\n  /// IndirectBranch - The first time an indirect goto is seen we create a block\n  /// with an indirect branch.  Every time we see the address of a label taken,\n  /// we add the label to the indirect goto.  Every subsequent indirect goto is\n  /// codegen'd as a jump to the IndirectBranch's basic block.\n  llvm::IndirectBrInst *IndirectBranch = nullptr;\n\n  /// LocalDeclMap - This keeps track of the LLVM allocas or globals for local C\n  /// decls.\n  DeclMapTy LocalDeclMap;\n\n  // Keep track of the cleanups for callee-destructed parameters pushed to the\n  // cleanup stack so that they can be deactivated later.\n  llvm::DenseMap<const ParmVarDecl *, EHScopeStack::stable_iterator>\n      CalleeDestructedParamCleanups;\n\n  /// SizeArguments - If a ParmVarDecl had the pass_object_size attribute, this\n  /// will contain a mapping from said ParmVarDecl to its implicit \"object_size\"\n  /// parameter.\n  llvm::SmallDenseMap<const ParmVarDecl *, const ImplicitParamDecl *, 2>\n      SizeArguments;\n\n  /// Track escaped local variables with auto storage. Used during SEH\n  /// outlining to produce a call to llvm.localescape.\n  llvm::DenseMap<llvm::AllocaInst *, int> EscapedLocals;\n\n  /// LabelMap - This keeps track of the LLVM basic block for each C label.\n  llvm::DenseMap<const LabelDecl*, JumpDest> LabelMap;\n\n  // BreakContinueStack - This keeps track of where break and continue\n  // statements should jump to.\n  struct BreakContinue {\n    BreakContinue(JumpDest Break, JumpDest Continue)\n      : BreakBlock(Break), ContinueBlock(Continue) {}\n\n    JumpDest BreakBlock;\n    JumpDest ContinueBlock;\n  };\n  SmallVector<BreakContinue, 8> BreakContinueStack;\n\n  /// Handles cancellation exit points in OpenMP-related constructs.\n  class OpenMPCancelExitStack {\n    /// Tracks cancellation exit point and join point for cancel-related exit\n    /// and normal exit.\n    struct CancelExit {\n      CancelExit() = default;\n      CancelExit(OpenMPDirectiveKind Kind, JumpDest ExitBlock,\n                 JumpDest ContBlock)\n          : Kind(Kind), ExitBlock(ExitBlock), ContBlock(ContBlock) {}\n      OpenMPDirectiveKind Kind = llvm::omp::OMPD_unknown;\n      /// true if the exit block has been emitted already by the special\n      /// emitExit() call, false if the default codegen is used.\n      bool HasBeenEmitted = false;\n      JumpDest ExitBlock;\n      JumpDest ContBlock;\n    };\n\n    SmallVector<CancelExit, 8> Stack;\n\n  public:\n    OpenMPCancelExitStack() : Stack(1) {}\n    ~OpenMPCancelExitStack() = default;\n    /// Fetches the exit block for the current OpenMP construct.\n    JumpDest getExitBlock() const { return Stack.back().ExitBlock; }\n    /// Emits exit block with special codegen procedure specific for the related\n    /// OpenMP construct + emits code for normal construct cleanup.\n    void emitExit(CodeGenFunction &CGF, OpenMPDirectiveKind Kind,\n                  const llvm::function_ref<void(CodeGenFunction &)> CodeGen) {\n      if (Stack.back().Kind == Kind && getExitBlock().isValid()) {\n        assert(CGF.getOMPCancelDestination(Kind).isValid());\n        assert(CGF.HaveInsertPoint());\n        assert(!Stack.back().HasBeenEmitted);\n        auto IP = CGF.Builder.saveAndClearIP();\n        CGF.EmitBlock(Stack.back().ExitBlock.getBlock());\n        CodeGen(CGF);\n        CGF.EmitBranch(Stack.back().ContBlock.getBlock());\n        CGF.Builder.restoreIP(IP);\n        Stack.back().HasBeenEmitted = true;\n      }\n      CodeGen(CGF);\n    }\n    /// Enter the cancel supporting \\a Kind construct.\n    /// \\param Kind OpenMP directive that supports cancel constructs.\n    /// \\param HasCancel true, if the construct has inner cancel directive,\n    /// false otherwise.\n    void enter(CodeGenFunction &CGF, OpenMPDirectiveKind Kind, bool HasCancel) {\n      Stack.push_back({Kind,\n                       HasCancel ? CGF.getJumpDestInCurrentScope(\"cancel.exit\")\n                                 : JumpDest(),\n                       HasCancel ? CGF.getJumpDestInCurrentScope(\"cancel.cont\")\n                                 : JumpDest()});\n    }\n    /// Emits default exit point for the cancel construct (if the special one\n    /// has not be used) + join point for cancel/normal exits.\n    void exit(CodeGenFunction &CGF) {\n      if (getExitBlock().isValid()) {\n        assert(CGF.getOMPCancelDestination(Stack.back().Kind).isValid());\n        bool HaveIP = CGF.HaveInsertPoint();\n        if (!Stack.back().HasBeenEmitted) {\n          if (HaveIP)\n            CGF.EmitBranchThroughCleanup(Stack.back().ContBlock);\n          CGF.EmitBlock(Stack.back().ExitBlock.getBlock());\n          CGF.EmitBranchThroughCleanup(Stack.back().ContBlock);\n        }\n        CGF.EmitBlock(Stack.back().ContBlock.getBlock());\n        if (!HaveIP) {\n          CGF.Builder.CreateUnreachable();\n          CGF.Builder.ClearInsertionPoint();\n        }\n      }\n      Stack.pop_back();\n    }\n  };\n  OpenMPCancelExitStack OMPCancelStack;\n\n  /// Calculate branch weights for the likelihood attribute\n  llvm::MDNode *createBranchWeights(Stmt::Likelihood LH) const;\n\n  CodeGenPGO PGO;\n\n  /// Calculate branch weights appropriate for PGO data\n  llvm::MDNode *createProfileWeights(uint64_t TrueCount,\n                                     uint64_t FalseCount) const;\n  llvm::MDNode *createProfileWeights(ArrayRef<uint64_t> Weights) const;\n  llvm::MDNode *createProfileWeightsForLoop(const Stmt *Cond,\n                                            uint64_t LoopCount) const;\n\n  /// Calculate the branch weight for PGO data or the likelihood attribute.\n  /// The function tries to get the weight of \\ref createProfileWeightsForLoop.\n  /// If that fails it gets the weight of \\ref createBranchWeights.\n  llvm::MDNode *createProfileOrBranchWeightsForLoop(const Stmt *Cond,\n                                                    uint64_t LoopCount,\n                                                    const Stmt *Body) const;\n\npublic:\n  /// Increment the profiler's counter for the given statement by \\p StepV.\n  /// If \\p StepV is null, the default increment is 1.\n  void incrementProfileCounter(const Stmt *S, llvm::Value *StepV = nullptr) {\n    if (CGM.getCodeGenOpts().hasProfileClangInstr() &&\n        !CurFn->hasFnAttribute(llvm::Attribute::NoProfile))\n      PGO.emitCounterIncrement(Builder, S, StepV);\n    PGO.setCurrentStmt(S);\n  }\n\n  /// Get the profiler's count for the given statement.\n  uint64_t getProfileCount(const Stmt *S) {\n    Optional<uint64_t> Count = PGO.getStmtCount(S);\n    if (!Count.hasValue())\n      return 0;\n    return *Count;\n  }\n\n  /// Set the profiler's current count.\n  void setCurrentProfileCount(uint64_t Count) {\n    PGO.setCurrentRegionCount(Count);\n  }\n\n  /// Get the profiler's current count. This is generally the count for the most\n  /// recently incremented counter.\n  uint64_t getCurrentProfileCount() {\n    return PGO.getCurrentRegionCount();\n  }\n\nprivate:\n\n  /// SwitchInsn - This is nearest current switch instruction. It is null if\n  /// current context is not in a switch.\n  llvm::SwitchInst *SwitchInsn = nullptr;\n  /// The branch weights of SwitchInsn when doing instrumentation based PGO.\n  SmallVector<uint64_t, 16> *SwitchWeights = nullptr;\n\n  /// The likelihood attributes of the SwitchCase.\n  SmallVector<Stmt::Likelihood, 16> *SwitchLikelihood = nullptr;\n\n  /// CaseRangeBlock - This block holds if condition check for last case\n  /// statement range in current switch instruction.\n  llvm::BasicBlock *CaseRangeBlock = nullptr;\n\n  /// OpaqueLValues - Keeps track of the current set of opaque value\n  /// expressions.\n  llvm::DenseMap<const OpaqueValueExpr *, LValue> OpaqueLValues;\n  llvm::DenseMap<const OpaqueValueExpr *, RValue> OpaqueRValues;\n\n  // VLASizeMap - This keeps track of the associated size for each VLA type.\n  // We track this by the size expression rather than the type itself because\n  // in certain situations, like a const qualifier applied to an VLA typedef,\n  // multiple VLA types can share the same size expression.\n  // FIXME: Maybe this could be a stack of maps that is pushed/popped as we\n  // enter/leave scopes.\n  llvm::DenseMap<const Expr*, llvm::Value*> VLASizeMap;\n\n  /// A block containing a single 'unreachable' instruction.  Created\n  /// lazily by getUnreachableBlock().\n  llvm::BasicBlock *UnreachableBlock = nullptr;\n\n  /// Counts of the number return expressions in the function.\n  unsigned NumReturnExprs = 0;\n\n  /// Count the number of simple (constant) return expressions in the function.\n  unsigned NumSimpleReturnExprs = 0;\n\n  /// The last regular (non-return) debug location (breakpoint) in the function.\n  SourceLocation LastStopPoint;\n\npublic:\n  /// Source location information about the default argument or member\n  /// initializer expression we're evaluating, if any.\n  CurrentSourceLocExprScope CurSourceLocExprScope;\n  using SourceLocExprScopeGuard =\n      CurrentSourceLocExprScope::SourceLocExprScopeGuard;\n\n  /// A scope within which we are constructing the fields of an object which\n  /// might use a CXXDefaultInitExpr. This stashes away a 'this' value to use\n  /// if we need to evaluate a CXXDefaultInitExpr within the evaluation.\n  class FieldConstructionScope {\n  public:\n    FieldConstructionScope(CodeGenFunction &CGF, Address This)\n        : CGF(CGF), OldCXXDefaultInitExprThis(CGF.CXXDefaultInitExprThis) {\n      CGF.CXXDefaultInitExprThis = This;\n    }\n    ~FieldConstructionScope() {\n      CGF.CXXDefaultInitExprThis = OldCXXDefaultInitExprThis;\n    }\n\n  private:\n    CodeGenFunction &CGF;\n    Address OldCXXDefaultInitExprThis;\n  };\n\n  /// The scope of a CXXDefaultInitExpr. Within this scope, the value of 'this'\n  /// is overridden to be the object under construction.\n  class CXXDefaultInitExprScope  {\n  public:\n    CXXDefaultInitExprScope(CodeGenFunction &CGF, const CXXDefaultInitExpr *E)\n        : CGF(CGF), OldCXXThisValue(CGF.CXXThisValue),\n          OldCXXThisAlignment(CGF.CXXThisAlignment),\n          SourceLocScope(E, CGF.CurSourceLocExprScope) {\n      CGF.CXXThisValue = CGF.CXXDefaultInitExprThis.getPointer();\n      CGF.CXXThisAlignment = CGF.CXXDefaultInitExprThis.getAlignment();\n    }\n    ~CXXDefaultInitExprScope() {\n      CGF.CXXThisValue = OldCXXThisValue;\n      CGF.CXXThisAlignment = OldCXXThisAlignment;\n    }\n\n  public:\n    CodeGenFunction &CGF;\n    llvm::Value *OldCXXThisValue;\n    CharUnits OldCXXThisAlignment;\n    SourceLocExprScopeGuard SourceLocScope;\n  };\n\n  struct CXXDefaultArgExprScope : SourceLocExprScopeGuard {\n    CXXDefaultArgExprScope(CodeGenFunction &CGF, const CXXDefaultArgExpr *E)\n        : SourceLocExprScopeGuard(E, CGF.CurSourceLocExprScope) {}\n  };\n\n  /// The scope of an ArrayInitLoopExpr. Within this scope, the value of the\n  /// current loop index is overridden.\n  class ArrayInitLoopExprScope {\n  public:\n    ArrayInitLoopExprScope(CodeGenFunction &CGF, llvm::Value *Index)\n      : CGF(CGF), OldArrayInitIndex(CGF.ArrayInitIndex) {\n      CGF.ArrayInitIndex = Index;\n    }\n    ~ArrayInitLoopExprScope() {\n      CGF.ArrayInitIndex = OldArrayInitIndex;\n    }\n\n  private:\n    CodeGenFunction &CGF;\n    llvm::Value *OldArrayInitIndex;\n  };\n\n  class InlinedInheritingConstructorScope {\n  public:\n    InlinedInheritingConstructorScope(CodeGenFunction &CGF, GlobalDecl GD)\n        : CGF(CGF), OldCurGD(CGF.CurGD), OldCurFuncDecl(CGF.CurFuncDecl),\n          OldCurCodeDecl(CGF.CurCodeDecl),\n          OldCXXABIThisDecl(CGF.CXXABIThisDecl),\n          OldCXXABIThisValue(CGF.CXXABIThisValue),\n          OldCXXThisValue(CGF.CXXThisValue),\n          OldCXXABIThisAlignment(CGF.CXXABIThisAlignment),\n          OldCXXThisAlignment(CGF.CXXThisAlignment),\n          OldReturnValue(CGF.ReturnValue), OldFnRetTy(CGF.FnRetTy),\n          OldCXXInheritedCtorInitExprArgs(\n              std::move(CGF.CXXInheritedCtorInitExprArgs)) {\n      CGF.CurGD = GD;\n      CGF.CurFuncDecl = CGF.CurCodeDecl =\n          cast<CXXConstructorDecl>(GD.getDecl());\n      CGF.CXXABIThisDecl = nullptr;\n      CGF.CXXABIThisValue = nullptr;\n      CGF.CXXThisValue = nullptr;\n      CGF.CXXABIThisAlignment = CharUnits();\n      CGF.CXXThisAlignment = CharUnits();\n      CGF.ReturnValue = Address::invalid();\n      CGF.FnRetTy = QualType();\n      CGF.CXXInheritedCtorInitExprArgs.clear();\n    }\n    ~InlinedInheritingConstructorScope() {\n      CGF.CurGD = OldCurGD;\n      CGF.CurFuncDecl = OldCurFuncDecl;\n      CGF.CurCodeDecl = OldCurCodeDecl;\n      CGF.CXXABIThisDecl = OldCXXABIThisDecl;\n      CGF.CXXABIThisValue = OldCXXABIThisValue;\n      CGF.CXXThisValue = OldCXXThisValue;\n      CGF.CXXABIThisAlignment = OldCXXABIThisAlignment;\n      CGF.CXXThisAlignment = OldCXXThisAlignment;\n      CGF.ReturnValue = OldReturnValue;\n      CGF.FnRetTy = OldFnRetTy;\n      CGF.CXXInheritedCtorInitExprArgs =\n          std::move(OldCXXInheritedCtorInitExprArgs);\n    }\n\n  private:\n    CodeGenFunction &CGF;\n    GlobalDecl OldCurGD;\n    const Decl *OldCurFuncDecl;\n    const Decl *OldCurCodeDecl;\n    ImplicitParamDecl *OldCXXABIThisDecl;\n    llvm::Value *OldCXXABIThisValue;\n    llvm::Value *OldCXXThisValue;\n    CharUnits OldCXXABIThisAlignment;\n    CharUnits OldCXXThisAlignment;\n    Address OldReturnValue;\n    QualType OldFnRetTy;\n    CallArgList OldCXXInheritedCtorInitExprArgs;\n  };\n\n  // Helper class for the OpenMP IR Builder. Allows reusability of code used for\n  // region body, and finalization codegen callbacks. This will class will also\n  // contain privatization functions used by the privatization call backs\n  //\n  // TODO: this is temporary class for things that are being moved out of\n  // CGOpenMPRuntime, new versions of current CodeGenFunction methods, or\n  // utility function for use with the OMPBuilder. Once that move to use the\n  // OMPBuilder is done, everything here will either become part of CodeGenFunc.\n  // directly, or a new helper class that will contain functions used by both\n  // this and the OMPBuilder\n\n  struct OMPBuilderCBHelpers {\n\n    OMPBuilderCBHelpers() = delete;\n    OMPBuilderCBHelpers(const OMPBuilderCBHelpers &) = delete;\n    OMPBuilderCBHelpers &operator=(const OMPBuilderCBHelpers &) = delete;\n\n    using InsertPointTy = llvm::OpenMPIRBuilder::InsertPointTy;\n\n    /// Cleanup action for allocate support.\n    class OMPAllocateCleanupTy final : public EHScopeStack::Cleanup {\n\n    private:\n      llvm::CallInst *RTLFnCI;\n\n    public:\n      OMPAllocateCleanupTy(llvm::CallInst *RLFnCI) : RTLFnCI(RLFnCI) {\n        RLFnCI->removeFromParent();\n      }\n\n      void Emit(CodeGenFunction &CGF, Flags /*flags*/) override {\n        if (!CGF.HaveInsertPoint())\n          return;\n        CGF.Builder.Insert(RTLFnCI);\n      }\n    };\n\n    /// Returns address of the threadprivate variable for the current\n    /// thread. This Also create any necessary OMP runtime calls.\n    ///\n    /// \\param VD VarDecl for Threadprivate variable.\n    /// \\param VDAddr Address of the Vardecl\n    /// \\param Loc  The location where the barrier directive was encountered\n    static Address getAddrOfThreadPrivate(CodeGenFunction &CGF,\n                                          const VarDecl *VD, Address VDAddr,\n                                          SourceLocation Loc);\n\n    /// Gets the OpenMP-specific address of the local variable /p VD.\n    static Address getAddressOfLocalVariable(CodeGenFunction &CGF,\n                                             const VarDecl *VD);\n    /// Get the platform-specific name separator.\n    /// \\param Parts different parts of the final name that needs separation\n    /// \\param FirstSeparator First separator used between the initial two\n    ///        parts of the name.\n    /// \\param Separator separator used between all of the rest consecutinve\n    ///        parts of the name\n    static std::string getNameWithSeparators(ArrayRef<StringRef> Parts,\n                                             StringRef FirstSeparator = \".\",\n                                             StringRef Separator = \".\");\n    /// Emit the Finalization for an OMP region\n    /// \\param CGF\tThe Codegen function this belongs to\n    /// \\param IP\tInsertion point for generating the finalization code.\n    static void FinalizeOMPRegion(CodeGenFunction &CGF, InsertPointTy IP) {\n      CGBuilderTy::InsertPointGuard IPG(CGF.Builder);\n      assert(IP.getBlock()->end() != IP.getPoint() &&\n             \"OpenMP IR Builder should cause terminated block!\");\n\n      llvm::BasicBlock *IPBB = IP.getBlock();\n      llvm::BasicBlock *DestBB = IPBB->getUniqueSuccessor();\n      assert(DestBB && \"Finalization block should have one successor!\");\n\n      // erase and replace with cleanup branch.\n      IPBB->getTerminator()->eraseFromParent();\n      CGF.Builder.SetInsertPoint(IPBB);\n      CodeGenFunction::JumpDest Dest = CGF.getJumpDestInCurrentScope(DestBB);\n      CGF.EmitBranchThroughCleanup(Dest);\n    }\n\n    /// Emit the body of an OMP region\n    /// \\param CGF\tThe Codegen function this belongs to\n    /// \\param RegionBodyStmt\tThe body statement for the OpenMP region being\n    /// \t\t\t generated\n    /// \\param CodeGenIP\tInsertion point for generating the body code.\n    /// \\param FiniBB\tThe finalization basic block\n    static void EmitOMPRegionBody(CodeGenFunction &CGF,\n                                  const Stmt *RegionBodyStmt,\n                                  InsertPointTy CodeGenIP,\n                                  llvm::BasicBlock &FiniBB) {\n      llvm::BasicBlock *CodeGenIPBB = CodeGenIP.getBlock();\n      if (llvm::Instruction *CodeGenIPBBTI = CodeGenIPBB->getTerminator())\n        CodeGenIPBBTI->eraseFromParent();\n\n      CGF.Builder.SetInsertPoint(CodeGenIPBB);\n\n      CGF.EmitStmt(RegionBodyStmt);\n\n      if (CGF.Builder.saveIP().isSet())\n        CGF.Builder.CreateBr(&FiniBB);\n    }\n\n    /// RAII for preserving necessary info during Outlined region body codegen.\n    class OutlinedRegionBodyRAII {\n\n      llvm::AssertingVH<llvm::Instruction> OldAllocaIP;\n      CodeGenFunction::JumpDest OldReturnBlock;\n      CGBuilderTy::InsertPoint IP;\n      CodeGenFunction &CGF;\n\n    public:\n      OutlinedRegionBodyRAII(CodeGenFunction &cgf, InsertPointTy &AllocaIP,\n                             llvm::BasicBlock &RetBB)\n          : CGF(cgf) {\n        assert(AllocaIP.isSet() &&\n               \"Must specify Insertion point for allocas of outlined function\");\n        OldAllocaIP = CGF.AllocaInsertPt;\n        CGF.AllocaInsertPt = &*AllocaIP.getPoint();\n        IP = CGF.Builder.saveIP();\n\n        OldReturnBlock = CGF.ReturnBlock;\n        CGF.ReturnBlock = CGF.getJumpDestInCurrentScope(&RetBB);\n      }\n\n      ~OutlinedRegionBodyRAII() {\n        CGF.AllocaInsertPt = OldAllocaIP;\n        CGF.ReturnBlock = OldReturnBlock;\n        CGF.Builder.restoreIP(IP);\n      }\n    };\n\n    /// RAII for preserving necessary info during inlined region body codegen.\n    class InlinedRegionBodyRAII {\n\n      llvm::AssertingVH<llvm::Instruction> OldAllocaIP;\n      CodeGenFunction &CGF;\n\n    public:\n      InlinedRegionBodyRAII(CodeGenFunction &cgf, InsertPointTy &AllocaIP,\n                            llvm::BasicBlock &FiniBB)\n          : CGF(cgf) {\n        // Alloca insertion block should be in the entry block of the containing\n        // function so it expects an empty AllocaIP in which case will reuse the\n        // old alloca insertion point, or a new AllocaIP in the same block as\n        // the old one\n        assert((!AllocaIP.isSet() ||\n                CGF.AllocaInsertPt->getParent() == AllocaIP.getBlock()) &&\n               \"Insertion point should be in the entry block of containing \"\n               \"function!\");\n        OldAllocaIP = CGF.AllocaInsertPt;\n        if (AllocaIP.isSet())\n          CGF.AllocaInsertPt = &*AllocaIP.getPoint();\n\n        // TODO: Remove the call, after making sure the counter is not used by\n        //       the EHStack.\n        // Since this is an inlined region, it should not modify the\n        // ReturnBlock, and should reuse the one for the enclosing outlined\n        // region. So, the JumpDest being return by the function is discarded\n        (void)CGF.getJumpDestInCurrentScope(&FiniBB);\n      }\n\n      ~InlinedRegionBodyRAII() { CGF.AllocaInsertPt = OldAllocaIP; }\n    };\n  };\n\nprivate:\n  /// CXXThisDecl - When generating code for a C++ member function,\n  /// this will hold the implicit 'this' declaration.\n  ImplicitParamDecl *CXXABIThisDecl = nullptr;\n  llvm::Value *CXXABIThisValue = nullptr;\n  llvm::Value *CXXThisValue = nullptr;\n  CharUnits CXXABIThisAlignment;\n  CharUnits CXXThisAlignment;\n\n  /// The value of 'this' to use when evaluating CXXDefaultInitExprs within\n  /// this expression.\n  Address CXXDefaultInitExprThis = Address::invalid();\n\n  /// The current array initialization index when evaluating an\n  /// ArrayInitIndexExpr within an ArrayInitLoopExpr.\n  llvm::Value *ArrayInitIndex = nullptr;\n\n  /// The values of function arguments to use when evaluating\n  /// CXXInheritedCtorInitExprs within this context.\n  CallArgList CXXInheritedCtorInitExprArgs;\n\n  /// CXXStructorImplicitParamDecl - When generating code for a constructor or\n  /// destructor, this will hold the implicit argument (e.g. VTT).\n  ImplicitParamDecl *CXXStructorImplicitParamDecl = nullptr;\n  llvm::Value *CXXStructorImplicitParamValue = nullptr;\n\n  /// OutermostConditional - Points to the outermost active\n  /// conditional control.  This is used so that we know if a\n  /// temporary should be destroyed conditionally.\n  ConditionalEvaluation *OutermostConditional = nullptr;\n\n  /// The current lexical scope.\n  LexicalScope *CurLexicalScope = nullptr;\n\n  /// The current source location that should be used for exception\n  /// handling code.\n  SourceLocation CurEHLocation;\n\n  /// BlockByrefInfos - For each __block variable, contains\n  /// information about the layout of the variable.\n  llvm::DenseMap<const ValueDecl *, BlockByrefInfo> BlockByrefInfos;\n\n  /// Used by -fsanitize=nullability-return to determine whether the return\n  /// value can be checked.\n  llvm::Value *RetValNullabilityPrecondition = nullptr;\n\n  /// Check if -fsanitize=nullability-return instrumentation is required for\n  /// this function.\n  bool requiresReturnValueNullabilityCheck() const {\n    return RetValNullabilityPrecondition;\n  }\n\n  /// Used to store precise source locations for return statements by the\n  /// runtime return value checks.\n  Address ReturnLocation = Address::invalid();\n\n  /// Check if the return value of this function requires sanitization.\n  bool requiresReturnValueCheck() const;\n\n  llvm::BasicBlock *TerminateLandingPad = nullptr;\n  llvm::BasicBlock *TerminateHandler = nullptr;\n  llvm::SmallVector<llvm::BasicBlock *, 2> TrapBBs;\n\n  /// Terminate funclets keyed by parent funclet pad.\n  llvm::MapVector<llvm::Value *, llvm::BasicBlock *> TerminateFunclets;\n\n  /// Largest vector width used in ths function. Will be used to create a\n  /// function attribute.\n  unsigned LargestVectorWidth = 0;\n\n  /// True if we need emit the life-time markers.\n  const bool ShouldEmitLifetimeMarkers;\n\n  /// Add OpenCL kernel arg metadata and the kernel attribute metadata to\n  /// the function metadata.\n  void EmitOpenCLKernelMetadata(const FunctionDecl *FD,\n                                llvm::Function *Fn);\n\npublic:\n  CodeGenFunction(CodeGenModule &cgm, bool suppressNewContext=false);\n  ~CodeGenFunction();\n\n  CodeGenTypes &getTypes() const { return CGM.getTypes(); }\n  ASTContext &getContext() const { return CGM.getContext(); }\n  CGDebugInfo *getDebugInfo() {\n    if (DisableDebugInfo)\n      return nullptr;\n    return DebugInfo;\n  }\n  void disableDebugInfo() { DisableDebugInfo = true; }\n  void enableDebugInfo() { DisableDebugInfo = false; }\n\n  bool shouldUseFusedARCCalls() {\n    return CGM.getCodeGenOpts().OptimizationLevel == 0;\n  }\n\n  const LangOptions &getLangOpts() const { return CGM.getLangOpts(); }\n\n  /// Returns a pointer to the function's exception object and selector slot,\n  /// which is assigned in every landing pad.\n  Address getExceptionSlot();\n  Address getEHSelectorSlot();\n\n  /// Returns the contents of the function's exception object and selector\n  /// slots.\n  llvm::Value *getExceptionFromSlot();\n  llvm::Value *getSelectorFromSlot();\n\n  Address getNormalCleanupDestSlot();\n\n  llvm::BasicBlock *getUnreachableBlock() {\n    if (!UnreachableBlock) {\n      UnreachableBlock = createBasicBlock(\"unreachable\");\n      new llvm::UnreachableInst(getLLVMContext(), UnreachableBlock);\n    }\n    return UnreachableBlock;\n  }\n\n  llvm::BasicBlock *getInvokeDest() {\n    if (!EHStack.requiresLandingPad()) return nullptr;\n    return getInvokeDestImpl();\n  }\n\n  bool currentFunctionUsesSEHTry() const { return CurSEHParent != nullptr; }\n\n  const TargetInfo &getTarget() const { return Target; }\n  llvm::LLVMContext &getLLVMContext() { return CGM.getLLVMContext(); }\n  const TargetCodeGenInfo &getTargetHooks() const {\n    return CGM.getTargetCodeGenInfo();\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                                  Cleanups\n  //===--------------------------------------------------------------------===//\n\n  typedef void Destroyer(CodeGenFunction &CGF, Address addr, QualType ty);\n\n  void pushIrregularPartialArrayCleanup(llvm::Value *arrayBegin,\n                                        Address arrayEndPointer,\n                                        QualType elementType,\n                                        CharUnits elementAlignment,\n                                        Destroyer *destroyer);\n  void pushRegularPartialArrayCleanup(llvm::Value *arrayBegin,\n                                      llvm::Value *arrayEnd,\n                                      QualType elementType,\n                                      CharUnits elementAlignment,\n                                      Destroyer *destroyer);\n\n  void pushDestroy(QualType::DestructionKind dtorKind,\n                   Address addr, QualType type);\n  void pushEHDestroy(QualType::DestructionKind dtorKind,\n                     Address addr, QualType type);\n  void pushDestroy(CleanupKind kind, Address addr, QualType type,\n                   Destroyer *destroyer, bool useEHCleanupForArray);\n  void pushLifetimeExtendedDestroy(CleanupKind kind, Address addr,\n                                   QualType type, Destroyer *destroyer,\n                                   bool useEHCleanupForArray);\n  void pushCallObjectDeleteCleanup(const FunctionDecl *OperatorDelete,\n                                   llvm::Value *CompletePtr,\n                                   QualType ElementType);\n  void pushStackRestore(CleanupKind kind, Address SPMem);\n  void emitDestroy(Address addr, QualType type, Destroyer *destroyer,\n                   bool useEHCleanupForArray);\n  llvm::Function *generateDestroyHelper(Address addr, QualType type,\n                                        Destroyer *destroyer,\n                                        bool useEHCleanupForArray,\n                                        const VarDecl *VD);\n  void emitArrayDestroy(llvm::Value *begin, llvm::Value *end,\n                        QualType elementType, CharUnits elementAlign,\n                        Destroyer *destroyer,\n                        bool checkZeroLength, bool useEHCleanup);\n\n  Destroyer *getDestroyer(QualType::DestructionKind destructionKind);\n\n  /// Determines whether an EH cleanup is required to destroy a type\n  /// with the given destruction kind.\n  bool needsEHCleanup(QualType::DestructionKind kind) {\n    switch (kind) {\n    case QualType::DK_none:\n      return false;\n    case QualType::DK_cxx_destructor:\n    case QualType::DK_objc_weak_lifetime:\n    case QualType::DK_nontrivial_c_struct:\n      return getLangOpts().Exceptions;\n    case QualType::DK_objc_strong_lifetime:\n      return getLangOpts().Exceptions &&\n             CGM.getCodeGenOpts().ObjCAutoRefCountExceptions;\n    }\n    llvm_unreachable(\"bad destruction kind\");\n  }\n\n  CleanupKind getCleanupKind(QualType::DestructionKind kind) {\n    return (needsEHCleanup(kind) ? NormalAndEHCleanup : NormalCleanup);\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                                  Objective-C\n  //===--------------------------------------------------------------------===//\n\n  void GenerateObjCMethod(const ObjCMethodDecl *OMD);\n\n  void StartObjCMethod(const ObjCMethodDecl *MD, const ObjCContainerDecl *CD);\n\n  /// GenerateObjCGetter - Synthesize an Objective-C property getter function.\n  void GenerateObjCGetter(ObjCImplementationDecl *IMP,\n                          const ObjCPropertyImplDecl *PID);\n  void generateObjCGetterBody(const ObjCImplementationDecl *classImpl,\n                              const ObjCPropertyImplDecl *propImpl,\n                              const ObjCMethodDecl *GetterMothodDecl,\n                              llvm::Constant *AtomicHelperFn);\n\n  void GenerateObjCCtorDtorMethod(ObjCImplementationDecl *IMP,\n                                  ObjCMethodDecl *MD, bool ctor);\n\n  /// GenerateObjCSetter - Synthesize an Objective-C property setter function\n  /// for the given property.\n  void GenerateObjCSetter(ObjCImplementationDecl *IMP,\n                          const ObjCPropertyImplDecl *PID);\n  void generateObjCSetterBody(const ObjCImplementationDecl *classImpl,\n                              const ObjCPropertyImplDecl *propImpl,\n                              llvm::Constant *AtomicHelperFn);\n\n  //===--------------------------------------------------------------------===//\n  //                                  Block Bits\n  //===--------------------------------------------------------------------===//\n\n  /// Emit block literal.\n  /// \\return an LLVM value which is a pointer to a struct which contains\n  /// information about the block, including the block invoke function, the\n  /// captured variables, etc.\n  llvm::Value *EmitBlockLiteral(const BlockExpr *);\n\n  llvm::Function *GenerateBlockFunction(GlobalDecl GD,\n                                        const CGBlockInfo &Info,\n                                        const DeclMapTy &ldm,\n                                        bool IsLambdaConversionToBlock,\n                                        bool BuildGlobalBlock);\n\n  /// Check if \\p T is a C++ class that has a destructor that can throw.\n  static bool cxxDestructorCanThrow(QualType T);\n\n  llvm::Constant *GenerateCopyHelperFunction(const CGBlockInfo &blockInfo);\n  llvm::Constant *GenerateDestroyHelperFunction(const CGBlockInfo &blockInfo);\n  llvm::Constant *GenerateObjCAtomicSetterCopyHelperFunction(\n                                             const ObjCPropertyImplDecl *PID);\n  llvm::Constant *GenerateObjCAtomicGetterCopyHelperFunction(\n                                             const ObjCPropertyImplDecl *PID);\n  llvm::Value *EmitBlockCopyAndAutorelease(llvm::Value *Block, QualType Ty);\n\n  void BuildBlockRelease(llvm::Value *DeclPtr, BlockFieldFlags flags,\n                         bool CanThrow);\n\n  class AutoVarEmission;\n\n  void emitByrefStructureInit(const AutoVarEmission &emission);\n\n  /// Enter a cleanup to destroy a __block variable.  Note that this\n  /// cleanup should be a no-op if the variable hasn't left the stack\n  /// yet; if a cleanup is required for the variable itself, that needs\n  /// to be done externally.\n  ///\n  /// \\param Kind Cleanup kind.\n  ///\n  /// \\param Addr When \\p LoadBlockVarAddr is false, the address of the __block\n  /// structure that will be passed to _Block_object_dispose. When\n  /// \\p LoadBlockVarAddr is true, the address of the field of the block\n  /// structure that holds the address of the __block structure.\n  ///\n  /// \\param Flags The flag that will be passed to _Block_object_dispose.\n  ///\n  /// \\param LoadBlockVarAddr Indicates whether we need to emit a load from\n  /// \\p Addr to get the address of the __block structure.\n  void enterByrefCleanup(CleanupKind Kind, Address Addr, BlockFieldFlags Flags,\n                         bool LoadBlockVarAddr, bool CanThrow);\n\n  void setBlockContextParameter(const ImplicitParamDecl *D, unsigned argNum,\n                                llvm::Value *ptr);\n\n  Address LoadBlockStruct();\n  Address GetAddrOfBlockDecl(const VarDecl *var);\n\n  /// BuildBlockByrefAddress - Computes the location of the\n  /// data in a variable which is declared as __block.\n  Address emitBlockByrefAddress(Address baseAddr, const VarDecl *V,\n                                bool followForward = true);\n  Address emitBlockByrefAddress(Address baseAddr,\n                                const BlockByrefInfo &info,\n                                bool followForward,\n                                const llvm::Twine &name);\n\n  const BlockByrefInfo &getBlockByrefInfo(const VarDecl *var);\n\n  QualType BuildFunctionArgList(GlobalDecl GD, FunctionArgList &Args);\n\n  void GenerateCode(GlobalDecl GD, llvm::Function *Fn,\n                    const CGFunctionInfo &FnInfo);\n\n  /// Annotate the function with an attribute that disables TSan checking at\n  /// runtime.\n  void markAsIgnoreThreadCheckingAtRuntime(llvm::Function *Fn);\n\n  /// Emit code for the start of a function.\n  /// \\param Loc       The location to be associated with the function.\n  /// \\param StartLoc  The location of the function body.\n  void StartFunction(GlobalDecl GD,\n                     QualType RetTy,\n                     llvm::Function *Fn,\n                     const CGFunctionInfo &FnInfo,\n                     const FunctionArgList &Args,\n                     SourceLocation Loc = SourceLocation(),\n                     SourceLocation StartLoc = SourceLocation());\n\n  static bool IsConstructorDelegationValid(const CXXConstructorDecl *Ctor);\n\n  void EmitConstructorBody(FunctionArgList &Args);\n  void EmitDestructorBody(FunctionArgList &Args);\n  void emitImplicitAssignmentOperatorBody(FunctionArgList &Args);\n  void EmitFunctionBody(const Stmt *Body);\n  void EmitBlockWithFallThrough(llvm::BasicBlock *BB, const Stmt *S);\n\n  void EmitForwardingCallToLambda(const CXXMethodDecl *LambdaCallOperator,\n                                  CallArgList &CallArgs);\n  void EmitLambdaBlockInvokeBody();\n  void EmitLambdaDelegatingInvokeBody(const CXXMethodDecl *MD);\n  void EmitLambdaStaticInvokeBody(const CXXMethodDecl *MD);\n  void EmitLambdaVLACapture(const VariableArrayType *VAT, LValue LV) {\n    EmitStoreThroughLValue(RValue::get(VLASizeMap[VAT->getSizeExpr()]), LV);\n  }\n  void EmitAsanPrologueOrEpilogue(bool Prologue);\n\n  /// Emit the unified return block, trying to avoid its emission when\n  /// possible.\n  /// \\return The debug location of the user written return statement if the\n  /// return block is is avoided.\n  llvm::DebugLoc EmitReturnBlock();\n\n  /// FinishFunction - Complete IR generation of the current function. It is\n  /// legal to call this function even if there is no current insertion point.\n  void FinishFunction(SourceLocation EndLoc=SourceLocation());\n\n  void StartThunk(llvm::Function *Fn, GlobalDecl GD,\n                  const CGFunctionInfo &FnInfo, bool IsUnprototyped);\n\n  void EmitCallAndReturnForThunk(llvm::FunctionCallee Callee,\n                                 const ThunkInfo *Thunk, bool IsUnprototyped);\n\n  void FinishThunk();\n\n  /// Emit a musttail call for a thunk with a potentially adjusted this pointer.\n  void EmitMustTailThunk(GlobalDecl GD, llvm::Value *AdjustedThisPtr,\n                         llvm::FunctionCallee Callee);\n\n  /// Generate a thunk for the given method.\n  void generateThunk(llvm::Function *Fn, const CGFunctionInfo &FnInfo,\n                     GlobalDecl GD, const ThunkInfo &Thunk,\n                     bool IsUnprototyped);\n\n  llvm::Function *GenerateVarArgsThunk(llvm::Function *Fn,\n                                       const CGFunctionInfo &FnInfo,\n                                       GlobalDecl GD, const ThunkInfo &Thunk);\n\n  void EmitCtorPrologue(const CXXConstructorDecl *CD, CXXCtorType Type,\n                        FunctionArgList &Args);\n\n  void EmitInitializerForField(FieldDecl *Field, LValue LHS, Expr *Init);\n\n  /// Struct with all information about dynamic [sub]class needed to set vptr.\n  struct VPtr {\n    BaseSubobject Base;\n    const CXXRecordDecl *NearestVBase;\n    CharUnits OffsetFromNearestVBase;\n    const CXXRecordDecl *VTableClass;\n  };\n\n  /// Initialize the vtable pointer of the given subobject.\n  void InitializeVTablePointer(const VPtr &vptr);\n\n  typedef llvm::SmallVector<VPtr, 4> VPtrsVector;\n\n  typedef llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedVirtualBasesSetTy;\n  VPtrsVector getVTablePointers(const CXXRecordDecl *VTableClass);\n\n  void getVTablePointers(BaseSubobject Base, const CXXRecordDecl *NearestVBase,\n                         CharUnits OffsetFromNearestVBase,\n                         bool BaseIsNonVirtualPrimaryBase,\n                         const CXXRecordDecl *VTableClass,\n                         VisitedVirtualBasesSetTy &VBases, VPtrsVector &vptrs);\n\n  void InitializeVTablePointers(const CXXRecordDecl *ClassDecl);\n\n  /// GetVTablePtr - Return the Value of the vtable pointer member pointed\n  /// to by This.\n  llvm::Value *GetVTablePtr(Address This, llvm::Type *VTableTy,\n                            const CXXRecordDecl *VTableClass);\n\n  enum CFITypeCheckKind {\n    CFITCK_VCall,\n    CFITCK_NVCall,\n    CFITCK_DerivedCast,\n    CFITCK_UnrelatedCast,\n    CFITCK_ICall,\n    CFITCK_NVMFCall,\n    CFITCK_VMFCall,\n  };\n\n  /// Derived is the presumed address of an object of type T after a\n  /// cast. If T is a polymorphic class type, emit a check that the virtual\n  /// table for Derived belongs to a class derived from T.\n  void EmitVTablePtrCheckForCast(QualType T, llvm::Value *Derived,\n                                 bool MayBeNull, CFITypeCheckKind TCK,\n                                 SourceLocation Loc);\n\n  /// EmitVTablePtrCheckForCall - Virtual method MD is being called via VTable.\n  /// If vptr CFI is enabled, emit a check that VTable is valid.\n  void EmitVTablePtrCheckForCall(const CXXRecordDecl *RD, llvm::Value *VTable,\n                                 CFITypeCheckKind TCK, SourceLocation Loc);\n\n  /// EmitVTablePtrCheck - Emit a check that VTable is a valid virtual table for\n  /// RD using llvm.type.test.\n  void EmitVTablePtrCheck(const CXXRecordDecl *RD, llvm::Value *VTable,\n                          CFITypeCheckKind TCK, SourceLocation Loc);\n\n  /// If whole-program virtual table optimization is enabled, emit an assumption\n  /// that VTable is a member of RD's type identifier. Or, if vptr CFI is\n  /// enabled, emit a check that VTable is a member of RD's type identifier.\n  void EmitTypeMetadataCodeForVCall(const CXXRecordDecl *RD,\n                                    llvm::Value *VTable, SourceLocation Loc);\n\n  /// Returns whether we should perform a type checked load when loading a\n  /// virtual function for virtual calls to members of RD. This is generally\n  /// true when both vcall CFI and whole-program-vtables are enabled.\n  bool ShouldEmitVTableTypeCheckedLoad(const CXXRecordDecl *RD);\n\n  /// Emit a type checked load from the given vtable.\n  llvm::Value *EmitVTableTypeCheckedLoad(const CXXRecordDecl *RD, llvm::Value *VTable,\n                                         uint64_t VTableByteOffset);\n\n  /// EnterDtorCleanups - Enter the cleanups necessary to complete the\n  /// given phase of destruction for a destructor.  The end result\n  /// should call destructors on members and base classes in reverse\n  /// order of their construction.\n  void EnterDtorCleanups(const CXXDestructorDecl *Dtor, CXXDtorType Type);\n\n  /// ShouldInstrumentFunction - Return true if the current function should be\n  /// instrumented with __cyg_profile_func_* calls\n  bool ShouldInstrumentFunction();\n\n  /// ShouldXRayInstrument - Return true if the current function should be\n  /// instrumented with XRay nop sleds.\n  bool ShouldXRayInstrumentFunction() const;\n\n  /// AlwaysEmitXRayCustomEvents - Return true if we must unconditionally emit\n  /// XRay custom event handling calls.\n  bool AlwaysEmitXRayCustomEvents() const;\n\n  /// AlwaysEmitXRayTypedEvents - Return true if clang must unconditionally emit\n  /// XRay typed event handling calls.\n  bool AlwaysEmitXRayTypedEvents() const;\n\n  /// Encode an address into a form suitable for use in a function prologue.\n  llvm::Constant *EncodeAddrForUseInPrologue(llvm::Function *F,\n                                             llvm::Constant *Addr);\n\n  /// Decode an address used in a function prologue, encoded by \\c\n  /// EncodeAddrForUseInPrologue.\n  llvm::Value *DecodeAddrUsedInPrologue(llvm::Value *F,\n                                        llvm::Value *EncodedAddr);\n\n  /// EmitFunctionProlog - Emit the target specific LLVM code to load the\n  /// arguments for the given function. This is also responsible for naming the\n  /// LLVM function arguments.\n  void EmitFunctionProlog(const CGFunctionInfo &FI,\n                          llvm::Function *Fn,\n                          const FunctionArgList &Args);\n\n  /// EmitFunctionEpilog - Emit the target specific LLVM code to return the\n  /// given temporary.\n  void EmitFunctionEpilog(const CGFunctionInfo &FI, bool EmitRetDbgLoc,\n                          SourceLocation EndLoc);\n\n  /// Emit a test that checks if the return value \\p RV is nonnull.\n  void EmitReturnValueCheck(llvm::Value *RV);\n\n  /// EmitStartEHSpec - Emit the start of the exception spec.\n  void EmitStartEHSpec(const Decl *D);\n\n  /// EmitEndEHSpec - Emit the end of the exception spec.\n  void EmitEndEHSpec(const Decl *D);\n\n  /// getTerminateLandingPad - Return a landing pad that just calls terminate.\n  llvm::BasicBlock *getTerminateLandingPad();\n\n  /// getTerminateLandingPad - Return a cleanup funclet that just calls\n  /// terminate.\n  llvm::BasicBlock *getTerminateFunclet();\n\n  /// getTerminateHandler - Return a handler (not a landing pad, just\n  /// a catch handler) that just calls terminate.  This is used when\n  /// a terminate scope encloses a try.\n  llvm::BasicBlock *getTerminateHandler();\n\n  llvm::Type *ConvertTypeForMem(QualType T);\n  llvm::Type *ConvertType(QualType T);\n  llvm::Type *ConvertType(const TypeDecl *T) {\n    return ConvertType(getContext().getTypeDeclType(T));\n  }\n\n  /// LoadObjCSelf - Load the value of self. This function is only valid while\n  /// generating code for an Objective-C method.\n  llvm::Value *LoadObjCSelf();\n\n  /// TypeOfSelfObject - Return type of object that this self represents.\n  QualType TypeOfSelfObject();\n\n  /// getEvaluationKind - Return the TypeEvaluationKind of QualType \\c T.\n  static TypeEvaluationKind getEvaluationKind(QualType T);\n\n  static bool hasScalarEvaluationKind(QualType T) {\n    return getEvaluationKind(T) == TEK_Scalar;\n  }\n\n  static bool hasAggregateEvaluationKind(QualType T) {\n    return getEvaluationKind(T) == TEK_Aggregate;\n  }\n\n  /// createBasicBlock - Create an LLVM basic block.\n  llvm::BasicBlock *createBasicBlock(const Twine &name = \"\",\n                                     llvm::Function *parent = nullptr,\n                                     llvm::BasicBlock *before = nullptr) {\n    return llvm::BasicBlock::Create(getLLVMContext(), name, parent, before);\n  }\n\n  /// getBasicBlockForLabel - Return the LLVM basicblock that the specified\n  /// label maps to.\n  JumpDest getJumpDestForLabel(const LabelDecl *S);\n\n  /// SimplifyForwardingBlocks - If the given basic block is only a branch to\n  /// another basic block, simplify it. This assumes that no other code could\n  /// potentially reference the basic block.\n  void SimplifyForwardingBlocks(llvm::BasicBlock *BB);\n\n  /// EmitBlock - Emit the given block \\arg BB and set it as the insert point,\n  /// adding a fall-through branch from the current insert block if\n  /// necessary. It is legal to call this function even if there is no current\n  /// insertion point.\n  ///\n  /// IsFinished - If true, indicates that the caller has finished emitting\n  /// branches to the given block and does not expect to emit code into it. This\n  /// means the block can be ignored if it is unreachable.\n  void EmitBlock(llvm::BasicBlock *BB, bool IsFinished=false);\n\n  /// EmitBlockAfterUses - Emit the given block somewhere hopefully\n  /// near its uses, and leave the insertion point in it.\n  void EmitBlockAfterUses(llvm::BasicBlock *BB);\n\n  /// EmitBranch - Emit a branch to the specified basic block from the current\n  /// insert block, taking care to avoid creation of branches from dummy\n  /// blocks. It is legal to call this function even if there is no current\n  /// insertion point.\n  ///\n  /// This function clears the current insertion point. The caller should follow\n  /// calls to this function with calls to Emit*Block prior to generation new\n  /// code.\n  void EmitBranch(llvm::BasicBlock *Block);\n\n  /// HaveInsertPoint - True if an insertion point is defined. If not, this\n  /// indicates that the current code being emitted is unreachable.\n  bool HaveInsertPoint() const {\n    return Builder.GetInsertBlock() != nullptr;\n  }\n\n  /// EnsureInsertPoint - Ensure that an insertion point is defined so that\n  /// emitted IR has a place to go. Note that by definition, if this function\n  /// creates a block then that block is unreachable; callers may do better to\n  /// detect when no insertion point is defined and simply skip IR generation.\n  void EnsureInsertPoint() {\n    if (!HaveInsertPoint())\n      EmitBlock(createBasicBlock());\n  }\n\n  /// ErrorUnsupported - Print out an error that codegen doesn't support the\n  /// specified stmt yet.\n  void ErrorUnsupported(const Stmt *S, const char *Type);\n\n  //===--------------------------------------------------------------------===//\n  //                                  Helpers\n  //===--------------------------------------------------------------------===//\n\n  LValue MakeAddrLValue(Address Addr, QualType T,\n                        AlignmentSource Source = AlignmentSource::Type) {\n    return LValue::MakeAddr(Addr, T, getContext(), LValueBaseInfo(Source),\n                            CGM.getTBAAAccessInfo(T));\n  }\n\n  LValue MakeAddrLValue(Address Addr, QualType T, LValueBaseInfo BaseInfo,\n                        TBAAAccessInfo TBAAInfo) {\n    return LValue::MakeAddr(Addr, T, getContext(), BaseInfo, TBAAInfo);\n  }\n\n  LValue MakeAddrLValue(llvm::Value *V, QualType T, CharUnits Alignment,\n                        AlignmentSource Source = AlignmentSource::Type) {\n    return LValue::MakeAddr(Address(V, Alignment), T, getContext(),\n                            LValueBaseInfo(Source), CGM.getTBAAAccessInfo(T));\n  }\n\n  LValue MakeAddrLValue(llvm::Value *V, QualType T, CharUnits Alignment,\n                        LValueBaseInfo BaseInfo, TBAAAccessInfo TBAAInfo) {\n    return LValue::MakeAddr(Address(V, Alignment), T, getContext(),\n                            BaseInfo, TBAAInfo);\n  }\n\n  LValue MakeNaturalAlignPointeeAddrLValue(llvm::Value *V, QualType T);\n  LValue MakeNaturalAlignAddrLValue(llvm::Value *V, QualType T);\n\n  Address EmitLoadOfReference(LValue RefLVal,\n                              LValueBaseInfo *PointeeBaseInfo = nullptr,\n                              TBAAAccessInfo *PointeeTBAAInfo = nullptr);\n  LValue EmitLoadOfReferenceLValue(LValue RefLVal);\n  LValue EmitLoadOfReferenceLValue(Address RefAddr, QualType RefTy,\n                                   AlignmentSource Source =\n                                       AlignmentSource::Type) {\n    LValue RefLVal = MakeAddrLValue(RefAddr, RefTy, LValueBaseInfo(Source),\n                                    CGM.getTBAAAccessInfo(RefTy));\n    return EmitLoadOfReferenceLValue(RefLVal);\n  }\n\n  Address EmitLoadOfPointer(Address Ptr, const PointerType *PtrTy,\n                            LValueBaseInfo *BaseInfo = nullptr,\n                            TBAAAccessInfo *TBAAInfo = nullptr);\n  LValue EmitLoadOfPointerLValue(Address Ptr, const PointerType *PtrTy);\n\n  /// CreateTempAlloca - This creates an alloca and inserts it into the entry\n  /// block if \\p ArraySize is nullptr, otherwise inserts it at the current\n  /// insertion point of the builder. The caller is responsible for setting an\n  /// appropriate alignment on\n  /// the alloca.\n  ///\n  /// \\p ArraySize is the number of array elements to be allocated if it\n  ///    is not nullptr.\n  ///\n  /// LangAS::Default is the address space of pointers to local variables and\n  /// temporaries, as exposed in the source language. In certain\n  /// configurations, this is not the same as the alloca address space, and a\n  /// cast is needed to lift the pointer from the alloca AS into\n  /// LangAS::Default. This can happen when the target uses a restricted\n  /// address space for the stack but the source language requires\n  /// LangAS::Default to be a generic address space. The latter condition is\n  /// common for most programming languages; OpenCL is an exception in that\n  /// LangAS::Default is the private address space, which naturally maps\n  /// to the stack.\n  ///\n  /// Because the address of a temporary is often exposed to the program in\n  /// various ways, this function will perform the cast. The original alloca\n  /// instruction is returned through \\p Alloca if it is not nullptr.\n  ///\n  /// The cast is not performaed in CreateTempAllocaWithoutCast. This is\n  /// more efficient if the caller knows that the address will not be exposed.\n  llvm::AllocaInst *CreateTempAlloca(llvm::Type *Ty, const Twine &Name = \"tmp\",\n                                     llvm::Value *ArraySize = nullptr);\n  Address CreateTempAlloca(llvm::Type *Ty, CharUnits align,\n                           const Twine &Name = \"tmp\",\n                           llvm::Value *ArraySize = nullptr,\n                           Address *Alloca = nullptr);\n  Address CreateTempAllocaWithoutCast(llvm::Type *Ty, CharUnits align,\n                                      const Twine &Name = \"tmp\",\n                                      llvm::Value *ArraySize = nullptr);\n\n  /// CreateDefaultAlignedTempAlloca - This creates an alloca with the\n  /// default ABI alignment of the given LLVM type.\n  ///\n  /// IMPORTANT NOTE: This is *not* generally the right alignment for\n  /// any given AST type that happens to have been lowered to the\n  /// given IR type.  This should only ever be used for function-local,\n  /// IR-driven manipulations like saving and restoring a value.  Do\n  /// not hand this address off to arbitrary IRGen routines, and especially\n  /// do not pass it as an argument to a function that might expect a\n  /// properly ABI-aligned value.\n  Address CreateDefaultAlignTempAlloca(llvm::Type *Ty,\n                                       const Twine &Name = \"tmp\");\n\n  /// InitTempAlloca - Provide an initial value for the given alloca which\n  /// will be observable at all locations in the function.\n  ///\n  /// The address should be something that was returned from one of\n  /// the CreateTempAlloca or CreateMemTemp routines, and the\n  /// initializer must be valid in the entry block (i.e. it must\n  /// either be a constant or an argument value).\n  void InitTempAlloca(Address Alloca, llvm::Value *Value);\n\n  /// CreateIRTemp - Create a temporary IR object of the given type, with\n  /// appropriate alignment. This routine should only be used when an temporary\n  /// value needs to be stored into an alloca (for example, to avoid explicit\n  /// PHI construction), but the type is the IR type, not the type appropriate\n  /// for storing in memory.\n  ///\n  /// That is, this is exactly equivalent to CreateMemTemp, but calling\n  /// ConvertType instead of ConvertTypeForMem.\n  Address CreateIRTemp(QualType T, const Twine &Name = \"tmp\");\n\n  /// CreateMemTemp - Create a temporary memory object of the given type, with\n  /// appropriate alignmen and cast it to the default address space. Returns\n  /// the original alloca instruction by \\p Alloca if it is not nullptr.\n  Address CreateMemTemp(QualType T, const Twine &Name = \"tmp\",\n                        Address *Alloca = nullptr);\n  Address CreateMemTemp(QualType T, CharUnits Align, const Twine &Name = \"tmp\",\n                        Address *Alloca = nullptr);\n\n  /// CreateMemTemp - Create a temporary memory object of the given type, with\n  /// appropriate alignmen without casting it to the default address space.\n  Address CreateMemTempWithoutCast(QualType T, const Twine &Name = \"tmp\");\n  Address CreateMemTempWithoutCast(QualType T, CharUnits Align,\n                                   const Twine &Name = \"tmp\");\n\n  /// CreateAggTemp - Create a temporary memory object for the given\n  /// aggregate type.\n  AggValueSlot CreateAggTemp(QualType T, const Twine &Name = \"tmp\",\n                             Address *Alloca = nullptr) {\n    return AggValueSlot::forAddr(CreateMemTemp(T, Name, Alloca),\n                                 T.getQualifiers(),\n                                 AggValueSlot::IsNotDestructed,\n                                 AggValueSlot::DoesNotNeedGCBarriers,\n                                 AggValueSlot::IsNotAliased,\n                                 AggValueSlot::DoesNotOverlap);\n  }\n\n  /// Emit a cast to void* in the appropriate address space.\n  llvm::Value *EmitCastToVoidPtr(llvm::Value *value);\n\n  /// EvaluateExprAsBool - Perform the usual unary conversions on the specified\n  /// expression and compare the result against zero, returning an Int1Ty value.\n  llvm::Value *EvaluateExprAsBool(const Expr *E);\n\n  /// EmitIgnoredExpr - Emit an expression in a context which ignores the result.\n  void EmitIgnoredExpr(const Expr *E);\n\n  /// EmitAnyExpr - Emit code to compute the specified expression which can have\n  /// any type.  The result is returned as an RValue struct.  If this is an\n  /// aggregate expression, the aggloc/agglocvolatile arguments indicate where\n  /// the result should be returned.\n  ///\n  /// \\param ignoreResult True if the resulting value isn't used.\n  RValue EmitAnyExpr(const Expr *E,\n                     AggValueSlot aggSlot = AggValueSlot::ignored(),\n                     bool ignoreResult = false);\n\n  // EmitVAListRef - Emit a \"reference\" to a va_list; this is either the address\n  // or the value of the expression, depending on how va_list is defined.\n  Address EmitVAListRef(const Expr *E);\n\n  /// Emit a \"reference\" to a __builtin_ms_va_list; this is\n  /// always the value of the expression, because a __builtin_ms_va_list is a\n  /// pointer to a char.\n  Address EmitMSVAListRef(const Expr *E);\n\n  /// EmitAnyExprToTemp - Similarly to EmitAnyExpr(), however, the result will\n  /// always be accessible even if no aggregate location is provided.\n  RValue EmitAnyExprToTemp(const Expr *E);\n\n  /// EmitAnyExprToMem - Emits the code necessary to evaluate an\n  /// arbitrary expression into the given memory location.\n  void EmitAnyExprToMem(const Expr *E, Address Location,\n                        Qualifiers Quals, bool IsInitializer);\n\n  void EmitAnyExprToExn(const Expr *E, Address Addr);\n\n  /// EmitExprAsInit - Emits the code necessary to initialize a\n  /// location in memory with the given initializer.\n  void EmitExprAsInit(const Expr *init, const ValueDecl *D, LValue lvalue,\n                      bool capturedByInit);\n\n  /// hasVolatileMember - returns true if aggregate type has a volatile\n  /// member.\n  bool hasVolatileMember(QualType T) {\n    if (const RecordType *RT = T->getAs<RecordType>()) {\n      const RecordDecl *RD = cast<RecordDecl>(RT->getDecl());\n      return RD->hasVolatileMember();\n    }\n    return false;\n  }\n\n  /// Determine whether a return value slot may overlap some other object.\n  AggValueSlot::Overlap_t getOverlapForReturnValue() {\n    // FIXME: Assuming no overlap here breaks guaranteed copy elision for base\n    // class subobjects. These cases may need to be revisited depending on the\n    // resolution of the relevant core issue.\n    return AggValueSlot::DoesNotOverlap;\n  }\n\n  /// Determine whether a field initialization may overlap some other object.\n  AggValueSlot::Overlap_t getOverlapForFieldInit(const FieldDecl *FD);\n\n  /// Determine whether a base class initialization may overlap some other\n  /// object.\n  AggValueSlot::Overlap_t getOverlapForBaseInit(const CXXRecordDecl *RD,\n                                                const CXXRecordDecl *BaseRD,\n                                                bool IsVirtual);\n\n  /// Emit an aggregate assignment.\n  void EmitAggregateAssign(LValue Dest, LValue Src, QualType EltTy) {\n    bool IsVolatile = hasVolatileMember(EltTy);\n    EmitAggregateCopy(Dest, Src, EltTy, AggValueSlot::MayOverlap, IsVolatile);\n  }\n\n  void EmitAggregateCopyCtor(LValue Dest, LValue Src,\n                             AggValueSlot::Overlap_t MayOverlap) {\n    EmitAggregateCopy(Dest, Src, Src.getType(), MayOverlap);\n  }\n\n  /// EmitAggregateCopy - Emit an aggregate copy.\n  ///\n  /// \\param isVolatile \\c true iff either the source or the destination is\n  ///        volatile.\n  /// \\param MayOverlap Whether the tail padding of the destination might be\n  ///        occupied by some other object. More efficient code can often be\n  ///        generated if not.\n  void EmitAggregateCopy(LValue Dest, LValue Src, QualType EltTy,\n                         AggValueSlot::Overlap_t MayOverlap,\n                         bool isVolatile = false);\n\n  /// GetAddrOfLocalVar - Return the address of a local variable.\n  Address GetAddrOfLocalVar(const VarDecl *VD) {\n    auto it = LocalDeclMap.find(VD);\n    assert(it != LocalDeclMap.end() &&\n           \"Invalid argument to GetAddrOfLocalVar(), no decl!\");\n    return it->second;\n  }\n\n  /// Given an opaque value expression, return its LValue mapping if it exists,\n  /// otherwise create one.\n  LValue getOrCreateOpaqueLValueMapping(const OpaqueValueExpr *e);\n\n  /// Given an opaque value expression, return its RValue mapping if it exists,\n  /// otherwise create one.\n  RValue getOrCreateOpaqueRValueMapping(const OpaqueValueExpr *e);\n\n  /// Get the index of the current ArrayInitLoopExpr, if any.\n  llvm::Value *getArrayInitIndex() { return ArrayInitIndex; }\n\n  /// getAccessedFieldNo - Given an encoded value and a result number, return\n  /// the input field number being accessed.\n  static unsigned getAccessedFieldNo(unsigned Idx, const llvm::Constant *Elts);\n\n  llvm::BlockAddress *GetAddrOfLabel(const LabelDecl *L);\n  llvm::BasicBlock *GetIndirectGotoBlock();\n\n  /// Check if \\p E is a C++ \"this\" pointer wrapped in value-preserving casts.\n  static bool IsWrappedCXXThis(const Expr *E);\n\n  /// EmitNullInitialization - Generate code to set a value of the given type to\n  /// null, If the type contains data member pointers, they will be initialized\n  /// to -1 in accordance with the Itanium C++ ABI.\n  void EmitNullInitialization(Address DestPtr, QualType Ty);\n\n  /// Emits a call to an LLVM variable-argument intrinsic, either\n  /// \\c llvm.va_start or \\c llvm.va_end.\n  /// \\param ArgValue A reference to the \\c va_list as emitted by either\n  /// \\c EmitVAListRef or \\c EmitMSVAListRef.\n  /// \\param IsStart If \\c true, emits a call to \\c llvm.va_start; otherwise,\n  /// calls \\c llvm.va_end.\n  llvm::Value *EmitVAStartEnd(llvm::Value *ArgValue, bool IsStart);\n\n  /// Generate code to get an argument from the passed in pointer\n  /// and update it accordingly.\n  /// \\param VE The \\c VAArgExpr for which to generate code.\n  /// \\param VAListAddr Receives a reference to the \\c va_list as emitted by\n  /// either \\c EmitVAListRef or \\c EmitMSVAListRef.\n  /// \\returns A pointer to the argument.\n  // FIXME: We should be able to get rid of this method and use the va_arg\n  // instruction in LLVM instead once it works well enough.\n  Address EmitVAArg(VAArgExpr *VE, Address &VAListAddr);\n\n  /// emitArrayLength - Compute the length of an array, even if it's a\n  /// VLA, and drill down to the base element type.\n  llvm::Value *emitArrayLength(const ArrayType *arrayType,\n                               QualType &baseType,\n                               Address &addr);\n\n  /// EmitVLASize - Capture all the sizes for the VLA expressions in\n  /// the given variably-modified type and store them in the VLASizeMap.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitVariablyModifiedType(QualType Ty);\n\n  struct VlaSizePair {\n    llvm::Value *NumElts;\n    QualType Type;\n\n    VlaSizePair(llvm::Value *NE, QualType T) : NumElts(NE), Type(T) {}\n  };\n\n  /// Return the number of elements for a single dimension\n  /// for the given array type.\n  VlaSizePair getVLAElements1D(const VariableArrayType *vla);\n  VlaSizePair getVLAElements1D(QualType vla);\n\n  /// Returns an LLVM value that corresponds to the size,\n  /// in non-variably-sized elements, of a variable length array type,\n  /// plus that largest non-variably-sized element type.  Assumes that\n  /// the type has already been emitted with EmitVariablyModifiedType.\n  VlaSizePair getVLASize(const VariableArrayType *vla);\n  VlaSizePair getVLASize(QualType vla);\n\n  /// LoadCXXThis - Load the value of 'this'. This function is only valid while\n  /// generating code for an C++ member function.\n  llvm::Value *LoadCXXThis() {\n    assert(CXXThisValue && \"no 'this' value for this function\");\n    return CXXThisValue;\n  }\n  Address LoadCXXThisAddress();\n\n  /// LoadCXXVTT - Load the VTT parameter to base constructors/destructors have\n  /// virtual bases.\n  // FIXME: Every place that calls LoadCXXVTT is something\n  // that needs to be abstracted properly.\n  llvm::Value *LoadCXXVTT() {\n    assert(CXXStructorImplicitParamValue && \"no VTT value for this function\");\n    return CXXStructorImplicitParamValue;\n  }\n\n  /// GetAddressOfBaseOfCompleteClass - Convert the given pointer to a\n  /// complete class to the given direct base.\n  Address\n  GetAddressOfDirectBaseInCompleteClass(Address Value,\n                                        const CXXRecordDecl *Derived,\n                                        const CXXRecordDecl *Base,\n                                        bool BaseIsVirtual);\n\n  static bool ShouldNullCheckClassCastValue(const CastExpr *Cast);\n\n  /// GetAddressOfBaseClass - This function will add the necessary delta to the\n  /// load of 'this' and returns address of the base class.\n  Address GetAddressOfBaseClass(Address Value,\n                                const CXXRecordDecl *Derived,\n                                CastExpr::path_const_iterator PathBegin,\n                                CastExpr::path_const_iterator PathEnd,\n                                bool NullCheckValue, SourceLocation Loc);\n\n  Address GetAddressOfDerivedClass(Address Value,\n                                   const CXXRecordDecl *Derived,\n                                   CastExpr::path_const_iterator PathBegin,\n                                   CastExpr::path_const_iterator PathEnd,\n                                   bool NullCheckValue);\n\n  /// GetVTTParameter - Return the VTT parameter that should be passed to a\n  /// base constructor/destructor with virtual bases.\n  /// FIXME: VTTs are Itanium ABI-specific, so the definition should move\n  /// to ItaniumCXXABI.cpp together with all the references to VTT.\n  llvm::Value *GetVTTParameter(GlobalDecl GD, bool ForVirtualBase,\n                               bool Delegating);\n\n  void EmitDelegateCXXConstructorCall(const CXXConstructorDecl *Ctor,\n                                      CXXCtorType CtorType,\n                                      const FunctionArgList &Args,\n                                      SourceLocation Loc);\n  // It's important not to confuse this and the previous function. Delegating\n  // constructors are the C++0x feature. The constructor delegate optimization\n  // is used to reduce duplication in the base and complete consturctors where\n  // they are substantially the same.\n  void EmitDelegatingCXXConstructorCall(const CXXConstructorDecl *Ctor,\n                                        const FunctionArgList &Args);\n\n  /// Emit a call to an inheriting constructor (that is, one that invokes a\n  /// constructor inherited from a base class) by inlining its definition. This\n  /// is necessary if the ABI does not support forwarding the arguments to the\n  /// base class constructor (because they're variadic or similar).\n  void EmitInlinedInheritingCXXConstructorCall(const CXXConstructorDecl *Ctor,\n                                               CXXCtorType CtorType,\n                                               bool ForVirtualBase,\n                                               bool Delegating,\n                                               CallArgList &Args);\n\n  /// Emit a call to a constructor inherited from a base class, passing the\n  /// current constructor's arguments along unmodified (without even making\n  /// a copy).\n  void EmitInheritedCXXConstructorCall(const CXXConstructorDecl *D,\n                                       bool ForVirtualBase, Address This,\n                                       bool InheritedFromVBase,\n                                       const CXXInheritedCtorInitExpr *E);\n\n  void EmitCXXConstructorCall(const CXXConstructorDecl *D, CXXCtorType Type,\n                              bool ForVirtualBase, bool Delegating,\n                              AggValueSlot ThisAVS, const CXXConstructExpr *E);\n\n  void EmitCXXConstructorCall(const CXXConstructorDecl *D, CXXCtorType Type,\n                              bool ForVirtualBase, bool Delegating,\n                              Address This, CallArgList &Args,\n                              AggValueSlot::Overlap_t Overlap,\n                              SourceLocation Loc, bool NewPointerIsChecked);\n\n  /// Emit assumption load for all bases. Requires to be be called only on\n  /// most-derived class and not under construction of the object.\n  void EmitVTableAssumptionLoads(const CXXRecordDecl *ClassDecl, Address This);\n\n  /// Emit assumption that vptr load == global vtable.\n  void EmitVTableAssumptionLoad(const VPtr &vptr, Address This);\n\n  void EmitSynthesizedCXXCopyCtorCall(const CXXConstructorDecl *D,\n                                      Address This, Address Src,\n                                      const CXXConstructExpr *E);\n\n  void EmitCXXAggrConstructorCall(const CXXConstructorDecl *D,\n                                  const ArrayType *ArrayTy,\n                                  Address ArrayPtr,\n                                  const CXXConstructExpr *E,\n                                  bool NewPointerIsChecked,\n                                  bool ZeroInitialization = false);\n\n  void EmitCXXAggrConstructorCall(const CXXConstructorDecl *D,\n                                  llvm::Value *NumElements,\n                                  Address ArrayPtr,\n                                  const CXXConstructExpr *E,\n                                  bool NewPointerIsChecked,\n                                  bool ZeroInitialization = false);\n\n  static Destroyer destroyCXXObject;\n\n  void EmitCXXDestructorCall(const CXXDestructorDecl *D, CXXDtorType Type,\n                             bool ForVirtualBase, bool Delegating, Address This,\n                             QualType ThisTy);\n\n  void EmitNewArrayInitializer(const CXXNewExpr *E, QualType elementType,\n                               llvm::Type *ElementTy, Address NewPtr,\n                               llvm::Value *NumElements,\n                               llvm::Value *AllocSizeWithoutCookie);\n\n  void EmitCXXTemporary(const CXXTemporary *Temporary, QualType TempType,\n                        Address Ptr);\n\n  llvm::Value *EmitLifetimeStart(uint64_t Size, llvm::Value *Addr);\n  void EmitLifetimeEnd(llvm::Value *Size, llvm::Value *Addr);\n\n  llvm::Value *EmitCXXNewExpr(const CXXNewExpr *E);\n  void EmitCXXDeleteExpr(const CXXDeleteExpr *E);\n\n  void EmitDeleteCall(const FunctionDecl *DeleteFD, llvm::Value *Ptr,\n                      QualType DeleteTy, llvm::Value *NumElements = nullptr,\n                      CharUnits CookieSize = CharUnits());\n\n  RValue EmitBuiltinNewDeleteCall(const FunctionProtoType *Type,\n                                  const CallExpr *TheCallExpr, bool IsDelete);\n\n  llvm::Value *EmitCXXTypeidExpr(const CXXTypeidExpr *E);\n  llvm::Value *EmitDynamicCast(Address V, const CXXDynamicCastExpr *DCE);\n  Address EmitCXXUuidofExpr(const CXXUuidofExpr *E);\n\n  /// Situations in which we might emit a check for the suitability of a\n  /// pointer or glvalue. Needs to be kept in sync with ubsan_handlers.cpp in\n  /// compiler-rt.\n  enum TypeCheckKind {\n    /// Checking the operand of a load. Must be suitably sized and aligned.\n    TCK_Load,\n    /// Checking the destination of a store. Must be suitably sized and aligned.\n    TCK_Store,\n    /// Checking the bound value in a reference binding. Must be suitably sized\n    /// and aligned, but is not required to refer to an object (until the\n    /// reference is used), per core issue 453.\n    TCK_ReferenceBinding,\n    /// Checking the object expression in a non-static data member access. Must\n    /// be an object within its lifetime.\n    TCK_MemberAccess,\n    /// Checking the 'this' pointer for a call to a non-static member function.\n    /// Must be an object within its lifetime.\n    TCK_MemberCall,\n    /// Checking the 'this' pointer for a constructor call.\n    TCK_ConstructorCall,\n    /// Checking the operand of a static_cast to a derived pointer type. Must be\n    /// null or an object within its lifetime.\n    TCK_DowncastPointer,\n    /// Checking the operand of a static_cast to a derived reference type. Must\n    /// be an object within its lifetime.\n    TCK_DowncastReference,\n    /// Checking the operand of a cast to a base object. Must be suitably sized\n    /// and aligned.\n    TCK_Upcast,\n    /// Checking the operand of a cast to a virtual base object. Must be an\n    /// object within its lifetime.\n    TCK_UpcastToVirtualBase,\n    /// Checking the value assigned to a _Nonnull pointer. Must not be null.\n    TCK_NonnullAssign,\n    /// Checking the operand of a dynamic_cast or a typeid expression.  Must be\n    /// null or an object within its lifetime.\n    TCK_DynamicOperation\n  };\n\n  /// Determine whether the pointer type check \\p TCK permits null pointers.\n  static bool isNullPointerAllowed(TypeCheckKind TCK);\n\n  /// Determine whether the pointer type check \\p TCK requires a vptr check.\n  static bool isVptrCheckRequired(TypeCheckKind TCK, QualType Ty);\n\n  /// Whether any type-checking sanitizers are enabled. If \\c false,\n  /// calls to EmitTypeCheck can be skipped.\n  bool sanitizePerformTypeCheck() const;\n\n  /// Emit a check that \\p V is the address of storage of the\n  /// appropriate size and alignment for an object of type \\p Type\n  /// (or if ArraySize is provided, for an array of that bound).\n  void EmitTypeCheck(TypeCheckKind TCK, SourceLocation Loc, llvm::Value *V,\n                     QualType Type, CharUnits Alignment = CharUnits::Zero(),\n                     SanitizerSet SkippedChecks = SanitizerSet(),\n                     llvm::Value *ArraySize = nullptr);\n\n  /// Emit a check that \\p Base points into an array object, which\n  /// we can access at index \\p Index. \\p Accessed should be \\c false if we\n  /// this expression is used as an lvalue, for instance in \"&Arr[Idx]\".\n  void EmitBoundsCheck(const Expr *E, const Expr *Base, llvm::Value *Index,\n                       QualType IndexType, bool Accessed);\n\n  llvm::Value *EmitScalarPrePostIncDec(const UnaryOperator *E, LValue LV,\n                                       bool isInc, bool isPre);\n  ComplexPairTy EmitComplexPrePostIncDec(const UnaryOperator *E, LValue LV,\n                                         bool isInc, bool isPre);\n\n  /// Converts Location to a DebugLoc, if debug information is enabled.\n  llvm::DebugLoc SourceLocToDebugLoc(SourceLocation Location);\n\n  /// Get the record field index as represented in debug info.\n  unsigned getDebugInfoFIndex(const RecordDecl *Rec, unsigned FieldIndex);\n\n\n  //===--------------------------------------------------------------------===//\n  //                            Declaration Emission\n  //===--------------------------------------------------------------------===//\n\n  /// EmitDecl - Emit a declaration.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitDecl(const Decl &D);\n\n  /// EmitVarDecl - Emit a local variable declaration.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitVarDecl(const VarDecl &D);\n\n  void EmitScalarInit(const Expr *init, const ValueDecl *D, LValue lvalue,\n                      bool capturedByInit);\n\n  typedef void SpecialInitFn(CodeGenFunction &Init, const VarDecl &D,\n                             llvm::Value *Address);\n\n  /// Determine whether the given initializer is trivial in the sense\n  /// that it requires no code to be generated.\n  bool isTrivialInitializer(const Expr *Init);\n\n  /// EmitAutoVarDecl - Emit an auto variable declaration.\n  ///\n  /// This function can be called with a null (unreachable) insert point.\n  void EmitAutoVarDecl(const VarDecl &D);\n\n  class AutoVarEmission {\n    friend class CodeGenFunction;\n\n    const VarDecl *Variable;\n\n    /// The address of the alloca for languages with explicit address space\n    /// (e.g. OpenCL) or alloca casted to generic pointer for address space\n    /// agnostic languages (e.g. C++). Invalid if the variable was emitted\n    /// as a global constant.\n    Address Addr;\n\n    llvm::Value *NRVOFlag;\n\n    /// True if the variable is a __block variable that is captured by an\n    /// escaping block.\n    bool IsEscapingByRef;\n\n    /// True if the variable is of aggregate type and has a constant\n    /// initializer.\n    bool IsConstantAggregate;\n\n    /// Non-null if we should use lifetime annotations.\n    llvm::Value *SizeForLifetimeMarkers;\n\n    /// Address with original alloca instruction. Invalid if the variable was\n    /// emitted as a global constant.\n    Address AllocaAddr;\n\n    struct Invalid {};\n    AutoVarEmission(Invalid)\n        : Variable(nullptr), Addr(Address::invalid()),\n          AllocaAddr(Address::invalid()) {}\n\n    AutoVarEmission(const VarDecl &variable)\n        : Variable(&variable), Addr(Address::invalid()), NRVOFlag(nullptr),\n          IsEscapingByRef(false), IsConstantAggregate(false),\n          SizeForLifetimeMarkers(nullptr), AllocaAddr(Address::invalid()) {}\n\n    bool wasEmittedAsGlobal() const { return !Addr.isValid(); }\n\n  public:\n    static AutoVarEmission invalid() { return AutoVarEmission(Invalid()); }\n\n    bool useLifetimeMarkers() const {\n      return SizeForLifetimeMarkers != nullptr;\n    }\n    llvm::Value *getSizeForLifetimeMarkers() const {\n      assert(useLifetimeMarkers());\n      return SizeForLifetimeMarkers;\n    }\n\n    /// Returns the raw, allocated address, which is not necessarily\n    /// the address of the object itself. It is casted to default\n    /// address space for address space agnostic languages.\n    Address getAllocatedAddress() const {\n      return Addr;\n    }\n\n    /// Returns the address for the original alloca instruction.\n    Address getOriginalAllocatedAddress() const { return AllocaAddr; }\n\n    /// Returns the address of the object within this declaration.\n    /// Note that this does not chase the forwarding pointer for\n    /// __block decls.\n    Address getObjectAddress(CodeGenFunction &CGF) const {\n      if (!IsEscapingByRef) return Addr;\n\n      return CGF.emitBlockByrefAddress(Addr, Variable, /*forward*/ false);\n    }\n  };\n  AutoVarEmission EmitAutoVarAlloca(const VarDecl &var);\n  void EmitAutoVarInit(const AutoVarEmission &emission);\n  void EmitAutoVarCleanups(const AutoVarEmission &emission);\n  void emitAutoVarTypeCleanup(const AutoVarEmission &emission,\n                              QualType::DestructionKind dtorKind);\n\n  /// Emits the alloca and debug information for the size expressions for each\n  /// dimension of an array. It registers the association of its (1-dimensional)\n  /// QualTypes and size expression's debug node, so that CGDebugInfo can\n  /// reference this node when creating the DISubrange object to describe the\n  /// array types.\n  void EmitAndRegisterVariableArrayDimensions(CGDebugInfo *DI,\n                                              const VarDecl &D,\n                                              bool EmitDebugInfo);\n\n  void EmitStaticVarDecl(const VarDecl &D,\n                         llvm::GlobalValue::LinkageTypes Linkage);\n\n  class ParamValue {\n    llvm::Value *Value;\n    unsigned Alignment;\n    ParamValue(llvm::Value *V, unsigned A) : Value(V), Alignment(A) {}\n  public:\n    static ParamValue forDirect(llvm::Value *value) {\n      return ParamValue(value, 0);\n    }\n    static ParamValue forIndirect(Address addr) {\n      assert(!addr.getAlignment().isZero());\n      return ParamValue(addr.getPointer(), addr.getAlignment().getQuantity());\n    }\n\n    bool isIndirect() const { return Alignment != 0; }\n    llvm::Value *getAnyValue() const { return Value; }\n\n    llvm::Value *getDirectValue() const {\n      assert(!isIndirect());\n      return Value;\n    }\n\n    Address getIndirectAddress() const {\n      assert(isIndirect());\n      return Address(Value, CharUnits::fromQuantity(Alignment));\n    }\n  };\n\n  /// EmitParmDecl - Emit a ParmVarDecl or an ImplicitParamDecl.\n  void EmitParmDecl(const VarDecl &D, ParamValue Arg, unsigned ArgNo);\n\n  /// protectFromPeepholes - Protect a value that we're intending to\n  /// store to the side, but which will probably be used later, from\n  /// aggressive peepholing optimizations that might delete it.\n  ///\n  /// Pass the result to unprotectFromPeepholes to declare that\n  /// protection is no longer required.\n  ///\n  /// There's no particular reason why this shouldn't apply to\n  /// l-values, it's just that no existing peepholes work on pointers.\n  PeepholeProtection protectFromPeepholes(RValue rvalue);\n  void unprotectFromPeepholes(PeepholeProtection protection);\n\n  void emitAlignmentAssumptionCheck(llvm::Value *Ptr, QualType Ty,\n                                    SourceLocation Loc,\n                                    SourceLocation AssumptionLoc,\n                                    llvm::Value *Alignment,\n                                    llvm::Value *OffsetValue,\n                                    llvm::Value *TheCheck,\n                                    llvm::Instruction *Assumption);\n\n  void emitAlignmentAssumption(llvm::Value *PtrValue, QualType Ty,\n                               SourceLocation Loc, SourceLocation AssumptionLoc,\n                               llvm::Value *Alignment,\n                               llvm::Value *OffsetValue = nullptr);\n\n  void emitAlignmentAssumption(llvm::Value *PtrValue, const Expr *E,\n                               SourceLocation AssumptionLoc,\n                               llvm::Value *Alignment,\n                               llvm::Value *OffsetValue = nullptr);\n\n  //===--------------------------------------------------------------------===//\n  //                             Statement Emission\n  //===--------------------------------------------------------------------===//\n\n  /// EmitStopPoint - Emit a debug stoppoint if we are emitting debug info.\n  void EmitStopPoint(const Stmt *S);\n\n  /// EmitStmt - Emit the code for the statement \\arg S. It is legal to call\n  /// this function even if there is no current insertion point.\n  ///\n  /// This function may clear the current insertion point; callers should use\n  /// EnsureInsertPoint if they wish to subsequently generate code without first\n  /// calling EmitBlock, EmitBranch, or EmitStmt.\n  void EmitStmt(const Stmt *S, ArrayRef<const Attr *> Attrs = None);\n\n  /// EmitSimpleStmt - Try to emit a \"simple\" statement which does not\n  /// necessarily require an insertion point or debug information; typically\n  /// because the statement amounts to a jump or a container of other\n  /// statements.\n  ///\n  /// \\return True if the statement was handled.\n  bool EmitSimpleStmt(const Stmt *S, ArrayRef<const Attr *> Attrs);\n\n  Address EmitCompoundStmt(const CompoundStmt &S, bool GetLast = false,\n                           AggValueSlot AVS = AggValueSlot::ignored());\n  Address EmitCompoundStmtWithoutScope(const CompoundStmt &S,\n                                       bool GetLast = false,\n                                       AggValueSlot AVS =\n                                                AggValueSlot::ignored());\n\n  /// EmitLabel - Emit the block for the given label. It is legal to call this\n  /// function even if there is no current insertion point.\n  void EmitLabel(const LabelDecl *D); // helper for EmitLabelStmt.\n\n  void EmitLabelStmt(const LabelStmt &S);\n  void EmitAttributedStmt(const AttributedStmt &S);\n  void EmitGotoStmt(const GotoStmt &S);\n  void EmitIndirectGotoStmt(const IndirectGotoStmt &S);\n  void EmitIfStmt(const IfStmt &S);\n\n  void EmitWhileStmt(const WhileStmt &S,\n                     ArrayRef<const Attr *> Attrs = None);\n  void EmitDoStmt(const DoStmt &S, ArrayRef<const Attr *> Attrs = None);\n  void EmitForStmt(const ForStmt &S,\n                   ArrayRef<const Attr *> Attrs = None);\n  void EmitReturnStmt(const ReturnStmt &S);\n  void EmitDeclStmt(const DeclStmt &S);\n  void EmitBreakStmt(const BreakStmt &S);\n  void EmitContinueStmt(const ContinueStmt &S);\n  void EmitSwitchStmt(const SwitchStmt &S);\n  void EmitDefaultStmt(const DefaultStmt &S, ArrayRef<const Attr *> Attrs);\n  void EmitCaseStmt(const CaseStmt &S, ArrayRef<const Attr *> Attrs);\n  void EmitCaseStmtRange(const CaseStmt &S, ArrayRef<const Attr *> Attrs);\n  void EmitAsmStmt(const AsmStmt &S);\n\n  void EmitObjCForCollectionStmt(const ObjCForCollectionStmt &S);\n  void EmitObjCAtTryStmt(const ObjCAtTryStmt &S);\n  void EmitObjCAtThrowStmt(const ObjCAtThrowStmt &S);\n  void EmitObjCAtSynchronizedStmt(const ObjCAtSynchronizedStmt &S);\n  void EmitObjCAutoreleasePoolStmt(const ObjCAutoreleasePoolStmt &S);\n\n  void EmitCoroutineBody(const CoroutineBodyStmt &S);\n  void EmitCoreturnStmt(const CoreturnStmt &S);\n  RValue EmitCoawaitExpr(const CoawaitExpr &E,\n                         AggValueSlot aggSlot = AggValueSlot::ignored(),\n                         bool ignoreResult = false);\n  LValue EmitCoawaitLValue(const CoawaitExpr *E);\n  RValue EmitCoyieldExpr(const CoyieldExpr &E,\n                         AggValueSlot aggSlot = AggValueSlot::ignored(),\n                         bool ignoreResult = false);\n  LValue EmitCoyieldLValue(const CoyieldExpr *E);\n  RValue EmitCoroutineIntrinsic(const CallExpr *E, unsigned int IID);\n\n  void EnterCXXTryStmt(const CXXTryStmt &S, bool IsFnTryBlock = false);\n  void ExitCXXTryStmt(const CXXTryStmt &S, bool IsFnTryBlock = false);\n\n  void EmitCXXTryStmt(const CXXTryStmt &S);\n  void EmitSEHTryStmt(const SEHTryStmt &S);\n  void EmitSEHLeaveStmt(const SEHLeaveStmt &S);\n  void EnterSEHTryStmt(const SEHTryStmt &S);\n  void ExitSEHTryStmt(const SEHTryStmt &S);\n\n  void pushSEHCleanup(CleanupKind kind,\n                      llvm::Function *FinallyFunc);\n  void startOutlinedSEHHelper(CodeGenFunction &ParentCGF, bool IsFilter,\n                              const Stmt *OutlinedStmt);\n\n  llvm::Function *GenerateSEHFilterFunction(CodeGenFunction &ParentCGF,\n                                            const SEHExceptStmt &Except);\n\n  llvm::Function *GenerateSEHFinallyFunction(CodeGenFunction &ParentCGF,\n                                             const SEHFinallyStmt &Finally);\n\n  void EmitSEHExceptionCodeSave(CodeGenFunction &ParentCGF,\n                                llvm::Value *ParentFP,\n                                llvm::Value *EntryEBP);\n  llvm::Value *EmitSEHExceptionCode();\n  llvm::Value *EmitSEHExceptionInfo();\n  llvm::Value *EmitSEHAbnormalTermination();\n\n  /// Emit simple code for OpenMP directives in Simd-only mode.\n  void EmitSimpleOMPExecutableDirective(const OMPExecutableDirective &D);\n\n  /// Scan the outlined statement for captures from the parent function. For\n  /// each capture, mark the capture as escaped and emit a call to\n  /// llvm.localrecover. Insert the localrecover result into the LocalDeclMap.\n  void EmitCapturedLocals(CodeGenFunction &ParentCGF, const Stmt *OutlinedStmt,\n                          bool IsFilter);\n\n  /// Recovers the address of a local in a parent function. ParentVar is the\n  /// address of the variable used in the immediate parent function. It can\n  /// either be an alloca or a call to llvm.localrecover if there are nested\n  /// outlined functions. ParentFP is the frame pointer of the outermost parent\n  /// frame.\n  Address recoverAddrOfEscapedLocal(CodeGenFunction &ParentCGF,\n                                    Address ParentVar,\n                                    llvm::Value *ParentFP);\n\n  void EmitCXXForRangeStmt(const CXXForRangeStmt &S,\n                           ArrayRef<const Attr *> Attrs = None);\n\n  /// Controls insertion of cancellation exit blocks in worksharing constructs.\n  class OMPCancelStackRAII {\n    CodeGenFunction &CGF;\n\n  public:\n    OMPCancelStackRAII(CodeGenFunction &CGF, OpenMPDirectiveKind Kind,\n                       bool HasCancel)\n        : CGF(CGF) {\n      CGF.OMPCancelStack.enter(CGF, Kind, HasCancel);\n    }\n    ~OMPCancelStackRAII() { CGF.OMPCancelStack.exit(CGF); }\n  };\n\n  /// Returns calculated size of the specified type.\n  llvm::Value *getTypeSize(QualType Ty);\n  LValue InitCapturedStruct(const CapturedStmt &S);\n  llvm::Function *EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K);\n  llvm::Function *GenerateCapturedStmtFunction(const CapturedStmt &S);\n  Address GenerateCapturedStmtArgument(const CapturedStmt &S);\n  llvm::Function *GenerateOpenMPCapturedStmtFunction(const CapturedStmt &S,\n                                                     SourceLocation Loc);\n  void GenerateOpenMPCapturedVars(const CapturedStmt &S,\n                                  SmallVectorImpl<llvm::Value *> &CapturedVars);\n  void emitOMPSimpleStore(LValue LVal, RValue RVal, QualType RValTy,\n                          SourceLocation Loc);\n  /// Perform element by element copying of arrays with type \\a\n  /// OriginalType from \\a SrcAddr to \\a DestAddr using copying procedure\n  /// generated by \\a CopyGen.\n  ///\n  /// \\param DestAddr Address of the destination array.\n  /// \\param SrcAddr Address of the source array.\n  /// \\param OriginalType Type of destination and source arrays.\n  /// \\param CopyGen Copying procedure that copies value of single array element\n  /// to another single array element.\n  void EmitOMPAggregateAssign(\n      Address DestAddr, Address SrcAddr, QualType OriginalType,\n      const llvm::function_ref<void(Address, Address)> CopyGen);\n  /// Emit proper copying of data from one variable to another.\n  ///\n  /// \\param OriginalType Original type of the copied variables.\n  /// \\param DestAddr Destination address.\n  /// \\param SrcAddr Source address.\n  /// \\param DestVD Destination variable used in \\a CopyExpr (for arrays, has\n  /// type of the base array element).\n  /// \\param SrcVD Source variable used in \\a CopyExpr (for arrays, has type of\n  /// the base array element).\n  /// \\param Copy Actual copygin expression for copying data from \\a SrcVD to \\a\n  /// DestVD.\n  void EmitOMPCopy(QualType OriginalType,\n                   Address DestAddr, Address SrcAddr,\n                   const VarDecl *DestVD, const VarDecl *SrcVD,\n                   const Expr *Copy);\n  /// Emit atomic update code for constructs: \\a X = \\a X \\a BO \\a E or\n  /// \\a X = \\a E \\a BO \\a E.\n  ///\n  /// \\param X Value to be updated.\n  /// \\param E Update value.\n  /// \\param BO Binary operation for update operation.\n  /// \\param IsXLHSInRHSPart true if \\a X is LHS in RHS part of the update\n  /// expression, false otherwise.\n  /// \\param AO Atomic ordering of the generated atomic instructions.\n  /// \\param CommonGen Code generator for complex expressions that cannot be\n  /// expressed through atomicrmw instruction.\n  /// \\returns <true, OldAtomicValue> if simple 'atomicrmw' instruction was\n  /// generated, <false, RValue::get(nullptr)> otherwise.\n  std::pair<bool, RValue> EmitOMPAtomicSimpleUpdateExpr(\n      LValue X, RValue E, BinaryOperatorKind BO, bool IsXLHSInRHSPart,\n      llvm::AtomicOrdering AO, SourceLocation Loc,\n      const llvm::function_ref<RValue(RValue)> CommonGen);\n  bool EmitOMPFirstprivateClause(const OMPExecutableDirective &D,\n                                 OMPPrivateScope &PrivateScope);\n  void EmitOMPPrivateClause(const OMPExecutableDirective &D,\n                            OMPPrivateScope &PrivateScope);\n  void EmitOMPUseDevicePtrClause(\n      const OMPUseDevicePtrClause &C, OMPPrivateScope &PrivateScope,\n      const llvm::DenseMap<const ValueDecl *, Address> &CaptureDeviceAddrMap);\n  void EmitOMPUseDeviceAddrClause(\n      const OMPUseDeviceAddrClause &C, OMPPrivateScope &PrivateScope,\n      const llvm::DenseMap<const ValueDecl *, Address> &CaptureDeviceAddrMap);\n  /// Emit code for copyin clause in \\a D directive. The next code is\n  /// generated at the start of outlined functions for directives:\n  /// \\code\n  /// threadprivate_var1 = master_threadprivate_var1;\n  /// operator=(threadprivate_var2, master_threadprivate_var2);\n  /// ...\n  /// __kmpc_barrier(&loc, global_tid);\n  /// \\endcode\n  ///\n  /// \\param D OpenMP directive possibly with 'copyin' clause(s).\n  /// \\returns true if at least one copyin variable is found, false otherwise.\n  bool EmitOMPCopyinClause(const OMPExecutableDirective &D);\n  /// Emit initial code for lastprivate variables. If some variable is\n  /// not also firstprivate, then the default initialization is used. Otherwise\n  /// initialization of this variable is performed by EmitOMPFirstprivateClause\n  /// method.\n  ///\n  /// \\param D Directive that may have 'lastprivate' directives.\n  /// \\param PrivateScope Private scope for capturing lastprivate variables for\n  /// proper codegen in internal captured statement.\n  ///\n  /// \\returns true if there is at least one lastprivate variable, false\n  /// otherwise.\n  bool EmitOMPLastprivateClauseInit(const OMPExecutableDirective &D,\n                                    OMPPrivateScope &PrivateScope);\n  /// Emit final copying of lastprivate values to original variables at\n  /// the end of the worksharing or simd directive.\n  ///\n  /// \\param D Directive that has at least one 'lastprivate' directives.\n  /// \\param IsLastIterCond Boolean condition that must be set to 'i1 true' if\n  /// it is the last iteration of the loop code in associated directive, or to\n  /// 'i1 false' otherwise. If this item is nullptr, no final check is required.\n  void EmitOMPLastprivateClauseFinal(const OMPExecutableDirective &D,\n                                     bool NoFinals,\n                                     llvm::Value *IsLastIterCond = nullptr);\n  /// Emit initial code for linear clauses.\n  void EmitOMPLinearClause(const OMPLoopDirective &D,\n                           CodeGenFunction::OMPPrivateScope &PrivateScope);\n  /// Emit final code for linear clauses.\n  /// \\param CondGen Optional conditional code for final part of codegen for\n  /// linear clause.\n  void EmitOMPLinearClauseFinal(\n      const OMPLoopDirective &D,\n      const llvm::function_ref<llvm::Value *(CodeGenFunction &)> CondGen);\n  /// Emit initial code for reduction variables. Creates reduction copies\n  /// and initializes them with the values according to OpenMP standard.\n  ///\n  /// \\param D Directive (possibly) with the 'reduction' clause.\n  /// \\param PrivateScope Private scope for capturing reduction variables for\n  /// proper codegen in internal captured statement.\n  ///\n  void EmitOMPReductionClauseInit(const OMPExecutableDirective &D,\n                                  OMPPrivateScope &PrivateScope,\n                                  bool ForInscan = false);\n  /// Emit final update of reduction values to original variables at\n  /// the end of the directive.\n  ///\n  /// \\param D Directive that has at least one 'reduction' directives.\n  /// \\param ReductionKind The kind of reduction to perform.\n  void EmitOMPReductionClauseFinal(const OMPExecutableDirective &D,\n                                   const OpenMPDirectiveKind ReductionKind);\n  /// Emit initial code for linear variables. Creates private copies\n  /// and initializes them with the values according to OpenMP standard.\n  ///\n  /// \\param D Directive (possibly) with the 'linear' clause.\n  /// \\return true if at least one linear variable is found that should be\n  /// initialized with the value of the original variable, false otherwise.\n  bool EmitOMPLinearClauseInit(const OMPLoopDirective &D);\n\n  typedef const llvm::function_ref<void(CodeGenFunction & /*CGF*/,\n                                        llvm::Function * /*OutlinedFn*/,\n                                        const OMPTaskDataTy & /*Data*/)>\n      TaskGenTy;\n  void EmitOMPTaskBasedDirective(const OMPExecutableDirective &S,\n                                 const OpenMPDirectiveKind CapturedRegion,\n                                 const RegionCodeGenTy &BodyGen,\n                                 const TaskGenTy &TaskGen, OMPTaskDataTy &Data);\n  struct OMPTargetDataInfo {\n    Address BasePointersArray = Address::invalid();\n    Address PointersArray = Address::invalid();\n    Address SizesArray = Address::invalid();\n    Address MappersArray = Address::invalid();\n    unsigned NumberOfTargetItems = 0;\n    explicit OMPTargetDataInfo() = default;\n    OMPTargetDataInfo(Address BasePointersArray, Address PointersArray,\n                      Address SizesArray, Address MappersArray,\n                      unsigned NumberOfTargetItems)\n        : BasePointersArray(BasePointersArray), PointersArray(PointersArray),\n          SizesArray(SizesArray), MappersArray(MappersArray),\n          NumberOfTargetItems(NumberOfTargetItems) {}\n  };\n  void EmitOMPTargetTaskBasedDirective(const OMPExecutableDirective &S,\n                                       const RegionCodeGenTy &BodyGen,\n                                       OMPTargetDataInfo &InputInfo);\n\n  void EmitOMPParallelDirective(const OMPParallelDirective &S);\n  void EmitOMPSimdDirective(const OMPSimdDirective &S);\n  void EmitOMPTileDirective(const OMPTileDirective &S);\n  void EmitOMPForDirective(const OMPForDirective &S);\n  void EmitOMPForSimdDirective(const OMPForSimdDirective &S);\n  void EmitOMPSectionsDirective(const OMPSectionsDirective &S);\n  void EmitOMPSectionDirective(const OMPSectionDirective &S);\n  void EmitOMPSingleDirective(const OMPSingleDirective &S);\n  void EmitOMPMasterDirective(const OMPMasterDirective &S);\n  void EmitOMPCriticalDirective(const OMPCriticalDirective &S);\n  void EmitOMPParallelForDirective(const OMPParallelForDirective &S);\n  void EmitOMPParallelForSimdDirective(const OMPParallelForSimdDirective &S);\n  void EmitOMPParallelSectionsDirective(const OMPParallelSectionsDirective &S);\n  void EmitOMPParallelMasterDirective(const OMPParallelMasterDirective &S);\n  void EmitOMPTaskDirective(const OMPTaskDirective &S);\n  void EmitOMPTaskyieldDirective(const OMPTaskyieldDirective &S);\n  void EmitOMPBarrierDirective(const OMPBarrierDirective &S);\n  void EmitOMPTaskwaitDirective(const OMPTaskwaitDirective &S);\n  void EmitOMPTaskgroupDirective(const OMPTaskgroupDirective &S);\n  void EmitOMPFlushDirective(const OMPFlushDirective &S);\n  void EmitOMPDepobjDirective(const OMPDepobjDirective &S);\n  void EmitOMPScanDirective(const OMPScanDirective &S);\n  void EmitOMPOrderedDirective(const OMPOrderedDirective &S);\n  void EmitOMPAtomicDirective(const OMPAtomicDirective &S);\n  void EmitOMPTargetDirective(const OMPTargetDirective &S);\n  void EmitOMPTargetDataDirective(const OMPTargetDataDirective &S);\n  void EmitOMPTargetEnterDataDirective(const OMPTargetEnterDataDirective &S);\n  void EmitOMPTargetExitDataDirective(const OMPTargetExitDataDirective &S);\n  void EmitOMPTargetUpdateDirective(const OMPTargetUpdateDirective &S);\n  void EmitOMPTargetParallelDirective(const OMPTargetParallelDirective &S);\n  void\n  EmitOMPTargetParallelForDirective(const OMPTargetParallelForDirective &S);\n  void EmitOMPTeamsDirective(const OMPTeamsDirective &S);\n  void\n  EmitOMPCancellationPointDirective(const OMPCancellationPointDirective &S);\n  void EmitOMPCancelDirective(const OMPCancelDirective &S);\n  void EmitOMPTaskLoopBasedDirective(const OMPLoopDirective &S);\n  void EmitOMPTaskLoopDirective(const OMPTaskLoopDirective &S);\n  void EmitOMPTaskLoopSimdDirective(const OMPTaskLoopSimdDirective &S);\n  void EmitOMPMasterTaskLoopDirective(const OMPMasterTaskLoopDirective &S);\n  void\n  EmitOMPMasterTaskLoopSimdDirective(const OMPMasterTaskLoopSimdDirective &S);\n  void EmitOMPParallelMasterTaskLoopDirective(\n      const OMPParallelMasterTaskLoopDirective &S);\n  void EmitOMPParallelMasterTaskLoopSimdDirective(\n      const OMPParallelMasterTaskLoopSimdDirective &S);\n  void EmitOMPDistributeDirective(const OMPDistributeDirective &S);\n  void EmitOMPDistributeParallelForDirective(\n      const OMPDistributeParallelForDirective &S);\n  void EmitOMPDistributeParallelForSimdDirective(\n      const OMPDistributeParallelForSimdDirective &S);\n  void EmitOMPDistributeSimdDirective(const OMPDistributeSimdDirective &S);\n  void EmitOMPTargetParallelForSimdDirective(\n      const OMPTargetParallelForSimdDirective &S);\n  void EmitOMPTargetSimdDirective(const OMPTargetSimdDirective &S);\n  void EmitOMPTeamsDistributeDirective(const OMPTeamsDistributeDirective &S);\n  void\n  EmitOMPTeamsDistributeSimdDirective(const OMPTeamsDistributeSimdDirective &S);\n  void EmitOMPTeamsDistributeParallelForSimdDirective(\n      const OMPTeamsDistributeParallelForSimdDirective &S);\n  void EmitOMPTeamsDistributeParallelForDirective(\n      const OMPTeamsDistributeParallelForDirective &S);\n  void EmitOMPTargetTeamsDirective(const OMPTargetTeamsDirective &S);\n  void EmitOMPTargetTeamsDistributeDirective(\n      const OMPTargetTeamsDistributeDirective &S);\n  void EmitOMPTargetTeamsDistributeParallelForDirective(\n      const OMPTargetTeamsDistributeParallelForDirective &S);\n  void EmitOMPTargetTeamsDistributeParallelForSimdDirective(\n      const OMPTargetTeamsDistributeParallelForSimdDirective &S);\n  void EmitOMPTargetTeamsDistributeSimdDirective(\n      const OMPTargetTeamsDistributeSimdDirective &S);\n\n  /// Emit device code for the target directive.\n  static void EmitOMPTargetDeviceFunction(CodeGenModule &CGM,\n                                          StringRef ParentName,\n                                          const OMPTargetDirective &S);\n  static void\n  EmitOMPTargetParallelDeviceFunction(CodeGenModule &CGM, StringRef ParentName,\n                                      const OMPTargetParallelDirective &S);\n  /// Emit device code for the target parallel for directive.\n  static void EmitOMPTargetParallelForDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetParallelForDirective &S);\n  /// Emit device code for the target parallel for simd directive.\n  static void EmitOMPTargetParallelForSimdDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetParallelForSimdDirective &S);\n  /// Emit device code for the target teams directive.\n  static void\n  EmitOMPTargetTeamsDeviceFunction(CodeGenModule &CGM, StringRef ParentName,\n                                   const OMPTargetTeamsDirective &S);\n  /// Emit device code for the target teams distribute directive.\n  static void EmitOMPTargetTeamsDistributeDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeDirective &S);\n  /// Emit device code for the target teams distribute simd directive.\n  static void EmitOMPTargetTeamsDistributeSimdDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeSimdDirective &S);\n  /// Emit device code for the target simd directive.\n  static void EmitOMPTargetSimdDeviceFunction(CodeGenModule &CGM,\n                                              StringRef ParentName,\n                                              const OMPTargetSimdDirective &S);\n  /// Emit device code for the target teams distribute parallel for simd\n  /// directive.\n  static void EmitOMPTargetTeamsDistributeParallelForSimdDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeParallelForSimdDirective &S);\n\n  static void EmitOMPTargetTeamsDistributeParallelForDeviceFunction(\n      CodeGenModule &CGM, StringRef ParentName,\n      const OMPTargetTeamsDistributeParallelForDirective &S);\n\n  /// Emit the Stmt \\p S and return its topmost canonical loop, if any.\n  /// TODO: The \\p Depth paramter is not yet implemented and must be 1. In the\n  /// future it is meant to be the number of loops expected in the loop nests\n  /// (usually specified by the \"collapse\" clause) that are collapsed to a\n  /// single loop by this function.\n  llvm::CanonicalLoopInfo *EmitOMPCollapsedCanonicalLoopNest(const Stmt *S,\n                                                             int Depth);\n\n  /// Emit an OMPCanonicalLoop using the OpenMPIRBuilder.\n  void EmitOMPCanonicalLoop(const OMPCanonicalLoop *S);\n\n  /// Emit inner loop of the worksharing/simd construct.\n  ///\n  /// \\param S Directive, for which the inner loop must be emitted.\n  /// \\param RequiresCleanup true, if directive has some associated private\n  /// variables.\n  /// \\param LoopCond Bollean condition for loop continuation.\n  /// \\param IncExpr Increment expression for loop control variable.\n  /// \\param BodyGen Generator for the inner body of the inner loop.\n  /// \\param PostIncGen Genrator for post-increment code (required for ordered\n  /// loop directvies).\n  void EmitOMPInnerLoop(\n      const OMPExecutableDirective &S, bool RequiresCleanup,\n      const Expr *LoopCond, const Expr *IncExpr,\n      const llvm::function_ref<void(CodeGenFunction &)> BodyGen,\n      const llvm::function_ref<void(CodeGenFunction &)> PostIncGen);\n\n  JumpDest getOMPCancelDestination(OpenMPDirectiveKind Kind);\n  /// Emit initial code for loop counters of loop-based directives.\n  void EmitOMPPrivateLoopCounters(const OMPLoopDirective &S,\n                                  OMPPrivateScope &LoopScope);\n\n  /// Helper for the OpenMP loop directives.\n  void EmitOMPLoopBody(const OMPLoopDirective &D, JumpDest LoopExit);\n\n  /// Emit code for the worksharing loop-based directive.\n  /// \\return true, if this construct has any lastprivate clause, false -\n  /// otherwise.\n  bool EmitOMPWorksharingLoop(const OMPLoopDirective &S, Expr *EUB,\n                              const CodeGenLoopBoundsTy &CodeGenLoopBounds,\n                              const CodeGenDispatchBoundsTy &CGDispatchBounds);\n\n  /// Emit code for the distribute loop-based directive.\n  void EmitOMPDistributeLoop(const OMPLoopDirective &S,\n                             const CodeGenLoopTy &CodeGenLoop, Expr *IncExpr);\n\n  /// Helpers for the OpenMP loop directives.\n  void EmitOMPSimdInit(const OMPLoopDirective &D, bool IsMonotonic = false);\n  void EmitOMPSimdFinal(\n      const OMPLoopDirective &D,\n      const llvm::function_ref<llvm::Value *(CodeGenFunction &)> CondGen);\n\n  /// Emits the lvalue for the expression with possibly captured variable.\n  LValue EmitOMPSharedLValue(const Expr *E);\n\nprivate:\n  /// Helpers for blocks.\n  llvm::Value *EmitBlockLiteral(const CGBlockInfo &Info);\n\n  /// struct with the values to be passed to the OpenMP loop-related functions\n  struct OMPLoopArguments {\n    /// loop lower bound\n    Address LB = Address::invalid();\n    /// loop upper bound\n    Address UB = Address::invalid();\n    /// loop stride\n    Address ST = Address::invalid();\n    /// isLastIteration argument for runtime functions\n    Address IL = Address::invalid();\n    /// Chunk value generated by sema\n    llvm::Value *Chunk = nullptr;\n    /// EnsureUpperBound\n    Expr *EUB = nullptr;\n    /// IncrementExpression\n    Expr *IncExpr = nullptr;\n    /// Loop initialization\n    Expr *Init = nullptr;\n    /// Loop exit condition\n    Expr *Cond = nullptr;\n    /// Update of LB after a whole chunk has been executed\n    Expr *NextLB = nullptr;\n    /// Update of UB after a whole chunk has been executed\n    Expr *NextUB = nullptr;\n    OMPLoopArguments() = default;\n    OMPLoopArguments(Address LB, Address UB, Address ST, Address IL,\n                     llvm::Value *Chunk = nullptr, Expr *EUB = nullptr,\n                     Expr *IncExpr = nullptr, Expr *Init = nullptr,\n                     Expr *Cond = nullptr, Expr *NextLB = nullptr,\n                     Expr *NextUB = nullptr)\n        : LB(LB), UB(UB), ST(ST), IL(IL), Chunk(Chunk), EUB(EUB),\n          IncExpr(IncExpr), Init(Init), Cond(Cond), NextLB(NextLB),\n          NextUB(NextUB) {}\n  };\n  void EmitOMPOuterLoop(bool DynamicOrOrdered, bool IsMonotonic,\n                        const OMPLoopDirective &S, OMPPrivateScope &LoopScope,\n                        const OMPLoopArguments &LoopArgs,\n                        const CodeGenLoopTy &CodeGenLoop,\n                        const CodeGenOrderedTy &CodeGenOrdered);\n  void EmitOMPForOuterLoop(const OpenMPScheduleTy &ScheduleKind,\n                           bool IsMonotonic, const OMPLoopDirective &S,\n                           OMPPrivateScope &LoopScope, bool Ordered,\n                           const OMPLoopArguments &LoopArgs,\n                           const CodeGenDispatchBoundsTy &CGDispatchBounds);\n  void EmitOMPDistributeOuterLoop(OpenMPDistScheduleClauseKind ScheduleKind,\n                                  const OMPLoopDirective &S,\n                                  OMPPrivateScope &LoopScope,\n                                  const OMPLoopArguments &LoopArgs,\n                                  const CodeGenLoopTy &CodeGenLoopContent);\n  /// Emit code for sections directive.\n  void EmitSections(const OMPExecutableDirective &S);\n\npublic:\n\n  //===--------------------------------------------------------------------===//\n  //                         LValue Expression Emission\n  //===--------------------------------------------------------------------===//\n\n  /// Create a check that a scalar RValue is non-null.\n  llvm::Value *EmitNonNullRValueCheck(RValue RV, QualType T);\n\n  /// GetUndefRValue - Get an appropriate 'undef' rvalue for the given type.\n  RValue GetUndefRValue(QualType Ty);\n\n  /// EmitUnsupportedRValue - Emit a dummy r-value using the type of E\n  /// and issue an ErrorUnsupported style diagnostic (using the\n  /// provided Name).\n  RValue EmitUnsupportedRValue(const Expr *E,\n                               const char *Name);\n\n  /// EmitUnsupportedLValue - Emit a dummy l-value using the type of E and issue\n  /// an ErrorUnsupported style diagnostic (using the provided Name).\n  LValue EmitUnsupportedLValue(const Expr *E,\n                               const char *Name);\n\n  /// EmitLValue - Emit code to compute a designator that specifies the location\n  /// of the expression.\n  ///\n  /// This can return one of two things: a simple address or a bitfield\n  /// reference.  In either case, the LLVM Value* in the LValue structure is\n  /// guaranteed to be an LLVM pointer type.\n  ///\n  /// If this returns a bitfield reference, nothing about the pointee type of\n  /// the LLVM value is known: For example, it may not be a pointer to an\n  /// integer.\n  ///\n  /// If this returns a normal address, and if the lvalue's C type is fixed\n  /// size, this method guarantees that the returned pointer type will point to\n  /// an LLVM type of the same size of the lvalue's type.  If the lvalue has a\n  /// variable length type, this is not possible.\n  ///\n  LValue EmitLValue(const Expr *E);\n\n  /// Same as EmitLValue but additionally we generate checking code to\n  /// guard against undefined behavior.  This is only suitable when we know\n  /// that the address will be used to access the object.\n  LValue EmitCheckedLValue(const Expr *E, TypeCheckKind TCK);\n\n  RValue convertTempToRValue(Address addr, QualType type,\n                             SourceLocation Loc);\n\n  void EmitAtomicInit(Expr *E, LValue lvalue);\n\n  bool LValueIsSuitableForInlineAtomic(LValue Src);\n\n  RValue EmitAtomicLoad(LValue LV, SourceLocation SL,\n                        AggValueSlot Slot = AggValueSlot::ignored());\n\n  RValue EmitAtomicLoad(LValue lvalue, SourceLocation loc,\n                        llvm::AtomicOrdering AO, bool IsVolatile = false,\n                        AggValueSlot slot = AggValueSlot::ignored());\n\n  void EmitAtomicStore(RValue rvalue, LValue lvalue, bool isInit);\n\n  void EmitAtomicStore(RValue rvalue, LValue lvalue, llvm::AtomicOrdering AO,\n                       bool IsVolatile, bool isInit);\n\n  std::pair<RValue, llvm::Value *> EmitAtomicCompareExchange(\n      LValue Obj, RValue Expected, RValue Desired, SourceLocation Loc,\n      llvm::AtomicOrdering Success =\n          llvm::AtomicOrdering::SequentiallyConsistent,\n      llvm::AtomicOrdering Failure =\n          llvm::AtomicOrdering::SequentiallyConsistent,\n      bool IsWeak = false, AggValueSlot Slot = AggValueSlot::ignored());\n\n  void EmitAtomicUpdate(LValue LVal, llvm::AtomicOrdering AO,\n                        const llvm::function_ref<RValue(RValue)> &UpdateOp,\n                        bool IsVolatile);\n\n  /// EmitToMemory - Change a scalar value from its value\n  /// representation to its in-memory representation.\n  llvm::Value *EmitToMemory(llvm::Value *Value, QualType Ty);\n\n  /// EmitFromMemory - Change a scalar value from its memory\n  /// representation to its value representation.\n  llvm::Value *EmitFromMemory(llvm::Value *Value, QualType Ty);\n\n  /// Check if the scalar \\p Value is within the valid range for the given\n  /// type \\p Ty.\n  ///\n  /// Returns true if a check is needed (even if the range is unknown).\n  bool EmitScalarRangeCheck(llvm::Value *Value, QualType Ty,\n                            SourceLocation Loc);\n\n  /// EmitLoadOfScalar - Load a scalar value from an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.\n  llvm::Value *EmitLoadOfScalar(Address Addr, bool Volatile, QualType Ty,\n                                SourceLocation Loc,\n                                AlignmentSource Source = AlignmentSource::Type,\n                                bool isNontemporal = false) {\n    return EmitLoadOfScalar(Addr, Volatile, Ty, Loc, LValueBaseInfo(Source),\n                            CGM.getTBAAAccessInfo(Ty), isNontemporal);\n  }\n\n  llvm::Value *EmitLoadOfScalar(Address Addr, bool Volatile, QualType Ty,\n                                SourceLocation Loc, LValueBaseInfo BaseInfo,\n                                TBAAAccessInfo TBAAInfo,\n                                bool isNontemporal = false);\n\n  /// EmitLoadOfScalar - Load a scalar value from an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.  The l-value must be a simple\n  /// l-value.\n  llvm::Value *EmitLoadOfScalar(LValue lvalue, SourceLocation Loc);\n\n  /// EmitStoreOfScalar - Store a scalar value to an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.\n  void EmitStoreOfScalar(llvm::Value *Value, Address Addr,\n                         bool Volatile, QualType Ty,\n                         AlignmentSource Source = AlignmentSource::Type,\n                         bool isInit = false, bool isNontemporal = false) {\n    EmitStoreOfScalar(Value, Addr, Volatile, Ty, LValueBaseInfo(Source),\n                      CGM.getTBAAAccessInfo(Ty), isInit, isNontemporal);\n  }\n\n  void EmitStoreOfScalar(llvm::Value *Value, Address Addr,\n                         bool Volatile, QualType Ty,\n                         LValueBaseInfo BaseInfo, TBAAAccessInfo TBAAInfo,\n                         bool isInit = false, bool isNontemporal = false);\n\n  /// EmitStoreOfScalar - Store a scalar value to an address, taking\n  /// care to appropriately convert from the memory representation to\n  /// the LLVM value representation.  The l-value must be a simple\n  /// l-value.  The isInit flag indicates whether this is an initialization.\n  /// If so, atomic qualifiers are ignored and the store is always non-atomic.\n  void EmitStoreOfScalar(llvm::Value *value, LValue lvalue, bool isInit=false);\n\n  /// EmitLoadOfLValue - Given an expression that represents a value lvalue,\n  /// this method emits the address of the lvalue, then loads the result as an\n  /// rvalue, returning the rvalue.\n  RValue EmitLoadOfLValue(LValue V, SourceLocation Loc);\n  RValue EmitLoadOfExtVectorElementLValue(LValue V);\n  RValue EmitLoadOfBitfieldLValue(LValue LV, SourceLocation Loc);\n  RValue EmitLoadOfGlobalRegLValue(LValue LV);\n\n  /// EmitStoreThroughLValue - Store the specified rvalue into the specified\n  /// lvalue, where both are guaranteed to the have the same type, and that type\n  /// is 'Ty'.\n  void EmitStoreThroughLValue(RValue Src, LValue Dst, bool isInit = false);\n  void EmitStoreThroughExtVectorComponentLValue(RValue Src, LValue Dst);\n  void EmitStoreThroughGlobalRegLValue(RValue Src, LValue Dst);\n\n  /// EmitStoreThroughBitfieldLValue - Store Src into Dst with same constraints\n  /// as EmitStoreThroughLValue.\n  ///\n  /// \\param Result [out] - If non-null, this will be set to a Value* for the\n  /// bit-field contents after the store, appropriate for use as the result of\n  /// an assignment to the bit-field.\n  void EmitStoreThroughBitfieldLValue(RValue Src, LValue Dst,\n                                      llvm::Value **Result=nullptr);\n\n  /// Emit an l-value for an assignment (simple or compound) of complex type.\n  LValue EmitComplexAssignmentLValue(const BinaryOperator *E);\n  LValue EmitComplexCompoundAssignmentLValue(const CompoundAssignOperator *E);\n  LValue EmitScalarCompoundAssignWithComplex(const CompoundAssignOperator *E,\n                                             llvm::Value *&Result);\n\n  // Note: only available for agg return types\n  LValue EmitBinaryOperatorLValue(const BinaryOperator *E);\n  LValue EmitCompoundAssignmentLValue(const CompoundAssignOperator *E);\n  // Note: only available for agg return types\n  LValue EmitCallExprLValue(const CallExpr *E);\n  // Note: only available for agg return types\n  LValue EmitVAArgExprLValue(const VAArgExpr *E);\n  LValue EmitDeclRefLValue(const DeclRefExpr *E);\n  LValue EmitStringLiteralLValue(const StringLiteral *E);\n  LValue EmitObjCEncodeExprLValue(const ObjCEncodeExpr *E);\n  LValue EmitPredefinedLValue(const PredefinedExpr *E);\n  LValue EmitUnaryOpLValue(const UnaryOperator *E);\n  LValue EmitArraySubscriptExpr(const ArraySubscriptExpr *E,\n                                bool Accessed = false);\n  LValue EmitMatrixSubscriptExpr(const MatrixSubscriptExpr *E);\n  LValue EmitOMPArraySectionExpr(const OMPArraySectionExpr *E,\n                                 bool IsLowerBound = true);\n  LValue EmitExtVectorElementExpr(const ExtVectorElementExpr *E);\n  LValue EmitMemberExpr(const MemberExpr *E);\n  LValue EmitObjCIsaExpr(const ObjCIsaExpr *E);\n  LValue EmitCompoundLiteralLValue(const CompoundLiteralExpr *E);\n  LValue EmitInitListLValue(const InitListExpr *E);\n  LValue EmitConditionalOperatorLValue(const AbstractConditionalOperator *E);\n  LValue EmitCastLValue(const CastExpr *E);\n  LValue EmitMaterializeTemporaryExpr(const MaterializeTemporaryExpr *E);\n  LValue EmitOpaqueValueLValue(const OpaqueValueExpr *e);\n\n  Address EmitExtVectorElementLValue(LValue V);\n\n  RValue EmitRValueForField(LValue LV, const FieldDecl *FD, SourceLocation Loc);\n\n  Address EmitArrayToPointerDecay(const Expr *Array,\n                                  LValueBaseInfo *BaseInfo = nullptr,\n                                  TBAAAccessInfo *TBAAInfo = nullptr);\n\n  class ConstantEmission {\n    llvm::PointerIntPair<llvm::Constant*, 1, bool> ValueAndIsReference;\n    ConstantEmission(llvm::Constant *C, bool isReference)\n      : ValueAndIsReference(C, isReference) {}\n  public:\n    ConstantEmission() {}\n    static ConstantEmission forReference(llvm::Constant *C) {\n      return ConstantEmission(C, true);\n    }\n    static ConstantEmission forValue(llvm::Constant *C) {\n      return ConstantEmission(C, false);\n    }\n\n    explicit operator bool() const {\n      return ValueAndIsReference.getOpaqueValue() != nullptr;\n    }\n\n    bool isReference() const { return ValueAndIsReference.getInt(); }\n    LValue getReferenceLValue(CodeGenFunction &CGF, Expr *refExpr) const {\n      assert(isReference());\n      return CGF.MakeNaturalAlignAddrLValue(ValueAndIsReference.getPointer(),\n                                            refExpr->getType());\n    }\n\n    llvm::Constant *getValue() const {\n      assert(!isReference());\n      return ValueAndIsReference.getPointer();\n    }\n  };\n\n  ConstantEmission tryEmitAsConstant(DeclRefExpr *refExpr);\n  ConstantEmission tryEmitAsConstant(const MemberExpr *ME);\n  llvm::Value *emitScalarConstant(const ConstantEmission &Constant, Expr *E);\n\n  RValue EmitPseudoObjectRValue(const PseudoObjectExpr *e,\n                                AggValueSlot slot = AggValueSlot::ignored());\n  LValue EmitPseudoObjectLValue(const PseudoObjectExpr *e);\n\n  llvm::Value *EmitIvarOffset(const ObjCInterfaceDecl *Interface,\n                              const ObjCIvarDecl *Ivar);\n  LValue EmitLValueForField(LValue Base, const FieldDecl* Field);\n  LValue EmitLValueForLambdaField(const FieldDecl *Field);\n\n  /// EmitLValueForFieldInitialization - Like EmitLValueForField, except that\n  /// if the Field is a reference, this will return the address of the reference\n  /// and not the address of the value stored in the reference.\n  LValue EmitLValueForFieldInitialization(LValue Base,\n                                          const FieldDecl* Field);\n\n  LValue EmitLValueForIvar(QualType ObjectTy,\n                           llvm::Value* Base, const ObjCIvarDecl *Ivar,\n                           unsigned CVRQualifiers);\n\n  LValue EmitCXXConstructLValue(const CXXConstructExpr *E);\n  LValue EmitCXXBindTemporaryLValue(const CXXBindTemporaryExpr *E);\n  LValue EmitCXXTypeidLValue(const CXXTypeidExpr *E);\n  LValue EmitCXXUuidofLValue(const CXXUuidofExpr *E);\n\n  LValue EmitObjCMessageExprLValue(const ObjCMessageExpr *E);\n  LValue EmitObjCIvarRefLValue(const ObjCIvarRefExpr *E);\n  LValue EmitStmtExprLValue(const StmtExpr *E);\n  LValue EmitPointerToDataMemberBinaryExpr(const BinaryOperator *E);\n  LValue EmitObjCSelectorLValue(const ObjCSelectorExpr *E);\n  void   EmitDeclRefExprDbgValue(const DeclRefExpr *E, const APValue &Init);\n\n  //===--------------------------------------------------------------------===//\n  //                         Scalar Expression Emission\n  //===--------------------------------------------------------------------===//\n\n  /// EmitCall - Generate a call of the given function, expecting the given\n  /// result type, and using the given argument list which specifies both the\n  /// LLVM arguments and the types they were derived from.\n  RValue EmitCall(const CGFunctionInfo &CallInfo, const CGCallee &Callee,\n                  ReturnValueSlot ReturnValue, const CallArgList &Args,\n                  llvm::CallBase **callOrInvoke, SourceLocation Loc);\n  RValue EmitCall(const CGFunctionInfo &CallInfo, const CGCallee &Callee,\n                  ReturnValueSlot ReturnValue, const CallArgList &Args,\n                  llvm::CallBase **callOrInvoke = nullptr) {\n    return EmitCall(CallInfo, Callee, ReturnValue, Args, callOrInvoke,\n                    SourceLocation());\n  }\n  RValue EmitCall(QualType FnType, const CGCallee &Callee, const CallExpr *E,\n                  ReturnValueSlot ReturnValue, llvm::Value *Chain = nullptr);\n  RValue EmitCallExpr(const CallExpr *E,\n                      ReturnValueSlot ReturnValue = ReturnValueSlot());\n  RValue EmitSimpleCallExpr(const CallExpr *E, ReturnValueSlot ReturnValue);\n  CGCallee EmitCallee(const Expr *E);\n\n  void checkTargetFeatures(const CallExpr *E, const FunctionDecl *TargetDecl);\n  void checkTargetFeatures(SourceLocation Loc, const FunctionDecl *TargetDecl);\n\n  llvm::CallInst *EmitRuntimeCall(llvm::FunctionCallee callee,\n                                  const Twine &name = \"\");\n  llvm::CallInst *EmitRuntimeCall(llvm::FunctionCallee callee,\n                                  ArrayRef<llvm::Value *> args,\n                                  const Twine &name = \"\");\n  llvm::CallInst *EmitNounwindRuntimeCall(llvm::FunctionCallee callee,\n                                          const Twine &name = \"\");\n  llvm::CallInst *EmitNounwindRuntimeCall(llvm::FunctionCallee callee,\n                                          ArrayRef<llvm::Value *> args,\n                                          const Twine &name = \"\");\n\n  SmallVector<llvm::OperandBundleDef, 1>\n  getBundlesForFunclet(llvm::Value *Callee);\n\n  llvm::CallBase *EmitCallOrInvoke(llvm::FunctionCallee Callee,\n                                   ArrayRef<llvm::Value *> Args,\n                                   const Twine &Name = \"\");\n  llvm::CallBase *EmitRuntimeCallOrInvoke(llvm::FunctionCallee callee,\n                                          ArrayRef<llvm::Value *> args,\n                                          const Twine &name = \"\");\n  llvm::CallBase *EmitRuntimeCallOrInvoke(llvm::FunctionCallee callee,\n                                          const Twine &name = \"\");\n  void EmitNoreturnRuntimeCallOrInvoke(llvm::FunctionCallee callee,\n                                       ArrayRef<llvm::Value *> args);\n\n  CGCallee BuildAppleKextVirtualCall(const CXXMethodDecl *MD,\n                                     NestedNameSpecifier *Qual,\n                                     llvm::Type *Ty);\n\n  CGCallee BuildAppleKextVirtualDestructorCall(const CXXDestructorDecl *DD,\n                                               CXXDtorType Type,\n                                               const CXXRecordDecl *RD);\n\n  // Return the copy constructor name with the prefix \"__copy_constructor_\"\n  // removed.\n  static std::string getNonTrivialCopyConstructorStr(QualType QT,\n                                                     CharUnits Alignment,\n                                                     bool IsVolatile,\n                                                     ASTContext &Ctx);\n\n  // Return the destructor name with the prefix \"__destructor_\" removed.\n  static std::string getNonTrivialDestructorStr(QualType QT,\n                                                CharUnits Alignment,\n                                                bool IsVolatile,\n                                                ASTContext &Ctx);\n\n  // These functions emit calls to the special functions of non-trivial C\n  // structs.\n  void defaultInitNonTrivialCStructVar(LValue Dst);\n  void callCStructDefaultConstructor(LValue Dst);\n  void callCStructDestructor(LValue Dst);\n  void callCStructCopyConstructor(LValue Dst, LValue Src);\n  void callCStructMoveConstructor(LValue Dst, LValue Src);\n  void callCStructCopyAssignmentOperator(LValue Dst, LValue Src);\n  void callCStructMoveAssignmentOperator(LValue Dst, LValue Src);\n\n  RValue\n  EmitCXXMemberOrOperatorCall(const CXXMethodDecl *Method,\n                              const CGCallee &Callee,\n                              ReturnValueSlot ReturnValue, llvm::Value *This,\n                              llvm::Value *ImplicitParam,\n                              QualType ImplicitParamTy, const CallExpr *E,\n                              CallArgList *RtlArgs);\n  RValue EmitCXXDestructorCall(GlobalDecl Dtor, const CGCallee &Callee,\n                               llvm::Value *This, QualType ThisTy,\n                               llvm::Value *ImplicitParam,\n                               QualType ImplicitParamTy, const CallExpr *E);\n  RValue EmitCXXMemberCallExpr(const CXXMemberCallExpr *E,\n                               ReturnValueSlot ReturnValue);\n  RValue EmitCXXMemberOrOperatorMemberCallExpr(const CallExpr *CE,\n                                               const CXXMethodDecl *MD,\n                                               ReturnValueSlot ReturnValue,\n                                               bool HasQualifier,\n                                               NestedNameSpecifier *Qualifier,\n                                               bool IsArrow, const Expr *Base);\n  // Compute the object pointer.\n  Address EmitCXXMemberDataPointerAddress(const Expr *E, Address base,\n                                          llvm::Value *memberPtr,\n                                          const MemberPointerType *memberPtrType,\n                                          LValueBaseInfo *BaseInfo = nullptr,\n                                          TBAAAccessInfo *TBAAInfo = nullptr);\n  RValue EmitCXXMemberPointerCallExpr(const CXXMemberCallExpr *E,\n                                      ReturnValueSlot ReturnValue);\n\n  RValue EmitCXXOperatorMemberCallExpr(const CXXOperatorCallExpr *E,\n                                       const CXXMethodDecl *MD,\n                                       ReturnValueSlot ReturnValue);\n  RValue EmitCXXPseudoDestructorExpr(const CXXPseudoDestructorExpr *E);\n\n  RValue EmitCUDAKernelCallExpr(const CUDAKernelCallExpr *E,\n                                ReturnValueSlot ReturnValue);\n\n  RValue EmitNVPTXDevicePrintfCallExpr(const CallExpr *E,\n                                       ReturnValueSlot ReturnValue);\n  RValue EmitAMDGPUDevicePrintfCallExpr(const CallExpr *E,\n                                        ReturnValueSlot ReturnValue);\n\n  RValue EmitBuiltinExpr(const GlobalDecl GD, unsigned BuiltinID,\n                         const CallExpr *E, ReturnValueSlot ReturnValue);\n\n  RValue emitRotate(const CallExpr *E, bool IsRotateRight);\n\n  /// Emit IR for __builtin_os_log_format.\n  RValue emitBuiltinOSLogFormat(const CallExpr &E);\n\n  /// Emit IR for __builtin_is_aligned.\n  RValue EmitBuiltinIsAligned(const CallExpr *E);\n  /// Emit IR for __builtin_align_up/__builtin_align_down.\n  RValue EmitBuiltinAlignTo(const CallExpr *E, bool AlignUp);\n\n  llvm::Function *generateBuiltinOSLogHelperFunction(\n      const analyze_os_log::OSLogBufferLayout &Layout,\n      CharUnits BufferAlignment);\n\n  RValue EmitBlockCallExpr(const CallExpr *E, ReturnValueSlot ReturnValue);\n\n  /// EmitTargetBuiltinExpr - Emit the given builtin call. Returns 0 if the call\n  /// is unhandled by the current target.\n  llvm::Value *EmitTargetBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                     ReturnValueSlot ReturnValue);\n\n  llvm::Value *EmitAArch64CompareBuiltinExpr(llvm::Value *Op, llvm::Type *Ty,\n                                             const llvm::CmpInst::Predicate Fp,\n                                             const llvm::CmpInst::Predicate Ip,\n                                             const llvm::Twine &Name = \"\");\n  llvm::Value *EmitARMBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                  ReturnValueSlot ReturnValue,\n                                  llvm::Triple::ArchType Arch);\n  llvm::Value *EmitARMMVEBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                     ReturnValueSlot ReturnValue,\n                                     llvm::Triple::ArchType Arch);\n  llvm::Value *EmitARMCDEBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                     ReturnValueSlot ReturnValue,\n                                     llvm::Triple::ArchType Arch);\n  llvm::Value *EmitCMSEClearRecord(llvm::Value *V, llvm::IntegerType *ITy,\n                                   QualType RTy);\n  llvm::Value *EmitCMSEClearRecord(llvm::Value *V, llvm::ArrayType *ATy,\n                                   QualType RTy);\n\n  llvm::Value *EmitCommonNeonBuiltinExpr(unsigned BuiltinID,\n                                         unsigned LLVMIntrinsic,\n                                         unsigned AltLLVMIntrinsic,\n                                         const char *NameHint,\n                                         unsigned Modifier,\n                                         const CallExpr *E,\n                                         SmallVectorImpl<llvm::Value *> &Ops,\n                                         Address PtrOp0, Address PtrOp1,\n                                         llvm::Triple::ArchType Arch);\n\n  llvm::Function *LookupNeonLLVMIntrinsic(unsigned IntrinsicID,\n                                          unsigned Modifier, llvm::Type *ArgTy,\n                                          const CallExpr *E);\n  llvm::Value *EmitNeonCall(llvm::Function *F,\n                            SmallVectorImpl<llvm::Value*> &O,\n                            const char *name,\n                            unsigned shift = 0, bool rightshift = false);\n  llvm::Value *EmitNeonSplat(llvm::Value *V, llvm::Constant *Idx,\n                             const llvm::ElementCount &Count);\n  llvm::Value *EmitNeonSplat(llvm::Value *V, llvm::Constant *Idx);\n  llvm::Value *EmitNeonShiftVector(llvm::Value *V, llvm::Type *Ty,\n                                   bool negateForRightShift);\n  llvm::Value *EmitNeonRShiftImm(llvm::Value *Vec, llvm::Value *Amt,\n                                 llvm::Type *Ty, bool usgn, const char *name);\n  llvm::Value *vectorWrapScalar16(llvm::Value *Op);\n  /// SVEBuiltinMemEltTy - Returns the memory element type for this memory\n  /// access builtin.  Only required if it can't be inferred from the base\n  /// pointer operand.\n  llvm::Type *SVEBuiltinMemEltTy(SVETypeFlags TypeFlags);\n\n  SmallVector<llvm::Type *, 2> getSVEOverloadTypes(SVETypeFlags TypeFlags,\n                                                   llvm::Type *ReturnType,\n                                                   ArrayRef<llvm::Value *> Ops);\n  llvm::Type *getEltType(SVETypeFlags TypeFlags);\n  llvm::ScalableVectorType *getSVEType(const SVETypeFlags &TypeFlags);\n  llvm::ScalableVectorType *getSVEPredType(SVETypeFlags TypeFlags);\n  llvm::Value *EmitSVEAllTruePred(SVETypeFlags TypeFlags);\n  llvm::Value *EmitSVEDupX(llvm::Value *Scalar);\n  llvm::Value *EmitSVEDupX(llvm::Value *Scalar, llvm::Type *Ty);\n  llvm::Value *EmitSVEReinterpret(llvm::Value *Val, llvm::Type *Ty);\n  llvm::Value *EmitSVEPMull(SVETypeFlags TypeFlags,\n                            llvm::SmallVectorImpl<llvm::Value *> &Ops,\n                            unsigned BuiltinID);\n  llvm::Value *EmitSVEMovl(SVETypeFlags TypeFlags,\n                           llvm::ArrayRef<llvm::Value *> Ops,\n                           unsigned BuiltinID);\n  llvm::Value *EmitSVEPredicateCast(llvm::Value *Pred,\n                                    llvm::ScalableVectorType *VTy);\n  llvm::Value *EmitSVEGatherLoad(SVETypeFlags TypeFlags,\n                                 llvm::SmallVectorImpl<llvm::Value *> &Ops,\n                                 unsigned IntID);\n  llvm::Value *EmitSVEScatterStore(SVETypeFlags TypeFlags,\n                                   llvm::SmallVectorImpl<llvm::Value *> &Ops,\n                                   unsigned IntID);\n  llvm::Value *EmitSVEMaskedLoad(const CallExpr *, llvm::Type *ReturnTy,\n                                 SmallVectorImpl<llvm::Value *> &Ops,\n                                 unsigned BuiltinID, bool IsZExtReturn);\n  llvm::Value *EmitSVEMaskedStore(const CallExpr *,\n                                  SmallVectorImpl<llvm::Value *> &Ops,\n                                  unsigned BuiltinID);\n  llvm::Value *EmitSVEPrefetchLoad(SVETypeFlags TypeFlags,\n                                   SmallVectorImpl<llvm::Value *> &Ops,\n                                   unsigned BuiltinID);\n  llvm::Value *EmitSVEGatherPrefetch(SVETypeFlags TypeFlags,\n                                     SmallVectorImpl<llvm::Value *> &Ops,\n                                     unsigned IntID);\n  llvm::Value *EmitSVEStructLoad(SVETypeFlags TypeFlags,\n                                 SmallVectorImpl<llvm::Value *> &Ops, unsigned IntID);\n  llvm::Value *EmitSVEStructStore(SVETypeFlags TypeFlags,\n                                  SmallVectorImpl<llvm::Value *> &Ops,\n                                  unsigned IntID);\n  llvm::Value *EmitAArch64SVEBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n\n  llvm::Value *EmitAArch64BuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                      llvm::Triple::ArchType Arch);\n  llvm::Value *EmitBPFBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n\n  llvm::Value *BuildVector(ArrayRef<llvm::Value*> Ops);\n  llvm::Value *EmitX86BuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitPPCBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitAMDGPUBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitSystemZBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitNVPTXBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitWebAssemblyBuiltinExpr(unsigned BuiltinID,\n                                          const CallExpr *E);\n  llvm::Value *EmitHexagonBuiltinExpr(unsigned BuiltinID, const CallExpr *E);\n  llvm::Value *EmitRISCVBuiltinExpr(unsigned BuiltinID, const CallExpr *E,\n                                    ReturnValueSlot ReturnValue);\n  bool ProcessOrderScopeAMDGCN(llvm::Value *Order, llvm::Value *Scope,\n                               llvm::AtomicOrdering &AO,\n                               llvm::SyncScope::ID &SSID);\n\n  enum class MSVCIntrin;\n  llvm::Value *EmitMSVCBuiltinExpr(MSVCIntrin BuiltinID, const CallExpr *E);\n\n  llvm::Value *EmitBuiltinAvailable(const VersionTuple &Version);\n\n  llvm::Value *EmitObjCProtocolExpr(const ObjCProtocolExpr *E);\n  llvm::Value *EmitObjCStringLiteral(const ObjCStringLiteral *E);\n  llvm::Value *EmitObjCBoxedExpr(const ObjCBoxedExpr *E);\n  llvm::Value *EmitObjCArrayLiteral(const ObjCArrayLiteral *E);\n  llvm::Value *EmitObjCDictionaryLiteral(const ObjCDictionaryLiteral *E);\n  llvm::Value *EmitObjCCollectionLiteral(const Expr *E,\n                                const ObjCMethodDecl *MethodWithObjects);\n  llvm::Value *EmitObjCSelectorExpr(const ObjCSelectorExpr *E);\n  RValue EmitObjCMessageExpr(const ObjCMessageExpr *E,\n                             ReturnValueSlot Return = ReturnValueSlot());\n\n  /// Retrieves the default cleanup kind for an ARC cleanup.\n  /// Except under -fobjc-arc-eh, ARC cleanups are normal-only.\n  CleanupKind getARCCleanupKind() {\n    return CGM.getCodeGenOpts().ObjCAutoRefCountExceptions\n             ? NormalAndEHCleanup : NormalCleanup;\n  }\n\n  // ARC primitives.\n  void EmitARCInitWeak(Address addr, llvm::Value *value);\n  void EmitARCDestroyWeak(Address addr);\n  llvm::Value *EmitARCLoadWeak(Address addr);\n  llvm::Value *EmitARCLoadWeakRetained(Address addr);\n  llvm::Value *EmitARCStoreWeak(Address addr, llvm::Value *value, bool ignored);\n  void emitARCCopyAssignWeak(QualType Ty, Address DstAddr, Address SrcAddr);\n  void emitARCMoveAssignWeak(QualType Ty, Address DstAddr, Address SrcAddr);\n  void EmitARCCopyWeak(Address dst, Address src);\n  void EmitARCMoveWeak(Address dst, Address src);\n  llvm::Value *EmitARCRetainAutorelease(QualType type, llvm::Value *value);\n  llvm::Value *EmitARCRetainAutoreleaseNonBlock(llvm::Value *value);\n  llvm::Value *EmitARCStoreStrong(LValue lvalue, llvm::Value *value,\n                                  bool resultIgnored);\n  llvm::Value *EmitARCStoreStrongCall(Address addr, llvm::Value *value,\n                                      bool resultIgnored);\n  llvm::Value *EmitARCRetain(QualType type, llvm::Value *value);\n  llvm::Value *EmitARCRetainNonBlock(llvm::Value *value);\n  llvm::Value *EmitARCRetainBlock(llvm::Value *value, bool mandatory);\n  void EmitARCDestroyStrong(Address addr, ARCPreciseLifetime_t precise);\n  void EmitARCRelease(llvm::Value *value, ARCPreciseLifetime_t precise);\n  llvm::Value *EmitARCAutorelease(llvm::Value *value);\n  llvm::Value *EmitARCAutoreleaseReturnValue(llvm::Value *value);\n  llvm::Value *EmitARCRetainAutoreleaseReturnValue(llvm::Value *value);\n  llvm::Value *EmitARCRetainAutoreleasedReturnValue(llvm::Value *value);\n  llvm::Value *EmitARCUnsafeClaimAutoreleasedReturnValue(llvm::Value *value);\n\n  llvm::Value *EmitObjCAutorelease(llvm::Value *value, llvm::Type *returnType);\n  llvm::Value *EmitObjCRetainNonBlock(llvm::Value *value,\n                                      llvm::Type *returnType);\n  void EmitObjCRelease(llvm::Value *value, ARCPreciseLifetime_t precise);\n\n  std::pair<LValue,llvm::Value*>\n  EmitARCStoreAutoreleasing(const BinaryOperator *e);\n  std::pair<LValue,llvm::Value*>\n  EmitARCStoreStrong(const BinaryOperator *e, bool ignored);\n  std::pair<LValue,llvm::Value*>\n  EmitARCStoreUnsafeUnretained(const BinaryOperator *e, bool ignored);\n\n  llvm::Value *EmitObjCAlloc(llvm::Value *value,\n                             llvm::Type *returnType);\n  llvm::Value *EmitObjCAllocWithZone(llvm::Value *value,\n                                     llvm::Type *returnType);\n  llvm::Value *EmitObjCAllocInit(llvm::Value *value, llvm::Type *resultType);\n\n  llvm::Value *EmitObjCThrowOperand(const Expr *expr);\n  llvm::Value *EmitObjCConsumeObject(QualType T, llvm::Value *Ptr);\n  llvm::Value *EmitObjCExtendObjectLifetime(QualType T, llvm::Value *Ptr);\n\n  llvm::Value *EmitARCExtendBlockObject(const Expr *expr);\n  llvm::Value *EmitARCReclaimReturnedObject(const Expr *e,\n                                            bool allowUnsafeClaim);\n  llvm::Value *EmitARCRetainScalarExpr(const Expr *expr);\n  llvm::Value *EmitARCRetainAutoreleaseScalarExpr(const Expr *expr);\n  llvm::Value *EmitARCUnsafeUnretainedScalarExpr(const Expr *expr);\n\n  void EmitARCIntrinsicUse(ArrayRef<llvm::Value*> values);\n\n  void EmitARCNoopIntrinsicUse(ArrayRef<llvm::Value *> values);\n\n  static Destroyer destroyARCStrongImprecise;\n  static Destroyer destroyARCStrongPrecise;\n  static Destroyer destroyARCWeak;\n  static Destroyer emitARCIntrinsicUse;\n  static Destroyer destroyNonTrivialCStruct;\n\n  void EmitObjCAutoreleasePoolPop(llvm::Value *Ptr);\n  llvm::Value *EmitObjCAutoreleasePoolPush();\n  llvm::Value *EmitObjCMRRAutoreleasePoolPush();\n  void EmitObjCAutoreleasePoolCleanup(llvm::Value *Ptr);\n  void EmitObjCMRRAutoreleasePoolPop(llvm::Value *Ptr);\n\n  /// Emits a reference binding to the passed in expression.\n  RValue EmitReferenceBindingToExpr(const Expr *E);\n\n  //===--------------------------------------------------------------------===//\n  //                           Expression Emission\n  //===--------------------------------------------------------------------===//\n\n  // Expressions are broken into three classes: scalar, complex, aggregate.\n\n  /// EmitScalarExpr - Emit the computation of the specified expression of LLVM\n  /// scalar type, returning the result.\n  llvm::Value *EmitScalarExpr(const Expr *E , bool IgnoreResultAssign = false);\n\n  /// Emit a conversion from the specified type to the specified destination\n  /// type, both of which are LLVM scalar types.\n  llvm::Value *EmitScalarConversion(llvm::Value *Src, QualType SrcTy,\n                                    QualType DstTy, SourceLocation Loc);\n\n  /// Emit a conversion from the specified complex type to the specified\n  /// destination type, where the destination type is an LLVM scalar type.\n  llvm::Value *EmitComplexToScalarConversion(ComplexPairTy Src, QualType SrcTy,\n                                             QualType DstTy,\n                                             SourceLocation Loc);\n\n  /// EmitAggExpr - Emit the computation of the specified expression\n  /// of aggregate type.  The result is computed into the given slot,\n  /// which may be null to indicate that the value is not needed.\n  void EmitAggExpr(const Expr *E, AggValueSlot AS);\n\n  /// EmitAggExprToLValue - Emit the computation of the specified expression of\n  /// aggregate type into a temporary LValue.\n  LValue EmitAggExprToLValue(const Expr *E);\n\n  /// Build all the stores needed to initialize an aggregate at Dest with the\n  /// value Val.\n  void EmitAggregateStore(llvm::Value *Val, Address Dest, bool DestIsVolatile);\n\n  /// EmitExtendGCLifetime - Given a pointer to an Objective-C object,\n  /// make sure it survives garbage collection until this point.\n  void EmitExtendGCLifetime(llvm::Value *object);\n\n  /// EmitComplexExpr - Emit the computation of the specified expression of\n  /// complex type, returning the result.\n  ComplexPairTy EmitComplexExpr(const Expr *E,\n                                bool IgnoreReal = false,\n                                bool IgnoreImag = false);\n\n  /// EmitComplexExprIntoLValue - Emit the given expression of complex\n  /// type and place its result into the specified l-value.\n  void EmitComplexExprIntoLValue(const Expr *E, LValue dest, bool isInit);\n\n  /// EmitStoreOfComplex - Store a complex number into the specified l-value.\n  void EmitStoreOfComplex(ComplexPairTy V, LValue dest, bool isInit);\n\n  /// EmitLoadOfComplex - Load a complex number from the specified l-value.\n  ComplexPairTy EmitLoadOfComplex(LValue src, SourceLocation loc);\n\n  Address emitAddrOfRealComponent(Address complex, QualType complexType);\n  Address emitAddrOfImagComponent(Address complex, QualType complexType);\n\n  /// AddInitializerToStaticVarDecl - Add the initializer for 'D' to the\n  /// global variable that has already been created for it.  If the initializer\n  /// has a different type than GV does, this may free GV and return a different\n  /// one.  Otherwise it just returns GV.\n  llvm::GlobalVariable *\n  AddInitializerToStaticVarDecl(const VarDecl &D,\n                                llvm::GlobalVariable *GV);\n\n  // Emit an @llvm.invariant.start call for the given memory region.\n  void EmitInvariantStart(llvm::Constant *Addr, CharUnits Size);\n\n  /// EmitCXXGlobalVarDeclInit - Create the initializer for a C++\n  /// variable with global storage.\n  void EmitCXXGlobalVarDeclInit(const VarDecl &D, llvm::Constant *DeclPtr,\n                                bool PerformInit);\n\n  llvm::Function *createAtExitStub(const VarDecl &VD, llvm::FunctionCallee Dtor,\n                                   llvm::Constant *Addr);\n\n  /// Call atexit() with a function that passes the given argument to\n  /// the given function.\n  void registerGlobalDtorWithAtExit(const VarDecl &D, llvm::FunctionCallee fn,\n                                    llvm::Constant *addr);\n\n  /// Call atexit() with function dtorStub.\n  void registerGlobalDtorWithAtExit(llvm::Constant *dtorStub);\n\n  /// Call unatexit() with function dtorStub.\n  llvm::Value *unregisterGlobalDtorWithUnAtExit(llvm::Constant *dtorStub);\n\n  /// Emit code in this function to perform a guarded variable\n  /// initialization.  Guarded initializations are used when it's not\n  /// possible to prove that an initialization will be done exactly\n  /// once, e.g. with a static local variable or a static data member\n  /// of a class template.\n  void EmitCXXGuardedInit(const VarDecl &D, llvm::GlobalVariable *DeclPtr,\n                          bool PerformInit);\n\n  enum class GuardKind { VariableGuard, TlsGuard };\n\n  /// Emit a branch to select whether or not to perform guarded initialization.\n  void EmitCXXGuardedInitBranch(llvm::Value *NeedsInit,\n                                llvm::BasicBlock *InitBlock,\n                                llvm::BasicBlock *NoInitBlock,\n                                GuardKind Kind, const VarDecl *D);\n\n  /// GenerateCXXGlobalInitFunc - Generates code for initializing global\n  /// variables.\n  void\n  GenerateCXXGlobalInitFunc(llvm::Function *Fn,\n                            ArrayRef<llvm::Function *> CXXThreadLocals,\n                            ConstantAddress Guard = ConstantAddress::invalid());\n\n  /// GenerateCXXGlobalCleanUpFunc - Generates code for cleaning up global\n  /// variables.\n  void GenerateCXXGlobalCleanUpFunc(\n      llvm::Function *Fn,\n      const std::vector<std::tuple<llvm::FunctionType *, llvm::WeakTrackingVH,\n                                   llvm::Constant *>> &DtorsOrStermFinalizers);\n\n  void GenerateCXXGlobalVarDeclInitFunc(llvm::Function *Fn,\n                                        const VarDecl *D,\n                                        llvm::GlobalVariable *Addr,\n                                        bool PerformInit);\n\n  void EmitCXXConstructExpr(const CXXConstructExpr *E, AggValueSlot Dest);\n\n  void EmitSynthesizedCXXCopyCtor(Address Dest, Address Src, const Expr *Exp);\n\n  void EmitCXXThrowExpr(const CXXThrowExpr *E, bool KeepInsertionPoint = true);\n\n  RValue EmitAtomicExpr(AtomicExpr *E);\n\n  //===--------------------------------------------------------------------===//\n  //                         Annotations Emission\n  //===--------------------------------------------------------------------===//\n\n  /// Emit an annotation call (intrinsic).\n  llvm::Value *EmitAnnotationCall(llvm::Function *AnnotationFn,\n                                  llvm::Value *AnnotatedVal,\n                                  StringRef AnnotationStr,\n                                  SourceLocation Location,\n                                  const AnnotateAttr *Attr);\n\n  /// Emit local annotations for the local variable V, declared by D.\n  void EmitVarAnnotations(const VarDecl *D, llvm::Value *V);\n\n  /// Emit field annotations for the given field & value. Returns the\n  /// annotation result.\n  Address EmitFieldAnnotations(const FieldDecl *D, Address V);\n\n  //===--------------------------------------------------------------------===//\n  //                             Internal Helpers\n  //===--------------------------------------------------------------------===//\n\n  /// ContainsLabel - Return true if the statement contains a label in it.  If\n  /// this statement is not executed normally, it not containing a label means\n  /// that we can just remove the code.\n  static bool ContainsLabel(const Stmt *S, bool IgnoreCaseStmts = false);\n\n  /// containsBreak - Return true if the statement contains a break out of it.\n  /// If the statement (recursively) contains a switch or loop with a break\n  /// inside of it, this is fine.\n  static bool containsBreak(const Stmt *S);\n\n  /// Determine if the given statement might introduce a declaration into the\n  /// current scope, by being a (possibly-labelled) DeclStmt.\n  static bool mightAddDeclToScope(const Stmt *S);\n\n  /// ConstantFoldsToSimpleInteger - If the specified expression does not fold\n  /// to a constant, or if it does but contains a label, return false.  If it\n  /// constant folds return true and set the boolean result in Result.\n  bool ConstantFoldsToSimpleInteger(const Expr *Cond, bool &Result,\n                                    bool AllowLabels = false);\n\n  /// ConstantFoldsToSimpleInteger - If the specified expression does not fold\n  /// to a constant, or if it does but contains a label, return false.  If it\n  /// constant folds return true and set the folded value.\n  bool ConstantFoldsToSimpleInteger(const Expr *Cond, llvm::APSInt &Result,\n                                    bool AllowLabels = false);\n\n  /// isInstrumentedCondition - Determine whether the given condition is an\n  /// instrumentable condition (i.e. no \"&&\" or \"||\").\n  static bool isInstrumentedCondition(const Expr *C);\n\n  /// EmitBranchToCounterBlock - Emit a conditional branch to a new block that\n  /// increments a profile counter based on the semantics of the given logical\n  /// operator opcode.  This is used to instrument branch condition coverage\n  /// for logical operators.\n  void EmitBranchToCounterBlock(const Expr *Cond, BinaryOperator::Opcode LOp,\n                                llvm::BasicBlock *TrueBlock,\n                                llvm::BasicBlock *FalseBlock,\n                                uint64_t TrueCount = 0,\n                                Stmt::Likelihood LH = Stmt::LH_None,\n                                const Expr *CntrIdx = nullptr);\n\n  /// EmitBranchOnBoolExpr - Emit a branch on a boolean condition (e.g. for an\n  /// if statement) to the specified blocks.  Based on the condition, this might\n  /// try to simplify the codegen of the conditional based on the branch.\n  /// TrueCount should be the number of times we expect the condition to\n  /// evaluate to true based on PGO data.\n  void EmitBranchOnBoolExpr(const Expr *Cond, llvm::BasicBlock *TrueBlock,\n                            llvm::BasicBlock *FalseBlock, uint64_t TrueCount,\n                            Stmt::Likelihood LH = Stmt::LH_None);\n\n  /// Given an assignment `*LHS = RHS`, emit a test that checks if \\p RHS is\n  /// nonnull, if \\p LHS is marked _Nonnull.\n  void EmitNullabilityCheck(LValue LHS, llvm::Value *RHS, SourceLocation Loc);\n\n  /// An enumeration which makes it easier to specify whether or not an\n  /// operation is a subtraction.\n  enum { NotSubtraction = false, IsSubtraction = true };\n\n  /// Same as IRBuilder::CreateInBoundsGEP, but additionally emits a check to\n  /// detect undefined behavior when the pointer overflow sanitizer is enabled.\n  /// \\p SignedIndices indicates whether any of the GEP indices are signed.\n  /// \\p IsSubtraction indicates whether the expression used to form the GEP\n  /// is a subtraction.\n  llvm::Value *EmitCheckedInBoundsGEP(llvm::Value *Ptr,\n                                      ArrayRef<llvm::Value *> IdxList,\n                                      bool SignedIndices,\n                                      bool IsSubtraction,\n                                      SourceLocation Loc,\n                                      const Twine &Name = \"\");\n\n  /// Specifies which type of sanitizer check to apply when handling a\n  /// particular builtin.\n  enum BuiltinCheckKind {\n    BCK_CTZPassedZero,\n    BCK_CLZPassedZero,\n  };\n\n  /// Emits an argument for a call to a builtin. If the builtin sanitizer is\n  /// enabled, a runtime check specified by \\p Kind is also emitted.\n  llvm::Value *EmitCheckedArgForBuiltin(const Expr *E, BuiltinCheckKind Kind);\n\n  /// Emit a description of a type in a format suitable for passing to\n  /// a runtime sanitizer handler.\n  llvm::Constant *EmitCheckTypeDescriptor(QualType T);\n\n  /// Convert a value into a format suitable for passing to a runtime\n  /// sanitizer handler.\n  llvm::Value *EmitCheckValue(llvm::Value *V);\n\n  /// Emit a description of a source location in a format suitable for\n  /// passing to a runtime sanitizer handler.\n  llvm::Constant *EmitCheckSourceLocation(SourceLocation Loc);\n\n  /// Create a basic block that will either trap or call a handler function in\n  /// the UBSan runtime with the provided arguments, and create a conditional\n  /// branch to it.\n  void EmitCheck(ArrayRef<std::pair<llvm::Value *, SanitizerMask>> Checked,\n                 SanitizerHandler Check, ArrayRef<llvm::Constant *> StaticArgs,\n                 ArrayRef<llvm::Value *> DynamicArgs);\n\n  /// Emit a slow path cross-DSO CFI check which calls __cfi_slowpath\n  /// if Cond if false.\n  void EmitCfiSlowPathCheck(SanitizerMask Kind, llvm::Value *Cond,\n                            llvm::ConstantInt *TypeId, llvm::Value *Ptr,\n                            ArrayRef<llvm::Constant *> StaticArgs);\n\n  /// Emit a reached-unreachable diagnostic if \\p Loc is valid and runtime\n  /// checking is enabled. Otherwise, just emit an unreachable instruction.\n  void EmitUnreachable(SourceLocation Loc);\n\n  /// Create a basic block that will call the trap intrinsic, and emit a\n  /// conditional branch to it, for the -ftrapv checks.\n  void EmitTrapCheck(llvm::Value *Checked, SanitizerHandler CheckHandlerID);\n\n  /// Emit a call to trap or debugtrap and attach function attribute\n  /// \"trap-func-name\" if specified.\n  llvm::CallInst *EmitTrapCall(llvm::Intrinsic::ID IntrID);\n\n  /// Emit a stub for the cross-DSO CFI check function.\n  void EmitCfiCheckStub();\n\n  /// Emit a cross-DSO CFI failure handling function.\n  void EmitCfiCheckFail();\n\n  /// Create a check for a function parameter that may potentially be\n  /// declared as non-null.\n  void EmitNonNullArgCheck(RValue RV, QualType ArgType, SourceLocation ArgLoc,\n                           AbstractCallee AC, unsigned ParmNum);\n\n  /// EmitCallArg - Emit a single call argument.\n  void EmitCallArg(CallArgList &args, const Expr *E, QualType ArgType);\n\n  /// EmitDelegateCallArg - We are performing a delegate call; that\n  /// is, the current function is delegating to another one.  Produce\n  /// a r-value suitable for passing the given parameter.\n  void EmitDelegateCallArg(CallArgList &args, const VarDecl *param,\n                           SourceLocation loc);\n\n  /// SetFPAccuracy - Set the minimum required accuracy of the given floating\n  /// point operation, expressed as the maximum relative error in ulp.\n  void SetFPAccuracy(llvm::Value *Val, float Accuracy);\n\n  /// SetFPModel - Control floating point behavior via fp-model settings.\n  void SetFPModel();\n\n  /// Set the codegen fast-math flags.\n  void SetFastMathFlags(FPOptions FPFeatures);\n\nprivate:\n  llvm::MDNode *getRangeForLoadFromType(QualType Ty);\n  void EmitReturnOfRValue(RValue RV, QualType Ty);\n\n  void deferPlaceholderReplacement(llvm::Instruction *Old, llvm::Value *New);\n\n  llvm::SmallVector<std::pair<llvm::WeakTrackingVH, llvm::Value *>, 4>\n      DeferredReplacements;\n\n  /// Set the address of a local variable.\n  void setAddrOfLocalVar(const VarDecl *VD, Address Addr) {\n    assert(!LocalDeclMap.count(VD) && \"Decl already exists in LocalDeclMap!\");\n    LocalDeclMap.insert({VD, Addr});\n  }\n\n  /// ExpandTypeFromArgs - Reconstruct a structure of type \\arg Ty\n  /// from function arguments into \\arg Dst. See ABIArgInfo::Expand.\n  ///\n  /// \\param AI - The first function argument of the expansion.\n  void ExpandTypeFromArgs(QualType Ty, LValue Dst,\n                          llvm::Function::arg_iterator &AI);\n\n  /// ExpandTypeToArgs - Expand an CallArg \\arg Arg, with the LLVM type for \\arg\n  /// Ty, into individual arguments on the provided vector \\arg IRCallArgs,\n  /// starting at index \\arg IRCallArgPos. See ABIArgInfo::Expand.\n  void ExpandTypeToArgs(QualType Ty, CallArg Arg, llvm::FunctionType *IRFuncTy,\n                        SmallVectorImpl<llvm::Value *> &IRCallArgs,\n                        unsigned &IRCallArgPos);\n\n  llvm::Value* EmitAsmInput(const TargetInfo::ConstraintInfo &Info,\n                            const Expr *InputExpr, std::string &ConstraintStr);\n\n  llvm::Value* EmitAsmInputLValue(const TargetInfo::ConstraintInfo &Info,\n                                  LValue InputValue, QualType InputType,\n                                  std::string &ConstraintStr,\n                                  SourceLocation Loc);\n\n  /// Attempts to statically evaluate the object size of E. If that\n  /// fails, emits code to figure the size of E out for us. This is\n  /// pass_object_size aware.\n  ///\n  /// If EmittedExpr is non-null, this will use that instead of re-emitting E.\n  llvm::Value *evaluateOrEmitBuiltinObjectSize(const Expr *E, unsigned Type,\n                                               llvm::IntegerType *ResType,\n                                               llvm::Value *EmittedE,\n                                               bool IsDynamic);\n\n  /// Emits the size of E, as required by __builtin_object_size. This\n  /// function is aware of pass_object_size parameters, and will act accordingly\n  /// if E is a parameter with the pass_object_size attribute.\n  llvm::Value *emitBuiltinObjectSize(const Expr *E, unsigned Type,\n                                     llvm::IntegerType *ResType,\n                                     llvm::Value *EmittedE,\n                                     bool IsDynamic);\n\n  void emitZeroOrPatternForAutoVarInit(QualType type, const VarDecl &D,\n                                       Address Loc);\n\npublic:\n  enum class EvaluationOrder {\n    ///! No language constraints on evaluation order.\n    Default,\n    ///! Language semantics require left-to-right evaluation.\n    ForceLeftToRight,\n    ///! Language semantics require right-to-left evaluation.\n    ForceRightToLeft\n  };\n\n  // Wrapper for function prototype sources. Wraps either a FunctionProtoType or\n  // an ObjCMethodDecl.\n  struct PrototypeWrapper {\n    llvm::PointerUnion<const FunctionProtoType *, const ObjCMethodDecl *> P;\n\n    PrototypeWrapper(const FunctionProtoType *FT) : P(FT) {}\n    PrototypeWrapper(const ObjCMethodDecl *MD) : P(MD) {}\n  };\n\n  void EmitCallArgs(CallArgList &Args, PrototypeWrapper Prototype,\n                    llvm::iterator_range<CallExpr::const_arg_iterator> ArgRange,\n                    AbstractCallee AC = AbstractCallee(),\n                    unsigned ParamsToSkip = 0,\n                    EvaluationOrder Order = EvaluationOrder::Default);\n\n  /// EmitPointerWithAlignment - Given an expression with a pointer type,\n  /// emit the value and compute our best estimate of the alignment of the\n  /// pointee.\n  ///\n  /// \\param BaseInfo - If non-null, this will be initialized with\n  /// information about the source of the alignment and the may-alias\n  /// attribute.  Note that this function will conservatively fall back on\n  /// the type when it doesn't recognize the expression and may-alias will\n  /// be set to false.\n  ///\n  /// One reasonable way to use this information is when there's a language\n  /// guarantee that the pointer must be aligned to some stricter value, and\n  /// we're simply trying to ensure that sufficiently obvious uses of under-\n  /// aligned objects don't get miscompiled; for example, a placement new\n  /// into the address of a local variable.  In such a case, it's quite\n  /// reasonable to just ignore the returned alignment when it isn't from an\n  /// explicit source.\n  Address EmitPointerWithAlignment(const Expr *Addr,\n                                   LValueBaseInfo *BaseInfo = nullptr,\n                                   TBAAAccessInfo *TBAAInfo = nullptr);\n\n  /// If \\p E references a parameter with pass_object_size info or a constant\n  /// array size modifier, emit the object size divided by the size of \\p EltTy.\n  /// Otherwise return null.\n  llvm::Value *LoadPassedObjectSize(const Expr *E, QualType EltTy);\n\n  void EmitSanitizerStatReport(llvm::SanitizerStatKind SSK);\n\n  struct MultiVersionResolverOption {\n    llvm::Function *Function;\n    FunctionDecl *FD;\n    struct Conds {\n      StringRef Architecture;\n      llvm::SmallVector<StringRef, 8> Features;\n\n      Conds(StringRef Arch, ArrayRef<StringRef> Feats)\n          : Architecture(Arch), Features(Feats.begin(), Feats.end()) {}\n    } Conditions;\n\n    MultiVersionResolverOption(llvm::Function *F, StringRef Arch,\n                               ArrayRef<StringRef> Feats)\n        : Function(F), Conditions(Arch, Feats) {}\n  };\n\n  // Emits the body of a multiversion function's resolver. Assumes that the\n  // options are already sorted in the proper order, with the 'default' option\n  // last (if it exists).\n  void EmitMultiVersionResolver(llvm::Function *Resolver,\n                                ArrayRef<MultiVersionResolverOption> Options);\n\n  static uint64_t GetX86CpuSupportsMask(ArrayRef<StringRef> FeatureStrs);\n\nprivate:\n  QualType getVarArgType(const Expr *Arg);\n\n  void EmitDeclMetadata();\n\n  BlockByrefHelpers *buildByrefHelpers(llvm::StructType &byrefType,\n                                  const AutoVarEmission &emission);\n\n  void AddObjCARCExceptionMetadata(llvm::Instruction *Inst);\n\n  llvm::Value *GetValueForARMHint(unsigned BuiltinID);\n  llvm::Value *EmitX86CpuIs(const CallExpr *E);\n  llvm::Value *EmitX86CpuIs(StringRef CPUStr);\n  llvm::Value *EmitX86CpuSupports(const CallExpr *E);\n  llvm::Value *EmitX86CpuSupports(ArrayRef<StringRef> FeatureStrs);\n  llvm::Value *EmitX86CpuSupports(uint64_t Mask);\n  llvm::Value *EmitX86CpuInit();\n  llvm::Value *FormResolverCondition(const MultiVersionResolverOption &RO);\n};\n\n/// TargetFeatures - This class is used to check whether the builtin function\n/// has the required tagert specific features. It is able to support the\n/// combination of ','(and), '|'(or), and '()'. By default, the priority of\n/// ',' is higher than that of '|' .\n/// E.g:\n/// A,B|C means the builtin function requires both A and B, or C.\n/// If we want the builtin function requires both A and B, or both A and C,\n/// there are two ways: A,B|A,C or A,(B|C).\n/// The FeaturesList should not contain spaces, and brackets must appear in\n/// pairs.\nclass TargetFeatures {\n  struct FeatureListStatus {\n    bool HasFeatures;\n    StringRef CurFeaturesList;\n  };\n\n  const llvm::StringMap<bool> &CallerFeatureMap;\n\n  FeatureListStatus getAndFeatures(StringRef FeatureList) {\n    int InParentheses = 0;\n    bool HasFeatures = true;\n    size_t SubexpressionStart = 0;\n    for (size_t i = 0, e = FeatureList.size(); i < e; ++i) {\n      char CurrentToken = FeatureList[i];\n      switch (CurrentToken) {\n      default:\n        break;\n      case '(':\n        if (InParentheses == 0)\n          SubexpressionStart = i + 1;\n        ++InParentheses;\n        break;\n      case ')':\n        --InParentheses;\n        assert(InParentheses >= 0 && \"Parentheses are not in pair\");\n        LLVM_FALLTHROUGH;\n      case '|':\n      case ',':\n        if (InParentheses == 0) {\n          if (HasFeatures && i != SubexpressionStart) {\n            StringRef F = FeatureList.slice(SubexpressionStart, i);\n            HasFeatures = CurrentToken == ')' ? hasRequiredFeatures(F)\n                                              : CallerFeatureMap.lookup(F);\n          }\n          SubexpressionStart = i + 1;\n          if (CurrentToken == '|') {\n            return {HasFeatures, FeatureList.substr(SubexpressionStart)};\n          }\n        }\n        break;\n      }\n    }\n    assert(InParentheses == 0 && \"Parentheses are not in pair\");\n    if (HasFeatures && SubexpressionStart != FeatureList.size())\n      HasFeatures =\n          CallerFeatureMap.lookup(FeatureList.substr(SubexpressionStart));\n    return {HasFeatures, StringRef()};\n  }\n\npublic:\n  bool hasRequiredFeatures(StringRef FeatureList) {\n    FeatureListStatus FS = {false, FeatureList};\n    while (!FS.HasFeatures && !FS.CurFeaturesList.empty())\n      FS = getAndFeatures(FS.CurFeaturesList);\n    return FS.HasFeatures;\n  }\n\n  TargetFeatures(const llvm::StringMap<bool> &CallerFeatureMap)\n      : CallerFeatureMap(CallerFeatureMap) {}\n};\n\ninline DominatingLLVMValue::saved_type\nDominatingLLVMValue::save(CodeGenFunction &CGF, llvm::Value *value) {\n  if (!needsSaving(value)) return saved_type(value, false);\n\n  // Otherwise, we need an alloca.\n  auto align = CharUnits::fromQuantity(\n            CGF.CGM.getDataLayout().getPrefTypeAlignment(value->getType()));\n  Address alloca =\n    CGF.CreateTempAlloca(value->getType(), align, \"cond-cleanup.save\");\n  CGF.Builder.CreateStore(value, alloca);\n\n  return saved_type(alloca.getPointer(), true);\n}\n\ninline llvm::Value *DominatingLLVMValue::restore(CodeGenFunction &CGF,\n                                                 saved_type value) {\n  // If the value says it wasn't saved, trust that it's still dominating.\n  if (!value.getInt()) return value.getPointer();\n\n  // Otherwise, it should be an alloca instruction, as set up in save().\n  auto alloca = cast<llvm::AllocaInst>(value.getPointer());\n  return CGF.Builder.CreateAlignedLoad(alloca, alloca->getAlign());\n}\n\n}  // end namespace CodeGen\n\n// Map the LangOption for floating point exception behavior into\n// the corresponding enum in the IR.\nllvm::fp::ExceptionBehavior\nToConstrainedExceptMD(LangOptions::FPExceptionModeKind Kind);\n}  // end namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 10, "line": 677}, "message": "'OMPLoopBasedDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "3099f6a4c8efa8c5938173b2e755b234", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 927}, "message": "'OMPLoopDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "67095bc61e07f94ce2fbc52c1258f2b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 96}, "message": "'OMPTaskDataTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "6601c790a0e1b562aea04358acaad14e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 1092}, "message": "'DispatchRTInput' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "18e5eabb155ac625b262d5bdf1de8efb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 1130}, "message": "'StaticRTInput' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h", "reportHash": "58fe1665619e4f8f997cf86986008685", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 41}, "message": "'OMPLexicalScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "reportHash": "19480367f45a924cdb17bc2722f48195", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 104}, "message": "'OMPParallelScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "reportHash": "d750635070c32e6131dc662ae741a8cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 120}, "message": "'OMPTeamsScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "reportHash": "d61b2792a5459609816460d2b44c078e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 135}, "message": "'OMPLoopScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "reportHash": "48e5dbf8aacd52829171120399bf3d3c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 196}, "message": "'OMPSimdLexicalScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "reportHash": "832457a8c814278cf01f7fa92ec8af12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 388}, "message": "'FunctionOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "reportHash": "7ce7ccef89cac163d518099b129b99c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 35, "line": 6317}, "message": "'DevicePointerPrivActionTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp", "reportHash": "ccadf01423f8c00046130e46e2977919", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 36, "line": 3590}, "message": "'OMPLoopArguments' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenFunction.h", "reportHash": "fea1a6db9d9a30081cca8b4723846ba5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
