<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "content": "//===- llvm/ADT/IntervalMap.h - A sorted interval map -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a coalescing interval map for small objects.\n//\n// KeyT objects are mapped to ValT objects. Intervals of keys that map to the\n// same value are represented in a compressed form.\n//\n// Iterators provide ordered access to the compressed intervals rather than the\n// individual keys, and insert and erase operations use key intervals as well.\n//\n// Like SmallVector, IntervalMap will store the first N intervals in the map\n// object itself without any allocations. When space is exhausted it switches to\n// a B+-tree representation with very small overhead for small key and value\n// objects.\n//\n// A Traits class specifies how keys are compared. It also allows IntervalMap to\n// work with both closed and half-open intervals.\n//\n// Keys and values are not stored next to each other in a std::pair, so we don't\n// provide such a value_type. Dereferencing iterators only returns the mapped\n// value. The interval bounds are accessible through the start() and stop()\n// iterator methods.\n//\n// IntervalMap is optimized for small key and value objects, 4 or 8 bytes each\n// is the optimal size. For large objects use std::map instead.\n//\n//===----------------------------------------------------------------------===//\n//\n// Synopsis:\n//\n// template <typename KeyT, typename ValT, unsigned N, typename Traits>\n// class IntervalMap {\n// public:\n//   typedef KeyT key_type;\n//   typedef ValT mapped_type;\n//   typedef RecyclingAllocator<...> Allocator;\n//   class iterator;\n//   class const_iterator;\n//\n//   explicit IntervalMap(Allocator&);\n//   ~IntervalMap():\n//\n//   bool empty() const;\n//   KeyT start() const;\n//   KeyT stop() const;\n//   ValT lookup(KeyT x, Value NotFound = Value()) const;\n//\n//   const_iterator begin() const;\n//   const_iterator end() const;\n//   iterator begin();\n//   iterator end();\n//   const_iterator find(KeyT x) const;\n//   iterator find(KeyT x);\n//\n//   void insert(KeyT a, KeyT b, ValT y);\n//   void clear();\n// };\n//\n// template <typename KeyT, typename ValT, unsigned N, typename Traits>\n// class IntervalMap::const_iterator :\n//   public std::iterator<std::bidirectional_iterator_tag, ValT> {\n// public:\n//   bool operator==(const const_iterator &) const;\n//   bool operator!=(const const_iterator &) const;\n//   bool valid() const;\n//\n//   const KeyT &start() const;\n//   const KeyT &stop() const;\n//   const ValT &value() const;\n//   const ValT &operator*() const;\n//   const ValT *operator->() const;\n//\n//   const_iterator &operator++();\n//   const_iterator &operator++(int);\n//   const_iterator &operator--();\n//   const_iterator &operator--(int);\n//   void goToBegin();\n//   void goToEnd();\n//   void find(KeyT x);\n//   void advanceTo(KeyT x);\n// };\n//\n// template <typename KeyT, typename ValT, unsigned N, typename Traits>\n// class IntervalMap::iterator : public const_iterator {\n// public:\n//   void insert(KeyT a, KeyT b, Value y);\n//   void erase();\n// };\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_INTERVALMAP_H\n#define LLVM_ADT_INTERVALMAP_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/bit.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/RecyclingAllocator.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <new>\n#include <utility>\n\nnamespace llvm {\n\n//===----------------------------------------------------------------------===//\n//---                              Key traits                              ---//\n//===----------------------------------------------------------------------===//\n//\n// The IntervalMap works with closed or half-open intervals.\n// Adjacent intervals that map to the same value are coalesced.\n//\n// The IntervalMapInfo traits class is used to determine if a key is contained\n// in an interval, and if two intervals are adjacent so they can be coalesced.\n// The provided implementation works for closed integer intervals, other keys\n// probably need a specialized version.\n//\n// The point x is contained in [a;b] when !startLess(x, a) && !stopLess(b, x).\n//\n// It is assumed that (a;b] half-open intervals are not used, only [a;b) is\n// allowed. This is so that stopLess(a, b) can be used to determine if two\n// intervals overlap.\n//\n//===----------------------------------------------------------------------===//\n\ntemplate <typename T>\nstruct IntervalMapInfo {\n  /// startLess - Return true if x is not in [a;b].\n  /// This is x < a both for closed intervals and for [a;b) half-open intervals.\n  static inline bool startLess(const T &x, const T &a) {\n    return x < a;\n  }\n\n  /// stopLess - Return true if x is not in [a;b].\n  /// This is b < x for a closed interval, b <= x for [a;b) half-open intervals.\n  static inline bool stopLess(const T &b, const T &x) {\n    return b < x;\n  }\n\n  /// adjacent - Return true when the intervals [x;a] and [b;y] can coalesce.\n  /// This is a+1 == b for closed intervals, a == b for half-open intervals.\n  static inline bool adjacent(const T &a, const T &b) {\n    return a+1 == b;\n  }\n\n  /// nonEmpty - Return true if [a;b] is non-empty.\n  /// This is a <= b for a closed interval, a < b for [a;b) half-open intervals.\n  static inline bool nonEmpty(const T &a, const T &b) {\n    return a <= b;\n  }\n};\n\ntemplate <typename T>\nstruct IntervalMapHalfOpenInfo {\n  /// startLess - Return true if x is not in [a;b).\n  static inline bool startLess(const T &x, const T &a) {\n    return x < a;\n  }\n\n  /// stopLess - Return true if x is not in [a;b).\n  static inline bool stopLess(const T &b, const T &x) {\n    return b <= x;\n  }\n\n  /// adjacent - Return true when the intervals [x;a) and [b;y) can coalesce.\n  static inline bool adjacent(const T &a, const T &b) {\n    return a == b;\n  }\n\n  /// nonEmpty - Return true if [a;b) is non-empty.\n  static inline bool nonEmpty(const T &a, const T &b) {\n    return a < b;\n  }\n};\n\n/// IntervalMapImpl - Namespace used for IntervalMap implementation details.\n/// It should be considered private to the implementation.\nnamespace IntervalMapImpl {\n\nusing IdxPair = std::pair<unsigned,unsigned>;\n\n//===----------------------------------------------------------------------===//\n//---                    IntervalMapImpl::NodeBase                         ---//\n//===----------------------------------------------------------------------===//\n//\n// Both leaf and branch nodes store vectors of pairs.\n// Leaves store ((KeyT, KeyT), ValT) pairs, branches use (NodeRef, KeyT).\n//\n// Keys and values are stored in separate arrays to avoid padding caused by\n// different object alignments. This also helps improve locality of reference\n// when searching the keys.\n//\n// The nodes don't know how many elements they contain - that information is\n// stored elsewhere. Omitting the size field prevents padding and allows a node\n// to fill the allocated cache lines completely.\n//\n// These are typical key and value sizes, the node branching factor (N), and\n// wasted space when nodes are sized to fit in three cache lines (192 bytes):\n//\n//   T1  T2   N Waste  Used by\n//    4   4  24   0    Branch<4> (32-bit pointers)\n//    8   4  16   0    Leaf<4,4>, Branch<4>\n//    8   8  12   0    Leaf<4,8>, Branch<8>\n//   16   4   9  12    Leaf<8,4>\n//   16   8   8   0    Leaf<8,8>\n//\n//===----------------------------------------------------------------------===//\n\ntemplate <typename T1, typename T2, unsigned N>\nclass NodeBase {\npublic:\n  enum { Capacity = N };\n\n  T1 first[N];\n  T2 second[N];\n\n  /// copy - Copy elements from another node.\n  /// @param Other Node elements are copied from.\n  /// @param i     Beginning of the source range in other.\n  /// @param j     Beginning of the destination range in this.\n  /// @param Count Number of elements to copy.\n  template <unsigned M>\n  void copy(const NodeBase<T1, T2, M> &Other, unsigned i,\n            unsigned j, unsigned Count) {\n    assert(i + Count <= M && \"Invalid source range\");\n    assert(j + Count <= N && \"Invalid dest range\");\n    for (unsigned e = i + Count; i != e; ++i, ++j) {\n      first[j]  = Other.first[i];\n      second[j] = Other.second[i];\n    }\n  }\n\n  /// moveLeft - Move elements to the left.\n  /// @param i     Beginning of the source range.\n  /// @param j     Beginning of the destination range.\n  /// @param Count Number of elements to copy.\n  void moveLeft(unsigned i, unsigned j, unsigned Count) {\n    assert(j <= i && \"Use moveRight shift elements right\");\n    copy(*this, i, j, Count);\n  }\n\n  /// moveRight - Move elements to the right.\n  /// @param i     Beginning of the source range.\n  /// @param j     Beginning of the destination range.\n  /// @param Count Number of elements to copy.\n  void moveRight(unsigned i, unsigned j, unsigned Count) {\n    assert(i <= j && \"Use moveLeft shift elements left\");\n    assert(j + Count <= N && \"Invalid range\");\n    while (Count--) {\n      first[j + Count]  = first[i + Count];\n      second[j + Count] = second[i + Count];\n    }\n  }\n\n  /// erase - Erase elements [i;j).\n  /// @param i    Beginning of the range to erase.\n  /// @param j    End of the range. (Exclusive).\n  /// @param Size Number of elements in node.\n  void erase(unsigned i, unsigned j, unsigned Size) {\n    moveLeft(j, i, Size - j);\n  }\n\n  /// erase - Erase element at i.\n  /// @param i    Index of element to erase.\n  /// @param Size Number of elements in node.\n  void erase(unsigned i, unsigned Size) {\n    erase(i, i+1, Size);\n  }\n\n  /// shift - Shift elements [i;size) 1 position to the right.\n  /// @param i    Beginning of the range to move.\n  /// @param Size Number of elements in node.\n  void shift(unsigned i, unsigned Size) {\n    moveRight(i, i + 1, Size - i);\n  }\n\n  /// transferToLeftSib - Transfer elements to a left sibling node.\n  /// @param Size  Number of elements in this.\n  /// @param Sib   Left sibling node.\n  /// @param SSize Number of elements in sib.\n  /// @param Count Number of elements to transfer.\n  void transferToLeftSib(unsigned Size, NodeBase &Sib, unsigned SSize,\n                         unsigned Count) {\n    Sib.copy(*this, 0, SSize, Count);\n    erase(0, Count, Size);\n  }\n\n  /// transferToRightSib - Transfer elements to a right sibling node.\n  /// @param Size  Number of elements in this.\n  /// @param Sib   Right sibling node.\n  /// @param SSize Number of elements in sib.\n  /// @param Count Number of elements to transfer.\n  void transferToRightSib(unsigned Size, NodeBase &Sib, unsigned SSize,\n                          unsigned Count) {\n    Sib.moveRight(0, Count, SSize);\n    Sib.copy(*this, Size-Count, 0, Count);\n  }\n\n  /// adjustFromLeftSib - Adjust the number if elements in this node by moving\n  /// elements to or from a left sibling node.\n  /// @param Size  Number of elements in this.\n  /// @param Sib   Right sibling node.\n  /// @param SSize Number of elements in sib.\n  /// @param Add   The number of elements to add to this node, possibly < 0.\n  /// @return      Number of elements added to this node, possibly negative.\n  int adjustFromLeftSib(unsigned Size, NodeBase &Sib, unsigned SSize, int Add) {\n    if (Add > 0) {\n      // We want to grow, copy from sib.\n      unsigned Count = std::min(std::min(unsigned(Add), SSize), N - Size);\n      Sib.transferToRightSib(SSize, *this, Size, Count);\n      return Count;\n    } else {\n      // We want to shrink, copy to sib.\n      unsigned Count = std::min(std::min(unsigned(-Add), Size), N - SSize);\n      transferToLeftSib(Size, Sib, SSize, Count);\n      return -Count;\n    }\n  }\n};\n\n/// IntervalMapImpl::adjustSiblingSizes - Move elements between sibling nodes.\n/// @param Node  Array of pointers to sibling nodes.\n/// @param Nodes Number of nodes.\n/// @param CurSize Array of current node sizes, will be overwritten.\n/// @param NewSize Array of desired node sizes.\ntemplate <typename NodeT>\nvoid adjustSiblingSizes(NodeT *Node[], unsigned Nodes,\n                        unsigned CurSize[], const unsigned NewSize[]) {\n  // Move elements right.\n  for (int n = Nodes - 1; n; --n) {\n    if (CurSize[n] == NewSize[n])\n      continue;\n    for (int m = n - 1; m != -1; --m) {\n      int d = Node[n]->adjustFromLeftSib(CurSize[n], *Node[m], CurSize[m],\n                                         NewSize[n] - CurSize[n]);\n      CurSize[m] -= d;\n      CurSize[n] += d;\n      // Keep going if the current node was exhausted.\n      if (CurSize[n] >= NewSize[n])\n          break;\n    }\n  }\n\n  if (Nodes == 0)\n    return;\n\n  // Move elements left.\n  for (unsigned n = 0; n != Nodes - 1; ++n) {\n    if (CurSize[n] == NewSize[n])\n      continue;\n    for (unsigned m = n + 1; m != Nodes; ++m) {\n      int d = Node[m]->adjustFromLeftSib(CurSize[m], *Node[n], CurSize[n],\n                                        CurSize[n] -  NewSize[n]);\n      CurSize[m] += d;\n      CurSize[n] -= d;\n      // Keep going if the current node was exhausted.\n      if (CurSize[n] >= NewSize[n])\n          break;\n    }\n  }\n\n#ifndef NDEBUG\n  for (unsigned n = 0; n != Nodes; n++)\n    assert(CurSize[n] == NewSize[n] && \"Insufficient element shuffle\");\n#endif\n}\n\n/// IntervalMapImpl::distribute - Compute a new distribution of node elements\n/// after an overflow or underflow. Reserve space for a new element at Position,\n/// and compute the node that will hold Position after redistributing node\n/// elements.\n///\n/// It is required that\n///\n///   Elements == sum(CurSize), and\n///   Elements + Grow <= Nodes * Capacity.\n///\n/// NewSize[] will be filled in such that:\n///\n///   sum(NewSize) == Elements, and\n///   NewSize[i] <= Capacity.\n///\n/// The returned index is the node where Position will go, so:\n///\n///   sum(NewSize[0..idx-1]) <= Position\n///   sum(NewSize[0..idx])   >= Position\n///\n/// The last equality, sum(NewSize[0..idx]) == Position, can only happen when\n/// Grow is set and NewSize[idx] == Capacity-1. The index points to the node\n/// before the one holding the Position'th element where there is room for an\n/// insertion.\n///\n/// @param Nodes    The number of nodes.\n/// @param Elements Total elements in all nodes.\n/// @param Capacity The capacity of each node.\n/// @param CurSize  Array[Nodes] of current node sizes, or NULL.\n/// @param NewSize  Array[Nodes] to receive the new node sizes.\n/// @param Position Insert position.\n/// @param Grow     Reserve space for a new element at Position.\n/// @return         (node, offset) for Position.\nIdxPair distribute(unsigned Nodes, unsigned Elements, unsigned Capacity,\n                   const unsigned *CurSize, unsigned NewSize[],\n                   unsigned Position, bool Grow);\n\n//===----------------------------------------------------------------------===//\n//---                   IntervalMapImpl::NodeSizer                         ---//\n//===----------------------------------------------------------------------===//\n//\n// Compute node sizes from key and value types.\n//\n// The branching factors are chosen to make nodes fit in three cache lines.\n// This may not be possible if keys or values are very large. Such large objects\n// are handled correctly, but a std::map would probably give better performance.\n//\n//===----------------------------------------------------------------------===//\n\nenum {\n  // Cache line size. Most architectures have 32 or 64 byte cache lines.\n  // We use 64 bytes here because it provides good branching factors.\n  Log2CacheLine = 6,\n  CacheLineBytes = 1 << Log2CacheLine,\n  DesiredNodeBytes = 3 * CacheLineBytes\n};\n\ntemplate <typename KeyT, typename ValT>\nstruct NodeSizer {\n  enum {\n    // Compute the leaf node branching factor that makes a node fit in three\n    // cache lines. The branching factor must be at least 3, or some B+-tree\n    // balancing algorithms won't work.\n    // LeafSize can't be larger than CacheLineBytes. This is required by the\n    // PointerIntPair used by NodeRef.\n    DesiredLeafSize = DesiredNodeBytes /\n      static_cast<unsigned>(2*sizeof(KeyT)+sizeof(ValT)),\n    MinLeafSize = 3,\n    LeafSize = DesiredLeafSize > MinLeafSize ? DesiredLeafSize : MinLeafSize\n  };\n\n  using LeafBase = NodeBase<std::pair<KeyT, KeyT>, ValT, LeafSize>;\n\n  enum {\n    // Now that we have the leaf branching factor, compute the actual allocation\n    // unit size by rounding up to a whole number of cache lines.\n    AllocBytes = (sizeof(LeafBase) + CacheLineBytes-1) & ~(CacheLineBytes-1),\n\n    // Determine the branching factor for branch nodes.\n    BranchSize = AllocBytes /\n      static_cast<unsigned>(sizeof(KeyT) + sizeof(void*))\n  };\n\n  /// Allocator - The recycling allocator used for both branch and leaf nodes.\n  /// This typedef is very likely to be identical for all IntervalMaps with\n  /// reasonably sized entries, so the same allocator can be shared among\n  /// different kinds of maps.\n  using Allocator =\n      RecyclingAllocator<BumpPtrAllocator, char, AllocBytes, CacheLineBytes>;\n};\n\n//===----------------------------------------------------------------------===//\n//---                     IntervalMapImpl::NodeRef                         ---//\n//===----------------------------------------------------------------------===//\n//\n// B+-tree nodes can be leaves or branches, so we need a polymorphic node\n// pointer that can point to both kinds.\n//\n// All nodes are cache line aligned and the low 6 bits of a node pointer are\n// always 0. These bits are used to store the number of elements in the\n// referenced node. Besides saving space, placing node sizes in the parents\n// allow tree balancing algorithms to run without faulting cache lines for nodes\n// that may not need to be modified.\n//\n// A NodeRef doesn't know whether it references a leaf node or a branch node.\n// It is the responsibility of the caller to use the correct types.\n//\n// Nodes are never supposed to be empty, and it is invalid to store a node size\n// of 0 in a NodeRef. The valid range of sizes is 1-64.\n//\n//===----------------------------------------------------------------------===//\n\nclass NodeRef {\n  struct CacheAlignedPointerTraits {\n    static inline void *getAsVoidPointer(void *P) { return P; }\n    static inline void *getFromVoidPointer(void *P) { return P; }\n    static constexpr int NumLowBitsAvailable = Log2CacheLine;\n  };\n  PointerIntPair<void*, Log2CacheLine, unsigned, CacheAlignedPointerTraits> pip;\n\npublic:\n  /// NodeRef - Create a null ref.\n  NodeRef() = default;\n\n  /// operator bool - Detect a null ref.\n  explicit operator bool() const { return pip.getOpaqueValue(); }\n\n  /// NodeRef - Create a reference to the node p with n elements.\n  template <typename NodeT>\n  NodeRef(NodeT *p, unsigned n) : pip(p, n - 1) {\n    assert(n <= NodeT::Capacity && \"Size too big for node\");\n  }\n\n  /// size - Return the number of elements in the referenced node.\n  unsigned size() const { return pip.getInt() + 1; }\n\n  /// setSize - Update the node size.\n  void setSize(unsigned n) { pip.setInt(n - 1); }\n\n  /// subtree - Access the i'th subtree reference in a branch node.\n  /// This depends on branch nodes storing the NodeRef array as their first\n  /// member.\n  NodeRef &subtree(unsigned i) const {\n    return reinterpret_cast<NodeRef*>(pip.getPointer())[i];\n  }\n\n  /// get - Dereference as a NodeT reference.\n  template <typename NodeT>\n  NodeT &get() const {\n    return *reinterpret_cast<NodeT*>(pip.getPointer());\n  }\n\n  bool operator==(const NodeRef &RHS) const {\n    if (pip == RHS.pip)\n      return true;\n    assert(pip.getPointer() != RHS.pip.getPointer() && \"Inconsistent NodeRefs\");\n    return false;\n  }\n\n  bool operator!=(const NodeRef &RHS) const {\n    return !operator==(RHS);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//---                      IntervalMapImpl::LeafNode                       ---//\n//===----------------------------------------------------------------------===//\n//\n// Leaf nodes store up to N disjoint intervals with corresponding values.\n//\n// The intervals are kept sorted and fully coalesced so there are no adjacent\n// intervals mapping to the same value.\n//\n// These constraints are always satisfied:\n//\n// - Traits::stopLess(start(i), stop(i))    - Non-empty, sane intervals.\n//\n// - Traits::stopLess(stop(i), start(i + 1) - Sorted.\n//\n// - value(i) != value(i + 1) || !Traits::adjacent(stop(i), start(i + 1))\n//                                          - Fully coalesced.\n//\n//===----------------------------------------------------------------------===//\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nclass LeafNode : public NodeBase<std::pair<KeyT, KeyT>, ValT, N> {\npublic:\n  const KeyT &start(unsigned i) const { return this->first[i].first; }\n  const KeyT &stop(unsigned i) const { return this->first[i].second; }\n  const ValT &value(unsigned i) const { return this->second[i]; }\n\n  KeyT &start(unsigned i) { return this->first[i].first; }\n  KeyT &stop(unsigned i) { return this->first[i].second; }\n  ValT &value(unsigned i) { return this->second[i]; }\n\n  /// findFrom - Find the first interval after i that may contain x.\n  /// @param i    Starting index for the search.\n  /// @param Size Number of elements in node.\n  /// @param x    Key to search for.\n  /// @return     First index with !stopLess(key[i].stop, x), or size.\n  ///             This is the first interval that can possibly contain x.\n  unsigned findFrom(unsigned i, unsigned Size, KeyT x) const {\n    assert(i <= Size && Size <= N && \"Bad indices\");\n    assert((i == 0 || Traits::stopLess(stop(i - 1), x)) &&\n           \"Index is past the needed point\");\n    while (i != Size && Traits::stopLess(stop(i), x)) ++i;\n    return i;\n  }\n\n  /// safeFind - Find an interval that is known to exist. This is the same as\n  /// findFrom except is it assumed that x is at least within range of the last\n  /// interval.\n  /// @param i Starting index for the search.\n  /// @param x Key to search for.\n  /// @return  First index with !stopLess(key[i].stop, x), never size.\n  ///          This is the first interval that can possibly contain x.\n  unsigned safeFind(unsigned i, KeyT x) const {\n    assert(i < N && \"Bad index\");\n    assert((i == 0 || Traits::stopLess(stop(i - 1), x)) &&\n           \"Index is past the needed point\");\n    while (Traits::stopLess(stop(i), x)) ++i;\n    assert(i < N && \"Unsafe intervals\");\n    return i;\n  }\n\n  /// safeLookup - Lookup mapped value for a safe key.\n  /// It is assumed that x is within range of the last entry.\n  /// @param x        Key to search for.\n  /// @param NotFound Value to return if x is not in any interval.\n  /// @return         The mapped value at x or NotFound.\n  ValT safeLookup(KeyT x, ValT NotFound) const {\n    unsigned i = safeFind(0, x);\n    return Traits::startLess(x, start(i)) ? NotFound : value(i);\n  }\n\n  unsigned insertFrom(unsigned &Pos, unsigned Size, KeyT a, KeyT b, ValT y);\n};\n\n/// insertFrom - Add mapping of [a;b] to y if possible, coalescing as much as\n/// possible. This may cause the node to grow by 1, or it may cause the node\n/// to shrink because of coalescing.\n/// @param Pos  Starting index = insertFrom(0, size, a)\n/// @param Size Number of elements in node.\n/// @param a    Interval start.\n/// @param b    Interval stop.\n/// @param y    Value be mapped.\n/// @return     (insert position, new size), or (i, Capacity+1) on overflow.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nunsigned LeafNode<KeyT, ValT, N, Traits>::\ninsertFrom(unsigned &Pos, unsigned Size, KeyT a, KeyT b, ValT y) {\n  unsigned i = Pos;\n  assert(i <= Size && Size <= N && \"Invalid index\");\n  assert(!Traits::stopLess(b, a) && \"Invalid interval\");\n\n  // Verify the findFrom invariant.\n  assert((i == 0 || Traits::stopLess(stop(i - 1), a)));\n  assert((i == Size || !Traits::stopLess(stop(i), a)));\n  assert((i == Size || Traits::stopLess(b, start(i))) && \"Overlapping insert\");\n\n  // Coalesce with previous interval.\n  if (i && value(i - 1) == y && Traits::adjacent(stop(i - 1), a)) {\n    Pos = i - 1;\n    // Also coalesce with next interval?\n    if (i != Size && value(i) == y && Traits::adjacent(b, start(i))) {\n      stop(i - 1) = stop(i);\n      this->erase(i, Size);\n      return Size - 1;\n    }\n    stop(i - 1) = b;\n    return Size;\n  }\n\n  // Detect overflow.\n  if (i == N)\n    return N + 1;\n\n  // Add new interval at end.\n  if (i == Size) {\n    start(i) = a;\n    stop(i) = b;\n    value(i) = y;\n    return Size + 1;\n  }\n\n  // Try to coalesce with following interval.\n  if (value(i) == y && Traits::adjacent(b, start(i))) {\n    start(i) = a;\n    return Size;\n  }\n\n  // We must insert before i. Detect overflow.\n  if (Size == N)\n    return N + 1;\n\n  // Insert before i.\n  this->shift(i, Size);\n  start(i) = a;\n  stop(i) = b;\n  value(i) = y;\n  return Size + 1;\n}\n\n//===----------------------------------------------------------------------===//\n//---                   IntervalMapImpl::BranchNode                        ---//\n//===----------------------------------------------------------------------===//\n//\n// A branch node stores references to 1--N subtrees all of the same height.\n//\n// The key array in a branch node holds the rightmost stop key of each subtree.\n// It is redundant to store the last stop key since it can be found in the\n// parent node, but doing so makes tree balancing a lot simpler.\n//\n// It is unusual for a branch node to only have one subtree, but it can happen\n// in the root node if it is smaller than the normal nodes.\n//\n// When all of the leaf nodes from all the subtrees are concatenated, they must\n// satisfy the same constraints as a single leaf node. They must be sorted,\n// sane, and fully coalesced.\n//\n//===----------------------------------------------------------------------===//\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nclass BranchNode : public NodeBase<NodeRef, KeyT, N> {\npublic:\n  const KeyT &stop(unsigned i) const { return this->second[i]; }\n  const NodeRef &subtree(unsigned i) const { return this->first[i]; }\n\n  KeyT &stop(unsigned i) { return this->second[i]; }\n  NodeRef &subtree(unsigned i) { return this->first[i]; }\n\n  /// findFrom - Find the first subtree after i that may contain x.\n  /// @param i    Starting index for the search.\n  /// @param Size Number of elements in node.\n  /// @param x    Key to search for.\n  /// @return     First index with !stopLess(key[i], x), or size.\n  ///             This is the first subtree that can possibly contain x.\n  unsigned findFrom(unsigned i, unsigned Size, KeyT x) const {\n    assert(i <= Size && Size <= N && \"Bad indices\");\n    assert((i == 0 || Traits::stopLess(stop(i - 1), x)) &&\n           \"Index to findFrom is past the needed point\");\n    while (i != Size && Traits::stopLess(stop(i), x)) ++i;\n    return i;\n  }\n\n  /// safeFind - Find a subtree that is known to exist. This is the same as\n  /// findFrom except is it assumed that x is in range.\n  /// @param i Starting index for the search.\n  /// @param x Key to search for.\n  /// @return  First index with !stopLess(key[i], x), never size.\n  ///          This is the first subtree that can possibly contain x.\n  unsigned safeFind(unsigned i, KeyT x) const {\n    assert(i < N && \"Bad index\");\n    assert((i == 0 || Traits::stopLess(stop(i - 1), x)) &&\n           \"Index is past the needed point\");\n    while (Traits::stopLess(stop(i), x)) ++i;\n    assert(i < N && \"Unsafe intervals\");\n    return i;\n  }\n\n  /// safeLookup - Get the subtree containing x, Assuming that x is in range.\n  /// @param x Key to search for.\n  /// @return  Subtree containing x\n  NodeRef safeLookup(KeyT x) const {\n    return subtree(safeFind(0, x));\n  }\n\n  /// insert - Insert a new (subtree, stop) pair.\n  /// @param i    Insert position, following entries will be shifted.\n  /// @param Size Number of elements in node.\n  /// @param Node Subtree to insert.\n  /// @param Stop Last key in subtree.\n  void insert(unsigned i, unsigned Size, NodeRef Node, KeyT Stop) {\n    assert(Size < N && \"branch node overflow\");\n    assert(i <= Size && \"Bad insert position\");\n    this->shift(i, Size);\n    subtree(i) = Node;\n    stop(i) = Stop;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//---                         IntervalMapImpl::Path                        ---//\n//===----------------------------------------------------------------------===//\n//\n// A Path is used by iterators to represent a position in a B+-tree, and the\n// path to get there from the root.\n//\n// The Path class also contains the tree navigation code that doesn't have to\n// be templatized.\n//\n//===----------------------------------------------------------------------===//\n\nclass Path {\n  /// Entry - Each step in the path is a node pointer and an offset into that\n  /// node.\n  struct Entry {\n    void *node;\n    unsigned size;\n    unsigned offset;\n\n    Entry(void *Node, unsigned Size, unsigned Offset)\n      : node(Node), size(Size), offset(Offset) {}\n\n    Entry(NodeRef Node, unsigned Offset)\n      : node(&Node.subtree(0)), size(Node.size()), offset(Offset) {}\n\n    NodeRef &subtree(unsigned i) const {\n      return reinterpret_cast<NodeRef*>(node)[i];\n    }\n  };\n\n  /// path - The path entries, path[0] is the root node, path.back() is a leaf.\n  SmallVector<Entry, 4> path;\n\npublic:\n  // Node accessors.\n  template <typename NodeT> NodeT &node(unsigned Level) const {\n    return *reinterpret_cast<NodeT*>(path[Level].node);\n  }\n  unsigned size(unsigned Level) const { return path[Level].size; }\n  unsigned offset(unsigned Level) const { return path[Level].offset; }\n  unsigned &offset(unsigned Level) { return path[Level].offset; }\n\n  // Leaf accessors.\n  template <typename NodeT> NodeT &leaf() const {\n    return *reinterpret_cast<NodeT*>(path.back().node);\n  }\n  unsigned leafSize() const { return path.back().size; }\n  unsigned leafOffset() const { return path.back().offset; }\n  unsigned &leafOffset() { return path.back().offset; }\n\n  /// valid - Return true if path is at a valid node, not at end().\n  bool valid() const {\n    return !path.empty() && path.front().offset < path.front().size;\n  }\n\n  /// height - Return the height of the tree corresponding to this path.\n  /// This matches map->height in a full path.\n  unsigned height() const { return path.size() - 1; }\n\n  /// subtree - Get the subtree referenced from Level. When the path is\n  /// consistent, node(Level + 1) == subtree(Level).\n  /// @param Level 0..height-1. The leaves have no subtrees.\n  NodeRef &subtree(unsigned Level) const {\n    return path[Level].subtree(path[Level].offset);\n  }\n\n  /// reset - Reset cached information about node(Level) from subtree(Level -1).\n  /// @param Level 1..height. The node to update after parent node changed.\n  void reset(unsigned Level) {\n    path[Level] = Entry(subtree(Level - 1), offset(Level));\n  }\n\n  /// push - Add entry to path.\n  /// @param Node Node to add, should be subtree(path.size()-1).\n  /// @param Offset Offset into Node.\n  void push(NodeRef Node, unsigned Offset) {\n    path.push_back(Entry(Node, Offset));\n  }\n\n  /// pop - Remove the last path entry.\n  void pop() {\n    path.pop_back();\n  }\n\n  /// setSize - Set the size of a node both in the path and in the tree.\n  /// @param Level 0..height. Note that setting the root size won't change\n  ///              map->rootSize.\n  /// @param Size New node size.\n  void setSize(unsigned Level, unsigned Size) {\n    path[Level].size = Size;\n    if (Level)\n      subtree(Level - 1).setSize(Size);\n  }\n\n  /// setRoot - Clear the path and set a new root node.\n  /// @param Node New root node.\n  /// @param Size New root size.\n  /// @param Offset Offset into root node.\n  void setRoot(void *Node, unsigned Size, unsigned Offset) {\n    path.clear();\n    path.push_back(Entry(Node, Size, Offset));\n  }\n\n  /// replaceRoot - Replace the current root node with two new entries after the\n  /// tree height has increased.\n  /// @param Root The new root node.\n  /// @param Size Number of entries in the new root.\n  /// @param Offsets Offsets into the root and first branch nodes.\n  void replaceRoot(void *Root, unsigned Size, IdxPair Offsets);\n\n  /// getLeftSibling - Get the left sibling node at Level, or a null NodeRef.\n  /// @param Level Get the sibling to node(Level).\n  /// @return Left sibling, or NodeRef().\n  NodeRef getLeftSibling(unsigned Level) const;\n\n  /// moveLeft - Move path to the left sibling at Level. Leave nodes below Level\n  /// unaltered.\n  /// @param Level Move node(Level).\n  void moveLeft(unsigned Level);\n\n  /// fillLeft - Grow path to Height by taking leftmost branches.\n  /// @param Height The target height.\n  void fillLeft(unsigned Height) {\n    while (height() < Height)\n      push(subtree(height()), 0);\n  }\n\n  /// getLeftSibling - Get the left sibling node at Level, or a null NodeRef.\n  /// @param Level Get the sibling to node(Level).\n  /// @return Left sibling, or NodeRef().\n  NodeRef getRightSibling(unsigned Level) const;\n\n  /// moveRight - Move path to the left sibling at Level. Leave nodes below\n  /// Level unaltered.\n  /// @param Level Move node(Level).\n  void moveRight(unsigned Level);\n\n  /// atBegin - Return true if path is at begin().\n  bool atBegin() const {\n    for (unsigned i = 0, e = path.size(); i != e; ++i)\n      if (path[i].offset != 0)\n        return false;\n    return true;\n  }\n\n  /// atLastEntry - Return true if the path is at the last entry of the node at\n  /// Level.\n  /// @param Level Node to examine.\n  bool atLastEntry(unsigned Level) const {\n    return path[Level].offset == path[Level].size - 1;\n  }\n\n  /// legalizeForInsert - Prepare the path for an insertion at Level. When the\n  /// path is at end(), node(Level) may not be a legal node. legalizeForInsert\n  /// ensures that node(Level) is real by moving back to the last node at Level,\n  /// and setting offset(Level) to size(Level) if required.\n  /// @param Level The level where an insertion is about to take place.\n  void legalizeForInsert(unsigned Level) {\n    if (valid())\n      return;\n    moveLeft(Level);\n    ++path[Level].offset;\n  }\n};\n\n} // end namespace IntervalMapImpl\n\n//===----------------------------------------------------------------------===//\n//---                          IntervalMap                                ----//\n//===----------------------------------------------------------------------===//\n\ntemplate <typename KeyT, typename ValT,\n          unsigned N = IntervalMapImpl::NodeSizer<KeyT, ValT>::LeafSize,\n          typename Traits = IntervalMapInfo<KeyT>>\nclass IntervalMap {\n  using Sizer = IntervalMapImpl::NodeSizer<KeyT, ValT>;\n  using Leaf = IntervalMapImpl::LeafNode<KeyT, ValT, Sizer::LeafSize, Traits>;\n  using Branch =\n      IntervalMapImpl::BranchNode<KeyT, ValT, Sizer::BranchSize, Traits>;\n  using RootLeaf = IntervalMapImpl::LeafNode<KeyT, ValT, N, Traits>;\n  using IdxPair = IntervalMapImpl::IdxPair;\n\n  // The RootLeaf capacity is given as a template parameter. We must compute the\n  // corresponding RootBranch capacity.\n  enum {\n    DesiredRootBranchCap = (sizeof(RootLeaf) - sizeof(KeyT)) /\n      (sizeof(KeyT) + sizeof(IntervalMapImpl::NodeRef)),\n    RootBranchCap = DesiredRootBranchCap ? DesiredRootBranchCap : 1\n  };\n\n  using RootBranch =\n      IntervalMapImpl::BranchNode<KeyT, ValT, RootBranchCap, Traits>;\n\n  // When branched, we store a global start key as well as the branch node.\n  struct RootBranchData {\n    KeyT start;\n    RootBranch node;\n  };\n\npublic:\n  using Allocator = typename Sizer::Allocator;\n  using KeyType = KeyT;\n  using ValueType = ValT;\n  using KeyTraits = Traits;\n\nprivate:\n  // The root data is either a RootLeaf or a RootBranchData instance.\n  AlignedCharArrayUnion<RootLeaf, RootBranchData> data;\n\n  // Tree height.\n  // 0: Leaves in root.\n  // 1: Root points to leaf.\n  // 2: root->branch->leaf ...\n  unsigned height;\n\n  // Number of entries in the root node.\n  unsigned rootSize;\n\n  // Allocator used for creating external nodes.\n  Allocator &allocator;\n\n  /// Represent data as a node type without breaking aliasing rules.\n  template <typename T> T &dataAs() const { return *bit_cast<T *>(&data); }\n\n  const RootLeaf &rootLeaf() const {\n    assert(!branched() && \"Cannot acces leaf data in branched root\");\n    return dataAs<RootLeaf>();\n  }\n  RootLeaf &rootLeaf() {\n    assert(!branched() && \"Cannot acces leaf data in branched root\");\n    return dataAs<RootLeaf>();\n  }\n\n  RootBranchData &rootBranchData() const {\n    assert(branched() && \"Cannot access branch data in non-branched root\");\n    return dataAs<RootBranchData>();\n  }\n  RootBranchData &rootBranchData() {\n    assert(branched() && \"Cannot access branch data in non-branched root\");\n    return dataAs<RootBranchData>();\n  }\n\n  const RootBranch &rootBranch() const { return rootBranchData().node; }\n  RootBranch &rootBranch()             { return rootBranchData().node; }\n  KeyT rootBranchStart() const { return rootBranchData().start; }\n  KeyT &rootBranchStart()      { return rootBranchData().start; }\n\n  template <typename NodeT> NodeT *newNode() {\n    return new(allocator.template Allocate<NodeT>()) NodeT();\n  }\n\n  template <typename NodeT> void deleteNode(NodeT *P) {\n    P->~NodeT();\n    allocator.Deallocate(P);\n  }\n\n  IdxPair branchRoot(unsigned Position);\n  IdxPair splitRoot(unsigned Position);\n\n  void switchRootToBranch() {\n    rootLeaf().~RootLeaf();\n    height = 1;\n    new (&rootBranchData()) RootBranchData();\n  }\n\n  void switchRootToLeaf() {\n    rootBranchData().~RootBranchData();\n    height = 0;\n    new(&rootLeaf()) RootLeaf();\n  }\n\n  bool branched() const { return height > 0; }\n\n  ValT treeSafeLookup(KeyT x, ValT NotFound) const;\n  void visitNodes(void (IntervalMap::*f)(IntervalMapImpl::NodeRef,\n                  unsigned Level));\n  void deleteNode(IntervalMapImpl::NodeRef Node, unsigned Level);\n\npublic:\n  explicit IntervalMap(Allocator &a) : height(0), rootSize(0), allocator(a) {\n    assert((uintptr_t(&data) & (alignof(RootLeaf) - 1)) == 0 &&\n           \"Insufficient alignment\");\n    new(&rootLeaf()) RootLeaf();\n  }\n\n  ~IntervalMap() {\n    clear();\n    rootLeaf().~RootLeaf();\n  }\n\n  /// empty -  Return true when no intervals are mapped.\n  bool empty() const {\n    return rootSize == 0;\n  }\n\n  /// start - Return the smallest mapped key in a non-empty map.\n  KeyT start() const {\n    assert(!empty() && \"Empty IntervalMap has no start\");\n    return !branched() ? rootLeaf().start(0) : rootBranchStart();\n  }\n\n  /// stop - Return the largest mapped key in a non-empty map.\n  KeyT stop() const {\n    assert(!empty() && \"Empty IntervalMap has no stop\");\n    return !branched() ? rootLeaf().stop(rootSize - 1) :\n                         rootBranch().stop(rootSize - 1);\n  }\n\n  /// lookup - Return the mapped value at x or NotFound.\n  ValT lookup(KeyT x, ValT NotFound = ValT()) const {\n    if (empty() || Traits::startLess(x, start()) || Traits::stopLess(stop(), x))\n      return NotFound;\n    return branched() ? treeSafeLookup(x, NotFound) :\n                        rootLeaf().safeLookup(x, NotFound);\n  }\n\n  /// insert - Add a mapping of [a;b] to y, coalesce with adjacent intervals.\n  /// It is assumed that no key in the interval is mapped to another value, but\n  /// overlapping intervals already mapped to y will be coalesced.\n  void insert(KeyT a, KeyT b, ValT y) {\n    if (branched() || rootSize == RootLeaf::Capacity)\n      return find(a).insert(a, b, y);\n\n    // Easy insert into root leaf.\n    unsigned p = rootLeaf().findFrom(0, rootSize, a);\n    rootSize = rootLeaf().insertFrom(p, rootSize, a, b, y);\n  }\n\n  /// clear - Remove all entries.\n  void clear();\n\n  class const_iterator;\n  class iterator;\n  friend class const_iterator;\n  friend class iterator;\n\n  const_iterator begin() const {\n    const_iterator I(*this);\n    I.goToBegin();\n    return I;\n  }\n\n  iterator begin() {\n    iterator I(*this);\n    I.goToBegin();\n    return I;\n  }\n\n  const_iterator end() const {\n    const_iterator I(*this);\n    I.goToEnd();\n    return I;\n  }\n\n  iterator end() {\n    iterator I(*this);\n    I.goToEnd();\n    return I;\n  }\n\n  /// find - Return an iterator pointing to the first interval ending at or\n  /// after x, or end().\n  const_iterator find(KeyT x) const {\n    const_iterator I(*this);\n    I.find(x);\n    return I;\n  }\n\n  iterator find(KeyT x) {\n    iterator I(*this);\n    I.find(x);\n    return I;\n  }\n\n  /// overlaps(a, b) - Return true if the intervals in this map overlap with the\n  /// interval [a;b].\n  bool overlaps(KeyT a, KeyT b) {\n    assert(Traits::nonEmpty(a, b));\n    const_iterator I = find(a);\n    if (!I.valid())\n      return false;\n    // [a;b] and [x;y] overlap iff x<=b and a<=y. The find() call guarantees the\n    // second part (y = find(a).stop()), so it is sufficient to check the first\n    // one.\n    return !Traits::stopLess(b, I.start());\n  }\n};\n\n/// treeSafeLookup - Return the mapped value at x or NotFound, assuming a\n/// branched root.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nValT IntervalMap<KeyT, ValT, N, Traits>::\ntreeSafeLookup(KeyT x, ValT NotFound) const {\n  assert(branched() && \"treeLookup assumes a branched root\");\n\n  IntervalMapImpl::NodeRef NR = rootBranch().safeLookup(x);\n  for (unsigned h = height-1; h; --h)\n    NR = NR.get<Branch>().safeLookup(x);\n  return NR.get<Leaf>().safeLookup(x, NotFound);\n}\n\n// branchRoot - Switch from a leaf root to a branched root.\n// Return the new (root offset, node offset) corresponding to Position.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nIntervalMapImpl::IdxPair IntervalMap<KeyT, ValT, N, Traits>::\nbranchRoot(unsigned Position) {\n  using namespace IntervalMapImpl;\n  // How many external leaf nodes to hold RootLeaf+1?\n  const unsigned Nodes = RootLeaf::Capacity / Leaf::Capacity + 1;\n\n  // Compute element distribution among new nodes.\n  unsigned size[Nodes];\n  IdxPair NewOffset(0, Position);\n\n  // Is is very common for the root node to be smaller than external nodes.\n  if (Nodes == 1)\n    size[0] = rootSize;\n  else\n    NewOffset = distribute(Nodes, rootSize, Leaf::Capacity,  nullptr, size,\n                           Position, true);\n\n  // Allocate new nodes.\n  unsigned pos = 0;\n  NodeRef node[Nodes];\n  for (unsigned n = 0; n != Nodes; ++n) {\n    Leaf *L = newNode<Leaf>();\n    L->copy(rootLeaf(), pos, 0, size[n]);\n    node[n] = NodeRef(L, size[n]);\n    pos += size[n];\n  }\n\n  // Destroy the old leaf node, construct branch node instead.\n  switchRootToBranch();\n  for (unsigned n = 0; n != Nodes; ++n) {\n    rootBranch().stop(n) = node[n].template get<Leaf>().stop(size[n]-1);\n    rootBranch().subtree(n) = node[n];\n  }\n  rootBranchStart() = node[0].template get<Leaf>().start(0);\n  rootSize = Nodes;\n  return NewOffset;\n}\n\n// splitRoot - Split the current BranchRoot into multiple Branch nodes.\n// Return the new (root offset, node offset) corresponding to Position.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nIntervalMapImpl::IdxPair IntervalMap<KeyT, ValT, N, Traits>::\nsplitRoot(unsigned Position) {\n  using namespace IntervalMapImpl;\n  // How many external leaf nodes to hold RootBranch+1?\n  const unsigned Nodes = RootBranch::Capacity / Branch::Capacity + 1;\n\n  // Compute element distribution among new nodes.\n  unsigned Size[Nodes];\n  IdxPair NewOffset(0, Position);\n\n  // Is is very common for the root node to be smaller than external nodes.\n  if (Nodes == 1)\n    Size[0] = rootSize;\n  else\n    NewOffset = distribute(Nodes, rootSize, Leaf::Capacity,  nullptr, Size,\n                           Position, true);\n\n  // Allocate new nodes.\n  unsigned Pos = 0;\n  NodeRef Node[Nodes];\n  for (unsigned n = 0; n != Nodes; ++n) {\n    Branch *B = newNode<Branch>();\n    B->copy(rootBranch(), Pos, 0, Size[n]);\n    Node[n] = NodeRef(B, Size[n]);\n    Pos += Size[n];\n  }\n\n  for (unsigned n = 0; n != Nodes; ++n) {\n    rootBranch().stop(n) = Node[n].template get<Branch>().stop(Size[n]-1);\n    rootBranch().subtree(n) = Node[n];\n  }\n  rootSize = Nodes;\n  ++height;\n  return NewOffset;\n}\n\n/// visitNodes - Visit each external node.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\nvisitNodes(void (IntervalMap::*f)(IntervalMapImpl::NodeRef, unsigned Height)) {\n  if (!branched())\n    return;\n  SmallVector<IntervalMapImpl::NodeRef, 4> Refs, NextRefs;\n\n  // Collect level 0 nodes from the root.\n  for (unsigned i = 0; i != rootSize; ++i)\n    Refs.push_back(rootBranch().subtree(i));\n\n  // Visit all branch nodes.\n  for (unsigned h = height - 1; h; --h) {\n    for (unsigned i = 0, e = Refs.size(); i != e; ++i) {\n      for (unsigned j = 0, s = Refs[i].size(); j != s; ++j)\n        NextRefs.push_back(Refs[i].subtree(j));\n      (this->*f)(Refs[i], h);\n    }\n    Refs.clear();\n    Refs.swap(NextRefs);\n  }\n\n  // Visit all leaf nodes.\n  for (unsigned i = 0, e = Refs.size(); i != e; ++i)\n    (this->*f)(Refs[i], 0);\n}\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\ndeleteNode(IntervalMapImpl::NodeRef Node, unsigned Level) {\n  if (Level)\n    deleteNode(&Node.get<Branch>());\n  else\n    deleteNode(&Node.get<Leaf>());\n}\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\nclear() {\n  if (branched()) {\n    visitNodes(&IntervalMap::deleteNode);\n    switchRootToLeaf();\n  }\n  rootSize = 0;\n}\n\n//===----------------------------------------------------------------------===//\n//---                   IntervalMap::const_iterator                       ----//\n//===----------------------------------------------------------------------===//\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nclass IntervalMap<KeyT, ValT, N, Traits>::const_iterator :\n  public std::iterator<std::bidirectional_iterator_tag, ValT> {\n\nprotected:\n  friend class IntervalMap;\n\n  // The map referred to.\n  IntervalMap *map = nullptr;\n\n  // We store a full path from the root to the current position.\n  // The path may be partially filled, but never between iterator calls.\n  IntervalMapImpl::Path path;\n\n  explicit const_iterator(const IntervalMap &map) :\n    map(const_cast<IntervalMap*>(&map)) {}\n\n  bool branched() const {\n    assert(map && \"Invalid iterator\");\n    return map->branched();\n  }\n\n  void setRoot(unsigned Offset) {\n    if (branched())\n      path.setRoot(&map->rootBranch(), map->rootSize, Offset);\n    else\n      path.setRoot(&map->rootLeaf(), map->rootSize, Offset);\n  }\n\n  void pathFillFind(KeyT x);\n  void treeFind(KeyT x);\n  void treeAdvanceTo(KeyT x);\n\n  /// unsafeStart - Writable access to start() for iterator.\n  KeyT &unsafeStart() const {\n    assert(valid() && \"Cannot access invalid iterator\");\n    return branched() ? path.leaf<Leaf>().start(path.leafOffset()) :\n                        path.leaf<RootLeaf>().start(path.leafOffset());\n  }\n\n  /// unsafeStop - Writable access to stop() for iterator.\n  KeyT &unsafeStop() const {\n    assert(valid() && \"Cannot access invalid iterator\");\n    return branched() ? path.leaf<Leaf>().stop(path.leafOffset()) :\n                        path.leaf<RootLeaf>().stop(path.leafOffset());\n  }\n\n  /// unsafeValue - Writable access to value() for iterator.\n  ValT &unsafeValue() const {\n    assert(valid() && \"Cannot access invalid iterator\");\n    return branched() ? path.leaf<Leaf>().value(path.leafOffset()) :\n                        path.leaf<RootLeaf>().value(path.leafOffset());\n  }\n\npublic:\n  /// const_iterator - Create an iterator that isn't pointing anywhere.\n  const_iterator() = default;\n\n  /// setMap - Change the map iterated over. This call must be followed by a\n  /// call to goToBegin(), goToEnd(), or find()\n  void setMap(const IntervalMap &m) { map = const_cast<IntervalMap*>(&m); }\n\n  /// valid - Return true if the current position is valid, false for end().\n  bool valid() const { return path.valid(); }\n\n  /// atBegin - Return true if the current position is the first map entry.\n  bool atBegin() const { return path.atBegin(); }\n\n  /// start - Return the beginning of the current interval.\n  const KeyT &start() const { return unsafeStart(); }\n\n  /// stop - Return the end of the current interval.\n  const KeyT &stop() const { return unsafeStop(); }\n\n  /// value - Return the mapped value at the current interval.\n  const ValT &value() const { return unsafeValue(); }\n\n  const ValT &operator*() const { return value(); }\n\n  bool operator==(const const_iterator &RHS) const {\n    assert(map == RHS.map && \"Cannot compare iterators from different maps\");\n    if (!valid())\n      return !RHS.valid();\n    if (path.leafOffset() != RHS.path.leafOffset())\n      return false;\n    return &path.template leaf<Leaf>() == &RHS.path.template leaf<Leaf>();\n  }\n\n  bool operator!=(const const_iterator &RHS) const {\n    return !operator==(RHS);\n  }\n\n  /// goToBegin - Move to the first interval in map.\n  void goToBegin() {\n    setRoot(0);\n    if (branched())\n      path.fillLeft(map->height);\n  }\n\n  /// goToEnd - Move beyond the last interval in map.\n  void goToEnd() {\n    setRoot(map->rootSize);\n  }\n\n  /// preincrement - Move to the next interval.\n  const_iterator &operator++() {\n    assert(valid() && \"Cannot increment end()\");\n    if (++path.leafOffset() == path.leafSize() && branched())\n      path.moveRight(map->height);\n    return *this;\n  }\n\n  /// postincrement - Don't do that!\n  const_iterator operator++(int) {\n    const_iterator tmp = *this;\n    operator++();\n    return tmp;\n  }\n\n  /// predecrement - Move to the previous interval.\n  const_iterator &operator--() {\n    if (path.leafOffset() && (valid() || !branched()))\n      --path.leafOffset();\n    else\n      path.moveLeft(map->height);\n    return *this;\n  }\n\n  /// postdecrement - Don't do that!\n  const_iterator operator--(int) {\n    const_iterator tmp = *this;\n    operator--();\n    return tmp;\n  }\n\n  /// find - Move to the first interval with stop >= x, or end().\n  /// This is a full search from the root, the current position is ignored.\n  void find(KeyT x) {\n    if (branched())\n      treeFind(x);\n    else\n      setRoot(map->rootLeaf().findFrom(0, map->rootSize, x));\n  }\n\n  /// advanceTo - Move to the first interval with stop >= x, or end().\n  /// The search is started from the current position, and no earlier positions\n  /// can be found. This is much faster than find() for small moves.\n  void advanceTo(KeyT x) {\n    if (!valid())\n      return;\n    if (branched())\n      treeAdvanceTo(x);\n    else\n      path.leafOffset() =\n        map->rootLeaf().findFrom(path.leafOffset(), map->rootSize, x);\n  }\n};\n\n/// pathFillFind - Complete path by searching for x.\n/// @param x Key to search for.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\nconst_iterator::pathFillFind(KeyT x) {\n  IntervalMapImpl::NodeRef NR = path.subtree(path.height());\n  for (unsigned i = map->height - path.height() - 1; i; --i) {\n    unsigned p = NR.get<Branch>().safeFind(0, x);\n    path.push(NR, p);\n    NR = NR.subtree(p);\n  }\n  path.push(NR, NR.get<Leaf>().safeFind(0, x));\n}\n\n/// treeFind - Find in a branched tree.\n/// @param x Key to search for.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\nconst_iterator::treeFind(KeyT x) {\n  setRoot(map->rootBranch().findFrom(0, map->rootSize, x));\n  if (valid())\n    pathFillFind(x);\n}\n\n/// treeAdvanceTo - Find position after the current one.\n/// @param x Key to search for.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\nconst_iterator::treeAdvanceTo(KeyT x) {\n  // Can we stay on the same leaf node?\n  if (!Traits::stopLess(path.leaf<Leaf>().stop(path.leafSize() - 1), x)) {\n    path.leafOffset() = path.leaf<Leaf>().safeFind(path.leafOffset(), x);\n    return;\n  }\n\n  // Drop the current leaf.\n  path.pop();\n\n  // Search towards the root for a usable subtree.\n  if (path.height()) {\n    for (unsigned l = path.height() - 1; l; --l) {\n      if (!Traits::stopLess(path.node<Branch>(l).stop(path.offset(l)), x)) {\n        // The branch node at l+1 is usable\n        path.offset(l + 1) =\n          path.node<Branch>(l + 1).safeFind(path.offset(l + 1), x);\n        return pathFillFind(x);\n      }\n      path.pop();\n    }\n    // Is the level-1 Branch usable?\n    if (!Traits::stopLess(map->rootBranch().stop(path.offset(0)), x)) {\n      path.offset(1) = path.node<Branch>(1).safeFind(path.offset(1), x);\n      return pathFillFind(x);\n    }\n  }\n\n  // We reached the root.\n  setRoot(map->rootBranch().findFrom(path.offset(0), map->rootSize, x));\n  if (valid())\n    pathFillFind(x);\n}\n\n//===----------------------------------------------------------------------===//\n//---                       IntervalMap::iterator                         ----//\n//===----------------------------------------------------------------------===//\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nclass IntervalMap<KeyT, ValT, N, Traits>::iterator : public const_iterator {\n  friend class IntervalMap;\n\n  using IdxPair = IntervalMapImpl::IdxPair;\n\n  explicit iterator(IntervalMap &map) : const_iterator(map) {}\n\n  void setNodeStop(unsigned Level, KeyT Stop);\n  bool insertNode(unsigned Level, IntervalMapImpl::NodeRef Node, KeyT Stop);\n  template <typename NodeT> bool overflow(unsigned Level);\n  void treeInsert(KeyT a, KeyT b, ValT y);\n  void eraseNode(unsigned Level);\n  void treeErase(bool UpdateRoot = true);\n  bool canCoalesceLeft(KeyT Start, ValT x);\n  bool canCoalesceRight(KeyT Stop, ValT x);\n\npublic:\n  /// iterator - Create null iterator.\n  iterator() = default;\n\n  /// setStart - Move the start of the current interval.\n  /// This may cause coalescing with the previous interval.\n  /// @param a New start key, must not overlap the previous interval.\n  void setStart(KeyT a);\n\n  /// setStop - Move the end of the current interval.\n  /// This may cause coalescing with the following interval.\n  /// @param b New stop key, must not overlap the following interval.\n  void setStop(KeyT b);\n\n  /// setValue - Change the mapped value of the current interval.\n  /// This may cause coalescing with the previous and following intervals.\n  /// @param x New value.\n  void setValue(ValT x);\n\n  /// setStartUnchecked - Move the start of the current interval without\n  /// checking for coalescing or overlaps.\n  /// This should only be used when it is known that coalescing is not required.\n  /// @param a New start key.\n  void setStartUnchecked(KeyT a) { this->unsafeStart() = a; }\n\n  /// setStopUnchecked - Move the end of the current interval without checking\n  /// for coalescing or overlaps.\n  /// This should only be used when it is known that coalescing is not required.\n  /// @param b New stop key.\n  void setStopUnchecked(KeyT b) {\n    this->unsafeStop() = b;\n    // Update keys in branch nodes as well.\n    if (this->path.atLastEntry(this->path.height()))\n      setNodeStop(this->path.height(), b);\n  }\n\n  /// setValueUnchecked - Change the mapped value of the current interval\n  /// without checking for coalescing.\n  /// @param x New value.\n  void setValueUnchecked(ValT x) { this->unsafeValue() = x; }\n\n  /// insert - Insert mapping [a;b] -> y before the current position.\n  void insert(KeyT a, KeyT b, ValT y);\n\n  /// erase - Erase the current interval.\n  void erase();\n\n  iterator &operator++() {\n    const_iterator::operator++();\n    return *this;\n  }\n\n  iterator operator++(int) {\n    iterator tmp = *this;\n    operator++();\n    return tmp;\n  }\n\n  iterator &operator--() {\n    const_iterator::operator--();\n    return *this;\n  }\n\n  iterator operator--(int) {\n    iterator tmp = *this;\n    operator--();\n    return tmp;\n  }\n};\n\n/// canCoalesceLeft - Can the current interval coalesce to the left after\n/// changing start or value?\n/// @param Start New start of current interval.\n/// @param Value New value for current interval.\n/// @return True when updating the current interval would enable coalescing.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nbool IntervalMap<KeyT, ValT, N, Traits>::\niterator::canCoalesceLeft(KeyT Start, ValT Value) {\n  using namespace IntervalMapImpl;\n  Path &P = this->path;\n  if (!this->branched()) {\n    unsigned i = P.leafOffset();\n    RootLeaf &Node = P.leaf<RootLeaf>();\n    return i && Node.value(i-1) == Value &&\n                Traits::adjacent(Node.stop(i-1), Start);\n  }\n  // Branched.\n  if (unsigned i = P.leafOffset()) {\n    Leaf &Node = P.leaf<Leaf>();\n    return Node.value(i-1) == Value && Traits::adjacent(Node.stop(i-1), Start);\n  } else if (NodeRef NR = P.getLeftSibling(P.height())) {\n    unsigned i = NR.size() - 1;\n    Leaf &Node = NR.get<Leaf>();\n    return Node.value(i) == Value && Traits::adjacent(Node.stop(i), Start);\n  }\n  return false;\n}\n\n/// canCoalesceRight - Can the current interval coalesce to the right after\n/// changing stop or value?\n/// @param Stop New stop of current interval.\n/// @param Value New value for current interval.\n/// @return True when updating the current interval would enable coalescing.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nbool IntervalMap<KeyT, ValT, N, Traits>::\niterator::canCoalesceRight(KeyT Stop, ValT Value) {\n  using namespace IntervalMapImpl;\n  Path &P = this->path;\n  unsigned i = P.leafOffset() + 1;\n  if (!this->branched()) {\n    if (i >= P.leafSize())\n      return false;\n    RootLeaf &Node = P.leaf<RootLeaf>();\n    return Node.value(i) == Value && Traits::adjacent(Stop, Node.start(i));\n  }\n  // Branched.\n  if (i < P.leafSize()) {\n    Leaf &Node = P.leaf<Leaf>();\n    return Node.value(i) == Value && Traits::adjacent(Stop, Node.start(i));\n  } else if (NodeRef NR = P.getRightSibling(P.height())) {\n    Leaf &Node = NR.get<Leaf>();\n    return Node.value(0) == Value && Traits::adjacent(Stop, Node.start(0));\n  }\n  return false;\n}\n\n/// setNodeStop - Update the stop key of the current node at level and above.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::setNodeStop(unsigned Level, KeyT Stop) {\n  // There are no references to the root node, so nothing to update.\n  if (!Level)\n    return;\n  IntervalMapImpl::Path &P = this->path;\n  // Update nodes pointing to the current node.\n  while (--Level) {\n    P.node<Branch>(Level).stop(P.offset(Level)) = Stop;\n    if (!P.atLastEntry(Level))\n      return;\n  }\n  // Update root separately since it has a different layout.\n  P.node<RootBranch>(Level).stop(P.offset(Level)) = Stop;\n}\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::setStart(KeyT a) {\n  assert(Traits::nonEmpty(a, this->stop()) && \"Cannot move start beyond stop\");\n  KeyT &CurStart = this->unsafeStart();\n  if (!Traits::startLess(a, CurStart) || !canCoalesceLeft(a, this->value())) {\n    CurStart = a;\n    return;\n  }\n  // Coalesce with the interval to the left.\n  --*this;\n  a = this->start();\n  erase();\n  setStartUnchecked(a);\n}\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::setStop(KeyT b) {\n  assert(Traits::nonEmpty(this->start(), b) && \"Cannot move stop beyond start\");\n  if (Traits::startLess(b, this->stop()) ||\n      !canCoalesceRight(b, this->value())) {\n    setStopUnchecked(b);\n    return;\n  }\n  // Coalesce with interval to the right.\n  KeyT a = this->start();\n  erase();\n  setStartUnchecked(a);\n}\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::setValue(ValT x) {\n  setValueUnchecked(x);\n  if (canCoalesceRight(this->stop(), x)) {\n    KeyT a = this->start();\n    erase();\n    setStartUnchecked(a);\n  }\n  if (canCoalesceLeft(this->start(), x)) {\n    --*this;\n    KeyT a = this->start();\n    erase();\n    setStartUnchecked(a);\n  }\n}\n\n/// insertNode - insert a node before the current path at level.\n/// Leave the current path pointing at the new node.\n/// @param Level path index of the node to be inserted.\n/// @param Node The node to be inserted.\n/// @param Stop The last index in the new node.\n/// @return True if the tree height was increased.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nbool IntervalMap<KeyT, ValT, N, Traits>::\niterator::insertNode(unsigned Level, IntervalMapImpl::NodeRef Node, KeyT Stop) {\n  assert(Level && \"Cannot insert next to the root\");\n  bool SplitRoot = false;\n  IntervalMap &IM = *this->map;\n  IntervalMapImpl::Path &P = this->path;\n\n  if (Level == 1) {\n    // Insert into the root branch node.\n    if (IM.rootSize < RootBranch::Capacity) {\n      IM.rootBranch().insert(P.offset(0), IM.rootSize, Node, Stop);\n      P.setSize(0, ++IM.rootSize);\n      P.reset(Level);\n      return SplitRoot;\n    }\n\n    // We need to split the root while keeping our position.\n    SplitRoot = true;\n    IdxPair Offset = IM.splitRoot(P.offset(0));\n    P.replaceRoot(&IM.rootBranch(), IM.rootSize, Offset);\n\n    // Fall through to insert at the new higher level.\n    ++Level;\n  }\n\n  // When inserting before end(), make sure we have a valid path.\n  P.legalizeForInsert(--Level);\n\n  // Insert into the branch node at Level-1.\n  if (P.size(Level) == Branch::Capacity) {\n    // Branch node is full, handle handle the overflow.\n    assert(!SplitRoot && \"Cannot overflow after splitting the root\");\n    SplitRoot = overflow<Branch>(Level);\n    Level += SplitRoot;\n  }\n  P.node<Branch>(Level).insert(P.offset(Level), P.size(Level), Node, Stop);\n  P.setSize(Level, P.size(Level) + 1);\n  if (P.atLastEntry(Level))\n    setNodeStop(Level, Stop);\n  P.reset(Level + 1);\n  return SplitRoot;\n}\n\n// insert\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::insert(KeyT a, KeyT b, ValT y) {\n  if (this->branched())\n    return treeInsert(a, b, y);\n  IntervalMap &IM = *this->map;\n  IntervalMapImpl::Path &P = this->path;\n\n  // Try simple root leaf insert.\n  unsigned Size = IM.rootLeaf().insertFrom(P.leafOffset(), IM.rootSize, a, b, y);\n\n  // Was the root node insert successful?\n  if (Size <= RootLeaf::Capacity) {\n    P.setSize(0, IM.rootSize = Size);\n    return;\n  }\n\n  // Root leaf node is full, we must branch.\n  IdxPair Offset = IM.branchRoot(P.leafOffset());\n  P.replaceRoot(&IM.rootBranch(), IM.rootSize, Offset);\n\n  // Now it fits in the new leaf.\n  treeInsert(a, b, y);\n}\n\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::treeInsert(KeyT a, KeyT b, ValT y) {\n  using namespace IntervalMapImpl;\n  Path &P = this->path;\n\n  if (!P.valid())\n    P.legalizeForInsert(this->map->height);\n\n  // Check if this insertion will extend the node to the left.\n  if (P.leafOffset() == 0 && Traits::startLess(a, P.leaf<Leaf>().start(0))) {\n    // Node is growing to the left, will it affect a left sibling node?\n    if (NodeRef Sib = P.getLeftSibling(P.height())) {\n      Leaf &SibLeaf = Sib.get<Leaf>();\n      unsigned SibOfs = Sib.size() - 1;\n      if (SibLeaf.value(SibOfs) == y &&\n          Traits::adjacent(SibLeaf.stop(SibOfs), a)) {\n        // This insertion will coalesce with the last entry in SibLeaf. We can\n        // handle it in two ways:\n        //  1. Extend SibLeaf.stop to b and be done, or\n        //  2. Extend a to SibLeaf, erase the SibLeaf entry and continue.\n        // We prefer 1., but need 2 when coalescing to the right as well.\n        Leaf &CurLeaf = P.leaf<Leaf>();\n        P.moveLeft(P.height());\n        if (Traits::stopLess(b, CurLeaf.start(0)) &&\n            (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {\n          // Easy, just extend SibLeaf and we're done.\n          setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);\n          return;\n        } else {\n          // We have both left and right coalescing. Erase the old SibLeaf entry\n          // and continue inserting the larger interval.\n          a = SibLeaf.start(SibOfs);\n          treeErase(/* UpdateRoot= */false);\n        }\n      }\n    } else {\n      // No left sibling means we are at begin(). Update cached bound.\n      this->map->rootBranchStart() = a;\n    }\n  }\n\n  // When we are inserting at the end of a leaf node, we must update stops.\n  unsigned Size = P.leafSize();\n  bool Grow = P.leafOffset() == Size;\n  Size = P.leaf<Leaf>().insertFrom(P.leafOffset(), Size, a, b, y);\n\n  // Leaf insertion unsuccessful? Overflow and try again.\n  if (Size > Leaf::Capacity) {\n    overflow<Leaf>(P.height());\n    Grow = P.leafOffset() == P.leafSize();\n    Size = P.leaf<Leaf>().insertFrom(P.leafOffset(), P.leafSize(), a, b, y);\n    assert(Size <= Leaf::Capacity && \"overflow() didn't make room\");\n  }\n\n  // Inserted, update offset and leaf size.\n  P.setSize(P.height(), Size);\n\n  // Insert was the last node entry, update stops.\n  if (Grow)\n    setNodeStop(P.height(), b);\n}\n\n/// erase - erase the current interval and move to the next position.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::erase() {\n  IntervalMap &IM = *this->map;\n  IntervalMapImpl::Path &P = this->path;\n  assert(P.valid() && \"Cannot erase end()\");\n  if (this->branched())\n    return treeErase();\n  IM.rootLeaf().erase(P.leafOffset(), IM.rootSize);\n  P.setSize(0, --IM.rootSize);\n}\n\n/// treeErase - erase() for a branched tree.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::treeErase(bool UpdateRoot) {\n  IntervalMap &IM = *this->map;\n  IntervalMapImpl::Path &P = this->path;\n  Leaf &Node = P.leaf<Leaf>();\n\n  // Nodes are not allowed to become empty.\n  if (P.leafSize() == 1) {\n    IM.deleteNode(&Node);\n    eraseNode(IM.height);\n    // Update rootBranchStart if we erased begin().\n    if (UpdateRoot && IM.branched() && P.valid() && P.atBegin())\n      IM.rootBranchStart() = P.leaf<Leaf>().start(0);\n    return;\n  }\n\n  // Erase current entry.\n  Node.erase(P.leafOffset(), P.leafSize());\n  unsigned NewSize = P.leafSize() - 1;\n  P.setSize(IM.height, NewSize);\n  // When we erase the last entry, update stop and move to a legal position.\n  if (P.leafOffset() == NewSize) {\n    setNodeStop(IM.height, Node.stop(NewSize - 1));\n    P.moveRight(IM.height);\n  } else if (UpdateRoot && P.atBegin())\n    IM.rootBranchStart() = P.leaf<Leaf>().start(0);\n}\n\n/// eraseNode - Erase the current node at Level from its parent and move path to\n/// the first entry of the next sibling node.\n/// The node must be deallocated by the caller.\n/// @param Level 1..height, the root node cannot be erased.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\nvoid IntervalMap<KeyT, ValT, N, Traits>::\niterator::eraseNode(unsigned Level) {\n  assert(Level && \"Cannot erase root node\");\n  IntervalMap &IM = *this->map;\n  IntervalMapImpl::Path &P = this->path;\n\n  if (--Level == 0) {\n    IM.rootBranch().erase(P.offset(0), IM.rootSize);\n    P.setSize(0, --IM.rootSize);\n    // If this cleared the root, switch to height=0.\n    if (IM.empty()) {\n      IM.switchRootToLeaf();\n      this->setRoot(0);\n      return;\n    }\n  } else {\n    // Remove node ref from branch node at Level.\n    Branch &Parent = P.node<Branch>(Level);\n    if (P.size(Level) == 1) {\n      // Branch node became empty, remove it recursively.\n      IM.deleteNode(&Parent);\n      eraseNode(Level);\n    } else {\n      // Branch node won't become empty.\n      Parent.erase(P.offset(Level), P.size(Level));\n      unsigned NewSize = P.size(Level) - 1;\n      P.setSize(Level, NewSize);\n      // If we removed the last branch, update stop and move to a legal pos.\n      if (P.offset(Level) == NewSize) {\n        setNodeStop(Level, Parent.stop(NewSize - 1));\n        P.moveRight(Level);\n      }\n    }\n  }\n  // Update path cache for the new right sibling position.\n  if (P.valid()) {\n    P.reset(Level + 1);\n    P.offset(Level + 1) = 0;\n  }\n}\n\n/// overflow - Distribute entries of the current node evenly among\n/// its siblings and ensure that the current node is not full.\n/// This may require allocating a new node.\n/// @tparam NodeT The type of node at Level (Leaf or Branch).\n/// @param Level path index of the overflowing node.\n/// @return True when the tree height was changed.\ntemplate <typename KeyT, typename ValT, unsigned N, typename Traits>\ntemplate <typename NodeT>\nbool IntervalMap<KeyT, ValT, N, Traits>::\niterator::overflow(unsigned Level) {\n  using namespace IntervalMapImpl;\n  Path &P = this->path;\n  unsigned CurSize[4];\n  NodeT *Node[4];\n  unsigned Nodes = 0;\n  unsigned Elements = 0;\n  unsigned Offset = P.offset(Level);\n\n  // Do we have a left sibling?\n  NodeRef LeftSib = P.getLeftSibling(Level);\n  if (LeftSib) {\n    Offset += Elements = CurSize[Nodes] = LeftSib.size();\n    Node[Nodes++] = &LeftSib.get<NodeT>();\n  }\n\n  // Current node.\n  Elements += CurSize[Nodes] = P.size(Level);\n  Node[Nodes++] = &P.node<NodeT>(Level);\n\n  // Do we have a right sibling?\n  NodeRef RightSib = P.getRightSibling(Level);\n  if (RightSib) {\n    Elements += CurSize[Nodes] = RightSib.size();\n    Node[Nodes++] = &RightSib.get<NodeT>();\n  }\n\n  // Do we need to allocate a new node?\n  unsigned NewNode = 0;\n  if (Elements + 1 > Nodes * NodeT::Capacity) {\n    // Insert NewNode at the penultimate position, or after a single node.\n    NewNode = Nodes == 1 ? 1 : Nodes - 1;\n    CurSize[Nodes] = CurSize[NewNode];\n    Node[Nodes] = Node[NewNode];\n    CurSize[NewNode] = 0;\n    Node[NewNode] = this->map->template newNode<NodeT>();\n    ++Nodes;\n  }\n\n  // Compute the new element distribution.\n  unsigned NewSize[4];\n  IdxPair NewOffset = distribute(Nodes, Elements, NodeT::Capacity,\n                                 CurSize, NewSize, Offset, true);\n  adjustSiblingSizes(Node, Nodes, CurSize, NewSize);\n\n  // Move current location to the leftmost node.\n  if (LeftSib)\n    P.moveLeft(Level);\n\n  // Elements have been rearranged, now update node sizes and stops.\n  bool SplitRoot = false;\n  unsigned Pos = 0;\n  while (true) {\n    KeyT Stop = Node[Pos]->stop(NewSize[Pos]-1);\n    if (NewNode && Pos == NewNode) {\n      SplitRoot = insertNode(Level, NodeRef(Node[Pos], NewSize[Pos]), Stop);\n      Level += SplitRoot;\n    } else {\n      P.setSize(Level, NewSize[Pos]);\n      setNodeStop(Level, Stop);\n    }\n    if (Pos + 1 == Nodes)\n      break;\n    P.moveRight(Level);\n    ++Pos;\n  }\n\n  // Where was I? Find NewOffset.\n  while(Pos != NewOffset.first) {\n    P.moveLeft(Level);\n    --Pos;\n  }\n  P.offset(Level) = NewOffset.second;\n  return SplitRoot;\n}\n\n//===----------------------------------------------------------------------===//\n//---                       IntervalMapOverlaps                           ----//\n//===----------------------------------------------------------------------===//\n\n/// IntervalMapOverlaps - Iterate over the overlaps of mapped intervals in two\n/// IntervalMaps. The maps may be different, but the KeyT and Traits types\n/// should be the same.\n///\n/// Typical uses:\n///\n/// 1. Test for overlap:\n///    bool overlap = IntervalMapOverlaps(a, b).valid();\n///\n/// 2. Enumerate overlaps:\n///    for (IntervalMapOverlaps I(a, b); I.valid() ; ++I) { ... }\n///\ntemplate <typename MapA, typename MapB>\nclass IntervalMapOverlaps {\n  using KeyType = typename MapA::KeyType;\n  using Traits = typename MapA::KeyTraits;\n\n  typename MapA::const_iterator posA;\n  typename MapB::const_iterator posB;\n\n  /// advance - Move posA and posB forward until reaching an overlap, or until\n  /// either meets end.\n  /// Don't move the iterators if they are already overlapping.\n  void advance() {\n    if (!valid())\n      return;\n\n    if (Traits::stopLess(posA.stop(), posB.start())) {\n      // A ends before B begins. Catch up.\n      posA.advanceTo(posB.start());\n      if (!posA.valid() || !Traits::stopLess(posB.stop(), posA.start()))\n        return;\n    } else if (Traits::stopLess(posB.stop(), posA.start())) {\n      // B ends before A begins. Catch up.\n      posB.advanceTo(posA.start());\n      if (!posB.valid() || !Traits::stopLess(posA.stop(), posB.start()))\n        return;\n    } else\n      // Already overlapping.\n      return;\n\n    while (true) {\n      // Make a.end > b.start.\n      posA.advanceTo(posB.start());\n      if (!posA.valid() || !Traits::stopLess(posB.stop(), posA.start()))\n        return;\n      // Make b.end > a.start.\n      posB.advanceTo(posA.start());\n      if (!posB.valid() || !Traits::stopLess(posA.stop(), posB.start()))\n        return;\n    }\n  }\n\npublic:\n  /// IntervalMapOverlaps - Create an iterator for the overlaps of a and b.\n  IntervalMapOverlaps(const MapA &a, const MapB &b)\n    : posA(b.empty() ? a.end() : a.find(b.start())),\n      posB(posA.valid() ? b.find(posA.start()) : b.end()) { advance(); }\n\n  /// valid - Return true if iterator is at an overlap.\n  bool valid() const {\n    return posA.valid() && posB.valid();\n  }\n\n  /// a - access the left hand side in the overlap.\n  const typename MapA::const_iterator &a() const { return posA; }\n\n  /// b - access the right hand side in the overlap.\n  const typename MapB::const_iterator &b() const { return posB; }\n\n  /// start - Beginning of the overlapping interval.\n  KeyType start() const {\n    KeyType ak = a().start();\n    KeyType bk = b().start();\n    return Traits::startLess(ak, bk) ? bk : ak;\n  }\n\n  /// stop - End of the overlapping interval.\n  KeyType stop() const {\n    KeyType ak = a().stop();\n    KeyType bk = b().stop();\n    return Traits::startLess(ak, bk) ? ak : bk;\n  }\n\n  /// skipA - Move to the next overlap that doesn't involve a().\n  void skipA() {\n    ++posA;\n    advance();\n  }\n\n  /// skipB - Move to the next overlap that doesn't involve b().\n  void skipB() {\n    ++posB;\n    advance();\n  }\n\n  /// Preincrement - Move to the next overlap.\n  IntervalMapOverlaps &operator++() {\n    // Bump the iterator that ends first. The other one may have more overlaps.\n    if (Traits::startLess(posB.stop(), posA.stop()))\n      skipB();\n    else\n      skipA();\n    return *this;\n  }\n\n  /// advanceTo - Move to the first overlapping interval with\n  /// stopLess(x, stop()).\n  void advanceTo(KeyType x) {\n    if (!valid())\n      return;\n    // Make sure advanceTo sees monotonic keys.\n    if (Traits::stopLess(posA.stop(), x))\n      posA.advanceTo(x);\n    if (Traits::stopLess(posB.stop(), x))\n      posB.advanceTo(x);\n    advance();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_INTERVALMAP_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVRecord.h", "content": "//===- CVRecord.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_CVRECORD_H\n#define LLVM_DEBUGINFO_CODEVIEW_CVRECORD_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/DebugInfo/CodeView/CodeViewError.h\"\n#include \"llvm/DebugInfo/CodeView/RecordSerialization.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nnamespace codeview {\n\n/// CVRecord is a fat pointer (base + size pair) to a symbol or type record.\n/// Carrying the size separately instead of trusting the size stored in the\n/// record prefix provides some extra safety and flexibility.\ntemplate <typename Kind> class CVRecord {\npublic:\n  CVRecord() = default;\n\n  CVRecord(ArrayRef<uint8_t> Data) : RecordData(Data) {}\n\n  CVRecord(const RecordPrefix *P, size_t Size)\n      : RecordData(reinterpret_cast<const uint8_t *>(P), Size) {}\n\n  bool valid() const { return kind() != Kind(0); }\n\n  uint32_t length() const { return RecordData.size(); }\n\n  Kind kind() const {\n    if (RecordData.size() < sizeof(RecordPrefix))\n      return Kind(0);\n    return static_cast<Kind>(static_cast<uint16_t>(\n        reinterpret_cast<const RecordPrefix *>(RecordData.data())->RecordKind));\n  }\n\n  ArrayRef<uint8_t> data() const { return RecordData; }\n\n  StringRef str_data() const {\n    return StringRef(reinterpret_cast<const char *>(RecordData.data()),\n                     RecordData.size());\n  }\n\n  ArrayRef<uint8_t> content() const {\n    return RecordData.drop_front(sizeof(RecordPrefix));\n  }\n\n  ArrayRef<uint8_t> RecordData;\n};\n\n// There are two kinds of codeview records: type and symbol records.\nusing CVType = CVRecord<TypeLeafKind>;\nusing CVSymbol = CVRecord<SymbolKind>;\n\ntemplate <typename Record, typename Func>\nError forEachCodeViewRecord(ArrayRef<uint8_t> StreamBuffer, Func F) {\n  while (!StreamBuffer.empty()) {\n    if (StreamBuffer.size() < sizeof(RecordPrefix))\n      return make_error<CodeViewError>(cv_error_code::corrupt_record);\n\n    const RecordPrefix *Prefix =\n        reinterpret_cast<const RecordPrefix *>(StreamBuffer.data());\n\n    size_t RealLen = Prefix->RecordLen + 2;\n    if (StreamBuffer.size() < RealLen)\n      return make_error<CodeViewError>(cv_error_code::corrupt_record);\n\n    ArrayRef<uint8_t> Data = StreamBuffer.take_front(RealLen);\n    StreamBuffer = StreamBuffer.drop_front(RealLen);\n\n    Record R(Data);\n    if (auto EC = F(R))\n      return EC;\n  }\n  return Error::success();\n}\n\n/// Read a complete record from a stream at a random offset.\ntemplate <typename Kind>\ninline Expected<CVRecord<Kind>> readCVRecordFromStream(BinaryStreamRef Stream,\n                                                       uint32_t Offset) {\n  const RecordPrefix *Prefix = nullptr;\n  BinaryStreamReader Reader(Stream);\n  Reader.setOffset(Offset);\n\n  if (auto EC = Reader.readObject(Prefix))\n    return std::move(EC);\n  if (Prefix->RecordLen < 2)\n    return make_error<CodeViewError>(cv_error_code::corrupt_record);\n\n  Reader.setOffset(Offset);\n  ArrayRef<uint8_t> RawData;\n  if (auto EC = Reader.readBytes(RawData, Prefix->RecordLen + sizeof(uint16_t)))\n    return std::move(EC);\n  return codeview::CVRecord<Kind>(RawData);\n}\n\n} // end namespace codeview\n\ntemplate <typename Kind>\nstruct VarStreamArrayExtractor<codeview::CVRecord<Kind>> {\n  Error operator()(BinaryStreamRef Stream, uint32_t &Len,\n                   codeview::CVRecord<Kind> &Item) {\n    auto ExpectedRec = codeview::readCVRecordFromStream<Kind>(Stream, 0);\n    if (!ExpectedRec)\n      return ExpectedRec.takeError();\n    Item = *ExpectedRec;\n    Len = ExpectedRec->length();\n    return Error::success();\n  }\n};\n\nnamespace codeview {\nusing CVSymbolArray = VarStreamArray<CVSymbol>;\nusing CVTypeArray = VarStreamArray<CVType>;\nusing CVTypeRange = iterator_range<CVTypeArray::Iterator>;\n} // namespace codeview\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_CODEVIEW_CVRECORD_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h", "content": "//===- DebugChecksumsSubsection.h -------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_DEBUGCHECKSUMSSUBSECTION_H\n#define LLVM_DEBUGINFO_CODEVIEW_DEBUGCHECKSUMSSUBSECTION_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/DebugInfo/CodeView/DebugSubsection.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/BinaryStreamArray.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\n\nnamespace codeview {\n\nclass DebugStringTableSubsection;\n\nstruct FileChecksumEntry {\n  uint32_t FileNameOffset;    // Byte offset of filename in global stringtable.\n  FileChecksumKind Kind;      // The type of checksum.\n  ArrayRef<uint8_t> Checksum; // The bytes of the checksum.\n};\n\n} // end namespace codeview\n\ntemplate <> struct VarStreamArrayExtractor<codeview::FileChecksumEntry> {\npublic:\n  using ContextType = void;\n\n  Error operator()(BinaryStreamRef Stream, uint32_t &Len,\n                   codeview::FileChecksumEntry &Item);\n};\n\nnamespace codeview {\n\nclass DebugChecksumsSubsectionRef final : public DebugSubsectionRef {\n  using FileChecksumArray = VarStreamArray<codeview::FileChecksumEntry>;\n  using Iterator = FileChecksumArray::Iterator;\n\npublic:\n  DebugChecksumsSubsectionRef()\n      : DebugSubsectionRef(DebugSubsectionKind::FileChecksums) {}\n\n  static bool classof(const DebugSubsectionRef *S) {\n    return S->kind() == DebugSubsectionKind::FileChecksums;\n  }\n\n  bool valid() const { return Checksums.valid(); }\n\n  Error initialize(BinaryStreamReader Reader);\n  Error initialize(BinaryStreamRef Stream);\n\n  Iterator begin() const { return Checksums.begin(); }\n  Iterator end() const { return Checksums.end(); }\n\n  const FileChecksumArray &getArray() const { return Checksums; }\n\nprivate:\n  FileChecksumArray Checksums;\n};\n\nclass DebugChecksumsSubsection final : public DebugSubsection {\npublic:\n  explicit DebugChecksumsSubsection(DebugStringTableSubsection &Strings);\n\n  static bool classof(const DebugSubsection *S) {\n    return S->kind() == DebugSubsectionKind::FileChecksums;\n  }\n\n  void addChecksum(StringRef FileName, FileChecksumKind Kind,\n                   ArrayRef<uint8_t> Bytes);\n\n  uint32_t calculateSerializedSize() const override;\n  Error commit(BinaryStreamWriter &Writer) const override;\n  uint32_t mapChecksumOffset(StringRef FileName) const;\n\nprivate:\n  DebugStringTableSubsection &Strings;\n\n  DenseMap<uint32_t, uint32_t> OffsetMap;\n  uint32_t SerializedSize = 0;\n  BumpPtrAllocator Storage;\n  std::vector<FileChecksumEntry> Checksums;\n};\n\n} // end namespace codeview\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_CODEVIEW_DEBUGCHECKSUMSSUBSECTION_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugFrameDataSubsection.h", "content": "//===- DebugFrameDataSubsection.h ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_DEBUGFRAMEDATASUBSECTION_H\n#define LLVM_DEBUGINFO_CODEVIEW_DEBUGFRAMEDATASUBSECTION_H\n\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/DebugInfo/CodeView/DebugSubsection.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\nnamespace codeview {\nclass DebugFrameDataSubsectionRef final : public DebugSubsectionRef {\npublic:\n  DebugFrameDataSubsectionRef()\n      : DebugSubsectionRef(DebugSubsectionKind::FrameData) {}\n  static bool classof(const DebugSubsection *S) {\n    return S->kind() == DebugSubsectionKind::FrameData;\n  }\n\n  Error initialize(BinaryStreamReader Reader);\n  Error initialize(BinaryStreamRef Stream);\n\n  FixedStreamArray<FrameData>::Iterator begin() const { return Frames.begin(); }\n  FixedStreamArray<FrameData>::Iterator end() const { return Frames.end(); }\n\n  const support::ulittle32_t *getRelocPtr() const { return RelocPtr; }\n\nprivate:\n  const support::ulittle32_t *RelocPtr = nullptr;\n  FixedStreamArray<FrameData> Frames;\n};\n\nclass DebugFrameDataSubsection final : public DebugSubsection {\npublic:\n  DebugFrameDataSubsection(bool IncludeRelocPtr)\n      : DebugSubsection(DebugSubsectionKind::FrameData),\n        IncludeRelocPtr(IncludeRelocPtr) {}\n  static bool classof(const DebugSubsection *S) {\n    return S->kind() == DebugSubsectionKind::FrameData;\n  }\n\n  uint32_t calculateSerializedSize() const override;\n  Error commit(BinaryStreamWriter &Writer) const override;\n\n  void addFrameData(const FrameData &Frame);\n  void setFrames(ArrayRef<FrameData> Frames);\n\nprivate:\n  bool IncludeRelocPtr = false;\n  std::vector<FrameData> Frames;\n};\n}\n}\n\n#endif\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugStringTableSubsection.h", "content": "//===- DebugStringTableSubsection.h - CodeView String Table -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_DEBUGSTRINGTABLESUBSECTION_H\n#define LLVM_DEBUGINFO_CODEVIEW_DEBUGSTRINGTABLESUBSECTION_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/DebugInfo/CodeView/DebugSubsection.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass BinaryStreamReader;\n\nnamespace codeview {\n\n/// Represents a read-only view of a CodeView string table.  This is a very\n/// simple flat buffer consisting of null-terminated strings, where strings\n/// are retrieved by their offset in the buffer.  DebugStringTableSubsectionRef\n/// does not own the underlying storage for the buffer.\nclass DebugStringTableSubsectionRef : public DebugSubsectionRef {\npublic:\n  DebugStringTableSubsectionRef();\n\n  static bool classof(const DebugSubsectionRef *S) {\n    return S->kind() == DebugSubsectionKind::StringTable;\n  }\n\n  Error initialize(BinaryStreamRef Contents);\n  Error initialize(BinaryStreamReader &Reader);\n\n  Expected<StringRef> getString(uint32_t Offset) const;\n\n  bool valid() const { return Stream.valid(); }\n\n  BinaryStreamRef getBuffer() const { return Stream; }\n\nprivate:\n  BinaryStreamRef Stream;\n};\n\n/// Represents a read-write view of a CodeView string table.\n/// DebugStringTableSubsection owns the underlying storage for the table, and is\n/// capable of serializing the string table into a format understood by\n/// DebugStringTableSubsectionRef.\nclass DebugStringTableSubsection : public DebugSubsection {\npublic:\n  DebugStringTableSubsection();\n\n  static bool classof(const DebugSubsection *S) {\n    return S->kind() == DebugSubsectionKind::StringTable;\n  }\n\n  // If string S does not exist in the string table, insert it.\n  // Returns the ID for S.\n  uint32_t insert(StringRef S);\n\n  // Return the ID for string S.  Assumes S exists in the table.\n  uint32_t getIdForString(StringRef S) const;\n\n  StringRef getStringForId(uint32_t Id) const;\n\n  uint32_t calculateSerializedSize() const override;\n  Error commit(BinaryStreamWriter &Writer) const override;\n\n  uint32_t size() const;\n\n  StringMap<uint32_t>::const_iterator begin() const {\n    return StringToId.begin();\n  }\n\n  StringMap<uint32_t>::const_iterator end() const { return StringToId.end(); }\n\n  std::vector<uint32_t> sortedIds() const;\n\nprivate:\n  DenseMap<uint32_t, StringRef> IdToString;\n  StringMap<uint32_t> StringToId;\n  uint32_t StringSize = 1;\n};\n\n} // end namespace codeview\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_CODEVIEW_DEBUGSTRINGTABLESUBSECTION_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugSubsectionRecord.h", "content": "//===- DebugSubsectionRecord.h ----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_DEBUGSUBSECTIONRECORD_H\n#define LLVM_DEBUGINFO_CODEVIEW_DEBUGSUBSECTIONRECORD_H\n\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/Support/BinaryStreamArray.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\n\nclass BinaryStreamWriter;\n\nnamespace codeview {\n\nclass DebugSubsection;\n\n// Corresponds to the `CV_DebugSSubsectionHeader_t` structure.\nstruct DebugSubsectionHeader {\n  support::ulittle32_t Kind;   // codeview::DebugSubsectionKind enum\n  support::ulittle32_t Length; // number of bytes occupied by this record.\n};\n\nclass DebugSubsectionRecord {\npublic:\n  DebugSubsectionRecord();\n  DebugSubsectionRecord(DebugSubsectionKind Kind, BinaryStreamRef Data);\n\n  static Error initialize(BinaryStreamRef Stream, DebugSubsectionRecord &Info);\n\n  uint32_t getRecordLength() const;\n  DebugSubsectionKind kind() const;\n  BinaryStreamRef getRecordData() const;\n\nprivate:\n  DebugSubsectionKind Kind = DebugSubsectionKind::None;\n  BinaryStreamRef Data;\n};\n\nclass DebugSubsectionRecordBuilder {\npublic:\n  DebugSubsectionRecordBuilder(std::shared_ptr<DebugSubsection> Subsection);\n\n  /// Use this to copy existing subsections directly from source to destination.\n  /// For example, line table subsections in an object file only need to be\n  /// relocated before being copied into the PDB.\n  DebugSubsectionRecordBuilder(const DebugSubsectionRecord &Contents);\n\n  uint32_t calculateSerializedLength() const;\n  Error commit(BinaryStreamWriter &Writer, CodeViewContainer Container) const;\n\nprivate:\n  /// The subsection to build. Will be null if Contents is non-empty.\n  std::shared_ptr<DebugSubsection> Subsection;\n\n  /// The bytes of the subsection. Only non-empty if Subsection is null.\n  /// FIXME: Reduce the size of this.\n  DebugSubsectionRecord Contents;\n};\n\n} // end namespace codeview\n\ntemplate <> struct VarStreamArrayExtractor<codeview::DebugSubsectionRecord> {\n  Error operator()(BinaryStreamRef Stream, uint32_t &Length,\n                   codeview::DebugSubsectionRecord &Info) {\n    // FIXME: We need to pass the container type through to this function.  In\n    // practice this isn't super important since the subsection header describes\n    // its length and we can just skip it.  It's more important when writing.\n    if (auto EC = codeview::DebugSubsectionRecord::initialize(Stream, Info))\n      return EC;\n    Length = alignTo(Info.getRecordLength(), 4);\n    return Error::success();\n  }\n};\n\nnamespace codeview {\n\nusing DebugSubsectionArray = VarStreamArray<DebugSubsectionRecord>;\n\n} // end namespace codeview\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_CODEVIEW_DEBUGSUBSECTIONRECORD_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/LazyRandomTypeCollection.h", "content": "//===- LazyRandomTypeCollection.h -------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_LAZYRANDOMTYPECOLLECTION_H\n#define LLVM_DEBUGINFO_CODEVIEW_LAZYRANDOMTYPECOLLECTION_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/CodeView/TypeCollection.h\"\n#include \"llvm/DebugInfo/CodeView/TypeIndex.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/BinaryStreamArray.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\nnamespace codeview {\n\n/// Provides amortized O(1) random access to a CodeView type stream.\n/// Normally to access a type from a type stream, you must know its byte\n/// offset into the type stream, because type records are variable-lengthed.\n/// However, this is not the way we prefer to access them.  For example, given\n/// a symbol record one of the fields may be the TypeIndex of the symbol's\n/// type record.  Or given a type record such as an array type, there might\n/// be a TypeIndex for the element type.  Sequential access is perfect when\n/// we're just dumping every entry, but it's very poor for real world usage.\n///\n/// Type streams in PDBs contain an additional field which is a list of pairs\n/// containing indices and their corresponding offsets, roughly every ~8KB of\n/// record data.  This general idea need not be confined to PDBs though.  By\n/// supplying such an array, the producer of a type stream can allow the\n/// consumer much better access time, because the consumer can find the nearest\n/// index in this array, and do a linear scan forward only from there.\n///\n/// LazyRandomTypeCollection implements this algorithm, but additionally goes\n/// one step further by caching offsets of every record that has been visited at\n/// least once.  This way, even repeated visits of the same record will never\n/// require more than one linear scan.  For a type stream of N elements divided\n/// into M chunks of roughly equal size, this yields a worst case lookup time\n/// of O(N/M) and an amortized time of O(1).\nclass LazyRandomTypeCollection : public TypeCollection {\n  using PartialOffsetArray = FixedStreamArray<TypeIndexOffset>;\n\n  struct CacheEntry {\n    CVType Type;\n    uint32_t Offset;\n    StringRef Name;\n  };\n\npublic:\n  explicit LazyRandomTypeCollection(uint32_t RecordCountHint);\n  LazyRandomTypeCollection(StringRef Data, uint32_t RecordCountHint);\n  LazyRandomTypeCollection(ArrayRef<uint8_t> Data, uint32_t RecordCountHint);\n  LazyRandomTypeCollection(const CVTypeArray &Types, uint32_t RecordCountHint,\n                           PartialOffsetArray PartialOffsets);\n  LazyRandomTypeCollection(const CVTypeArray &Types, uint32_t RecordCountHint);\n\n  void reset(ArrayRef<uint8_t> Data, uint32_t RecordCountHint);\n  void reset(StringRef Data, uint32_t RecordCountHint);\n  void reset(BinaryStreamReader &Reader, uint32_t RecordCountHint);\n\n  uint32_t getOffsetOfType(TypeIndex Index);\n\n  Optional<CVType> tryGetType(TypeIndex Index);\n\n  CVType getType(TypeIndex Index) override;\n  StringRef getTypeName(TypeIndex Index) override;\n  bool contains(TypeIndex Index) override;\n  uint32_t size() override;\n  uint32_t capacity() override;\n  Optional<TypeIndex> getFirst() override;\n  Optional<TypeIndex> getNext(TypeIndex Prev) override;\n  bool replaceType(TypeIndex &Index, CVType Data, bool Stabilize) override;\n\nprivate:\n  Error ensureTypeExists(TypeIndex Index);\n  void ensureCapacityFor(TypeIndex Index);\n\n  Error visitRangeForType(TypeIndex TI);\n  Error fullScanForType(TypeIndex TI);\n  void visitRange(TypeIndex Begin, uint32_t BeginOffset, TypeIndex End);\n\n  /// Number of actual records.\n  uint32_t Count = 0;\n\n  /// The largest type index which we've visited.\n  TypeIndex LargestTypeIndex = TypeIndex::None();\n\n  BumpPtrAllocator Allocator;\n  StringSaver NameStorage;\n\n  /// The type array to allow random access visitation of.\n  CVTypeArray Types;\n\n  std::vector<CacheEntry> Records;\n\n  /// An array of index offsets for the given type stream, allowing log(N)\n  /// lookups of a type record by index.  Similar to KnownOffsets but only\n  /// contains offsets for some type indices, some of which may not have\n  /// ever been visited.\n  PartialOffsetArray PartialOffsets;\n};\n\n} // end namespace codeview\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_CODEVIEW_LAZYRANDOMTYPECOLLECTION_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/Line.h", "content": "//===- Line.h ---------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_LINE_H\n#define LLVM_DEBUGINFO_CODEVIEW_LINE_H\n\n#include \"llvm/DebugInfo/CodeView/TypeIndex.h\"\n#include \"llvm/Support/Endian.h\"\n#include <cinttypes>\n\nnamespace llvm {\nnamespace codeview {\n\nusing llvm::support::ulittle32_t;\n\nclass LineInfo {\npublic:\n  enum : uint32_t {\n    AlwaysStepIntoLineNumber = 0xfeefee,\n    NeverStepIntoLineNumber = 0xf00f00\n  };\n\n  enum : int { EndLineDeltaShift = 24 };\n\n  enum : uint32_t {\n    StartLineMask = 0x00ffffff,\n    EndLineDeltaMask = 0x7f000000,\n    StatementFlag = 0x80000000u\n  };\n\n  LineInfo(uint32_t StartLine, uint32_t EndLine, bool IsStatement);\n  LineInfo(uint32_t LineData) : LineData(LineData) {}\n\n  uint32_t getStartLine() const { return LineData & StartLineMask; }\n\n  uint32_t getLineDelta() const {\n    return (LineData & EndLineDeltaMask) >> EndLineDeltaShift;\n  }\n\n  uint32_t getEndLine() const { return getStartLine() + getLineDelta(); }\n\n  bool isStatement() const { return (LineData & StatementFlag) != 0; }\n\n  uint32_t getRawData() const { return LineData; }\n\n  bool isAlwaysStepInto() const {\n    return getStartLine() == AlwaysStepIntoLineNumber;\n  }\n\n  bool isNeverStepInto() const {\n    return getStartLine() == NeverStepIntoLineNumber;\n  }\n\nprivate:\n  uint32_t LineData;\n};\n\nclass ColumnInfo {\nprivate:\n  static const uint32_t StartColumnMask = 0x0000ffffu;\n  static const uint32_t EndColumnMask = 0xffff0000u;\n  static const int EndColumnShift = 16;\n\npublic:\n  ColumnInfo(uint16_t StartColumn, uint16_t EndColumn) {\n    ColumnData =\n        (static_cast<uint32_t>(StartColumn) & StartColumnMask) |\n        ((static_cast<uint32_t>(EndColumn) << EndColumnShift) & EndColumnMask);\n  }\n\n  uint16_t getStartColumn() const {\n    return static_cast<uint16_t>(ColumnData & StartColumnMask);\n  }\n\n  uint16_t getEndColumn() const {\n    return static_cast<uint16_t>((ColumnData & EndColumnMask) >>\n                                 EndColumnShift);\n  }\n\n  uint32_t getRawData() const { return ColumnData; }\n\nprivate:\n  uint32_t ColumnData;\n};\n\nclass Line {\nprivate:\n  int32_t CodeOffset;\n  LineInfo LineInf;\n  ColumnInfo ColumnInf;\n\npublic:\n  Line(int32_t CodeOffset, uint32_t StartLine, uint32_t EndLine,\n       uint16_t StartColumn, uint16_t EndColumn, bool IsStatement)\n      : CodeOffset(CodeOffset), LineInf(StartLine, EndLine, IsStatement),\n        ColumnInf(StartColumn, EndColumn) {}\n\n  Line(int32_t CodeOffset, LineInfo LineInf, ColumnInfo ColumnInf)\n      : CodeOffset(CodeOffset), LineInf(LineInf), ColumnInf(ColumnInf) {}\n\n  LineInfo getLineInfo() const { return LineInf; }\n\n  ColumnInfo getColumnInfo() const { return ColumnInf; }\n\n  int32_t getCodeOffset() const { return CodeOffset; }\n\n  uint32_t getStartLine() const { return LineInf.getStartLine(); }\n\n  uint32_t getLineDelta() const { return LineInf.getLineDelta(); }\n\n  uint32_t getEndLine() const { return LineInf.getEndLine(); }\n\n  uint16_t getStartColumn() const { return ColumnInf.getStartColumn(); }\n\n  uint16_t getEndColumn() const { return ColumnInf.getEndColumn(); }\n\n  bool isStatement() const { return LineInf.isStatement(); }\n\n  bool isAlwaysStepInto() const { return LineInf.isAlwaysStepInto(); }\n\n  bool isNeverStepInto() const { return LineInf.isNeverStepInto(); }\n};\n\n} // namespace codeview\n} // namespace llvm\n\n#endif\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeDeserializer.h", "content": "//===- TypeDeserializer.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_TYPEDESERIALIZER_H\n#define LLVM_DEBUGINFO_CODEVIEW_TYPEDESERIALIZER_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/DebugInfo/CodeView/CodeView.h\"\n#include \"llvm/DebugInfo/CodeView/TypeRecord.h\"\n#include \"llvm/DebugInfo/CodeView/TypeRecordMapping.h\"\n#include \"llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h\"\n#include \"llvm/Support/BinaryByteStream.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/Error.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\nnamespace codeview {\n\nclass TypeDeserializer : public TypeVisitorCallbacks {\n  struct MappingInfo {\n    explicit MappingInfo(ArrayRef<uint8_t> RecordData)\n        : Stream(RecordData, llvm::support::little), Reader(Stream),\n          Mapping(Reader) {}\n\n    BinaryByteStream Stream;\n    BinaryStreamReader Reader;\n    TypeRecordMapping Mapping;\n  };\n\npublic:\n  TypeDeserializer() = default;\n\n  template <typename T> static Error deserializeAs(CVType &CVT, T &Record) {\n    Record.Kind = static_cast<TypeRecordKind>(CVT.kind());\n    MappingInfo I(CVT.content());\n    if (auto EC = I.Mapping.visitTypeBegin(CVT))\n      return EC;\n    if (auto EC = I.Mapping.visitKnownRecord(CVT, Record))\n      return EC;\n    if (auto EC = I.Mapping.visitTypeEnd(CVT))\n      return EC;\n    return Error::success();\n  }\n\n  template <typename T>\n  static Expected<T> deserializeAs(ArrayRef<uint8_t> Data) {\n    const RecordPrefix *Prefix =\n        reinterpret_cast<const RecordPrefix *>(Data.data());\n    TypeRecordKind K =\n        static_cast<TypeRecordKind>(uint16_t(Prefix->RecordKind));\n    T Record(K);\n    CVType CVT(Data);\n    if (auto EC = deserializeAs<T>(CVT, Record))\n      return std::move(EC);\n    return Record;\n  }\n\n  Error visitTypeBegin(CVType &Record) override {\n    assert(!Mapping && \"Already in a type mapping!\");\n    Mapping = std::make_unique<MappingInfo>(Record.content());\n    return Mapping->Mapping.visitTypeBegin(Record);\n  }\n\n  Error visitTypeBegin(CVType &Record, TypeIndex Index) override {\n    return visitTypeBegin(Record);\n  }\n\n  Error visitTypeEnd(CVType &Record) override {\n    assert(Mapping && \"Not in a type mapping!\");\n    auto EC = Mapping->Mapping.visitTypeEnd(Record);\n    Mapping.reset();\n    return EC;\n  }\n\n#define TYPE_RECORD(EnumName, EnumVal, Name)                                   \\\n  Error visitKnownRecord(CVType &CVR, Name##Record &Record) override {         \\\n    return visitKnownRecordImpl<Name##Record>(CVR, Record);                    \\\n  }\n#define MEMBER_RECORD(EnumName, EnumVal, Name)\n#define TYPE_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)\n#define MEMBER_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)\n#include \"llvm/DebugInfo/CodeView/CodeViewTypes.def\"\n\nprivate:\n  template <typename RecordType>\n  Error visitKnownRecordImpl(CVType &CVR, RecordType &Record) {\n    return Mapping->Mapping.visitKnownRecord(CVR, Record);\n  }\n\n  std::unique_ptr<MappingInfo> Mapping;\n};\n\nclass FieldListDeserializer : public TypeVisitorCallbacks {\n  struct MappingInfo {\n    explicit MappingInfo(BinaryStreamReader &R)\n        : Reader(R), Mapping(Reader), StartOffset(0) {}\n\n    BinaryStreamReader &Reader;\n    TypeRecordMapping Mapping;\n    uint32_t StartOffset;\n  };\n\npublic:\n  explicit FieldListDeserializer(BinaryStreamReader &Reader) : Mapping(Reader) {\n    RecordPrefix Pre(static_cast<uint16_t>(TypeLeafKind::LF_FIELDLIST));\n    CVType FieldList(&Pre, sizeof(Pre));\n    consumeError(Mapping.Mapping.visitTypeBegin(FieldList));\n  }\n\n  ~FieldListDeserializer() override {\n    RecordPrefix Pre(static_cast<uint16_t>(TypeLeafKind::LF_FIELDLIST));\n    CVType FieldList(&Pre, sizeof(Pre));\n    consumeError(Mapping.Mapping.visitTypeEnd(FieldList));\n  }\n\n  Error visitMemberBegin(CVMemberRecord &Record) override {\n    Mapping.StartOffset = Mapping.Reader.getOffset();\n    return Mapping.Mapping.visitMemberBegin(Record);\n  }\n\n  Error visitMemberEnd(CVMemberRecord &Record) override {\n    if (auto EC = Mapping.Mapping.visitMemberEnd(Record))\n      return EC;\n    return Error::success();\n  }\n\n#define TYPE_RECORD(EnumName, EnumVal, Name)\n#define MEMBER_RECORD(EnumName, EnumVal, Name)                                 \\\n  Error visitKnownMember(CVMemberRecord &CVR, Name##Record &Record) override { \\\n    return visitKnownMemberImpl<Name##Record>(CVR, Record);                    \\\n  }\n#define TYPE_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)\n#define MEMBER_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)\n#include \"llvm/DebugInfo/CodeView/CodeViewTypes.def\"\n\nprivate:\n  template <typename RecordType>\n  Error visitKnownMemberImpl(CVMemberRecord &CVR, RecordType &Record) {\n    if (auto EC = Mapping.Mapping.visitKnownMember(CVR, Record))\n      return EC;\n\n    uint32_t EndOffset = Mapping.Reader.getOffset();\n    uint32_t RecordLength = EndOffset - Mapping.StartOffset;\n    Mapping.Reader.setOffset(Mapping.StartOffset);\n    if (auto EC = Mapping.Reader.readBytes(CVR.Data, RecordLength))\n      return EC;\n    assert(Mapping.Reader.getOffset() == EndOffset);\n    return Error::success();\n  }\n  MappingInfo Mapping;\n};\n\n} // end namespace codeview\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_CODEVIEW_TYPEDESERIALIZER_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeRecordMapping.h", "content": "//===- TypeRecordMapping.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_CODEVIEW_TYPERECORDMAPPING_H\n#define LLVM_DEBUGINFO_CODEVIEW_TYPERECORDMAPPING_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/DebugInfo/CodeView/CVTypeVisitor.h\"\n#include \"llvm/DebugInfo/CodeView/CodeViewRecordIO.h\"\n#include \"llvm/DebugInfo/CodeView/TypeVisitorCallbacks.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\nclass BinaryStreamReader;\nclass BinaryStreamWriter;\n\nnamespace codeview {\nclass TypeRecordMapping : public TypeVisitorCallbacks {\npublic:\n  explicit TypeRecordMapping(BinaryStreamReader &Reader) : IO(Reader) {}\n  explicit TypeRecordMapping(BinaryStreamWriter &Writer) : IO(Writer) {}\n  explicit TypeRecordMapping(CodeViewRecordStreamer &Streamer) : IO(Streamer) {}\n\n  using TypeVisitorCallbacks::visitTypeBegin;\n  Error visitTypeBegin(CVType &Record) override;\n  Error visitTypeBegin(CVType &Record, TypeIndex Index) override;\n  Error visitTypeEnd(CVType &Record) override;\n\n  Error visitMemberBegin(CVMemberRecord &Record) override;\n  Error visitMemberEnd(CVMemberRecord &Record) override;\n\n#define TYPE_RECORD(EnumName, EnumVal, Name)                                   \\\n  Error visitKnownRecord(CVType &CVR, Name##Record &Record) override;\n#define MEMBER_RECORD(EnumName, EnumVal, Name)                                 \\\n  Error visitKnownMember(CVMemberRecord &CVR, Name##Record &Record) override;\n#define TYPE_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)\n#define MEMBER_RECORD_ALIAS(EnumName, EnumVal, Name, AliasName)\n#include \"llvm/DebugInfo/CodeView/CodeViewTypes.def\"\n\nprivate:\n  Optional<TypeLeafKind> TypeKind;\n  Optional<TypeLeafKind> MemberKind;\n\n  CodeViewRecordIO IO;\n};\n}\n}\n\n#endif\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "content": "//===- MSFCommon.h - Common types and functions for MSF files ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n#define LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\nnamespace msf {\n\nstatic const char Magic[] = {'M',  'i',  'c',    'r', 'o', 's',  'o',  'f',\n                             't',  ' ',  'C',    '/', 'C', '+',  '+',  ' ',\n                             'M',  'S',  'F',    ' ', '7', '.',  '0',  '0',\n                             '\\r', '\\n', '\\x1a', 'D', 'S', '\\0', '\\0', '\\0'};\n\n// The superblock is overlaid at the beginning of the file (offset 0).\n// It starts with a magic header and is followed by information which\n// describes the layout of the file system.\nstruct SuperBlock {\n  char MagicBytes[sizeof(Magic)];\n  // The file system is split into a variable number of fixed size elements.\n  // These elements are referred to as blocks.  The size of a block may vary\n  // from system to system.\n  support::ulittle32_t BlockSize;\n  // The index of the free block map.\n  support::ulittle32_t FreeBlockMapBlock;\n  // This contains the number of blocks resident in the file system.  In\n  // practice, NumBlocks * BlockSize is equivalent to the size of the MSF\n  // file.\n  support::ulittle32_t NumBlocks;\n  // This contains the number of bytes which make up the directory.\n  support::ulittle32_t NumDirectoryBytes;\n  // This field's purpose is not yet known.\n  support::ulittle32_t Unknown1;\n  // This contains the block # of the block map.\n  support::ulittle32_t BlockMapAddr;\n};\n\nstruct MSFLayout {\n  MSFLayout() = default;\n\n  uint32_t mainFpmBlock() const {\n    assert(SB->FreeBlockMapBlock == 1 || SB->FreeBlockMapBlock == 2);\n    return SB->FreeBlockMapBlock;\n  }\n\n  uint32_t alternateFpmBlock() const {\n    // If mainFpmBlock is 1, this is 2.  If mainFpmBlock is 2, this is 1.\n    return 3U - mainFpmBlock();\n  }\n\n  const SuperBlock *SB = nullptr;\n  BitVector FreePageMap;\n  ArrayRef<support::ulittle32_t> DirectoryBlocks;\n  ArrayRef<support::ulittle32_t> StreamSizes;\n  std::vector<ArrayRef<support::ulittle32_t>> StreamMap;\n};\n\n/// Describes the layout of a stream in an MSF layout.  A \"stream\" here\n/// is defined as any logical unit of data which may be arranged inside the MSF\n/// file as a sequence of (possibly discontiguous) blocks.  When we want to read\n/// from a particular MSF Stream, we fill out a stream layout structure and the\n/// reader uses it to determine which blocks in the underlying MSF file contain\n/// the data, so that it can be pieced together in the right order.\nclass MSFStreamLayout {\npublic:\n  uint32_t Length;\n  std::vector<support::ulittle32_t> Blocks;\n};\n\n/// Determine the layout of the FPM stream, given the MSF layout.  An FPM\n/// stream spans 1 or more blocks, each at equally spaced intervals throughout\n/// the file.\nMSFStreamLayout getFpmStreamLayout(const MSFLayout &Msf,\n                                   bool IncludeUnusedFpmData = false,\n                                   bool AltFpm = false);\n\ninline bool isValidBlockSize(uint32_t Size) {\n  switch (Size) {\n  case 512:\n  case 1024:\n  case 2048:\n  case 4096:\n    return true;\n  }\n  return false;\n}\n\n// Super Block, Fpm0, Fpm1, and Block Map\ninline uint32_t getMinimumBlockCount() { return 4; }\n\n// Super Block, Fpm0, and Fpm1 are reserved.  The Block Map, although required\n// need not be at block 3.\ninline uint32_t getFirstUnreservedBlock() { return 3; }\n\ninline uint64_t bytesToBlocks(uint64_t NumBytes, uint64_t BlockSize) {\n  return divideCeil(NumBytes, BlockSize);\n}\n\ninline uint64_t blockToOffset(uint64_t BlockNumber, uint64_t BlockSize) {\n  return BlockNumber * BlockSize;\n}\n\ninline uint32_t getFpmIntervalLength(const MSFLayout &L) {\n  return L.SB->BlockSize;\n}\n\n/// Given an MSF with the specified block size and number of blocks, determine\n/// how many pieces the specified Fpm is split into.\n/// \\p BlockSize - the block size of the MSF\n/// \\p NumBlocks - the total number of blocks in the MSF\n/// \\p IncludeUnusedFpmData - When true, this will count every block that is\n///    both in the file and matches the form of an FPM block, even if some of\n///    those FPM blocks are unused (a single FPM block can describe the\n///    allocation status of up to 32,767 blocks, although one appears only\n///    every 4,096 blocks).  So there are 8x as many blocks that match the\n///    form as there are blocks that are necessary to describe the allocation\n///    status of the file.  When this parameter is false, these extraneous\n///    trailing blocks are not counted.\ninline uint32_t getNumFpmIntervals(uint32_t BlockSize, uint32_t NumBlocks,\n                                   bool IncludeUnusedFpmData, int FpmNumber) {\n  assert(FpmNumber == 1 || FpmNumber == 2);\n  if (IncludeUnusedFpmData) {\n    // This calculation determines how many times a number of the form\n    // BlockSize * k + N appears in the range [0, NumBlocks).  We only need to\n    // do this when unused data is included, since the number of blocks dwarfs\n    // the number of fpm blocks.\n    return divideCeil(NumBlocks - FpmNumber, BlockSize);\n  }\n\n  // We want the minimum number of intervals required, where each interval can\n  // represent BlockSize * 8 blocks.\n  return divideCeil(NumBlocks, 8 * BlockSize);\n}\n\ninline uint32_t getNumFpmIntervals(const MSFLayout &L,\n                                   bool IncludeUnusedFpmData = false,\n                                   bool AltFpm = false) {\n  return getNumFpmIntervals(L.SB->BlockSize, L.SB->NumBlocks,\n                            IncludeUnusedFpmData,\n                            AltFpm ? L.alternateFpmBlock() : L.mainFpmBlock());\n}\n\nError validateSuperBlock(const SuperBlock &SB);\n\n} // end namespace msf\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptor.h", "content": "//===- DbiModuleDescriptor.h - PDB module information -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULEDESCRIPTOR_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULEDESCRIPTOR_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawTypes.h\"\n#include \"llvm/Support/BinaryStreamArray.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nnamespace pdb {\n\nclass DbiModuleDescriptor {\n  friend class DbiStreamBuilder;\n\npublic:\n  DbiModuleDescriptor() = default;\n  DbiModuleDescriptor(const DbiModuleDescriptor &Info) = default;\n  DbiModuleDescriptor &operator=(const DbiModuleDescriptor &Info) = default;\n\n  static Error initialize(BinaryStreamRef Stream, DbiModuleDescriptor &Info);\n\n  bool hasECInfo() const;\n  uint16_t getTypeServerIndex() const;\n  uint16_t getModuleStreamIndex() const;\n  uint32_t getSymbolDebugInfoByteSize() const;\n  uint32_t getC11LineInfoByteSize() const;\n  uint32_t getC13LineInfoByteSize() const;\n  uint32_t getNumberOfFiles() const;\n  uint32_t getSourceFileNameIndex() const;\n  uint32_t getPdbFilePathNameIndex() const;\n\n  StringRef getModuleName() const;\n  StringRef getObjFileName() const;\n\n  uint32_t getRecordLength() const;\n\n  const SectionContrib &getSectionContrib() const;\n\nprivate:\n  StringRef ModuleName;\n  StringRef ObjFileName;\n  const ModuleInfoHeader *Layout = nullptr;\n};\n\n} // end namespace pdb\n\ntemplate <> struct VarStreamArrayExtractor<pdb::DbiModuleDescriptor> {\n  Error operator()(BinaryStreamRef Stream, uint32_t &Length,\n                   pdb::DbiModuleDescriptor &Info) {\n    if (auto EC = pdb::DbiModuleDescriptor::initialize(Stream, Info))\n      return EC;\n    Length = Info.getRecordLength();\n    return Error::success();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULEDESCRIPTOR_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleList.h", "content": "//===- DbiModuleList.h - PDB module information list ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULELIST_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULELIST_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/DebugInfo/PDB/Native/DbiModuleDescriptor.h\"\n#include \"llvm/Support/BinaryStreamArray.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <vector>\n\nnamespace llvm {\nnamespace pdb {\n\nclass DbiModuleList;\nstruct FileInfoSubstreamHeader;\n\nclass DbiModuleSourceFilesIterator\n    : public iterator_facade_base<DbiModuleSourceFilesIterator,\n                                  std::random_access_iterator_tag, StringRef> {\n  using BaseType =\n      iterator_facade_base<DbiModuleSourceFilesIterator,\n                           std::random_access_iterator_tag, StringRef>;\n\npublic:\n  DbiModuleSourceFilesIterator(const DbiModuleList &Modules, uint32_t Modi,\n                               uint16_t Filei);\n  DbiModuleSourceFilesIterator() = default;\n  DbiModuleSourceFilesIterator(const DbiModuleSourceFilesIterator &R) = default;\n  DbiModuleSourceFilesIterator &\n  operator=(const DbiModuleSourceFilesIterator &R) = default;\n\n  bool operator==(const DbiModuleSourceFilesIterator &R) const;\n\n  const StringRef &operator*() const { return ThisValue; }\n  StringRef &operator*() { return ThisValue; }\n\n  bool operator<(const DbiModuleSourceFilesIterator &RHS) const;\n  std::ptrdiff_t operator-(const DbiModuleSourceFilesIterator &R) const;\n  DbiModuleSourceFilesIterator &operator+=(std::ptrdiff_t N);\n  DbiModuleSourceFilesIterator &operator-=(std::ptrdiff_t N);\n\nprivate:\n  void setValue();\n\n  bool isEnd() const;\n  bool isCompatible(const DbiModuleSourceFilesIterator &R) const;\n  bool isUniversalEnd() const;\n\n  StringRef ThisValue;\n  const DbiModuleList *Modules{nullptr};\n  uint32_t Modi{0};\n  uint16_t Filei{0};\n};\n\nclass DbiModuleList {\n  friend DbiModuleSourceFilesIterator;\n\npublic:\n  Error initialize(BinaryStreamRef ModInfo, BinaryStreamRef FileInfo);\n\n  Expected<StringRef> getFileName(uint32_t Index) const;\n  uint32_t getModuleCount() const;\n  uint32_t getSourceFileCount() const;\n  uint16_t getSourceFileCount(uint32_t Modi) const;\n\n  iterator_range<DbiModuleSourceFilesIterator>\n  source_files(uint32_t Modi) const;\n\n  DbiModuleDescriptor getModuleDescriptor(uint32_t Modi) const;\n\nprivate:\n  Error initializeModInfo(BinaryStreamRef ModInfo);\n  Error initializeFileInfo(BinaryStreamRef FileInfo);\n\n  VarStreamArray<DbiModuleDescriptor> Descriptors;\n\n  FixedStreamArray<support::little32_t> FileNameOffsets;\n  FixedStreamArray<support::ulittle16_t> ModFileCountArray;\n\n  // For each module, there are multiple filenames, which can be obtained by\n  // knowing the index of the file.  Given the index of the file, one can use\n  // that as an offset into the FileNameOffsets array, which contains the\n  // absolute offset of the file name in NamesBuffer.  Thus, for each module\n  // we store the first index in the FileNameOffsets array for this module.\n  // The number of files for the corresponding module is stored in\n  // ModFileCountArray.\n  std::vector<uint32_t> ModuleInitialFileIndex;\n\n  // In order to provide random access into the Descriptors array, we iterate it\n  // once up front to find the offsets of the individual items and store them in\n  // this array.\n  std::vector<uint32_t> ModuleDescriptorOffsets;\n\n  const FileInfoSubstreamHeader *FileInfoHeader = nullptr;\n\n  BinaryStreamRef ModInfoSubstream;\n  BinaryStreamRef FileInfoSubstream;\n  BinaryStreamRef NamesBuffer;\n};\n\n} // end namespace pdb\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_DBIMODULELIST_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/HashTable.h", "content": "//===- HashTable.h - PDB Hash Table -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_HASHTABLE_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_HASHTABLE_H\n\n#include \"llvm/ADT/SparseBitVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawError.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/BinaryStreamWriter.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n#include <iterator>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass BinaryStreamReader;\nclass BinaryStreamWriter;\n\nnamespace pdb {\n\nError readSparseBitVector(BinaryStreamReader &Stream, SparseBitVector<> &V);\nError writeSparseBitVector(BinaryStreamWriter &Writer, SparseBitVector<> &Vec);\n\ntemplate <typename ValueT> class HashTable;\n\ntemplate <typename ValueT>\nclass HashTableIterator\n    : public iterator_facade_base<HashTableIterator<ValueT>,\n                                  std::forward_iterator_tag,\n                                  const std::pair<uint32_t, ValueT>> {\n  friend HashTable<ValueT>;\n\n  HashTableIterator(const HashTable<ValueT> &Map, uint32_t Index,\n                    bool IsEnd)\n      : Map(&Map), Index(Index), IsEnd(IsEnd) {}\n\npublic:\n  HashTableIterator(const HashTable<ValueT> &Map) : Map(&Map) {\n    int I = Map.Present.find_first();\n    if (I == -1) {\n      Index = 0;\n      IsEnd = true;\n    } else {\n      Index = static_cast<uint32_t>(I);\n      IsEnd = false;\n    }\n  }\n\n  HashTableIterator(const HashTableIterator &R) = default;\n  HashTableIterator &operator=(const HashTableIterator &R) {\n    Map = R.Map;\n    return *this;\n  }\n  bool operator==(const HashTableIterator &R) const {\n    if (IsEnd && R.IsEnd)\n      return true;\n    if (IsEnd != R.IsEnd)\n      return false;\n\n    return (Map == R.Map) && (Index == R.Index);\n  }\n  const std::pair<uint32_t, ValueT> &operator*() const {\n    assert(Map->Present.test(Index));\n    return Map->Buckets[Index];\n  }\n\n  // Implement postfix op++ in terms of prefix op++ by using the superclass\n  // implementation.\n  using iterator_facade_base<HashTableIterator<ValueT>,\n                             std::forward_iterator_tag,\n                             const std::pair<uint32_t, ValueT>>::operator++;\n  HashTableIterator &operator++() {\n    while (Index < Map->Buckets.size()) {\n      ++Index;\n      if (Map->Present.test(Index))\n        return *this;\n    }\n\n    IsEnd = true;\n    return *this;\n  }\n\nprivate:\n  bool isEnd() const { return IsEnd; }\n  uint32_t index() const { return Index; }\n\n  const HashTable<ValueT> *Map;\n  uint32_t Index;\n  bool IsEnd;\n};\n\ntemplate <typename ValueT>\nclass HashTable {\n  struct Header {\n    support::ulittle32_t Size;\n    support::ulittle32_t Capacity;\n  };\n\n  using BucketList = std::vector<std::pair<uint32_t, ValueT>>;\n\npublic:\n  using const_iterator = HashTableIterator<ValueT>;\n  friend const_iterator;\n\n  HashTable() { Buckets.resize(8); }\n  explicit HashTable(uint32_t Capacity) {\n    Buckets.resize(Capacity);\n  }\n\n  Error load(BinaryStreamReader &Stream) {\n    const Header *H;\n    if (auto EC = Stream.readObject(H))\n      return EC;\n    if (H->Capacity == 0)\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Invalid Hash Table Capacity\");\n    if (H->Size > maxLoad(H->Capacity))\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Invalid Hash Table Size\");\n\n    Buckets.resize(H->Capacity);\n\n    if (auto EC = readSparseBitVector(Stream, Present))\n      return EC;\n    if (Present.count() != H->Size)\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Present bit vector does not match size!\");\n\n    if (auto EC = readSparseBitVector(Stream, Deleted))\n      return EC;\n    if (Present.intersects(Deleted))\n      return make_error<RawError>(raw_error_code::corrupt_file,\n                                  \"Present bit vector intersects deleted!\");\n\n    for (uint32_t P : Present) {\n      if (auto EC = Stream.readInteger(Buckets[P].first))\n        return EC;\n      const ValueT *Value;\n      if (auto EC = Stream.readObject(Value))\n        return EC;\n      Buckets[P].second = *Value;\n    }\n\n    return Error::success();\n  }\n\n  uint32_t calculateSerializedLength() const {\n    uint32_t Size = sizeof(Header);\n\n    constexpr int BitsPerWord = 8 * sizeof(uint32_t);\n\n    int NumBitsP = Present.find_last() + 1;\n    int NumBitsD = Deleted.find_last() + 1;\n\n    uint32_t NumWordsP = alignTo(NumBitsP, BitsPerWord) / BitsPerWord;\n    uint32_t NumWordsD = alignTo(NumBitsD, BitsPerWord) / BitsPerWord;\n\n    // Present bit set number of words (4 bytes), followed by that many actual\n    // words (4 bytes each).\n    Size += sizeof(uint32_t);\n    Size += NumWordsP * sizeof(uint32_t);\n\n    // Deleted bit set number of words (4 bytes), followed by that many actual\n    // words (4 bytes each).\n    Size += sizeof(uint32_t);\n    Size += NumWordsD * sizeof(uint32_t);\n\n    // One (Key, ValueT) pair for each entry Present.\n    Size += (sizeof(uint32_t) + sizeof(ValueT)) * size();\n\n    return Size;\n  }\n\n  Error commit(BinaryStreamWriter &Writer) const {\n    Header H;\n    H.Size = size();\n    H.Capacity = capacity();\n    if (auto EC = Writer.writeObject(H))\n      return EC;\n\n    if (auto EC = writeSparseBitVector(Writer, Present))\n      return EC;\n\n    if (auto EC = writeSparseBitVector(Writer, Deleted))\n      return EC;\n\n    for (const auto &Entry : *this) {\n      if (auto EC = Writer.writeInteger(Entry.first))\n        return EC;\n      if (auto EC = Writer.writeObject(Entry.second))\n        return EC;\n    }\n    return Error::success();\n  }\n\n  void clear() {\n    Buckets.resize(8);\n    Present.clear();\n    Deleted.clear();\n  }\n\n  bool empty() const { return size() == 0; }\n  uint32_t capacity() const { return Buckets.size(); }\n  uint32_t size() const { return Present.count(); }\n\n  const_iterator begin() const { return const_iterator(*this); }\n  const_iterator end() const { return const_iterator(*this, 0, true); }\n\n  /// Find the entry whose key has the specified hash value, using the specified\n  /// traits defining hash function and equality.\n  template <typename Key, typename TraitsT>\n  const_iterator find_as(const Key &K, TraitsT &Traits) const {\n    uint32_t H = Traits.hashLookupKey(K) % capacity();\n    uint32_t I = H;\n    Optional<uint32_t> FirstUnused;\n    do {\n      if (isPresent(I)) {\n        if (Traits.storageKeyToLookupKey(Buckets[I].first) == K)\n          return const_iterator(*this, I, false);\n      } else {\n        if (!FirstUnused)\n          FirstUnused = I;\n        // Insertion occurs via linear probing from the slot hint, and will be\n        // inserted at the first empty / deleted location.  Therefore, if we are\n        // probing and find a location that is neither present nor deleted, then\n        // nothing must have EVER been inserted at this location, and thus it is\n        // not possible for a matching value to occur later.\n        if (!isDeleted(I))\n          break;\n      }\n      I = (I + 1) % capacity();\n    } while (I != H);\n\n    // The only way FirstUnused would not be set is if every single entry in the\n    // table were Present.  But this would violate the load factor constraints\n    // that we impose, so it should never happen.\n    assert(FirstUnused);\n    return const_iterator(*this, *FirstUnused, true);\n  }\n\n  /// Set the entry using a key type that the specified Traits can convert\n  /// from a real key to an internal key.\n  template <typename Key, typename TraitsT>\n  bool set_as(const Key &K, ValueT V, TraitsT &Traits) {\n    return set_as_internal(K, std::move(V), Traits, None);\n  }\n\n  template <typename Key, typename TraitsT>\n  ValueT get(const Key &K, TraitsT &Traits) const {\n    auto Iter = find_as(K, Traits);\n    assert(Iter != end());\n    return (*Iter).second;\n  }\n\nprotected:\n  bool isPresent(uint32_t K) const { return Present.test(K); }\n  bool isDeleted(uint32_t K) const { return Deleted.test(K); }\n\n  BucketList Buckets;\n  mutable SparseBitVector<> Present;\n  mutable SparseBitVector<> Deleted;\n\nprivate:\n  /// Set the entry using a key type that the specified Traits can convert\n  /// from a real key to an internal key.\n  template <typename Key, typename TraitsT>\n  bool set_as_internal(const Key &K, ValueT V, TraitsT &Traits,\n                       Optional<uint32_t> InternalKey) {\n    auto Entry = find_as(K, Traits);\n    if (Entry != end()) {\n      assert(isPresent(Entry.index()));\n      assert(Traits.storageKeyToLookupKey(Buckets[Entry.index()].first) == K);\n      // We're updating, no need to do anything special.\n      Buckets[Entry.index()].second = V;\n      return false;\n    }\n\n    auto &B = Buckets[Entry.index()];\n    assert(!isPresent(Entry.index()));\n    assert(Entry.isEnd());\n    B.first = InternalKey ? *InternalKey : Traits.lookupKeyToStorageKey(K);\n    B.second = V;\n    Present.set(Entry.index());\n    Deleted.reset(Entry.index());\n\n    grow(Traits);\n\n    assert((find_as(K, Traits)) != end());\n    return true;\n  }\n\n  static uint32_t maxLoad(uint32_t capacity) { return capacity * 2 / 3 + 1; }\n\n  template <typename TraitsT>\n  void grow(TraitsT &Traits) {\n    uint32_t S = size();\n    uint32_t MaxLoad = maxLoad(capacity());\n    if (S < maxLoad(capacity()))\n      return;\n    assert(capacity() != UINT32_MAX && \"Can't grow Hash table!\");\n\n    uint32_t NewCapacity = (capacity() <= INT32_MAX) ? MaxLoad * 2 : UINT32_MAX;\n\n    // Growing requires rebuilding the table and re-hashing every item.  Make a\n    // copy with a larger capacity, insert everything into the copy, then swap\n    // it in.\n    HashTable NewMap(NewCapacity);\n    for (auto I : Present) {\n      auto LookupKey = Traits.storageKeyToLookupKey(Buckets[I].first);\n      NewMap.set_as_internal(LookupKey, Buckets[I].second, Traits,\n                             Buckets[I].first);\n    }\n\n    Buckets.swap(NewMap.Buckets);\n    std::swap(Present, NewMap.Present);\n    std::swap(Deleted, NewMap.Deleted);\n    assert(capacity() == NewCapacity);\n    assert(size() == S);\n  }\n};\n\n} // end namespace pdb\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_HASHTABLE_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InjectedSourceStream.h", "content": "//===- InjectedSourceStream.h - PDB Headerblock Stream Access ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_INJECTEDSOURCESTREAM_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_INJECTEDSOURCESTREAM_H\n\n#include \"llvm/DebugInfo/PDB/Native/HashTable.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawTypes.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\nnamespace msf {\nclass MappedBlockStream;\n}\nnamespace pdb {\nclass PDBStringTable;\n\nclass InjectedSourceStream {\npublic:\n  InjectedSourceStream(std::unique_ptr<msf::MappedBlockStream> Stream);\n  Error reload(const PDBStringTable &Strings);\n\n  using const_iterator = HashTable<SrcHeaderBlockEntry>::const_iterator;\n  const_iterator begin() const { return InjectedSourceTable.begin(); }\n  const_iterator end() const { return InjectedSourceTable.end(); }\n\n  uint32_t size() const { return InjectedSourceTable.size(); }\n\nprivate:\n  std::unique_ptr<msf::MappedBlockStream> Stream;\n\n  const SrcHeaderBlockHeader* Header;\n  HashTable<SrcHeaderBlockEntry> InjectedSourceTable;\n};\n}\n}\n\n#endif\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/ModuleDebugStream.h", "content": "//===- ModuleDebugStream.h - PDB Module Info Stream Access ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_MODULEDEBUGSTREAM_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_MODULEDEBUGSTREAM_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h\"\n#include \"llvm/DebugInfo/CodeView/DebugSubsectionRecord.h\"\n#include \"llvm/DebugInfo/CodeView/SymbolRecord.h\"\n#include \"llvm/DebugInfo/MSF/MappedBlockStream.h\"\n#include \"llvm/DebugInfo/PDB/Native/DbiModuleDescriptor.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\nnamespace pdb {\n\nclass DbiModuleDescriptor;\n\nclass ModuleDebugStreamRef {\n  using DebugSubsectionIterator = codeview::DebugSubsectionArray::Iterator;\n\npublic:\n  ModuleDebugStreamRef(const DbiModuleDescriptor &Module,\n                       std::unique_ptr<msf::MappedBlockStream> Stream);\n  ModuleDebugStreamRef(ModuleDebugStreamRef &&Other) = default;\n  ModuleDebugStreamRef(const ModuleDebugStreamRef &Other) = default;\n  ~ModuleDebugStreamRef();\n\n  Error reload();\n\n  uint32_t signature() const { return Signature; }\n\n  iterator_range<codeview::CVSymbolArray::Iterator>\n  symbols(bool *HadError) const;\n\n  const codeview::CVSymbolArray &getSymbolArray() const { return SymbolArray; }\n  const codeview::CVSymbolArray\n  getSymbolArrayForScope(uint32_t ScopeBegin) const;\n\n  BinarySubstreamRef getSymbolsSubstream() const;\n  BinarySubstreamRef getC11LinesSubstream() const;\n  BinarySubstreamRef getC13LinesSubstream() const;\n  BinarySubstreamRef getGlobalRefsSubstream() const;\n\n  ModuleDebugStreamRef &operator=(ModuleDebugStreamRef &&Other) = delete;\n\n  codeview::CVSymbol readSymbolAtOffset(uint32_t Offset) const;\n\n  iterator_range<DebugSubsectionIterator> subsections() const;\n  codeview::DebugSubsectionArray getSubsectionsArray() const {\n    return Subsections;\n  }\n\n  bool hasDebugSubsections() const;\n\n  Error commit();\n\n  Expected<codeview::DebugChecksumsSubsectionRef>\n  findChecksumsSubsection() const;\n\nprivate:\n  Error reloadSerialize(BinaryStreamReader &Reader);\n\n  DbiModuleDescriptor Mod;\n\n  uint32_t Signature;\n\n  std::shared_ptr<msf::MappedBlockStream> Stream;\n\n  codeview::CVSymbolArray SymbolArray;\n\n  BinarySubstreamRef SymbolsSubstream;\n  BinarySubstreamRef C11LinesSubstream;\n  BinarySubstreamRef C13LinesSubstream;\n  BinarySubstreamRef GlobalRefsSubstream;\n\n  codeview::DebugSubsectionArray Subsections;\n};\n\n} // end namespace pdb\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_MODULEDEBUGSTREAM_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeCompilandSymbol.h", "content": "//===- NativeCompilandSymbol.h - native impl for compiland syms -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_NATIVECOMPILANDSYMBOL_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_NATIVECOMPILANDSYMBOL_H\n\n#include \"llvm/DebugInfo/PDB/Native/DbiModuleDescriptor.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeRawSymbol.h\"\n\nnamespace llvm {\nnamespace pdb {\n\nclass NativeCompilandSymbol : public NativeRawSymbol {\npublic:\n  NativeCompilandSymbol(NativeSession &Session, SymIndexId SymbolId,\n                        DbiModuleDescriptor MI);\n\n  void dump(raw_ostream &OS, int Indent, PdbSymbolIdField ShowIdFields,\n            PdbSymbolIdField RecurseIdFields) const override;\n\n  PDB_SymType getSymTag() const override;\n  bool isEditAndContinueEnabled() const override;\n  SymIndexId getLexicalParentId() const override;\n  std::string getLibraryName() const override;\n  std::string getName() const override;\n\nprivate:\n  DbiModuleDescriptor Module;\n};\n\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeEnumInjectedSources.h", "content": "//==- NativeEnumInjectedSources.cpp - Native Injected Source Enumerator --*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_NATIVEENUMINJECTEDSOURCES_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_NATIVEENUMINJECTEDSOURCES_H\n\n#include \"llvm/DebugInfo/PDB/IPDBEnumChildren.h\"\n#include \"llvm/DebugInfo/PDB/IPDBInjectedSource.h\"\n#include \"llvm/DebugInfo/PDB/Native/InjectedSourceStream.h\"\n\nnamespace llvm {\nnamespace pdb {\n\nclass InjectedSourceStream;\nclass PDBFile;\nclass PDBStringTable;\n\nclass NativeEnumInjectedSources : public IPDBEnumChildren<IPDBInjectedSource> {\npublic:\n  NativeEnumInjectedSources(PDBFile &File, const InjectedSourceStream &IJS,\n                            const PDBStringTable &Strings);\n\n  uint32_t getChildCount() const override;\n  std::unique_ptr<IPDBInjectedSource>\n  getChildAtIndex(uint32_t Index) const override;\n  std::unique_ptr<IPDBInjectedSource> getNext() override;\n  void reset() override;\n\nprivate:\n  PDBFile &File;\n  const InjectedSourceStream &Stream;\n  const PDBStringTable &Strings;\n  InjectedSourceStream::const_iterator Cur;\n};\n\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeEnumTypes.h", "content": "//==- NativeEnumTypes.h - Native Type Enumerator impl ------------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_NATIVEENUMTYPES_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_NATIVEENUMTYPES_H\n\n#include \"llvm/DebugInfo/CodeView/LazyRandomTypeCollection.h\"\n#include \"llvm/DebugInfo/CodeView/TypeRecord.h\"\n#include \"llvm/DebugInfo/PDB/IPDBEnumChildren.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbol.h\"\n\n#include <vector>\n\nnamespace llvm {\nnamespace pdb {\n\nclass NativeSession;\n\nclass NativeEnumTypes : public IPDBEnumChildren<PDBSymbol> {\npublic:\n  NativeEnumTypes(NativeSession &Session,\n                  codeview::LazyRandomTypeCollection &TypeCollection,\n                  std::vector<codeview::TypeLeafKind> Kinds);\n\n  NativeEnumTypes(NativeSession &Session,\n                  std::vector<codeview::TypeIndex> Indices);\n\n  uint32_t getChildCount() const override;\n  std::unique_ptr<PDBSymbol> getChildAtIndex(uint32_t Index) const override;\n  std::unique_ptr<PDBSymbol> getNext() override;\n  void reset() override;\n\nprivate:\n  std::vector<codeview::TypeIndex> Matches;\n  uint32_t Index;\n  NativeSession &Session;\n};\n\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeExeSymbol.h", "content": "//===- NativeExeSymbol.h - native impl for PDBSymbolExe ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_NATIVEEXESYMBOL_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_NATIVEEXESYMBOL_H\n\n#include \"llvm/DebugInfo/PDB/Native/NativeRawSymbol.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeSession.h\"\n\nnamespace llvm {\nnamespace pdb {\n\nclass DbiStream;\n\nclass NativeExeSymbol : public NativeRawSymbol {\n  // EXE symbol is the authority on the various symbol types.\n  DbiStream *Dbi = nullptr;\n\npublic:\n  NativeExeSymbol(NativeSession &Session, SymIndexId Id);\n\n  std::unique_ptr<IPDBEnumSymbols>\n  findChildren(PDB_SymType Type) const override;\n\n  uint32_t getAge() const override;\n  std::string getSymbolsFileName() const override;\n  codeview::GUID getGuid() const override;\n  bool hasCTypes() const override;\n  bool hasPrivateSymbols() const override;\n};\n\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeRawSymbol.h", "content": "//==- NativeRawSymbol.h - Native implementation of IPDBRawSymbol -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_NATIVERAWSYMBOL_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_NATIVERAWSYMBOL_H\n\n#include \"llvm/DebugInfo/PDB/IPDBRawSymbol.h\"\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\nnamespace pdb {\n\nclass NativeSession;\n\nclass NativeRawSymbol : public IPDBRawSymbol {\n  friend class SymbolCache;\n  virtual void initialize() {}\n\npublic:\n  NativeRawSymbol(NativeSession &PDBSession, PDB_SymType Tag,\n                  SymIndexId SymbolId);\n\n  void dump(raw_ostream &OS, int Indent, PdbSymbolIdField ShowIdFields,\n            PdbSymbolIdField RecurseIdFields) const override;\n\n  std::unique_ptr<IPDBEnumSymbols>\n    findChildren(PDB_SymType Type) const override;\n  std::unique_ptr<IPDBEnumSymbols>\n    findChildren(PDB_SymType Type, StringRef Name,\n      PDB_NameSearchFlags Flags) const override;\n  std::unique_ptr<IPDBEnumSymbols>\n    findChildrenByAddr(PDB_SymType Type, StringRef Name,\n                       PDB_NameSearchFlags Flags,\n                       uint32_t Section, uint32_t Offset) const override;\n  std::unique_ptr<IPDBEnumSymbols>\n    findChildrenByVA(PDB_SymType Type, StringRef Name, PDB_NameSearchFlags Flags,\n                     uint64_t VA) const override;\n  std::unique_ptr<IPDBEnumSymbols>\n    findChildrenByRVA(PDB_SymType Type, StringRef Name, PDB_NameSearchFlags Flags,\n      uint32_t RVA) const override;\n\n  std::unique_ptr<IPDBEnumSymbols>\n    findInlineFramesByAddr(uint32_t Section, uint32_t Offset) const override;\n  std::unique_ptr<IPDBEnumSymbols>\n    findInlineFramesByRVA(uint32_t RVA) const override;\n  std::unique_ptr<IPDBEnumSymbols>\n    findInlineFramesByVA(uint64_t VA) const override;\n\n  std::unique_ptr<IPDBEnumLineNumbers> findInlineeLines() const override;\n  std::unique_ptr<IPDBEnumLineNumbers>\n    findInlineeLinesByAddr(uint32_t Section, uint32_t Offset,\n                           uint32_t Length) const override;\n  std::unique_ptr<IPDBEnumLineNumbers>\n    findInlineeLinesByRVA(uint32_t RVA, uint32_t Length) const override;\n  std::unique_ptr<IPDBEnumLineNumbers>\n    findInlineeLinesByVA(uint64_t VA, uint32_t Length) const override;\n\n  void getDataBytes(SmallVector<uint8_t, 32> &Bytes) const override;\n  void getFrontEndVersion(VersionInfo &Version) const override;\n  void getBackEndVersion(VersionInfo &Version) const override;\n  PDB_MemberAccess getAccess() const override;\n  uint32_t getAddressOffset() const override;\n  uint32_t getAddressSection() const override;\n  uint32_t getAge() const override;\n  SymIndexId getArrayIndexTypeId() const override;\n  uint32_t getBaseDataOffset() const override;\n  uint32_t getBaseDataSlot() const override;\n  SymIndexId getBaseSymbolId() const override;\n  PDB_BuiltinType getBuiltinType() const override;\n  uint32_t getBitPosition() const override;\n  PDB_CallingConv getCallingConvention() const override;\n  SymIndexId getClassParentId() const override;\n  std::string getCompilerName() const override;\n  uint32_t getCount() const override;\n  uint32_t getCountLiveRanges() const override;\n  PDB_Lang getLanguage() const override;\n  SymIndexId getLexicalParentId() const override;\n  std::string getLibraryName() const override;\n  uint32_t getLiveRangeStartAddressOffset() const override;\n  uint32_t getLiveRangeStartAddressSection() const override;\n  uint32_t getLiveRangeStartRelativeVirtualAddress() const override;\n  codeview::RegisterId getLocalBasePointerRegisterId() const override;\n  SymIndexId getLowerBoundId() const override;\n  uint32_t getMemorySpaceKind() const override;\n  std::string getName() const override;\n  uint32_t getNumberOfAcceleratorPointerTags() const override;\n  uint32_t getNumberOfColumns() const override;\n  uint32_t getNumberOfModifiers() const override;\n  uint32_t getNumberOfRegisterIndices() const override;\n  uint32_t getNumberOfRows() const override;\n  std::string getObjectFileName() const override;\n  uint32_t getOemId() const override;\n  SymIndexId getOemSymbolId() const override;\n  uint32_t getOffsetInUdt() const override;\n  PDB_Cpu getPlatform() const override;\n  uint32_t getRank() const override;\n  codeview::RegisterId getRegisterId() const override;\n  uint32_t getRegisterType() const override;\n  uint32_t getRelativeVirtualAddress() const override;\n  uint32_t getSamplerSlot() const override;\n  uint32_t getSignature() const override;\n  uint32_t getSizeInUdt() const override;\n  uint32_t getSlot() const override;\n  std::string getSourceFileName() const override;\n  std::unique_ptr<IPDBLineNumber> getSrcLineOnTypeDefn() const override;\n  uint32_t getStride() const override;\n  SymIndexId getSubTypeId() const override;\n  std::string getSymbolsFileName() const override;\n  SymIndexId getSymIndexId() const override;\n  uint32_t getTargetOffset() const override;\n  uint32_t getTargetRelativeVirtualAddress() const override;\n  uint64_t getTargetVirtualAddress() const override;\n  uint32_t getTargetSection() const override;\n  uint32_t getTextureSlot() const override;\n  uint32_t getTimeStamp() const override;\n  uint32_t getToken() const override;\n  SymIndexId getTypeId() const override;\n  uint32_t getUavSlot() const override;\n  std::string getUndecoratedName() const override;\n  std::string getUndecoratedNameEx(PDB_UndnameFlags Flags) const override;\n  SymIndexId getUnmodifiedTypeId() const override;\n  SymIndexId getUpperBoundId() const override;\n  Variant getValue() const override;\n  uint32_t getVirtualBaseDispIndex() const override;\n  uint32_t getVirtualBaseOffset() const override;\n  SymIndexId getVirtualTableShapeId() const override;\n  std::unique_ptr<PDBSymbolTypeBuiltin>\n  getVirtualBaseTableType() const override;\n  PDB_DataKind getDataKind() const override;\n  PDB_SymType getSymTag() const override;\n  codeview::GUID getGuid() const override;\n  int32_t getOffset() const override;\n  int32_t getThisAdjust() const override;\n  int32_t getVirtualBasePointerOffset() const override;\n  PDB_LocType getLocationType() const override;\n  PDB_Machine getMachineType() const override;\n  codeview::ThunkOrdinal getThunkOrdinal() const override;\n  uint64_t getLength() const override;\n  uint64_t getLiveRangeLength() const override;\n  uint64_t getVirtualAddress() const override;\n  PDB_UdtType getUdtKind() const override;\n  bool hasConstructor() const override;\n  bool hasCustomCallingConvention() const override;\n  bool hasFarReturn() const override;\n  bool isCode() const override;\n  bool isCompilerGenerated() const override;\n  bool isConstType() const override;\n  bool isEditAndContinueEnabled() const override;\n  bool isFunction() const override;\n  bool getAddressTaken() const override;\n  bool getNoStackOrdering() const override;\n  bool hasAlloca() const override;\n  bool hasAssignmentOperator() const override;\n  bool hasCTypes() const override;\n  bool hasCastOperator() const override;\n  bool hasDebugInfo() const override;\n  bool hasEH() const override;\n  bool hasEHa() const override;\n  bool hasInlAsm() const override;\n  bool hasInlineAttribute() const override;\n  bool hasInterruptReturn() const override;\n  bool hasFramePointer() const override;\n  bool hasLongJump() const override;\n  bool hasManagedCode() const override;\n  bool hasNestedTypes() const override;\n  bool hasNoInlineAttribute() const override;\n  bool hasNoReturnAttribute() const override;\n  bool hasOptimizedCodeDebugInfo() const override;\n  bool hasOverloadedOperator() const override;\n  bool hasSEH() const override;\n  bool hasSecurityChecks() const override;\n  bool hasSetJump() const override;\n  bool hasStrictGSCheck() const override;\n  bool isAcceleratorGroupSharedLocal() const override;\n  bool isAcceleratorPointerTagLiveRange() const override;\n  bool isAcceleratorStubFunction() const override;\n  bool isAggregated() const override;\n  bool isIntroVirtualFunction() const override;\n  bool isCVTCIL() const override;\n  bool isConstructorVirtualBase() const override;\n  bool isCxxReturnUdt() const override;\n  bool isDataAligned() const override;\n  bool isHLSLData() const override;\n  bool isHotpatchable() const override;\n  bool isIndirectVirtualBaseClass() const override;\n  bool isInterfaceUdt() const override;\n  bool isIntrinsic() const override;\n  bool isLTCG() const override;\n  bool isLocationControlFlowDependent() const override;\n  bool isMSILNetmodule() const override;\n  bool isMatrixRowMajor() const override;\n  bool isManagedCode() const override;\n  bool isMSILCode() const override;\n  bool isMultipleInheritance() const override;\n  bool isNaked() const override;\n  bool isNested() const override;\n  bool isOptimizedAway() const override;\n  bool isPacked() const override;\n  bool isPointerBasedOnSymbolValue() const override;\n  bool isPointerToDataMember() const override;\n  bool isPointerToMemberFunction() const override;\n  bool isPureVirtual() const override;\n  bool isRValueReference() const override;\n  bool isRefUdt() const override;\n  bool isReference() const override;\n  bool isRestrictedType() const override;\n  bool isReturnValue() const override;\n  bool isSafeBuffers() const override;\n  bool isScoped() const override;\n  bool isSdl() const override;\n  bool isSingleInheritance() const override;\n  bool isSplitted() const override;\n  bool isStatic() const override;\n  bool hasPrivateSymbols() const override;\n  bool isUnalignedType() const override;\n  bool isUnreached() const override;\n  bool isValueUdt() const override;\n  bool isVirtual() const override;\n  bool isVirtualBaseClass() const override;\n  bool isVirtualInheritance() const override;\n  bool isVolatileType() const override;\n  bool wasInlined() const override;\n  std::string getUnused() const override;\n\nprotected:\n  NativeSession &Session;\n  PDB_SymType Tag;\n  SymIndexId SymbolId;\n};\n\n} // end namespace pdb\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_NATIVERAWSYMBOL_H\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeSourceFile.h", "content": "//===- NativeSourceFile.h - Native source file implementation ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_NATIVESOURCEFILE_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_NATIVESOURCEFILE_H\n\n#include \"llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h\"\n#include \"llvm/DebugInfo/PDB/IPDBSourceFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBStringTable.h\"\n\nnamespace llvm {\nnamespace pdb {\nclass NativeSession;\n\nclass NativeSourceFile : public IPDBSourceFile {\npublic:\n  explicit NativeSourceFile(NativeSession &Session, uint32_t FileId,\n                            const codeview::FileChecksumEntry &Checksum);\n\n  std::string getFileName() const override;\n  uint32_t getUniqueId() const override;\n  std::string getChecksum() const override;\n  PDB_Checksum getChecksumType() const override;\n  std::unique_ptr<IPDBEnumChildren<PDBSymbolCompiland>>\n  getCompilands() const override;\n\nprivate:\n  NativeSession &Session;\n  uint32_t FileId;\n  const codeview::FileChecksumEntry Checksum;\n};\n} // namespace pdb\n} // namespace llvm\n#endif\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBStringTable.h", "content": "//===- PDBStringTable.h - PDB String Table -----------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_PDBSTRINGTABLE_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_PDBSTRINGTABLE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/DebugInfo/CodeView/DebugStringTableSubsection.h\"\n#include \"llvm/Support/BinaryStreamArray.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n\nnamespace llvm {\nclass BinaryStreamReader;\n\nnamespace msf {\nclass MappedBlockStream;\n}\n\nnamespace pdb {\n\nstruct PDBStringTableHeader;\n\nclass PDBStringTable {\npublic:\n  Error reload(BinaryStreamReader &Reader);\n\n  uint32_t getByteSize() const;\n  uint32_t getNameCount() const;\n  uint32_t getHashVersion() const;\n  uint32_t getSignature() const;\n\n  Expected<StringRef> getStringForID(uint32_t ID) const;\n  Expected<uint32_t> getIDForString(StringRef Str) const;\n\n  FixedStreamArray<support::ulittle32_t> name_ids() const;\n\n  const codeview::DebugStringTableSubsectionRef &getStringTable() const;\n\nprivate:\n  Error readHeader(BinaryStreamReader &Reader);\n  Error readStrings(BinaryStreamReader &Reader);\n  Error readHashTable(BinaryStreamReader &Reader);\n  Error readEpilogue(BinaryStreamReader &Reader);\n\n  const PDBStringTableHeader *Header = nullptr;\n  codeview::DebugStringTableSubsectionRef Strings;\n  FixedStreamArray<support::ulittle32_t> IDs;\n  uint32_t NameCount = 0;\n};\n\n} // end namespace pdb\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_PDB_NATIVE_PDBSTRINGTABLE_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawError.h", "content": "//===- RawError.h - Error extensions for raw PDB implementation -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_RAWERROR_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_RAWERROR_H\n\n#include \"llvm/Support/Error.h\"\n\n#include <string>\n\nnamespace llvm {\nnamespace pdb {\nenum class raw_error_code {\n  unspecified = 1,\n  feature_unsupported,\n  invalid_format,\n  corrupt_file,\n  insufficient_buffer,\n  no_stream,\n  index_out_of_bounds,\n  invalid_block_address,\n  duplicate_entry,\n  no_entry,\n  not_writable,\n  stream_too_long,\n  invalid_tpi_hash,\n};\n} // namespace pdb\n} // namespace llvm\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<llvm::pdb::raw_error_code> : std::true_type {};\n} // namespace std\n\nnamespace llvm {\nnamespace pdb {\nconst std::error_category &RawErrCategory();\n\ninline std::error_code make_error_code(raw_error_code E) {\n  return std::error_code(static_cast<int>(E), RawErrCategory());\n}\n\n/// Base class for errors originating when parsing raw PDB files\nclass RawError : public ErrorInfo<RawError, StringError> {\npublic:\n  using ErrorInfo<RawError, StringError>::ErrorInfo; // inherit constructors\n  RawError(const Twine &S) : ErrorInfo(S, raw_error_code::unspecified) {}\n  static char ID;\n};\n} // namespace pdb\n} // namespace llvm\n#endif\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h", "content": "//===- RawTypes.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_RAWTYPES_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_RAWTYPES_H\n\n#include \"llvm/DebugInfo/CodeView/GUID.h\"\n#include \"llvm/DebugInfo/CodeView/TypeRecord.h\"\n#include \"llvm/Support/Endian.h\"\n\nnamespace llvm {\nnamespace pdb {\n// This struct is defined as \"SO\" in langapi/include/pdb.h.\nstruct SectionOffset {\n  support::ulittle32_t Off;\n  support::ulittle16_t Isect;\n  char Padding[2];\n};\n\n/// Header of the hash tables found in the globals and publics sections.\n/// Based on GSIHashHdr in\n/// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/dbi/gsi.h\nstruct GSIHashHeader {\n  enum : unsigned {\n    HdrSignature = ~0U,\n    HdrVersion = 0xeffe0000 + 19990810,\n  };\n  support::ulittle32_t VerSignature;\n  support::ulittle32_t VerHdr;\n  support::ulittle32_t HrSize;\n  support::ulittle32_t NumBuckets;\n};\n\n// This is HRFile.\nstruct PSHashRecord {\n  support::ulittle32_t Off; // Offset in the symbol record stream\n  support::ulittle32_t CRef;\n};\n\n// This struct is defined as `SC` in include/dbicommon.h\nstruct SectionContrib {\n  support::ulittle16_t ISect;\n  char Padding[2];\n  support::little32_t Off;\n  support::little32_t Size;\n  support::ulittle32_t Characteristics;\n  support::ulittle16_t Imod;\n  char Padding2[2];\n  support::ulittle32_t DataCrc;\n  support::ulittle32_t RelocCrc;\n};\n\n// This struct is defined as `SC2` in include/dbicommon.h\nstruct SectionContrib2 {\n  // To guarantee SectionContrib2 is standard layout, we cannot use inheritance.\n  SectionContrib Base;\n  support::ulittle32_t ISectCoff;\n};\n\n// This corresponds to the `OMFSegMap` structure.\nstruct SecMapHeader {\n  support::ulittle16_t SecCount;    // Number of segment descriptors in table\n  support::ulittle16_t SecCountLog; // Number of logical segment descriptors\n};\n\n// This corresponds to the `OMFSegMapDesc` structure.  The definition is not\n// present in the reference implementation, but the layout is derived from\n// code that accesses the fields.\nstruct SecMapEntry {\n  support::ulittle16_t Flags; // Descriptor flags.  See OMFSegDescFlags\n  support::ulittle16_t Ovl;   // Logical overlay number.\n  support::ulittle16_t Group; // Group index into descriptor array.\n  support::ulittle16_t Frame;\n  support::ulittle16_t SecName;       // Byte index of the segment or group name\n                                      // in the sstSegName table, or 0xFFFF.\n  support::ulittle16_t ClassName;     // Byte index of the class name in the\n                                      // sstSegName table, or 0xFFFF.\n  support::ulittle32_t Offset;        // Byte offset of the logical segment\n                                      // within the specified physical segment.\n                                      // If group is set in flags, offset is the\n                                      // offset of the group.\n  support::ulittle32_t SecByteLength; // Byte count of the segment or group.\n};\n\n/// Some of the values are stored in bitfields.  Since this needs to be portable\n/// across compilers and architectures (big / little endian in particular) we\n/// can't use the actual structures below, but must instead do the shifting\n/// and masking ourselves.  The struct definitions are provided for reference.\nstruct DbiFlags {\n  ///  uint16_t IncrementalLinking : 1; // True if linked incrementally\n  ///  uint16_t IsStripped : 1;         // True if private symbols were\n  ///  stripped.\n  ///  uint16_t HasCTypes : 1;          // True if linked with /debug:ctypes.\n  ///  uint16_t Reserved : 13;\n  static const uint16_t FlagIncrementalMask = 0x0001;\n  static const uint16_t FlagStrippedMask = 0x0002;\n  static const uint16_t FlagHasCTypesMask = 0x0004;\n};\n\nstruct DbiBuildNo {\n  ///  uint16_t MinorVersion : 8;\n  ///  uint16_t MajorVersion : 7;\n  ///  uint16_t NewVersionFormat : 1;\n  static const uint16_t BuildMinorMask = 0x00FF;\n  static const uint16_t BuildMinorShift = 0;\n\n  static const uint16_t BuildMajorMask = 0x7F00;\n  static const uint16_t BuildMajorShift = 8;\n\n  static const uint16_t NewVersionFormatMask = 0x8000;\n};\n\n/// The fixed size header that appears at the beginning of the DBI Stream.\nstruct DbiStreamHeader {\n  support::little32_t VersionSignature;\n  support::ulittle32_t VersionHeader;\n\n  /// How \"old\" is this DBI Stream. Should match the age of the PDB InfoStream.\n  support::ulittle32_t Age;\n\n  /// Global symbol stream #\n  support::ulittle16_t GlobalSymbolStreamIndex;\n\n  /// See DbiBuildNo structure.\n  support::ulittle16_t BuildNumber;\n\n  /// Public symbols stream #\n  support::ulittle16_t PublicSymbolStreamIndex;\n\n  /// version of mspdbNNN.dll\n  support::ulittle16_t PdbDllVersion;\n\n  /// Symbol records stream #\n  support::ulittle16_t SymRecordStreamIndex;\n\n  /// rbld number of mspdbNNN.dll\n  support::ulittle16_t PdbDllRbld;\n\n  /// Size of module info stream\n  support::little32_t ModiSubstreamSize;\n\n  /// Size of sec. contrib stream\n  support::little32_t SecContrSubstreamSize;\n\n  /// Size of sec. map substream\n  support::little32_t SectionMapSize;\n\n  /// Size of file info substream\n  support::little32_t FileInfoSize;\n\n  /// Size of type server map\n  support::little32_t TypeServerSize;\n\n  /// Index of MFC Type Server\n  support::ulittle32_t MFCTypeServerIndex;\n\n  /// Size of DbgHeader info\n  support::little32_t OptionalDbgHdrSize;\n\n  /// Size of EC stream (what is EC?)\n  support::little32_t ECSubstreamSize;\n\n  /// See DbiFlags enum.\n  support::ulittle16_t Flags;\n\n  /// See PDB_MachineType enum.\n  support::ulittle16_t MachineType;\n\n  /// Pad to 64 bytes\n  support::ulittle32_t Reserved;\n};\nstatic_assert(sizeof(DbiStreamHeader) == 64, \"Invalid DbiStreamHeader size!\");\n\n/// The header preceding the File Info Substream of the DBI stream.\nstruct FileInfoSubstreamHeader {\n  /// Total # of modules, should match number of records in the ModuleInfo\n  /// substream.\n  support::ulittle16_t NumModules;\n\n  /// Total # of source files. This value is not accurate because PDB actually\n  /// supports more than 64k source files, so we ignore it and compute the value\n  /// from other stream fields.\n  support::ulittle16_t NumSourceFiles;\n\n  /// Following this header the File Info Substream is laid out as follows:\n  ///   ulittle16_t ModIndices[NumModules];\n  ///   ulittle16_t ModFileCounts[NumModules];\n  ///   ulittle32_t FileNameOffsets[NumSourceFiles];\n  ///   char Names[][NumSourceFiles];\n  /// with the caveat that `NumSourceFiles` cannot be trusted, so\n  /// it is computed by summing the `ModFileCounts` array.\n};\n\nstruct ModInfoFlags {\n  ///  uint16_t fWritten : 1;   // True if DbiModuleDescriptor is dirty\n  ///  uint16_t fECEnabled : 1; // Is EC symbolic info present?  (What is EC?)\n  ///  uint16_t unused : 6;     // Reserved\n  ///  uint16_t iTSM : 8;       // Type Server Index for this module\n  static const uint16_t HasECFlagMask = 0x2;\n\n  static const uint16_t TypeServerIndexMask = 0xFF00;\n  static const uint16_t TypeServerIndexShift = 8;\n};\n\n/// The header preceding each entry in the Module Info substream of the DBI\n/// stream.  Corresponds to the type MODI in the reference implementation.\nstruct ModuleInfoHeader {\n  /// Currently opened module. This field is a pointer in the reference\n  /// implementation, but that won't work on 64-bit systems, and anyway it\n  /// doesn't make sense to read a pointer from a file. For now it is unused,\n  /// so just ignore it.\n  support::ulittle32_t Mod;\n\n  /// First section contribution of this module.\n  SectionContrib SC;\n\n  /// See ModInfoFlags definition.\n  support::ulittle16_t Flags;\n\n  /// Stream Number of module debug info\n  support::ulittle16_t ModDiStream;\n\n  /// Size of local symbol debug info in above stream\n  support::ulittle32_t SymBytes;\n\n  /// Size of C11 line number info in above stream\n  support::ulittle32_t C11Bytes;\n\n  /// Size of C13 line number info in above stream\n  support::ulittle32_t C13Bytes;\n\n  /// Number of files contributing to this module\n  support::ulittle16_t NumFiles;\n\n  /// Padding so the next field is 4-byte aligned.\n  char Padding1[2];\n\n  /// Array of [0..NumFiles) DBI name buffer offsets.  In the reference\n  /// implementation this field is a pointer.  But since you can't portably\n  /// serialize a pointer, on 64-bit platforms they copy all the values except\n  /// this one into the 32-bit version of the struct and use that for\n  /// serialization.  Regardless, this field is unused, it is only there to\n  /// store a pointer that can be accessed at runtime.\n  support::ulittle32_t FileNameOffs;\n\n  /// Name Index for src file name\n  support::ulittle32_t SrcFileNameNI;\n\n  /// Name Index for path to compiler PDB\n  support::ulittle32_t PdbFilePathNI;\n\n  /// Following this header are two zero terminated strings.\n  /// char ModuleName[];\n  /// char ObjFileName[];\n};\n\n// This is PSGSIHDR struct defined in\n// https://github.com/Microsoft/microsoft-pdb/blob/master/PDB/dbi/gsi.h\nstruct PublicsStreamHeader {\n  support::ulittle32_t SymHash;\n  support::ulittle32_t AddrMap;\n  support::ulittle32_t NumThunks;\n  support::ulittle32_t SizeOfThunk;\n  support::ulittle16_t ISectThunkTable;\n  char Padding[2];\n  support::ulittle32_t OffThunkTable;\n  support::ulittle32_t NumSections;\n};\n\n// The header preceding the global TPI stream.\n// This corresponds to `HDR` in PDB/dbi/tpi.h.\nstruct TpiStreamHeader {\n  struct EmbeddedBuf {\n    support::little32_t Off;\n    support::ulittle32_t Length;\n  };\n\n  support::ulittle32_t Version;\n  support::ulittle32_t HeaderSize;\n  support::ulittle32_t TypeIndexBegin;\n  support::ulittle32_t TypeIndexEnd;\n  support::ulittle32_t TypeRecordBytes;\n\n  // The following members correspond to `TpiHash` in PDB/dbi/tpi.h.\n  support::ulittle16_t HashStreamIndex;\n  support::ulittle16_t HashAuxStreamIndex;\n  support::ulittle32_t HashKeySize;\n  support::ulittle32_t NumHashBuckets;\n\n  EmbeddedBuf HashValueBuffer;\n  EmbeddedBuf IndexOffsetBuffer;\n  EmbeddedBuf HashAdjBuffer;\n};\n\nconst uint32_t MinTpiHashBuckets = 0x1000;\nconst uint32_t MaxTpiHashBuckets = 0x40000;\n\n/// The header preceding the global PDB Stream (Stream 1)\nstruct InfoStreamHeader {\n  support::ulittle32_t Version;\n  support::ulittle32_t Signature;\n  support::ulittle32_t Age;\n  codeview::GUID Guid;\n};\n\n/// The header preceding the /names stream.\nstruct PDBStringTableHeader {\n  support::ulittle32_t Signature;   // PDBStringTableSignature\n  support::ulittle32_t HashVersion; // 1 or 2\n  support::ulittle32_t ByteSize;    // Number of bytes of names buffer.\n};\n\nconst uint32_t PDBStringTableSignature = 0xEFFEEFFE;\n\n/// The header preceding the /src/headerblock stream.\nstruct SrcHeaderBlockHeader {\n  support::ulittle32_t Version; // PdbRaw_SrcHeaderBlockVer enumeration.\n  support::ulittle32_t Size;    // Size of entire stream.\n  uint64_t FileTime;            // Time stamp (Windows FILETIME format).\n  support::ulittle32_t Age;     // Age\n  uint8_t Padding[44];          // Pad to 64 bytes.\n};\nstatic_assert(sizeof(SrcHeaderBlockHeader) == 64, \"Incorrect struct size!\");\n\n/// A single file record entry within the /src/headerblock stream.\nstruct SrcHeaderBlockEntry {\n  support::ulittle32_t Size;     // Record Length.\n  support::ulittle32_t Version;  // PdbRaw_SrcHeaderBlockVer enumeration.\n  support::ulittle32_t CRC;      // CRC of the original file contents.\n  support::ulittle32_t FileSize; // Size of original source file.\n  support::ulittle32_t FileNI;   // String table index of file name.\n  support::ulittle32_t ObjNI;    // String table index of object name.\n  support::ulittle32_t VFileNI;  // String table index of virtual file name.\n  uint8_t Compression;           // PDB_SourceCompression enumeration.\n  uint8_t IsVirtual;             // Is this a virtual file (injected)?\n  short Padding;                 // Pad to 4 bytes.\n  char Reserved[8];\n};\nstatic_assert(sizeof(SrcHeaderBlockEntry) == 40, \"Incorrect struct size!\");\n\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h", "content": "//==- SymbolCache.h - Cache of native symbols and ids ------------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_NATIVE_SYMBOLCACHE_H\n#define LLVM_DEBUGINFO_PDB_NATIVE_SYMBOLCACHE_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntervalMap.h\"\n#include \"llvm/DebugInfo/CodeView/Line.h\"\n#include \"llvm/DebugInfo/CodeView/SymbolRecord.h\"\n#include \"llvm/DebugInfo/CodeView/TypeDeserializer.h\"\n#include \"llvm/DebugInfo/CodeView/TypeIndex.h\"\n#include \"llvm/DebugInfo/CodeView/TypeRecord.h\"\n#include \"llvm/DebugInfo/PDB/Native/ModuleDebugStream.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeRawSymbol.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeSourceFile.h\"\n\n#include <memory>\n#include <vector>\n\nnamespace llvm {\nnamespace pdb {\nclass DbiStream;\nclass PDBFile;\n\nclass SymbolCache {\n  NativeSession &Session;\n  DbiStream *Dbi = nullptr;\n\n  /// Cache of all stable symbols, indexed by SymIndexId.  Just because a\n  /// symbol has been parsed does not imply that it will be stable and have\n  /// an Id.  Id allocation is an implementation, with the only guarantee\n  /// being that once an Id is allocated, the symbol can be assumed to be\n  /// cached.\n  mutable std::vector<std::unique_ptr<NativeRawSymbol>> Cache;\n\n  /// For type records from the TPI stream which have been paresd and cached,\n  /// stores a mapping to SymIndexId of the cached symbol.\n  mutable DenseMap<codeview::TypeIndex, SymIndexId> TypeIndexToSymbolId;\n\n  /// For field list members which have been parsed and cached, stores a mapping\n  /// from (IndexOfClass, MemberIndex) to the corresponding SymIndexId of the\n  /// cached symbol.\n  mutable DenseMap<std::pair<codeview::TypeIndex, uint32_t>, SymIndexId>\n      FieldListMembersToSymbolId;\n\n  /// List of SymIndexIds for each compiland, indexed by compiland index as they\n  /// appear in the PDB file.\n  mutable std::vector<SymIndexId> Compilands;\n\n  /// List of source files, indexed by unique source file index.\n  mutable std::vector<std::unique_ptr<NativeSourceFile>> SourceFiles;\n\n  /// Map from string table offset to source file Id.\n  mutable DenseMap<uint32_t, SymIndexId> FileNameOffsetToId;\n\n  /// Map from global symbol offset to SymIndexId.\n  mutable DenseMap<uint32_t, SymIndexId> GlobalOffsetToSymbolId;\n\n  /// Map from segment and code offset to function symbols.\n  mutable DenseMap<std::pair<uint32_t, uint32_t>, SymIndexId> AddressToSymbolId;\n  /// Map from segment and code offset to public symbols.\n  mutable DenseMap<std::pair<uint32_t, uint32_t>, SymIndexId>\n      AddressToPublicSymId;\n\n  /// Map from module index and symbol table offset to SymIndexId.\n  mutable DenseMap<std::pair<uint16_t, uint32_t>, SymIndexId>\n      SymTabOffsetToSymbolId;\n\n  struct LineTableEntry {\n    uint64_t Addr;\n    codeview::LineInfo Line;\n    uint32_t ColumnNumber;\n    uint32_t FileNameIndex;\n    bool IsTerminalEntry;\n  };\n\n  std::vector<LineTableEntry> findLineTable(uint16_t Modi) const;\n  mutable DenseMap<uint16_t, std::vector<LineTableEntry>> LineTable;\n\n  SymIndexId createSymbolPlaceholder() const {\n    SymIndexId Id = Cache.size();\n    Cache.push_back(nullptr);\n    return Id;\n  }\n\n  template <typename ConcreteSymbolT, typename CVRecordT, typename... Args>\n  SymIndexId createSymbolForType(codeview::TypeIndex TI, codeview::CVType CVT,\n                                 Args &&...ConstructorArgs) const {\n    CVRecordT Record;\n    if (auto EC =\n            codeview::TypeDeserializer::deserializeAs<CVRecordT>(CVT, Record)) {\n      consumeError(std::move(EC));\n      return 0;\n    }\n\n    return createSymbol<ConcreteSymbolT>(\n        TI, std::move(Record), std::forward<Args>(ConstructorArgs)...);\n  }\n\n  SymIndexId createSymbolForModifiedType(codeview::TypeIndex ModifierTI,\n                                         codeview::CVType CVT) const;\n\n  SymIndexId createSimpleType(codeview::TypeIndex TI,\n                              codeview::ModifierOptions Mods) const;\n\n  std::unique_ptr<PDBSymbol> findFunctionSymbolBySectOffset(uint32_t Sect,\n                                                            uint32_t Offset);\n  std::unique_ptr<PDBSymbol> findPublicSymbolBySectOffset(uint32_t Sect,\n                                                          uint32_t Offset);\n\npublic:\n  SymbolCache(NativeSession &Session, DbiStream *Dbi);\n\n  template <typename ConcreteSymbolT, typename... Args>\n  SymIndexId createSymbol(Args &&...ConstructorArgs) const {\n    SymIndexId Id = Cache.size();\n\n    // Initial construction must not access the cache, since it must be done\n    // atomically.\n    auto Result = std::make_unique<ConcreteSymbolT>(\n        Session, Id, std::forward<Args>(ConstructorArgs)...);\n    Result->SymbolId = Id;\n\n    NativeRawSymbol *NRS = static_cast<NativeRawSymbol *>(Result.get());\n    Cache.push_back(std::move(Result));\n\n    // After the item is in the cache, we can do further initialization which\n    // is then allowed to access the cache.\n    NRS->initialize();\n    return Id;\n  }\n\n  std::unique_ptr<IPDBEnumSymbols>\n  createTypeEnumerator(codeview::TypeLeafKind Kind);\n\n  std::unique_ptr<IPDBEnumSymbols>\n  createTypeEnumerator(std::vector<codeview::TypeLeafKind> Kinds);\n\n  std::unique_ptr<IPDBEnumSymbols>\n  createGlobalsEnumerator(codeview::SymbolKind Kind);\n\n  SymIndexId findSymbolByTypeIndex(codeview::TypeIndex TI) const;\n\n  template <typename ConcreteSymbolT, typename... Args>\n  SymIndexId getOrCreateFieldListMember(codeview::TypeIndex FieldListTI,\n                                        uint32_t Index,\n                                        Args &&... ConstructorArgs) {\n    SymIndexId SymId = Cache.size();\n    std::pair<codeview::TypeIndex, uint32_t> Key{FieldListTI, Index};\n    auto Result = FieldListMembersToSymbolId.try_emplace(Key, SymId);\n    if (Result.second)\n      SymId =\n          createSymbol<ConcreteSymbolT>(std::forward<Args>(ConstructorArgs)...);\n    else\n      SymId = Result.first->second;\n    return SymId;\n  }\n\n  SymIndexId getOrCreateGlobalSymbolByOffset(uint32_t Offset);\n  SymIndexId getOrCreateInlineSymbol(codeview::InlineSiteSym Sym,\n                                     uint64_t ParentAddr, uint16_t Modi,\n                                     uint32_t RecordOffset) const;\n\n  std::unique_ptr<PDBSymbol>\n  findSymbolBySectOffset(uint32_t Sect, uint32_t Offset, PDB_SymType Type);\n\n  std::unique_ptr<IPDBEnumLineNumbers>\n  findLineNumbersByVA(uint64_t VA, uint32_t Length) const;\n\n  std::unique_ptr<PDBSymbolCompiland> getOrCreateCompiland(uint32_t Index);\n  uint32_t getNumCompilands() const;\n\n  std::unique_ptr<PDBSymbol> getSymbolById(SymIndexId SymbolId) const;\n\n  NativeRawSymbol &getNativeSymbolById(SymIndexId SymbolId) const;\n\n  template <typename ConcreteT>\n  ConcreteT &getNativeSymbolById(SymIndexId SymbolId) const {\n    return static_cast<ConcreteT &>(getNativeSymbolById(SymbolId));\n  }\n\n  std::unique_ptr<IPDBSourceFile> getSourceFileById(SymIndexId FileId) const;\n  SymIndexId\n  getOrCreateSourceFile(const codeview::FileChecksumEntry &Checksum) const;\n};\n\n} // namespace pdb\n} // namespace llvm\n\n#endif\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolCompiland.h", "content": "//===- PDBSymbolCompiland.h - Accessors for querying PDB compilands -----*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_DEBUGINFO_PDB_PDBSYMBOLCOMPILAND_H\n#define LLVM_DEBUGINFO_PDB_PDBSYMBOLCOMPILAND_H\n\n#include \"PDBSymbol.h\"\n#include \"PDBTypes.h\"\n#include <string>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nnamespace pdb {\n\nclass PDBSymbolCompiland : public PDBSymbol {\n  DECLARE_PDB_SYMBOL_CONCRETE_TYPE(PDB_SymType::Compiland)\npublic:\n  void dump(PDBSymDumper &Dumper) const override;\n\n  FORWARD_SYMBOL_METHOD(isEditAndContinueEnabled)\n  FORWARD_SYMBOL_ID_METHOD(getLexicalParent)\n  FORWARD_SYMBOL_METHOD(getLibraryName)\n  FORWARD_SYMBOL_METHOD(getName)\n\n  std::string getSourceFileName() const;\n  std::string getSourceFileFullPath() const;\n};\n}\n}\n\n#endif // LLVM_DEBUGINFO_PDB_PDBSYMBOLCOMPILAND_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolExe.h", "content": "//===- PDBSymbolExe.h - Accessors for querying executables in a PDB ----*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_PDB_PDBSYMBOLEXE_H\n#define LLVM_DEBUGINFO_PDB_PDBSYMBOLEXE_H\n\n#include \"PDBSymbol.h\"\n#include \"PDBTypes.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\n\nnamespace pdb {\n\nclass PDBSymbolExe : public PDBSymbol {\n  DECLARE_PDB_SYMBOL_CONCRETE_TYPE(PDB_SymType::Exe)\npublic:\n  void dump(PDBSymDumper &Dumper) const override;\n\n  FORWARD_SYMBOL_METHOD(getAge)\n  FORWARD_SYMBOL_METHOD(getGuid)\n  FORWARD_SYMBOL_METHOD(hasCTypes)\n  FORWARD_SYMBOL_METHOD(hasPrivateSymbols)\n  FORWARD_SYMBOL_METHOD(getMachineType)\n  FORWARD_SYMBOL_METHOD(getName)\n  FORWARD_SYMBOL_METHOD(getSignature)\n  FORWARD_SYMBOL_METHOD(getSymbolsFileName)\n\n  uint32_t getPointerByteSize() const;\n\nprivate:\n  void dumpChildren(raw_ostream &OS, StringRef Label, PDB_SymType ChildType,\n                    int Indent) const;\n};\n} // namespace llvm\n}\n\n#endif // LLVM_DEBUGINFO_PDB_PDBSYMBOLEXE_H\n"}, "87": {"id": 87, "path": "/home/vsts/work/1/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeSession.cpp", "content": "//===- NativeSession.cpp - Native implementation of IPDBSession -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/DebugInfo/PDB/Native/NativeSession.h\"\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/DebugInfo/CodeView/TypeIndex.h\"\n#include \"llvm/DebugInfo/PDB/IPDBEnumChildren.h\"\n#include \"llvm/DebugInfo/PDB/IPDBSourceFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/DbiStream.h\"\n#include \"llvm/DebugInfo/PDB/Native/ISectionContribVisitor.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeCompilandSymbol.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeEnumInjectedSources.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeEnumTypes.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeExeSymbol.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeTypeBuiltin.h\"\n#include \"llvm/DebugInfo/PDB/Native/NativeTypeEnum.h\"\n#include \"llvm/DebugInfo/PDB/Native/PDBFile.h\"\n#include \"llvm/DebugInfo/PDB/Native/RawError.h\"\n#include \"llvm/DebugInfo/PDB/Native/SymbolCache.h\"\n#include \"llvm/DebugInfo/PDB/Native/TpiStream.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolCompiland.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolExe.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h\"\n#include \"llvm/Object/COFF.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/BinaryByteStream.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Path.h\"\n\n#include <algorithm>\n#include <cassert>\n#include <memory>\n#include <utility>\n\nusing namespace llvm;\nusing namespace llvm::msf;\nusing namespace llvm::pdb;\n\nstatic DbiStream *getDbiStreamPtr(PDBFile &File) {\n  Expected<DbiStream &> DbiS = File.getPDBDbiStream();\n  if (DbiS)\n    return &DbiS.get();\n\n  consumeError(DbiS.takeError());\n  return nullptr;\n}\n\nNativeSession::NativeSession(std::unique_ptr<PDBFile> PdbFile,\n                             std::unique_ptr<BumpPtrAllocator> Allocator)\n    : Pdb(std::move(PdbFile)), Allocator(std::move(Allocator)),\n      Cache(*this, getDbiStreamPtr(*Pdb)), AddrToModuleIndex(IMapAllocator) {}\n\nNativeSession::~NativeSession() = default;\n\nError NativeSession::createFromPdb(std::unique_ptr<MemoryBuffer> Buffer,\n                                   std::unique_ptr<IPDBSession> &Session) {\n  StringRef Path = Buffer->getBufferIdentifier();\n  auto Stream = std::make_unique<MemoryBufferByteStream>(\n      std::move(Buffer), llvm::support::little);\n\n  auto Allocator = std::make_unique<BumpPtrAllocator>();\n  auto File = std::make_unique<PDBFile>(Path, std::move(Stream), *Allocator);\n  if (auto EC = File->parseFileHeaders())\n    return EC;\n  if (auto EC = File->parseStreamData())\n    return EC;\n\n  Session =\n      std::make_unique<NativeSession>(std::move(File), std::move(Allocator));\n\n  return Error::success();\n}\n\nstatic Expected<std::unique_ptr<PDBFile>>\nloadPdbFile(StringRef PdbPath, std::unique_ptr<BumpPtrAllocator> &Allocator) {\n  ErrorOr<std::unique_ptr<MemoryBuffer>> ErrorOrBuffer =\n      MemoryBuffer::getFile(PdbPath, /*FileSize=*/-1,\n                            /*RequiresNullTerminator=*/false);\n  if (!ErrorOrBuffer)\n    return make_error<RawError>(ErrorOrBuffer.getError());\n  std::unique_ptr<llvm::MemoryBuffer> Buffer = std::move(*ErrorOrBuffer);\n\n  PdbPath = Buffer->getBufferIdentifier();\n  file_magic Magic;\n  auto EC = identify_magic(PdbPath, Magic);\n  if (EC || Magic != file_magic::pdb)\n    return make_error<RawError>(EC);\n\n  auto Stream = std::make_unique<MemoryBufferByteStream>(std::move(Buffer),\n                                                         llvm::support::little);\n\n  auto File = std::make_unique<PDBFile>(PdbPath, std::move(Stream), *Allocator);\n  if (auto EC = File->parseFileHeaders())\n    return std::move(EC);\n\n  if (auto EC = File->parseStreamData())\n    return std::move(EC);\n\n  return std::move(File);\n}\n\nError NativeSession::createFromPdbPath(StringRef PdbPath,\n                                       std::unique_ptr<IPDBSession> &Session) {\n  auto Allocator = std::make_unique<BumpPtrAllocator>();\n  auto PdbFile = loadPdbFile(PdbPath, Allocator);\n  if (!PdbFile)\n    return PdbFile.takeError();\n\n  Session = std::make_unique<NativeSession>(std::move(PdbFile.get()),\n                                            std::move(Allocator));\n  return Error::success();\n}\n\nstatic Expected<std::string> getPdbPathFromExe(StringRef ExePath) {\n  Expected<object::OwningBinary<object::Binary>> BinaryFile =\n      object::createBinary(ExePath);\n  if (!BinaryFile)\n    return BinaryFile.takeError();\n\n  const object::COFFObjectFile *ObjFile =\n      dyn_cast<object::COFFObjectFile>(BinaryFile->getBinary());\n  if (!ObjFile)\n    return make_error<RawError>(raw_error_code::invalid_format);\n\n  StringRef PdbPath;\n  const llvm::codeview::DebugInfo *PdbInfo = nullptr;\n  if (Error E = ObjFile->getDebugPDBInfo(PdbInfo, PdbPath))\n    return std::move(E);\n\n  return std::string(PdbPath);\n}\n\nError NativeSession::createFromExe(StringRef ExePath,\n                                   std::unique_ptr<IPDBSession> &Session) {\n  Expected<std::string> PdbPath = getPdbPathFromExe(ExePath);\n  if (!PdbPath)\n    return PdbPath.takeError();\n\n  file_magic Magic;\n  auto EC = identify_magic(PdbPath.get(), Magic);\n  if (EC || Magic != file_magic::pdb)\n    return make_error<RawError>(EC);\n\n  auto Allocator = std::make_unique<BumpPtrAllocator>();\n  auto File = loadPdbFile(PdbPath.get(), Allocator);\n  if (!File)\n    return File.takeError();\n\n  Session = std::make_unique<NativeSession>(std::move(File.get()),\n                                            std::move(Allocator));\n\n  return Error::success();\n}\n\nExpected<std::string>\nNativeSession::searchForPdb(const PdbSearchOptions &Opts) {\n  Expected<std::string> PathOrErr = getPdbPathFromExe(Opts.ExePath);\n  if (!PathOrErr)\n    return PathOrErr.takeError();\n  StringRef PathFromExe = PathOrErr.get();\n  sys::path::Style Style = PathFromExe.startswith(\"/\")\n                               ? sys::path::Style::posix\n                               : sys::path::Style::windows;\n  StringRef PdbName = sys::path::filename(PathFromExe, Style);\n\n  // Check if pdb exists in the executable directory.\n  SmallString<128> PdbPath = StringRef(Opts.ExePath);\n  sys::path::remove_filename(PdbPath);\n  sys::path::append(PdbPath, PdbName);\n\n  auto Allocator = std::make_unique<BumpPtrAllocator>();\n\n  if (auto File = loadPdbFile(PdbPath, Allocator))\n    return std::string(PdbPath);\n  else\n    consumeError(File.takeError());\n\n  // Check path that was in the executable.\n  if (auto File = loadPdbFile(PathFromExe, Allocator))\n    return std::string(PathFromExe);\n  else\n    return File.takeError();\n\n  return make_error<RawError>(\"PDB not found\");\n}\n\nuint64_t NativeSession::getLoadAddress() const { return LoadAddress; }\n\nbool NativeSession::setLoadAddress(uint64_t Address) {\n  LoadAddress = Address;\n  return true;\n}\n\nstd::unique_ptr<PDBSymbolExe> NativeSession::getGlobalScope() {\n  return PDBSymbol::createAs<PDBSymbolExe>(*this, getNativeGlobalScope());\n}\n\nstd::unique_ptr<PDBSymbol>\nNativeSession::getSymbolById(SymIndexId SymbolId) const {\n  return Cache.getSymbolById(SymbolId);\n}\n\nbool NativeSession::addressForVA(uint64_t VA, uint32_t &Section,\n                                 uint32_t &Offset) const {\n  uint32_t RVA = VA - getLoadAddress();\n  return addressForRVA(RVA, Section, Offset);\n}\n\nbool NativeSession::addressForRVA(uint32_t RVA, uint32_t &Section,\n                                  uint32_t &Offset) const {\n  Section = 0;\n  Offset = 0;\n\n  auto Dbi = Pdb->getPDBDbiStream();\n  if (!Dbi)\n    return false;\n\n  if ((int32_t)RVA < 0)\n    return true;\n\n  Offset = RVA;\n  for (; Section < Dbi->getSectionHeaders().size(); ++Section) {\n    auto &Sec = Dbi->getSectionHeaders()[Section];\n    if (RVA < Sec.VirtualAddress)\n      return true;\n    Offset = RVA - Sec.VirtualAddress;\n  }\n  return true;\n}\n\nstd::unique_ptr<PDBSymbol>\nNativeSession::findSymbolByAddress(uint64_t Address, PDB_SymType Type) {\n  uint32_t Section;\n  uint32_t Offset;\n  addressForVA(Address, Section, Offset);\n  return findSymbolBySectOffset(Section, Offset, Type);\n}\n\nstd::unique_ptr<PDBSymbol> NativeSession::findSymbolByRVA(uint32_t RVA,\n                                                          PDB_SymType Type) {\n  uint32_t Section;\n  uint32_t Offset;\n  addressForRVA(RVA, Section, Offset);\n  return findSymbolBySectOffset(Section, Offset, Type);\n}\n\nstd::unique_ptr<PDBSymbol>\nNativeSession::findSymbolBySectOffset(uint32_t Sect, uint32_t Offset,\n                                      PDB_SymType Type) {\n  if (AddrToModuleIndex.empty())\n    parseSectionContribs();\n\n  return Cache.findSymbolBySectOffset(Sect, Offset, Type);\n}\n\nstd::unique_ptr<IPDBEnumLineNumbers>\nNativeSession::findLineNumbers(const PDBSymbolCompiland &Compiland,\n                               const IPDBSourceFile &File) const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBEnumLineNumbers>\nNativeSession::findLineNumbersByAddress(uint64_t Address,\n                                        uint32_t Length) const {\n  return Cache.findLineNumbersByVA(Address, Length);\n}\n\nstd::unique_ptr<IPDBEnumLineNumbers>\nNativeSession::findLineNumbersByRVA(uint32_t RVA, uint32_t Length) const {\n  return Cache.findLineNumbersByVA(getLoadAddress() + RVA, Length);\n}\n\nstd::unique_ptr<IPDBEnumLineNumbers>\nNativeSession::findLineNumbersBySectOffset(uint32_t Section, uint32_t Offset,\n                                           uint32_t Length) const {\n  uint64_t VA = getVAFromSectOffset(Section, Offset);\n  return Cache.findLineNumbersByVA(VA, Length);\n}\n\nstd::unique_ptr<IPDBEnumSourceFiles>\nNativeSession::findSourceFiles(const PDBSymbolCompiland *Compiland,\n                               StringRef Pattern,\n                               PDB_NameSearchFlags Flags) const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBSourceFile>\nNativeSession::findOneSourceFile(const PDBSymbolCompiland *Compiland,\n                                 StringRef Pattern,\n                                 PDB_NameSearchFlags Flags) const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBEnumChildren<PDBSymbolCompiland>>\nNativeSession::findCompilandsForSourceFile(StringRef Pattern,\n                                           PDB_NameSearchFlags Flags) const {\n  return nullptr;\n}\n\nstd::unique_ptr<PDBSymbolCompiland>\nNativeSession::findOneCompilandForSourceFile(StringRef Pattern,\n                                             PDB_NameSearchFlags Flags) const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBEnumSourceFiles> NativeSession::getAllSourceFiles() const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBEnumSourceFiles> NativeSession::getSourceFilesForCompiland(\n    const PDBSymbolCompiland &Compiland) const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBSourceFile>\nNativeSession::getSourceFileById(uint32_t FileId) const {\n  return Cache.getSourceFileById(FileId);\n}\n\nstd::unique_ptr<IPDBEnumDataStreams> NativeSession::getDebugStreams() const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBEnumTables> NativeSession::getEnumTables() const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBEnumInjectedSources>\nNativeSession::getInjectedSources() const {\n  auto ISS = Pdb->getInjectedSourceStream();\n  if (!ISS) {\n    consumeError(ISS.takeError());\n    return nullptr;\n  }\n  auto Strings = Pdb->getStringTable();\n  if (!Strings) {\n    consumeError(Strings.takeError());\n    return nullptr;\n  }\n  return std::make_unique<NativeEnumInjectedSources>(*Pdb, *ISS, *Strings);\n}\n\nstd::unique_ptr<IPDBEnumSectionContribs>\nNativeSession::getSectionContribs() const {\n  return nullptr;\n}\n\nstd::unique_ptr<IPDBEnumFrameData>\nNativeSession::getFrameData() const {\n  return nullptr;\n}\n\nvoid NativeSession::initializeExeSymbol() {\n  if (ExeSymbol == 0)\n    ExeSymbol = Cache.createSymbol<NativeExeSymbol>();\n}\n\nNativeExeSymbol &NativeSession::getNativeGlobalScope() const {\n  const_cast<NativeSession &>(*this).initializeExeSymbol();\n\n  return Cache.getNativeSymbolById<NativeExeSymbol>(ExeSymbol);\n}\n\nuint32_t NativeSession::getRVAFromSectOffset(uint32_t Section,\n                                             uint32_t Offset) const {\n  if (Section <= 0)\n    return 0;\n\n  auto Dbi = getDbiStreamPtr(*Pdb);\n  if (!Dbi)\n    return 0;\n\n  uint32_t MaxSection = Dbi->getSectionHeaders().size();\n  if (Section > MaxSection + 1)\n    Section = MaxSection + 1;\n  auto &Sec = Dbi->getSectionHeaders()[Section - 1];\n  return Sec.VirtualAddress + Offset;\n}\n\nuint64_t NativeSession::getVAFromSectOffset(uint32_t Section,\n                                            uint32_t Offset) const {\n  return LoadAddress + getRVAFromSectOffset(Section, Offset);\n}\n\nbool NativeSession::moduleIndexForVA(uint64_t VA, uint16_t &ModuleIndex) const {\n  ModuleIndex = 0;\n  auto Iter = AddrToModuleIndex.find(VA);\n  if (Iter == AddrToModuleIndex.end())\n    return false;\n  ModuleIndex = Iter.value();\n  return true;\n}\n\nbool NativeSession::moduleIndexForSectOffset(uint32_t Sect, uint32_t Offset,\n                                             uint16_t &ModuleIndex) const {\n  ModuleIndex = 0;\n  auto Iter = AddrToModuleIndex.find(getVAFromSectOffset(Sect, Offset));\n  if (Iter == AddrToModuleIndex.end())\n    return false;\n  ModuleIndex = Iter.value();\n  return true;\n}\n\nvoid NativeSession::parseSectionContribs() {\n  auto Dbi = Pdb->getPDBDbiStream();\n  if (!Dbi)\n    return;\n\n  class Visitor : public ISectionContribVisitor {\n    NativeSession &Session;\n    IMap &AddrMap;\n\n  public:\n    Visitor(NativeSession &Session, IMap &AddrMap)\n        : Session(Session), AddrMap(AddrMap) {}\n    void visit(const SectionContrib &C) override {\n      if (C.Size == 0)\n        return;\n\n      uint64_t VA = Session.getVAFromSectOffset(C.ISect, C.Off);\n      uint64_t End = VA + C.Size;\n\n      // Ignore overlapping sections based on the assumption that a valid\n      // PDB file should not have overlaps.\n      if (!AddrMap.overlaps(VA, End))\n        AddrMap.insert(VA, End, C.Imod);\n    }\n    void visit(const SectionContrib2 &C) override { visit(C.Base); }\n  };\n\n  Visitor V(*this, AddrToModuleIndex);\n  Dbi->visitSectionContributions(V);\n}\n\nExpected<ModuleDebugStreamRef>\nNativeSession::getModuleDebugStream(uint32_t Index) const {\n  auto *Dbi = getDbiStreamPtr(*Pdb);\n  assert(Dbi && \"Dbi stream not present\");\n\n  DbiModuleDescriptor Modi = Dbi->modules().getModuleDescriptor(Index);\n\n  uint16_t ModiStream = Modi.getModuleStreamIndex();\n  if (ModiStream == kInvalidStreamIndex)\n    return make_error<RawError>(\"Module stream not present\");\n\n  std::unique_ptr<msf::MappedBlockStream> ModStreamData =\n      Pdb->createIndexedStream(ModiStream);\n\n  ModuleDebugStreamRef ModS(Modi, std::move(ModStreamData));\n  if (auto EC = ModS.reload())\n    return std::move(EC);\n\n  return std::move(ModS);\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 9, "line": 220}, "message": "'NodeBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "reportHash": "33a9ccb41b5eeb7bcedb5633298cdf8a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 563}, "message": "'LeafNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "reportHash": "cb463e669d6f25ec9cf51a3e8aaaec1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 700}, "message": "'BranchNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "reportHash": "77a301bc2185287abf716388168f55c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 770}, "message": "'Path' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "reportHash": "738090e21e08daa6cf6bd4b509d65261", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 9, "line": 953}, "message": "'RootBranchData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "reportHash": "8cb2e76afc387379b0f4b62d3be28bc0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 9, "line": 1292}, "message": "'const_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "reportHash": "466e1ae7e9c9d630d591cdc906f76371", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 9, "line": 1516}, "message": "'iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntervalMap.h", "reportHash": "07d181f49a21c75a4ba2752ab6d30498", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 25, "line": 30}, "message": "'CVRecord' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVRecord.h", "reportHash": "7242031c6fd41406013c2dc86e517fd0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 31}, "message": "'FileChecksumEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h", "reportHash": "7de48bd7233cc01fbd50d446e18541c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 29, "line": 39}, "message": "'VarStreamArrayExtractor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h", "reportHash": "3d156230a45c94bb318333196ffddbbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 49}, "message": "'DebugChecksumsSubsectionRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h", "reportHash": "8f8d36ab30e72f594c8f5d7c600cb162", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 75}, "message": "'DebugChecksumsSubsection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h", "reportHash": "53c7e37d96540d8764fb87bc183b2e35", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 20}, "message": "'DebugFrameDataSubsectionRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugFrameDataSubsection.h", "reportHash": "4be08bd8b4521f51d95c1507ddd30cb4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 41}, "message": "'DebugFrameDataSubsection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugFrameDataSubsection.h", "reportHash": "05e3924b7de54cbc4ee75e3fa39e1a45", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 31}, "message": "'DebugStringTableSubsectionRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugStringTableSubsection.h", "reportHash": "9ffcb3817b3c4d922f20603fbac01cc2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 56}, "message": "'DebugStringTableSubsection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugStringTableSubsection.h", "reportHash": "8bad7bb42133ccd8b2b1c6d9893c188f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 35}, "message": "'DebugSubsectionRecord' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugSubsectionRecord.h", "reportHash": "d30f73f957e0a96baa3e0ace10963710", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 51}, "message": "'DebugSubsectionRecordBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugSubsectionRecord.h", "reportHash": "c79a71920d4772d78d0833bc347294af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 49}, "message": "'LazyRandomTypeCollection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/LazyRandomTypeCollection.h", "reportHash": "92fa3e5837a32cf0d5a0c9fcee06b186", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 21}, "message": "'LineInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/Line.h", "reportHash": "bce7a7a26f4d8aab8086cb0bec990078", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 63}, "message": "'ColumnInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/Line.h", "reportHash": "f74130a1cbac84799b4c1f35d6976f57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 28}, "message": "'TypeDeserializer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeDeserializer.h", "reportHash": "b8f9eed8fe6fac532cec9a45c686e129", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 29}, "message": "'MappingInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeDeserializer.h", "reportHash": "f577a1288cc58cb1a4494c7ef2dc89b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 103}, "message": "'MappingInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeDeserializer.h", "reportHash": "f577a1288cc58cb1a4494c7ef2dc89b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 39, "line": 23}, "message": "'TypeRecordMapping' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeRecordMapping.h", "reportHash": "caaa8fecc078d573f58b296697976d94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 77}, "message": "'MSFStreamLayout' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "reportHash": "0caba65b1dc2f5691fab5f9f71a6a4f2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 42, "line": 58}, "message": "'VarStreamArrayExtractor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptor.h", "reportHash": "69302ee1381145b0dbd1b2caa7c2a8c6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 69}, "message": "'DbiModuleList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleList.h", "reportHash": "5eff6c2689ca966630af676b5f73d1e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 103}, "message": "'HashTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/HashTable.h", "reportHash": "aaae50bd320e3e34dba7dacc9f9c634f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 23}, "message": "'InjectedSourceStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InjectedSourceStream.h", "reportHash": "12d6be462655e2fd941a2f6370336e55", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 46, "line": 34}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 46, "line": 34}, "message": "'ModuleDebugStreamRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/ModuleDebugStream.h", "reportHash": "c14a8f6f2fe66a4a7a4f7195a78b7f88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 18}, "message": "'NativeCompilandSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeCompilandSymbol.h", "reportHash": "afdecb2ca442006548bebc4dc059dee4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 23}, "message": "'NativeEnumInjectedSources' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeEnumInjectedSources.h", "reportHash": "3016094ac4b5a42f4909e617b5a8001e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 49, "line": 24}, "message": "'NativeEnumTypes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeEnumTypes.h", "reportHash": "f50bddb1669de421bd1a78e2bbcba5dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 50, "line": 20}, "message": "'NativeExeSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeExeSymbol.h", "reportHash": "59f29bb578d4695778903e8f64461aa3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 21}, "message": "'NativeRawSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeRawSymbol.h", "reportHash": "2b120ff641529a259782f3da457a7771", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 52, "line": 21}, "message": "'NativeSourceFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NativeSourceFile.h", "reportHash": "583c930c0aed3dad5f69fe334d50bbf6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 53, "line": 32}, "message": "'PDBStringTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBStringTable.h", "reportHash": "7ab06e8e2c10dd8e1ea0c463a026ac42", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 50}, "message": "'RawError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawError.h", "reportHash": "4eaaba4f23041b4c8a3416b85773b07d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 46}, "message": "'SectionContrib' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h", "reportHash": "72c6c27dcdc63209e970ab644030224a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 59}, "message": "'SectionContrib2' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h", "reportHash": "84018ff0162db7509fc366786a31ce59", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 56, "line": 31}, "message": "'SymbolCache' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h", "reportHash": "287cdb33bba5929f4d191d1b72db5360", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 58, "line": 21}, "message": "'PDBSymbolCompiland' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolCompiland.h", "reportHash": "9cf700c4f5a4add4534c923964c1fd63", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 59, "line": 21}, "message": "'PDBSymbolExe' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBSymbolExe.h", "reportHash": "b2db243a771e211c1992ea81330f7a89", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 87, "line": 418}, "message": "'Visitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeSession.cpp", "reportHash": "580edfd39c54e16f33a65ef72cbd1e2b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
