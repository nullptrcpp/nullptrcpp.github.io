<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "content": "//===- llvm/ADT/EpochTracker.h - ADT epoch tracking --------------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DebugEpochBase and DebugEpochBase::HandleBase classes.\n// These can be used to write iterators that are fail-fast when LLVM is built\n// with asserts enabled.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_EPOCHTRACKER_H\n#define LLVM_ADT_EPOCHTRACKER_H\n\n#include \"llvm/Config/abi-breaking.h\"\n\n#include <cstdint>\n\nnamespace llvm {\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n\n/// A base class for data structure classes wishing to make iterators\n/// (\"handles\") pointing into themselves fail-fast.  When building without\n/// asserts, this class is empty and does nothing.\n///\n/// DebugEpochBase does not by itself track handles pointing into itself.  The\n/// expectation is that routines touching the handles will poll on\n/// isHandleInSync at appropriate points to assert that the handle they're using\n/// is still valid.\n///\nclass DebugEpochBase {\n  uint64_t Epoch;\n\npublic:\n  DebugEpochBase() : Epoch(0) {}\n\n  /// Calling incrementEpoch invalidates all handles pointing into the\n  /// calling instance.\n  void incrementEpoch() { ++Epoch; }\n\n  /// The destructor calls incrementEpoch to make use-after-free bugs\n  /// more likely to crash deterministically.\n  ~DebugEpochBase() { incrementEpoch(); }\n\n  /// A base class for iterator classes (\"handles\") that wish to poll for\n  /// iterator invalidating modifications in the underlying data structure.\n  /// When LLVM is built without asserts, this class is empty and does nothing.\n  ///\n  /// HandleBase does not track the parent data structure by itself.  It expects\n  /// the routines modifying the data structure to call incrementEpoch when they\n  /// make an iterator-invalidating modification.\n  ///\n  class HandleBase {\n    const uint64_t *EpochAddress;\n    uint64_t EpochAtCreation;\n\n  public:\n    HandleBase() : EpochAddress(nullptr), EpochAtCreation(UINT64_MAX) {}\n\n    explicit HandleBase(const DebugEpochBase *Parent)\n        : EpochAddress(&Parent->Epoch), EpochAtCreation(Parent->Epoch) {}\n\n    /// Returns true if the DebugEpochBase this Handle is linked to has\n    /// not called incrementEpoch on itself since the creation of this\n    /// HandleBase instance.\n    bool isHandleInSync() const { return *EpochAddress == EpochAtCreation; }\n\n    /// Returns a pointer to the epoch word stored in the data structure\n    /// this handle points into.  Can be used to check if two iterators point\n    /// into the same data structure.\n    const void *getEpochAddress() const { return EpochAddress; }\n  };\n};\n\n#else\n\nclass DebugEpochBase {\npublic:\n  void incrementEpoch() {}\n\n  class HandleBase {\n  public:\n    HandleBase() = default;\n    explicit HandleBase(const DebugEpochBase *) {}\n    bool isHandleInSync() const { return true; }\n    const void *getEpochAddress() const { return nullptr; }\n  };\n};\n\n#endif // LLVM_ENABLE_ABI_BREAKING_CHECKS\n\n} // namespace llvm\n\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "content": "//===- llvm/ADT/PointerIntPair.h - Pair for pointer and int -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PointerIntPair class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERINTPAIR_H\n#define LLVM_ADT_POINTERINTPAIR_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n\nnamespace llvm {\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <typename PointerT, unsigned IntBits, typename PtrTraits>\nstruct PointerIntPairInfo;\n\n/// PointerIntPair - This class implements a pair of a pointer and small\n/// integer.  It is designed to represent this in the space required by one\n/// pointer by bitmangling the integer into the low part of the pointer.  This\n/// can only be done for small integers: typically up to 3 bits, but it depends\n/// on the number of bits available according to PointerLikeTypeTraits for the\n/// type.\n///\n/// Note that PointerIntPair always puts the IntVal part in the highest bits\n/// possible.  For example, PointerIntPair<void*, 1, bool> will put the bit for\n/// the bool into bit #2, not bit #0, which allows the low two bits to be used\n/// for something else.  For example, this allows:\n///   PointerIntPair<PointerIntPair<void*, 1, bool>, 1, bool>\n/// ... and the two bools will land in different bits.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType = unsigned,\n          typename PtrTraits = PointerLikeTypeTraits<PointerTy>,\n          typename Info = PointerIntPairInfo<PointerTy, IntBits, PtrTraits>>\nclass PointerIntPair {\n  // Used by MSVC visualizer and generally helpful for debugging/visualizing.\n  using InfoTy = Info;\n  intptr_t Value = 0;\n\npublic:\n  constexpr PointerIntPair() = default;\n\n  PointerIntPair(PointerTy PtrVal, IntType IntVal) {\n    setPointerAndInt(PtrVal, IntVal);\n  }\n\n  explicit PointerIntPair(PointerTy PtrVal) { initWithPointer(PtrVal); }\n\n  PointerTy getPointer() const { return Info::getPointer(Value); }\n\n  IntType getInt() const { return (IntType)Info::getInt(Value); }\n\n  void setPointer(PointerTy PtrVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updatePointer(Value, PtrVal);\n  }\n\n  void setInt(IntType IntVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updateInt(Value, static_cast<intptr_t>(IntVal));\n  }\n\n  void initWithPointer(PointerTy PtrVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updatePointer(0, PtrVal);\n  }\n\n  void setPointerAndInt(PointerTy PtrVal, IntType IntVal) LLVM_LVALUE_FUNCTION {\n    Value = Info::updateInt(Info::updatePointer(0, PtrVal),\n                            static_cast<intptr_t>(IntVal));\n  }\n\n  PointerTy const *getAddrOfPointer() const {\n    return const_cast<PointerIntPair *>(this)->getAddrOfPointer();\n  }\n\n  PointerTy *getAddrOfPointer() {\n    assert(Value == reinterpret_cast<intptr_t>(getPointer()) &&\n           \"Can only return the address if IntBits is cleared and \"\n           \"PtrTraits doesn't change the pointer\");\n    return reinterpret_cast<PointerTy *>(&Value);\n  }\n\n  void *getOpaqueValue() const { return reinterpret_cast<void *>(Value); }\n\n  void setFromOpaqueValue(void *Val) LLVM_LVALUE_FUNCTION {\n    Value = reinterpret_cast<intptr_t>(Val);\n  }\n\n  static PointerIntPair getFromOpaqueValue(void *V) {\n    PointerIntPair P;\n    P.setFromOpaqueValue(V);\n    return P;\n  }\n\n  // Allow PointerIntPairs to be created from const void * if and only if the\n  // pointer type could be created from a const void *.\n  static PointerIntPair getFromOpaqueValue(const void *V) {\n    (void)PtrTraits::getFromVoidPointer(V);\n    return getFromOpaqueValue(const_cast<void *>(V));\n  }\n\n  bool operator==(const PointerIntPair &RHS) const {\n    return Value == RHS.Value;\n  }\n\n  bool operator!=(const PointerIntPair &RHS) const {\n    return Value != RHS.Value;\n  }\n\n  bool operator<(const PointerIntPair &RHS) const { return Value < RHS.Value; }\n  bool operator>(const PointerIntPair &RHS) const { return Value > RHS.Value; }\n\n  bool operator<=(const PointerIntPair &RHS) const {\n    return Value <= RHS.Value;\n  }\n\n  bool operator>=(const PointerIntPair &RHS) const {\n    return Value >= RHS.Value;\n  }\n};\n\n// Specialize is_trivially_copyable to avoid limitation of llvm::is_trivially_copyable\n// when compiled with gcc 4.9.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType,\n          typename PtrTraits,\n          typename Info>\nstruct is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>> : std::true_type {\n#ifdef HAVE_STD_IS_TRIVIALLY_COPYABLE\n  static_assert(std::is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>>::value,\n                \"inconsistent behavior between llvm:: and std:: implementation of is_trivially_copyable\");\n#endif\n};\n\n\ntemplate <typename PointerT, unsigned IntBits, typename PtrTraits>\nstruct PointerIntPairInfo {\n  static_assert(PtrTraits::NumLowBitsAvailable <\n                    std::numeric_limits<uintptr_t>::digits,\n                \"cannot use a pointer type that has all bits free\");\n  static_assert(IntBits <= PtrTraits::NumLowBitsAvailable,\n                \"PointerIntPair with integer size too large for pointer\");\n  enum MaskAndShiftConstants : uintptr_t {\n    /// PointerBitMask - The bits that come from the pointer.\n    PointerBitMask =\n        ~(uintptr_t)(((intptr_t)1 << PtrTraits::NumLowBitsAvailable) - 1),\n\n    /// IntShift - The number of low bits that we reserve for other uses, and\n    /// keep zero.\n    IntShift = (uintptr_t)PtrTraits::NumLowBitsAvailable - IntBits,\n\n    /// IntMask - This is the unshifted mask for valid bits of the int type.\n    IntMask = (uintptr_t)(((intptr_t)1 << IntBits) - 1),\n\n    // ShiftedIntMask - This is the bits for the integer shifted in place.\n    ShiftedIntMask = (uintptr_t)(IntMask << IntShift)\n  };\n\n  static PointerT getPointer(intptr_t Value) {\n    return PtrTraits::getFromVoidPointer(\n        reinterpret_cast<void *>(Value & PointerBitMask));\n  }\n\n  static intptr_t getInt(intptr_t Value) {\n    return (Value >> IntShift) & IntMask;\n  }\n\n  static intptr_t updatePointer(intptr_t OrigValue, PointerT Ptr) {\n    intptr_t PtrWord =\n        reinterpret_cast<intptr_t>(PtrTraits::getAsVoidPointer(Ptr));\n    assert((PtrWord & ~PointerBitMask) == 0 &&\n           \"Pointer is not sufficiently aligned\");\n    // Preserve all low bits, just update the pointer.\n    return PtrWord | (OrigValue & ~PointerBitMask);\n  }\n\n  static intptr_t updateInt(intptr_t OrigValue, intptr_t Int) {\n    intptr_t IntWord = static_cast<intptr_t>(Int);\n    assert((IntWord & ~IntMask) == 0 && \"Integer too large for field\");\n\n    // Preserve all bits other than the ones we are updating.\n    return (OrigValue & ~ShiftedIntMask) | IntWord << IntShift;\n  }\n};\n\n// Provide specialization of DenseMapInfo for PointerIntPair.\ntemplate <typename PointerTy, unsigned IntBits, typename IntType>\nstruct DenseMapInfo<PointerIntPair<PointerTy, IntBits, IntType>> {\n  using Ty = PointerIntPair<PointerTy, IntBits, IntType>;\n\n  static Ty getEmptyKey() {\n    uintptr_t Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<Ty>::NumLowBitsAvailable;\n    return Ty::getFromOpaqueValue(reinterpret_cast<void *>(Val));\n  }\n\n  static Ty getTombstoneKey() {\n    uintptr_t Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<PointerTy>::NumLowBitsAvailable;\n    return Ty::getFromOpaqueValue(reinterpret_cast<void *>(Val));\n  }\n\n  static unsigned getHashValue(Ty V) {\n    uintptr_t IV = reinterpret_cast<uintptr_t>(V.getOpaqueValue());\n    return unsigned(IV) ^ unsigned(IV >> 9);\n  }\n\n  static bool isEqual(const Ty &LHS, const Ty &RHS) { return LHS == RHS; }\n};\n\n// Teach SmallPtrSet that PointerIntPair is \"basically a pointer\".\ntemplate <typename PointerTy, unsigned IntBits, typename IntType,\n          typename PtrTraits>\nstruct PointerLikeTypeTraits<\n    PointerIntPair<PointerTy, IntBits, IntType, PtrTraits>> {\n  static inline void *\n  getAsVoidPointer(const PointerIntPair<PointerTy, IntBits, IntType> &P) {\n    return P.getOpaqueValue();\n  }\n\n  static inline PointerIntPair<PointerTy, IntBits, IntType>\n  getFromVoidPointer(void *P) {\n    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);\n  }\n\n  static inline PointerIntPair<PointerTy, IntBits, IntType>\n  getFromVoidPointer(const void *P) {\n    return PointerIntPair<PointerTy, IntBits, IntType>::getFromOpaqueValue(P);\n  }\n\n  static constexpr int NumLowBitsAvailable =\n      PtrTraits::NumLowBitsAvailable - IntBits;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERINTPAIR_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringExtras.h", "content": "//===- llvm/ADT/StringExtras.h - Useful string functions --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains some functions that are useful when dealing with strings.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGEXTRAS_H\n#define LLVM_ADT_STRINGEXTRAS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <iterator>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\ntemplate<typename T> class SmallVectorImpl;\nclass raw_ostream;\n\n/// hexdigit - Return the hexadecimal character for the\n/// given number \\p X (which should be less than 16).\ninline char hexdigit(unsigned X, bool LowerCase = false) {\n  const char HexChar = LowerCase ? 'a' : 'A';\n  return X < 10 ? '0' + X : HexChar + X - 10;\n}\n\n/// Given an array of c-style strings terminated by a null pointer, construct\n/// a vector of StringRefs representing the same strings without the terminating\n/// null string.\ninline std::vector<StringRef> toStringRefArray(const char *const *Strings) {\n  std::vector<StringRef> Result;\n  while (*Strings)\n    Result.push_back(*Strings++);\n  return Result;\n}\n\n/// Construct a string ref from a boolean.\ninline StringRef toStringRef(bool B) { return StringRef(B ? \"true\" : \"false\"); }\n\n/// Construct a string ref from an array ref of unsigned chars.\ninline StringRef toStringRef(ArrayRef<uint8_t> Input) {\n  return StringRef(reinterpret_cast<const char *>(Input.begin()), Input.size());\n}\n\n/// Construct a string ref from an array ref of unsigned chars.\ninline ArrayRef<uint8_t> arrayRefFromStringRef(StringRef Input) {\n  return {Input.bytes_begin(), Input.bytes_end()};\n}\n\n/// Interpret the given character \\p C as a hexadecimal digit and return its\n/// value.\n///\n/// If \\p C is not a valid hex digit, -1U is returned.\ninline unsigned hexDigitValue(char C) {\n  struct HexTable {\n    unsigned LUT[255] = {};\n    constexpr HexTable() {\n      // Default initialize everything to invalid.\n      for (int i = 0; i < 255; ++i)\n        LUT[i] = ~0U;\n      // Initialize `0`-`9`.\n      for (int i = 0; i < 10; ++i)\n        LUT['0' + i] = i;\n      // Initialize `A`-`F` and `a`-`f`.\n      for (int i = 0; i < 6; ++i)\n        LUT['A' + i] = LUT['a' + i] = 10 + i;\n    }\n  };\n  constexpr HexTable Table;\n  return Table.LUT[static_cast<unsigned char>(C)];\n}\n\n/// Checks if character \\p C is one of the 10 decimal digits.\ninline bool isDigit(char C) { return C >= '0' && C <= '9'; }\n\n/// Checks if character \\p C is a hexadecimal numeric character.\ninline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }\n\n/// Checks if character \\p C is a valid letter as classified by \"C\" locale.\ninline bool isAlpha(char C) {\n  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');\n}\n\n/// Checks whether character \\p C is either a decimal digit or an uppercase or\n/// lowercase letter as classified by \"C\" locale.\ninline bool isAlnum(char C) { return isAlpha(C) || isDigit(C); }\n\n/// Checks whether character \\p C is valid ASCII (high bit is zero).\ninline bool isASCII(char C) { return static_cast<unsigned char>(C) <= 127; }\n\n/// Checks whether all characters in S are ASCII.\ninline bool isASCII(llvm::StringRef S) {\n  for (char C : S)\n    if (LLVM_UNLIKELY(!isASCII(C)))\n      return false;\n  return true;\n}\n\n/// Checks whether character \\p C is printable.\n///\n/// Locale-independent version of the C standard library isprint whose results\n/// may differ on different platforms.\ninline bool isPrint(char C) {\n  unsigned char UC = static_cast<unsigned char>(C);\n  return (0x20 <= UC) && (UC <= 0x7E);\n}\n\n/// Checks whether character \\p C is whitespace in the \"C\" locale.\n///\n/// Locale-independent version of the C standard library isspace.\ninline bool isSpace(char C) {\n  return C == ' ' || C == '\\f' || C == '\\n' || C == '\\r' || C == '\\t' ||\n         C == '\\v';\n}\n\n/// Returns the corresponding lowercase character if \\p x is uppercase.\ninline char toLower(char x) {\n  if (x >= 'A' && x <= 'Z')\n    return x - 'A' + 'a';\n  return x;\n}\n\n/// Returns the corresponding uppercase character if \\p x is lowercase.\ninline char toUpper(char x) {\n  if (x >= 'a' && x <= 'z')\n    return x - 'a' + 'A';\n  return x;\n}\n\ninline std::string utohexstr(uint64_t X, bool LowerCase = false) {\n  char Buffer[17];\n  char *BufPtr = std::end(Buffer);\n\n  if (X == 0) *--BufPtr = '0';\n\n  while (X) {\n    unsigned char Mod = static_cast<unsigned char>(X) & 15;\n    *--BufPtr = hexdigit(Mod, LowerCase);\n    X >>= 4;\n  }\n\n  return std::string(BufPtr, std::end(Buffer));\n}\n\n/// Convert buffer \\p Input to its hexadecimal representation.\n/// The returned string is double the size of \\p Input.\ninline std::string toHex(StringRef Input, bool LowerCase = false) {\n  static const char *const LUT = \"0123456789ABCDEF\";\n  const uint8_t Offset = LowerCase ? 32 : 0;\n  size_t Length = Input.size();\n\n  std::string Output;\n  Output.reserve(2 * Length);\n  for (size_t i = 0; i < Length; ++i) {\n    const unsigned char c = Input[i];\n    Output.push_back(LUT[c >> 4] | Offset);\n    Output.push_back(LUT[c & 15] | Offset);\n  }\n  return Output;\n}\n\ninline std::string toHex(ArrayRef<uint8_t> Input, bool LowerCase = false) {\n  return toHex(toStringRef(Input), LowerCase);\n}\n\n/// Store the binary representation of the two provided values, \\p MSB and\n/// \\p LSB, that make up the nibbles of a hexadecimal digit. If \\p MSB or \\p LSB\n/// do not correspond to proper nibbles of a hexadecimal digit, this method\n/// returns false. Otherwise, returns true.\ninline bool tryGetHexFromNibbles(char MSB, char LSB, uint8_t &Hex) {\n  unsigned U1 = hexDigitValue(MSB);\n  unsigned U2 = hexDigitValue(LSB);\n  if (U1 == ~0U || U2 == ~0U)\n    return false;\n\n  Hex = static_cast<uint8_t>((U1 << 4) | U2);\n  return true;\n}\n\n/// Return the binary representation of the two provided values, \\p MSB and\n/// \\p LSB, that make up the nibbles of a hexadecimal digit.\ninline uint8_t hexFromNibbles(char MSB, char LSB) {\n  uint8_t Hex = 0;\n  bool GotHex = tryGetHexFromNibbles(MSB, LSB, Hex);\n  (void)GotHex;\n  assert(GotHex && \"MSB and/or LSB do not correspond to hex digits\");\n  return Hex;\n}\n\n/// Convert hexadecimal string \\p Input to its binary representation and store\n/// the result in \\p Output. Returns true if the binary representation could be\n/// converted from the hexadecimal string. Returns false if \\p Input contains\n/// non-hexadecimal digits. The output string is half the size of \\p Input.\ninline bool tryGetFromHex(StringRef Input, std::string &Output) {\n  if (Input.empty())\n    return true;\n\n  Output.reserve((Input.size() + 1) / 2);\n  if (Input.size() % 2 == 1) {\n    uint8_t Hex = 0;\n    if (!tryGetHexFromNibbles('0', Input.front(), Hex))\n      return false;\n\n    Output.push_back(Hex);\n    Input = Input.drop_front();\n  }\n\n  assert(Input.size() % 2 == 0);\n  while (!Input.empty()) {\n    uint8_t Hex = 0;\n    if (!tryGetHexFromNibbles(Input[0], Input[1], Hex))\n      return false;\n\n    Output.push_back(Hex);\n    Input = Input.drop_front(2);\n  }\n  return true;\n}\n\n/// Convert hexadecimal string \\p Input to its binary representation.\n/// The return string is half the size of \\p Input.\ninline std::string fromHex(StringRef Input) {\n  std::string Hex;\n  bool GotHex = tryGetFromHex(Input, Hex);\n  (void)GotHex;\n  assert(GotHex && \"Input contains non hex digits\");\n  return Hex;\n}\n\n/// Convert the string \\p S to an integer of the specified type using\n/// the radix \\p Base.  If \\p Base is 0, auto-detects the radix.\n/// Returns true if the number was successfully converted, false otherwise.\ntemplate <typename N> bool to_integer(StringRef S, N &Num, unsigned Base = 0) {\n  return !S.getAsInteger(Base, Num);\n}\n\nnamespace detail {\ntemplate <typename N>\ninline bool to_float(const Twine &T, N &Num, N (*StrTo)(const char *, char **)) {\n  SmallString<32> Storage;\n  StringRef S = T.toNullTerminatedStringRef(Storage);\n  char *End;\n  N Temp = StrTo(S.data(), &End);\n  if (*End != '\\0')\n    return false;\n  Num = Temp;\n  return true;\n}\n}\n\ninline bool to_float(const Twine &T, float &Num) {\n  return detail::to_float(T, Num, strtof);\n}\n\ninline bool to_float(const Twine &T, double &Num) {\n  return detail::to_float(T, Num, strtod);\n}\n\ninline bool to_float(const Twine &T, long double &Num) {\n  return detail::to_float(T, Num, strtold);\n}\n\ninline std::string utostr(uint64_t X, bool isNeg = false) {\n  char Buffer[21];\n  char *BufPtr = std::end(Buffer);\n\n  if (X == 0) *--BufPtr = '0';  // Handle special case...\n\n  while (X) {\n    *--BufPtr = '0' + char(X % 10);\n    X /= 10;\n  }\n\n  if (isNeg) *--BufPtr = '-';   // Add negative sign...\n  return std::string(BufPtr, std::end(Buffer));\n}\n\ninline std::string itostr(int64_t X) {\n  if (X < 0)\n    return utostr(static_cast<uint64_t>(1) + ~static_cast<uint64_t>(X), true);\n  else\n    return utostr(static_cast<uint64_t>(X));\n}\n\n/// StrInStrNoCase - Portable version of strcasestr.  Locates the first\n/// occurrence of string 's1' in string 's2', ignoring case.  Returns\n/// the offset of s2 in s1 or npos if s2 cannot be found.\nStringRef::size_type StrInStrNoCase(StringRef s1, StringRef s2);\n\n/// getToken - This function extracts one token from source, ignoring any\n/// leading characters that appear in the Delimiters string, and ending the\n/// token at any of the characters that appear in the Delimiters string.  If\n/// there are no tokens in the source string, an empty string is returned.\n/// The function returns a pair containing the extracted token and the\n/// remaining tail string.\nstd::pair<StringRef, StringRef> getToken(StringRef Source,\n                                         StringRef Delimiters = \" \\t\\n\\v\\f\\r\");\n\n/// SplitString - Split up the specified string according to the specified\n/// delimiters, appending the result fragments to the output list.\nvoid SplitString(StringRef Source,\n                 SmallVectorImpl<StringRef> &OutFragments,\n                 StringRef Delimiters = \" \\t\\n\\v\\f\\r\");\n\n/// Returns the English suffix for an ordinal integer (-st, -nd, -rd, -th).\ninline StringRef getOrdinalSuffix(unsigned Val) {\n  // It is critically important that we do this perfectly for\n  // user-written sequences with over 100 elements.\n  switch (Val % 100) {\n  case 11:\n  case 12:\n  case 13:\n    return \"th\";\n  default:\n    switch (Val % 10) {\n      case 1: return \"st\";\n      case 2: return \"nd\";\n      case 3: return \"rd\";\n      default: return \"th\";\n    }\n  }\n}\n\n/// Print each character of the specified string, escaping it if it is not\n/// printable or if it is an escape char.\nvoid printEscapedString(StringRef Name, raw_ostream &Out);\n\n/// Print each character of the specified string, escaping HTML special\n/// characters.\nvoid printHTMLEscaped(StringRef String, raw_ostream &Out);\n\n/// printLowerCase - Print each character as lowercase if it is uppercase.\nvoid printLowerCase(StringRef String, raw_ostream &Out);\n\n/// Converts a string from camel-case to snake-case by replacing all uppercase\n/// letters with '_' followed by the letter in lowercase, except if the\n/// uppercase letter is the first character of the string.\nstd::string convertToSnakeFromCamelCase(StringRef input);\n\n/// Converts a string from snake-case to camel-case by replacing all occurrences\n/// of '_' followed by a lowercase letter with the letter in uppercase.\n/// Optionally allow capitalization of the first letter (if it is a lowercase\n/// letter)\nstd::string convertToCamelFromSnakeCase(StringRef input,\n                                        bool capitalizeFirst = false);\n\nnamespace detail {\n\ntemplate <typename IteratorT>\ninline std::string join_impl(IteratorT Begin, IteratorT End,\n                             StringRef Separator, std::input_iterator_tag) {\n  std::string S;\n  if (Begin == End)\n    return S;\n\n  S += (*Begin);\n  while (++Begin != End) {\n    S += Separator;\n    S += (*Begin);\n  }\n  return S;\n}\n\ntemplate <typename IteratorT>\ninline std::string join_impl(IteratorT Begin, IteratorT End,\n                             StringRef Separator, std::forward_iterator_tag) {\n  std::string S;\n  if (Begin == End)\n    return S;\n\n  size_t Len = (std::distance(Begin, End) - 1) * Separator.size();\n  for (IteratorT I = Begin; I != End; ++I)\n    Len += (*I).size();\n  S.reserve(Len);\n  size_t PrevCapacity = S.capacity();\n  (void)PrevCapacity;\n  S += (*Begin);\n  while (++Begin != End) {\n    S += Separator;\n    S += (*Begin);\n  }\n  assert(PrevCapacity == S.capacity() && \"String grew during building\");\n  return S;\n}\n\ntemplate <typename Sep>\ninline void join_items_impl(std::string &Result, Sep Separator) {}\n\ntemplate <typename Sep, typename Arg>\ninline void join_items_impl(std::string &Result, Sep Separator,\n                            const Arg &Item) {\n  Result += Item;\n}\n\ntemplate <typename Sep, typename Arg1, typename... Args>\ninline void join_items_impl(std::string &Result, Sep Separator, const Arg1 &A1,\n                            Args &&... Items) {\n  Result += A1;\n  Result += Separator;\n  join_items_impl(Result, Separator, std::forward<Args>(Items)...);\n}\n\ninline size_t join_one_item_size(char) { return 1; }\ninline size_t join_one_item_size(const char *S) { return S ? ::strlen(S) : 0; }\n\ntemplate <typename T> inline size_t join_one_item_size(const T &Str) {\n  return Str.size();\n}\n\ninline size_t join_items_size() { return 0; }\n\ntemplate <typename A1> inline size_t join_items_size(const A1 &A) {\n  return join_one_item_size(A);\n}\ntemplate <typename A1, typename... Args>\ninline size_t join_items_size(const A1 &A, Args &&... Items) {\n  return join_one_item_size(A) + join_items_size(std::forward<Args>(Items)...);\n}\n\n} // end namespace detail\n\n/// Joins the strings in the range [Begin, End), adding Separator between\n/// the elements.\ntemplate <typename IteratorT>\ninline std::string join(IteratorT Begin, IteratorT End, StringRef Separator) {\n  using tag = typename std::iterator_traits<IteratorT>::iterator_category;\n  return detail::join_impl(Begin, End, Separator, tag());\n}\n\n/// Joins the strings in the range [R.begin(), R.end()), adding Separator\n/// between the elements.\ntemplate <typename Range>\ninline std::string join(Range &&R, StringRef Separator) {\n  return join(R.begin(), R.end(), Separator);\n}\n\n/// Joins the strings in the parameter pack \\p Items, adding \\p Separator\n/// between the elements.  All arguments must be implicitly convertible to\n/// std::string, or there should be an overload of std::string::operator+=()\n/// that accepts the argument explicitly.\ntemplate <typename Sep, typename... Args>\ninline std::string join_items(Sep Separator, Args &&... Items) {\n  std::string Result;\n  if (sizeof...(Items) == 0)\n    return Result;\n\n  size_t NS = detail::join_one_item_size(Separator);\n  size_t NI = detail::join_items_size(std::forward<Args>(Items)...);\n  Result.reserve(NI + (sizeof...(Items) - 1) * NS + 1);\n  detail::join_items_impl(Result, Separator, std::forward<Args>(Items)...);\n  return Result;\n}\n\n/// A helper class to return the specified delimiter string after the first\n/// invocation of operator StringRef().  Used to generate a comma-separated\n/// list from a loop like so:\n///\n/// \\code\n///   ListSeparator LS;\n///   for (auto &I : C)\n///     OS << LS << I.getName();\n/// \\end\nclass ListSeparator {\n  bool First = true;\n  StringRef Separator;\n\npublic:\n  ListSeparator(StringRef Separator = \", \") : Separator(Separator) {}\n  operator StringRef() {\n    if (First) {\n      First = false;\n      return {};\n    }\n    return Separator;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGEXTRAS_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Triple.h", "content": "//===-- llvm/ADT/Triple.h - Target triple helper class ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_TRIPLE_H\n#define LLVM_ADT_TRIPLE_H\n\n#include \"llvm/ADT/Twine.h\"\n\n// Some system headers or GCC predefined macros conflict with identifiers in\n// this file.  Undefine them here.\n#undef NetBSD\n#undef mips\n#undef sparc\n\nnamespace llvm {\n\nclass VersionTuple;\n\n/// Triple - Helper class for working with autoconf configuration names. For\n/// historical reasons, we also call these 'triples' (they used to contain\n/// exactly three fields).\n///\n/// Configuration names are strings in the canonical form:\n///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM\n/// or\n///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT\n///\n/// This class is used for clients which want to support arbitrary\n/// configuration names, but also want to implement certain special\n/// behavior for particular configurations. This class isolates the mapping\n/// from the components of the configuration name to well known IDs.\n///\n/// At its core the Triple class is designed to be a wrapper for a triple\n/// string; the constructor does not change or normalize the triple string.\n/// Clients that need to handle the non-canonical triples that users often\n/// specify should use the normalize method.\n///\n/// See autoconf/config.guess for a glimpse into what configuration names\n/// look like in practice.\nclass Triple {\npublic:\n  enum ArchType {\n    UnknownArch,\n\n    arm,            // ARM (little endian): arm, armv.*, xscale\n    armeb,          // ARM (big endian): armeb\n    aarch64,        // AArch64 (little endian): aarch64\n    aarch64_be,     // AArch64 (big endian): aarch64_be\n    aarch64_32,     // AArch64 (little endian) ILP32: aarch64_32\n    arc,            // ARC: Synopsys ARC\n    avr,            // AVR: Atmel AVR microcontroller\n    bpfel,          // eBPF or extended BPF or 64-bit BPF (little endian)\n    bpfeb,          // eBPF or extended BPF or 64-bit BPF (big endian)\n    csky,           // CSKY: csky\n    hexagon,        // Hexagon: hexagon\n    m68k,           // M68k: Motorola 680x0 family\n    mips,           // MIPS: mips, mipsallegrex, mipsr6\n    mipsel,         // MIPSEL: mipsel, mipsallegrexe, mipsr6el\n    mips64,         // MIPS64: mips64, mips64r6, mipsn32, mipsn32r6\n    mips64el,       // MIPS64EL: mips64el, mips64r6el, mipsn32el, mipsn32r6el\n    msp430,         // MSP430: msp430\n    ppc,            // PPC: powerpc\n    ppcle,          // PPCLE: powerpc (little endian)\n    ppc64,          // PPC64: powerpc64, ppu\n    ppc64le,        // PPC64LE: powerpc64le\n    r600,           // R600: AMD GPUs HD2XXX - HD6XXX\n    amdgcn,         // AMDGCN: AMD GCN GPUs\n    riscv32,        // RISC-V (32-bit): riscv32\n    riscv64,        // RISC-V (64-bit): riscv64\n    sparc,          // Sparc: sparc\n    sparcv9,        // Sparcv9: Sparcv9\n    sparcel,        // Sparc: (endianness = little). NB: 'Sparcle' is a CPU variant\n    systemz,        // SystemZ: s390x\n    tce,            // TCE (http://tce.cs.tut.fi/): tce\n    tcele,          // TCE little endian (http://tce.cs.tut.fi/): tcele\n    thumb,          // Thumb (little endian): thumb, thumbv.*\n    thumbeb,        // Thumb (big endian): thumbeb\n    x86,            // X86: i[3-9]86\n    x86_64,         // X86-64: amd64, x86_64\n    xcore,          // XCore: xcore\n    nvptx,          // NVPTX: 32-bit\n    nvptx64,        // NVPTX: 64-bit\n    le32,           // le32: generic little-endian 32-bit CPU (PNaCl)\n    le64,           // le64: generic little-endian 64-bit CPU (PNaCl)\n    amdil,          // AMDIL\n    amdil64,        // AMDIL with 64-bit pointers\n    hsail,          // AMD HSAIL\n    hsail64,        // AMD HSAIL with 64-bit pointers\n    spir,           // SPIR: standard portable IR for OpenCL 32-bit version\n    spir64,         // SPIR: standard portable IR for OpenCL 64-bit version\n    kalimba,        // Kalimba: generic kalimba\n    shave,          // SHAVE: Movidius vector VLIW processors\n    lanai,          // Lanai: Lanai 32-bit\n    wasm32,         // WebAssembly with 32-bit pointers\n    wasm64,         // WebAssembly with 64-bit pointers\n    renderscript32, // 32-bit RenderScript\n    renderscript64, // 64-bit RenderScript\n    ve,             // NEC SX-Aurora Vector Engine\n    LastArchType = ve\n  };\n  enum SubArchType {\n    NoSubArch,\n\n    ARMSubArch_v8_7a,\n    ARMSubArch_v8_6a,\n    ARMSubArch_v8_5a,\n    ARMSubArch_v8_4a,\n    ARMSubArch_v8_3a,\n    ARMSubArch_v8_2a,\n    ARMSubArch_v8_1a,\n    ARMSubArch_v8,\n    ARMSubArch_v8r,\n    ARMSubArch_v8m_baseline,\n    ARMSubArch_v8m_mainline,\n    ARMSubArch_v8_1m_mainline,\n    ARMSubArch_v7,\n    ARMSubArch_v7em,\n    ARMSubArch_v7m,\n    ARMSubArch_v7s,\n    ARMSubArch_v7k,\n    ARMSubArch_v7ve,\n    ARMSubArch_v6,\n    ARMSubArch_v6m,\n    ARMSubArch_v6k,\n    ARMSubArch_v6t2,\n    ARMSubArch_v5,\n    ARMSubArch_v5te,\n    ARMSubArch_v4t,\n\n    AArch64SubArch_arm64e,\n\n    KalimbaSubArch_v3,\n    KalimbaSubArch_v4,\n    KalimbaSubArch_v5,\n\n    MipsSubArch_r6,\n\n    PPCSubArch_spe\n  };\n  enum VendorType {\n    UnknownVendor,\n\n    Apple,\n    PC,\n    SCEI,\n    Freescale,\n    IBM,\n    ImaginationTechnologies,\n    MipsTechnologies,\n    NVIDIA,\n    CSR,\n    Myriad,\n    AMD,\n    Mesa,\n    SUSE,\n    OpenEmbedded,\n    LastVendorType = OpenEmbedded\n  };\n  enum OSType {\n    UnknownOS,\n\n    Ananas,\n    CloudABI,\n    Darwin,\n    DragonFly,\n    FreeBSD,\n    Fuchsia,\n    IOS,\n    KFreeBSD,\n    Linux,\n    Lv2,        // PS3\n    MacOSX,\n    NetBSD,\n    OpenBSD,\n    Solaris,\n    Win32,\n    ZOS,\n    Haiku,\n    Minix,\n    RTEMS,\n    NaCl,       // Native Client\n    AIX,\n    CUDA,       // NVIDIA CUDA\n    NVCL,       // NVIDIA OpenCL\n    AMDHSA,     // AMD HSA Runtime\n    PS4,\n    ELFIAMCU,\n    TvOS,       // Apple tvOS\n    WatchOS,    // Apple watchOS\n    Mesa3D,\n    Contiki,\n    AMDPAL,     // AMD PAL Runtime\n    HermitCore, // HermitCore Unikernel/Multikernel\n    Hurd,       // GNU/Hurd\n    WASI,       // Experimental WebAssembly OS\n    Emscripten,\n    LastOSType = Emscripten\n  };\n  enum EnvironmentType {\n    UnknownEnvironment,\n\n    GNU,\n    GNUABIN32,\n    GNUABI64,\n    GNUEABI,\n    GNUEABIHF,\n    GNUX32,\n    GNUILP32,\n    CODE16,\n    EABI,\n    EABIHF,\n    Android,\n    Musl,\n    MuslEABI,\n    MuslEABIHF,\n\n    MSVC,\n    Itanium,\n    Cygnus,\n    CoreCLR,\n    Simulator, // Simulator variants of other systems, e.g., Apple's iOS\n    MacABI, // Mac Catalyst variant of Apple's iOS deployment target.\n    LastEnvironmentType = MacABI\n  };\n  enum ObjectFormatType {\n    UnknownObjectFormat,\n\n    COFF,\n    ELF,\n    GOFF,\n    MachO,\n    Wasm,\n    XCOFF,\n  };\n\nprivate:\n  std::string Data;\n\n  /// The parsed arch type.\n  ArchType Arch;\n\n  /// The parsed subarchitecture type.\n  SubArchType SubArch;\n\n  /// The parsed vendor type.\n  VendorType Vendor;\n\n  /// The parsed OS type.\n  OSType OS;\n\n  /// The parsed Environment type.\n  EnvironmentType Environment;\n\n  /// The object format type.\n  ObjectFormatType ObjectFormat;\n\npublic:\n  /// @name Constructors\n  /// @{\n\n  /// Default constructor is the same as an empty string and leaves all\n  /// triple fields unknown.\n  Triple()\n      : Data(), Arch(), SubArch(), Vendor(), OS(), Environment(),\n        ObjectFormat() {}\n\n  explicit Triple(const Twine &Str);\n  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr);\n  Triple(const Twine &ArchStr, const Twine &VendorStr, const Twine &OSStr,\n         const Twine &EnvironmentStr);\n\n  bool operator==(const Triple &Other) const {\n    return Arch == Other.Arch && SubArch == Other.SubArch &&\n           Vendor == Other.Vendor && OS == Other.OS &&\n           Environment == Other.Environment &&\n           ObjectFormat == Other.ObjectFormat;\n  }\n\n  bool operator!=(const Triple &Other) const {\n    return !(*this == Other);\n  }\n\n  /// @}\n  /// @name Normalization\n  /// @{\n\n  /// normalize - Turn an arbitrary machine specification into the canonical\n  /// triple form (or something sensible that the Triple class understands if\n  /// nothing better can reasonably be done).  In particular, it handles the\n  /// common case in which otherwise valid components are in the wrong order.\n  static std::string normalize(StringRef Str);\n\n  /// Return the normalized form of this triple's string.\n  std::string normalize() const { return normalize(Data); }\n\n  /// @}\n  /// @name Typed Component Access\n  /// @{\n\n  /// getArch - Get the parsed architecture type of this triple.\n  ArchType getArch() const { return Arch; }\n\n  /// getSubArch - get the parsed subarchitecture type for this triple.\n  SubArchType getSubArch() const { return SubArch; }\n\n  /// getVendor - Get the parsed vendor type of this triple.\n  VendorType getVendor() const { return Vendor; }\n\n  /// getOS - Get the parsed operating system type of this triple.\n  OSType getOS() const { return OS; }\n\n  /// hasEnvironment - Does this triple have the optional environment\n  /// (fourth) component?\n  bool hasEnvironment() const {\n    return getEnvironmentName() != \"\";\n  }\n\n  /// getEnvironment - Get the parsed environment type of this triple.\n  EnvironmentType getEnvironment() const { return Environment; }\n\n  /// Parse the version number from the OS name component of the\n  /// triple, if present.\n  ///\n  /// For example, \"fooos1.2.3\" would return (1, 2, 3).\n  ///\n  /// If an entry is not defined, it will be returned as 0.\n  void getEnvironmentVersion(unsigned &Major, unsigned &Minor,\n                             unsigned &Micro) const;\n\n  /// getFormat - Get the object format for this triple.\n  ObjectFormatType getObjectFormat() const { return ObjectFormat; }\n\n  /// getOSVersion - Parse the version number from the OS name component of the\n  /// triple, if present.\n  ///\n  /// For example, \"fooos1.2.3\" would return (1, 2, 3).\n  ///\n  /// If an entry is not defined, it will be returned as 0.\n  void getOSVersion(unsigned &Major, unsigned &Minor, unsigned &Micro) const;\n\n  /// getOSMajorVersion - Return just the major version number, this is\n  /// specialized because it is a common query.\n  unsigned getOSMajorVersion() const {\n    unsigned Maj, Min, Micro;\n    getOSVersion(Maj, Min, Micro);\n    return Maj;\n  }\n\n  /// getMacOSXVersion - Parse the version number as with getOSVersion and then\n  /// translate generic \"darwin\" versions to the corresponding OS X versions.\n  /// This may also be called with IOS triples but the OS X version number is\n  /// just set to a constant 10.4.0 in that case.  Returns true if successful.\n  bool getMacOSXVersion(unsigned &Major, unsigned &Minor,\n                        unsigned &Micro) const;\n\n  /// getiOSVersion - Parse the version number as with getOSVersion.  This should\n  /// only be called with IOS or generic triples.\n  void getiOSVersion(unsigned &Major, unsigned &Minor,\n                     unsigned &Micro) const;\n\n  /// getWatchOSVersion - Parse the version number as with getOSVersion.  This\n  /// should only be called with WatchOS or generic triples.\n  void getWatchOSVersion(unsigned &Major, unsigned &Minor,\n                         unsigned &Micro) const;\n\n  /// @}\n  /// @name Direct Component Access\n  /// @{\n\n  const std::string &str() const { return Data; }\n\n  const std::string &getTriple() const { return Data; }\n\n  /// getArchName - Get the architecture (first) component of the\n  /// triple.\n  StringRef getArchName() const;\n\n  /// getVendorName - Get the vendor (second) component of the triple.\n  StringRef getVendorName() const;\n\n  /// getOSName - Get the operating system (third) component of the\n  /// triple.\n  StringRef getOSName() const;\n\n  /// getEnvironmentName - Get the optional environment (fourth)\n  /// component of the triple, or \"\" if empty.\n  StringRef getEnvironmentName() const;\n\n  /// getOSAndEnvironmentName - Get the operating system and optional\n  /// environment components as a single string (separated by a '-'\n  /// if the environment component is present).\n  StringRef getOSAndEnvironmentName() const;\n\n  /// @}\n  /// @name Convenience Predicates\n  /// @{\n\n  /// Test whether the architecture is 64-bit\n  ///\n  /// Note that this tests for 64-bit pointer width, and nothing else. Note\n  /// that we intentionally expose only three predicates, 64-bit, 32-bit, and\n  /// 16-bit. The inner details of pointer width for particular architectures\n  /// is not summed up in the triple, and so only a coarse grained predicate\n  /// system is provided.\n  bool isArch64Bit() const;\n\n  /// Test whether the architecture is 32-bit\n  ///\n  /// Note that this tests for 32-bit pointer width, and nothing else.\n  bool isArch32Bit() const;\n\n  /// Test whether the architecture is 16-bit\n  ///\n  /// Note that this tests for 16-bit pointer width, and nothing else.\n  bool isArch16Bit() const;\n\n  /// isOSVersionLT - Helper function for doing comparisons against version\n  /// numbers included in the target triple.\n  bool isOSVersionLT(unsigned Major, unsigned Minor = 0,\n                     unsigned Micro = 0) const {\n    unsigned LHS[3];\n    getOSVersion(LHS[0], LHS[1], LHS[2]);\n\n    if (LHS[0] != Major)\n      return LHS[0] < Major;\n    if (LHS[1] != Minor)\n      return LHS[1] < Minor;\n    if (LHS[2] != Micro)\n      return LHS[2] < Micro;\n\n    return false;\n  }\n\n  bool isOSVersionLT(const Triple &Other) const {\n    unsigned RHS[3];\n    Other.getOSVersion(RHS[0], RHS[1], RHS[2]);\n    return isOSVersionLT(RHS[0], RHS[1], RHS[2]);\n  }\n\n  /// isMacOSXVersionLT - Comparison function for checking OS X version\n  /// compatibility, which handles supporting skewed version numbering schemes\n  /// used by the \"darwin\" triples.\n  bool isMacOSXVersionLT(unsigned Major, unsigned Minor = 0,\n                         unsigned Micro = 0) const;\n\n  /// isMacOSX - Is this a Mac OS X triple. For legacy reasons, we support both\n  /// \"darwin\" and \"osx\" as OS X triples.\n  bool isMacOSX() const {\n    return getOS() == Triple::Darwin || getOS() == Triple::MacOSX;\n  }\n\n  /// Is this an iOS triple.\n  /// Note: This identifies tvOS as a variant of iOS. If that ever\n  /// changes, i.e., if the two operating systems diverge or their version\n  /// numbers get out of sync, that will need to be changed.\n  /// watchOS has completely different version numbers so it is not included.\n  bool isiOS() const {\n    return getOS() == Triple::IOS || isTvOS();\n  }\n\n  /// Is this an Apple tvOS triple.\n  bool isTvOS() const {\n    return getOS() == Triple::TvOS;\n  }\n\n  /// Is this an Apple watchOS triple.\n  bool isWatchOS() const {\n    return getOS() == Triple::WatchOS;\n  }\n\n  bool isWatchABI() const {\n    return getSubArch() == Triple::ARMSubArch_v7k;\n  }\n\n  bool isOSzOS() const { return getOS() == Triple::ZOS; }\n\n  /// isOSDarwin - Is this a \"Darwin\" OS (macOS, iOS, tvOS or watchOS).\n  bool isOSDarwin() const {\n    return isMacOSX() || isiOS() || isWatchOS();\n  }\n\n  bool isSimulatorEnvironment() const {\n    return getEnvironment() == Triple::Simulator;\n  }\n\n  bool isMacCatalystEnvironment() const {\n    return getEnvironment() == Triple::MacABI;\n  }\n\n  /// Returns true for targets that run on a macOS machine.\n  bool isTargetMachineMac() const {\n    return isMacOSX() || (isOSDarwin() && (isSimulatorEnvironment() ||\n                                           isMacCatalystEnvironment()));\n  }\n\n  bool isOSNetBSD() const {\n    return getOS() == Triple::NetBSD;\n  }\n\n  bool isOSOpenBSD() const {\n    return getOS() == Triple::OpenBSD;\n  }\n\n  bool isOSFreeBSD() const {\n    return getOS() == Triple::FreeBSD;\n  }\n\n  bool isOSFuchsia() const {\n    return getOS() == Triple::Fuchsia;\n  }\n\n  bool isOSDragonFly() const { return getOS() == Triple::DragonFly; }\n\n  bool isOSSolaris() const {\n    return getOS() == Triple::Solaris;\n  }\n\n  bool isOSIAMCU() const {\n    return getOS() == Triple::ELFIAMCU;\n  }\n\n  bool isOSUnknown() const { return getOS() == Triple::UnknownOS; }\n\n  bool isGNUEnvironment() const {\n    EnvironmentType Env = getEnvironment();\n    return Env == Triple::GNU || Env == Triple::GNUABIN32 ||\n           Env == Triple::GNUABI64 || Env == Triple::GNUEABI ||\n           Env == Triple::GNUEABIHF || Env == Triple::GNUX32;\n  }\n\n  bool isOSContiki() const {\n    return getOS() == Triple::Contiki;\n  }\n\n  /// Tests whether the OS is Haiku.\n  bool isOSHaiku() const {\n    return getOS() == Triple::Haiku;\n  }\n\n  /// Tests whether the OS is Windows.\n  bool isOSWindows() const {\n    return getOS() == Triple::Win32;\n  }\n\n  /// Checks if the environment is MSVC.\n  bool isKnownWindowsMSVCEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::MSVC;\n  }\n\n  /// Checks if the environment could be MSVC.\n  bool isWindowsMSVCEnvironment() const {\n    return isKnownWindowsMSVCEnvironment() ||\n           (isOSWindows() && getEnvironment() == Triple::UnknownEnvironment);\n  }\n\n  bool isWindowsCoreCLREnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::CoreCLR;\n  }\n\n  bool isWindowsItaniumEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::Itanium;\n  }\n\n  bool isWindowsCygwinEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::Cygnus;\n  }\n\n  bool isWindowsGNUEnvironment() const {\n    return isOSWindows() && getEnvironment() == Triple::GNU;\n  }\n\n  /// Tests for either Cygwin or MinGW OS\n  bool isOSCygMing() const {\n    return isWindowsCygwinEnvironment() || isWindowsGNUEnvironment();\n  }\n\n  /// Is this a \"Windows\" OS targeting a \"MSVCRT.dll\" environment.\n  bool isOSMSVCRT() const {\n    return isWindowsMSVCEnvironment() || isWindowsGNUEnvironment() ||\n           isWindowsItaniumEnvironment();\n  }\n\n  /// Tests whether the OS is NaCl (Native Client)\n  bool isOSNaCl() const {\n    return getOS() == Triple::NaCl;\n  }\n\n  /// Tests whether the OS is Linux.\n  bool isOSLinux() const {\n    return getOS() == Triple::Linux;\n  }\n\n  /// Tests whether the OS is kFreeBSD.\n  bool isOSKFreeBSD() const {\n    return getOS() == Triple::KFreeBSD;\n  }\n\n  /// Tests whether the OS is Hurd.\n  bool isOSHurd() const {\n    return getOS() == Triple::Hurd;\n  }\n\n  /// Tests whether the OS is WASI.\n  bool isOSWASI() const {\n    return getOS() == Triple::WASI;\n  }\n\n  /// Tests whether the OS is Emscripten.\n  bool isOSEmscripten() const {\n    return getOS() == Triple::Emscripten;\n  }\n\n  /// Tests whether the OS uses glibc.\n  bool isOSGlibc() const {\n    return (getOS() == Triple::Linux || getOS() == Triple::KFreeBSD ||\n            getOS() == Triple::Hurd) &&\n           !isAndroid();\n  }\n\n  /// Tests whether the OS is AIX.\n  bool isOSAIX() const {\n    return getOS() == Triple::AIX;\n  }\n\n  /// Tests whether the OS uses the ELF binary format.\n  bool isOSBinFormatELF() const {\n    return getObjectFormat() == Triple::ELF;\n  }\n\n  /// Tests whether the OS uses the COFF binary format.\n  bool isOSBinFormatCOFF() const {\n    return getObjectFormat() == Triple::COFF;\n  }\n\n  /// Tests whether the OS uses the GOFF binary format.\n  bool isOSBinFormatGOFF() const { return getObjectFormat() == Triple::GOFF; }\n\n  /// Tests whether the environment is MachO.\n  bool isOSBinFormatMachO() const {\n    return getObjectFormat() == Triple::MachO;\n  }\n\n  /// Tests whether the OS uses the Wasm binary format.\n  bool isOSBinFormatWasm() const {\n    return getObjectFormat() == Triple::Wasm;\n  }\n\n  /// Tests whether the OS uses the XCOFF binary format.\n  bool isOSBinFormatXCOFF() const {\n    return getObjectFormat() == Triple::XCOFF;\n  }\n\n  /// Tests whether the target is the PS4 CPU\n  bool isPS4CPU() const {\n    return getArch() == Triple::x86_64 &&\n           getVendor() == Triple::SCEI &&\n           getOS() == Triple::PS4;\n  }\n\n  /// Tests whether the target is the PS4 platform\n  bool isPS4() const {\n    return getVendor() == Triple::SCEI &&\n           getOS() == Triple::PS4;\n  }\n\n  /// Tests whether the target is Android\n  bool isAndroid() const { return getEnvironment() == Triple::Android; }\n\n  bool isAndroidVersionLT(unsigned Major) const {\n    assert(isAndroid() && \"Not an Android triple!\");\n\n    unsigned Env[3];\n    getEnvironmentVersion(Env[0], Env[1], Env[2]);\n\n    // 64-bit targets did not exist before API level 21 (Lollipop).\n    if (isArch64Bit() && Env[0] < 21)\n      Env[0] = 21;\n\n    return Env[0] < Major;\n  }\n\n  /// Tests whether the environment is musl-libc\n  bool isMusl() const {\n    return getEnvironment() == Triple::Musl ||\n           getEnvironment() == Triple::MuslEABI ||\n           getEnvironment() == Triple::MuslEABIHF;\n  }\n\n  /// Tests whether the target is SPIR (32- or 64-bit).\n  bool isSPIR() const {\n    return getArch() == Triple::spir || getArch() == Triple::spir64;\n  }\n\n  /// Tests whether the target is NVPTX (32- or 64-bit).\n  bool isNVPTX() const {\n    return getArch() == Triple::nvptx || getArch() == Triple::nvptx64;\n  }\n\n  /// Tests whether the target is AMDGCN\n  bool isAMDGCN() const { return getArch() == Triple::amdgcn; }\n\n  bool isAMDGPU() const {\n    return getArch() == Triple::r600 || getArch() == Triple::amdgcn;\n  }\n\n  /// Tests whether the target is Thumb (little and big endian).\n  bool isThumb() const {\n    return getArch() == Triple::thumb || getArch() == Triple::thumbeb;\n  }\n\n  /// Tests whether the target is ARM (little and big endian).\n  bool isARM() const {\n    return getArch() == Triple::arm || getArch() == Triple::armeb;\n  }\n\n  /// Tests whether the target is AArch64 (little and big endian).\n  bool isAArch64() const {\n    return getArch() == Triple::aarch64 || getArch() == Triple::aarch64_be ||\n           getArch() == Triple::aarch64_32;\n  }\n\n  /// Tests whether the target is AArch64 and pointers are the size specified by\n  /// \\p PointerWidth.\n  bool isAArch64(int PointerWidth) const {\n    assert(PointerWidth == 64 || PointerWidth == 32);\n    if (!isAArch64())\n      return false;\n    return getArch() == Triple::aarch64_32 ||\n                   getEnvironment() == Triple::GNUILP32\n               ? PointerWidth == 32\n               : PointerWidth == 64;\n  }\n\n  /// Tests whether the target is MIPS 32-bit (little and big endian).\n  bool isMIPS32() const {\n    return getArch() == Triple::mips || getArch() == Triple::mipsel;\n  }\n\n  /// Tests whether the target is MIPS 64-bit (little and big endian).\n  bool isMIPS64() const {\n    return getArch() == Triple::mips64 || getArch() == Triple::mips64el;\n  }\n\n  /// Tests whether the target is MIPS (little and big endian, 32- or 64-bit).\n  bool isMIPS() const {\n    return isMIPS32() || isMIPS64();\n  }\n\n  /// Tests whether the target is PowerPC (32- or 64-bit LE or BE).\n  bool isPPC() const {\n    return getArch() == Triple::ppc || getArch() == Triple::ppc64 ||\n           getArch() == Triple::ppcle || getArch() == Triple::ppc64le;\n  }\n\n  /// Tests whether the target is 32-bit PowerPC (little and big endian).\n  bool isPPC32() const {\n    return getArch() == Triple::ppc || getArch() == Triple::ppcle;\n  }\n\n  /// Tests whether the target is 64-bit PowerPC (little and big endian).\n  bool isPPC64() const {\n    return getArch() == Triple::ppc64 || getArch() == Triple::ppc64le;\n  }\n\n  /// Tests whether the target is RISC-V (32- and 64-bit).\n  bool isRISCV() const {\n    return getArch() == Triple::riscv32 || getArch() == Triple::riscv64;\n  }\n\n  /// Tests whether the target is SystemZ.\n  bool isSystemZ() const {\n    return getArch() == Triple::systemz;\n  }\n\n  /// Tests whether the target is x86 (32- or 64-bit).\n  bool isX86() const {\n    return getArch() == Triple::x86 || getArch() == Triple::x86_64;\n  }\n\n  /// Tests whether the target is VE\n  bool isVE() const {\n    return getArch() == Triple::ve;\n  }\n\n  /// Tests whether the target is wasm (32- and 64-bit).\n  bool isWasm() const {\n    return getArch() == Triple::wasm32 || getArch() == Triple::wasm64;\n  }\n\n  // Tests whether the target is CSKY\n  bool isCSKY() const {\n    return getArch() == Triple::csky;\n  }\n\n  /// Tests whether the target is the Apple \"arm64e\" AArch64 subarch.\n  bool isArm64e() const {\n    return getArch() == Triple::aarch64 &&\n           getSubArch() == Triple::AArch64SubArch_arm64e;\n  }\n\n  /// Tests whether the target supports comdat\n  bool supportsCOMDAT() const {\n    return !(isOSBinFormatMachO() || isOSBinFormatXCOFF());\n  }\n\n  /// Tests whether the target uses emulated TLS as default.\n  bool hasDefaultEmulatedTLS() const {\n    return isAndroid() || isOSOpenBSD() || isWindowsCygwinEnvironment();\n  }\n\n  /// Tests whether the target uses -data-sections as default.\n  bool hasDefaultDataSections() const {\n    return isOSBinFormatXCOFF() || isWasm();\n  }\n\n  /// Tests if the environment supports dllimport/export annotations.\n  bool hasDLLImportExport() const { return isOSWindows() || isPS4CPU(); }\n\n  /// @}\n  /// @name Mutators\n  /// @{\n\n  /// setArch - Set the architecture (first) component of the triple\n  /// to a known type.\n  void setArch(ArchType Kind);\n\n  /// setVendor - Set the vendor (second) component of the triple to a\n  /// known type.\n  void setVendor(VendorType Kind);\n\n  /// setOS - Set the operating system (third) component of the triple\n  /// to a known type.\n  void setOS(OSType Kind);\n\n  /// setEnvironment - Set the environment (fourth) component of the triple\n  /// to a known type.\n  void setEnvironment(EnvironmentType Kind);\n\n  /// setObjectFormat - Set the object file format\n  void setObjectFormat(ObjectFormatType Kind);\n\n  /// setTriple - Set all components to the new triple \\p Str.\n  void setTriple(const Twine &Str);\n\n  /// setArchName - Set the architecture (first) component of the\n  /// triple by name.\n  void setArchName(StringRef Str);\n\n  /// setVendorName - Set the vendor (second) component of the triple\n  /// by name.\n  void setVendorName(StringRef Str);\n\n  /// setOSName - Set the operating system (third) component of the\n  /// triple by name.\n  void setOSName(StringRef Str);\n\n  /// setEnvironmentName - Set the optional environment (fourth)\n  /// component of the triple by name.\n  void setEnvironmentName(StringRef Str);\n\n  /// setOSAndEnvironmentName - Set the operating system and optional\n  /// environment components with a single string.\n  void setOSAndEnvironmentName(StringRef Str);\n\n  /// @}\n  /// @name Helpers to build variants of a particular triple.\n  /// @{\n\n  /// Form a triple with a 32-bit variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a 32-bit architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple get32BitArchVariant() const;\n\n  /// Form a triple with a 64-bit variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a 64-bit architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple get64BitArchVariant() const;\n\n  /// Form a triple with a big endian variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a big endian architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple getBigEndianArchVariant() const;\n\n  /// Form a triple with a little endian variant of the current architecture.\n  ///\n  /// This can be used to move across \"families\" of architectures where useful.\n  ///\n  /// \\returns A new triple with a little endian architecture or an unknown\n  ///          architecture if no such variant can be found.\n  llvm::Triple getLittleEndianArchVariant() const;\n\n  /// Get the (LLVM) name of the minimum ARM CPU for the arch we are targeting.\n  ///\n  /// \\param Arch the architecture name (e.g., \"armv7s\"). If it is an empty\n  /// string then the triple's arch name is used.\n  StringRef getARMCPUForArch(StringRef Arch = StringRef()) const;\n\n  /// Tests whether the target triple is little endian.\n  ///\n  /// \\returns true if the triple is little endian, false otherwise.\n  bool isLittleEndian() const;\n\n  /// Test whether target triples are compatible.\n  bool isCompatibleWith(const Triple &Other) const;\n\n  /// Merge target triples.\n  std::string merge(const Triple &Other) const;\n\n  /// Some platforms have different minimum supported OS versions that\n  /// varies by the architecture specified in the triple. This function\n  /// returns the minimum supported OS version for this triple if one an exists,\n  /// or an invalid version tuple if this triple doesn't have one.\n  VersionTuple getMinimumSupportedOSVersion() const;\n\n  /// @}\n  /// @name Static helpers for IDs.\n  /// @{\n\n  /// getArchTypeName - Get the canonical name for the \\p Kind architecture.\n  static StringRef getArchTypeName(ArchType Kind);\n\n  /// getArchTypePrefix - Get the \"prefix\" canonical name for the \\p Kind\n  /// architecture. This is the prefix used by the architecture specific\n  /// builtins, and is suitable for passing to \\see\n  /// Intrinsic::getIntrinsicForGCCBuiltin().\n  ///\n  /// \\return - The architecture prefix, or 0 if none is defined.\n  static StringRef getArchTypePrefix(ArchType Kind);\n\n  /// getVendorTypeName - Get the canonical name for the \\p Kind vendor.\n  static StringRef getVendorTypeName(VendorType Kind);\n\n  /// getOSTypeName - Get the canonical name for the \\p Kind operating system.\n  static StringRef getOSTypeName(OSType Kind);\n\n  /// getEnvironmentTypeName - Get the canonical name for the \\p Kind\n  /// environment.\n  static StringRef getEnvironmentTypeName(EnvironmentType Kind);\n\n  /// @}\n  /// @name Static helpers for converting alternate architecture names.\n  /// @{\n\n  /// getArchTypeForLLVMName - The canonical type for the given LLVM\n  /// architecture name (e.g., \"x86\").\n  static ArchType getArchTypeForLLVMName(StringRef Str);\n\n  /// @}\n\n  /// Returns a canonicalized OS version number for the specified OS.\n  static VersionTuple getCanonicalVersionForOS(OSType OSKind,\n                                               const VersionTuple &Version);\n};\n\n} // End llvm namespace\n\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "content": "//===- llvm/ADT/ilist_node.h - Intrusive Linked List Helper -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ilist_node class template, which is a convenient\n// base class for creating classes that can be used with ilists.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_NODE_H\n#define LLVM_ADT_ILIST_NODE_H\n\n#include \"llvm/ADT/ilist_node_base.h\"\n#include \"llvm/ADT/ilist_node_options.h\"\n\nnamespace llvm {\n\nnamespace ilist_detail {\n\nstruct NodeAccess;\n\n} // end namespace ilist_detail\n\ntemplate <class OptionsT, bool IsReverse, bool IsConst> class ilist_iterator;\ntemplate <class OptionsT> class ilist_sentinel;\n\n/// Implementation for an ilist node.\n///\n/// Templated on an appropriate \\a ilist_detail::node_options, usually computed\n/// by \\a ilist_detail::compute_node_options.\n///\n/// This is a wrapper around \\a ilist_node_base whose main purpose is to\n/// provide type safety: you can't insert nodes of \\a ilist_node_impl into the\n/// wrong \\a simple_ilist or \\a iplist.\ntemplate <class OptionsT> class ilist_node_impl : OptionsT::node_base_type {\n  using value_type = typename OptionsT::value_type;\n  using node_base_type = typename OptionsT::node_base_type;\n  using list_base_type = typename OptionsT::list_base_type;\n\n  friend typename OptionsT::list_base_type;\n  friend struct ilist_detail::NodeAccess;\n  friend class ilist_sentinel<OptionsT>;\n  friend class ilist_iterator<OptionsT, false, false>;\n  friend class ilist_iterator<OptionsT, false, true>;\n  friend class ilist_iterator<OptionsT, true, false>;\n  friend class ilist_iterator<OptionsT, true, true>;\n\nprotected:\n  using self_iterator = ilist_iterator<OptionsT, false, false>;\n  using const_self_iterator = ilist_iterator<OptionsT, false, true>;\n  using reverse_self_iterator = ilist_iterator<OptionsT, true, false>;\n  using const_reverse_self_iterator = ilist_iterator<OptionsT, true, true>;\n\n  ilist_node_impl() = default;\n\nprivate:\n  ilist_node_impl *getPrev() {\n    return static_cast<ilist_node_impl *>(node_base_type::getPrev());\n  }\n\n  ilist_node_impl *getNext() {\n    return static_cast<ilist_node_impl *>(node_base_type::getNext());\n  }\n\n  const ilist_node_impl *getPrev() const {\n    return static_cast<ilist_node_impl *>(node_base_type::getPrev());\n  }\n\n  const ilist_node_impl *getNext() const {\n    return static_cast<ilist_node_impl *>(node_base_type::getNext());\n  }\n\n  void setPrev(ilist_node_impl *N) { node_base_type::setPrev(N); }\n  void setNext(ilist_node_impl *N) { node_base_type::setNext(N); }\n\npublic:\n  self_iterator getIterator() { return self_iterator(*this); }\n  const_self_iterator getIterator() const { return const_self_iterator(*this); }\n\n  reverse_self_iterator getReverseIterator() {\n    return reverse_self_iterator(*this);\n  }\n\n  const_reverse_self_iterator getReverseIterator() const {\n    return const_reverse_self_iterator(*this);\n  }\n\n  // Under-approximation, but always available for assertions.\n  using node_base_type::isKnownSentinel;\n\n  /// Check whether this is the sentinel node.\n  ///\n  /// This requires sentinel tracking to be explicitly enabled.  Use the\n  /// ilist_sentinel_tracking<true> option to get this API.\n  bool isSentinel() const {\n    static_assert(OptionsT::is_sentinel_tracking_explicit,\n                  \"Use ilist_sentinel_tracking<true> to enable isSentinel()\");\n    return node_base_type::isSentinel();\n  }\n};\n\n/// An intrusive list node.\n///\n/// A base class to enable membership in intrusive lists, including \\a\n/// simple_ilist, \\a iplist, and \\a ilist.  The first template parameter is the\n/// \\a value_type for the list.\n///\n/// An ilist node can be configured with compile-time options to change\n/// behaviour and/or add API.\n///\n/// By default, an \\a ilist_node knows whether it is the list sentinel (an\n/// instance of \\a ilist_sentinel) if and only if\n/// LLVM_ENABLE_ABI_BREAKING_CHECKS.  The function \\a isKnownSentinel() always\n/// returns \\c false tracking is off.  Sentinel tracking steals a bit from the\n/// \"prev\" link, which adds a mask operation when decrementing an iterator, but\n/// enables bug-finding assertions in \\a ilist_iterator.\n///\n/// To turn sentinel tracking on all the time, pass in the\n/// ilist_sentinel_tracking<true> template parameter.  This also enables the \\a\n/// isSentinel() function.  The same option must be passed to the intrusive\n/// list.  (ilist_sentinel_tracking<false> turns sentinel tracking off all the\n/// time.)\n///\n/// A type can inherit from ilist_node multiple times by passing in different\n/// \\a ilist_tag options.  This allows a single instance to be inserted into\n/// multiple lists simultaneously, where each list is given the same tag.\n///\n/// \\example\n/// struct A {};\n/// struct B {};\n/// struct N : ilist_node<N, ilist_tag<A>>, ilist_node<N, ilist_tag<B>> {};\n///\n/// void foo() {\n///   simple_ilist<N, ilist_tag<A>> ListA;\n///   simple_ilist<N, ilist_tag<B>> ListB;\n///   N N1;\n///   ListA.push_back(N1);\n///   ListB.push_back(N1);\n/// }\n/// \\endexample\n///\n/// See \\a is_valid_option for steps on adding a new option.\ntemplate <class T, class... Options>\nclass ilist_node\n    : public ilist_node_impl<\n          typename ilist_detail::compute_node_options<T, Options...>::type> {\n  static_assert(ilist_detail::check_options<Options...>::value,\n                \"Unrecognized node option!\");\n};\n\nnamespace ilist_detail {\n\n/// An access class for ilist_node private API.\n///\n/// This gives access to the private parts of ilist nodes.  Nodes for an ilist\n/// should friend this class if they inherit privately from ilist_node.\n///\n/// Using this class outside of the ilist implementation is unsupported.\nstruct NodeAccess {\nprotected:\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getNodePtr(typename OptionsT::pointer N) {\n    return N;\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getNodePtr(typename OptionsT::const_pointer N) {\n    return N;\n  }\n\n  template <class OptionsT>\n  static typename OptionsT::pointer getValuePtr(ilist_node_impl<OptionsT> *N) {\n    return static_cast<typename OptionsT::pointer>(N);\n  }\n\n  template <class OptionsT>\n  static typename OptionsT::const_pointer\n  getValuePtr(const ilist_node_impl<OptionsT> *N) {\n    return static_cast<typename OptionsT::const_pointer>(N);\n  }\n\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getPrev(ilist_node_impl<OptionsT> &N) {\n    return N.getPrev();\n  }\n\n  template <class OptionsT>\n  static ilist_node_impl<OptionsT> *getNext(ilist_node_impl<OptionsT> &N) {\n    return N.getNext();\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getPrev(const ilist_node_impl<OptionsT> &N) {\n    return N.getPrev();\n  }\n\n  template <class OptionsT>\n  static const ilist_node_impl<OptionsT> *\n  getNext(const ilist_node_impl<OptionsT> &N) {\n    return N.getNext();\n  }\n};\n\ntemplate <class OptionsT> struct SpecificNodeAccess : NodeAccess {\nprotected:\n  using pointer = typename OptionsT::pointer;\n  using const_pointer = typename OptionsT::const_pointer;\n  using node_type = ilist_node_impl<OptionsT>;\n\n  static node_type *getNodePtr(pointer N) {\n    return NodeAccess::getNodePtr<OptionsT>(N);\n  }\n\n  static const node_type *getNodePtr(const_pointer N) {\n    return NodeAccess::getNodePtr<OptionsT>(N);\n  }\n\n  static pointer getValuePtr(node_type *N) {\n    return NodeAccess::getValuePtr<OptionsT>(N);\n  }\n\n  static const_pointer getValuePtr(const node_type *N) {\n    return NodeAccess::getValuePtr<OptionsT>(N);\n  }\n};\n\n} // end namespace ilist_detail\n\ntemplate <class OptionsT>\nclass ilist_sentinel : public ilist_node_impl<OptionsT> {\npublic:\n  ilist_sentinel() {\n    this->initializeSentinel();\n    reset();\n  }\n\n  void reset() {\n    this->setPrev(this);\n    this->setNext(this);\n  }\n\n  bool empty() const { return this == this->getPrev(); }\n};\n\n/// An ilist node that can access its parent list.\n///\n/// Requires \\c NodeTy to have \\a getParent() to find the parent node, and the\n/// \\c ParentTy to have \\a getSublistAccess() to get a reference to the list.\ntemplate <typename NodeTy, typename ParentTy, class... Options>\nclass ilist_node_with_parent : public ilist_node<NodeTy, Options...> {\nprotected:\n  ilist_node_with_parent() = default;\n\nprivate:\n  /// Forward to NodeTy::getParent().\n  ///\n  /// Note: do not use the name \"getParent()\".  We want a compile error\n  /// (instead of recursion) when the subclass fails to implement \\a\n  /// getParent().\n  const ParentTy *getNodeParent() const {\n    return static_cast<const NodeTy *>(this)->getParent();\n  }\n\npublic:\n  /// @name Adjacent Node Accessors\n  /// @{\n  /// Get the previous node, or \\c nullptr for the list head.\n  NodeTy *getPrevNode() {\n    // Should be separated to a reused function, but then we couldn't use auto\n    // (and would need the type of the list).\n    const auto &List =\n        getNodeParent()->*(ParentTy::getSublistAccess((NodeTy *)nullptr));\n    return List.getPrevNode(*static_cast<NodeTy *>(this));\n  }\n\n  /// Get the previous node, or \\c nullptr for the list head.\n  const NodeTy *getPrevNode() const {\n    return const_cast<ilist_node_with_parent *>(this)->getPrevNode();\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  NodeTy *getNextNode() {\n    // Should be separated to a reused function, but then we couldn't use auto\n    // (and would need the type of the list).\n    const auto &List =\n        getNodeParent()->*(ParentTy::getSublistAccess((NodeTy *)nullptr));\n    return List.getNextNode(*static_cast<NodeTy *>(this));\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  const NodeTy *getNextNode() const {\n    return const_cast<ilist_node_with_parent *>(this)->getNextNode();\n  }\n  /// @}\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ILIST_NODE_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node_base.h", "content": "//===- llvm/ADT/ilist_node_base.h - Intrusive List Node Base -----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_NODE_BASE_H\n#define LLVM_ADT_ILIST_NODE_BASE_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n\nnamespace llvm {\n\n/// Base class for ilist nodes.\n///\n/// Optionally tracks whether this node is the sentinel.\ntemplate <bool EnableSentinelTracking> class ilist_node_base;\n\ntemplate <> class ilist_node_base<false> {\n  ilist_node_base *Prev = nullptr;\n  ilist_node_base *Next = nullptr;\n\npublic:\n  void setPrev(ilist_node_base *Prev) { this->Prev = Prev; }\n  void setNext(ilist_node_base *Next) { this->Next = Next; }\n  ilist_node_base *getPrev() const { return Prev; }\n  ilist_node_base *getNext() const { return Next; }\n\n  bool isKnownSentinel() const { return false; }\n  void initializeSentinel() {}\n};\n\ntemplate <> class ilist_node_base<true> {\n  PointerIntPair<ilist_node_base *, 1> PrevAndSentinel;\n  ilist_node_base *Next = nullptr;\n\npublic:\n  void setPrev(ilist_node_base *Prev) { PrevAndSentinel.setPointer(Prev); }\n  void setNext(ilist_node_base *Next) { this->Next = Next; }\n  ilist_node_base *getPrev() const { return PrevAndSentinel.getPointer(); }\n  ilist_node_base *getNext() const { return Next; }\n\n  bool isSentinel() const { return PrevAndSentinel.getInt(); }\n  bool isKnownSentinel() const { return isSentinel(); }\n  void initializeSentinel() { PrevAndSentinel.setInt(true); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ILIST_NODE_BASE_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "content": "//===- iterator.h - Utilities for using and defining iterators --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_H\n#define LLVM_ADT_ITERATOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// CRTP base class which implements the entire standard iterator facade\n/// in terms of a minimal subset of the interface.\n///\n/// Use this when it is reasonable to implement most of the iterator\n/// functionality in terms of a core subset. If you need special behavior or\n/// there are performance implications for this, you may want to override the\n/// relevant members instead.\n///\n/// Note, one abstraction that this does *not* provide is implementing\n/// subtraction in terms of addition by negating the difference. Negation isn't\n/// always information preserving, and I can see very reasonable iterator\n/// designs where this doesn't work well. It doesn't really force much added\n/// boilerplate anyways.\n///\n/// Another abstraction that this doesn't provide is implementing increment in\n/// terms of addition of one. These aren't equivalent for all iterator\n/// categories, and respecting that adds a lot of complexity for little gain.\n///\n/// Classes wishing to use `iterator_facade_base` should implement the following\n/// methods:\n///\n/// Forward Iterators:\n///   (All of the following methods)\n///   - DerivedT &operator=(const DerivedT &R);\n///   - bool operator==(const DerivedT &R) const;\n///   - const T &operator*() const;\n///   - T &operator*();\n///   - DerivedT &operator++();\n///\n/// Bidirectional Iterators:\n///   (All methods of forward iterators, plus the following)\n///   - DerivedT &operator--();\n///\n/// Random-access Iterators:\n///   (All methods of bidirectional iterators excluding the following)\n///   - DerivedT &operator++();\n///   - DerivedT &operator--();\n///   (and plus the following)\n///   - bool operator<(const DerivedT &RHS) const;\n///   - DifferenceTypeT operator-(const DerivedT &R) const;\n///   - DerivedT &operator+=(DifferenceTypeT N);\n///   - DerivedT &operator-=(DifferenceTypeT N);\n///\ntemplate <typename DerivedT, typename IteratorCategoryT, typename T,\n          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,\n          typename ReferenceT = T &>\nclass iterator_facade_base\n    : public std::iterator<IteratorCategoryT, T, DifferenceTypeT, PointerT,\n                           ReferenceT> {\nprotected:\n  enum {\n    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,\n                                     IteratorCategoryT>::value,\n    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,\n                                      IteratorCategoryT>::value,\n  };\n\n  /// A proxy object for computing a reference via indirecting a copy of an\n  /// iterator. This is used in APIs which need to produce a reference via\n  /// indirection but for which the iterator object might be a temporary. The\n  /// proxy preserves the iterator internally and exposes the indirected\n  /// reference via a conversion operator.\n  class ReferenceProxy {\n    friend iterator_facade_base;\n\n    DerivedT I;\n\n    ReferenceProxy(DerivedT I) : I(std::move(I)) {}\n\n  public:\n    operator ReferenceT() const { return *I; }\n  };\n\npublic:\n  DerivedT operator+(DifferenceTypeT n) const {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp += n;\n    return tmp;\n  }\n  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    return i + n;\n  }\n  DerivedT operator-(DifferenceTypeT n) const {\n    static_assert(\n        IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp -= n;\n    return tmp;\n  }\n\n  DerivedT &operator++() {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return static_cast<DerivedT *>(this)->operator+=(1);\n  }\n  DerivedT operator++(int) {\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    ++*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n  DerivedT &operator--() {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    return static_cast<DerivedT *>(this)->operator-=(1);\n  }\n  DerivedT operator--(int) {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    --*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n\n#ifndef __cpp_impl_three_way_comparison\n  bool operator!=(const DerivedT &RHS) const {\n    return !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n#endif\n\n  bool operator>(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS) &&\n           !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n  bool operator<=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) > RHS);\n  }\n  bool operator>=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS);\n  }\n\n  PointerT operator->() { return &static_cast<DerivedT *>(this)->operator*(); }\n  PointerT operator->() const {\n    return &static_cast<const DerivedT *>(this)->operator*();\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<DerivedT *>(this)->operator+(n));\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) const {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<const DerivedT *>(this)->operator+(n));\n  }\n};\n\n/// CRTP base class for adapting an iterator to a different type.\n///\n/// This class can be used through CRTP to adapt one iterator into another.\n/// Typically this is done through providing in the derived class a custom \\c\n/// operator* implementation. Other methods can be overridden as well.\ntemplate <\n    typename DerivedT, typename WrappedIteratorT,\n    typename IteratorCategoryT =\n        typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,\n    typename DifferenceTypeT =\n        typename std::iterator_traits<WrappedIteratorT>::difference_type,\n    typename PointerT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,\n    typename ReferenceT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>\nclass iterator_adaptor_base\n    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,\n                                  DifferenceTypeT, PointerT, ReferenceT> {\n  using BaseT = typename iterator_adaptor_base::iterator_facade_base;\n\nprotected:\n  WrappedIteratorT I;\n\n  iterator_adaptor_base() = default;\n\n  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {\n    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n  }\n\n  const WrappedIteratorT &wrapped() const { return I; }\n\npublic:\n  using difference_type = DifferenceTypeT;\n\n  DerivedT &operator+=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '+=' operator is only defined for random access iterators.\");\n    I += n;\n    return *static_cast<DerivedT *>(this);\n  }\n  DerivedT &operator-=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-=' operator is only defined for random access iterators.\");\n    I -= n;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator-;\n  difference_type operator-(const DerivedT &RHS) const {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    return I - RHS.I;\n  }\n\n  // We have to explicitly provide ++ and -- rather than letting the facade\n  // forward to += because WrappedIteratorT might not support +=.\n  using BaseT::operator++;\n  DerivedT &operator++() {\n    ++I;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator--;\n  DerivedT &operator--() {\n    static_assert(\n        BaseT::IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    --I;\n    return *static_cast<DerivedT *>(this);\n  }\n\n  friend bool operator==(const iterator_adaptor_base &LHS,\n                         const iterator_adaptor_base &RHS) {\n    return LHS.I == RHS.I;\n  }\n  friend bool operator<(const iterator_adaptor_base &LHS,\n                        const iterator_adaptor_base &RHS) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return LHS.I < RHS.I;\n  }\n\n  ReferenceT operator*() const { return *I; }\n};\n\n/// An iterator type that allows iterating over the pointees via some\n/// other iterator.\n///\n/// The typical usage of this is to expose a type that iterates over Ts, but\n/// which is implemented with some iterator over T*s:\n///\n/// \\code\n///   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n/// \\endcode\ntemplate <typename WrappedIteratorT,\n          typename T = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>>\nstruct pointee_iterator\n    : iterator_adaptor_base<\n          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  pointee_iterator() = default;\n  template <typename U>\n  pointee_iterator(U &&u)\n      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}\n\n  T &operator*() const { return **this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointee_iterator<WrappedIteratorT>>\nmake_pointee_range(RangeT &&Range) {\n  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;\n  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T = decltype(&*std::declval<WrappedIteratorT>())>\nclass pointer_iterator\n    : public iterator_adaptor_base<\n          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  mutable T Ptr;\n\npublic:\n  pointer_iterator() = default;\n\n  explicit pointer_iterator(WrappedIteratorT u)\n      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}\n\n  T &operator*() { return Ptr = &*this->I; }\n  const T &operator*() const { return Ptr = &*this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointer_iterator<WrappedIteratorT>>\nmake_pointer_range(RangeT &&Range) {\n  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;\n  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T1 = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>,\n          typename T2 = std::add_pointer_t<T1>>\nusing raw_pointer_iterator =\n    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;\n\n// Wrapper iterator over iterator ItType, adding DataRef to the type of ItType,\n// to create NodeRef = std::pair<InnerTypeOfItType, DataRef>.\ntemplate <typename ItType, typename NodeRef, typename DataRef>\nclass WrappedPairNodeDataIterator\n    : public iterator_adaptor_base<\n          WrappedPairNodeDataIterator<ItType, NodeRef, DataRef>, ItType,\n          typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n          std::ptrdiff_t, NodeRef *, NodeRef &> {\n  using BaseT = iterator_adaptor_base<\n      WrappedPairNodeDataIterator, ItType,\n      typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n      std::ptrdiff_t, NodeRef *, NodeRef &>;\n\n  const DataRef DR;\n  mutable NodeRef NR;\n\npublic:\n  WrappedPairNodeDataIterator(ItType Begin, const DataRef DR)\n      : BaseT(Begin), DR(DR) {\n    NR.first = DR;\n  }\n\n  NodeRef &operator*() const {\n    NR.second = *this->I;\n    return NR;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ITERATOR_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "content": "//===- Wasm.h - Wasm object file format -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines manifest constants for the wasm object file format.\n// See: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_WASM_H\n#define LLVM_BINARYFORMAT_WASM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\nnamespace wasm {\n\n// Object file magic string.\nconst char WasmMagic[] = {'\\0', 'a', 's', 'm'};\n// Wasm binary format version\nconst uint32_t WasmVersion = 0x1;\n// Wasm linking metadata version\nconst uint32_t WasmMetadataVersion = 0x2;\n// Wasm uses a 64k page size\nconst uint32_t WasmPageSize = 65536;\n\nstruct WasmObjectHeader {\n  StringRef Magic;\n  uint32_t Version;\n};\n\nstruct WasmDylinkInfo {\n  uint32_t MemorySize; // Memory size in bytes\n  uint32_t MemoryAlignment;  // P2 alignment of memory\n  uint32_t TableSize;  // Table size in elements\n  uint32_t TableAlignment;  // P2 alignment of table\n  std::vector<StringRef> Needed; // Shared library dependencies\n};\n\nstruct WasmProducerInfo {\n  std::vector<std::pair<std::string, std::string>> Languages;\n  std::vector<std::pair<std::string, std::string>> Tools;\n  std::vector<std::pair<std::string, std::string>> SDKs;\n};\n\nstruct WasmFeatureEntry {\n  uint8_t Prefix;\n  std::string Name;\n};\n\nstruct WasmExport {\n  StringRef Name;\n  uint8_t Kind;\n  uint32_t Index;\n};\n\nstruct WasmLimits {\n  uint8_t Flags;\n  uint64_t Initial;\n  uint64_t Maximum;\n};\n\nstruct WasmTableType {\n  uint8_t ElemType;\n  WasmLimits Limits;\n};\n\nstruct WasmTable {\n  uint32_t Index;\n  WasmTableType Type;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmInitExpr {\n  uint8_t Opcode;\n  union {\n    int32_t Int32;\n    int64_t Int64;\n    uint32_t Float32;\n    uint64_t Float64;\n    uint32_t Global;\n  } Value;\n};\n\nstruct WasmGlobalType {\n  uint8_t Type;\n  bool Mutable;\n};\n\nstruct WasmGlobal {\n  uint32_t Index;\n  WasmGlobalType Type;\n  WasmInitExpr InitExpr;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmEventType {\n  // Kind of event. Currently only WASM_EVENT_ATTRIBUTE_EXCEPTION is possible.\n  uint32_t Attribute;\n  uint32_t SigIndex;\n};\n\nstruct WasmEvent {\n  uint32_t Index;\n  WasmEventType Type;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmImport {\n  StringRef Module;\n  StringRef Field;\n  uint8_t Kind;\n  union {\n    uint32_t SigIndex;\n    WasmGlobalType Global;\n    WasmTableType Table;\n    WasmLimits Memory;\n    WasmEventType Event;\n  };\n};\n\nstruct WasmLocalDecl {\n  uint8_t Type;\n  uint32_t Count;\n};\n\nstruct WasmFunction {\n  uint32_t Index;\n  std::vector<WasmLocalDecl> Locals;\n  ArrayRef<uint8_t> Body;\n  uint32_t CodeSectionOffset;\n  uint32_t Size;\n  uint32_t CodeOffset;  // start of Locals and Body\n  Optional<StringRef> ExportName; // from the \"export\" section\n  StringRef SymbolName; // from the \"linking\" section\n  StringRef DebugName;  // from the \"name\" section\n  uint32_t Comdat;      // from the \"comdat info\" section\n};\n\nstruct WasmDataSegment {\n  uint32_t InitFlags;\n  // Present if InitFlags & WASM_DATA_SEGMENT_HAS_MEMINDEX.\n  uint32_t MemoryIndex;\n  // Present if InitFlags & WASM_DATA_SEGMENT_IS_PASSIVE == 0.\n  WasmInitExpr Offset;\n\n  ArrayRef<uint8_t> Content;\n  StringRef Name; // from the \"segment info\" section\n  uint32_t Alignment;\n  uint32_t LinkerFlags;\n  uint32_t Comdat; // from the \"comdat info\" section\n};\n\nstruct WasmElemSegment {\n  uint32_t Flags;\n  uint32_t TableNumber;\n  uint8_t ElemKind;\n  WasmInitExpr Offset;\n  std::vector<uint32_t> Functions;\n};\n\n// Represents the location of a Wasm data symbol within a WasmDataSegment, as\n// the index of the segment, and the offset and size within the segment.\nstruct WasmDataReference {\n  uint32_t Segment;\n  uint64_t Offset;\n  uint64_t Size;\n};\n\nstruct WasmRelocation {\n  uint8_t Type;    // The type of the relocation.\n  uint32_t Index;  // Index into either symbol or type index space.\n  uint64_t Offset; // Offset from the start of the section.\n  int64_t Addend;  // A value to add to the symbol.\n};\n\nstruct WasmInitFunc {\n  uint32_t Priority;\n  uint32_t Symbol;\n};\n\nstruct WasmSymbolInfo {\n  StringRef Name;\n  uint8_t Kind;\n  uint32_t Flags;\n  // For undefined symbols the module of the import\n  Optional<StringRef> ImportModule;\n  // For undefined symbols the name of the import\n  Optional<StringRef> ImportName;\n  // For symbols to be exported from the final module\n  Optional<StringRef> ExportName;\n  union {\n    // For function, table, or global symbols, the index in function, table, or\n    // global index space.\n    uint32_t ElementIndex;\n    // For a data symbols, the address of the data relative to segment.\n    WasmDataReference DataRef;\n  };\n};\n\nenum class NameType {\n  FUNCTION,\n  GLOBAL,\n  DATA_SEGMENT,\n};\n\nstruct WasmDebugName {\n  NameType Type;\n  uint32_t Index;\n  StringRef Name;\n};\n\nstruct WasmLinkingData {\n  uint32_t Version;\n  std::vector<WasmInitFunc> InitFunctions;\n  std::vector<StringRef> Comdats;\n  std::vector<WasmSymbolInfo> SymbolTable;\n};\n\nenum : unsigned {\n  WASM_SEC_CUSTOM = 0,     // Custom / User-defined section\n  WASM_SEC_TYPE = 1,       // Function signature declarations\n  WASM_SEC_IMPORT = 2,     // Import declarations\n  WASM_SEC_FUNCTION = 3,   // Function declarations\n  WASM_SEC_TABLE = 4,      // Indirect function table and other tables\n  WASM_SEC_MEMORY = 5,     // Memory attributes\n  WASM_SEC_GLOBAL = 6,     // Global declarations\n  WASM_SEC_EXPORT = 7,     // Exports\n  WASM_SEC_START = 8,      // Start function declaration\n  WASM_SEC_ELEM = 9,       // Elements section\n  WASM_SEC_CODE = 10,      // Function bodies (code)\n  WASM_SEC_DATA = 11,      // Data segments\n  WASM_SEC_DATACOUNT = 12, // Data segment count\n  WASM_SEC_EVENT = 13      // Event declarations\n};\n\n// Type immediate encodings used in various contexts.\nenum : unsigned {\n  WASM_TYPE_I32 = 0x7F,\n  WASM_TYPE_I64 = 0x7E,\n  WASM_TYPE_F32 = 0x7D,\n  WASM_TYPE_F64 = 0x7C,\n  WASM_TYPE_V128 = 0x7B,\n  WASM_TYPE_FUNCREF = 0x70,\n  WASM_TYPE_EXTERNREF = 0x6F,\n  WASM_TYPE_FUNC = 0x60,\n  WASM_TYPE_NORESULT = 0x40, // for blocks with no result values\n};\n\n// Kinds of externals (for imports and exports).\nenum : unsigned {\n  WASM_EXTERNAL_FUNCTION = 0x0,\n  WASM_EXTERNAL_TABLE = 0x1,\n  WASM_EXTERNAL_MEMORY = 0x2,\n  WASM_EXTERNAL_GLOBAL = 0x3,\n  WASM_EXTERNAL_EVENT = 0x4,\n};\n\n// Opcodes used in initializer expressions.\nenum : unsigned {\n  WASM_OPCODE_END = 0x0b,\n  WASM_OPCODE_CALL = 0x10,\n  WASM_OPCODE_LOCAL_GET = 0x20,\n  WASM_OPCODE_LOCAL_SET = 0x21,\n  WASM_OPCODE_GLOBAL_GET = 0x23,\n  WASM_OPCODE_GLOBAL_SET = 0x24,\n  WASM_OPCODE_I32_STORE = 0x36,\n  WASM_OPCODE_I64_STORE = 0x37,\n  WASM_OPCODE_I32_CONST = 0x41,\n  WASM_OPCODE_I64_CONST = 0x42,\n  WASM_OPCODE_F32_CONST = 0x43,\n  WASM_OPCODE_F64_CONST = 0x44,\n  WASM_OPCODE_I32_ADD = 0x6a,\n  WASM_OPCODE_I64_ADD = 0x7c,\n  WASM_OPCODE_REF_NULL = 0xd0,\n};\n\n// Opcodes used in synthetic functions.\nenum : unsigned {\n  WASM_OPCODE_IF = 0x04,\n  WASM_OPCODE_ELSE = 0x05,\n  WASM_OPCODE_DROP = 0x1a,\n  WASM_OPCODE_MISC_PREFIX = 0xfc,\n  WASM_OPCODE_MEMORY_INIT = 0x08,\n  WASM_OPCODE_DATA_DROP = 0x09,\n  WASM_OPCODE_ATOMICS_PREFIX = 0xfe,\n  WASM_OPCODE_ATOMIC_NOTIFY = 0x00,\n  WASM_OPCODE_I32_ATOMIC_WAIT = 0x01,\n  WASM_OPCODE_I32_ATOMIC_STORE = 0x17,\n  WASM_OPCODE_I32_RMW_CMPXCHG = 0x48,\n};\n\nenum : unsigned {\n  WASM_LIMITS_FLAG_NONE = 0x0,\n  WASM_LIMITS_FLAG_HAS_MAX = 0x1,\n  WASM_LIMITS_FLAG_IS_SHARED = 0x2,\n  WASM_LIMITS_FLAG_IS_64 = 0x4,\n};\n\nenum : unsigned {\n  WASM_DATA_SEGMENT_IS_PASSIVE = 0x01,\n  WASM_DATA_SEGMENT_HAS_MEMINDEX = 0x02,\n};\n\nenum : unsigned {\n  WASM_ELEM_SEGMENT_IS_PASSIVE = 0x01,\n  WASM_ELEM_SEGMENT_HAS_TABLE_NUMBER = 0x02,\n  WASM_ELEM_SEGMENT_HAS_INIT_EXPRS = 0x04,\n};\nconst unsigned WASM_ELEM_SEGMENT_MASK_HAS_ELEM_KIND = 0x3;\n\n// Feature policy prefixes used in the custom \"target_features\" section\nenum : uint8_t {\n  WASM_FEATURE_PREFIX_USED = '+',\n  WASM_FEATURE_PREFIX_REQUIRED = '=',\n  WASM_FEATURE_PREFIX_DISALLOWED = '-',\n};\n\n// Kind codes used in the custom \"name\" section\nenum : unsigned {\n  WASM_NAMES_FUNCTION = 1,\n  WASM_NAMES_LOCAL = 2,\n  WASM_NAMES_GLOBAL = 7,\n  WASM_NAMES_DATA_SEGMENT = 9,\n};\n\n// Kind codes used in the custom \"linking\" section\nenum : unsigned {\n  WASM_SEGMENT_INFO = 0x5,\n  WASM_INIT_FUNCS = 0x6,\n  WASM_COMDAT_INFO = 0x7,\n  WASM_SYMBOL_TABLE = 0x8,\n};\n\n// Kind codes used in the custom \"linking\" section in the WASM_COMDAT_INFO\nenum : unsigned {\n  WASM_COMDAT_DATA = 0x0,\n  WASM_COMDAT_FUNCTION = 0x1,\n  // GLOBAL, EVENT, and TABLE are in here but LLVM doesn't use them yet.\n  WASM_COMDAT_SECTION = 0x5,\n};\n\n// Kind codes used in the custom \"linking\" section in the WASM_SYMBOL_TABLE\nenum WasmSymbolType : unsigned {\n  WASM_SYMBOL_TYPE_FUNCTION = 0x0,\n  WASM_SYMBOL_TYPE_DATA = 0x1,\n  WASM_SYMBOL_TYPE_GLOBAL = 0x2,\n  WASM_SYMBOL_TYPE_SECTION = 0x3,\n  WASM_SYMBOL_TYPE_EVENT = 0x4,\n  WASM_SYMBOL_TYPE_TABLE = 0x5,\n};\n\n// Kinds of event attributes.\nenum WasmEventAttribute : unsigned {\n  WASM_EVENT_ATTRIBUTE_EXCEPTION = 0x0,\n};\n\nconst unsigned WASM_SYMBOL_BINDING_MASK = 0x3;\nconst unsigned WASM_SYMBOL_VISIBILITY_MASK = 0xc;\n\nconst unsigned WASM_SYMBOL_BINDING_GLOBAL = 0x0;\nconst unsigned WASM_SYMBOL_BINDING_WEAK = 0x1;\nconst unsigned WASM_SYMBOL_BINDING_LOCAL = 0x2;\nconst unsigned WASM_SYMBOL_VISIBILITY_DEFAULT = 0x0;\nconst unsigned WASM_SYMBOL_VISIBILITY_HIDDEN = 0x4;\nconst unsigned WASM_SYMBOL_UNDEFINED = 0x10;\nconst unsigned WASM_SYMBOL_EXPORTED = 0x20;\nconst unsigned WASM_SYMBOL_EXPLICIT_NAME = 0x40;\nconst unsigned WASM_SYMBOL_NO_STRIP = 0x80;\n\n#define WASM_RELOC(name, value) name = value,\n\nenum : unsigned {\n#include \"WasmRelocs.def\"\n};\n\n#undef WASM_RELOC\n\n// Subset of types that a value can have\nenum class ValType {\n  I32 = WASM_TYPE_I32,\n  I64 = WASM_TYPE_I64,\n  F32 = WASM_TYPE_F32,\n  F64 = WASM_TYPE_F64,\n  V128 = WASM_TYPE_V128,\n  FUNCREF = WASM_TYPE_FUNCREF,\n  EXTERNREF = WASM_TYPE_EXTERNREF,\n};\n\nstruct WasmSignature {\n  SmallVector<ValType, 1> Returns;\n  SmallVector<ValType, 4> Params;\n  // Support empty and tombstone instances, needed by DenseMap.\n  enum { Plain, Empty, Tombstone } State = Plain;\n\n  WasmSignature(SmallVector<ValType, 1> &&InReturns,\n                SmallVector<ValType, 4> &&InParams)\n      : Returns(InReturns), Params(InParams) {}\n  WasmSignature() = default;\n};\n\n// Useful comparison operators\ninline bool operator==(const WasmSignature &LHS, const WasmSignature &RHS) {\n  return LHS.State == RHS.State && LHS.Returns == RHS.Returns &&\n         LHS.Params == RHS.Params;\n}\n\ninline bool operator!=(const WasmSignature &LHS, const WasmSignature &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator==(const WasmGlobalType &LHS, const WasmGlobalType &RHS) {\n  return LHS.Type == RHS.Type && LHS.Mutable == RHS.Mutable;\n}\n\ninline bool operator!=(const WasmGlobalType &LHS, const WasmGlobalType &RHS) {\n  return !(LHS == RHS);\n}\n\nstd::string toString(WasmSymbolType type);\nstd::string relocTypetoString(uint32_t type);\nbool relocTypeHasAddend(uint32_t type);\n\n} // end namespace wasm\n} // end namespace llvm\n\n#endif\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "content": "//===- DIContext.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines DIContext, an abstract data structure that holds\n// debug information data.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DICONTEXT_H\n#define LLVM_DEBUGINFO_DICONTEXT_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/WithColor.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// A format-neutral container for source line information.\nstruct DILineInfo {\n  // DILineInfo contains \"<invalid>\" for function/filename it cannot fetch.\n  static constexpr const char *const BadString = \"<invalid>\";\n  // Use \"??\" instead of \"<invalid>\" to make our output closer to addr2line.\n  static constexpr const char *const Addr2LineBadString = \"??\";\n  std::string FileName;\n  std::string FunctionName;\n  std::string StartFileName;\n  Optional<StringRef> Source;\n  uint32_t Line = 0;\n  uint32_t Column = 0;\n  uint32_t StartLine = 0;\n\n  // DWARF-specific.\n  uint32_t Discriminator = 0;\n\n  DILineInfo()\n      : FileName(BadString), FunctionName(BadString), StartFileName(BadString) {\n  }\n\n  bool operator==(const DILineInfo &RHS) const {\n    return Line == RHS.Line && Column == RHS.Column &&\n           FileName == RHS.FileName && FunctionName == RHS.FunctionName &&\n           StartFileName == RHS.StartFileName && StartLine == RHS.StartLine &&\n           Discriminator == RHS.Discriminator;\n  }\n\n  bool operator!=(const DILineInfo &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator<(const DILineInfo &RHS) const {\n    return std::tie(FileName, FunctionName, StartFileName, Line, Column,\n                    StartLine, Discriminator) <\n           std::tie(RHS.FileName, RHS.FunctionName, RHS.StartFileName, RHS.Line,\n                    RHS.Column, RHS.StartLine, RHS.Discriminator);\n  }\n\n  explicit operator bool() const { return *this != DILineInfo(); }\n\n  void dump(raw_ostream &OS) {\n    OS << \"Line info: \";\n    if (FileName != BadString)\n      OS << \"file '\" << FileName << \"', \";\n    if (FunctionName != BadString)\n      OS << \"function '\" << FunctionName << \"', \";\n    OS << \"line \" << Line << \", \";\n    OS << \"column \" << Column << \", \";\n    if (StartFileName != BadString)\n      OS << \"start file '\" << StartFileName << \"', \";\n    OS << \"start line \" << StartLine << '\\n';\n  }\n};\n\nusing DILineInfoTable = SmallVector<std::pair<uint64_t, DILineInfo>, 16>;\n\n/// A format-neutral container for inlined code description.\nclass DIInliningInfo {\n  SmallVector<DILineInfo, 4> Frames;\n\npublic:\n  DIInliningInfo() = default;\n\n  const DILineInfo & getFrame(unsigned Index) const {\n    assert(Index < Frames.size());\n    return Frames[Index];\n  }\n\n  DILineInfo *getMutableFrame(unsigned Index) {\n    assert(Index < Frames.size());\n    return &Frames[Index];\n  }\n\n  uint32_t getNumberOfFrames() const {\n    return Frames.size();\n  }\n\n  void addFrame(const DILineInfo &Frame) {\n    Frames.push_back(Frame);\n  }\n\n  void resize(unsigned i) {\n    Frames.resize(i);\n  }\n};\n\n/// Container for description of a global variable.\nstruct DIGlobal {\n  std::string Name;\n  uint64_t Start = 0;\n  uint64_t Size = 0;\n\n  DIGlobal() : Name(DILineInfo::BadString) {}\n};\n\nstruct DILocal {\n  std::string FunctionName;\n  std::string Name;\n  std::string DeclFile;\n  uint64_t DeclLine = 0;\n  Optional<int64_t> FrameOffset;\n  Optional<uint64_t> Size;\n  Optional<uint64_t> TagOffset;\n};\n\n/// A DINameKind is passed to name search methods to specify a\n/// preference regarding the type of name resolution the caller wants.\nenum class DINameKind { None, ShortName, LinkageName };\n\n/// Controls which fields of DILineInfo container should be filled\n/// with data.\nstruct DILineInfoSpecifier {\n  enum class FileLineInfoKind {\n    None,\n    // RawValue is whatever the compiler stored in the filename table.  Could be\n    // a full path, could be something else.\n    RawValue,\n    BaseNameOnly,\n    // Relative to the compilation directory.\n    RelativeFilePath,\n    AbsoluteFilePath\n  };\n  using FunctionNameKind = DINameKind;\n\n  FileLineInfoKind FLIKind;\n  FunctionNameKind FNKind;\n\n  DILineInfoSpecifier(FileLineInfoKind FLIKind = FileLineInfoKind::RawValue,\n                      FunctionNameKind FNKind = FunctionNameKind::None)\n      : FLIKind(FLIKind), FNKind(FNKind) {}\n};\n\n/// This is just a helper to programmatically construct DIDumpType.\nenum DIDumpTypeCounter {\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  DIDT_ID_##ENUM_NAME,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n  DIDT_ID_UUID,\n  DIDT_ID_Count\n};\nstatic_assert(DIDT_ID_Count <= 32, \"section types overflow storage\");\n\n/// Selects which debug sections get dumped.\nenum DIDumpType : unsigned {\n  DIDT_Null,\n  DIDT_All             = ~0U,\n#define HANDLE_DWARF_SECTION(ENUM_NAME, ELF_NAME, CMDLINE_NAME, OPTION)        \\\n  DIDT_##ENUM_NAME = 1U << DIDT_ID_##ENUM_NAME,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n#undef HANDLE_DWARF_SECTION\n  DIDT_UUID = 1 << DIDT_ID_UUID,\n};\n\n/// Container for dump options that control which debug information will be\n/// dumped.\nstruct DIDumpOptions {\n  unsigned DumpType = DIDT_All;\n  unsigned ChildRecurseDepth = -1U;\n  unsigned ParentRecurseDepth = -1U;\n  uint16_t Version = 0; // DWARF version to assume when extracting.\n  uint8_t AddrSize = 4; // Address byte size to assume when extracting.\n  bool ShowAddresses = true;\n  bool ShowChildren = false;\n  bool ShowParents = false;\n  bool ShowForm = false;\n  bool SummarizeTypes = false;\n  bool Verbose = false;\n  bool DisplayRawContents = false;\n\n  /// Return default option set for printing a single DIE without children.\n  static DIDumpOptions getForSingleDIE() {\n    DIDumpOptions Opts;\n    Opts.ChildRecurseDepth = 0;\n    Opts.ParentRecurseDepth = 0;\n    return Opts;\n  }\n\n  /// Return the options with RecurseDepth set to 0 unless explicitly required.\n  DIDumpOptions noImplicitRecursion() const {\n    DIDumpOptions Opts = *this;\n    if (ChildRecurseDepth == -1U && !ShowChildren)\n      Opts.ChildRecurseDepth = 0;\n    if (ParentRecurseDepth == -1U && !ShowParents)\n      Opts.ParentRecurseDepth = 0;\n    return Opts;\n  }\n\n  std::function<void(Error)> RecoverableErrorHandler =\n      WithColor::defaultErrorHandler;\n  std::function<void(Error)> WarningHandler = WithColor::defaultWarningHandler;\n};\n\nclass DIContext {\npublic:\n  enum DIContextKind {\n    CK_DWARF,\n    CK_PDB\n  };\n\n  DIContext(DIContextKind K) : Kind(K) {}\n  virtual ~DIContext() = default;\n\n  DIContextKind getKind() const { return Kind; }\n\n  virtual void dump(raw_ostream &OS, DIDumpOptions DumpOpts) = 0;\n\n  virtual bool verify(raw_ostream &OS, DIDumpOptions DumpOpts = {}) {\n    // No verifier? Just say things went well.\n    return true;\n  }\n\n  virtual DILineInfo getLineInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n  virtual DILineInfoTable getLineInfoForAddressRange(\n      object::SectionedAddress Address, uint64_t Size,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n  virtual DIInliningInfo getInliningInfoForAddress(\n      object::SectionedAddress Address,\n      DILineInfoSpecifier Specifier = DILineInfoSpecifier()) = 0;\n\n  virtual std::vector<DILocal>\n  getLocalsForAddress(object::SectionedAddress Address) = 0;\n\nprivate:\n  const DIContextKind Kind;\n};\n\n/// An inferface for inquiring the load address of a loaded object file\n/// to be used by the DIContext implementations when applying relocations\n/// on the fly.\nclass LoadedObjectInfo {\nprotected:\n  LoadedObjectInfo() = default;\n  LoadedObjectInfo(const LoadedObjectInfo &) = default;\n\npublic:\n  virtual ~LoadedObjectInfo() = default;\n\n  /// Obtain the Load Address of a section by SectionRef.\n  ///\n  /// Calculate the address of the given section.\n  /// The section need not be present in the local address space. The addresses\n  /// need to be consistent with the addresses used to query the DIContext and\n  /// the output of this function should be deterministic, i.e. repeated calls\n  /// with the same Sec should give the same address.\n  virtual uint64_t getSectionLoadAddress(const object::SectionRef &Sec) const {\n    return 0;\n  }\n\n  /// If conveniently available, return the content of the given Section.\n  ///\n  /// When the section is available in the local address space, in relocated\n  /// (loaded) form, e.g. because it was relocated by a JIT for execution, this\n  /// function should provide the contents of said section in `Data`. If the\n  /// loaded section is not available, or the cost of retrieving it would be\n  /// prohibitive, this function should return false. In that case, relocations\n  /// will be read from the local (unrelocated) object file and applied on the\n  /// fly. Note that this method is used purely for optimzation purposes in the\n  /// common case of JITting in the local address space, so returning false\n  /// should always be correct.\n  virtual bool getLoadedSectionContents(const object::SectionRef &Sec,\n                                        StringRef &Data) const {\n    return false;\n  }\n\n  // FIXME: This is untested and unused anywhere in the LLVM project, it's\n  // used/needed by Julia (an external project). It should have some coverage\n  // (at least tests, but ideally example functionality).\n  /// Obtain a copy of this LoadedObjectInfo.\n  virtual std::unique_ptr<LoadedObjectInfo> clone() const = 0;\n};\n\ntemplate <typename Derived, typename Base = LoadedObjectInfo>\nstruct LoadedObjectInfoHelper : Base {\nprotected:\n  LoadedObjectInfoHelper(const LoadedObjectInfoHelper &) = default;\n  LoadedObjectInfoHelper() = default;\n\npublic:\n  template <typename... Ts>\n  LoadedObjectInfoHelper(Ts &&... Args) : Base(std::forward<Ts>(Args)...) {}\n\n  std::unique_ptr<llvm::LoadedObjectInfo> clone() const override {\n    return std::make_unique<Derived>(static_cast<const Derived &>(*this));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DICONTEXT_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "content": "//===- DWARFAbbreviationDeclaration.h ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n#define LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass DWARFFormValue;\nclass DWARFUnit;\nclass raw_ostream;\n\nclass DWARFAbbreviationDeclaration {\npublic:\n  struct AttributeSpec {\n    AttributeSpec(dwarf::Attribute A, dwarf::Form F, int64_t Value)\n        : Attr(A), Form(F), Value(Value) {\n      assert(isImplicitConst());\n    }\n    AttributeSpec(dwarf::Attribute A, dwarf::Form F, Optional<uint8_t> ByteSize)\n        : Attr(A), Form(F) {\n      assert(!isImplicitConst());\n      this->ByteSize.HasByteSize = ByteSize.hasValue();\n      if (this->ByteSize.HasByteSize)\n        this->ByteSize.ByteSize = *ByteSize;\n    }\n\n    dwarf::Attribute Attr;\n    dwarf::Form Form;\n\n  private:\n    /// The following field is used for ByteSize for non-implicit_const\n    /// attributes and as value for implicit_const ones, indicated by\n    /// Form == DW_FORM_implicit_const.\n    /// The following cases are distinguished:\n    /// * Form != DW_FORM_implicit_const and HasByteSize is true:\n    ///     ByteSize contains the fixed size in bytes for the Form in this\n    ///     object.\n    /// * Form != DW_FORM_implicit_const and HasByteSize is false:\n    ///     byte size of Form either varies according to the DWARFUnit\n    ///     that it is contained in or the value size varies and must be\n    ///     decoded from the debug information in order to determine its size.\n    /// * Form == DW_FORM_implicit_const:\n    ///     Value contains value for the implicit_const attribute.\n    struct ByteSizeStorage {\n      bool HasByteSize;\n      uint8_t ByteSize;\n    };\n    union {\n      ByteSizeStorage ByteSize;\n      int64_t Value;\n    };\n\n  public:\n    bool isImplicitConst() const {\n      return Form == dwarf::DW_FORM_implicit_const;\n    }\n\n    int64_t getImplicitConstValue() const {\n      assert(isImplicitConst());\n      return Value;\n    }\n\n    /// Get the fixed byte size of this Form if possible. This function might\n    /// use the DWARFUnit to calculate the size of the Form, like for\n    /// DW_AT_address and DW_AT_ref_addr, so this isn't just an accessor for\n    /// the ByteSize member.\n    Optional<int64_t> getByteSize(const DWARFUnit &U) const;\n  };\n  using AttributeSpecVector = SmallVector<AttributeSpec, 8>;\n\n  DWARFAbbreviationDeclaration();\n\n  uint32_t getCode() const { return Code; }\n  uint8_t getCodeByteSize() const { return CodeByteSize; }\n  dwarf::Tag getTag() const { return Tag; }\n  bool hasChildren() const { return HasChildren; }\n\n  using attr_iterator_range =\n      iterator_range<AttributeSpecVector::const_iterator>;\n\n  attr_iterator_range attributes() const {\n    return attr_iterator_range(AttributeSpecs.begin(), AttributeSpecs.end());\n  }\n\n  dwarf::Form getFormByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].Form;\n  }\n\n  size_t getNumAttributes() const {\n    return AttributeSpecs.size();\n  }\n\n  dwarf::Attribute getAttrByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].Attr;\n  }\n\n  bool getAttrIsImplicitConstByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].isImplicitConst();\n  }\n\n  int64_t getAttrImplicitConstValueByIndex(uint32_t idx) const {\n    assert(idx < AttributeSpecs.size());\n    return AttributeSpecs[idx].getImplicitConstValue();\n  }\n\n  /// Get the index of the specified attribute.\n  ///\n  /// Searches the this abbreviation declaration for the index of the specified\n  /// attribute.\n  ///\n  /// \\param attr DWARF attribute to search for.\n  /// \\returns Optional index of the attribute if found, None otherwise.\n  Optional<uint32_t> findAttributeIndex(dwarf::Attribute attr) const;\n\n  /// Extract a DWARF form value from a DIE specified by DIE offset.\n  ///\n  /// Extract an attribute value for a DWARFUnit given the DIE offset and the\n  /// attribute.\n  ///\n  /// \\param DIEOffset the DIE offset that points to the ULEB128 abbreviation\n  /// code in the .debug_info data.\n  /// \\param Attr DWARF attribute to search for.\n  /// \\param U the DWARFUnit the contains the DIE.\n  /// \\returns Optional DWARF form value if the attribute was extracted.\n  Optional<DWARFFormValue> getAttributeValue(const uint64_t DIEOffset,\n                                             const dwarf::Attribute Attr,\n                                             const DWARFUnit &U) const;\n\n  bool extract(DataExtractor Data, uint64_t* OffsetPtr);\n  void dump(raw_ostream &OS) const;\n\n  // Return an optional byte size of all attribute data in this abbreviation\n  // if a constant byte size can be calculated given a DWARFUnit. This allows\n  // DWARF parsing to be faster as many DWARF DIEs have a fixed byte size.\n  Optional<size_t> getFixedAttributesByteSize(const DWARFUnit &U) const;\n\nprivate:\n  void clear();\n\n  /// A helper structure that can quickly determine the size in bytes of an\n  /// abbreviation declaration.\n  struct FixedSizeInfo {\n    /// The fixed byte size for fixed size forms.\n    uint16_t NumBytes = 0;\n    /// Number of DW_FORM_address forms in this abbrevation declaration.\n    uint8_t NumAddrs = 0;\n    /// Number of DW_FORM_ref_addr forms in this abbrevation declaration.\n    uint8_t NumRefAddrs = 0;\n    /// Number of 4 byte in DWARF32 and 8 byte in DWARF64 forms.\n    uint8_t NumDwarfOffsets = 0;\n\n    FixedSizeInfo() = default;\n\n    /// Calculate the fixed size in bytes given a DWARFUnit.\n    ///\n    /// \\param U the DWARFUnit to use when determing the byte size.\n    /// \\returns the size in bytes for all attribute data in this abbreviation.\n    /// The returned size does not include bytes for the  ULEB128 abbreviation\n    /// code\n    size_t getByteSize(const DWARFUnit &U) const;\n  };\n\n  uint32_t Code;\n  dwarf::Tag Tag;\n  uint8_t CodeByteSize;\n  bool HasChildren;\n  AttributeSpecVector AttributeSpecs;\n  /// If this abbreviation has a fixed byte size then FixedAttributeSize member\n  /// variable below will have a value.\n  Optional<FixedSizeInfo> FixedAttributeSize;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFABBREVIATIONDECLARATION_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAttribute.h", "content": "//===- DWARFAttribute.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFATTRIBUTE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFATTRIBUTE_H\n\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFFormValue.h\"\n#include <cstdint>\n\nnamespace llvm {\n\n//===----------------------------------------------------------------------===//\n/// Encapsulates a DWARF attribute value and all of the data required to\n/// describe the attribute value.\n///\n/// This class is designed to be used by clients that want to iterate across all\n/// attributes in a DWARFDie.\nstruct DWARFAttribute {\n  /// The debug info/types offset for this attribute.\n  uint64_t Offset = 0;\n  /// The debug info/types section byte size of the data for this attribute.\n  uint32_t ByteSize = 0;\n  /// The attribute enumeration of this attribute.\n  dwarf::Attribute Attr = dwarf::Attribute(0);\n  /// The form and value for this attribute.\n  DWARFFormValue Value;\n\n  bool isValid() const {\n    return Offset != 0 && Attr != dwarf::Attribute(0);\n  }\n\n  explicit operator bool() const {\n    return isValid();\n  }\n\n  /// Identifies DWARF attributes that may contain a reference to a\n  /// DWARF expression.\n  static bool mayHaveLocationDescription(dwarf::Attribute Attr);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFATTRIBUTE_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h", "content": "//===- DWARFDebugAbbrev.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGABBREV_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGABBREV_H\n\n#include \"llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cstdint>\n#include <map>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass DWARFAbbreviationDeclarationSet {\n  uint64_t Offset;\n  /// Code of the first abbreviation, if all abbreviations in the set have\n  /// consecutive codes. UINT32_MAX otherwise.\n  uint32_t FirstAbbrCode;\n  std::vector<DWARFAbbreviationDeclaration> Decls;\n\n  using const_iterator =\n      std::vector<DWARFAbbreviationDeclaration>::const_iterator;\n\npublic:\n  DWARFAbbreviationDeclarationSet();\n\n  uint64_t getOffset() const { return Offset; }\n  void dump(raw_ostream &OS) const;\n  bool extract(DataExtractor Data, uint64_t *OffsetPtr);\n\n  const DWARFAbbreviationDeclaration *\n  getAbbreviationDeclaration(uint32_t AbbrCode) const;\n\n  const_iterator begin() const {\n    return Decls.begin();\n  }\n\n  const_iterator end() const {\n    return Decls.end();\n  }\n\nprivate:\n  void clear();\n};\n\nclass DWARFDebugAbbrev {\n  using DWARFAbbreviationDeclarationSetMap =\n      std::map<uint64_t, DWARFAbbreviationDeclarationSet>;\n\n  mutable DWARFAbbreviationDeclarationSetMap AbbrDeclSets;\n  mutable DWARFAbbreviationDeclarationSetMap::const_iterator PrevAbbrOffsetPos;\n  mutable Optional<DataExtractor> Data;\n\npublic:\n  DWARFDebugAbbrev();\n\n  const DWARFAbbreviationDeclarationSet *\n  getAbbreviationDeclarationSet(uint64_t CUAbbrOffset) const;\n\n  void dump(raw_ostream &OS) const;\n  void parse() const;\n  void extract(DataExtractor Data);\n\n  DWARFAbbreviationDeclarationSetMap::const_iterator begin() const {\n    parse();\n    return AbbrDeclSets.begin();\n  }\n\n  DWARFAbbreviationDeclarationSetMap::const_iterator end() const {\n    return AbbrDeclSets.end();\n  }\n\nprivate:\n  void clear();\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGABBREV_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "content": "//===- DWARFDebugLoc.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGLOC_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGLOC_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFLocationExpression.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFRelocMap.h\"\n#include <cstdint>\n\nnamespace llvm {\nclass DWARFUnit;\nclass MCRegisterInfo;\nclass raw_ostream;\n\n/// A single location within a location list. Entries are stored in the DWARF5\n/// form even if they originally come from a DWARF<=4 location list.\nstruct DWARFLocationEntry {\n  /// The entry kind (DW_LLE_***).\n  uint8_t Kind;\n\n  /// The first value of the location entry (if applicable).\n  uint64_t Value0;\n\n  /// The second value of the location entry (if applicable).\n  uint64_t Value1;\n\n  /// The index of the section this entry is relative to (if applicable).\n  uint64_t SectionIndex;\n\n  /// The location expression itself (if applicable).\n  SmallVector<uint8_t, 4> Loc;\n};\n\n/// An abstract base class for various kinds of location tables (.debug_loc,\n/// .debug_loclists, and their dwo variants).\nclass DWARFLocationTable {\npublic:\n  DWARFLocationTable(DWARFDataExtractor Data) : Data(std::move(Data)) {}\n  virtual ~DWARFLocationTable() = default;\n\n  /// Call the user-provided callback for each entry (including the end-of-list\n  /// entry) in the location list starting at \\p Offset. The callback can return\n  /// false to terminate the iteration early. Returns an error if it was unable\n  /// to parse the entire location list correctly. Upon successful termination\n  /// \\p Offset will be updated point past the end of the list.\n  virtual Error visitLocationList(\n      uint64_t *Offset,\n      function_ref<bool(const DWARFLocationEntry &)> Callback) const = 0;\n\n  /// Dump the location list at the given \\p Offset. The function returns true\n  /// iff it has successfully reched the end of the list. This means that one\n  /// can attempt to parse another list after the current one (\\p Offset will be\n  /// updated to point past the end of the current list).\n  bool dumpLocationList(uint64_t *Offset, raw_ostream &OS,\n                        Optional<object::SectionedAddress> BaseAddr,\n                        const MCRegisterInfo *MRI, const DWARFObject &Obj,\n                        DWARFUnit *U, DIDumpOptions DumpOpts,\n                        unsigned Indent) const;\n\n  Error visitAbsoluteLocationList(\n      uint64_t Offset, Optional<object::SectionedAddress> BaseAddr,\n      std::function<Optional<object::SectionedAddress>(uint32_t)> LookupAddr,\n      function_ref<bool(Expected<DWARFLocationExpression>)> Callback) const;\n\n  const DWARFDataExtractor &getData() { return Data; }\n\nprotected:\n  DWARFDataExtractor Data;\n\n  virtual void dumpRawEntry(const DWARFLocationEntry &Entry, raw_ostream &OS,\n                            unsigned Indent, DIDumpOptions DumpOpts,\n                            const DWARFObject &Obj) const = 0;\n};\n\nclass DWARFDebugLoc final : public DWARFLocationTable {\npublic:\n  /// A list of locations that contain one variable.\n  struct LocationList {\n    /// The beginning offset where this location list is stored in the debug_loc\n    /// section.\n    uint64_t Offset;\n    /// All the locations in which the variable is stored.\n    SmallVector<DWARFLocationEntry, 2> Entries;\n  };\n\nprivate:\n  using LocationLists = SmallVector<LocationList, 4>;\n\n  /// A list of all the variables in the debug_loc section, each one describing\n  /// the locations in which the variable is stored.\n  LocationLists Locations;\n\npublic:\n  DWARFDebugLoc(DWARFDataExtractor Data)\n      : DWARFLocationTable(std::move(Data)) {}\n\n  /// Print the location lists found within the debug_loc section.\n  void dump(raw_ostream &OS, const MCRegisterInfo *RegInfo,\n            const DWARFObject &Obj, DIDumpOptions DumpOpts,\n            Optional<uint64_t> Offset) const;\n\n  Error visitLocationList(\n      uint64_t *Offset,\n      function_ref<bool(const DWARFLocationEntry &)> Callback) const override;\n\nprotected:\n  void dumpRawEntry(const DWARFLocationEntry &Entry, raw_ostream &OS,\n                    unsigned Indent, DIDumpOptions DumpOpts,\n                    const DWARFObject &Obj) const override;\n};\n\nclass DWARFDebugLoclists final : public DWARFLocationTable {\npublic:\n  DWARFDebugLoclists(DWARFDataExtractor Data, uint16_t Version)\n      : DWARFLocationTable(std::move(Data)), Version(Version) {}\n\n  Error visitLocationList(\n      uint64_t *Offset,\n      function_ref<bool(const DWARFLocationEntry &)> Callback) const override;\n\n  /// Dump all location lists within the given range.\n  void dumpRange(uint64_t StartOffset, uint64_t Size, raw_ostream &OS,\n                 const MCRegisterInfo *MRI, const DWARFObject &Obj,\n                 DIDumpOptions DumpOpts);\n\nprotected:\n  void dumpRawEntry(const DWARFLocationEntry &Entry, raw_ostream &OS,\n                    unsigned Indent, DIDumpOptions DumpOpts,\n                    const DWARFObject &Obj) const override;\n\nprivate:\n  uint16_t Version;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGLOC_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRangeList.h", "content": "//===- DWARFDebugRangeList.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n\n#include \"llvm/DebugInfo/DWARF/DWARFAddressRange.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include <cassert>\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass DWARFDebugRangeList {\npublic:\n  struct RangeListEntry {\n    /// A beginning address offset. This address offset has the size of an\n    /// address and is relative to the applicable base address of the\n    /// compilation unit referencing this range list. It marks the beginning\n    /// of an address range.\n    uint64_t StartAddress;\n    /// An ending address offset. This address offset again has the size of\n    /// an address and is relative to the applicable base address of the\n    /// compilation unit referencing this range list. It marks the first\n    /// address past the end of the address range. The ending address must\n    /// be greater than or equal to the beginning address.\n    uint64_t EndAddress;\n    /// A section index this range belongs to.\n    uint64_t SectionIndex;\n\n    /// The end of any given range list is marked by an end of list entry,\n    /// which consists of a 0 for the beginning address offset\n    /// and a 0 for the ending address offset.\n    bool isEndOfListEntry() const {\n      return (StartAddress == 0) && (EndAddress == 0);\n    }\n\n    /// A base address selection entry consists of:\n    /// 1. The value of the largest representable address offset\n    /// (for example, 0xffffffff when the size of an address is 32 bits).\n    /// 2. An address, which defines the appropriate base address for\n    /// use in interpreting the beginning and ending address offsets of\n    /// subsequent entries of the location list.\n    bool isBaseAddressSelectionEntry(uint8_t AddressSize) const {\n      assert(AddressSize == 4 || AddressSize == 8);\n      if (AddressSize == 4)\n        return StartAddress == -1U;\n      return StartAddress == -1ULL;\n    }\n  };\n\nprivate:\n  /// Offset in .debug_ranges section.\n  uint64_t Offset;\n  uint8_t AddressSize;\n  std::vector<RangeListEntry> Entries;\n\npublic:\n  DWARFDebugRangeList() { clear(); }\n\n  void clear();\n  void dump(raw_ostream &OS) const;\n  Error extract(const DWARFDataExtractor &data, uint64_t *offset_ptr);\n  const std::vector<RangeListEntry> &getEntries() { return Entries; }\n\n  /// getAbsoluteRanges - Returns absolute address ranges defined by this range\n  /// list. Has to be passed base address of the compile unit referencing this\n  /// range list.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(llvm::Optional<object::SectionedAddress> BaseAddr) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGRANGELIST_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRnglists.h", "content": "//===- DWARFDebugRnglists.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRangeList.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFListTable.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass Error;\nclass raw_ostream;\nclass DWARFUnit;\n\n/// A class representing a single range list entry.\nstruct RangeListEntry : public DWARFListEntryBase {\n  /// The values making up the range list entry. Most represent a range with\n  /// a start and end address or a start address and a length. Others are\n  /// single value base addresses or end-of-list with no values. The unneeded\n  /// values are semantically undefined, but initialized to 0.\n  uint64_t Value0;\n  uint64_t Value1;\n\n  Error extract(DWARFDataExtractor Data, uint64_t *OffsetPtr);\n  void dump(raw_ostream &OS, uint8_t AddrSize, uint8_t MaxEncodingStringLength,\n            uint64_t &CurrentBase, DIDumpOptions DumpOpts,\n            llvm::function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                LookupPooledAddress) const;\n  bool isSentinel() const { return EntryKind == dwarf::DW_RLE_end_of_list; }\n};\n\n/// A class representing a single rangelist.\nclass DWARFDebugRnglist : public DWARFListType<RangeListEntry> {\npublic:\n  /// Build a DWARFAddressRangesVector from a rangelist.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(Optional<object::SectionedAddress> BaseAddr,\n                    uint8_t AddressByteSize,\n                    function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                        LookupPooledAddress) const;\n\n  /// Build a DWARFAddressRangesVector from a rangelist.\n  DWARFAddressRangesVector\n  getAbsoluteRanges(llvm::Optional<object::SectionedAddress> BaseAddr,\n                    DWARFUnit &U) const;\n};\n\nclass DWARFDebugRnglistTable : public DWARFListTableBase<DWARFDebugRnglist> {\npublic:\n  DWARFDebugRnglistTable()\n      : DWARFListTableBase(/* SectionName    = */ \".debug_rnglists\",\n                           /* HeaderString   = */ \"ranges:\",\n                           /* ListTypeString = */ \"range\") {}\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDEBUGRNGLISTS_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "content": "//===- DWARFDie.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAddressRange.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAttribute.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLoc.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\nclass DWARFUnit;\nclass raw_ostream;\n\n//===----------------------------------------------------------------------===//\n/// Utility class that carries the DWARF compile/type unit and the debug info\n/// entry in an object.\n///\n/// When accessing information from a debug info entry we always need to DWARF\n/// compile/type unit in order to extract the info correctly as some information\n/// is relative to the compile/type unit. Prior to this class the DWARFUnit and\n/// the DWARFDebugInfoEntry was passed around separately and there was the\n/// possibility for error if the wrong DWARFUnit was used to extract a unit\n/// relative offset. This class helps to ensure that this doesn't happen and\n/// also simplifies the attribute extraction calls by not having to specify the\n/// DWARFUnit for each call.\nclass DWARFDie {\n  DWARFUnit *U = nullptr;\n  const DWARFDebugInfoEntry *Die = nullptr;\n\npublic:\n  DWARFDie() = default;\n  DWARFDie(DWARFUnit *Unit, const DWARFDebugInfoEntry *D) : U(Unit), Die(D) {}\n\n  bool isValid() const { return U && Die; }\n  explicit operator bool() const { return isValid(); }\n  const DWARFDebugInfoEntry *getDebugInfoEntry() const { return Die; }\n  DWARFUnit *getDwarfUnit() const { return U; }\n\n  /// Get the abbreviation declaration for this DIE.\n  ///\n  /// \\returns the abbreviation declaration or NULL for null tags.\n  const DWARFAbbreviationDeclaration *getAbbreviationDeclarationPtr() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->getAbbreviationDeclarationPtr();\n  }\n\n  /// Get the absolute offset into the debug info or types section.\n  ///\n  /// \\returns the DIE offset or -1U if invalid.\n  uint64_t getOffset() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->getOffset();\n  }\n\n  dwarf::Tag getTag() const {\n    auto AbbrevDecl = getAbbreviationDeclarationPtr();\n    if (AbbrevDecl)\n      return AbbrevDecl->getTag();\n    return dwarf::DW_TAG_null;\n  }\n\n  bool hasChildren() const {\n    assert(isValid() && \"must check validity prior to calling\");\n    return Die->hasChildren();\n  }\n\n  /// Returns true for a valid DIE that terminates a sibling chain.\n  bool isNULL() const { return getAbbreviationDeclarationPtr() == nullptr; }\n\n  /// Returns true if DIE represents a subprogram (not inlined).\n  bool isSubprogramDIE() const;\n\n  /// Returns true if DIE represents a subprogram or an inlined subroutine.\n  bool isSubroutineDIE() const;\n\n  /// Get the parent of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a parent or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getParent() const;\n\n  /// Get the sibling of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a sibling or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getSibling() const;\n\n  /// Get the previous sibling of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has a sibling or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getPreviousSibling() const;\n\n  /// Get the first child of this DIE object.\n  ///\n  /// \\returns a valid DWARFDie instance if this object has children or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getFirstChild() const;\n\n  /// Get the last child of this DIE object.\n  ///\n  /// \\returns a valid null DWARFDie instance if this object has children or an\n  /// invalid DWARFDie instance if it doesn't.\n  DWARFDie getLastChild() const;\n\n  /// Dump the DIE and all of its attributes to the supplied stream.\n  ///\n  /// \\param OS the stream to use for output.\n  /// \\param indent the number of characters to indent each line that is output.\n  void dump(raw_ostream &OS, unsigned indent = 0,\n            DIDumpOptions DumpOpts = DIDumpOptions()) const;\n\n  /// Convenience zero-argument overload for debugging.\n  LLVM_DUMP_METHOD void dump() const;\n\n  /// Extract the specified attribute from this DIE.\n  ///\n  /// Extract an attribute value from this DIE only. This call doesn't look\n  /// for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs.\n  ///\n  /// \\param Attr the attribute to extract.\n  /// \\returns an optional DWARFFormValue that will have the form value if the\n  /// attribute was successfully extracted.\n  Optional<DWARFFormValue> find(dwarf::Attribute Attr) const;\n\n  /// Extract the first value of any attribute in Attrs from this DIE.\n  ///\n  /// Extract the first attribute that matches from this DIE only. This call\n  /// doesn't look for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs. The attributes will be searched\n  /// linearly in the order they are specified within Attrs.\n  ///\n  /// \\param Attrs an array of DWARF attribute to look for.\n  /// \\returns an optional that has a valid DWARFFormValue for the first\n  /// matching attribute in Attrs, or None if none of the attributes in Attrs\n  /// exist in this DIE.\n  Optional<DWARFFormValue> find(ArrayRef<dwarf::Attribute> Attrs) const;\n\n  /// Extract the first value of any attribute in Attrs from this DIE and\n  /// recurse into any DW_AT_specification or DW_AT_abstract_origin referenced\n  /// DIEs.\n  ///\n  /// \\param Attrs an array of DWARF attribute to look for.\n  /// \\returns an optional that has a valid DWARFFormValue for the first\n  /// matching attribute in Attrs, or None if none of the attributes in Attrs\n  /// exist in this DIE or in any DW_AT_specification or DW_AT_abstract_origin\n  /// DIEs.\n  Optional<DWARFFormValue>\n  findRecursively(ArrayRef<dwarf::Attribute> Attrs) const;\n\n  /// Extract the specified attribute from this DIE as the referenced DIE.\n  ///\n  /// Regardless of the reference type, return the correct DWARFDie instance if\n  /// the attribute exists. The returned DWARFDie object might be from another\n  /// DWARFUnit, but that is all encapsulated in the new DWARFDie object.\n  ///\n  /// Extract an attribute value from this DIE only. This call doesn't look\n  /// for the attribute value in any DW_AT_specification or\n  /// DW_AT_abstract_origin referenced DIEs.\n  ///\n  /// \\param Attr the attribute to extract.\n  /// \\returns a valid DWARFDie instance if the attribute exists, or an invalid\n  /// DWARFDie object if it doesn't.\n  DWARFDie getAttributeValueAsReferencedDie(dwarf::Attribute Attr) const;\n  DWARFDie getAttributeValueAsReferencedDie(const DWARFFormValue &V) const;\n\n  /// Extract the range base attribute from this DIE as absolute section offset.\n  ///\n  /// This is a utility function that checks for either the DW_AT_rnglists_base\n  /// or DW_AT_GNU_ranges_base attribute.\n  ///\n  /// \\returns anm optional absolute section offset value for the attribute.\n  Optional<uint64_t> getRangesBaseAttribute() const;\n  Optional<uint64_t> getLocBaseAttribute() const;\n\n  /// Get the DW_AT_high_pc attribute value as an address.\n  ///\n  /// In DWARF version 4 and later the high PC can be encoded as an offset from\n  /// the DW_AT_low_pc. This function takes care of extracting the value as an\n  /// address or offset and adds it to the low PC if needed and returns the\n  /// value as an optional in case the DIE doesn't have a DW_AT_high_pc\n  /// attribute.\n  ///\n  /// \\param LowPC the low PC that might be needed to calculate the high PC.\n  /// \\returns an optional address value for the attribute.\n  Optional<uint64_t> getHighPC(uint64_t LowPC) const;\n\n  /// Retrieves DW_AT_low_pc and DW_AT_high_pc from CU.\n  /// Returns true if both attributes are present.\n  bool getLowAndHighPC(uint64_t &LowPC, uint64_t &HighPC,\n                       uint64_t &SectionIndex) const;\n\n  /// Get the address ranges for this DIE.\n  ///\n  /// Get the hi/low PC range if both attributes are available or exrtracts the\n  /// non-contiguous address ranges from the DW_AT_ranges attribute.\n  ///\n  /// Extracts the range information from this DIE only. This call doesn't look\n  /// for the range in any DW_AT_specification or DW_AT_abstract_origin DIEs.\n  ///\n  /// \\returns a address range vector that might be empty if no address range\n  /// information is available.\n  Expected<DWARFAddressRangesVector> getAddressRanges() const;\n\n  /// Get all address ranges for any DW_TAG_subprogram DIEs in this DIE or any\n  /// of its children.\n  ///\n  /// Get the hi/low PC range if both attributes are available or exrtracts the\n  /// non-contiguous address ranges from the DW_AT_ranges attribute for this DIE\n  /// and all children.\n  ///\n  /// \\param Ranges the addres range vector to fill in.\n  void collectChildrenAddressRanges(DWARFAddressRangesVector &Ranges) const;\n\n  bool addressRangeContainsAddress(const uint64_t Address) const;\n\n  Expected<DWARFLocationExpressionsVector>\n  getLocations(dwarf::Attribute Attr) const;\n\n  /// If a DIE represents a subprogram (or inlined subroutine), returns its\n  /// mangled name (or short name, if mangled is missing). This name may be\n  /// fetched from specification or abstract origin for this subprogram.\n  /// Returns null if no name is found.\n  const char *getSubroutineName(DINameKind Kind) const;\n\n  /// Return the DIE name resolving DW_AT_specification or DW_AT_abstract_origin\n  /// references if necessary. For the LinkageName case it additionaly searches\n  /// for ShortName if LinkageName is not found.\n  /// Returns null if no name is found.\n  const char *getName(DINameKind Kind) const;\n\n  /// Return the DIE short name resolving DW_AT_specification or\n  /// DW_AT_abstract_origin references if necessary. Returns null if no name\n  /// is found.\n  const char *getShortName() const;\n\n  /// Return the DIE linkage name resolving DW_AT_specification or\n  /// DW_AT_abstract_origin references if necessary. Returns null if no name\n  /// is found.\n  const char *getLinkageName() const;\n\n  /// Returns the declaration line (start line) for a DIE, assuming it specifies\n  /// a subprogram. This may be fetched from specification or abstract origin\n  /// for this subprogram by resolving DW_AT_sepcification or\n  /// DW_AT_abstract_origin references if necessary.\n  uint64_t getDeclLine() const;\n  std::string getDeclFile(DILineInfoSpecifier::FileLineInfoKind Kind) const;\n\n  /// Retrieves values of DW_AT_call_file, DW_AT_call_line and DW_AT_call_column\n  /// from DIE (or zeroes if they are missing). This function looks for\n  /// DW_AT_call attributes in this DIE only, it will not resolve the attribute\n  /// values in any DW_AT_specification or DW_AT_abstract_origin DIEs.\n  /// \\param CallFile filled in with non-zero if successful, zero if there is no\n  /// DW_AT_call_file attribute in this DIE.\n  /// \\param CallLine filled in with non-zero if successful, zero if there is no\n  /// DW_AT_call_line attribute in this DIE.\n  /// \\param CallColumn filled in with non-zero if successful, zero if there is\n  /// no DW_AT_call_column attribute in this DIE.\n  /// \\param CallDiscriminator filled in with non-zero if successful, zero if\n  /// there is no DW_AT_GNU_discriminator attribute in this DIE.\n  void getCallerFrame(uint32_t &CallFile, uint32_t &CallLine,\n                      uint32_t &CallColumn, uint32_t &CallDiscriminator) const;\n\n  class attribute_iterator;\n\n  /// Get an iterator range to all attributes in the current DIE only.\n  ///\n  /// \\returns an iterator range for the attributes of the current DIE.\n  iterator_range<attribute_iterator> attributes() const;\n\n  class iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\n  std::reverse_iterator<iterator> rbegin() const;\n  std::reverse_iterator<iterator> rend() const;\n\n  iterator_range<iterator> children() const;\n};\n\nclass DWARFDie::attribute_iterator\n    : public iterator_facade_base<attribute_iterator, std::forward_iterator_tag,\n                                  const DWARFAttribute> {\n  /// The DWARF DIE we are extracting attributes from.\n  DWARFDie Die;\n  /// The value vended to clients via the operator*() or operator->().\n  DWARFAttribute AttrValue;\n  /// The attribute index within the abbreviation declaration in Die.\n  uint32_t Index;\n\n  friend bool operator==(const attribute_iterator &LHS,\n                         const attribute_iterator &RHS);\n\n  /// Update the attribute index and attempt to read the attribute value. If the\n  /// attribute is able to be read, update AttrValue and the Index member\n  /// variable. If the attribute value is not able to be read, an appropriate\n  /// error will be set if the Err member variable is non-NULL and the iterator\n  /// will be set to the end value so iteration stops.\n  void updateForIndex(const DWARFAbbreviationDeclaration &AbbrDecl, uint32_t I);\n\npublic:\n  attribute_iterator() = delete;\n  explicit attribute_iterator(DWARFDie D, bool End);\n\n  attribute_iterator &operator++();\n  attribute_iterator &operator--();\n  explicit operator bool() const { return AttrValue.isValid(); }\n  const DWARFAttribute &operator*() const { return AttrValue; }\n};\n\ninline bool operator==(const DWARFDie::attribute_iterator &LHS,\n                       const DWARFDie::attribute_iterator &RHS) {\n  return LHS.Index == RHS.Index;\n}\n\ninline bool operator!=(const DWARFDie::attribute_iterator &LHS,\n                       const DWARFDie::attribute_iterator &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator==(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return LHS.getDebugInfoEntry() == RHS.getDebugInfoEntry() &&\n         LHS.getDwarfUnit() == RHS.getDwarfUnit();\n}\n\ninline bool operator!=(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator<(const DWARFDie &LHS, const DWARFDie &RHS) {\n  return LHS.getOffset() < RHS.getOffset();\n}\n\nclass DWARFDie::iterator\n    : public iterator_facade_base<iterator, std::bidirectional_iterator_tag,\n                                  const DWARFDie> {\n  DWARFDie Die;\n\n  friend std::reverse_iterator<llvm::DWARFDie::iterator>;\n  friend bool operator==(const DWARFDie::iterator &LHS,\n                         const DWARFDie::iterator &RHS);\n\npublic:\n  iterator() = default;\n\n  explicit iterator(DWARFDie D) : Die(D) {}\n\n  iterator &operator++() {\n    Die = Die.getSibling();\n    return *this;\n  }\n\n  iterator &operator--() {\n    Die = Die.getPreviousSibling();\n    return *this;\n  }\n\n  const DWARFDie &operator*() const { return Die; }\n};\n\ninline bool operator==(const DWARFDie::iterator &LHS,\n                       const DWARFDie::iterator &RHS) {\n  return LHS.Die == RHS.Die;\n}\n\n// These inline functions must follow the DWARFDie::iterator definition above\n// as they use functions from that class.\ninline DWARFDie::iterator DWARFDie::begin() const {\n  return iterator(getFirstChild());\n}\n\ninline DWARFDie::iterator DWARFDie::end() const {\n  return iterator(getLastChild());\n}\n\ninline iterator_range<DWARFDie::iterator> DWARFDie::children() const {\n  return make_range(begin(), end());\n}\n\n} // end namespace llvm\n\nnamespace std {\n\ntemplate <>\nclass reverse_iterator<llvm::DWARFDie::iterator>\n    : public llvm::iterator_facade_base<\n          reverse_iterator<llvm::DWARFDie::iterator>,\n          bidirectional_iterator_tag, const llvm::DWARFDie> {\n\nprivate:\n  llvm::DWARFDie Die;\n  bool AtEnd;\n\npublic:\n  reverse_iterator(llvm::DWARFDie::iterator It)\n      : Die(It.Die), AtEnd(!It.Die.getPreviousSibling()) {\n    if (!AtEnd)\n      Die = Die.getPreviousSibling();\n  }\n\n  llvm::DWARFDie::iterator base() const {\n    return llvm::DWARFDie::iterator(AtEnd ? Die : Die.getSibling());\n  }\n\n  reverse_iterator<llvm::DWARFDie::iterator> &operator++() {\n    assert(!AtEnd && \"Incrementing rend\");\n    llvm::DWARFDie D = Die.getPreviousSibling();\n    if (D)\n      Die = D;\n    else\n      AtEnd = true;\n    return *this;\n  }\n\n  reverse_iterator<llvm::DWARFDie::iterator> &operator--() {\n    if (AtEnd) {\n      AtEnd = false;\n      return *this;\n    }\n    Die = Die.getSibling();\n    assert(!Die.isNULL() && \"Decrementing rbegin\");\n    return *this;\n  }\n\n  const llvm::DWARFDie &operator*() const {\n    assert(Die.isValid());\n    return Die;\n  }\n\n  // FIXME: We should be able to specify the equals operator as a friend, but\n  //        that causes the compiler to think the operator overload is ambiguous\n  //        with the friend declaration and the actual definition as candidates.\n  bool equals(const reverse_iterator<llvm::DWARFDie::iterator> &RHS) const {\n    return Die == RHS.Die && AtEnd == RHS.AtEnd;\n  }\n};\n\n} // namespace std\n\nnamespace llvm {\n\ninline bool operator==(const std::reverse_iterator<DWARFDie::iterator> &LHS,\n                       const std::reverse_iterator<DWARFDie::iterator> &RHS) {\n  return LHS.equals(RHS);\n}\n\ninline bool operator!=(const std::reverse_iterator<DWARFDie::iterator> &LHS,\n                       const std::reverse_iterator<DWARFDie::iterator> &RHS) {\n  return !(LHS == RHS);\n}\n\ninline std::reverse_iterator<DWARFDie::iterator> DWARFDie::rbegin() const {\n  return llvm::make_reverse_iterator(end());\n}\n\ninline std::reverse_iterator<DWARFDie::iterator> DWARFDie::rend() const {\n  return llvm::make_reverse_iterator(begin());\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFDIE_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "content": "//===- DWARFListTable.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFLISTTABLE_H\n#define LLVM_DEBUGINFO_DWARF_DWARFLISTTABLE_H\n\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DIContext.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDataExtractor.h\"\n#include \"llvm/Support/Errc.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <map>\n#include <vector>\n\nnamespace llvm {\n\n/// A base class for DWARF list entries, such as range or location list\n/// entries.\nstruct DWARFListEntryBase {\n  /// The offset at which the entry is located in the section.\n  uint64_t Offset;\n  /// The DWARF encoding (DW_RLE_* or DW_LLE_*).\n  uint8_t EntryKind;\n  /// The index of the section this entry belongs to.\n  uint64_t SectionIndex;\n};\n\n/// A base class for lists of entries that are extracted from a particular\n/// section, such as range lists or location lists.\ntemplate <typename ListEntryType> class DWARFListType {\n  using EntryType = ListEntryType;\n  using ListEntries = std::vector<EntryType>;\n\nprotected:\n  ListEntries Entries;\n\npublic:\n  const ListEntries &getEntries() const { return Entries; }\n  bool empty() const { return Entries.empty(); }\n  void clear() { Entries.clear(); }\n  Error extract(DWARFDataExtractor Data, uint64_t HeaderOffset,\n                uint64_t *OffsetPtr, StringRef SectionName,\n                StringRef ListStringName);\n};\n\n/// A class representing the header of a list table such as the range list\n/// table in the .debug_rnglists section.\nclass DWARFListTableHeader {\n  struct Header {\n    /// The total length of the entries for this table, not including the length\n    /// field itself.\n    uint64_t Length = 0;\n    /// The DWARF version number.\n    uint16_t Version;\n    /// The size in bytes of an address on the target architecture. For\n    /// segmented addressing, this is the size of the offset portion of the\n    /// address.\n    uint8_t AddrSize;\n    /// The size in bytes of a segment selector on the target architecture.\n    /// If the target system uses a flat address space, this value is 0.\n    uint8_t SegSize;\n    /// The number of offsets that follow the header before the range lists.\n    uint32_t OffsetEntryCount;\n  };\n\n  Header HeaderData;\n  /// The table's format, either DWARF32 or DWARF64.\n  dwarf::DwarfFormat Format;\n  /// The offset at which the header (and hence the table) is located within\n  /// its section.\n  uint64_t HeaderOffset;\n  /// The name of the section the list is located in.\n  StringRef SectionName;\n  /// A characterization of the list for dumping purposes, e.g. \"range\" or\n  /// \"location\".\n  StringRef ListTypeString;\n\npublic:\n  DWARFListTableHeader(StringRef SectionName, StringRef ListTypeString)\n      : SectionName(SectionName), ListTypeString(ListTypeString) {}\n\n  void clear() {\n    HeaderData = {};\n  }\n  uint64_t getHeaderOffset() const { return HeaderOffset; }\n  uint8_t getAddrSize() const { return HeaderData.AddrSize; }\n  uint64_t getLength() const { return HeaderData.Length; }\n  uint16_t getVersion() const { return HeaderData.Version; }\n  StringRef getSectionName() const { return SectionName; }\n  StringRef getListTypeString() const { return ListTypeString; }\n  dwarf::DwarfFormat getFormat() const { return Format; }\n\n  /// Return the size of the table header including the length but not including\n  /// the offsets.\n  static uint8_t getHeaderSize(dwarf::DwarfFormat Format) {\n    switch (Format) {\n    case dwarf::DwarfFormat::DWARF32:\n      return 12;\n    case dwarf::DwarfFormat::DWARF64:\n      return 20;\n    }\n    llvm_unreachable(\"Invalid DWARF format (expected DWARF32 or DWARF64\");\n  }\n\n  void dump(DataExtractor Data, raw_ostream &OS,\n            DIDumpOptions DumpOpts = {}) const;\n  Optional<uint64_t> getOffsetEntry(DataExtractor Data, uint32_t Index) const {\n    if (Index > HeaderData.OffsetEntryCount)\n      return None;\n\n    return getOffsetEntry(Data, getHeaderOffset() + getHeaderSize(Format), Format, Index);\n  }\n\n  static Optional<uint64_t> getOffsetEntry(DataExtractor Data,\n                                           uint64_t OffsetTableOffset,\n                                           dwarf::DwarfFormat Format,\n                                           uint32_t Index) {\n    uint8_t OffsetByteSize = Format == dwarf::DWARF64 ? 8 : 4;\n    uint64_t Offset = OffsetTableOffset + OffsetByteSize * Index;\n    auto R = Data.getUnsigned(&Offset, OffsetByteSize);\n    return R;\n  }\n\n  /// Extract the table header and the array of offsets.\n  Error extract(DWARFDataExtractor Data, uint64_t *OffsetPtr);\n\n  /// Returns the length of the table, including the length field, or 0 if the\n  /// length has not been determined (e.g. because the table has not yet been\n  /// parsed, or there was a problem in parsing).\n  uint64_t length() const;\n};\n\n/// A class representing a table of lists as specified in the DWARF v5\n/// standard for location lists and range lists. The table consists of a header\n/// followed by an array of offsets into a DWARF section, followed by zero or\n/// more list entries. The list entries are kept in a map where the keys are\n/// the lists' section offsets.\ntemplate <typename DWARFListType> class DWARFListTableBase {\n  DWARFListTableHeader Header;\n  /// A mapping between file offsets and lists. It is used to find a particular\n  /// list based on an offset (obtained from DW_AT_ranges, for example).\n  std::map<uint64_t, DWARFListType> ListMap;\n  /// This string is displayed as a heading before the list is dumped\n  /// (e.g. \"ranges:\").\n  StringRef HeaderString;\n\nprotected:\n  DWARFListTableBase(StringRef SectionName, StringRef HeaderString,\n                     StringRef ListTypeString)\n      : Header(SectionName, ListTypeString), HeaderString(HeaderString) {}\n\npublic:\n  void clear() {\n    Header.clear();\n    ListMap.clear();\n  }\n  /// Extract the table header and the array of offsets.\n  Error extractHeaderAndOffsets(DWARFDataExtractor Data, uint64_t *OffsetPtr) {\n    return Header.extract(Data, OffsetPtr);\n  }\n  /// Extract an entire table, including all list entries.\n  Error extract(DWARFDataExtractor Data, uint64_t *OffsetPtr);\n  /// Look up a list based on a given offset. Extract it and enter it into the\n  /// list map if necessary.\n  Expected<DWARFListType> findList(DWARFDataExtractor Data, uint64_t Offset);\n\n  uint64_t getHeaderOffset() const { return Header.getHeaderOffset(); }\n  uint8_t getAddrSize() const { return Header.getAddrSize(); }\n  dwarf::DwarfFormat getFormat() const { return Header.getFormat(); }\n\n  void dump(DWARFDataExtractor Data, raw_ostream &OS,\n            llvm::function_ref<Optional<object::SectionedAddress>(uint32_t)>\n                LookupPooledAddress,\n            DIDumpOptions DumpOpts = {}) const;\n\n  /// Return the contents of the offset entry designated by a given index.\n  Optional<uint64_t> getOffsetEntry(DataExtractor Data, uint32_t Index) const {\n    return Header.getOffsetEntry(Data, Index);\n  }\n  /// Return the size of the table header including the length but not including\n  /// the offsets. This is dependent on the table format, which is unambiguously\n  /// derived from parsing the table.\n  uint8_t getHeaderSize() const {\n    return DWARFListTableHeader::getHeaderSize(getFormat());\n  }\n\n  uint64_t length() { return Header.length(); }\n};\n\ntemplate <typename DWARFListType>\nError DWARFListTableBase<DWARFListType>::extract(DWARFDataExtractor Data,\n                                                 uint64_t *OffsetPtr) {\n  clear();\n  if (Error E = extractHeaderAndOffsets(Data, OffsetPtr))\n    return E;\n\n  Data.setAddressSize(Header.getAddrSize());\n  Data = DWARFDataExtractor(Data, getHeaderOffset() + Header.length());\n  while (Data.isValidOffset(*OffsetPtr)) {\n    DWARFListType CurrentList;\n    uint64_t Off = *OffsetPtr;\n    if (Error E = CurrentList.extract(Data, getHeaderOffset(), OffsetPtr,\n                                      Header.getSectionName(),\n                                      Header.getListTypeString()))\n      return E;\n    ListMap[Off] = CurrentList;\n  }\n\n  assert(*OffsetPtr == Data.size() &&\n         \"mismatch between expected length of table and length \"\n         \"of extracted data\");\n  return Error::success();\n}\n\ntemplate <typename ListEntryType>\nError DWARFListType<ListEntryType>::extract(DWARFDataExtractor Data,\n                                            uint64_t HeaderOffset,\n                                            uint64_t *OffsetPtr,\n                                            StringRef SectionName,\n                                            StringRef ListTypeString) {\n  if (*OffsetPtr < HeaderOffset || *OffsetPtr >= Data.size())\n    return createStringError(errc::invalid_argument,\n                       \"invalid %s list offset 0x%\" PRIx64,\n                       ListTypeString.data(), *OffsetPtr);\n  Entries.clear();\n  while (Data.isValidOffset(*OffsetPtr)) {\n    ListEntryType Entry;\n    if (Error E = Entry.extract(Data, OffsetPtr))\n      return E;\n    Entries.push_back(Entry);\n    if (Entry.isSentinel())\n      return Error::success();\n  }\n  return createStringError(errc::illegal_byte_sequence,\n                     \"no end of list marker detected at end of %s table \"\n                     \"starting at offset 0x%\" PRIx64,\n                     SectionName.data(), HeaderOffset);\n}\n\ntemplate <typename DWARFListType>\nvoid DWARFListTableBase<DWARFListType>::dump(\n    DWARFDataExtractor Data, raw_ostream &OS,\n    llvm::function_ref<Optional<object::SectionedAddress>(uint32_t)>\n        LookupPooledAddress,\n    DIDumpOptions DumpOpts) const {\n  Header.dump(Data, OS, DumpOpts);\n  OS << HeaderString << \"\\n\";\n\n  // Determine the length of the longest encoding string we have in the table,\n  // so we can align the output properly. We only need this in verbose mode.\n  size_t MaxEncodingStringLength = 0;\n  if (DumpOpts.Verbose) {\n    for (const auto &List : ListMap)\n      for (const auto &Entry : List.second.getEntries())\n        MaxEncodingStringLength =\n            std::max(MaxEncodingStringLength,\n                     dwarf::RangeListEncodingString(Entry.EntryKind).size());\n  }\n\n  uint64_t CurrentBase = 0;\n  for (const auto &List : ListMap)\n    for (const auto &Entry : List.second.getEntries())\n      Entry.dump(OS, getAddrSize(), MaxEncodingStringLength, CurrentBase,\n                 DumpOpts, LookupPooledAddress);\n}\n\ntemplate <typename DWARFListType>\nExpected<DWARFListType>\nDWARFListTableBase<DWARFListType>::findList(DWARFDataExtractor Data,\n                                            uint64_t Offset) {\n  // Extract the list from the section and enter it into the list map.\n  DWARFListType List;\n  if (Header.length())\n    Data = DWARFDataExtractor(Data, getHeaderOffset() + Header.length());\n  if (Error E =\n          List.extract(Data, Header.length() ? getHeaderOffset() : 0, &Offset,\n                       Header.getSectionName(), Header.getListTypeString()))\n    return std::move(E);\n  return List;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFLISTTABLE_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFLocationExpression.h", "content": "//===- DWARFLocationExpression.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFLOCATIONEXPRESSION_H\n#define LLVM_DEBUGINFO_DWARF_DWARFLOCATIONEXPRESSION_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAddressRange.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\n\n/// Represents a single DWARF expression, whose value is location-dependent.\n/// Typically used in DW_AT_location attributes to describe the location of\n/// objects.\nstruct DWARFLocationExpression {\n  /// The address range in which this expression is valid. None denotes a\n  /// default entry which is valid in addresses not covered by other location\n  /// expressions, or everywhere if there are no other expressions.\n  Optional<DWARFAddressRange> Range;\n\n  /// The expression itself.\n  SmallVector<uint8_t, 4> Expr;\n};\n\ninline bool operator==(const DWARFLocationExpression &L,\n                       const DWARFLocationExpression &R) {\n  return L.Range == R.Range && L.Expr == R.Expr;\n}\n\ninline bool operator!=(const DWARFLocationExpression &L,\n                       const DWARFLocationExpression &R) {\n  return !(L == R);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, const DWARFLocationExpression &Loc);\n\n/// Represents a set of absolute location expressions.\nusing DWARFLocationExpressionsVector = std::vector<DWARFLocationExpression>;\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFLOCATIONEXPRESSION_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFRelocMap.h", "content": "//===- DWARFRelocMap.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFRELOCMAP_H\n#define LLVM_DEBUGINFO_DWARF_DWARFRELOCMAP_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/Object/RelocationResolver.h\"\n#include <cstdint>\n\nnamespace llvm {\n\n/// RelocAddrEntry contains relocated value and section index.\n/// Section index is -1LL if relocation points to absolute symbol.\nstruct RelocAddrEntry {\n  uint64_t SectionIndex;\n  object::RelocationRef Reloc;\n  uint64_t SymbolValue;\n  Optional<object::RelocationRef> Reloc2;\n  uint64_t SymbolValue2;\n  object::RelocationResolver Resolver;\n};\n\n/// In place of applying the relocations to the data we've read from disk we use\n/// a separate mapping table to the side and checking that at locations in the\n/// dwarf where we expect relocated values. This adds a bit of complexity to the\n/// dwarf parsing/extraction at the benefit of not allocating memory for the\n/// entire size of the debug info sections.\nusing RelocAddrMap = DenseMap<uint64_t, RelocAddrEntry>;\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFRELOCMAP_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "content": "//===- DWARFUnit.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n#define LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugLoc.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRangeList.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDebugRnglists.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFDie.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFFormValue.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFRelocMap.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFSection.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFUnitIndex.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass DWARFAbbreviationDeclarationSet;\nclass DWARFContext;\nclass DWARFDebugAbbrev;\nclass DWARFUnit;\n\n/// Base class describing the header of any kind of \"unit.\"  Some information\n/// is specific to certain unit types.  We separate this class out so we can\n/// parse the header before deciding what specific kind of unit to construct.\nclass DWARFUnitHeader {\n  // Offset within section.\n  uint64_t Offset = 0;\n  // Version, address size, and DWARF format.\n  dwarf::FormParams FormParams;\n  uint64_t Length = 0;\n  uint64_t AbbrOffset = 0;\n\n  // For DWO units only.\n  const DWARFUnitIndex::Entry *IndexEntry = nullptr;\n\n  // For type units only.\n  uint64_t TypeHash = 0;\n  uint64_t TypeOffset = 0;\n\n  // For v5 split or skeleton compile units only.\n  Optional<uint64_t> DWOId;\n\n  // Unit type as parsed, or derived from the section kind.\n  uint8_t UnitType = 0;\n\n  // Size as parsed. uint8_t for compactness.\n  uint8_t Size = 0;\n\npublic:\n  /// Parse a unit header from \\p debug_info starting at \\p offset_ptr.\n  /// Note that \\p SectionKind is used as a hint to guess the unit type\n  /// for DWARF formats prior to DWARFv5. In DWARFv5 the unit type is\n  /// explicitly defined in the header and the hint is ignored.\n  bool extract(DWARFContext &Context, const DWARFDataExtractor &debug_info,\n               uint64_t *offset_ptr, DWARFSectionKind SectionKind);\n  // For units in DWARF Package File, remember the index entry and update\n  // the abbreviation offset read by extract().\n  bool applyIndexEntry(const DWARFUnitIndex::Entry *Entry);\n  uint64_t getOffset() const { return Offset; }\n  const dwarf::FormParams &getFormParams() const { return FormParams; }\n  uint16_t getVersion() const { return FormParams.Version; }\n  dwarf::DwarfFormat getFormat() const { return FormParams.Format; }\n  uint8_t getAddressByteSize() const { return FormParams.AddrSize; }\n  uint8_t getRefAddrByteSize() const { return FormParams.getRefAddrByteSize(); }\n  uint8_t getDwarfOffsetByteSize() const {\n    return FormParams.getDwarfOffsetByteSize();\n  }\n  uint64_t getLength() const { return Length; }\n  uint64_t getAbbrOffset() const { return AbbrOffset; }\n  Optional<uint64_t> getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t Id) {\n    assert((!DWOId || *DWOId == Id) && \"setting DWOId to a different value\");\n    DWOId = Id;\n  }\n  const DWARFUnitIndex::Entry *getIndexEntry() const { return IndexEntry; }\n  uint64_t getTypeHash() const { return TypeHash; }\n  uint64_t getTypeOffset() const { return TypeOffset; }\n  uint8_t getUnitType() const { return UnitType; }\n  bool isTypeUnit() const {\n    return UnitType == dwarf::DW_UT_type || UnitType == dwarf::DW_UT_split_type;\n  }\n  uint8_t getSize() const { return Size; }\n  uint8_t getUnitLengthFieldByteSize() const {\n    return dwarf::getUnitLengthFieldByteSize(FormParams.Format);\n  }\n  uint64_t getNextUnitOffset() const {\n    return Offset + Length + getUnitLengthFieldByteSize();\n  }\n};\n\nconst DWARFUnitIndex &getDWARFUnitIndex(DWARFContext &Context,\n                                        DWARFSectionKind Kind);\n\nbool isCompileUnit(const std::unique_ptr<DWARFUnit> &U);\n\n/// Describe a collection of units. Intended to hold all units either from\n/// .debug_info and .debug_types, or from .debug_info.dwo and .debug_types.dwo.\nclass DWARFUnitVector final : public SmallVector<std::unique_ptr<DWARFUnit>, 1> {\n  std::function<std::unique_ptr<DWARFUnit>(uint64_t, DWARFSectionKind,\n                                           const DWARFSection *,\n                                           const DWARFUnitIndex::Entry *)>\n      Parser;\n  int NumInfoUnits = -1;\n\npublic:\n  using UnitVector = SmallVectorImpl<std::unique_ptr<DWARFUnit>>;\n  using iterator = typename UnitVector::iterator;\n  using iterator_range = llvm::iterator_range<typename UnitVector::iterator>;\n\n  using compile_unit_range =\n      decltype(make_filter_range(std::declval<iterator_range>(), isCompileUnit));\n\n  DWARFUnit *getUnitForOffset(uint64_t Offset) const;\n  DWARFUnit *getUnitForIndexEntry(const DWARFUnitIndex::Entry &E);\n\n  /// Read units from a .debug_info or .debug_types section.  Calls made\n  /// before finishedInfoUnits() are assumed to be for .debug_info sections,\n  /// calls after finishedInfoUnits() are for .debug_types sections.  Caller\n  /// must not mix calls to addUnitsForSection and addUnitsForDWOSection.\n  void addUnitsForSection(DWARFContext &C, const DWARFSection &Section,\n                          DWARFSectionKind SectionKind);\n  /// Read units from a .debug_info.dwo or .debug_types.dwo section.  Calls\n  /// made before finishedInfoUnits() are assumed to be for .debug_info.dwo\n  /// sections, calls after finishedInfoUnits() are for .debug_types.dwo\n  /// sections.  Caller must not mix calls to addUnitsForSection and\n  /// addUnitsForDWOSection.\n  void addUnitsForDWOSection(DWARFContext &C, const DWARFSection &DWOSection,\n                             DWARFSectionKind SectionKind, bool Lazy = false);\n\n  /// Add an existing DWARFUnit to this UnitVector. This is used by the DWARF\n  /// verifier to process unit separately.\n  DWARFUnit *addUnit(std::unique_ptr<DWARFUnit> Unit);\n\n  /// Returns number of all units held by this instance.\n  unsigned getNumUnits() const { return size(); }\n  /// Returns number of units from all .debug_info[.dwo] sections.\n  unsigned getNumInfoUnits() const {\n    return NumInfoUnits == -1 ? size() : NumInfoUnits;\n  }\n  /// Returns number of units from all .debug_types[.dwo] sections.\n  unsigned getNumTypesUnits() const { return size() - NumInfoUnits; }\n  /// Indicate that parsing .debug_info[.dwo] is done, and remaining units\n  /// will be from .debug_types[.dwo].\n  void finishedInfoUnits() { NumInfoUnits = size(); }\n\nprivate:\n  void addUnitsImpl(DWARFContext &Context, const DWARFObject &Obj,\n                    const DWARFSection &Section, const DWARFDebugAbbrev *DA,\n                    const DWARFSection *RS, const DWARFSection *LocSection,\n                    StringRef SS, const DWARFSection &SOS,\n                    const DWARFSection *AOS, const DWARFSection &LS, bool LE,\n                    bool IsDWO, bool Lazy, DWARFSectionKind SectionKind);\n};\n\n/// Represents base address of the CU.\n/// Represents a unit's contribution to the string offsets table.\nstruct StrOffsetsContributionDescriptor {\n  uint64_t Base = 0;\n  /// The contribution size not including the header.\n  uint64_t Size = 0;\n  /// Format and version.\n  dwarf::FormParams FormParams = {0, 0, dwarf::DwarfFormat::DWARF32};\n\n  StrOffsetsContributionDescriptor(uint64_t Base, uint64_t Size,\n                                   uint8_t Version, dwarf::DwarfFormat Format)\n      : Base(Base), Size(Size), FormParams({Version, 0, Format}) {}\n  StrOffsetsContributionDescriptor() = default;\n\n  uint8_t getVersion() const { return FormParams.Version; }\n  dwarf::DwarfFormat getFormat() const { return FormParams.Format; }\n  uint8_t getDwarfOffsetByteSize() const {\n    return FormParams.getDwarfOffsetByteSize();\n  }\n  /// Determine whether a contribution to the string offsets table is\n  /// consistent with the relevant section size and that its length is\n  /// a multiple of the size of one of its entries.\n  Expected<StrOffsetsContributionDescriptor>\n  validateContributionSize(DWARFDataExtractor &DA);\n};\n\nclass DWARFUnit {\n  DWARFContext &Context;\n  /// Section containing this DWARFUnit.\n  const DWARFSection &InfoSection;\n\n  DWARFUnitHeader Header;\n  const DWARFDebugAbbrev *Abbrev;\n  const DWARFSection *RangeSection;\n  uint64_t RangeSectionBase;\n  uint64_t LocSectionBase;\n\n  /// Location table of this unit.\n  std::unique_ptr<DWARFLocationTable> LocTable;\n\n  const DWARFSection &LineSection;\n  StringRef StringSection;\n  const DWARFSection &StringOffsetSection;\n  const DWARFSection *AddrOffsetSection;\n  Optional<uint64_t> AddrOffsetSectionBase;\n  bool isLittleEndian;\n  bool IsDWO;\n  const DWARFUnitVector &UnitVector;\n\n  /// Start, length, and DWARF format of the unit's contribution to the string\n  /// offsets table (DWARF v5).\n  Optional<StrOffsetsContributionDescriptor> StringOffsetsTableContribution;\n\n  mutable const DWARFAbbreviationDeclarationSet *Abbrevs;\n  llvm::Optional<object::SectionedAddress> BaseAddr;\n  /// The compile unit debug information entry items.\n  std::vector<DWARFDebugInfoEntry> DieArray;\n\n  /// Map from range's start address to end address and corresponding DIE.\n  /// IntervalMap does not support range removal, as a result, we use the\n  /// std::map::upper_bound for address range lookup.\n  std::map<uint64_t, std::pair<uint64_t, DWARFDie>> AddrDieMap;\n\n  using die_iterator_range =\n      iterator_range<std::vector<DWARFDebugInfoEntry>::iterator>;\n\n  std::shared_ptr<DWARFUnit> DWO;\n\n  uint32_t getDIEIndex(const DWARFDebugInfoEntry *Die) {\n    auto First = DieArray.data();\n    assert(Die >= First && Die < First + DieArray.size());\n    return Die - First;\n  }\n\nprotected:\n  const DWARFUnitHeader &getHeader() const { return Header; }\n\n  /// Size in bytes of the parsed unit header.\n  uint32_t getHeaderSize() const { return Header.getSize(); }\n\n  /// Find the unit's contribution to the string offsets table and determine its\n  /// length and form. The given offset is expected to be derived from the unit\n  /// DIE's DW_AT_str_offsets_base attribute.\n  Expected<Optional<StrOffsetsContributionDescriptor>>\n  determineStringOffsetsTableContribution(DWARFDataExtractor &DA);\n\n  /// Find the unit's contribution to the string offsets table and determine its\n  /// length and form. The given offset is expected to be 0 in a dwo file or,\n  /// in a dwp file, the start of the unit's contribution to the string offsets\n  /// table section (as determined by the index table).\n  Expected<Optional<StrOffsetsContributionDescriptor>>\n  determineStringOffsetsTableContributionDWO(DWARFDataExtractor &DA);\n\npublic:\n  DWARFUnit(DWARFContext &Context, const DWARFSection &Section,\n            const DWARFUnitHeader &Header, const DWARFDebugAbbrev *DA,\n            const DWARFSection *RS, const DWARFSection *LocSection,\n            StringRef SS, const DWARFSection &SOS, const DWARFSection *AOS,\n            const DWARFSection &LS, bool LE, bool IsDWO,\n            const DWARFUnitVector &UnitVector);\n\n  virtual ~DWARFUnit();\n\n  bool isDWOUnit() const { return IsDWO; }\n  DWARFContext& getContext() const { return Context; }\n  const DWARFSection &getInfoSection() const { return InfoSection; }\n  uint64_t getOffset() const { return Header.getOffset(); }\n  const dwarf::FormParams &getFormParams() const {\n    return Header.getFormParams();\n  }\n  uint16_t getVersion() const { return Header.getVersion(); }\n  uint8_t getAddressByteSize() const { return Header.getAddressByteSize(); }\n  uint8_t getRefAddrByteSize() const { return Header.getRefAddrByteSize(); }\n  uint8_t getDwarfOffsetByteSize() const {\n    return Header.getDwarfOffsetByteSize();\n  }\n  uint64_t getLength() const { return Header.getLength(); }\n  dwarf::DwarfFormat getFormat() const { return Header.getFormat(); }\n  uint8_t getUnitType() const { return Header.getUnitType(); }\n  bool isTypeUnit() const { return Header.isTypeUnit(); }\n  uint64_t getAbbrOffset() const { return Header.getAbbrOffset(); }\n  uint64_t getNextUnitOffset() const { return Header.getNextUnitOffset(); }\n  const DWARFSection &getLineSection() const { return LineSection; }\n  StringRef getStringSection() const { return StringSection; }\n  const DWARFSection &getStringOffsetSection() const {\n    return StringOffsetSection;\n  }\n\n  void setAddrOffsetSection(const DWARFSection *AOS, uint64_t Base) {\n    AddrOffsetSection = AOS;\n    AddrOffsetSectionBase = Base;\n  }\n\n  Optional<uint64_t> getAddrOffsetSectionBase() const {\n    return AddrOffsetSectionBase;\n  }\n\n  /// Recursively update address to Die map.\n  void updateAddressDieMap(DWARFDie Die);\n\n  void setRangesSection(const DWARFSection *RS, uint64_t Base) {\n    RangeSection = RS;\n    RangeSectionBase = Base;\n  }\n\n  uint64_t getLocSectionBase() const {\n    return LocSectionBase;\n  }\n\n  Optional<object::SectionedAddress>\n  getAddrOffsetSectionItem(uint32_t Index) const;\n  Optional<uint64_t> getStringOffsetSectionItem(uint32_t Index) const;\n\n  DWARFDataExtractor getDebugInfoExtractor() const;\n\n  DataExtractor getStringExtractor() const {\n    return DataExtractor(StringSection, false, 0);\n  }\n\n  const DWARFLocationTable &getLocationTable() { return *LocTable; }\n\n  /// Extract the range list referenced by this compile unit from the\n  /// .debug_ranges section. If the extraction is unsuccessful, an error\n  /// is returned. Successful extraction requires that the compile unit\n  /// has already been extracted.\n  Error extractRangeList(uint64_t RangeListOffset,\n                         DWARFDebugRangeList &RangeList) const;\n  void clear();\n\n  const Optional<StrOffsetsContributionDescriptor> &\n  getStringOffsetsTableContribution() const {\n    return StringOffsetsTableContribution;\n  }\n\n  uint8_t getDwarfStringOffsetsByteSize() const {\n    assert(StringOffsetsTableContribution);\n    return StringOffsetsTableContribution->getDwarfOffsetByteSize();\n  }\n\n  uint64_t getStringOffsetsBase() const {\n    assert(StringOffsetsTableContribution);\n    return StringOffsetsTableContribution->Base;\n  }\n\n  const DWARFAbbreviationDeclarationSet *getAbbreviations() const;\n\n  static bool isMatchingUnitTypeAndTag(uint8_t UnitType, dwarf::Tag Tag) {\n    switch (UnitType) {\n    case dwarf::DW_UT_compile:\n      return Tag == dwarf::DW_TAG_compile_unit;\n    case dwarf::DW_UT_type:\n      return Tag == dwarf::DW_TAG_type_unit;\n    case dwarf::DW_UT_partial:\n      return Tag == dwarf::DW_TAG_partial_unit;\n    case dwarf::DW_UT_skeleton:\n      return Tag == dwarf::DW_TAG_skeleton_unit;\n    case dwarf::DW_UT_split_compile:\n    case dwarf::DW_UT_split_type:\n      return dwarf::isUnitType(Tag);\n    }\n    return false;\n  }\n\n  llvm::Optional<object::SectionedAddress> getBaseAddress();\n\n  DWARFDie getUnitDIE(bool ExtractUnitDIEOnly = true) {\n    extractDIEsIfNeeded(ExtractUnitDIEOnly);\n    if (DieArray.empty())\n      return DWARFDie();\n    return DWARFDie(this, &DieArray[0]);\n  }\n\n  DWARFDie getNonSkeletonUnitDIE(bool ExtractUnitDIEOnly = true) {\n    parseDWO();\n    if (DWO)\n      return DWO->getUnitDIE(ExtractUnitDIEOnly);\n    return getUnitDIE(ExtractUnitDIEOnly);\n  }\n\n  const char *getCompilationDir();\n  Optional<uint64_t> getDWOId() {\n    extractDIEsIfNeeded(/*CUDieOnly*/ true);\n    return getHeader().getDWOId();\n  }\n  void setDWOId(uint64_t NewID) { Header.setDWOId(NewID); }\n\n  /// Return a vector of address ranges resulting from a (possibly encoded)\n  /// range list starting at a given offset in the appropriate ranges section.\n  Expected<DWARFAddressRangesVector> findRnglistFromOffset(uint64_t Offset);\n\n  /// Return a vector of address ranges retrieved from an encoded range\n  /// list whose offset is found via a table lookup given an index (DWARF v5\n  /// and later).\n  Expected<DWARFAddressRangesVector> findRnglistFromIndex(uint32_t Index);\n\n  /// Return a rangelist's offset based on an index. The index designates\n  /// an entry in the rangelist table's offset array and is supplied by\n  /// DW_FORM_rnglistx.\n  Optional<uint64_t> getRnglistOffset(uint32_t Index);\n\n  Optional<uint64_t> getLoclistOffset(uint32_t Index);\n\n  Expected<DWARFAddressRangesVector> collectAddressRanges();\n\n  Expected<DWARFLocationExpressionsVector>\n  findLoclistFromOffset(uint64_t Offset);\n\n  /// Returns subprogram DIE with address range encompassing the provided\n  /// address. The pointer is alive as long as parsed compile unit DIEs are not\n  /// cleared.\n  DWARFDie getSubroutineForAddress(uint64_t Address);\n\n  /// getInlinedChainForAddress - fetches inlined chain for a given address.\n  /// Returns empty chain if there is no subprogram containing address. The\n  /// chain is valid as long as parsed compile unit DIEs are not cleared.\n  void getInlinedChainForAddress(uint64_t Address,\n                                 SmallVectorImpl<DWARFDie> &InlinedChain);\n\n  /// Return the DWARFUnitVector containing this unit.\n  const DWARFUnitVector &getUnitVector() const { return UnitVector; }\n\n  /// Returns the number of DIEs in the unit. Parses the unit\n  /// if necessary.\n  unsigned getNumDIEs() {\n    extractDIEsIfNeeded(false);\n    return DieArray.size();\n  }\n\n  /// Return the index of a DIE inside the unit's DIE vector.\n  ///\n  /// It is illegal to call this method with a DIE that hasn't be\n  /// created by this unit. In other word, it's illegal to call this\n  /// method on a DIE that isn't accessible by following\n  /// children/sibling links starting from this unit's getUnitDIE().\n  uint32_t getDIEIndex(const DWARFDie &D) {\n    return getDIEIndex(D.getDebugInfoEntry());\n  }\n\n  /// Return the DIE object at the given index.\n  DWARFDie getDIEAtIndex(unsigned Index) {\n    assert(Index < DieArray.size());\n    return DWARFDie(this, &DieArray[Index]);\n  }\n\n  DWARFDie getParent(const DWARFDebugInfoEntry *Die);\n  DWARFDie getSibling(const DWARFDebugInfoEntry *Die);\n  DWARFDie getPreviousSibling(const DWARFDebugInfoEntry *Die);\n  DWARFDie getFirstChild(const DWARFDebugInfoEntry *Die);\n  DWARFDie getLastChild(const DWARFDebugInfoEntry *Die);\n\n  /// Return the DIE object for a given offset inside the\n  /// unit's DIE vector.\n  ///\n  /// The unit needs to have its DIEs extracted for this method to work.\n  DWARFDie getDIEForOffset(uint64_t Offset) {\n    extractDIEsIfNeeded(false);\n    auto It =\n        llvm::partition_point(DieArray, [=](const DWARFDebugInfoEntry &DIE) {\n          return DIE.getOffset() < Offset;\n        });\n    if (It != DieArray.end() && It->getOffset() == Offset)\n      return DWARFDie(this, &*It);\n    return DWARFDie();\n  }\n\n  uint32_t getLineTableOffset() const {\n    if (auto IndexEntry = Header.getIndexEntry())\n      if (const auto *Contrib = IndexEntry->getContribution(DW_SECT_LINE))\n        return Contrib->Offset;\n    return 0;\n  }\n\n  die_iterator_range dies() {\n    extractDIEsIfNeeded(false);\n    return die_iterator_range(DieArray.begin(), DieArray.end());\n  }\n\n  virtual void dump(raw_ostream &OS, DIDumpOptions DumpOpts) = 0;\n\n  Error tryExtractDIEsIfNeeded(bool CUDieOnly);\n\nprivate:\n  /// Size in bytes of the .debug_info data associated with this compile unit.\n  size_t getDebugInfoSize() const {\n    return Header.getLength() + Header.getUnitLengthFieldByteSize() -\n           getHeaderSize();\n  }\n\n  /// extractDIEsIfNeeded - Parses a compile unit and indexes its DIEs if it\n  /// hasn't already been done\n  void extractDIEsIfNeeded(bool CUDieOnly);\n\n  /// extractDIEsToVector - Appends all parsed DIEs to a vector.\n  void extractDIEsToVector(bool AppendCUDie, bool AppendNonCUDIEs,\n                           std::vector<DWARFDebugInfoEntry> &DIEs) const;\n\n  /// clearDIEs - Clear parsed DIEs to keep memory usage low.\n  void clearDIEs(bool KeepCUDie);\n\n  /// parseDWO - Parses .dwo file for current compile unit. Returns true if\n  /// it was actually constructed.\n  bool parseDWO();\n};\n\ninline bool isCompileUnit(const std::unique_ptr<DWARFUnit> &U) {\n  return !U->isTypeUnit();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFUNIT_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h", "content": "//===- DWARFUnitIndex.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_DWARF_DWARFUNITINDEX_H\n#define LLVM_DEBUGINFO_DWARF_DWARFUNITINDEX_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n/// The enum of section identifiers to be used in internal interfaces.\n///\n/// Pre-standard implementation of package files defined a number of section\n/// identifiers with values that clash definitions in the DWARFv5 standard.\n/// See https://gcc.gnu.org/wiki/DebugFissionDWP and Section 7.3.5.3 in DWARFv5.\n///\n/// The following identifiers are the same in the proposal and in DWARFv5:\n/// - DW_SECT_INFO         = 1 (.debug_info.dwo)\n/// - DW_SECT_ABBREV       = 3 (.debug_abbrev.dwo)\n/// - DW_SECT_LINE         = 4 (.debug_line.dwo)\n/// - DW_SECT_STR_OFFSETS  = 6 (.debug_str_offsets.dwo)\n///\n/// The following identifiers are defined only in DWARFv5:\n/// - DW_SECT_LOCLISTS     = 5 (.debug_loclists.dwo)\n/// - DW_SECT_RNGLISTS     = 8 (.debug_rnglists.dwo)\n///\n/// The following identifiers are defined only in the GNU proposal:\n/// - DW_SECT_TYPES        = 2 (.debug_types.dwo)\n/// - DW_SECT_LOC          = 5 (.debug_loc.dwo)\n/// - DW_SECT_MACINFO      = 7 (.debug_macinfo.dwo)\n///\n/// DW_SECT_MACRO for the .debug_macro.dwo section is defined in both standards,\n/// but with different values, 8 in GNU and 7 in DWARFv5.\n///\n/// This enum defines constants to represent the identifiers of both sets.\n/// For DWARFv5 ones, the values are the same as defined in the standard.\n/// For pre-standard ones that correspond to sections being deprecated in\n/// DWARFv5, the values are chosen arbitrary and a tag \"_EXT_\" is added to\n/// the names.\n///\n/// The enum is for internal use only. The user should not expect the values\n/// to correspond to any input/output constants. Special conversion functions,\n/// serializeSectionKind() and deserializeSectionKind(), should be used for\n/// the translation.\nenum DWARFSectionKind {\n  /// Denotes a value read from an index section that does not correspond\n  /// to any of the supported standards.\n  DW_SECT_EXT_unknown = 0,\n#define HANDLE_DW_SECT(ID, NAME) DW_SECT_##NAME = ID,\n#include \"llvm/BinaryFormat/Dwarf.def\"\n  DW_SECT_EXT_TYPES = 2,\n  DW_SECT_EXT_LOC = 9,\n  DW_SECT_EXT_MACINFO = 10,\n};\n\n/// Convert the internal value for a section kind to an on-disk value.\n///\n/// The conversion depends on the version of the index section.\n/// IndexVersion is expected to be either 2 for pre-standard GNU proposal\n/// or 5 for DWARFv5 package file.\nuint32_t serializeSectionKind(DWARFSectionKind Kind, unsigned IndexVersion);\n\n/// Convert a value read from an index section to the internal representation.\n///\n/// The conversion depends on the index section version, which is expected\n/// to be either 2 for pre-standard GNU proposal or 5 for DWARFv5 package file.\nDWARFSectionKind deserializeSectionKind(uint32_t Value, unsigned IndexVersion);\n\nclass DWARFUnitIndex {\n  struct Header {\n    uint32_t Version;\n    uint32_t NumColumns;\n    uint32_t NumUnits;\n    uint32_t NumBuckets = 0;\n\n    bool parse(DataExtractor IndexData, uint64_t *OffsetPtr);\n    void dump(raw_ostream &OS) const;\n  };\n\npublic:\n  class Entry {\n  public:\n    struct SectionContribution {\n      uint32_t Offset;\n      uint32_t Length;\n    };\n\n  private:\n    const DWARFUnitIndex *Index;\n    uint64_t Signature;\n    std::unique_ptr<SectionContribution[]> Contributions;\n    friend class DWARFUnitIndex;\n\n  public:\n    const SectionContribution *getContribution(DWARFSectionKind Sec) const;\n    const SectionContribution *getContribution() const;\n\n    const SectionContribution *getContributions() const {\n      return Contributions.get();\n    }\n\n    uint64_t getSignature() const { return Signature; }\n  };\n\nprivate:\n  struct Header Header;\n\n  DWARFSectionKind InfoColumnKind;\n  int InfoColumn = -1;\n  std::unique_ptr<DWARFSectionKind[]> ColumnKinds;\n  // This is a parallel array of section identifiers as they read from the input\n  // file. The mapping from raw values to DWARFSectionKind is not revertable in\n  // case of unknown identifiers, so we keep them here.\n  std::unique_ptr<uint32_t[]> RawSectionIds;\n  std::unique_ptr<Entry[]> Rows;\n  mutable std::vector<Entry *> OffsetLookup;\n\n  static StringRef getColumnHeader(DWARFSectionKind DS);\n\n  bool parseImpl(DataExtractor IndexData);\n\npublic:\n  DWARFUnitIndex(DWARFSectionKind InfoColumnKind)\n      : InfoColumnKind(InfoColumnKind) {}\n\n  explicit operator bool() const { return Header.NumBuckets; }\n\n  bool parse(DataExtractor IndexData);\n  void dump(raw_ostream &OS) const;\n\n  uint32_t getVersion() const { return Header.Version; }\n\n  const Entry *getFromOffset(uint32_t Offset) const;\n  const Entry *getFromHash(uint64_t Offset) const;\n\n  ArrayRef<DWARFSectionKind> getColumnKinds() const {\n    return makeArrayRef(ColumnKinds.get(), Header.NumColumns);\n  }\n\n  ArrayRef<Entry> getRows() const {\n    return makeArrayRef(Rows.get(), Header.NumBuckets);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_DWARF_DWARFUNITINDEX_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "content": "//===- MCExpr.h - Assembly Level Expressions --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCEXPR_H\n#define LLVM_MC_MCEXPR_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass MCAsmInfo;\nclass MCAsmLayout;\nclass MCAssembler;\nclass MCContext;\nclass MCFixup;\nclass MCFragment;\nclass MCSection;\nclass MCStreamer;\nclass MCSymbol;\nclass MCValue;\nclass raw_ostream;\nclass StringRef;\n\nusing SectionAddrMap = DenseMap<const MCSection *, uint64_t>;\n\n/// Base class for the full range of assembler expressions which are\n/// needed for parsing.\nclass MCExpr {\npublic:\n  enum ExprKind : uint8_t {\n    Binary,    ///< Binary expressions.\n    Constant,  ///< Constant expressions.\n    SymbolRef, ///< References to labels and assigned expressions.\n    Unary,     ///< Unary expressions.\n    Target     ///< Target specific expression.\n  };\n\nprivate:\n  static const unsigned NumSubclassDataBits = 24;\n  static_assert(\n      NumSubclassDataBits == CHAR_BIT * (sizeof(unsigned) - sizeof(ExprKind)),\n      \"ExprKind and SubclassData together should take up one word\");\n\n  ExprKind Kind;\n  /// Field reserved for use by MCExpr subclasses.\n  unsigned SubclassData : NumSubclassDataBits;\n  SMLoc Loc;\n\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler *Asm,\n                          const MCAsmLayout *Layout,\n                          const SectionAddrMap *Addrs, bool InSet) const;\n\nprotected:\n  explicit MCExpr(ExprKind Kind, SMLoc Loc, unsigned SubclassData = 0)\n      : Kind(Kind), SubclassData(SubclassData), Loc(Loc) {\n    assert(SubclassData < (1 << NumSubclassDataBits) &&\n           \"Subclass data too large\");\n  }\n\n  bool evaluateAsRelocatableImpl(MCValue &Res, const MCAssembler *Asm,\n                                 const MCAsmLayout *Layout,\n                                 const MCFixup *Fixup,\n                                 const SectionAddrMap *Addrs, bool InSet) const;\n\n  unsigned getSubclassData() const { return SubclassData; }\n\npublic:\n  MCExpr(const MCExpr &) = delete;\n  MCExpr &operator=(const MCExpr &) = delete;\n\n  /// \\name Accessors\n  /// @{\n\n  ExprKind getKind() const { return Kind; }\n  SMLoc getLoc() const { return Loc; }\n\n  /// @}\n  /// \\name Utility Methods\n  /// @{\n\n  void print(raw_ostream &OS, const MCAsmInfo *MAI,\n             bool InParens = false) const;\n  void dump() const;\n\n  /// @}\n  /// \\name Expression Evaluation\n  /// @{\n\n  /// Try to evaluate the expression to an absolute value.\n  ///\n  /// \\param Res - The absolute value, if evaluation succeeds.\n  /// \\param Layout - The assembler layout object to use for evaluating symbol\n  /// values. If not given, then only non-symbolic expressions will be\n  /// evaluated.\n  /// \\return - True on success.\n  bool evaluateAsAbsolute(int64_t &Res, const MCAsmLayout &Layout,\n                          const SectionAddrMap &Addrs) const;\n  bool evaluateAsAbsolute(int64_t &Res) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler &Asm) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAssembler *Asm) const;\n  bool evaluateAsAbsolute(int64_t &Res, const MCAsmLayout &Layout) const;\n\n  bool evaluateKnownAbsolute(int64_t &Res, const MCAsmLayout &Layout) const;\n\n  /// Try to evaluate the expression to a relocatable value, i.e. an\n  /// expression of the fixed form (a - b + constant).\n  ///\n  /// \\param Res - The relocatable value, if evaluation succeeds.\n  /// \\param Layout - The assembler layout object to use for evaluating values.\n  /// \\param Fixup - The Fixup object if available.\n  /// \\return - True on success.\n  bool evaluateAsRelocatable(MCValue &Res, const MCAsmLayout *Layout,\n                             const MCFixup *Fixup) const;\n\n  /// Try to evaluate the expression to the form (a - b + constant) where\n  /// neither a nor b are variables.\n  ///\n  /// This is a more aggressive variant of evaluateAsRelocatable. The intended\n  /// use is for when relocations are not available, like the .size directive.\n  bool evaluateAsValue(MCValue &Res, const MCAsmLayout &Layout) const;\n\n  /// Find the \"associated section\" for this expression, which is\n  /// currently defined as the absolute section for constants, or\n  /// otherwise the section associated with the first defined symbol in the\n  /// expression.\n  MCFragment *findAssociatedFragment() const;\n\n  /// @}\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const MCExpr &E) {\n  E.print(OS, nullptr);\n  return OS;\n}\n\n////  Represent a constant integer expression.\nclass MCConstantExpr : public MCExpr {\n  int64_t Value;\n\n  // Subclass data stores SizeInBytes in bits 0..7 and PrintInHex in bit 8.\n  static const unsigned SizeInBytesBits = 8;\n  static const unsigned SizeInBytesMask = (1 << SizeInBytesBits) - 1;\n  static const unsigned PrintInHexBit = 1 << SizeInBytesBits;\n\n  static unsigned encodeSubclassData(bool PrintInHex, unsigned SizeInBytes) {\n    assert(SizeInBytes <= sizeof(int64_t) && \"Excessive size\");\n    return SizeInBytes | (PrintInHex ? PrintInHexBit : 0);\n  }\n\n  MCConstantExpr(int64_t Value, bool PrintInHex, unsigned SizeInBytes)\n      : MCExpr(MCExpr::Constant, SMLoc(),\n               encodeSubclassData(PrintInHex, SizeInBytes)), Value(Value) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCConstantExpr *create(int64_t Value, MCContext &Ctx,\n                                      bool PrintInHex = false,\n                                      unsigned SizeInBytes = 0);\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  int64_t getValue() const { return Value; }\n  unsigned getSizeInBytes() const {\n    return getSubclassData() & SizeInBytesMask;\n  }\n\n  bool useHexFormat() const { return (getSubclassData() & PrintInHexBit) != 0; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Constant;\n  }\n};\n\n///  Represent a reference to a symbol from inside an expression.\n///\n/// A symbol reference in an expression may be a use of a label, a use of an\n/// assembler variable (defined constant), or constitute an implicit definition\n/// of the symbol as external.\nclass MCSymbolRefExpr : public MCExpr {\npublic:\n  enum VariantKind : uint16_t {\n    VK_None,\n    VK_Invalid,\n\n    VK_GOT,\n    VK_GOTOFF,\n    VK_GOTREL,\n    VK_PCREL,\n    VK_GOTPCREL,\n    VK_GOTTPOFF,\n    VK_INDNTPOFF,\n    VK_NTPOFF,\n    VK_GOTNTPOFF,\n    VK_PLT,\n    VK_TLSGD,\n    VK_TLSLD,\n    VK_TLSLDM,\n    VK_TPOFF,\n    VK_DTPOFF,\n    VK_TLSCALL, // symbol(tlscall)\n    VK_TLSDESC, // symbol(tlsdesc)\n    VK_TLVP,    // Mach-O thread local variable relocations\n    VK_TLVPPAGE,\n    VK_TLVPPAGEOFF,\n    VK_PAGE,\n    VK_PAGEOFF,\n    VK_GOTPAGE,\n    VK_GOTPAGEOFF,\n    VK_SECREL,\n    VK_SIZE,    // symbol@SIZE\n    VK_WEAKREF, // The link between the symbols in .weakref foo, bar\n\n    VK_X86_ABS8,\n    VK_X86_PLTOFF,\n\n    VK_ARM_NONE,\n    VK_ARM_GOT_PREL,\n    VK_ARM_TARGET1,\n    VK_ARM_TARGET2,\n    VK_ARM_PREL31,\n    VK_ARM_SBREL,  // symbol(sbrel)\n    VK_ARM_TLSLDO, // symbol(tlsldo)\n    VK_ARM_TLSDESCSEQ,\n\n    VK_AVR_NONE,\n    VK_AVR_LO8,\n    VK_AVR_HI8,\n    VK_AVR_HLO8,\n    VK_AVR_DIFF8,\n    VK_AVR_DIFF16,\n    VK_AVR_DIFF32,\n    VK_AVR_PM,\n\n    VK_PPC_LO,              // symbol@l\n    VK_PPC_HI,              // symbol@h\n    VK_PPC_HA,              // symbol@ha\n    VK_PPC_HIGH,            // symbol@high\n    VK_PPC_HIGHA,           // symbol@higha\n    VK_PPC_HIGHER,          // symbol@higher\n    VK_PPC_HIGHERA,         // symbol@highera\n    VK_PPC_HIGHEST,         // symbol@highest\n    VK_PPC_HIGHESTA,        // symbol@highesta\n    VK_PPC_GOT_LO,          // symbol@got@l\n    VK_PPC_GOT_HI,          // symbol@got@h\n    VK_PPC_GOT_HA,          // symbol@got@ha\n    VK_PPC_TOCBASE,         // symbol@tocbase\n    VK_PPC_TOC,             // symbol@toc\n    VK_PPC_TOC_LO,          // symbol@toc@l\n    VK_PPC_TOC_HI,          // symbol@toc@h\n    VK_PPC_TOC_HA,          // symbol@toc@ha\n    VK_PPC_U,               // symbol@u\n    VK_PPC_L,               // symbol@l\n    VK_PPC_DTPMOD,          // symbol@dtpmod\n    VK_PPC_TPREL_LO,        // symbol@tprel@l\n    VK_PPC_TPREL_HI,        // symbol@tprel@h\n    VK_PPC_TPREL_HA,        // symbol@tprel@ha\n    VK_PPC_TPREL_HIGH,      // symbol@tprel@high\n    VK_PPC_TPREL_HIGHA,     // symbol@tprel@higha\n    VK_PPC_TPREL_HIGHER,    // symbol@tprel@higher\n    VK_PPC_TPREL_HIGHERA,   // symbol@tprel@highera\n    VK_PPC_TPREL_HIGHEST,   // symbol@tprel@highest\n    VK_PPC_TPREL_HIGHESTA,  // symbol@tprel@highesta\n    VK_PPC_DTPREL_LO,       // symbol@dtprel@l\n    VK_PPC_DTPREL_HI,       // symbol@dtprel@h\n    VK_PPC_DTPREL_HA,       // symbol@dtprel@ha\n    VK_PPC_DTPREL_HIGH,     // symbol@dtprel@high\n    VK_PPC_DTPREL_HIGHA,    // symbol@dtprel@higha\n    VK_PPC_DTPREL_HIGHER,   // symbol@dtprel@higher\n    VK_PPC_DTPREL_HIGHERA,  // symbol@dtprel@highera\n    VK_PPC_DTPREL_HIGHEST,  // symbol@dtprel@highest\n    VK_PPC_DTPREL_HIGHESTA, // symbol@dtprel@highesta\n    VK_PPC_GOT_TPREL,       // symbol@got@tprel\n    VK_PPC_GOT_TPREL_LO,    // symbol@got@tprel@l\n    VK_PPC_GOT_TPREL_HI,    // symbol@got@tprel@h\n    VK_PPC_GOT_TPREL_HA,    // symbol@got@tprel@ha\n    VK_PPC_GOT_DTPREL,      // symbol@got@dtprel\n    VK_PPC_GOT_DTPREL_LO,   // symbol@got@dtprel@l\n    VK_PPC_GOT_DTPREL_HI,   // symbol@got@dtprel@h\n    VK_PPC_GOT_DTPREL_HA,   // symbol@got@dtprel@ha\n    VK_PPC_TLS,             // symbol@tls\n    VK_PPC_GOT_TLSGD,       // symbol@got@tlsgd\n    VK_PPC_GOT_TLSGD_LO,    // symbol@got@tlsgd@l\n    VK_PPC_GOT_TLSGD_HI,    // symbol@got@tlsgd@h\n    VK_PPC_GOT_TLSGD_HA,    // symbol@got@tlsgd@ha\n    VK_PPC_TLSGD,           // symbol@tlsgd\n    VK_PPC_GOT_TLSLD,       // symbol@got@tlsld\n    VK_PPC_GOT_TLSLD_LO,    // symbol@got@tlsld@l\n    VK_PPC_GOT_TLSLD_HI,    // symbol@got@tlsld@h\n    VK_PPC_GOT_TLSLD_HA,    // symbol@got@tlsld@ha\n    VK_PPC_GOT_PCREL,       // symbol@got@pcrel\n    VK_PPC_GOT_TLSGD_PCREL, // symbol@got@tlsgd@pcrel\n    VK_PPC_GOT_TLSLD_PCREL, // symbol@got@tlsld@pcrel\n    VK_PPC_GOT_TPREL_PCREL, // symbol@got@tprel@pcrel\n    VK_PPC_TLS_PCREL,       // symbol@tls@pcrel\n    VK_PPC_TLSLD,           // symbol@tlsld\n    VK_PPC_LOCAL,           // symbol@local\n    VK_PPC_NOTOC,           // symbol@notoc\n    VK_PPC_PCREL_OPT,       // .reloc expr, R_PPC64_PCREL_OPT, expr\n\n    VK_COFF_IMGREL32, // symbol@imgrel (image-relative)\n\n    VK_Hexagon_LO16,\n    VK_Hexagon_HI16,\n    VK_Hexagon_GPREL,\n    VK_Hexagon_GD_GOT,\n    VK_Hexagon_LD_GOT,\n    VK_Hexagon_GD_PLT,\n    VK_Hexagon_LD_PLT,\n    VK_Hexagon_IE,\n    VK_Hexagon_IE_GOT,\n\n    VK_WASM_TYPEINDEX, // Reference to a symbol's type (signature)\n    VK_WASM_TLSREL,    // Memory address relative to __tls_base\n    VK_WASM_MBREL,     // Memory address relative to __memory_base\n    VK_WASM_TBREL,     // Table index relative to __table_base\n\n    VK_AMDGPU_GOTPCREL32_LO, // symbol@gotpcrel32@lo\n    VK_AMDGPU_GOTPCREL32_HI, // symbol@gotpcrel32@hi\n    VK_AMDGPU_REL32_LO,      // symbol@rel32@lo\n    VK_AMDGPU_REL32_HI,      // symbol@rel32@hi\n    VK_AMDGPU_REL64,         // symbol@rel64\n    VK_AMDGPU_ABS32_LO,      // symbol@abs32@lo\n    VK_AMDGPU_ABS32_HI,      // symbol@abs32@hi\n\n    VK_VE_HI32,        // symbol@hi\n    VK_VE_LO32,        // symbol@lo\n    VK_VE_PC_HI32,     // symbol@pc_hi\n    VK_VE_PC_LO32,     // symbol@pc_lo\n    VK_VE_GOT_HI32,    // symbol@got_hi\n    VK_VE_GOT_LO32,    // symbol@got_lo\n    VK_VE_GOTOFF_HI32, // symbol@gotoff_hi\n    VK_VE_GOTOFF_LO32, // symbol@gotoff_lo\n    VK_VE_PLT_HI32,    // symbol@plt_hi\n    VK_VE_PLT_LO32,    // symbol@plt_lo\n    VK_VE_TLS_GD_HI32, // symbol@tls_gd_hi\n    VK_VE_TLS_GD_LO32, // symbol@tls_gd_lo\n    VK_VE_TPOFF_HI32,  // symbol@tpoff_hi\n    VK_VE_TPOFF_LO32,  // symbol@tpoff_lo\n\n    VK_TPREL,\n    VK_DTPREL\n  };\n\nprivate:\n  /// The symbol being referenced.\n  const MCSymbol *Symbol;\n\n  // Subclass data stores VariantKind in bits 0..15 and HasSubsectionsViaSymbols\n  // in bit 16.\n  static const unsigned VariantKindBits = 16;\n  static const unsigned VariantKindMask = (1 << VariantKindBits) - 1;\n\n  // FIXME: Remove this bit.\n  static const unsigned HasSubsectionsViaSymbolsBit = 1 << VariantKindBits;\n\n  static unsigned encodeSubclassData(VariantKind Kind,\n                                     bool HasSubsectionsViaSymbols) {\n    return (unsigned)Kind |\n           (HasSubsectionsViaSymbols ? HasSubsectionsViaSymbolsBit : 0);\n  }\n\n  explicit MCSymbolRefExpr(const MCSymbol *Symbol, VariantKind Kind,\n                           const MCAsmInfo *MAI, SMLoc Loc = SMLoc());\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCSymbolRefExpr *create(const MCSymbol *Symbol, MCContext &Ctx) {\n    return MCSymbolRefExpr::create(Symbol, VK_None, Ctx);\n  }\n\n  static const MCSymbolRefExpr *create(const MCSymbol *Symbol, VariantKind Kind,\n                                       MCContext &Ctx, SMLoc Loc = SMLoc());\n  static const MCSymbolRefExpr *create(StringRef Name, VariantKind Kind,\n                                       MCContext &Ctx);\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  const MCSymbol &getSymbol() const { return *Symbol; }\n\n  VariantKind getKind() const {\n    return (VariantKind)(getSubclassData() & VariantKindMask);\n  }\n\n  bool hasSubsectionsViaSymbols() const {\n    return (getSubclassData() & HasSubsectionsViaSymbolsBit) != 0;\n  }\n\n  /// @}\n  /// \\name Static Utility Functions\n  /// @{\n\n  static StringRef getVariantKindName(VariantKind Kind);\n\n  static VariantKind getVariantKindForName(StringRef Name);\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::SymbolRef;\n  }\n};\n\n/// Unary assembler expressions.\nclass MCUnaryExpr : public MCExpr {\npublic:\n  enum Opcode {\n    LNot,  ///< Logical negation.\n    Minus, ///< Unary minus.\n    Not,   ///< Bitwise negation.\n    Plus   ///< Unary plus.\n  };\n\nprivate:\n  const MCExpr *Expr;\n\n  MCUnaryExpr(Opcode Op, const MCExpr *Expr, SMLoc Loc)\n      : MCExpr(MCExpr::Unary, Loc, Op), Expr(Expr) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCUnaryExpr *create(Opcode Op, const MCExpr *Expr,\n                                   MCContext &Ctx, SMLoc Loc = SMLoc());\n\n  static const MCUnaryExpr *createLNot(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(LNot, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createMinus(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Minus, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createNot(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Not, Expr, Ctx, Loc);\n  }\n\n  static const MCUnaryExpr *createPlus(const MCExpr *Expr, MCContext &Ctx, SMLoc Loc = SMLoc()) {\n    return create(Plus, Expr, Ctx, Loc);\n  }\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  /// Get the kind of this unary expression.\n  Opcode getOpcode() const { return (Opcode)getSubclassData(); }\n\n  /// Get the child of this unary expression.\n  const MCExpr *getSubExpr() const { return Expr; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Unary;\n  }\n};\n\n/// Binary assembler expressions.\nclass MCBinaryExpr : public MCExpr {\npublic:\n  enum Opcode {\n    Add,  ///< Addition.\n    And,  ///< Bitwise and.\n    Div,  ///< Signed division.\n    EQ,   ///< Equality comparison.\n    GT,   ///< Signed greater than comparison (result is either 0 or some\n          ///< target-specific non-zero value)\n    GTE,  ///< Signed greater than or equal comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    LAnd, ///< Logical and.\n    LOr,  ///< Logical or.\n    LT,   ///< Signed less than comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    LTE,  ///< Signed less than or equal comparison (result is either 0 or\n          ///< some target-specific non-zero value).\n    Mod,  ///< Signed remainder.\n    Mul,  ///< Multiplication.\n    NE,   ///< Inequality comparison.\n    Or,   ///< Bitwise or.\n    OrNot, ///< Bitwise or not.\n    Shl,  ///< Shift left.\n    AShr, ///< Arithmetic shift right.\n    LShr, ///< Logical shift right.\n    Sub,  ///< Subtraction.\n    Xor   ///< Bitwise exclusive or.\n  };\n\nprivate:\n  const MCExpr *LHS, *RHS;\n\n  MCBinaryExpr(Opcode Op, const MCExpr *LHS, const MCExpr *RHS,\n               SMLoc Loc = SMLoc())\n      : MCExpr(MCExpr::Binary, Loc, Op), LHS(LHS), RHS(RHS) {}\n\npublic:\n  /// \\name Construction\n  /// @{\n\n  static const MCBinaryExpr *create(Opcode Op, const MCExpr *LHS,\n                                    const MCExpr *RHS, MCContext &Ctx,\n                                    SMLoc Loc = SMLoc());\n\n  static const MCBinaryExpr *createAdd(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Add, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createAnd(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(And, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createDiv(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Div, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createEQ(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(EQ, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createGT(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(GT, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createGTE(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(GTE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLAnd(const MCExpr *LHS, const MCExpr *RHS,\n                                        MCContext &Ctx) {\n    return create(LAnd, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLOr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LOr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLT(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(LT, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLTE(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LTE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createMod(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Mod, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createMul(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Mul, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createNE(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(NE, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createOr(const MCExpr *LHS, const MCExpr *RHS,\n                                      MCContext &Ctx) {\n    return create(Or, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createShl(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Shl, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createAShr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(AShr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createLShr(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(LShr, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createSub(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Sub, LHS, RHS, Ctx);\n  }\n\n  static const MCBinaryExpr *createXor(const MCExpr *LHS, const MCExpr *RHS,\n                                       MCContext &Ctx) {\n    return create(Xor, LHS, RHS, Ctx);\n  }\n\n  /// @}\n  /// \\name Accessors\n  /// @{\n\n  /// Get the kind of this binary expression.\n  Opcode getOpcode() const { return (Opcode)getSubclassData(); }\n\n  /// Get the left-hand side expression of the binary operator.\n  const MCExpr *getLHS() const { return LHS; }\n\n  /// Get the right-hand side expression of the binary operator.\n  const MCExpr *getRHS() const { return RHS; }\n\n  /// @}\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Binary;\n  }\n};\n\n/// This is an extension point for target-specific MCExpr subclasses to\n/// implement.\n///\n/// NOTE: All subclasses are required to have trivial destructors because\n/// MCExprs are bump pointer allocated and not destructed.\nclass MCTargetExpr : public MCExpr {\n  virtual void anchor();\n\nprotected:\n  MCTargetExpr() : MCExpr(Target, SMLoc()) {}\n  virtual ~MCTargetExpr() = default;\n\npublic:\n  virtual void printImpl(raw_ostream &OS, const MCAsmInfo *MAI) const = 0;\n  virtual bool evaluateAsRelocatableImpl(MCValue &Res,\n                                         const MCAsmLayout *Layout,\n                                         const MCFixup *Fixup) const = 0;\n  // allow Target Expressions to be checked for equality\n  virtual bool isEqualTo(const MCExpr *x) const { return false; }\n  // This should be set when assigned expressions are not valid \".set\"\n  // expressions, e.g. registers, and must be inlined.\n  virtual bool inlineAssignedExpr() const { return false; }\n  virtual void visitUsedExpr(MCStreamer& Streamer) const = 0;\n  virtual MCFragment *findAssociatedFragment() const = 0;\n\n  virtual void fixELFSymbolsInTLSFixups(MCAssembler &) const = 0;\n\n  static bool classof(const MCExpr *E) {\n    return E->getKind() == MCExpr::Target;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCEXPR_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "content": "//===- MCFragment.h - Fragment type hierarchy -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCFRAGMENT_H\n#define LLVM_MC_MCFRAGMENT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/MC/MCFixup.h\"\n#include \"llvm/MC/MCInst.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\nclass MCSection;\nclass MCSubtargetInfo;\nclass MCSymbol;\n\nclass MCFragment : public ilist_node_with_parent<MCFragment, MCSection> {\n  friend class MCAsmLayout;\n\npublic:\n  enum FragmentType : uint8_t {\n    FT_Align,\n    FT_Data,\n    FT_CompactEncodedInst,\n    FT_Fill,\n    FT_Nops,\n    FT_Relaxable,\n    FT_Org,\n    FT_Dwarf,\n    FT_DwarfFrame,\n    FT_LEB,\n    FT_BoundaryAlign,\n    FT_SymbolId,\n    FT_CVInlineLines,\n    FT_CVDefRange,\n    FT_PseudoProbe,\n    FT_Dummy\n  };\n\nprivate:\n  /// The data for the section this fragment is in.\n  MCSection *Parent;\n\n  /// The atom this fragment is in, as represented by its defining symbol.\n  const MCSymbol *Atom;\n\n  /// The offset of this fragment in its section. This is ~0 until\n  /// initialized.\n  uint64_t Offset;\n\n  /// The layout order of this fragment.\n  unsigned LayoutOrder;\n\n  /// The subsection this fragment belongs to. This is 0 if the fragment is not\n  // in any subsection.\n  unsigned SubsectionNumber = 0;\n\n  FragmentType Kind;\n\n  /// Whether fragment is being laid out.\n  bool IsBeingLaidOut;\n\nprotected:\n  bool HasInstructions;\n\n  MCFragment(FragmentType Kind, bool HasInstructions,\n             MCSection *Parent = nullptr);\n\npublic:\n  MCFragment() = delete;\n  MCFragment(const MCFragment &) = delete;\n  MCFragment &operator=(const MCFragment &) = delete;\n\n  /// Destroys the current fragment.\n  ///\n  /// This must be used instead of delete as MCFragment is non-virtual.\n  /// This method will dispatch to the appropriate subclass.\n  void destroy();\n\n  FragmentType getKind() const { return Kind; }\n\n  MCSection *getParent() const { return Parent; }\n  void setParent(MCSection *Value) { Parent = Value; }\n\n  const MCSymbol *getAtom() const { return Atom; }\n  void setAtom(const MCSymbol *Value) { Atom = Value; }\n\n  unsigned getLayoutOrder() const { return LayoutOrder; }\n  void setLayoutOrder(unsigned Value) { LayoutOrder = Value; }\n\n  /// Does this fragment have instructions emitted into it? By default\n  /// this is false, but specific fragment types may set it to true.\n  bool hasInstructions() const { return HasInstructions; }\n\n  void dump() const;\n\n  void setSubsectionNumber(unsigned Value) { SubsectionNumber = Value; }\n  unsigned getSubsectionNumber() const { return SubsectionNumber; }\n};\n\nclass MCDummyFragment : public MCFragment {\npublic:\n  explicit MCDummyFragment(MCSection *Sec) : MCFragment(FT_Dummy, false, Sec) {}\n\n  static bool classof(const MCFragment *F) { return F->getKind() == FT_Dummy; }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data.\n///\nclass MCEncodedFragment : public MCFragment {\n  /// Should this fragment be aligned to the end of a bundle?\n  bool AlignToBundleEnd = false;\n\n  uint8_t BundlePadding = 0;\n\nprotected:\n  MCEncodedFragment(MCFragment::FragmentType FType, bool HasInstructions,\n                    MCSection *Sec)\n      : MCFragment(FType, HasInstructions, Sec) {}\n\n  /// The MCSubtargetInfo in effect when the instruction was encoded.\n  /// It must be non-null for instructions.\n  const MCSubtargetInfo *STI = nullptr;\n\npublic:\n  static bool classof(const MCFragment *F) {\n    MCFragment::FragmentType Kind = F->getKind();\n    switch (Kind) {\n    default:\n      return false;\n    case MCFragment::FT_Relaxable:\n    case MCFragment::FT_CompactEncodedInst:\n    case MCFragment::FT_Data:\n    case MCFragment::FT_Dwarf:\n    case MCFragment::FT_DwarfFrame:\n    case MCFragment::FT_PseudoProbe:\n      return true;\n    }\n  }\n\n  /// Should this fragment be placed at the end of an aligned bundle?\n  bool alignToBundleEnd() const { return AlignToBundleEnd; }\n  void setAlignToBundleEnd(bool V) { AlignToBundleEnd = V; }\n\n  /// Get the padding size that must be inserted before this fragment.\n  /// Used for bundling. By default, no padding is inserted.\n  /// Note that padding size is restricted to 8 bits. This is an optimization\n  /// to reduce the amount of space used for each fragment. In practice, larger\n  /// padding should never be required.\n  uint8_t getBundlePadding() const { return BundlePadding; }\n\n  /// Set the padding size for this fragment. By default it's a no-op,\n  /// and only some fragments have a meaningful implementation.\n  void setBundlePadding(uint8_t N) { BundlePadding = N; }\n\n  /// Retrieve the MCSubTargetInfo in effect when the instruction was encoded.\n  /// Guaranteed to be non-null if hasInstructions() == true\n  const MCSubtargetInfo *getSubtargetInfo() const { return STI; }\n\n  /// Record that the fragment contains instructions with the MCSubtargetInfo in\n  /// effect when the instruction was encoded.\n  void setHasInstructions(const MCSubtargetInfo &STI) {\n    HasInstructions = true;\n    this->STI = &STI;\n  }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data.\n///\ntemplate<unsigned ContentsSize>\nclass MCEncodedFragmentWithContents : public MCEncodedFragment {\n  SmallVector<char, ContentsSize> Contents;\n\nprotected:\n  MCEncodedFragmentWithContents(MCFragment::FragmentType FType,\n                                bool HasInstructions,\n                                MCSection *Sec)\n      : MCEncodedFragment(FType, HasInstructions, Sec) {}\n\npublic:\n  SmallVectorImpl<char> &getContents() { return Contents; }\n  const SmallVectorImpl<char> &getContents() const { return Contents; }\n};\n\n/// Interface implemented by fragments that contain encoded instructions and/or\n/// data and also have fixups registered.\n///\ntemplate<unsigned ContentsSize, unsigned FixupsSize>\nclass MCEncodedFragmentWithFixups :\n  public MCEncodedFragmentWithContents<ContentsSize> {\n\n  /// The list of fixups in this fragment.\n  SmallVector<MCFixup, FixupsSize> Fixups;\n\nprotected:\n  MCEncodedFragmentWithFixups(MCFragment::FragmentType FType,\n                              bool HasInstructions,\n                              MCSection *Sec)\n      : MCEncodedFragmentWithContents<ContentsSize>(FType, HasInstructions,\n                                                    Sec) {}\n\npublic:\n\n  using const_fixup_iterator = SmallVectorImpl<MCFixup>::const_iterator;\n  using fixup_iterator = SmallVectorImpl<MCFixup>::iterator;\n\n  SmallVectorImpl<MCFixup> &getFixups() { return Fixups; }\n  const SmallVectorImpl<MCFixup> &getFixups() const { return Fixups; }\n\n  fixup_iterator fixup_begin() { return Fixups.begin(); }\n  const_fixup_iterator fixup_begin() const { return Fixups.begin(); }\n\n  fixup_iterator fixup_end() { return Fixups.end(); }\n  const_fixup_iterator fixup_end() const { return Fixups.end(); }\n\n  static bool classof(const MCFragment *F) {\n    MCFragment::FragmentType Kind = F->getKind();\n    return Kind == MCFragment::FT_Relaxable || Kind == MCFragment::FT_Data ||\n           Kind == MCFragment::FT_CVDefRange || Kind == MCFragment::FT_Dwarf ||\n           Kind == MCFragment::FT_DwarfFrame;\n  }\n};\n\n/// Fragment for data and encoded instructions.\n///\nclass MCDataFragment : public MCEncodedFragmentWithFixups<32, 4> {\npublic:\n  MCDataFragment(MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<32, 4>(FT_Data, false, Sec) {}\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Data;\n  }\n};\n\n/// This is a compact (memory-size-wise) fragment for holding an encoded\n/// instruction (non-relaxable) that has no fixups registered. When applicable,\n/// it can be used instead of MCDataFragment and lead to lower memory\n/// consumption.\n///\nclass MCCompactEncodedInstFragment : public MCEncodedFragmentWithContents<4> {\npublic:\n  MCCompactEncodedInstFragment(MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithContents(FT_CompactEncodedInst, true, Sec) {\n  }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CompactEncodedInst;\n  }\n};\n\n/// A relaxable fragment holds on to its MCInst, since it may need to be\n/// relaxed during the assembler layout and relaxation stage.\n///\nclass MCRelaxableFragment : public MCEncodedFragmentWithFixups<8, 1> {\n\n  /// The instruction this is a fragment for.\n  MCInst Inst;\n  /// Can we auto pad the instruction?\n  bool AllowAutoPadding = false;\n\npublic:\n  MCRelaxableFragment(const MCInst &Inst, const MCSubtargetInfo &STI,\n                      MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups(FT_Relaxable, true, Sec),\n        Inst(Inst) { this->STI = &STI; }\n\n  const MCInst &getInst() const { return Inst; }\n  void setInst(const MCInst &Value) { Inst = Value; }\n\n  bool getAllowAutoPadding() const { return AllowAutoPadding; }\n  void setAllowAutoPadding(bool V) { AllowAutoPadding = V; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Relaxable;\n  }\n};\n\nclass MCAlignFragment : public MCFragment {\n  /// The alignment to ensure, in bytes.\n  unsigned Alignment;\n\n  /// Flag to indicate that (optimal) NOPs should be emitted instead\n  /// of using the provided value. The exact interpretation of this flag is\n  /// target dependent.\n  bool EmitNops : 1;\n\n  /// Value to use for filling padding bytes.\n  int64_t Value;\n\n  /// The size of the integer (in bytes) of \\p Value.\n  unsigned ValueSize;\n\n  /// The maximum number of bytes to emit; if the alignment\n  /// cannot be satisfied in this width then this fragment is ignored.\n  unsigned MaxBytesToEmit;\n\npublic:\n  MCAlignFragment(unsigned Alignment, int64_t Value, unsigned ValueSize,\n                  unsigned MaxBytesToEmit, MCSection *Sec = nullptr)\n      : MCFragment(FT_Align, false, Sec), Alignment(Alignment), EmitNops(false),\n        Value(Value), ValueSize(ValueSize), MaxBytesToEmit(MaxBytesToEmit) {}\n\n  unsigned getAlignment() const { return Alignment; }\n\n  int64_t getValue() const { return Value; }\n\n  unsigned getValueSize() const { return ValueSize; }\n\n  unsigned getMaxBytesToEmit() const { return MaxBytesToEmit; }\n\n  bool hasEmitNops() const { return EmitNops; }\n  void setEmitNops(bool Value) { EmitNops = Value; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Align;\n  }\n};\n\nclass MCFillFragment : public MCFragment {\n  uint8_t ValueSize;\n  /// Value to use for filling bytes.\n  uint64_t Value;\n  /// The number of bytes to insert.\n  const MCExpr &NumValues;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCFillFragment(uint64_t Value, uint8_t VSize, const MCExpr &NumValues,\n                 SMLoc Loc, MCSection *Sec = nullptr)\n      : MCFragment(FT_Fill, false, Sec), ValueSize(VSize), Value(Value),\n        NumValues(NumValues), Loc(Loc) {}\n\n  uint64_t getValue() const { return Value; }\n  uint8_t getValueSize() const { return ValueSize; }\n  const MCExpr &getNumValues() const { return NumValues; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Fill;\n  }\n};\n\nclass MCNopsFragment : public MCFragment {\n  /// The number of bytes to insert.\n  int64_t Size;\n  /// Maximum number of bytes allowed in each NOP instruction.\n  int64_t ControlledNopLength;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCNopsFragment(int64_t NumBytes, int64_t ControlledNopLength, SMLoc L,\n                 MCSection *Sec = nullptr)\n      : MCFragment(FT_Nops, false, Sec), Size(NumBytes),\n        ControlledNopLength(ControlledNopLength), Loc(L) {}\n\n  int64_t getNumBytes() const { return Size; }\n  int64_t getControlledNopLength() const { return ControlledNopLength; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Nops;\n  }\n};\n\nclass MCOrgFragment : public MCFragment {\n  /// Value to use for filling bytes.\n  int8_t Value;\n\n  /// The offset this fragment should start at.\n  const MCExpr *Offset;\n\n  /// Source location of the directive that this fragment was created for.\n  SMLoc Loc;\n\npublic:\n  MCOrgFragment(const MCExpr &Offset, int8_t Value, SMLoc Loc,\n                MCSection *Sec = nullptr)\n      : MCFragment(FT_Org, false, Sec), Value(Value), Offset(&Offset),\n        Loc(Loc) {}\n\n  const MCExpr &getOffset() const { return *Offset; }\n\n  uint8_t getValue() const { return Value; }\n\n  SMLoc getLoc() const { return Loc; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Org;\n  }\n};\n\nclass MCLEBFragment : public MCFragment {\n  /// True if this is a sleb128, false if uleb128.\n  bool IsSigned;\n\n  /// The value this fragment should contain.\n  const MCExpr *Value;\n\n  SmallString<8> Contents;\n\npublic:\n  MCLEBFragment(const MCExpr &Value_, bool IsSigned_, MCSection *Sec = nullptr)\n      : MCFragment(FT_LEB, false, Sec), IsSigned(IsSigned_), Value(&Value_) {\n    Contents.push_back(0);\n  }\n\n  const MCExpr &getValue() const { return *Value; }\n\n  bool isSigned() const { return IsSigned; }\n\n  SmallString<8> &getContents() { return Contents; }\n  const SmallString<8> &getContents() const { return Contents; }\n\n  /// @}\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_LEB;\n  }\n};\n\nclass MCDwarfLineAddrFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The value of the difference between the two line numbers\n  /// between two .loc dwarf directives.\n  int64_t LineDelta;\n\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .loc dwarf directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCDwarfLineAddrFragment(int64_t LineDelta, const MCExpr &AddrDelta,\n                          MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_Dwarf, false, Sec),\n        LineDelta(LineDelta), AddrDelta(&AddrDelta) {}\n\n  int64_t getLineDelta() const { return LineDelta; }\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_Dwarf;\n  }\n};\n\nclass MCDwarfCallFrameFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .cfi_* dwarf directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCDwarfCallFrameFragment(const MCExpr &AddrDelta, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_DwarfFrame, false, Sec),\n        AddrDelta(&AddrDelta) {}\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_DwarfFrame;\n  }\n};\n\n/// Represents a symbol table index fragment.\nclass MCSymbolIdFragment : public MCFragment {\n  const MCSymbol *Sym;\n\npublic:\n  MCSymbolIdFragment(const MCSymbol *Sym, MCSection *Sec = nullptr)\n      : MCFragment(FT_SymbolId, false, Sec), Sym(Sym) {}\n\n  const MCSymbol *getSymbol() { return Sym; }\n  const MCSymbol *getSymbol() const { return Sym; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_SymbolId;\n  }\n};\n\n/// Fragment representing the binary annotations produced by the\n/// .cv_inline_linetable directive.\nclass MCCVInlineLineTableFragment : public MCFragment {\n  unsigned SiteFuncId;\n  unsigned StartFileId;\n  unsigned StartLineNum;\n  const MCSymbol *FnStartSym;\n  const MCSymbol *FnEndSym;\n  SmallString<8> Contents;\n\n  /// CodeViewContext has the real knowledge about this format, so let it access\n  /// our members.\n  friend class CodeViewContext;\n\npublic:\n  MCCVInlineLineTableFragment(unsigned SiteFuncId, unsigned StartFileId,\n                              unsigned StartLineNum, const MCSymbol *FnStartSym,\n                              const MCSymbol *FnEndSym,\n                              MCSection *Sec = nullptr)\n      : MCFragment(FT_CVInlineLines, false, Sec), SiteFuncId(SiteFuncId),\n        StartFileId(StartFileId), StartLineNum(StartLineNum),\n        FnStartSym(FnStartSym), FnEndSym(FnEndSym) {}\n\n  const MCSymbol *getFnStartSym() const { return FnStartSym; }\n  const MCSymbol *getFnEndSym() const { return FnEndSym; }\n\n  SmallString<8> &getContents() { return Contents; }\n  const SmallString<8> &getContents() const { return Contents; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CVInlineLines;\n  }\n};\n\n/// Fragment representing the .cv_def_range directive.\nclass MCCVDefRangeFragment : public MCEncodedFragmentWithFixups<32, 4> {\n  SmallVector<std::pair<const MCSymbol *, const MCSymbol *>, 2> Ranges;\n  SmallString<32> FixedSizePortion;\n\n  /// CodeViewContext has the real knowledge about this format, so let it access\n  /// our members.\n  friend class CodeViewContext;\n\npublic:\n  MCCVDefRangeFragment(\n      ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> Ranges,\n      StringRef FixedSizePortion, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<32, 4>(FT_CVDefRange, false, Sec),\n        Ranges(Ranges.begin(), Ranges.end()),\n        FixedSizePortion(FixedSizePortion) {}\n\n  ArrayRef<std::pair<const MCSymbol *, const MCSymbol *>> getRanges() const {\n    return Ranges;\n  }\n\n  StringRef getFixedSizePortion() const { return FixedSizePortion; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_CVDefRange;\n  }\n};\n\n/// Represents required padding such that a particular other set of fragments\n/// does not cross a particular power-of-two boundary. The other fragments must\n/// follow this one within the same section.\nclass MCBoundaryAlignFragment : public MCFragment {\n  /// The alignment requirement of the branch to be aligned.\n  Align AlignBoundary;\n  /// The last fragment in the set of fragments to be aligned.\n  const MCFragment *LastFragment = nullptr;\n  /// The size of the fragment.  The size is lazily set during relaxation, and\n  /// is not meaningful before that.\n  uint64_t Size = 0;\n\npublic:\n  MCBoundaryAlignFragment(Align AlignBoundary, MCSection *Sec = nullptr)\n      : MCFragment(FT_BoundaryAlign, false, Sec), AlignBoundary(AlignBoundary) {\n  }\n\n  uint64_t getSize() const { return Size; }\n  void setSize(uint64_t Value) { Size = Value; }\n\n  Align getAlignment() const { return AlignBoundary; }\n  void setAlignment(Align Value) { AlignBoundary = Value; }\n\n  const MCFragment *getLastFragment() const { return LastFragment; }\n  void setLastFragment(const MCFragment *F) {\n    assert(!F || getParent() == F->getParent());\n    LastFragment = F;\n  }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_BoundaryAlign;\n  }\n};\n\nclass MCPseudoProbeAddrFragment : public MCEncodedFragmentWithFixups<8, 1> {\n  /// The expression for the difference of the two symbols that\n  /// make up the address delta between two .pseudoprobe directives.\n  const MCExpr *AddrDelta;\n\npublic:\n  MCPseudoProbeAddrFragment(const MCExpr *AddrDelta, MCSection *Sec = nullptr)\n      : MCEncodedFragmentWithFixups<8, 1>(FT_PseudoProbe, false, Sec),\n        AddrDelta(AddrDelta) {}\n\n  const MCExpr &getAddrDelta() const { return *AddrDelta; }\n\n  static bool classof(const MCFragment *F) {\n    return F->getKind() == MCFragment::FT_PseudoProbe;\n  }\n};\n} // end namespace llvm\n\n#endif // LLVM_MC_MCFRAGMENT_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "content": "//===- llvm/MC/MCInst.h - MCInst class --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MCInst and MCOperand classes, which\n// is the basic representation used to represent low-level machine code\n// instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCINST_H\n#define LLVM_MC_MCINST_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/bit.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass MCExpr;\nclass MCInst;\nclass MCInstPrinter;\nclass raw_ostream;\n\n/// Instances of this class represent operands of the MCInst class.\n/// This is a simple discriminated union.\nclass MCOperand {\n  enum MachineOperandType : unsigned char {\n    kInvalid,      ///< Uninitialized.\n    kRegister,     ///< Register operand.\n    kImmediate,    ///< Immediate operand.\n    kSFPImmediate, ///< Single-floating-point immediate operand.\n    kDFPImmediate, ///< Double-Floating-point immediate operand.\n    kExpr,         ///< Relocatable immediate operand.\n    kInst          ///< Sub-instruction operand.\n  };\n  MachineOperandType Kind = kInvalid;\n\n  union {\n    unsigned RegVal;\n    int64_t ImmVal;\n    uint32_t SFPImmVal;\n    uint64_t FPImmVal;\n    const MCExpr *ExprVal;\n    const MCInst *InstVal;\n  };\n\npublic:\n  MCOperand() : FPImmVal(0) {}\n\n  bool isValid() const { return Kind != kInvalid; }\n  bool isReg() const { return Kind == kRegister; }\n  bool isImm() const { return Kind == kImmediate; }\n  bool isSFPImm() const { return Kind == kSFPImmediate; }\n  bool isDFPImm() const { return Kind == kDFPImmediate; }\n  bool isFPImm() const { return Kind == kDFPImmediate; }\n  bool isExpr() const { return Kind == kExpr; }\n  bool isInst() const { return Kind == kInst; }\n\n  /// Returns the register number.\n  unsigned getReg() const {\n    assert(isReg() && \"This is not a register operand!\");\n    return RegVal;\n  }\n\n  /// Set the register number.\n  void setReg(unsigned Reg) {\n    assert(isReg() && \"This is not a register operand!\");\n    RegVal = Reg;\n  }\n\n  int64_t getImm() const {\n    assert(isImm() && \"This is not an immediate\");\n    return ImmVal;\n  }\n\n  void setImm(int64_t Val) {\n    assert(isImm() && \"This is not an immediate\");\n    ImmVal = Val;\n  }\n\n  uint32_t getSFPImm() const {\n    assert(isSFPImm() && \"This is not an SFP immediate\");\n    return SFPImmVal;\n  }\n\n  void setSFPImm(uint32_t Val) {\n    assert(isSFPImm() && \"This is not an SFP immediate\");\n    SFPImmVal = Val;\n  }\n\n  uint64_t getDFPImm() const {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    return FPImmVal;\n  }\n  double getFPImm() const {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    return bit_cast<double>(FPImmVal);\n  }\n\n  void setDFPImm(uint64_t Val) {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    FPImmVal = Val;\n  }\n  void setFPImm(double Val) {\n    assert(isDFPImm() && \"This is not an FP immediate\");\n    FPImmVal = bit_cast<uint64_t>(Val);\n  }\n\n  const MCExpr *getExpr() const {\n    assert(isExpr() && \"This is not an expression\");\n    return ExprVal;\n  }\n\n  void setExpr(const MCExpr *Val) {\n    assert(isExpr() && \"This is not an expression\");\n    ExprVal = Val;\n  }\n\n  const MCInst *getInst() const {\n    assert(isInst() && \"This is not a sub-instruction\");\n    return InstVal;\n  }\n\n  void setInst(const MCInst *Val) {\n    assert(isInst() && \"This is not a sub-instruction\");\n    InstVal = Val;\n  }\n\n  static MCOperand createReg(unsigned Reg) {\n    MCOperand Op;\n    Op.Kind = kRegister;\n    Op.RegVal = Reg;\n    return Op;\n  }\n\n  static MCOperand createImm(int64_t Val) {\n    MCOperand Op;\n    Op.Kind = kImmediate;\n    Op.ImmVal = Val;\n    return Op;\n  }\n\n  static MCOperand createSFPImm(uint32_t Val) {\n    MCOperand Op;\n    Op.Kind = kSFPImmediate;\n    Op.SFPImmVal = Val;\n    return Op;\n  }\n\n  static MCOperand createDFPImm(uint64_t Val) {\n    MCOperand Op;\n    Op.Kind = kDFPImmediate;\n    Op.FPImmVal = Val;\n    return Op;\n  }\n  static MCOperand createFPImm(double Val) {\n    MCOperand Op;\n    Op.Kind = kDFPImmediate;\n    Op.FPImmVal = bit_cast<uint64_t>(Val);\n    return Op;\n  }\n\n  static MCOperand createExpr(const MCExpr *Val) {\n    MCOperand Op;\n    Op.Kind = kExpr;\n    Op.ExprVal = Val;\n    return Op;\n  }\n\n  static MCOperand createInst(const MCInst *Val) {\n    MCOperand Op;\n    Op.Kind = kInst;\n    Op.InstVal = Val;\n    return Op;\n  }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n  bool isBareSymbolRef() const;\n  bool evaluateAsConstantImm(int64_t &Imm) const;\n};\n\n/// Instances of this class represent a single low-level machine\n/// instruction.\nclass MCInst {\n  unsigned Opcode = 0;\n  // These flags could be used to pass some info from one target subcomponent\n  // to another, for example, from disassembler to asm printer. The values of\n  // the flags have any sense on target level only (e.g. prefixes on x86).\n  unsigned Flags = 0;\n\n  SMLoc Loc;\n  SmallVector<MCOperand, 8> Operands;\n\npublic:\n  MCInst() = default;\n\n  void setOpcode(unsigned Op) { Opcode = Op; }\n  unsigned getOpcode() const { return Opcode; }\n\n  void setFlags(unsigned F) { Flags = F; }\n  unsigned getFlags() const { return Flags; }\n\n  void setLoc(SMLoc loc) { Loc = loc; }\n  SMLoc getLoc() const { return Loc; }\n\n  const MCOperand &getOperand(unsigned i) const { return Operands[i]; }\n  MCOperand &getOperand(unsigned i) { return Operands[i]; }\n  unsigned getNumOperands() const { return Operands.size(); }\n\n  void addOperand(const MCOperand Op) { Operands.push_back(Op); }\n\n  using iterator = SmallVectorImpl<MCOperand>::iterator;\n  using const_iterator = SmallVectorImpl<MCOperand>::const_iterator;\n\n  void clear() { Operands.clear(); }\n  void erase(iterator I) { Operands.erase(I); }\n  void erase(iterator First, iterator Last) { Operands.erase(First, Last); }\n  size_t size() const { return Operands.size(); }\n  iterator begin() { return Operands.begin(); }\n  const_iterator begin() const { return Operands.begin(); }\n  iterator end() { return Operands.end(); }\n  const_iterator end() const { return Operands.end(); }\n\n  iterator insert(iterator I, const MCOperand &Op) {\n    return Operands.insert(I, Op);\n  }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  /// Dump the MCInst as prettily as possible using the additional MC\n  /// structures, if given. Operators are separated by the \\p Separator\n  /// string.\n  void dump_pretty(raw_ostream &OS, const MCInstPrinter *Printer = nullptr,\n                   StringRef Separator = \" \") const;\n  void dump_pretty(raw_ostream &OS, StringRef Name,\n                   StringRef Separator = \" \") const;\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MCOperand &MO) {\n  MO.print(OS);\n  return OS;\n}\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MCInst &MI) {\n  MI.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCINST_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSymbolWasm.h", "content": "//===- MCSymbolWasm.h -  ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_MC_MCSYMBOLWASM_H\n#define LLVM_MC_MCSYMBOLWASM_H\n\n#include \"llvm/BinaryFormat/Wasm.h\"\n#include \"llvm/MC/MCSymbol.h\"\n\nnamespace llvm {\n\nclass MCSymbolWasm : public MCSymbol {\n  Optional<wasm::WasmSymbolType> Type;\n  bool IsWeak = false;\n  bool IsHidden = false;\n  bool IsComdat = false;\n  bool OmitFromLinkingSection = false;\n  mutable bool IsUsedInInitArray = false;\n  mutable bool IsUsedInGOT = false;\n  Optional<StringRef> ImportModule;\n  Optional<StringRef> ImportName;\n  Optional<StringRef> ExportName;\n  wasm::WasmSignature *Signature = nullptr;\n  Optional<wasm::WasmGlobalType> GlobalType;\n  Optional<wasm::ValType> TableType;\n  Optional<wasm::WasmEventType> EventType;\n\n  /// An expression describing how to calculate the size of a symbol. If a\n  /// symbol has no size this field will be NULL.\n  const MCExpr *SymbolSize = nullptr;\n\npublic:\n  MCSymbolWasm(const StringMapEntry<bool> *Name, bool isTemporary)\n      : MCSymbol(SymbolKindWasm, Name, isTemporary) {}\n  static bool classof(const MCSymbol *S) { return S->isWasm(); }\n\n  const MCExpr *getSize() const { return SymbolSize; }\n  void setSize(const MCExpr *SS) { SymbolSize = SS; }\n\n  bool isFunction() const { return Type == wasm::WASM_SYMBOL_TYPE_FUNCTION; }\n  // Data is the default value if not set.\n  bool isData() const { return !Type || Type == wasm::WASM_SYMBOL_TYPE_DATA; }\n  bool isGlobal() const { return Type == wasm::WASM_SYMBOL_TYPE_GLOBAL; }\n  bool isTable() const { return Type == wasm::WASM_SYMBOL_TYPE_TABLE; }\n  bool isSection() const { return Type == wasm::WASM_SYMBOL_TYPE_SECTION; }\n  bool isEvent() const { return Type == wasm::WASM_SYMBOL_TYPE_EVENT; }\n\n  Optional<wasm::WasmSymbolType> getType() const { return Type; }\n\n  void setType(wasm::WasmSymbolType type) { Type = type; }\n\n  bool isExported() const {\n    return getFlags() & wasm::WASM_SYMBOL_EXPORTED;\n  }\n  void setExported() const {\n    modifyFlags(wasm::WASM_SYMBOL_EXPORTED, wasm::WASM_SYMBOL_EXPORTED);\n  }\n\n  bool isNoStrip() const {\n    return getFlags() & wasm::WASM_SYMBOL_NO_STRIP;\n  }\n  void setNoStrip() const {\n    modifyFlags(wasm::WASM_SYMBOL_NO_STRIP, wasm::WASM_SYMBOL_NO_STRIP);\n  }\n\n  bool isWeak() const { return IsWeak; }\n  void setWeak(bool isWeak) { IsWeak = isWeak; }\n\n  bool isHidden() const { return IsHidden; }\n  void setHidden(bool isHidden) { IsHidden = isHidden; }\n\n  bool isComdat() const { return IsComdat; }\n  void setComdat(bool isComdat) { IsComdat = isComdat; }\n\n  // wasm-ld understands a finite set of symbol types.  This flag allows the\n  // compiler to avoid emitting symbol table entries that would confuse the\n  // linker, unless the user specifically requests the feature.\n  bool omitFromLinkingSection() const { return OmitFromLinkingSection; }\n  void setOmitFromLinkingSection() { OmitFromLinkingSection = true; }\n\n  bool hasImportModule() const { return ImportModule.hasValue(); }\n  StringRef getImportModule() const {\n    if (ImportModule.hasValue())\n      return ImportModule.getValue();\n    // Use a default module name of \"env\" for now, for compatibility with\n    // existing tools.\n    // TODO(sbc): Find a way to specify a default value in the object format\n    // without picking a hardcoded value like this.\n    return \"env\";\n  }\n  void setImportModule(StringRef Name) { ImportModule = Name; }\n\n  bool hasImportName() const { return ImportName.hasValue(); }\n  StringRef getImportName() const {\n    if (ImportName.hasValue())\n      return ImportName.getValue();\n    return getName();\n  }\n  void setImportName(StringRef Name) { ImportName = Name; }\n\n  bool hasExportName() const { return ExportName.hasValue(); }\n  StringRef getExportName() const { return ExportName.getValue(); }\n  void setExportName(StringRef Name) { ExportName = Name; }\n\n  bool isFunctionTable() const {\n    return isTable() && hasTableType() &&\n           getTableType() == wasm::ValType::FUNCREF;\n  }\n  void setFunctionTable() {\n    setType(wasm::WASM_SYMBOL_TYPE_TABLE);\n    setTableType(wasm::ValType::FUNCREF);\n  }\n\n  void setUsedInGOT() const { IsUsedInGOT = true; }\n  bool isUsedInGOT() const { return IsUsedInGOT; }\n\n  void setUsedInInitArray() const { IsUsedInInitArray = true; }\n  bool isUsedInInitArray() const { return IsUsedInInitArray; }\n\n  const wasm::WasmSignature *getSignature() const { return Signature; }\n  void setSignature(wasm::WasmSignature *Sig) { Signature = Sig; }\n\n  const wasm::WasmGlobalType &getGlobalType() const {\n    assert(GlobalType.hasValue());\n    return GlobalType.getValue();\n  }\n  void setGlobalType(wasm::WasmGlobalType GT) { GlobalType = GT; }\n\n  bool hasTableType() const { return TableType.hasValue(); }\n  wasm::ValType getTableType() const {\n    assert(hasTableType());\n    return TableType.getValue();\n  }\n  void setTableType(wasm::ValType TT) { TableType = TT; }\n\n  const wasm::WasmEventType &getEventType() const {\n    assert(EventType.hasValue());\n    return EventType.getValue();\n  }\n  void setEventType(wasm::WasmEventType ET) { EventType = ET; }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCSYMBOLWASM_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "content": "//===- Binary.h - A generic binary file -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Binary class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_BINARY_H\n#define LLVM_OBJECT_BINARY_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <algorithm>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass LLVMContext;\nclass StringRef;\n\nnamespace object {\n\nclass Binary {\nprivate:\n  unsigned int TypeID;\n\nprotected:\n  MemoryBufferRef Data;\n\n  Binary(unsigned int Type, MemoryBufferRef Source);\n\n  enum {\n    ID_Archive,\n    ID_MachOUniversalBinary,\n    ID_COFFImportFile,\n    ID_IR,            // LLVM IR\n    ID_TapiUniversal, // Text-based Dynamic Library Stub file.\n    ID_TapiFile,      // Text-based Dynamic Library Stub file.\n\n    ID_Minidump,\n\n    ID_WinRes, // Windows resource (.res) file.\n\n    // Object and children.\n    ID_StartObjects,\n    ID_COFF,\n\n    ID_XCOFF32, // AIX XCOFF 32-bit\n    ID_XCOFF64, // AIX XCOFF 64-bit\n\n    ID_ELF32L, // ELF 32-bit, little endian\n    ID_ELF32B, // ELF 32-bit, big endian\n    ID_ELF64L, // ELF 64-bit, little endian\n    ID_ELF64B, // ELF 64-bit, big endian\n\n    ID_MachO32L, // MachO 32-bit, little endian\n    ID_MachO32B, // MachO 32-bit, big endian\n    ID_MachO64L, // MachO 64-bit, little endian\n    ID_MachO64B, // MachO 64-bit, big endian\n\n    ID_Wasm,\n\n    ID_EndObjects\n  };\n\n  static inline unsigned int getELFType(bool isLE, bool is64Bits) {\n    if (isLE)\n      return is64Bits ? ID_ELF64L : ID_ELF32L;\n    else\n      return is64Bits ? ID_ELF64B : ID_ELF32B;\n  }\n\n  static unsigned int getMachOType(bool isLE, bool is64Bits) {\n    if (isLE)\n      return is64Bits ? ID_MachO64L : ID_MachO32L;\n    else\n      return is64Bits ? ID_MachO64B : ID_MachO32B;\n  }\n\npublic:\n  Binary() = delete;\n  Binary(const Binary &other) = delete;\n  virtual ~Binary();\n\n  virtual Error initContent() { return Error::success(); };\n\n  StringRef getData() const;\n  StringRef getFileName() const;\n  MemoryBufferRef getMemoryBufferRef() const;\n\n  // Cast methods.\n  unsigned int getType() const { return TypeID; }\n\n  // Convenience methods\n  bool isObject() const {\n    return TypeID > ID_StartObjects && TypeID < ID_EndObjects;\n  }\n\n  bool isSymbolic() const {\n    return isIR() || isObject() || isCOFFImportFile() || isTapiFile();\n  }\n\n  bool isArchive() const { return TypeID == ID_Archive; }\n\n  bool isMachOUniversalBinary() const {\n    return TypeID == ID_MachOUniversalBinary;\n  }\n\n  bool isTapiUniversal() const { return TypeID == ID_TapiUniversal; }\n\n  bool isELF() const {\n    return TypeID >= ID_ELF32L && TypeID <= ID_ELF64B;\n  }\n\n  bool isMachO() const {\n    return TypeID >= ID_MachO32L && TypeID <= ID_MachO64B;\n  }\n\n  bool isCOFF() const {\n    return TypeID == ID_COFF;\n  }\n\n  bool isXCOFF() const { return TypeID == ID_XCOFF32 || TypeID == ID_XCOFF64; }\n\n  bool isWasm() const { return TypeID == ID_Wasm; }\n\n  bool isCOFFImportFile() const {\n    return TypeID == ID_COFFImportFile;\n  }\n\n  bool isIR() const {\n    return TypeID == ID_IR;\n  }\n\n  bool isMinidump() const { return TypeID == ID_Minidump; }\n\n  bool isTapiFile() const { return TypeID == ID_TapiFile; }\n\n  bool isLittleEndian() const {\n    return !(TypeID == ID_ELF32B || TypeID == ID_ELF64B ||\n             TypeID == ID_MachO32B || TypeID == ID_MachO64B);\n  }\n\n  bool isWinRes() const { return TypeID == ID_WinRes; }\n\n  Triple::ObjectFormatType getTripleObjectFormat() const {\n    if (isCOFF())\n      return Triple::COFF;\n    if (isMachO())\n      return Triple::MachO;\n    if (isELF())\n      return Triple::ELF;\n    return Triple::UnknownObjectFormat;\n  }\n\n  static Error checkOffset(MemoryBufferRef M, uintptr_t Addr,\n                           const uint64_t Size) {\n    if (Addr + Size < Addr || Addr + Size < Size ||\n        Addr + Size > reinterpret_cast<uintptr_t>(M.getBufferEnd()) ||\n        Addr < reinterpret_cast<uintptr_t>(M.getBufferStart())) {\n      return errorCodeToError(object_error::unexpected_eof);\n    }\n    return Error::success();\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Binary, LLVMBinaryRef)\n\n/// Create a Binary from Source, autodetecting the file type.\n///\n/// @param Source The data to create the Binary from.\nExpected<std::unique_ptr<Binary>> createBinary(MemoryBufferRef Source,\n                                               LLVMContext *Context = nullptr,\n                                               bool InitContent = true);\n\ntemplate <typename T> class OwningBinary {\n  std::unique_ptr<T> Bin;\n  std::unique_ptr<MemoryBuffer> Buf;\n\npublic:\n  OwningBinary();\n  OwningBinary(std::unique_ptr<T> Bin, std::unique_ptr<MemoryBuffer> Buf);\n  OwningBinary(OwningBinary<T>&& Other);\n  OwningBinary<T> &operator=(OwningBinary<T> &&Other);\n\n  std::pair<std::unique_ptr<T>, std::unique_ptr<MemoryBuffer>> takeBinary();\n\n  T* getBinary();\n  const T* getBinary() const;\n};\n\ntemplate <typename T>\nOwningBinary<T>::OwningBinary(std::unique_ptr<T> Bin,\n                              std::unique_ptr<MemoryBuffer> Buf)\n    : Bin(std::move(Bin)), Buf(std::move(Buf)) {}\n\ntemplate <typename T> OwningBinary<T>::OwningBinary() = default;\n\ntemplate <typename T>\nOwningBinary<T>::OwningBinary(OwningBinary &&Other)\n    : Bin(std::move(Other.Bin)), Buf(std::move(Other.Buf)) {}\n\ntemplate <typename T>\nOwningBinary<T> &OwningBinary<T>::operator=(OwningBinary &&Other) {\n  Bin = std::move(Other.Bin);\n  Buf = std::move(Other.Buf);\n  return *this;\n}\n\ntemplate <typename T>\nstd::pair<std::unique_ptr<T>, std::unique_ptr<MemoryBuffer>>\nOwningBinary<T>::takeBinary() {\n  return std::make_pair(std::move(Bin), std::move(Buf));\n}\n\ntemplate <typename T> T* OwningBinary<T>::getBinary() {\n  return Bin.get();\n}\n\ntemplate <typename T> const T* OwningBinary<T>::getBinary() const {\n  return Bin.get();\n}\n\nExpected<OwningBinary<Binary>> createBinary(StringRef Path,\n                                            LLVMContext *Context = nullptr,\n                                            bool InitContent = true);\n\n} // end namespace object\n\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_BINARY_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/COFF.h", "content": "//===- COFF.h - COFF object file implementation -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the COFFObjectFile class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_COFF_H\n#define LLVM_OBJECT_COFF_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/COFF.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/CVDebugRecord.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/BinaryByteStream.h\"\n#include \"llvm/Support/ConvertUTF.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <system_error>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\n\nnamespace object {\n\nclass BaseRelocRef;\nclass DelayImportDirectoryEntryRef;\nclass ExportDirectoryEntryRef;\nclass ImportDirectoryEntryRef;\nclass ImportedSymbolRef;\nclass ResourceSectionRef;\n\nusing import_directory_iterator = content_iterator<ImportDirectoryEntryRef>;\nusing delay_import_directory_iterator =\n    content_iterator<DelayImportDirectoryEntryRef>;\nusing export_directory_iterator = content_iterator<ExportDirectoryEntryRef>;\nusing imported_symbol_iterator = content_iterator<ImportedSymbolRef>;\nusing base_reloc_iterator = content_iterator<BaseRelocRef>;\n\n/// The DOS compatible header at the front of all PE/COFF executables.\nstruct dos_header {\n  char                 Magic[2];\n  support::ulittle16_t UsedBytesInTheLastPage;\n  support::ulittle16_t FileSizeInPages;\n  support::ulittle16_t NumberOfRelocationItems;\n  support::ulittle16_t HeaderSizeInParagraphs;\n  support::ulittle16_t MinimumExtraParagraphs;\n  support::ulittle16_t MaximumExtraParagraphs;\n  support::ulittle16_t InitialRelativeSS;\n  support::ulittle16_t InitialSP;\n  support::ulittle16_t Checksum;\n  support::ulittle16_t InitialIP;\n  support::ulittle16_t InitialRelativeCS;\n  support::ulittle16_t AddressOfRelocationTable;\n  support::ulittle16_t OverlayNumber;\n  support::ulittle16_t Reserved[4];\n  support::ulittle16_t OEMid;\n  support::ulittle16_t OEMinfo;\n  support::ulittle16_t Reserved2[10];\n  support::ulittle32_t AddressOfNewExeHeader;\n};\n\nstruct coff_file_header {\n  support::ulittle16_t Machine;\n  support::ulittle16_t NumberOfSections;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle32_t PointerToSymbolTable;\n  support::ulittle32_t NumberOfSymbols;\n  support::ulittle16_t SizeOfOptionalHeader;\n  support::ulittle16_t Characteristics;\n\n  bool isImportLibrary() const { return NumberOfSections == 0xffff; }\n};\n\nstruct coff_bigobj_file_header {\n  support::ulittle16_t Sig1;\n  support::ulittle16_t Sig2;\n  support::ulittle16_t Version;\n  support::ulittle16_t Machine;\n  support::ulittle32_t TimeDateStamp;\n  uint8_t              UUID[16];\n  support::ulittle32_t unused1;\n  support::ulittle32_t unused2;\n  support::ulittle32_t unused3;\n  support::ulittle32_t unused4;\n  support::ulittle32_t NumberOfSections;\n  support::ulittle32_t PointerToSymbolTable;\n  support::ulittle32_t NumberOfSymbols;\n};\n\n/// The 32-bit PE header that follows the COFF header.\nstruct pe32_header {\n  support::ulittle16_t Magic;\n  uint8_t MajorLinkerVersion;\n  uint8_t MinorLinkerVersion;\n  support::ulittle32_t SizeOfCode;\n  support::ulittle32_t SizeOfInitializedData;\n  support::ulittle32_t SizeOfUninitializedData;\n  support::ulittle32_t AddressOfEntryPoint;\n  support::ulittle32_t BaseOfCode;\n  support::ulittle32_t BaseOfData;\n  support::ulittle32_t ImageBase;\n  support::ulittle32_t SectionAlignment;\n  support::ulittle32_t FileAlignment;\n  support::ulittle16_t MajorOperatingSystemVersion;\n  support::ulittle16_t MinorOperatingSystemVersion;\n  support::ulittle16_t MajorImageVersion;\n  support::ulittle16_t MinorImageVersion;\n  support::ulittle16_t MajorSubsystemVersion;\n  support::ulittle16_t MinorSubsystemVersion;\n  support::ulittle32_t Win32VersionValue;\n  support::ulittle32_t SizeOfImage;\n  support::ulittle32_t SizeOfHeaders;\n  support::ulittle32_t CheckSum;\n  support::ulittle16_t Subsystem;\n  // FIXME: This should be DllCharacteristics.\n  support::ulittle16_t DLLCharacteristics;\n  support::ulittle32_t SizeOfStackReserve;\n  support::ulittle32_t SizeOfStackCommit;\n  support::ulittle32_t SizeOfHeapReserve;\n  support::ulittle32_t SizeOfHeapCommit;\n  support::ulittle32_t LoaderFlags;\n  // FIXME: This should be NumberOfRvaAndSizes.\n  support::ulittle32_t NumberOfRvaAndSize;\n};\n\n/// The 64-bit PE header that follows the COFF header.\nstruct pe32plus_header {\n  support::ulittle16_t Magic;\n  uint8_t MajorLinkerVersion;\n  uint8_t MinorLinkerVersion;\n  support::ulittle32_t SizeOfCode;\n  support::ulittle32_t SizeOfInitializedData;\n  support::ulittle32_t SizeOfUninitializedData;\n  support::ulittle32_t AddressOfEntryPoint;\n  support::ulittle32_t BaseOfCode;\n  support::ulittle64_t ImageBase;\n  support::ulittle32_t SectionAlignment;\n  support::ulittle32_t FileAlignment;\n  support::ulittle16_t MajorOperatingSystemVersion;\n  support::ulittle16_t MinorOperatingSystemVersion;\n  support::ulittle16_t MajorImageVersion;\n  support::ulittle16_t MinorImageVersion;\n  support::ulittle16_t MajorSubsystemVersion;\n  support::ulittle16_t MinorSubsystemVersion;\n  support::ulittle32_t Win32VersionValue;\n  support::ulittle32_t SizeOfImage;\n  support::ulittle32_t SizeOfHeaders;\n  support::ulittle32_t CheckSum;\n  support::ulittle16_t Subsystem;\n  support::ulittle16_t DLLCharacteristics;\n  support::ulittle64_t SizeOfStackReserve;\n  support::ulittle64_t SizeOfStackCommit;\n  support::ulittle64_t SizeOfHeapReserve;\n  support::ulittle64_t SizeOfHeapCommit;\n  support::ulittle32_t LoaderFlags;\n  support::ulittle32_t NumberOfRvaAndSize;\n};\n\nstruct data_directory {\n  support::ulittle32_t RelativeVirtualAddress;\n  support::ulittle32_t Size;\n};\n\nstruct debug_directory {\n  support::ulittle32_t Characteristics;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t Type;\n  support::ulittle32_t SizeOfData;\n  support::ulittle32_t AddressOfRawData;\n  support::ulittle32_t PointerToRawData;\n};\n\ntemplate <typename IntTy>\nstruct import_lookup_table_entry {\n  IntTy Data;\n\n  bool isOrdinal() const { return Data < 0; }\n\n  uint16_t getOrdinal() const {\n    assert(isOrdinal() && \"ILT entry is not an ordinal!\");\n    return Data & 0xFFFF;\n  }\n\n  uint32_t getHintNameRVA() const {\n    assert(!isOrdinal() && \"ILT entry is not a Hint/Name RVA!\");\n    return Data & 0xFFFFFFFF;\n  }\n};\n\nusing import_lookup_table_entry32 =\n    import_lookup_table_entry<support::little32_t>;\nusing import_lookup_table_entry64 =\n    import_lookup_table_entry<support::little64_t>;\n\nstruct delay_import_directory_table_entry {\n  // dumpbin reports this field as \"Characteristics\" instead of \"Attributes\".\n  support::ulittle32_t Attributes;\n  support::ulittle32_t Name;\n  support::ulittle32_t ModuleHandle;\n  support::ulittle32_t DelayImportAddressTable;\n  support::ulittle32_t DelayImportNameTable;\n  support::ulittle32_t BoundDelayImportTable;\n  support::ulittle32_t UnloadDelayImportTable;\n  support::ulittle32_t TimeStamp;\n};\n\nstruct export_directory_table_entry {\n  support::ulittle32_t ExportFlags;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t NameRVA;\n  support::ulittle32_t OrdinalBase;\n  support::ulittle32_t AddressTableEntries;\n  support::ulittle32_t NumberOfNamePointers;\n  support::ulittle32_t ExportAddressTableRVA;\n  support::ulittle32_t NamePointerRVA;\n  support::ulittle32_t OrdinalTableRVA;\n};\n\nunion export_address_table_entry {\n  support::ulittle32_t ExportRVA;\n  support::ulittle32_t ForwarderRVA;\n};\n\nusing export_name_pointer_table_entry = support::ulittle32_t;\nusing export_ordinal_table_entry = support::ulittle16_t;\n\nstruct StringTableOffset {\n  support::ulittle32_t Zeroes;\n  support::ulittle32_t Offset;\n};\n\ntemplate <typename SectionNumberType>\nstruct coff_symbol {\n  union {\n    char ShortName[COFF::NameSize];\n    StringTableOffset Offset;\n  } Name;\n\n  support::ulittle32_t Value;\n  SectionNumberType SectionNumber;\n\n  support::ulittle16_t Type;\n\n  uint8_t StorageClass;\n  uint8_t NumberOfAuxSymbols;\n};\n\nusing coff_symbol16 = coff_symbol<support::ulittle16_t>;\nusing coff_symbol32 = coff_symbol<support::ulittle32_t>;\n\n// Contains only common parts of coff_symbol16 and coff_symbol32.\nstruct coff_symbol_generic {\n  union {\n    char ShortName[COFF::NameSize];\n    StringTableOffset Offset;\n  } Name;\n  support::ulittle32_t Value;\n};\n\nstruct coff_aux_section_definition;\nstruct coff_aux_weak_external;\n\nclass COFFSymbolRef {\npublic:\n  COFFSymbolRef() = default;\n  COFFSymbolRef(const coff_symbol16 *CS) : CS16(CS) {}\n  COFFSymbolRef(const coff_symbol32 *CS) : CS32(CS) {}\n\n  const void *getRawPtr() const {\n    return CS16 ? static_cast<const void *>(CS16) : CS32;\n  }\n\n  const coff_symbol_generic *getGeneric() const {\n    if (CS16)\n      return reinterpret_cast<const coff_symbol_generic *>(CS16);\n    return reinterpret_cast<const coff_symbol_generic *>(CS32);\n  }\n\n  friend bool operator<(COFFSymbolRef A, COFFSymbolRef B) {\n    return A.getRawPtr() < B.getRawPtr();\n  }\n\n  bool isBigObj() const {\n    if (CS16)\n      return false;\n    if (CS32)\n      return true;\n    llvm_unreachable(\"COFFSymbolRef points to nothing!\");\n  }\n\n  const char *getShortName() const {\n    return CS16 ? CS16->Name.ShortName : CS32->Name.ShortName;\n  }\n\n  const StringTableOffset &getStringTableOffset() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->Name.Offset : CS32->Name.Offset;\n  }\n\n  uint32_t getValue() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->Value : CS32->Value;\n  }\n\n  int32_t getSectionNumber() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    if (CS16) {\n      // Reserved sections are returned as negative numbers.\n      if (CS16->SectionNumber <= COFF::MaxNumberOfSections16)\n        return CS16->SectionNumber;\n      return static_cast<int16_t>(CS16->SectionNumber);\n    }\n    return static_cast<int32_t>(CS32->SectionNumber);\n  }\n\n  uint16_t getType() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->Type : CS32->Type;\n  }\n\n  uint8_t getStorageClass() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->StorageClass : CS32->StorageClass;\n  }\n\n  uint8_t getNumberOfAuxSymbols() const {\n    assert(isSet() && \"COFFSymbolRef points to nothing!\");\n    return CS16 ? CS16->NumberOfAuxSymbols : CS32->NumberOfAuxSymbols;\n  }\n\n  uint8_t getBaseType() const { return getType() & 0x0F; }\n\n  uint8_t getComplexType() const {\n    return (getType() & 0xF0) >> COFF::SCT_COMPLEX_TYPE_SHIFT;\n  }\n\n  template <typename T> const T *getAux() const {\n    return CS16 ? reinterpret_cast<const T *>(CS16 + 1)\n                : reinterpret_cast<const T *>(CS32 + 1);\n  }\n\n  const coff_aux_section_definition *getSectionDefinition() const {\n    if (!getNumberOfAuxSymbols() ||\n        getStorageClass() != COFF::IMAGE_SYM_CLASS_STATIC)\n      return nullptr;\n    return getAux<coff_aux_section_definition>();\n  }\n\n  const coff_aux_weak_external *getWeakExternal() const {\n    if (!getNumberOfAuxSymbols() ||\n        getStorageClass() != COFF::IMAGE_SYM_CLASS_WEAK_EXTERNAL)\n      return nullptr;\n    return getAux<coff_aux_weak_external>();\n  }\n\n  bool isAbsolute() const {\n    return getSectionNumber() == -1;\n  }\n\n  bool isExternal() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_EXTERNAL;\n  }\n\n  bool isCommon() const {\n    return isExternal() && getSectionNumber() == COFF::IMAGE_SYM_UNDEFINED &&\n           getValue() != 0;\n  }\n\n  bool isUndefined() const {\n    return isExternal() && getSectionNumber() == COFF::IMAGE_SYM_UNDEFINED &&\n           getValue() == 0;\n  }\n\n  bool isWeakExternal() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_WEAK_EXTERNAL;\n  }\n\n  bool isFunctionDefinition() const {\n    return isExternal() && getBaseType() == COFF::IMAGE_SYM_TYPE_NULL &&\n           getComplexType() == COFF::IMAGE_SYM_DTYPE_FUNCTION &&\n           !COFF::isReservedSectionNumber(getSectionNumber());\n  }\n\n  bool isFunctionLineInfo() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_FUNCTION;\n  }\n\n  bool isAnyUndefined() const {\n    return isUndefined() || isWeakExternal();\n  }\n\n  bool isFileRecord() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_FILE;\n  }\n\n  bool isSection() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_SECTION;\n  }\n\n  bool isSectionDefinition() const {\n    // C++/CLI creates external ABS symbols for non-const appdomain globals.\n    // These are also followed by an auxiliary section definition.\n    bool isAppdomainGlobal =\n        getStorageClass() == COFF::IMAGE_SYM_CLASS_EXTERNAL &&\n        getSectionNumber() == COFF::IMAGE_SYM_ABSOLUTE;\n    bool isOrdinarySection = getStorageClass() == COFF::IMAGE_SYM_CLASS_STATIC;\n    if (!getNumberOfAuxSymbols())\n      return false;\n    return isAppdomainGlobal || isOrdinarySection;\n  }\n\n  bool isCLRToken() const {\n    return getStorageClass() == COFF::IMAGE_SYM_CLASS_CLR_TOKEN;\n  }\n\nprivate:\n  bool isSet() const { return CS16 || CS32; }\n\n  const coff_symbol16 *CS16 = nullptr;\n  const coff_symbol32 *CS32 = nullptr;\n};\n\nstruct coff_section {\n  char Name[COFF::NameSize];\n  support::ulittle32_t VirtualSize;\n  support::ulittle32_t VirtualAddress;\n  support::ulittle32_t SizeOfRawData;\n  support::ulittle32_t PointerToRawData;\n  support::ulittle32_t PointerToRelocations;\n  support::ulittle32_t PointerToLinenumbers;\n  support::ulittle16_t NumberOfRelocations;\n  support::ulittle16_t NumberOfLinenumbers;\n  support::ulittle32_t Characteristics;\n\n  // Returns true if the actual number of relocations is stored in\n  // VirtualAddress field of the first relocation table entry.\n  bool hasExtendedRelocations() const {\n    return (Characteristics & COFF::IMAGE_SCN_LNK_NRELOC_OVFL) &&\n           NumberOfRelocations == UINT16_MAX;\n  }\n\n  uint32_t getAlignment() const {\n    // The IMAGE_SCN_TYPE_NO_PAD bit is a legacy way of getting to\n    // IMAGE_SCN_ALIGN_1BYTES.\n    if (Characteristics & COFF::IMAGE_SCN_TYPE_NO_PAD)\n      return 1;\n\n    // Bit [20:24] contains section alignment. 0 means use a default alignment\n    // of 16.\n    uint32_t Shift = (Characteristics >> 20) & 0xF;\n    if (Shift > 0)\n      return 1U << (Shift - 1);\n    return 16;\n  }\n};\n\nstruct coff_relocation {\n  support::ulittle32_t VirtualAddress;\n  support::ulittle32_t SymbolTableIndex;\n  support::ulittle16_t Type;\n};\n\nstruct coff_aux_function_definition {\n  support::ulittle32_t TagIndex;\n  support::ulittle32_t TotalSize;\n  support::ulittle32_t PointerToLinenumber;\n  support::ulittle32_t PointerToNextFunction;\n  char Unused1[2];\n};\n\nstatic_assert(sizeof(coff_aux_function_definition) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_bf_and_ef_symbol {\n  char Unused1[4];\n  support::ulittle16_t Linenumber;\n  char Unused2[6];\n  support::ulittle32_t PointerToNextFunction;\n  char Unused3[2];\n};\n\nstatic_assert(sizeof(coff_aux_bf_and_ef_symbol) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_weak_external {\n  support::ulittle32_t TagIndex;\n  support::ulittle32_t Characteristics;\n  char Unused1[10];\n};\n\nstatic_assert(sizeof(coff_aux_weak_external) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_section_definition {\n  support::ulittle32_t Length;\n  support::ulittle16_t NumberOfRelocations;\n  support::ulittle16_t NumberOfLinenumbers;\n  support::ulittle32_t CheckSum;\n  support::ulittle16_t NumberLowPart;\n  uint8_t              Selection;\n  uint8_t              Unused;\n  support::ulittle16_t NumberHighPart;\n  int32_t getNumber(bool IsBigObj) const {\n    uint32_t Number = static_cast<uint32_t>(NumberLowPart);\n    if (IsBigObj)\n      Number |= static_cast<uint32_t>(NumberHighPart) << 16;\n    return static_cast<int32_t>(Number);\n  }\n};\n\nstatic_assert(sizeof(coff_aux_section_definition) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_aux_clr_token {\n  uint8_t              AuxType;\n  uint8_t              Reserved;\n  support::ulittle32_t SymbolTableIndex;\n  char                 MBZ[12];\n};\n\nstatic_assert(sizeof(coff_aux_clr_token) == 18,\n              \"auxiliary entry must be 18 bytes\");\n\nstruct coff_import_header {\n  support::ulittle16_t Sig1;\n  support::ulittle16_t Sig2;\n  support::ulittle16_t Version;\n  support::ulittle16_t Machine;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle32_t SizeOfData;\n  support::ulittle16_t OrdinalHint;\n  support::ulittle16_t TypeInfo;\n\n  int getType() const { return TypeInfo & 0x3; }\n  int getNameType() const { return (TypeInfo >> 2) & 0x7; }\n};\n\nstruct coff_import_directory_table_entry {\n  support::ulittle32_t ImportLookupTableRVA;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle32_t ForwarderChain;\n  support::ulittle32_t NameRVA;\n  support::ulittle32_t ImportAddressTableRVA;\n\n  bool isNull() const {\n    return ImportLookupTableRVA == 0 && TimeDateStamp == 0 &&\n           ForwarderChain == 0 && NameRVA == 0 && ImportAddressTableRVA == 0;\n  }\n};\n\ntemplate <typename IntTy>\nstruct coff_tls_directory {\n  IntTy StartAddressOfRawData;\n  IntTy EndAddressOfRawData;\n  IntTy AddressOfIndex;\n  IntTy AddressOfCallBacks;\n  support::ulittle32_t SizeOfZeroFill;\n  support::ulittle32_t Characteristics;\n\n  uint32_t getAlignment() const {\n    // Bit [20:24] contains section alignment.\n    uint32_t Shift = (Characteristics & COFF::IMAGE_SCN_ALIGN_MASK) >> 20;\n    if (Shift > 0)\n      return 1U << (Shift - 1);\n    return 0;\n  }\n\n  void setAlignment(uint32_t Align) {\n    uint32_t AlignBits = 0;\n    if (Align) {\n      assert(llvm::isPowerOf2_32(Align) && \"alignment is not a power of 2\");\n      assert(llvm::Log2_32(Align) <= 13 && \"alignment requested is too large\");\n      AlignBits = (llvm::Log2_32(Align) + 1) << 20;\n    }\n    Characteristics =\n        (Characteristics & ~COFF::IMAGE_SCN_ALIGN_MASK) | AlignBits;\n  }\n};\n\nusing coff_tls_directory32 = coff_tls_directory<support::little32_t>;\nusing coff_tls_directory64 = coff_tls_directory<support::little64_t>;\n\n/// Bits in control flow guard flags as we understand them.\nenum class coff_guard_flags : uint32_t {\n  CFInstrumented = 0x00000100,\n  HasFidTable = 0x00000400,\n  ProtectDelayLoadIAT = 0x00001000,\n  DelayLoadIATSection = 0x00002000, // Delay load in separate section\n  HasLongJmpTable = 0x00010000,\n  FidTableHasFlags = 0x10000000, // Indicates that fid tables are 5 bytes\n};\n\nenum class frame_type : uint16_t { Fpo = 0, Trap = 1, Tss = 2, NonFpo = 3 };\n\nstruct coff_load_config_code_integrity {\n  support::ulittle16_t Flags;\n  support::ulittle16_t Catalog;\n  support::ulittle32_t CatalogOffset;\n  support::ulittle32_t Reserved;\n};\n\n/// 32-bit load config (IMAGE_LOAD_CONFIG_DIRECTORY32)\nstruct coff_load_configuration32 {\n  support::ulittle32_t Size;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t GlobalFlagsClear;\n  support::ulittle32_t GlobalFlagsSet;\n  support::ulittle32_t CriticalSectionDefaultTimeout;\n  support::ulittle32_t DeCommitFreeBlockThreshold;\n  support::ulittle32_t DeCommitTotalFreeThreshold;\n  support::ulittle32_t LockPrefixTable;\n  support::ulittle32_t MaximumAllocationSize;\n  support::ulittle32_t VirtualMemoryThreshold;\n  support::ulittle32_t ProcessAffinityMask;\n  support::ulittle32_t ProcessHeapFlags;\n  support::ulittle16_t CSDVersion;\n  support::ulittle16_t DependentLoadFlags;\n  support::ulittle32_t EditList;\n  support::ulittle32_t SecurityCookie;\n  support::ulittle32_t SEHandlerTable;\n  support::ulittle32_t SEHandlerCount;\n\n  // Added in MSVC 2015 for /guard:cf.\n  support::ulittle32_t GuardCFCheckFunction;\n  support::ulittle32_t GuardCFCheckDispatch;\n  support::ulittle32_t GuardCFFunctionTable;\n  support::ulittle32_t GuardCFFunctionCount;\n  support::ulittle32_t GuardFlags; // coff_guard_flags\n\n  // Added in MSVC 2017\n  coff_load_config_code_integrity CodeIntegrity;\n  support::ulittle32_t GuardAddressTakenIatEntryTable;\n  support::ulittle32_t GuardAddressTakenIatEntryCount;\n  support::ulittle32_t GuardLongJumpTargetTable;\n  support::ulittle32_t GuardLongJumpTargetCount;\n  support::ulittle32_t DynamicValueRelocTable;\n  support::ulittle32_t CHPEMetadataPointer;\n  support::ulittle32_t GuardRFFailureRoutine;\n  support::ulittle32_t GuardRFFailureRoutineFunctionPointer;\n  support::ulittle32_t DynamicValueRelocTableOffset;\n  support::ulittle16_t DynamicValueRelocTableSection;\n  support::ulittle16_t Reserved2;\n  support::ulittle32_t GuardRFVerifyStackPointerFunctionPointer;\n  support::ulittle32_t HotPatchTableOffset;\n};\n\n/// 64-bit load config (IMAGE_LOAD_CONFIG_DIRECTORY64)\nstruct coff_load_configuration64 {\n  support::ulittle32_t Size;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle32_t GlobalFlagsClear;\n  support::ulittle32_t GlobalFlagsSet;\n  support::ulittle32_t CriticalSectionDefaultTimeout;\n  support::ulittle64_t DeCommitFreeBlockThreshold;\n  support::ulittle64_t DeCommitTotalFreeThreshold;\n  support::ulittle64_t LockPrefixTable;\n  support::ulittle64_t MaximumAllocationSize;\n  support::ulittle64_t VirtualMemoryThreshold;\n  support::ulittle64_t ProcessAffinityMask;\n  support::ulittle32_t ProcessHeapFlags;\n  support::ulittle16_t CSDVersion;\n  support::ulittle16_t DependentLoadFlags;\n  support::ulittle64_t EditList;\n  support::ulittle64_t SecurityCookie;\n  support::ulittle64_t SEHandlerTable;\n  support::ulittle64_t SEHandlerCount;\n\n  // Added in MSVC 2015 for /guard:cf.\n  support::ulittle64_t GuardCFCheckFunction;\n  support::ulittle64_t GuardCFCheckDispatch;\n  support::ulittle64_t GuardCFFunctionTable;\n  support::ulittle64_t GuardCFFunctionCount;\n  support::ulittle32_t GuardFlags;\n\n  // Added in MSVC 2017\n  coff_load_config_code_integrity CodeIntegrity;\n  support::ulittle64_t GuardAddressTakenIatEntryTable;\n  support::ulittle64_t GuardAddressTakenIatEntryCount;\n  support::ulittle64_t GuardLongJumpTargetTable;\n  support::ulittle64_t GuardLongJumpTargetCount;\n  support::ulittle64_t DynamicValueRelocTable;\n  support::ulittle64_t CHPEMetadataPointer;\n  support::ulittle64_t GuardRFFailureRoutine;\n  support::ulittle64_t GuardRFFailureRoutineFunctionPointer;\n  support::ulittle32_t DynamicValueRelocTableOffset;\n  support::ulittle16_t DynamicValueRelocTableSection;\n  support::ulittle16_t Reserved2;\n  support::ulittle64_t GuardRFVerifyStackPointerFunctionPointer;\n  support::ulittle32_t HotPatchTableOffset;\n};\n\nstruct coff_runtime_function_x64 {\n  support::ulittle32_t BeginAddress;\n  support::ulittle32_t EndAddress;\n  support::ulittle32_t UnwindInformation;\n};\n\nstruct coff_base_reloc_block_header {\n  support::ulittle32_t PageRVA;\n  support::ulittle32_t BlockSize;\n};\n\nstruct coff_base_reloc_block_entry {\n  support::ulittle16_t Data;\n\n  int getType() const { return Data >> 12; }\n  int getOffset() const { return Data & ((1 << 12) - 1); }\n};\n\nstruct coff_resource_dir_entry {\n  union {\n    support::ulittle32_t NameOffset;\n    support::ulittle32_t ID;\n    uint32_t getNameOffset() const {\n      return maskTrailingOnes<uint32_t>(31) & NameOffset;\n    }\n    // Even though the PE/COFF spec doesn't mention this, the high bit of a name\n    // offset is set.\n    void setNameOffset(uint32_t Offset) { NameOffset = Offset | (1 << 31); }\n  } Identifier;\n  union {\n    support::ulittle32_t DataEntryOffset;\n    support::ulittle32_t SubdirOffset;\n\n    bool isSubDir() const { return SubdirOffset >> 31; }\n    uint32_t value() const {\n      return maskTrailingOnes<uint32_t>(31) & SubdirOffset;\n    }\n\n  } Offset;\n};\n\nstruct coff_resource_data_entry {\n  support::ulittle32_t DataRVA;\n  support::ulittle32_t DataSize;\n  support::ulittle32_t Codepage;\n  support::ulittle32_t Reserved;\n};\n\nstruct coff_resource_dir_table {\n  support::ulittle32_t Characteristics;\n  support::ulittle32_t TimeDateStamp;\n  support::ulittle16_t MajorVersion;\n  support::ulittle16_t MinorVersion;\n  support::ulittle16_t NumberOfNameEntries;\n  support::ulittle16_t NumberOfIDEntries;\n};\n\nstruct debug_h_header {\n  support::ulittle32_t Magic;\n  support::ulittle16_t Version;\n  support::ulittle16_t HashAlgorithm;\n};\n\nclass COFFObjectFile : public ObjectFile {\nprivate:\n  COFFObjectFile(MemoryBufferRef Object);\n\n  friend class ImportDirectoryEntryRef;\n  friend class ExportDirectoryEntryRef;\n  const coff_file_header *COFFHeader;\n  const coff_bigobj_file_header *COFFBigObjHeader;\n  const pe32_header *PE32Header;\n  const pe32plus_header *PE32PlusHeader;\n  const data_directory *DataDirectory;\n  const coff_section *SectionTable;\n  const coff_symbol16 *SymbolTable16;\n  const coff_symbol32 *SymbolTable32;\n  const char *StringTable;\n  uint32_t StringTableSize;\n  const coff_import_directory_table_entry *ImportDirectory;\n  const delay_import_directory_table_entry *DelayImportDirectory;\n  uint32_t NumberOfDelayImportDirectory;\n  const export_directory_table_entry *ExportDirectory;\n  const coff_base_reloc_block_header *BaseRelocHeader;\n  const coff_base_reloc_block_header *BaseRelocEnd;\n  const debug_directory *DebugDirectoryBegin;\n  const debug_directory *DebugDirectoryEnd;\n  const coff_tls_directory32 *TLSDirectory32;\n  const coff_tls_directory64 *TLSDirectory64;\n  // Either coff_load_configuration32 or coff_load_configuration64.\n  const void *LoadConfig = nullptr;\n\n  Expected<StringRef> getString(uint32_t offset) const;\n\n  template <typename coff_symbol_type>\n  const coff_symbol_type *toSymb(DataRefImpl Symb) const;\n  const coff_section *toSec(DataRefImpl Sec) const;\n  const coff_relocation *toRel(DataRefImpl Rel) const;\n\n  // Finish initializing the object and return success or an error.\n  Error initialize();\n\n  Error initSymbolTablePtr();\n  Error initImportTablePtr();\n  Error initDelayImportTablePtr();\n  Error initExportTablePtr();\n  Error initBaseRelocPtr();\n  Error initDebugDirectoryPtr();\n  Error initTLSDirectoryPtr();\n  Error initLoadConfigPtr();\n\npublic:\n  static Expected<std::unique_ptr<COFFObjectFile>>\n  create(MemoryBufferRef Object);\n\n  uintptr_t getSymbolTable() const {\n    if (SymbolTable16)\n      return reinterpret_cast<uintptr_t>(SymbolTable16);\n    if (SymbolTable32)\n      return reinterpret_cast<uintptr_t>(SymbolTable32);\n    return uintptr_t(0);\n  }\n\n  uint16_t getMachine() const {\n    if (COFFHeader)\n      return COFFHeader->Machine;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->Machine;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint16_t getSizeOfOptionalHeader() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0\n                                           : COFFHeader->SizeOfOptionalHeader;\n    // bigobj doesn't have this field.\n    if (COFFBigObjHeader)\n      return 0;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint16_t getCharacteristics() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0 : COFFHeader->Characteristics;\n    // bigobj doesn't have characteristics to speak of,\n    // editbin will silently lie to you if you attempt to set any.\n    if (COFFBigObjHeader)\n      return 0;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getTimeDateStamp() const {\n    if (COFFHeader)\n      return COFFHeader->TimeDateStamp;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->TimeDateStamp;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getNumberOfSections() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0 : COFFHeader->NumberOfSections;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->NumberOfSections;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getPointerToSymbolTable() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0\n                                           : COFFHeader->PointerToSymbolTable;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->PointerToSymbolTable;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getRawNumberOfSymbols() const {\n    if (COFFHeader)\n      return COFFHeader->isImportLibrary() ? 0 : COFFHeader->NumberOfSymbols;\n    if (COFFBigObjHeader)\n      return COFFBigObjHeader->NumberOfSymbols;\n    llvm_unreachable(\"no COFF header!\");\n  }\n\n  uint32_t getNumberOfSymbols() const {\n    if (!SymbolTable16 && !SymbolTable32)\n      return 0;\n    return getRawNumberOfSymbols();\n  }\n\n  uint32_t getStringTableSize() const { return StringTableSize; }\n\n  const coff_load_configuration32 *getLoadConfig32() const {\n    assert(!is64());\n    return reinterpret_cast<const coff_load_configuration32 *>(LoadConfig);\n  }\n\n  const coff_load_configuration64 *getLoadConfig64() const {\n    assert(is64());\n    return reinterpret_cast<const coff_load_configuration64 *>(LoadConfig);\n  }\n  StringRef getRelocationTypeName(uint16_t Type) const;\n\nprotected:\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n\npublic:\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  const coff_section *getCOFFSection(const SectionRef &Section) const;\n  COFFSymbolRef getCOFFSymbol(const DataRefImpl &Ref) const;\n  COFFSymbolRef getCOFFSymbol(const SymbolRef &Symbol) const;\n  const coff_relocation *getCOFFRelocation(const RelocationRef &Reloc) const;\n  unsigned getSectionID(SectionRef Sec) const;\n  unsigned getSymbolSectionID(SymbolRef Sym) const;\n\n  uint8_t getBytesInAddress() const override;\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  Expected<uint64_t> getStartAddress() const override;\n  SubtargetFeatures getFeatures() const override { return SubtargetFeatures(); }\n\n  import_directory_iterator import_directory_begin() const;\n  import_directory_iterator import_directory_end() const;\n  delay_import_directory_iterator delay_import_directory_begin() const;\n  delay_import_directory_iterator delay_import_directory_end() const;\n  export_directory_iterator export_directory_begin() const;\n  export_directory_iterator export_directory_end() const;\n  base_reloc_iterator base_reloc_begin() const;\n  base_reloc_iterator base_reloc_end() const;\n  const debug_directory *debug_directory_begin() const {\n    return DebugDirectoryBegin;\n  }\n  const debug_directory *debug_directory_end() const {\n    return DebugDirectoryEnd;\n  }\n\n  iterator_range<import_directory_iterator> import_directories() const;\n  iterator_range<delay_import_directory_iterator>\n      delay_import_directories() const;\n  iterator_range<export_directory_iterator> export_directories() const;\n  iterator_range<base_reloc_iterator> base_relocs() const;\n  iterator_range<const debug_directory *> debug_directories() const {\n    return make_range(debug_directory_begin(), debug_directory_end());\n  }\n\n  const coff_tls_directory32 *getTLSDirectory32() const {\n    return TLSDirectory32;\n  }\n  const coff_tls_directory64 *getTLSDirectory64() const {\n    return TLSDirectory64;\n  }\n\n  const dos_header *getDOSHeader() const {\n    if (!PE32Header && !PE32PlusHeader)\n      return nullptr;\n    return reinterpret_cast<const dos_header *>(base());\n  }\n\n  const coff_file_header *getCOFFHeader() const { return COFFHeader; }\n  const coff_bigobj_file_header *getCOFFBigObjHeader() const {\n    return COFFBigObjHeader;\n  }\n  const pe32_header *getPE32Header() const { return PE32Header; }\n  const pe32plus_header *getPE32PlusHeader() const { return PE32PlusHeader; }\n\n  const data_directory *getDataDirectory(uint32_t index) const;\n  Expected<const coff_section *> getSection(int32_t index) const;\n\n  Expected<COFFSymbolRef> getSymbol(uint32_t index) const {\n    if (index >= getNumberOfSymbols())\n      return errorCodeToError(object_error::parse_failed);\n    if (SymbolTable16)\n      return COFFSymbolRef(SymbolTable16 + index);\n    if (SymbolTable32)\n      return COFFSymbolRef(SymbolTable32 + index);\n    return errorCodeToError(object_error::parse_failed);\n  }\n\n  template <typename T>\n  Error getAuxSymbol(uint32_t index, const T *&Res) const {\n    Expected<COFFSymbolRef> S = getSymbol(index);\n    if (Error E = S.takeError())\n      return E;\n    Res = reinterpret_cast<const T *>(S->getRawPtr());\n    return Error::success();\n  }\n\n  Expected<StringRef> getSymbolName(COFFSymbolRef Symbol) const;\n  Expected<StringRef> getSymbolName(const coff_symbol_generic *Symbol) const;\n\n  ArrayRef<uint8_t> getSymbolAuxData(COFFSymbolRef Symbol) const;\n\n  uint32_t getSymbolIndex(COFFSymbolRef Symbol) const;\n\n  size_t getSymbolTableEntrySize() const {\n    if (COFFHeader)\n      return sizeof(coff_symbol16);\n    if (COFFBigObjHeader)\n      return sizeof(coff_symbol32);\n    llvm_unreachable(\"null symbol table pointer!\");\n  }\n\n  ArrayRef<coff_relocation> getRelocations(const coff_section *Sec) const;\n\n  Expected<StringRef> getSectionName(const coff_section *Sec) const;\n  uint64_t getSectionSize(const coff_section *Sec) const;\n  Error getSectionContents(const coff_section *Sec,\n                           ArrayRef<uint8_t> &Res) const;\n\n  uint64_t getImageBase() const;\n  Error getVaPtr(uint64_t VA, uintptr_t &Res) const;\n  Error getRvaPtr(uint32_t Rva, uintptr_t &Res) const;\n\n  /// Given an RVA base and size, returns a valid array of bytes or an error\n  /// code if the RVA and size is not contained completely within a valid\n  /// section.\n  Error getRvaAndSizeAsBytes(uint32_t RVA, uint32_t Size,\n                             ArrayRef<uint8_t> &Contents) const;\n\n  Error getHintName(uint32_t Rva, uint16_t &Hint,\n                              StringRef &Name) const;\n\n  /// Get PDB information out of a codeview debug directory entry.\n  Error getDebugPDBInfo(const debug_directory *DebugDir,\n                        const codeview::DebugInfo *&Info,\n                        StringRef &PDBFileName) const;\n\n  /// Get PDB information from an executable. If the information is not present,\n  /// Info will be set to nullptr and PDBFileName will be empty. An error is\n  /// returned only on corrupt object files. Convenience accessor that can be\n  /// used if the debug directory is not already handy.\n  Error getDebugPDBInfo(const codeview::DebugInfo *&Info,\n                        StringRef &PDBFileName) const;\n\n  bool isRelocatableObject() const override;\n  bool is64() const { return PE32PlusHeader; }\n\n  StringRef mapDebugSectionName(StringRef Name) const override;\n\n  static bool classof(const Binary *v) { return v->isCOFF(); }\n};\n\n// The iterator for the import directory table.\nclass ImportDirectoryEntryRef {\npublic:\n  ImportDirectoryEntryRef() = default;\n  ImportDirectoryEntryRef(const coff_import_directory_table_entry *Table,\n                          uint32_t I, const COFFObjectFile *Owner)\n      : ImportTable(Table), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const ImportDirectoryEntryRef &Other) const;\n  void moveNext();\n\n  imported_symbol_iterator imported_symbol_begin() const;\n  imported_symbol_iterator imported_symbol_end() const;\n  iterator_range<imported_symbol_iterator> imported_symbols() const;\n\n  imported_symbol_iterator lookup_table_begin() const;\n  imported_symbol_iterator lookup_table_end() const;\n  iterator_range<imported_symbol_iterator> lookup_table_symbols() const;\n\n  Error getName(StringRef &Result) const;\n  Error getImportLookupTableRVA(uint32_t &Result) const;\n  Error getImportAddressTableRVA(uint32_t &Result) const;\n\n  Error\n  getImportTableEntry(const coff_import_directory_table_entry *&Result) const;\n\nprivate:\n  const coff_import_directory_table_entry *ImportTable;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\nclass DelayImportDirectoryEntryRef {\npublic:\n  DelayImportDirectoryEntryRef() = default;\n  DelayImportDirectoryEntryRef(const delay_import_directory_table_entry *T,\n                               uint32_t I, const COFFObjectFile *Owner)\n      : Table(T), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const DelayImportDirectoryEntryRef &Other) const;\n  void moveNext();\n\n  imported_symbol_iterator imported_symbol_begin() const;\n  imported_symbol_iterator imported_symbol_end() const;\n  iterator_range<imported_symbol_iterator> imported_symbols() const;\n\n  Error getName(StringRef &Result) const;\n  Error getDelayImportTable(\n      const delay_import_directory_table_entry *&Result) const;\n  Error getImportAddress(int AddrIndex, uint64_t &Result) const;\n\nprivate:\n  const delay_import_directory_table_entry *Table;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\n// The iterator for the export directory table entry.\nclass ExportDirectoryEntryRef {\npublic:\n  ExportDirectoryEntryRef() = default;\n  ExportDirectoryEntryRef(const export_directory_table_entry *Table, uint32_t I,\n                          const COFFObjectFile *Owner)\n      : ExportTable(Table), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const ExportDirectoryEntryRef &Other) const;\n  void moveNext();\n\n  Error getDllName(StringRef &Result) const;\n  Error getOrdinalBase(uint32_t &Result) const;\n  Error getOrdinal(uint32_t &Result) const;\n  Error getExportRVA(uint32_t &Result) const;\n  Error getSymbolName(StringRef &Result) const;\n\n  Error isForwarder(bool &Result) const;\n  Error getForwardTo(StringRef &Result) const;\n\nprivate:\n  const export_directory_table_entry *ExportTable;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\nclass ImportedSymbolRef {\npublic:\n  ImportedSymbolRef() = default;\n  ImportedSymbolRef(const import_lookup_table_entry32 *Entry, uint32_t I,\n                    const COFFObjectFile *Owner)\n      : Entry32(Entry), Entry64(nullptr), Index(I), OwningObject(Owner) {}\n  ImportedSymbolRef(const import_lookup_table_entry64 *Entry, uint32_t I,\n                    const COFFObjectFile *Owner)\n      : Entry32(nullptr), Entry64(Entry), Index(I), OwningObject(Owner) {}\n\n  bool operator==(const ImportedSymbolRef &Other) const;\n  void moveNext();\n\n  Error getSymbolName(StringRef &Result) const;\n  Error isOrdinal(bool &Result) const;\n  Error getOrdinal(uint16_t &Result) const;\n  Error getHintNameRVA(uint32_t &Result) const;\n\nprivate:\n  const import_lookup_table_entry32 *Entry32;\n  const import_lookup_table_entry64 *Entry64;\n  uint32_t Index;\n  const COFFObjectFile *OwningObject = nullptr;\n};\n\nclass BaseRelocRef {\npublic:\n  BaseRelocRef() = default;\n  BaseRelocRef(const coff_base_reloc_block_header *Header,\n               const COFFObjectFile *Owner)\n      : Header(Header), Index(0) {}\n\n  bool operator==(const BaseRelocRef &Other) const;\n  void moveNext();\n\n  Error getType(uint8_t &Type) const;\n  Error getRVA(uint32_t &Result) const;\n\nprivate:\n  const coff_base_reloc_block_header *Header;\n  uint32_t Index;\n};\n\nclass ResourceSectionRef {\npublic:\n  ResourceSectionRef() = default;\n  explicit ResourceSectionRef(StringRef Ref) : BBS(Ref, support::little) {}\n\n  Error load(const COFFObjectFile *O);\n  Error load(const COFFObjectFile *O, const SectionRef &S);\n\n  Expected<ArrayRef<UTF16>>\n  getEntryNameString(const coff_resource_dir_entry &Entry);\n  Expected<const coff_resource_dir_table &>\n  getEntrySubDir(const coff_resource_dir_entry &Entry);\n  Expected<const coff_resource_data_entry &>\n  getEntryData(const coff_resource_dir_entry &Entry);\n  Expected<const coff_resource_dir_table &> getBaseTable();\n  Expected<const coff_resource_dir_entry &>\n  getTableEntry(const coff_resource_dir_table &Table, uint32_t Index);\n\n  Expected<StringRef> getContents(const coff_resource_data_entry &Entry);\n\nprivate:\n  BinaryByteStream BBS;\n\n  SectionRef Section;\n  const COFFObjectFile *Obj;\n\n  std::vector<const coff_relocation *> Relocs;\n\n  Expected<const coff_resource_dir_table &> getTableAtOffset(uint32_t Offset);\n  Expected<const coff_resource_dir_entry &>\n  getTableEntryAtOffset(uint32_t Offset);\n  Expected<const coff_resource_data_entry &>\n  getDataEntryAtOffset(uint32_t Offset);\n  Expected<ArrayRef<UTF16>> getDirStringAtOffset(uint32_t Offset);\n};\n\n// Corresponds to `_FPO_DATA` structure in the PE/COFF spec.\nstruct FpoData {\n  support::ulittle32_t Offset; // ulOffStart: Offset 1st byte of function code\n  support::ulittle32_t Size;   // cbProcSize: # bytes in function\n  support::ulittle32_t NumLocals; // cdwLocals: # bytes in locals/4\n  support::ulittle16_t NumParams; // cdwParams: # bytes in params/4\n  support::ulittle16_t Attributes;\n\n  // cbProlog: # bytes in prolog\n  int getPrologSize() const { return Attributes & 0xF; }\n\n  // cbRegs: # regs saved\n  int getNumSavedRegs() const { return (Attributes >> 8) & 0x7; }\n\n  // fHasSEH: true if seh is func\n  bool hasSEH() const { return (Attributes >> 9) & 1; }\n\n  // fUseBP: true if EBP has been allocated\n  bool useBP() const { return (Attributes >> 10) & 1; }\n\n  // cbFrame: frame pointer\n  frame_type getFP() const { return static_cast<frame_type>(Attributes >> 14); }\n};\n\n} // end namespace object\n\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_COFF_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "content": "//===- ELF.h - ELF object file implementation -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ELFFile template class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ELF_H\n#define LLVM_OBJECT_ELF_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/Object/ELFTypes.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n\nnamespace llvm {\nnamespace object {\n\nstruct VerdAux {\n  unsigned Offset;\n  std::string Name;\n};\n\nstruct VerDef {\n  unsigned Offset;\n  unsigned Version;\n  unsigned Flags;\n  unsigned Ndx;\n  unsigned Cnt;\n  unsigned Hash;\n  std::string Name;\n  std::vector<VerdAux> AuxV;\n};\n\nstruct VernAux {\n  unsigned Hash;\n  unsigned Flags;\n  unsigned Other;\n  unsigned Offset;\n  std::string Name;\n};\n\nstruct VerNeed {\n  unsigned Version;\n  unsigned Cnt;\n  unsigned Offset;\n  std::string File;\n  std::vector<VernAux> AuxV;\n};\n\nstruct VersionEntry {\n  std::string Name;\n  bool IsVerDef;\n};\n\nStringRef getELFRelocationTypeName(uint32_t Machine, uint32_t Type);\nuint32_t getELFRelativeRelocationType(uint32_t Machine);\nStringRef getELFSectionTypeName(uint32_t Machine, uint32_t Type);\n\n// Subclasses of ELFFile may need this for template instantiation\ninline std::pair<unsigned char, unsigned char>\ngetElfArchType(StringRef Object) {\n  if (Object.size() < ELF::EI_NIDENT)\n    return std::make_pair((uint8_t)ELF::ELFCLASSNONE,\n                          (uint8_t)ELF::ELFDATANONE);\n  return std::make_pair((uint8_t)Object[ELF::EI_CLASS],\n                        (uint8_t)Object[ELF::EI_DATA]);\n}\n\nstatic inline Error createError(const Twine &Err) {\n  return make_error<StringError>(Err, object_error::parse_failed);\n}\n\nenum PPCInstrMasks : uint64_t {\n  PADDI_R12_NO_DISP = 0x0610000039800000,\n  ADDIS_R12_TO_R2_NO_DISP = 0x3D820000,\n  ADDI_R12_TO_R2_NO_DISP = 0x39820000,\n  ADDI_R12_TO_R12_NO_DISP = 0x398C0000,\n  PLD_R12_NO_DISP = 0x04100000E5800000,\n  MTCTR_R12 = 0x7D8903A6,\n  BCTR = 0x4E800420,\n};\n\ntemplate <class ELFT> class ELFFile;\n\ntemplate <class T> struct DataRegion {\n  // This constructor is used when we know the start and the size of a data\n  // region. We assume that Arr does not go past the end of the file.\n  DataRegion(ArrayRef<T> Arr) : First(Arr.data()), Size(Arr.size()) {}\n\n  // Sometimes we only know the start of a data region. We still don't want to\n  // read past the end of the file, so we provide the end of a buffer.\n  DataRegion(const T *Data, const uint8_t *BufferEnd)\n      : First(Data), BufEnd(BufferEnd) {}\n\n  Expected<T> operator[](uint64_t N) {\n    assert(Size || BufEnd);\n    if (Size) {\n      if (N >= *Size)\n        return createError(\n            \"the index is greater than or equal to the number of entries (\" +\n            Twine(*Size) + \")\");\n    } else {\n      const uint8_t *EntryStart = (const uint8_t *)First + N * sizeof(T);\n      if (EntryStart + sizeof(T) > BufEnd)\n        return createError(\"can't read past the end of the file\");\n    }\n    return *(First + N);\n  }\n\n  const T *First;\n  Optional<uint64_t> Size = None;\n  const uint8_t *BufEnd = nullptr;\n};\n\ntemplate <class ELFT>\nstd::string getSecIndexForError(const ELFFile<ELFT> &Obj,\n                                const typename ELFT::Shdr &Sec) {\n  auto TableOrErr = Obj.sections();\n  if (TableOrErr)\n    return \"[index \" + std::to_string(&Sec - &TableOrErr->front()) + \"]\";\n  // To make this helper be more convenient for error reporting purposes we\n  // drop the error. But really it should never be triggered. Before this point,\n  // our code should have called 'sections()' and reported a proper error on\n  // failure.\n  llvm::consumeError(TableOrErr.takeError());\n  return \"[unknown index]\";\n}\n\ntemplate <class ELFT>\nstatic std::string describe(const ELFFile<ELFT> &Obj,\n                            const typename ELFT::Shdr &Sec) {\n  unsigned SecNdx = &Sec - &cantFail(Obj.sections()).front();\n  return (object::getELFSectionTypeName(Obj.getHeader().e_machine,\n                                        Sec.sh_type) +\n          \" section with index \" + Twine(SecNdx))\n      .str();\n}\n\ntemplate <class ELFT>\nstd::string getPhdrIndexForError(const ELFFile<ELFT> &Obj,\n                                 const typename ELFT::Phdr &Phdr) {\n  auto Headers = Obj.program_headers();\n  if (Headers)\n    return (\"[index \" + Twine(&Phdr - &Headers->front()) + \"]\").str();\n  // See comment in the getSecIndexForError() above.\n  llvm::consumeError(Headers.takeError());\n  return \"[unknown index]\";\n}\n\nstatic inline Error defaultWarningHandler(const Twine &Msg) {\n  return createError(Msg);\n}\n\ntemplate <class ELFT>\nclass ELFFile {\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  // This is a callback that can be passed to a number of functions.\n  // It can be used to ignore non-critical errors (warnings), which is\n  // useful for dumpers, like llvm-readobj.\n  // It accepts a warning message string and returns a success\n  // when the warning should be ignored or an error otherwise.\n  using WarningHandler = llvm::function_ref<Error(const Twine &Msg)>;\n\n  const uint8_t *base() const { return Buf.bytes_begin(); }\n  const uint8_t *end() const { return base() + getBufSize(); }\n\n  size_t getBufSize() const { return Buf.size(); }\n\nprivate:\n  StringRef Buf;\n\n  ELFFile(StringRef Object);\n\npublic:\n  const Elf_Ehdr &getHeader() const {\n    return *reinterpret_cast<const Elf_Ehdr *>(base());\n  }\n\n  template <typename T>\n  Expected<const T *> getEntry(uint32_t Section, uint32_t Entry) const;\n  template <typename T>\n  Expected<const T *> getEntry(const Elf_Shdr &Section, uint32_t Entry) const;\n\n  Expected<std::vector<VerDef>>\n  getVersionDefinitions(const Elf_Shdr &Sec) const;\n  Expected<std::vector<VerNeed>> getVersionDependencies(\n      const Elf_Shdr &Sec,\n      WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<StringRef>\n  getSymbolVersionByIndex(uint32_t SymbolVersionIndex, bool &IsDefault,\n                          SmallVector<Optional<VersionEntry>, 0> &VersionMap,\n                          Optional<bool> IsSymHidden) const;\n\n  Expected<StringRef>\n  getStringTable(const Elf_Shdr &Section,\n                 WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<StringRef> getStringTableForSymtab(const Elf_Shdr &Section) const;\n  Expected<StringRef> getStringTableForSymtab(const Elf_Shdr &Section,\n                                              Elf_Shdr_Range Sections) const;\n  Expected<StringRef> getLinkAsStrtab(const typename ELFT::Shdr &Sec) const;\n\n  Expected<ArrayRef<Elf_Word>> getSHNDXTable(const Elf_Shdr &Section) const;\n  Expected<ArrayRef<Elf_Word>> getSHNDXTable(const Elf_Shdr &Section,\n                                             Elf_Shdr_Range Sections) const;\n\n  Expected<uint64_t> getDynSymtabSize() const;\n\n  StringRef getRelocationTypeName(uint32_t Type) const;\n  void getRelocationTypeName(uint32_t Type,\n                             SmallVectorImpl<char> &Result) const;\n  uint32_t getRelativeRelocationType() const;\n\n  std::string getDynamicTagAsString(unsigned Arch, uint64_t Type) const;\n  std::string getDynamicTagAsString(uint64_t Type) const;\n\n  /// Get the symbol for a given relocation.\n  Expected<const Elf_Sym *> getRelocationSymbol(const Elf_Rel &Rel,\n                                                const Elf_Shdr *SymTab) const;\n\n  Expected<SmallVector<Optional<VersionEntry>, 0>>\n  loadVersionMap(const Elf_Shdr *VerNeedSec, const Elf_Shdr *VerDefSec) const;\n\n  static Expected<ELFFile> create(StringRef Object);\n\n  bool isLE() const {\n    return getHeader().getDataEncoding() == ELF::ELFDATA2LSB;\n  }\n\n  bool isMipsELF64() const {\n    return getHeader().e_machine == ELF::EM_MIPS &&\n           getHeader().getFileClass() == ELF::ELFCLASS64;\n  }\n\n  bool isMips64EL() const { return isMipsELF64() && isLE(); }\n\n  Expected<Elf_Shdr_Range> sections() const;\n\n  Expected<Elf_Dyn_Range> dynamicEntries() const;\n\n  Expected<const uint8_t *>\n  toMappedAddr(uint64_t VAddr,\n               WarningHandler WarnHandler = &defaultWarningHandler) const;\n\n  Expected<Elf_Sym_Range> symbols(const Elf_Shdr *Sec) const {\n    if (!Sec)\n      return makeArrayRef<Elf_Sym>(nullptr, nullptr);\n    return getSectionContentsAsArray<Elf_Sym>(*Sec);\n  }\n\n  Expected<Elf_Rela_Range> relas(const Elf_Shdr &Sec) const {\n    return getSectionContentsAsArray<Elf_Rela>(Sec);\n  }\n\n  Expected<Elf_Rel_Range> rels(const Elf_Shdr &Sec) const {\n    return getSectionContentsAsArray<Elf_Rel>(Sec);\n  }\n\n  Expected<Elf_Relr_Range> relrs(const Elf_Shdr &Sec) const {\n    return getSectionContentsAsArray<Elf_Relr>(Sec);\n  }\n\n  std::vector<Elf_Rel> decode_relrs(Elf_Relr_Range relrs) const;\n\n  Expected<std::vector<Elf_Rela>> android_relas(const Elf_Shdr &Sec) const;\n\n  /// Iterate over program header table.\n  Expected<Elf_Phdr_Range> program_headers() const {\n    if (getHeader().e_phnum && getHeader().e_phentsize != sizeof(Elf_Phdr))\n      return createError(\"invalid e_phentsize: \" +\n                         Twine(getHeader().e_phentsize));\n\n    uint64_t HeadersSize =\n        (uint64_t)getHeader().e_phnum * getHeader().e_phentsize;\n    uint64_t PhOff = getHeader().e_phoff;\n    if (PhOff + HeadersSize < PhOff || PhOff + HeadersSize > getBufSize())\n      return createError(\"program headers are longer than binary of size \" +\n                         Twine(getBufSize()) + \": e_phoff = 0x\" +\n                         Twine::utohexstr(getHeader().e_phoff) +\n                         \", e_phnum = \" + Twine(getHeader().e_phnum) +\n                         \", e_phentsize = \" + Twine(getHeader().e_phentsize));\n\n    auto *Begin = reinterpret_cast<const Elf_Phdr *>(base() + PhOff);\n    return makeArrayRef(Begin, Begin + getHeader().e_phnum);\n  }\n\n  /// Get an iterator over notes in a program header.\n  ///\n  /// The program header must be of type \\c PT_NOTE.\n  ///\n  /// \\param Phdr the program header to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  Elf_Note_Iterator notes_begin(const Elf_Phdr &Phdr, Error &Err) const {\n    assert(Phdr.p_type == ELF::PT_NOTE && \"Phdr is not of type PT_NOTE\");\n    ErrorAsOutParameter ErrAsOutParam(&Err);\n    if (Phdr.p_offset + Phdr.p_filesz > getBufSize()) {\n      Err =\n          createError(\"invalid offset (0x\" + Twine::utohexstr(Phdr.p_offset) +\n                      \") or size (0x\" + Twine::utohexstr(Phdr.p_filesz) + \")\");\n      return Elf_Note_Iterator(Err);\n    }\n    return Elf_Note_Iterator(base() + Phdr.p_offset, Phdr.p_filesz, Err);\n  }\n\n  /// Get an iterator over notes in a section.\n  ///\n  /// The section must be of type \\c SHT_NOTE.\n  ///\n  /// \\param Shdr the section to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  Elf_Note_Iterator notes_begin(const Elf_Shdr &Shdr, Error &Err) const {\n    assert(Shdr.sh_type == ELF::SHT_NOTE && \"Shdr is not of type SHT_NOTE\");\n    ErrorAsOutParameter ErrAsOutParam(&Err);\n    if (Shdr.sh_offset + Shdr.sh_size > getBufSize()) {\n      Err =\n          createError(\"invalid offset (0x\" + Twine::utohexstr(Shdr.sh_offset) +\n                      \") or size (0x\" + Twine::utohexstr(Shdr.sh_size) + \")\");\n      return Elf_Note_Iterator(Err);\n    }\n    return Elf_Note_Iterator(base() + Shdr.sh_offset, Shdr.sh_size, Err);\n  }\n\n  /// Get the end iterator for notes.\n  Elf_Note_Iterator notes_end() const {\n    return Elf_Note_Iterator();\n  }\n\n  /// Get an iterator range over notes of a program header.\n  ///\n  /// The program header must be of type \\c PT_NOTE.\n  ///\n  /// \\param Phdr the program header to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  iterator_range<Elf_Note_Iterator> notes(const Elf_Phdr &Phdr,\n                                          Error &Err) const {\n    return make_range(notes_begin(Phdr, Err), notes_end());\n  }\n\n  /// Get an iterator range over notes of a section.\n  ///\n  /// The section must be of type \\c SHT_NOTE.\n  ///\n  /// \\param Shdr the section to iterate over.\n  /// \\param Err [out] an error to support fallible iteration, which should\n  ///  be checked after iteration ends.\n  iterator_range<Elf_Note_Iterator> notes(const Elf_Shdr &Shdr,\n                                          Error &Err) const {\n    return make_range(notes_begin(Shdr, Err), notes_end());\n  }\n\n  Expected<StringRef> getSectionStringTable(\n      Elf_Shdr_Range Sections,\n      WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<uint32_t> getSectionIndex(const Elf_Sym &Sym, Elf_Sym_Range Syms,\n                                     DataRegion<Elf_Word> ShndxTable) const;\n  Expected<const Elf_Shdr *> getSection(const Elf_Sym &Sym,\n                                        const Elf_Shdr *SymTab,\n                                        DataRegion<Elf_Word> ShndxTable) const;\n  Expected<const Elf_Shdr *> getSection(const Elf_Sym &Sym,\n                                        Elf_Sym_Range Symtab,\n                                        DataRegion<Elf_Word> ShndxTable) const;\n  Expected<const Elf_Shdr *> getSection(uint32_t Index) const;\n\n  Expected<const Elf_Sym *> getSymbol(const Elf_Shdr *Sec,\n                                      uint32_t Index) const;\n\n  Expected<StringRef>\n  getSectionName(const Elf_Shdr &Section,\n                 WarningHandler WarnHandler = &defaultWarningHandler) const;\n  Expected<StringRef> getSectionName(const Elf_Shdr &Section,\n                                     StringRef DotShstrtab) const;\n  template <typename T>\n  Expected<ArrayRef<T>> getSectionContentsAsArray(const Elf_Shdr &Sec) const;\n  Expected<ArrayRef<uint8_t>> getSectionContents(const Elf_Shdr &Sec) const;\n  Expected<ArrayRef<uint8_t>> getSegmentContents(const Elf_Phdr &Phdr) const;\n  Expected<std::vector<Elf_BBAddrMap>>\n  decodeBBAddrMap(const Elf_Shdr &Sec) const;\n};\n\nusing ELF32LEFile = ELFFile<ELF32LE>;\nusing ELF64LEFile = ELFFile<ELF64LE>;\nusing ELF32BEFile = ELFFile<ELF32BE>;\nusing ELF64BEFile = ELFFile<ELF64BE>;\n\ntemplate <class ELFT>\ninline Expected<const typename ELFT::Shdr *>\ngetSection(typename ELFT::ShdrRange Sections, uint32_t Index) {\n  if (Index >= Sections.size())\n    return createError(\"invalid section index: \" + Twine(Index));\n  return &Sections[Index];\n}\n\ntemplate <class ELFT>\ninline Expected<uint32_t>\ngetExtendedSymbolTableIndex(const typename ELFT::Sym &Sym, unsigned SymIndex,\n                            DataRegion<typename ELFT::Word> ShndxTable) {\n  assert(Sym.st_shndx == ELF::SHN_XINDEX);\n  if (!ShndxTable.First)\n    return createError(\n        \"found an extended symbol index (\" + Twine(SymIndex) +\n        \"), but unable to locate the extended symbol index table\");\n\n  Expected<typename ELFT::Word> TableOrErr = ShndxTable[SymIndex];\n  if (!TableOrErr)\n    return createError(\"unable to read an extended symbol table at index \" +\n                       Twine(SymIndex) + \": \" +\n                       toString(TableOrErr.takeError()));\n  return *TableOrErr;\n}\n\ntemplate <class ELFT>\nExpected<uint32_t>\nELFFile<ELFT>::getSectionIndex(const Elf_Sym &Sym, Elf_Sym_Range Syms,\n                               DataRegion<Elf_Word> ShndxTable) const {\n  uint32_t Index = Sym.st_shndx;\n  if (Index == ELF::SHN_XINDEX) {\n    Expected<uint32_t> ErrorOrIndex =\n        getExtendedSymbolTableIndex<ELFT>(Sym, &Sym - Syms.begin(), ShndxTable);\n    if (!ErrorOrIndex)\n      return ErrorOrIndex.takeError();\n    return *ErrorOrIndex;\n  }\n  if (Index == ELF::SHN_UNDEF || Index >= ELF::SHN_LORESERVE)\n    return 0;\n  return Index;\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Shdr *>\nELFFile<ELFT>::getSection(const Elf_Sym &Sym, const Elf_Shdr *SymTab,\n                          DataRegion<Elf_Word> ShndxTable) const {\n  auto SymsOrErr = symbols(SymTab);\n  if (!SymsOrErr)\n    return SymsOrErr.takeError();\n  return getSection(Sym, *SymsOrErr, ShndxTable);\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Shdr *>\nELFFile<ELFT>::getSection(const Elf_Sym &Sym, Elf_Sym_Range Symbols,\n                          DataRegion<Elf_Word> ShndxTable) const {\n  auto IndexOrErr = getSectionIndex(Sym, Symbols, ShndxTable);\n  if (!IndexOrErr)\n    return IndexOrErr.takeError();\n  uint32_t Index = *IndexOrErr;\n  if (Index == 0)\n    return nullptr;\n  return getSection(Index);\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Sym *>\nELFFile<ELFT>::getSymbol(const Elf_Shdr *Sec, uint32_t Index) const {\n  auto SymsOrErr = symbols(Sec);\n  if (!SymsOrErr)\n    return SymsOrErr.takeError();\n\n  Elf_Sym_Range Symbols = *SymsOrErr;\n  if (Index >= Symbols.size())\n    return createError(\"unable to get symbol from section \" +\n                       getSecIndexForError(*this, *Sec) +\n                       \": invalid symbol index (\" + Twine(Index) + \")\");\n  return &Symbols[Index];\n}\n\ntemplate <class ELFT>\ntemplate <typename T>\nExpected<ArrayRef<T>>\nELFFile<ELFT>::getSectionContentsAsArray(const Elf_Shdr &Sec) const {\n  if (Sec.sh_entsize != sizeof(T) && sizeof(T) != 1)\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has invalid sh_entsize: expected \" + Twine(sizeof(T)) +\n                       \", but got \" + Twine(Sec.sh_entsize));\n\n  uintX_t Offset = Sec.sh_offset;\n  uintX_t Size = Sec.sh_size;\n\n  if (Size % sizeof(T))\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has an invalid sh_size (\" + Twine(Size) +\n                       \") which is not a multiple of its sh_entsize (\" +\n                       Twine(Sec.sh_entsize) + \")\");\n  if (std::numeric_limits<uintX_t>::max() - Offset < Size)\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has a sh_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + sh_size (0x\" + Twine::utohexstr(Size) +\n                       \") that cannot be represented\");\n  if (Offset + Size > Buf.size())\n    return createError(\"section \" + getSecIndexForError(*this, Sec) +\n                       \" has a sh_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + sh_size (0x\" + Twine::utohexstr(Size) +\n                       \") that is greater than the file size (0x\" +\n                       Twine::utohexstr(Buf.size()) + \")\");\n\n  if (Offset % alignof(T))\n    // TODO: this error is untested.\n    return createError(\"unaligned data\");\n\n  const T *Start = reinterpret_cast<const T *>(base() + Offset);\n  return makeArrayRef(Start, Size / sizeof(T));\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<uint8_t>>\nELFFile<ELFT>::getSegmentContents(const Elf_Phdr &Phdr) const {\n  uintX_t Offset = Phdr.p_offset;\n  uintX_t Size = Phdr.p_filesz;\n\n  if (std::numeric_limits<uintX_t>::max() - Offset < Size)\n    return createError(\"program header \" + getPhdrIndexForError(*this, Phdr) +\n                       \" has a p_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + p_filesz (0x\" + Twine::utohexstr(Size) +\n                       \") that cannot be represented\");\n  if (Offset + Size > Buf.size())\n    return createError(\"program header  \" + getPhdrIndexForError(*this, Phdr) +\n                       \" has a p_offset (0x\" + Twine::utohexstr(Offset) +\n                       \") + p_filesz (0x\" + Twine::utohexstr(Size) +\n                       \") that is greater than the file size (0x\" +\n                       Twine::utohexstr(Buf.size()) + \")\");\n  return makeArrayRef(base() + Offset, Size);\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<uint8_t>>\nELFFile<ELFT>::getSectionContents(const Elf_Shdr &Sec) const {\n  return getSectionContentsAsArray<uint8_t>(Sec);\n}\n\ntemplate <class ELFT>\nStringRef ELFFile<ELFT>::getRelocationTypeName(uint32_t Type) const {\n  return getELFRelocationTypeName(getHeader().e_machine, Type);\n}\n\ntemplate <class ELFT>\nvoid ELFFile<ELFT>::getRelocationTypeName(uint32_t Type,\n                                          SmallVectorImpl<char> &Result) const {\n  if (!isMipsELF64()) {\n    StringRef Name = getRelocationTypeName(Type);\n    Result.append(Name.begin(), Name.end());\n  } else {\n    // The Mips N64 ABI allows up to three operations to be specified per\n    // relocation record. Unfortunately there's no easy way to test for the\n    // presence of N64 ELFs as they have no special flag that identifies them\n    // as being N64. We can safely assume at the moment that all Mips\n    // ELFCLASS64 ELFs are N64. New Mips64 ABIs should provide enough\n    // information to disambiguate between old vs new ABIs.\n    uint8_t Type1 = (Type >> 0) & 0xFF;\n    uint8_t Type2 = (Type >> 8) & 0xFF;\n    uint8_t Type3 = (Type >> 16) & 0xFF;\n\n    // Concat all three relocation type names.\n    StringRef Name = getRelocationTypeName(Type1);\n    Result.append(Name.begin(), Name.end());\n\n    Name = getRelocationTypeName(Type2);\n    Result.append(1, '/');\n    Result.append(Name.begin(), Name.end());\n\n    Name = getRelocationTypeName(Type3);\n    Result.append(1, '/');\n    Result.append(Name.begin(), Name.end());\n  }\n}\n\ntemplate <class ELFT>\nuint32_t ELFFile<ELFT>::getRelativeRelocationType() const {\n  return getELFRelativeRelocationType(getHeader().e_machine);\n}\n\ntemplate <class ELFT>\nExpected<SmallVector<Optional<VersionEntry>, 0>>\nELFFile<ELFT>::loadVersionMap(const Elf_Shdr *VerNeedSec,\n                              const Elf_Shdr *VerDefSec) const {\n  SmallVector<Optional<VersionEntry>, 0> VersionMap;\n\n  // The first two version indexes are reserved.\n  // Index 0 is VER_NDX_LOCAL, index 1 is VER_NDX_GLOBAL.\n  VersionMap.push_back(VersionEntry());\n  VersionMap.push_back(VersionEntry());\n\n  auto InsertEntry = [&](unsigned N, StringRef Version, bool IsVerdef) {\n    if (N >= VersionMap.size())\n      VersionMap.resize(N + 1);\n    VersionMap[N] = {std::string(Version), IsVerdef};\n  };\n\n  if (VerDefSec) {\n    Expected<std::vector<VerDef>> Defs = getVersionDefinitions(*VerDefSec);\n    if (!Defs)\n      return Defs.takeError();\n    for (const VerDef &Def : *Defs)\n      InsertEntry(Def.Ndx & ELF::VERSYM_VERSION, Def.Name, true);\n  }\n\n  if (VerNeedSec) {\n    Expected<std::vector<VerNeed>> Deps = getVersionDependencies(*VerNeedSec);\n    if (!Deps)\n      return Deps.takeError();\n    for (const VerNeed &Dep : *Deps)\n      for (const VernAux &Aux : Dep.AuxV)\n        InsertEntry(Aux.Other & ELF::VERSYM_VERSION, Aux.Name, false);\n  }\n\n  return VersionMap;\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Sym *>\nELFFile<ELFT>::getRelocationSymbol(const Elf_Rel &Rel,\n                                   const Elf_Shdr *SymTab) const {\n  uint32_t Index = Rel.getSymbol(isMips64EL());\n  if (Index == 0)\n    return nullptr;\n  return getEntry<Elf_Sym>(*SymTab, Index);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getSectionStringTable(Elf_Shdr_Range Sections,\n                                     WarningHandler WarnHandler) const {\n  uint32_t Index = getHeader().e_shstrndx;\n  if (Index == ELF::SHN_XINDEX) {\n    // If the section name string table section index is greater than\n    // or equal to SHN_LORESERVE, then the actual index of the section name\n    // string table section is contained in the sh_link field of the section\n    // header at index 0.\n    if (Sections.empty())\n      return createError(\n          \"e_shstrndx == SHN_XINDEX, but the section header table is empty\");\n\n    Index = Sections[0].sh_link;\n  }\n\n  if (!Index) // no section string table.\n    return \"\";\n  if (Index >= Sections.size())\n    return createError(\"section header string table index \" + Twine(Index) +\n                       \" does not exist\");\n  return getStringTable(Sections[Index], WarnHandler);\n}\n\n/// This function finds the number of dynamic symbols using a GNU hash table.\n///\n/// @param Table The GNU hash table for .dynsym.\ntemplate <class ELFT>\nstatic Expected<uint64_t>\ngetDynSymtabSizeFromGnuHash(const typename ELFT::GnuHash &Table,\n                            const void *BufEnd) {\n  using Elf_Word = typename ELFT::Word;\n  if (Table.nbuckets == 0)\n    return Table.symndx + 1;\n  uint64_t LastSymIdx = 0;\n  // Find the index of the first symbol in the last chain.\n  for (Elf_Word Val : Table.buckets())\n    LastSymIdx = std::max(LastSymIdx, (uint64_t)Val);\n  const Elf_Word *It =\n      reinterpret_cast<const Elf_Word *>(Table.values(LastSymIdx).end());\n  // Locate the end of the chain to find the last symbol index.\n  while (It < BufEnd && (*It & 1) == 0) {\n    ++LastSymIdx;\n    ++It;\n  }\n  if (It >= BufEnd) {\n    return createStringError(\n        object_error::parse_failed,\n        \"no terminator found for GNU hash section before buffer end\");\n  }\n  return LastSymIdx + 1;\n}\n\n/// This function determines the number of dynamic symbols. It reads section\n/// headers first. If section headers are not available, the number of\n/// symbols will be inferred by parsing dynamic hash tables.\ntemplate <class ELFT>\nExpected<uint64_t> ELFFile<ELFT>::getDynSymtabSize() const {\n  // Read .dynsym section header first if available.\n  Expected<Elf_Shdr_Range> SectionsOrError = sections();\n  if (!SectionsOrError)\n    return SectionsOrError.takeError();\n  for (const Elf_Shdr &Sec : *SectionsOrError) {\n    if (Sec.sh_type == ELF::SHT_DYNSYM) {\n      if (Sec.sh_size % Sec.sh_entsize != 0) {\n        return createStringError(object_error::parse_failed,\n                                 \"SHT_DYNSYM section has sh_size (\" +\n                                     Twine(Sec.sh_size) + \") % sh_entsize (\" +\n                                     Twine(Sec.sh_entsize) + \") that is not 0\");\n      }\n      return Sec.sh_size / Sec.sh_entsize;\n    }\n  }\n\n  if (!SectionsOrError->empty()) {\n    // Section headers are available but .dynsym header is not found.\n    // Return 0 as .dynsym does not exist.\n    return 0;\n  }\n\n  // Section headers do not exist. Falling back to infer\n  // upper bound of .dynsym from .gnu.hash and .hash.\n  Expected<Elf_Dyn_Range> DynTable = dynamicEntries();\n  if (!DynTable)\n    return DynTable.takeError();\n  llvm::Optional<uint64_t> ElfHash;\n  llvm::Optional<uint64_t> ElfGnuHash;\n  for (const Elf_Dyn &Entry : *DynTable) {\n    switch (Entry.d_tag) {\n    case ELF::DT_HASH:\n      ElfHash = Entry.d_un.d_ptr;\n      break;\n    case ELF::DT_GNU_HASH:\n      ElfGnuHash = Entry.d_un.d_ptr;\n      break;\n    }\n  }\n  if (ElfGnuHash) {\n    Expected<const uint8_t *> TablePtr = toMappedAddr(*ElfGnuHash);\n    if (!TablePtr)\n      return TablePtr.takeError();\n    const Elf_GnuHash *Table =\n        reinterpret_cast<const Elf_GnuHash *>(TablePtr.get());\n    return getDynSymtabSizeFromGnuHash<ELFT>(*Table, this->Buf.bytes_end());\n  }\n\n  // Search SYSV hash table to try to find the upper bound of dynsym.\n  if (ElfHash) {\n    Expected<const uint8_t *> TablePtr = toMappedAddr(*ElfHash);\n    if (!TablePtr)\n      return TablePtr.takeError();\n    const Elf_Hash *Table = reinterpret_cast<const Elf_Hash *>(TablePtr.get());\n    return Table->nchain;\n  }\n  return 0;\n}\n\ntemplate <class ELFT> ELFFile<ELFT>::ELFFile(StringRef Object) : Buf(Object) {}\n\ntemplate <class ELFT>\nExpected<ELFFile<ELFT>> ELFFile<ELFT>::create(StringRef Object) {\n  if (sizeof(Elf_Ehdr) > Object.size())\n    return createError(\"invalid buffer: the size (\" + Twine(Object.size()) +\n                       \") is smaller than an ELF header (\" +\n                       Twine(sizeof(Elf_Ehdr)) + \")\");\n  return ELFFile(Object);\n}\n\ntemplate <class ELFT>\nExpected<typename ELFT::ShdrRange> ELFFile<ELFT>::sections() const {\n  const uintX_t SectionTableOffset = getHeader().e_shoff;\n  if (SectionTableOffset == 0)\n    return ArrayRef<Elf_Shdr>();\n\n  if (getHeader().e_shentsize != sizeof(Elf_Shdr))\n    return createError(\"invalid e_shentsize in ELF header: \" +\n                       Twine(getHeader().e_shentsize));\n\n  const uint64_t FileSize = Buf.size();\n  if (SectionTableOffset + sizeof(Elf_Shdr) > FileSize ||\n      SectionTableOffset + (uintX_t)sizeof(Elf_Shdr) < SectionTableOffset)\n    return createError(\n        \"section header table goes past the end of the file: e_shoff = 0x\" +\n        Twine::utohexstr(SectionTableOffset));\n\n  // Invalid address alignment of section headers\n  if (SectionTableOffset & (alignof(Elf_Shdr) - 1))\n    // TODO: this error is untested.\n    return createError(\"invalid alignment of section headers\");\n\n  const Elf_Shdr *First =\n      reinterpret_cast<const Elf_Shdr *>(base() + SectionTableOffset);\n\n  uintX_t NumSections = getHeader().e_shnum;\n  if (NumSections == 0)\n    NumSections = First->sh_size;\n\n  if (NumSections > UINT64_MAX / sizeof(Elf_Shdr))\n    return createError(\"invalid number of sections specified in the NULL \"\n                       \"section's sh_size field (\" +\n                       Twine(NumSections) + \")\");\n\n  const uint64_t SectionTableSize = NumSections * sizeof(Elf_Shdr);\n  if (SectionTableOffset + SectionTableSize < SectionTableOffset)\n    return createError(\n        \"invalid section header table offset (e_shoff = 0x\" +\n        Twine::utohexstr(SectionTableOffset) +\n        \") or invalid number of sections specified in the first section \"\n        \"header's sh_size field (0x\" +\n        Twine::utohexstr(NumSections) + \")\");\n\n  // Section table goes past end of file!\n  if (SectionTableOffset + SectionTableSize > FileSize)\n    return createError(\"section table goes past the end of file\");\n  return makeArrayRef(First, NumSections);\n}\n\ntemplate <class ELFT>\ntemplate <typename T>\nExpected<const T *> ELFFile<ELFT>::getEntry(uint32_t Section,\n                                            uint32_t Entry) const {\n  auto SecOrErr = getSection(Section);\n  if (!SecOrErr)\n    return SecOrErr.takeError();\n  return getEntry<T>(**SecOrErr, Entry);\n}\n\ntemplate <class ELFT>\ntemplate <typename T>\nExpected<const T *> ELFFile<ELFT>::getEntry(const Elf_Shdr &Section,\n                                            uint32_t Entry) const {\n  Expected<ArrayRef<T>> EntriesOrErr = getSectionContentsAsArray<T>(Section);\n  if (!EntriesOrErr)\n    return EntriesOrErr.takeError();\n\n  ArrayRef<T> Arr = *EntriesOrErr;\n  if (Entry >= Arr.size())\n    return createError(\n        \"can't read an entry at 0x\" +\n        Twine::utohexstr(Entry * static_cast<uint64_t>(sizeof(T))) +\n        \": it goes past the end of the section (0x\" +\n        Twine::utohexstr(Section.sh_size) + \")\");\n  return &Arr[Entry];\n}\n\ntemplate <typename ELFT>\nExpected<StringRef> ELFFile<ELFT>::getSymbolVersionByIndex(\n    uint32_t SymbolVersionIndex, bool &IsDefault,\n    SmallVector<Optional<VersionEntry>, 0> &VersionMap,\n    Optional<bool> IsSymHidden) const {\n  size_t VersionIndex = SymbolVersionIndex & llvm::ELF::VERSYM_VERSION;\n\n  // Special markers for unversioned symbols.\n  if (VersionIndex == llvm::ELF::VER_NDX_LOCAL ||\n      VersionIndex == llvm::ELF::VER_NDX_GLOBAL) {\n    IsDefault = false;\n    return \"\";\n  }\n\n  // Lookup this symbol in the version table.\n  if (VersionIndex >= VersionMap.size() || !VersionMap[VersionIndex])\n    return createError(\"SHT_GNU_versym section refers to a version index \" +\n                       Twine(VersionIndex) + \" which is missing\");\n\n  const VersionEntry &Entry = *VersionMap[VersionIndex];\n  // A default version (@@) is only available for defined symbols.\n  if (!Entry.IsVerDef || IsSymHidden.getValueOr(false))\n    IsDefault = false;\n  else\n    IsDefault = !(SymbolVersionIndex & llvm::ELF::VERSYM_HIDDEN);\n  return Entry.Name.c_str();\n}\n\ntemplate <class ELFT>\nExpected<std::vector<VerDef>>\nELFFile<ELFT>::getVersionDefinitions(const Elf_Shdr &Sec) const {\n  Expected<StringRef> StrTabOrErr = getLinkAsStrtab(Sec);\n  if (!StrTabOrErr)\n    return StrTabOrErr.takeError();\n\n  Expected<ArrayRef<uint8_t>> ContentsOrErr = getSectionContents(Sec);\n  if (!ContentsOrErr)\n    return createError(\"cannot read content of \" + describe(*this, Sec) + \": \" +\n                       toString(ContentsOrErr.takeError()));\n\n  const uint8_t *Start = ContentsOrErr->data();\n  const uint8_t *End = Start + ContentsOrErr->size();\n\n  auto ExtractNextAux = [&](const uint8_t *&VerdauxBuf,\n                            unsigned VerDefNdx) -> Expected<VerdAux> {\n    if (VerdauxBuf + sizeof(Elf_Verdaux) > End)\n      return createError(\"invalid \" + describe(*this, Sec) +\n                         \": version definition \" + Twine(VerDefNdx) +\n                         \" refers to an auxiliary entry that goes past the end \"\n                         \"of the section\");\n\n    auto *Verdaux = reinterpret_cast<const Elf_Verdaux *>(VerdauxBuf);\n    VerdauxBuf += Verdaux->vda_next;\n\n    VerdAux Aux;\n    Aux.Offset = VerdauxBuf - Start;\n    if (Verdaux->vda_name <= StrTabOrErr->size())\n      Aux.Name = std::string(StrTabOrErr->drop_front(Verdaux->vda_name));\n    else\n      Aux.Name = (\"<invalid vda_name: \" + Twine(Verdaux->vda_name) + \">\").str();\n    return Aux;\n  };\n\n  std::vector<VerDef> Ret;\n  const uint8_t *VerdefBuf = Start;\n  for (unsigned I = 1; I <= /*VerDefsNum=*/Sec.sh_info; ++I) {\n    if (VerdefBuf + sizeof(Elf_Verdef) > End)\n      return createError(\"invalid \" + describe(*this, Sec) +\n                         \": version definition \" + Twine(I) +\n                         \" goes past the end of the section\");\n\n    if (reinterpret_cast<uintptr_t>(VerdefBuf) % sizeof(uint32_t) != 0)\n      return createError(\n          \"invalid \" + describe(*this, Sec) +\n          \": found a misaligned version definition entry at offset 0x\" +\n          Twine::utohexstr(VerdefBuf - Start));\n\n    unsigned Version = *reinterpret_cast<const Elf_Half *>(VerdefBuf);\n    if (Version != 1)\n      return createError(\"unable to dump \" + describe(*this, Sec) +\n                         \": version \" + Twine(Version) +\n                         \" is not yet supported\");\n\n    const Elf_Verdef *D = reinterpret_cast<const Elf_Verdef *>(VerdefBuf);\n    VerDef &VD = *Ret.emplace(Ret.end());\n    VD.Offset = VerdefBuf - Start;\n    VD.Version = D->vd_version;\n    VD.Flags = D->vd_flags;\n    VD.Ndx = D->vd_ndx;\n    VD.Cnt = D->vd_cnt;\n    VD.Hash = D->vd_hash;\n\n    const uint8_t *VerdauxBuf = VerdefBuf + D->vd_aux;\n    for (unsigned J = 0; J < D->vd_cnt; ++J) {\n      if (reinterpret_cast<uintptr_t>(VerdauxBuf) % sizeof(uint32_t) != 0)\n        return createError(\"invalid \" + describe(*this, Sec) +\n                           \": found a misaligned auxiliary entry at offset 0x\" +\n                           Twine::utohexstr(VerdauxBuf - Start));\n\n      Expected<VerdAux> AuxOrErr = ExtractNextAux(VerdauxBuf, I);\n      if (!AuxOrErr)\n        return AuxOrErr.takeError();\n\n      if (J == 0)\n        VD.Name = AuxOrErr->Name;\n      else\n        VD.AuxV.push_back(*AuxOrErr);\n    }\n\n    VerdefBuf += D->vd_next;\n  }\n\n  return Ret;\n}\n\ntemplate <class ELFT>\nExpected<std::vector<VerNeed>>\nELFFile<ELFT>::getVersionDependencies(const Elf_Shdr &Sec,\n                                      WarningHandler WarnHandler) const {\n  StringRef StrTab;\n  Expected<StringRef> StrTabOrErr = getLinkAsStrtab(Sec);\n  if (!StrTabOrErr) {\n    if (Error E = WarnHandler(toString(StrTabOrErr.takeError())))\n      return std::move(E);\n  } else {\n    StrTab = *StrTabOrErr;\n  }\n\n  Expected<ArrayRef<uint8_t>> ContentsOrErr = getSectionContents(Sec);\n  if (!ContentsOrErr)\n    return createError(\"cannot read content of \" + describe(*this, Sec) + \": \" +\n                       toString(ContentsOrErr.takeError()));\n\n  const uint8_t *Start = ContentsOrErr->data();\n  const uint8_t *End = Start + ContentsOrErr->size();\n  const uint8_t *VerneedBuf = Start;\n\n  std::vector<VerNeed> Ret;\n  for (unsigned I = 1; I <= /*VerneedNum=*/Sec.sh_info; ++I) {\n    if (VerneedBuf + sizeof(Elf_Verdef) > End)\n      return createError(\"invalid \" + describe(*this, Sec) +\n                         \": version dependency \" + Twine(I) +\n                         \" goes past the end of the section\");\n\n    if (reinterpret_cast<uintptr_t>(VerneedBuf) % sizeof(uint32_t) != 0)\n      return createError(\n          \"invalid \" + describe(*this, Sec) +\n          \": found a misaligned version dependency entry at offset 0x\" +\n          Twine::utohexstr(VerneedBuf - Start));\n\n    unsigned Version = *reinterpret_cast<const Elf_Half *>(VerneedBuf);\n    if (Version != 1)\n      return createError(\"unable to dump \" + describe(*this, Sec) +\n                         \": version \" + Twine(Version) +\n                         \" is not yet supported\");\n\n    const Elf_Verneed *Verneed =\n        reinterpret_cast<const Elf_Verneed *>(VerneedBuf);\n\n    VerNeed &VN = *Ret.emplace(Ret.end());\n    VN.Version = Verneed->vn_version;\n    VN.Cnt = Verneed->vn_cnt;\n    VN.Offset = VerneedBuf - Start;\n\n    if (Verneed->vn_file < StrTab.size())\n      VN.File = std::string(StrTab.drop_front(Verneed->vn_file));\n    else\n      VN.File = (\"<corrupt vn_file: \" + Twine(Verneed->vn_file) + \">\").str();\n\n    const uint8_t *VernauxBuf = VerneedBuf + Verneed->vn_aux;\n    for (unsigned J = 0; J < Verneed->vn_cnt; ++J) {\n      if (reinterpret_cast<uintptr_t>(VernauxBuf) % sizeof(uint32_t) != 0)\n        return createError(\"invalid \" + describe(*this, Sec) +\n                           \": found a misaligned auxiliary entry at offset 0x\" +\n                           Twine::utohexstr(VernauxBuf - Start));\n\n      if (VernauxBuf + sizeof(Elf_Vernaux) > End)\n        return createError(\n            \"invalid \" + describe(*this, Sec) + \": version dependency \" +\n            Twine(I) +\n            \" refers to an auxiliary entry that goes past the end \"\n            \"of the section\");\n\n      const Elf_Vernaux *Vernaux =\n          reinterpret_cast<const Elf_Vernaux *>(VernauxBuf);\n\n      VernAux &Aux = *VN.AuxV.emplace(VN.AuxV.end());\n      Aux.Hash = Vernaux->vna_hash;\n      Aux.Flags = Vernaux->vna_flags;\n      Aux.Other = Vernaux->vna_other;\n      Aux.Offset = VernauxBuf - Start;\n      if (StrTab.size() <= Vernaux->vna_name)\n        Aux.Name = \"<corrupt>\";\n      else\n        Aux.Name = std::string(StrTab.drop_front(Vernaux->vna_name));\n\n      VernauxBuf += Vernaux->vna_next;\n    }\n    VerneedBuf += Verneed->vn_next;\n  }\n  return Ret;\n}\n\ntemplate <class ELFT>\nExpected<const typename ELFT::Shdr *>\nELFFile<ELFT>::getSection(uint32_t Index) const {\n  auto TableOrErr = sections();\n  if (!TableOrErr)\n    return TableOrErr.takeError();\n  return object::getSection<ELFT>(*TableOrErr, Index);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getStringTable(const Elf_Shdr &Section,\n                              WarningHandler WarnHandler) const {\n  if (Section.sh_type != ELF::SHT_STRTAB)\n    if (Error E = WarnHandler(\"invalid sh_type for string table section \" +\n                              getSecIndexForError(*this, Section) +\n                              \": expected SHT_STRTAB, but got \" +\n                              object::getELFSectionTypeName(\n                                  getHeader().e_machine, Section.sh_type)))\n      return std::move(E);\n\n  auto V = getSectionContentsAsArray<char>(Section);\n  if (!V)\n    return V.takeError();\n  ArrayRef<char> Data = *V;\n  if (Data.empty())\n    return createError(\"SHT_STRTAB string table section \" +\n                       getSecIndexForError(*this, Section) + \" is empty\");\n  if (Data.back() != '\\0')\n    return createError(\"SHT_STRTAB string table section \" +\n                       getSecIndexForError(*this, Section) +\n                       \" is non-null terminated\");\n  return StringRef(Data.begin(), Data.size());\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<typename ELFT::Word>>\nELFFile<ELFT>::getSHNDXTable(const Elf_Shdr &Section) const {\n  auto SectionsOrErr = sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n  return getSHNDXTable(Section, *SectionsOrErr);\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<typename ELFT::Word>>\nELFFile<ELFT>::getSHNDXTable(const Elf_Shdr &Section,\n                             Elf_Shdr_Range Sections) const {\n  assert(Section.sh_type == ELF::SHT_SYMTAB_SHNDX);\n  auto VOrErr = getSectionContentsAsArray<Elf_Word>(Section);\n  if (!VOrErr)\n    return VOrErr.takeError();\n  ArrayRef<Elf_Word> V = *VOrErr;\n  auto SymTableOrErr = object::getSection<ELFT>(Sections, Section.sh_link);\n  if (!SymTableOrErr)\n    return SymTableOrErr.takeError();\n  const Elf_Shdr &SymTable = **SymTableOrErr;\n  if (SymTable.sh_type != ELF::SHT_SYMTAB &&\n      SymTable.sh_type != ELF::SHT_DYNSYM)\n    return createError(\n        \"SHT_SYMTAB_SHNDX section is linked with \" +\n        object::getELFSectionTypeName(getHeader().e_machine, SymTable.sh_type) +\n        \" section (expected SHT_SYMTAB/SHT_DYNSYM)\");\n\n  uint64_t Syms = SymTable.sh_size / sizeof(Elf_Sym);\n  if (V.size() != Syms)\n    return createError(\"SHT_SYMTAB_SHNDX has \" + Twine(V.size()) +\n                       \" entries, but the symbol table associated has \" +\n                       Twine(Syms));\n\n  return V;\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getStringTableForSymtab(const Elf_Shdr &Sec) const {\n  auto SectionsOrErr = sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n  return getStringTableForSymtab(Sec, *SectionsOrErr);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getStringTableForSymtab(const Elf_Shdr &Sec,\n                                       Elf_Shdr_Range Sections) const {\n\n  if (Sec.sh_type != ELF::SHT_SYMTAB && Sec.sh_type != ELF::SHT_DYNSYM)\n    return createError(\n        \"invalid sh_type for symbol table, expected SHT_SYMTAB or SHT_DYNSYM\");\n  Expected<const Elf_Shdr *> SectionOrErr =\n      object::getSection<ELFT>(Sections, Sec.sh_link);\n  if (!SectionOrErr)\n    return SectionOrErr.takeError();\n  return getStringTable(**SectionOrErr);\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getLinkAsStrtab(const typename ELFT::Shdr &Sec) const {\n  Expected<const typename ELFT::Shdr *> StrTabSecOrErr =\n      getSection(Sec.sh_link);\n  if (!StrTabSecOrErr)\n    return createError(\"invalid section linked to \" + describe(*this, Sec) +\n                       \": \" + toString(StrTabSecOrErr.takeError()));\n\n  Expected<StringRef> StrTabOrErr = getStringTable(**StrTabSecOrErr);\n  if (!StrTabOrErr)\n    return createError(\"invalid string table linked to \" +\n                       describe(*this, Sec) + \": \" +\n                       toString(StrTabOrErr.takeError()));\n  return *StrTabOrErr;\n}\n\ntemplate <class ELFT>\nExpected<StringRef>\nELFFile<ELFT>::getSectionName(const Elf_Shdr &Section,\n                              WarningHandler WarnHandler) const {\n  auto SectionsOrErr = sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n  auto Table = getSectionStringTable(*SectionsOrErr, WarnHandler);\n  if (!Table)\n    return Table.takeError();\n  return getSectionName(Section, *Table);\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFFile<ELFT>::getSectionName(const Elf_Shdr &Section,\n                                                  StringRef DotShstrtab) const {\n  uint32_t Offset = Section.sh_name;\n  if (Offset == 0)\n    return StringRef();\n  if (Offset >= DotShstrtab.size())\n    return createError(\"a section \" + getSecIndexForError(*this, Section) +\n                       \" has an invalid sh_name (0x\" +\n                       Twine::utohexstr(Offset) +\n                       \") offset which goes past the end of the \"\n                       \"section name string table\");\n  return StringRef(DotShstrtab.data() + Offset);\n}\n\n/// This function returns the hash value for a symbol in the .dynsym section\n/// Name of the API remains consistent as specified in the libelf\n/// REF : http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash\ninline unsigned hashSysV(StringRef SymbolName) {\n  unsigned h = 0, g;\n  for (char C : SymbolName) {\n    h = (h << 4) + C;\n    g = h & 0xf0000000L;\n    if (g != 0)\n      h ^= g >> 24;\n    h &= ~g;\n  }\n  return h;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_ELF_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "content": "//===- ELFObjectFile.h - ELF object file implementation ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the ELFObjectFile template class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ELFOBJECTFILE_H\n#define LLVM_OBJECT_ELFOBJECTFILE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ELF.h\"\n#include \"llvm/Object/ELFTypes.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/ARMAttributeParser.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ELFAttributes.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstdint>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\nconstexpr int NumElfSymbolTypes = 16;\nextern const llvm::EnumEntry<unsigned> ElfSymbolTypes[NumElfSymbolTypes];\n\nclass elf_symbol_iterator;\n\nclass ELFObjectFileBase : public ObjectFile {\n  friend class ELFRelocationRef;\n  friend class ELFSectionRef;\n  friend class ELFSymbolRef;\n\n  SubtargetFeatures getMIPSFeatures() const;\n  SubtargetFeatures getARMFeatures() const;\n  SubtargetFeatures getRISCVFeatures() const;\n\n  StringRef getAMDGPUCPUName() const;\n\nprotected:\n  ELFObjectFileBase(unsigned int Type, MemoryBufferRef Source);\n\n  virtual uint64_t getSymbolSize(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolBinding(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolOther(DataRefImpl Symb) const = 0;\n  virtual uint8_t getSymbolELFType(DataRefImpl Symb) const = 0;\n\n  virtual uint32_t getSectionType(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionFlags(DataRefImpl Sec) const = 0;\n  virtual uint64_t getSectionOffset(DataRefImpl Sec) const = 0;\n\n  virtual Expected<int64_t> getRelocationAddend(DataRefImpl Rel) const = 0;\n  virtual Error getBuildAttributes(ELFAttributeParser &Attributes) const = 0;\n\npublic:\n  using elf_symbol_iterator_range = iterator_range<elf_symbol_iterator>;\n\n  virtual elf_symbol_iterator_range getDynamicSymbolIterators() const = 0;\n\n  /// Returns platform-specific object flags, if any.\n  virtual unsigned getPlatformFlags() const = 0;\n\n  elf_symbol_iterator_range symbols() const;\n\n  static bool classof(const Binary *v) { return v->isELF(); }\n\n  SubtargetFeatures getFeatures() const override;\n\n  Optional<StringRef> tryGetCPUName() const override;\n\n  void setARMSubArch(Triple &TheTriple) const override;\n\n  virtual uint16_t getEType() const = 0;\n\n  virtual uint16_t getEMachine() const = 0;\n\n  std::vector<std::pair<Optional<DataRefImpl>, uint64_t>>\n  getPltAddresses() const;\n};\n\nclass ELFSectionRef : public SectionRef {\npublic:\n  ELFSectionRef(const SectionRef &B) : SectionRef(B) {\n    assert(isa<ELFObjectFileBase>(SectionRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(SectionRef::getObject());\n  }\n\n  uint32_t getType() const {\n    return getObject()->getSectionType(getRawDataRefImpl());\n  }\n\n  uint64_t getFlags() const {\n    return getObject()->getSectionFlags(getRawDataRefImpl());\n  }\n\n  uint64_t getOffset() const {\n    return getObject()->getSectionOffset(getRawDataRefImpl());\n  }\n};\n\nclass elf_section_iterator : public section_iterator {\npublic:\n  elf_section_iterator(const section_iterator &B) : section_iterator(B) {\n    assert(isa<ELFObjectFileBase>(B->getObject()));\n  }\n\n  const ELFSectionRef *operator->() const {\n    return static_cast<const ELFSectionRef *>(section_iterator::operator->());\n  }\n\n  const ELFSectionRef &operator*() const {\n    return static_cast<const ELFSectionRef &>(section_iterator::operator*());\n  }\n};\n\nclass ELFSymbolRef : public SymbolRef {\npublic:\n  ELFSymbolRef(const SymbolRef &B) : SymbolRef(B) {\n    assert(isa<ELFObjectFileBase>(SymbolRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(BasicSymbolRef::getObject());\n  }\n\n  uint64_t getSize() const {\n    return getObject()->getSymbolSize(getRawDataRefImpl());\n  }\n\n  uint8_t getBinding() const {\n    return getObject()->getSymbolBinding(getRawDataRefImpl());\n  }\n\n  uint8_t getOther() const {\n    return getObject()->getSymbolOther(getRawDataRefImpl());\n  }\n\n  uint8_t getELFType() const {\n    return getObject()->getSymbolELFType(getRawDataRefImpl());\n  }\n\n  StringRef getELFTypeName() const {\n    uint8_t Type = getELFType();\n    for (auto &EE : ElfSymbolTypes) {\n      if (EE.Value == Type) {\n        return EE.AltName;\n      }\n    }\n    return \"\";\n  }\n};\n\nclass elf_symbol_iterator : public symbol_iterator {\npublic:\n  elf_symbol_iterator(const basic_symbol_iterator &B)\n      : symbol_iterator(SymbolRef(B->getRawDataRefImpl(),\n                                  cast<ELFObjectFileBase>(B->getObject()))) {}\n\n  const ELFSymbolRef *operator->() const {\n    return static_cast<const ELFSymbolRef *>(symbol_iterator::operator->());\n  }\n\n  const ELFSymbolRef &operator*() const {\n    return static_cast<const ELFSymbolRef &>(symbol_iterator::operator*());\n  }\n};\n\nclass ELFRelocationRef : public RelocationRef {\npublic:\n  ELFRelocationRef(const RelocationRef &B) : RelocationRef(B) {\n    assert(isa<ELFObjectFileBase>(RelocationRef::getObject()));\n  }\n\n  const ELFObjectFileBase *getObject() const {\n    return cast<ELFObjectFileBase>(RelocationRef::getObject());\n  }\n\n  Expected<int64_t> getAddend() const {\n    return getObject()->getRelocationAddend(getRawDataRefImpl());\n  }\n};\n\nclass elf_relocation_iterator : public relocation_iterator {\npublic:\n  elf_relocation_iterator(const relocation_iterator &B)\n      : relocation_iterator(RelocationRef(\n            B->getRawDataRefImpl(), cast<ELFObjectFileBase>(B->getObject()))) {}\n\n  const ELFRelocationRef *operator->() const {\n    return static_cast<const ELFRelocationRef *>(\n        relocation_iterator::operator->());\n  }\n\n  const ELFRelocationRef &operator*() const {\n    return static_cast<const ELFRelocationRef &>(\n        relocation_iterator::operator*());\n  }\n};\n\ninline ELFObjectFileBase::elf_symbol_iterator_range\nELFObjectFileBase::symbols() const {\n  return elf_symbol_iterator_range(symbol_begin(), symbol_end());\n}\n\ntemplate <class ELFT> class ELFObjectFile : public ELFObjectFileBase {\n  uint16_t getEMachine() const override;\n  uint16_t getEType() const override;\n  uint64_t getSymbolSize(DataRefImpl Sym) const override;\n\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  SectionRef toSectionRef(const Elf_Shdr *Sec) const {\n    return SectionRef(toDRI(Sec), this);\n  }\n\n  ELFSymbolRef toSymbolRef(const Elf_Shdr *SymTable, unsigned SymbolNum) const {\n    return ELFSymbolRef({toDRI(SymTable, SymbolNum), this});\n  }\n\n  bool IsContentValid() const { return ContentValid; }\n\nprivate:\n  ELFObjectFile(MemoryBufferRef Object, ELFFile<ELFT> EF,\n                const Elf_Shdr *DotDynSymSec, const Elf_Shdr *DotSymtabSec,\n                const Elf_Shdr *DotSymtabShndxSec);\n\n  bool ContentValid = false;\n\nprotected:\n  ELFFile<ELFT> EF;\n\n  const Elf_Shdr *DotDynSymSec = nullptr; // Dynamic symbol table section.\n  const Elf_Shdr *DotSymtabSec = nullptr; // Symbol table section.\n  const Elf_Shdr *DotSymtabShndxSec = nullptr; // SHT_SYMTAB_SHNDX section.\n\n  Error initContent() override;\n\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  uint8_t getSymbolBinding(DataRefImpl Symb) const override;\n  uint8_t getSymbolOther(DataRefImpl Symb) const override;\n  uint8_t getSymbolELFType(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(const Elf_Sym *Symb,\n                                              const Elf_Shdr *SymTab) const;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isBerkeleyText(DataRefImpl Sec) const override;\n  bool isBerkeleyData(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n  std::vector<SectionRef> dynamic_relocation_sections() const override;\n  Expected<section_iterator>\n  getRelocatedSection(DataRefImpl Sec) const override;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n\n  uint32_t getSectionType(DataRefImpl Sec) const override;\n  uint64_t getSectionFlags(DataRefImpl Sec) const override;\n  uint64_t getSectionOffset(DataRefImpl Sec) const override;\n  StringRef getRelocationTypeName(uint32_t Type) const;\n\n  DataRefImpl toDRI(const Elf_Shdr *SymTable, unsigned SymbolNum) const {\n    DataRefImpl DRI;\n    if (!SymTable) {\n      DRI.d.a = 0;\n      DRI.d.b = 0;\n      return DRI;\n    }\n    assert(SymTable->sh_type == ELF::SHT_SYMTAB ||\n           SymTable->sh_type == ELF::SHT_DYNSYM);\n\n    auto SectionsOrErr = EF.sections();\n    if (!SectionsOrErr) {\n      DRI.d.a = 0;\n      DRI.d.b = 0;\n      return DRI;\n    }\n    uintptr_t SHT = reinterpret_cast<uintptr_t>((*SectionsOrErr).begin());\n    unsigned SymTableIndex =\n        (reinterpret_cast<uintptr_t>(SymTable) - SHT) / sizeof(Elf_Shdr);\n\n    DRI.d.a = SymTableIndex;\n    DRI.d.b = SymbolNum;\n    return DRI;\n  }\n\n  const Elf_Shdr *toELFShdrIter(DataRefImpl Sec) const {\n    return reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  }\n\n  DataRefImpl toDRI(const Elf_Shdr *Sec) const {\n    DataRefImpl DRI;\n    DRI.p = reinterpret_cast<uintptr_t>(Sec);\n    return DRI;\n  }\n\n  DataRefImpl toDRI(const Elf_Dyn *Dyn) const {\n    DataRefImpl DRI;\n    DRI.p = reinterpret_cast<uintptr_t>(Dyn);\n    return DRI;\n  }\n\n  bool isExportedToOtherDSO(const Elf_Sym *ESym) const {\n    unsigned char Binding = ESym->getBinding();\n    unsigned char Visibility = ESym->getVisibility();\n\n    // A symbol is exported if its binding is either GLOBAL or WEAK, and its\n    // visibility is either DEFAULT or PROTECTED. All other symbols are not\n    // exported.\n    return (\n        (Binding == ELF::STB_GLOBAL || Binding == ELF::STB_WEAK ||\n         Binding == ELF::STB_GNU_UNIQUE) &&\n        (Visibility == ELF::STV_DEFAULT || Visibility == ELF::STV_PROTECTED));\n  }\n\n  Error getBuildAttributes(ELFAttributeParser &Attributes) const override {\n    auto SectionsOrErr = EF.sections();\n    if (!SectionsOrErr)\n      return SectionsOrErr.takeError();\n\n    for (const Elf_Shdr &Sec : *SectionsOrErr) {\n      if (Sec.sh_type == ELF::SHT_ARM_ATTRIBUTES ||\n          Sec.sh_type == ELF::SHT_RISCV_ATTRIBUTES) {\n        auto ErrorOrContents = EF.getSectionContents(Sec);\n        if (!ErrorOrContents)\n          return ErrorOrContents.takeError();\n\n        auto Contents = ErrorOrContents.get();\n        if (Contents[0] != ELFAttrs::Format_Version || Contents.size() == 1)\n          return Error::success();\n\n        if (Error E = Attributes.parse(Contents, ELFT::TargetEndianness))\n          return E;\n        break;\n      }\n    }\n    return Error::success();\n  }\n\n  // This flag is used for classof, to distinguish ELFObjectFile from\n  // its subclass. If more subclasses will be created, this flag will\n  // have to become an enum.\n  bool isDyldELFObject;\n\npublic:\n  ELFObjectFile(ELFObjectFile<ELFT> &&Other);\n  static Expected<ELFObjectFile<ELFT>> create(MemoryBufferRef Object,\n                                              bool InitContent = true);\n\n  const Elf_Rel *getRel(DataRefImpl Rel) const;\n  const Elf_Rela *getRela(DataRefImpl Rela) const;\n\n  Expected<const Elf_Sym *> getSymbol(DataRefImpl Sym) const {\n    return EF.template getEntry<Elf_Sym>(Sym.d.a, Sym.d.b);\n  }\n\n  /// Get the relocation section that contains \\a Rel.\n  const Elf_Shdr *getRelSection(DataRefImpl Rel) const {\n    auto RelSecOrErr = EF.getSection(Rel.d.a);\n    if (!RelSecOrErr)\n      report_fatal_error(errorToErrorCode(RelSecOrErr.takeError()).message());\n    return *RelSecOrErr;\n  }\n\n  const Elf_Shdr *getSection(DataRefImpl Sec) const {\n    return reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  }\n\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n\n  elf_symbol_iterator dynamic_symbol_begin() const;\n  elf_symbol_iterator dynamic_symbol_end() const;\n\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  Expected<int64_t> getRelocationAddend(DataRefImpl Rel) const override;\n\n  uint8_t getBytesInAddress() const override;\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  Expected<uint64_t> getStartAddress() const override;\n\n  unsigned getPlatformFlags() const override { return EF.getHeader().e_flags; }\n\n  const ELFFile<ELFT> &getELFFile() const { return EF; }\n\n  bool isDyldType() const { return isDyldELFObject; }\n  static bool classof(const Binary *v) {\n    return v->getType() == getELFType(ELFT::TargetEndianness == support::little,\n                                      ELFT::Is64Bits);\n  }\n\n  elf_symbol_iterator_range getDynamicSymbolIterators() const override;\n\n  bool isRelocatableObject() const override;\n};\n\nusing ELF32LEObjectFile = ELFObjectFile<ELF32LE>;\nusing ELF64LEObjectFile = ELFObjectFile<ELF64LE>;\nusing ELF32BEObjectFile = ELFObjectFile<ELF32BE>;\nusing ELF64BEObjectFile = ELFObjectFile<ELF64BE>;\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveSymbolNext(DataRefImpl &Sym) const {\n  ++Sym.d.b;\n}\n\ntemplate <class ELFT> Error ELFObjectFile<ELFT>::initContent() {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return SectionsOrErr.takeError();\n\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    switch (Sec.sh_type) {\n    case ELF::SHT_DYNSYM: {\n      if (!DotDynSymSec)\n        DotDynSymSec = &Sec;\n      break;\n    }\n    case ELF::SHT_SYMTAB: {\n      if (!DotSymtabSec)\n        DotSymtabSec = &Sec;\n      break;\n    }\n    case ELF::SHT_SYMTAB_SHNDX: {\n      if (!DotSymtabShndxSec)\n        DotSymtabShndxSec = &Sec;\n      break;\n    }\n    }\n  }\n\n  ContentValid = true;\n  return Error::success();\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFObjectFile<ELFT>::getSymbolName(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n  auto SymTabOrErr = EF.getSection(Sym.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n  const Elf_Shdr *SymTableSec = *SymTabOrErr;\n  auto StrTabOrErr = EF.getSection(SymTableSec->sh_link);\n  if (!StrTabOrErr)\n    return StrTabOrErr.takeError();\n  const Elf_Shdr *StringTableSec = *StrTabOrErr;\n  auto SymStrTabOrErr = EF.getStringTable(*StringTableSec);\n  if (!SymStrTabOrErr)\n    return SymStrTabOrErr.takeError();\n  Expected<StringRef> Name = (*SymOrErr)->getName(*SymStrTabOrErr);\n  if (Name && !Name->empty())\n    return Name;\n\n  // If the symbol name is empty use the section name.\n  if ((*SymOrErr)->getType() == ELF::STT_SECTION) {\n    if (Expected<section_iterator> SecOrErr = getSymbolSection(Sym)) {\n      consumeError(Name.takeError());\n      return (*SecOrErr)->getName();\n    }\n  }\n  return Name;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionFlags(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags;\n}\n\ntemplate <class ELFT>\nuint32_t ELFObjectFile<ELFT>::getSectionType(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_type;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionOffset(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_offset;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSymbolValueImpl(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n\n  uint64_t Ret = (*SymOrErr)->st_value;\n  if ((*SymOrErr)->st_shndx == ELF::SHN_ABS)\n    return Ret;\n\n  const Elf_Ehdr &Header = EF.getHeader();\n  // Clear the ARM/Thumb or microMIPS indicator flag.\n  if ((Header.e_machine == ELF::EM_ARM || Header.e_machine == ELF::EM_MIPS) &&\n      (*SymOrErr)->getType() == ELF::STT_FUNC)\n    Ret &= ~1;\n\n  return Ret;\n}\n\ntemplate <class ELFT>\nExpected<uint64_t>\nELFObjectFile<ELFT>::getSymbolAddress(DataRefImpl Symb) const {\n  Expected<uint64_t> SymbolValueOrErr = getSymbolValue(Symb);\n  if (!SymbolValueOrErr)\n    // TODO: Test this error.\n    return SymbolValueOrErr.takeError();\n\n  uint64_t Result = *SymbolValueOrErr;\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  switch ((*SymOrErr)->st_shndx) {\n  case ELF::SHN_COMMON:\n  case ELF::SHN_UNDEF:\n  case ELF::SHN_ABS:\n    return Result;\n  }\n\n  auto SymTabOrErr = EF.getSection(Symb.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n\n  if (EF.getHeader().e_type == ELF::ET_REL) {\n    ArrayRef<Elf_Word> ShndxTable;\n    if (DotSymtabShndxSec) {\n      // TODO: Test this error.\n      if (Expected<ArrayRef<Elf_Word>> ShndxTableOrErr =\n              EF.getSHNDXTable(*DotSymtabShndxSec))\n        ShndxTable = *ShndxTableOrErr;\n      else\n        return ShndxTableOrErr.takeError();\n    }\n\n    Expected<const Elf_Shdr *> SectionOrErr =\n        EF.getSection(**SymOrErr, *SymTabOrErr, ShndxTable);\n    if (!SectionOrErr)\n      return SectionOrErr.takeError();\n    const Elf_Shdr *Section = *SectionOrErr;\n    if (Section)\n      Result += Section->sh_addr;\n  }\n\n  return Result;\n}\n\ntemplate <class ELFT>\nuint32_t ELFObjectFile<ELFT>::getSymbolAlignment(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  if ((*SymOrErr)->st_shndx == ELF::SHN_COMMON)\n    return (*SymOrErr)->st_value;\n  return 0;\n}\n\ntemplate <class ELFT>\nuint16_t ELFObjectFile<ELFT>::getEMachine() const {\n  return EF.getHeader().e_machine;\n}\n\ntemplate <class ELFT> uint16_t ELFObjectFile<ELFT>::getEType() const {\n  return EF.getHeader().e_type;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSymbolSize(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->st_size;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getCommonSymbolSizeImpl(DataRefImpl Symb) const {\n  return getSymbolSize(Symb);\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolBinding(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->getBinding();\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolOther(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->st_other;\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getSymbolELFType(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    report_fatal_error(SymOrErr.takeError());\n  return (*SymOrErr)->getType();\n}\n\ntemplate <class ELFT>\nExpected<SymbolRef::Type>\nELFObjectFile<ELFT>::getSymbolType(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  switch ((*SymOrErr)->getType()) {\n  case ELF::STT_NOTYPE:\n    return SymbolRef::ST_Unknown;\n  case ELF::STT_SECTION:\n    return SymbolRef::ST_Debug;\n  case ELF::STT_FILE:\n    return SymbolRef::ST_File;\n  case ELF::STT_FUNC:\n    return SymbolRef::ST_Function;\n  case ELF::STT_OBJECT:\n  case ELF::STT_COMMON:\n    return SymbolRef::ST_Data;\n  case ELF::STT_TLS:\n  default:\n    return SymbolRef::ST_Other;\n  }\n}\n\ntemplate <class ELFT>\nExpected<uint32_t> ELFObjectFile<ELFT>::getSymbolFlags(DataRefImpl Sym) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Sym);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  const Elf_Sym *ESym = *SymOrErr;\n  uint32_t Result = SymbolRef::SF_None;\n\n  if (ESym->getBinding() != ELF::STB_LOCAL)\n    Result |= SymbolRef::SF_Global;\n\n  if (ESym->getBinding() == ELF::STB_WEAK)\n    Result |= SymbolRef::SF_Weak;\n\n  if (ESym->st_shndx == ELF::SHN_ABS)\n    Result |= SymbolRef::SF_Absolute;\n\n  if (ESym->getType() == ELF::STT_FILE || ESym->getType() == ELF::STT_SECTION)\n    Result |= SymbolRef::SF_FormatSpecific;\n\n  if (Expected<typename ELFT::SymRange> SymbolsOrErr =\n          EF.symbols(DotSymtabSec)) {\n    // Set the SF_FormatSpecific flag for the 0-index null symbol.\n    if (ESym == SymbolsOrErr->begin())\n      Result |= SymbolRef::SF_FormatSpecific;\n  } else\n    // TODO: Test this error.\n    return SymbolsOrErr.takeError();\n\n  if (Expected<typename ELFT::SymRange> SymbolsOrErr =\n          EF.symbols(DotDynSymSec)) {\n    // Set the SF_FormatSpecific flag for the 0-index null symbol.\n    if (ESym == SymbolsOrErr->begin())\n      Result |= SymbolRef::SF_FormatSpecific;\n  } else\n    // TODO: Test this error.\n    return SymbolsOrErr.takeError();\n\n  if (EF.getHeader().e_machine == ELF::EM_ARM) {\n    if (Expected<StringRef> NameOrErr = getSymbolName(Sym)) {\n      StringRef Name = *NameOrErr;\n      if (Name.startswith(\"$d\") || Name.startswith(\"$t\") ||\n          Name.startswith(\"$a\"))\n        Result |= SymbolRef::SF_FormatSpecific;\n    } else {\n      // TODO: Actually report errors helpfully.\n      consumeError(NameOrErr.takeError());\n    }\n    if (ESym->getType() == ELF::STT_FUNC && (ESym->st_value & 1) == 1)\n      Result |= SymbolRef::SF_Thumb;\n  }\n\n  if (ESym->st_shndx == ELF::SHN_UNDEF)\n    Result |= SymbolRef::SF_Undefined;\n\n  if (ESym->getType() == ELF::STT_COMMON || ESym->st_shndx == ELF::SHN_COMMON)\n    Result |= SymbolRef::SF_Common;\n\n  if (isExportedToOtherDSO(ESym))\n    Result |= SymbolRef::SF_Exported;\n\n  if (ESym->getVisibility() == ELF::STV_HIDDEN)\n    Result |= SymbolRef::SF_Hidden;\n\n  return Result;\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getSymbolSection(const Elf_Sym *ESym,\n                                      const Elf_Shdr *SymTab) const {\n  ArrayRef<Elf_Word> ShndxTable;\n  if (DotSymtabShndxSec) {\n    // TODO: Test this error.\n    Expected<ArrayRef<Elf_Word>> ShndxTableOrErr =\n        EF.getSHNDXTable(*DotSymtabShndxSec);\n    if (!ShndxTableOrErr)\n      return ShndxTableOrErr.takeError();\n    ShndxTable = *ShndxTableOrErr;\n  }\n\n  auto ESecOrErr = EF.getSection(*ESym, SymTab, ShndxTable);\n  if (!ESecOrErr)\n    return ESecOrErr.takeError();\n\n  const Elf_Shdr *ESec = *ESecOrErr;\n  if (!ESec)\n    return section_end();\n\n  DataRefImpl Sec;\n  Sec.p = reinterpret_cast<intptr_t>(ESec);\n  return section_iterator(SectionRef(Sec, this));\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getSymbolSection(DataRefImpl Symb) const {\n  Expected<const Elf_Sym *> SymOrErr = getSymbol(Symb);\n  if (!SymOrErr)\n    return SymOrErr.takeError();\n\n  auto SymTabOrErr = EF.getSection(Symb.d.a);\n  if (!SymTabOrErr)\n    return SymTabOrErr.takeError();\n  return getSymbolSection(*SymOrErr, *SymTabOrErr);\n}\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveSectionNext(DataRefImpl &Sec) const {\n  const Elf_Shdr *ESec = getSection(Sec);\n  Sec = toDRI(++ESec);\n}\n\ntemplate <class ELFT>\nExpected<StringRef> ELFObjectFile<ELFT>::getSectionName(DataRefImpl Sec) const {\n  return EF.getSectionName(*getSection(Sec));\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionAddress(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_addr;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionIndex(DataRefImpl Sec) const {\n  auto SectionsOrErr = EF.sections();\n  handleAllErrors(std::move(SectionsOrErr.takeError()),\n                  [](const ErrorInfoBase &) {\n                    llvm_unreachable(\"unable to get section index\");\n                  });\n  const Elf_Shdr *First = SectionsOrErr->begin();\n  return getSection(Sec) - First;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionSize(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_size;\n}\n\ntemplate <class ELFT>\nExpected<ArrayRef<uint8_t>>\nELFObjectFile<ELFT>::getSectionContents(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  if (EShdr->sh_type == ELF::SHT_NOBITS)\n    return makeArrayRef((const uint8_t *)base(), 0);\n  if (Error E =\n          checkOffset(getMemoryBufferRef(),\n                      (uintptr_t)base() + EShdr->sh_offset, EShdr->sh_size))\n    return std::move(E);\n  return makeArrayRef((const uint8_t *)base() + EShdr->sh_offset,\n                      EShdr->sh_size);\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getSectionAlignment(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_addralign;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionCompressed(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_COMPRESSED;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionText(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_EXECINSTR;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionData(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return EShdr->sh_type == ELF::SHT_PROGBITS &&\n         EShdr->sh_flags & ELF::SHF_ALLOC &&\n         !(EShdr->sh_flags & ELF::SHF_EXECINSTR);\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionBSS(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return EShdr->sh_flags & (ELF::SHF_ALLOC | ELF::SHF_WRITE) &&\n         EShdr->sh_type == ELF::SHT_NOBITS;\n}\n\ntemplate <class ELFT>\nstd::vector<SectionRef>\nELFObjectFile<ELFT>::dynamic_relocation_sections() const {\n  std::vector<SectionRef> Res;\n  std::vector<uintptr_t> Offsets;\n\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return Res;\n\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    if (Sec.sh_type != ELF::SHT_DYNAMIC)\n      continue;\n    Elf_Dyn *Dynamic =\n        reinterpret_cast<Elf_Dyn *>((uintptr_t)base() + Sec.sh_offset);\n    for (; Dynamic->d_tag != ELF::DT_NULL; Dynamic++) {\n      if (Dynamic->d_tag == ELF::DT_REL || Dynamic->d_tag == ELF::DT_RELA ||\n          Dynamic->d_tag == ELF::DT_JMPREL) {\n        Offsets.push_back(Dynamic->d_un.d_val);\n      }\n    }\n  }\n  for (const Elf_Shdr &Sec : *SectionsOrErr) {\n    if (is_contained(Offsets, Sec.sh_addr))\n      Res.emplace_back(toDRI(&Sec), this);\n  }\n  return Res;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isSectionVirtual(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_type == ELF::SHT_NOBITS;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isBerkeleyText(DataRefImpl Sec) const {\n  return getSection(Sec)->sh_flags & ELF::SHF_ALLOC &&\n         (getSection(Sec)->sh_flags & ELF::SHF_EXECINSTR ||\n          !(getSection(Sec)->sh_flags & ELF::SHF_WRITE));\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isBerkeleyData(DataRefImpl Sec) const {\n  const Elf_Shdr *EShdr = getSection(Sec);\n  return !isBerkeleyText(Sec) && EShdr->sh_type != ELF::SHT_NOBITS &&\n         EShdr->sh_flags & ELF::SHF_ALLOC;\n}\n\ntemplate <class ELFT>\nbool ELFObjectFile<ELFT>::isDebugSection(StringRef SectionName) const {\n  return SectionName.startswith(\".debug\") ||\n         SectionName.startswith(\".zdebug\") || SectionName == \".gdb_index\";\n}\n\ntemplate <class ELFT>\nrelocation_iterator\nELFObjectFile<ELFT>::section_rel_begin(DataRefImpl Sec) const {\n  DataRefImpl RelData;\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return relocation_iterator(RelocationRef());\n  uintptr_t SHT = reinterpret_cast<uintptr_t>((*SectionsOrErr).begin());\n  RelData.d.a = (Sec.p - SHT) / EF.getHeader().e_shentsize;\n  RelData.d.b = 0;\n  return relocation_iterator(RelocationRef(RelData, this));\n}\n\ntemplate <class ELFT>\nrelocation_iterator\nELFObjectFile<ELFT>::section_rel_end(DataRefImpl Sec) const {\n  const Elf_Shdr *S = reinterpret_cast<const Elf_Shdr *>(Sec.p);\n  relocation_iterator Begin = section_rel_begin(Sec);\n  if (S->sh_type != ELF::SHT_RELA && S->sh_type != ELF::SHT_REL)\n    return Begin;\n  DataRefImpl RelData = Begin->getRawDataRefImpl();\n  const Elf_Shdr *RelSec = getRelSection(RelData);\n\n  // Error check sh_link here so that getRelocationSymbol can just use it.\n  auto SymSecOrErr = EF.getSection(RelSec->sh_link);\n  if (!SymSecOrErr)\n    report_fatal_error(errorToErrorCode(SymSecOrErr.takeError()).message());\n\n  RelData.d.b += S->sh_size / S->sh_entsize;\n  return relocation_iterator(RelocationRef(RelData, this));\n}\n\ntemplate <class ELFT>\nExpected<section_iterator>\nELFObjectFile<ELFT>::getRelocatedSection(DataRefImpl Sec) const {\n  if (EF.getHeader().e_type != ELF::ET_REL)\n    return section_end();\n\n  const Elf_Shdr *EShdr = getSection(Sec);\n  uintX_t Type = EShdr->sh_type;\n  if (Type != ELF::SHT_REL && Type != ELF::SHT_RELA)\n    return section_end();\n\n  Expected<const Elf_Shdr *> SecOrErr = EF.getSection(EShdr->sh_info);\n  if (!SecOrErr)\n    return SecOrErr.takeError();\n  return section_iterator(SectionRef(toDRI(*SecOrErr), this));\n}\n\n// Relocations\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::moveRelocationNext(DataRefImpl &Rel) const {\n  ++Rel.d.b;\n}\n\ntemplate <class ELFT>\nsymbol_iterator\nELFObjectFile<ELFT>::getRelocationSymbol(DataRefImpl Rel) const {\n  uint32_t symbolIdx;\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    symbolIdx = getRel(Rel)->getSymbol(EF.isMips64EL());\n  else\n    symbolIdx = getRela(Rel)->getSymbol(EF.isMips64EL());\n  if (!symbolIdx)\n    return symbol_end();\n\n  // FIXME: error check symbolIdx\n  DataRefImpl SymbolData;\n  SymbolData.d.a = sec->sh_link;\n  SymbolData.d.b = symbolIdx;\n  return symbol_iterator(SymbolRef(SymbolData, this));\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getRelocationOffset(DataRefImpl Rel) const {\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    return getRel(Rel)->r_offset;\n\n  return getRela(Rel)->r_offset;\n}\n\ntemplate <class ELFT>\nuint64_t ELFObjectFile<ELFT>::getRelocationType(DataRefImpl Rel) const {\n  const Elf_Shdr *sec = getRelSection(Rel);\n  if (sec->sh_type == ELF::SHT_REL)\n    return getRel(Rel)->getType(EF.isMips64EL());\n  else\n    return getRela(Rel)->getType(EF.isMips64EL());\n}\n\ntemplate <class ELFT>\nStringRef ELFObjectFile<ELFT>::getRelocationTypeName(uint32_t Type) const {\n  return getELFRelocationTypeName(EF.getHeader().e_machine, Type);\n}\n\ntemplate <class ELFT>\nvoid ELFObjectFile<ELFT>::getRelocationTypeName(\n    DataRefImpl Rel, SmallVectorImpl<char> &Result) const {\n  uint32_t type = getRelocationType(Rel);\n  EF.getRelocationTypeName(type, Result);\n}\n\ntemplate <class ELFT>\nExpected<int64_t>\nELFObjectFile<ELFT>::getRelocationAddend(DataRefImpl Rel) const {\n  if (getRelSection(Rel)->sh_type != ELF::SHT_RELA)\n    return createError(\"Section is not SHT_RELA\");\n  return (int64_t)getRela(Rel)->r_addend;\n}\n\ntemplate <class ELFT>\nconst typename ELFObjectFile<ELFT>::Elf_Rel *\nELFObjectFile<ELFT>::getRel(DataRefImpl Rel) const {\n  assert(getRelSection(Rel)->sh_type == ELF::SHT_REL);\n  auto Ret = EF.template getEntry<Elf_Rel>(Rel.d.a, Rel.d.b);\n  if (!Ret)\n    report_fatal_error(errorToErrorCode(Ret.takeError()).message());\n  return *Ret;\n}\n\ntemplate <class ELFT>\nconst typename ELFObjectFile<ELFT>::Elf_Rela *\nELFObjectFile<ELFT>::getRela(DataRefImpl Rela) const {\n  assert(getRelSection(Rela)->sh_type == ELF::SHT_RELA);\n  auto Ret = EF.template getEntry<Elf_Rela>(Rela.d.a, Rela.d.b);\n  if (!Ret)\n    report_fatal_error(errorToErrorCode(Ret.takeError()).message());\n  return *Ret;\n}\n\ntemplate <class ELFT>\nExpected<ELFObjectFile<ELFT>>\nELFObjectFile<ELFT>::create(MemoryBufferRef Object, bool InitContent) {\n  auto EFOrErr = ELFFile<ELFT>::create(Object.getBuffer());\n  if (Error E = EFOrErr.takeError())\n    return std::move(E);\n\n  ELFObjectFile<ELFT> Obj = {Object, std::move(*EFOrErr), nullptr, nullptr,\n                             nullptr};\n  if (InitContent)\n    if (Error E = Obj.initContent())\n      return std::move(E);\n  return std::move(Obj);\n}\n\ntemplate <class ELFT>\nELFObjectFile<ELFT>::ELFObjectFile(MemoryBufferRef Object, ELFFile<ELFT> EF,\n                                   const Elf_Shdr *DotDynSymSec,\n                                   const Elf_Shdr *DotSymtabSec,\n                                   const Elf_Shdr *DotSymtabShndx)\n    : ELFObjectFileBase(\n          getELFType(ELFT::TargetEndianness == support::little, ELFT::Is64Bits),\n          Object),\n      EF(EF), DotDynSymSec(DotDynSymSec), DotSymtabSec(DotSymtabSec),\n      DotSymtabShndxSec(DotSymtabShndx) {}\n\ntemplate <class ELFT>\nELFObjectFile<ELFT>::ELFObjectFile(ELFObjectFile<ELFT> &&Other)\n    : ELFObjectFile(Other.Data, Other.EF, Other.DotDynSymSec,\n                    Other.DotSymtabSec, Other.DotSymtabShndxSec) {}\n\ntemplate <class ELFT>\nbasic_symbol_iterator ELFObjectFile<ELFT>::symbol_begin() const {\n  DataRefImpl Sym =\n      toDRI(DotSymtabSec,\n            DotSymtabSec && DotSymtabSec->sh_size >= sizeof(Elf_Sym) ? 1 : 0);\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nbasic_symbol_iterator ELFObjectFile<ELFT>::symbol_end() const {\n  const Elf_Shdr *SymTab = DotSymtabSec;\n  if (!SymTab)\n    return symbol_begin();\n  DataRefImpl Sym = toDRI(SymTab, SymTab->sh_size / sizeof(Elf_Sym));\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nelf_symbol_iterator ELFObjectFile<ELFT>::dynamic_symbol_begin() const {\n  if (!DotDynSymSec || DotDynSymSec->sh_size < sizeof(Elf_Sym))\n    // Ignore errors here where the dynsym is empty or sh_size less than the\n    // size of one symbol. These should be handled elsewhere.\n    return symbol_iterator(SymbolRef(toDRI(DotDynSymSec, 0), this));\n  // Skip 0-index NULL symbol.\n  return symbol_iterator(SymbolRef(toDRI(DotDynSymSec, 1), this));\n}\n\ntemplate <class ELFT>\nelf_symbol_iterator ELFObjectFile<ELFT>::dynamic_symbol_end() const {\n  const Elf_Shdr *SymTab = DotDynSymSec;\n  if (!SymTab)\n    return dynamic_symbol_begin();\n  DataRefImpl Sym = toDRI(SymTab, SymTab->sh_size / sizeof(Elf_Sym));\n  return basic_symbol_iterator(SymbolRef(Sym, this));\n}\n\ntemplate <class ELFT>\nsection_iterator ELFObjectFile<ELFT>::section_begin() const {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return section_iterator(SectionRef());\n  return section_iterator(SectionRef(toDRI((*SectionsOrErr).begin()), this));\n}\n\ntemplate <class ELFT>\nsection_iterator ELFObjectFile<ELFT>::section_end() const {\n  auto SectionsOrErr = EF.sections();\n  if (!SectionsOrErr)\n    return section_iterator(SectionRef());\n  return section_iterator(SectionRef(toDRI((*SectionsOrErr).end()), this));\n}\n\ntemplate <class ELFT>\nuint8_t ELFObjectFile<ELFT>::getBytesInAddress() const {\n  return ELFT::Is64Bits ? 8 : 4;\n}\n\ntemplate <class ELFT>\nStringRef ELFObjectFile<ELFT>::getFileFormatName() const {\n  bool IsLittleEndian = ELFT::TargetEndianness == support::little;\n  switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n  case ELF::ELFCLASS32:\n    switch (EF.getHeader().e_machine) {\n    case ELF::EM_68K:\n      return \"elf32-m68k\";\n    case ELF::EM_386:\n      return \"elf32-i386\";\n    case ELF::EM_IAMCU:\n      return \"elf32-iamcu\";\n    case ELF::EM_X86_64:\n      return \"elf32-x86-64\";\n    case ELF::EM_ARM:\n      return (IsLittleEndian ? \"elf32-littlearm\" : \"elf32-bigarm\");\n    case ELF::EM_AVR:\n      return \"elf32-avr\";\n    case ELF::EM_HEXAGON:\n      return \"elf32-hexagon\";\n    case ELF::EM_LANAI:\n      return \"elf32-lanai\";\n    case ELF::EM_MIPS:\n      return \"elf32-mips\";\n    case ELF::EM_MSP430:\n      return \"elf32-msp430\";\n    case ELF::EM_PPC:\n      return (IsLittleEndian ? \"elf32-powerpcle\" : \"elf32-powerpc\");\n    case ELF::EM_RISCV:\n      return \"elf32-littleriscv\";\n    case ELF::EM_CSKY:\n      return \"elf32-csky\";\n    case ELF::EM_SPARC:\n    case ELF::EM_SPARC32PLUS:\n      return \"elf32-sparc\";\n    case ELF::EM_AMDGPU:\n      return \"elf32-amdgpu\";\n    default:\n      return \"elf32-unknown\";\n    }\n  case ELF::ELFCLASS64:\n    switch (EF.getHeader().e_machine) {\n    case ELF::EM_386:\n      return \"elf64-i386\";\n    case ELF::EM_X86_64:\n      return \"elf64-x86-64\";\n    case ELF::EM_AARCH64:\n      return (IsLittleEndian ? \"elf64-littleaarch64\" : \"elf64-bigaarch64\");\n    case ELF::EM_PPC64:\n      return (IsLittleEndian ? \"elf64-powerpcle\" : \"elf64-powerpc\");\n    case ELF::EM_RISCV:\n      return \"elf64-littleriscv\";\n    case ELF::EM_S390:\n      return \"elf64-s390\";\n    case ELF::EM_SPARCV9:\n      return \"elf64-sparc\";\n    case ELF::EM_MIPS:\n      return \"elf64-mips\";\n    case ELF::EM_AMDGPU:\n      return \"elf64-amdgpu\";\n    case ELF::EM_BPF:\n      return \"elf64-bpf\";\n    case ELF::EM_VE:\n      return \"elf64-ve\";\n    default:\n      return \"elf64-unknown\";\n    }\n  default:\n    // FIXME: Proper error handling.\n    report_fatal_error(\"Invalid ELFCLASS!\");\n  }\n}\n\ntemplate <class ELFT> Triple::ArchType ELFObjectFile<ELFT>::getArch() const {\n  bool IsLittleEndian = ELFT::TargetEndianness == support::little;\n  switch (EF.getHeader().e_machine) {\n  case ELF::EM_68K:\n    return Triple::m68k;\n  case ELF::EM_386:\n  case ELF::EM_IAMCU:\n    return Triple::x86;\n  case ELF::EM_X86_64:\n    return Triple::x86_64;\n  case ELF::EM_AARCH64:\n    return IsLittleEndian ? Triple::aarch64 : Triple::aarch64_be;\n  case ELF::EM_ARM:\n    return Triple::arm;\n  case ELF::EM_AVR:\n    return Triple::avr;\n  case ELF::EM_HEXAGON:\n    return Triple::hexagon;\n  case ELF::EM_LANAI:\n    return Triple::lanai;\n  case ELF::EM_MIPS:\n    switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n    case ELF::ELFCLASS32:\n      return IsLittleEndian ? Triple::mipsel : Triple::mips;\n    case ELF::ELFCLASS64:\n      return IsLittleEndian ? Triple::mips64el : Triple::mips64;\n    default:\n      report_fatal_error(\"Invalid ELFCLASS!\");\n    }\n  case ELF::EM_MSP430:\n    return Triple::msp430;\n  case ELF::EM_PPC:\n    return IsLittleEndian ? Triple::ppcle : Triple::ppc;\n  case ELF::EM_PPC64:\n    return IsLittleEndian ? Triple::ppc64le : Triple::ppc64;\n  case ELF::EM_RISCV:\n    switch (EF.getHeader().e_ident[ELF::EI_CLASS]) {\n    case ELF::ELFCLASS32:\n      return Triple::riscv32;\n    case ELF::ELFCLASS64:\n      return Triple::riscv64;\n    default:\n      report_fatal_error(\"Invalid ELFCLASS!\");\n    }\n  case ELF::EM_S390:\n    return Triple::systemz;\n\n  case ELF::EM_SPARC:\n  case ELF::EM_SPARC32PLUS:\n    return IsLittleEndian ? Triple::sparcel : Triple::sparc;\n  case ELF::EM_SPARCV9:\n    return Triple::sparcv9;\n\n  case ELF::EM_AMDGPU: {\n    if (!IsLittleEndian)\n      return Triple::UnknownArch;\n\n    unsigned MACH = EF.getHeader().e_flags & ELF::EF_AMDGPU_MACH;\n    if (MACH >= ELF::EF_AMDGPU_MACH_R600_FIRST &&\n        MACH <= ELF::EF_AMDGPU_MACH_R600_LAST)\n      return Triple::r600;\n    if (MACH >= ELF::EF_AMDGPU_MACH_AMDGCN_FIRST &&\n        MACH <= ELF::EF_AMDGPU_MACH_AMDGCN_LAST)\n      return Triple::amdgcn;\n\n    return Triple::UnknownArch;\n  }\n\n  case ELF::EM_BPF:\n    return IsLittleEndian ? Triple::bpfel : Triple::bpfeb;\n\n  case ELF::EM_VE:\n    return Triple::ve;\n  case ELF::EM_CSKY:\n    return Triple::csky;\n  default:\n    return Triple::UnknownArch;\n  }\n}\n\ntemplate <class ELFT>\nExpected<uint64_t> ELFObjectFile<ELFT>::getStartAddress() const {\n  return EF.getHeader().e_entry;\n}\n\ntemplate <class ELFT>\nELFObjectFileBase::elf_symbol_iterator_range\nELFObjectFile<ELFT>::getDynamicSymbolIterators() const {\n  return make_range(dynamic_symbol_begin(), dynamic_symbol_end());\n}\n\ntemplate <class ELFT> bool ELFObjectFile<ELFT>::isRelocatableObject() const {\n  return EF.getHeader().e_type == ELF::ET_REL;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_ELFOBJECTFILE_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Error.h", "content": "//===- Error.h - system_error extensions for Object -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This declares a new error_category for the Object library.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_ERROR_H\n#define LLVM_OBJECT_ERROR_H\n\n#include \"llvm/Support/Error.h\"\n#include <system_error>\n\nnamespace llvm {\n\nclass Twine;\n\nnamespace object {\n\nclass Binary;\n\nconst std::error_category &object_category();\n\nenum class object_error {\n  // Error code 0 is absent. Use std::error_code() instead.\n  arch_not_found = 1,\n  invalid_file_type,\n  parse_failed,\n  unexpected_eof,\n  string_table_non_null_end,\n  invalid_section_index,\n  bitcode_section_not_found,\n  invalid_symbol_index,\n};\n\ninline std::error_code make_error_code(object_error e) {\n  return std::error_code(static_cast<int>(e), object_category());\n}\n\n/// Base class for all errors indicating malformed binary files.\n///\n/// Having a subclass for all malformed binary files allows archive-walking\n/// code to skip malformed files without having to understand every possible\n/// way that a binary file might be malformed.\n///\n/// Currently inherits from ECError for easy interoperability with\n/// std::error_code, but this will be removed in the future.\nclass BinaryError : public ErrorInfo<BinaryError, ECError> {\n  void anchor() override;\npublic:\n  static char ID;\n  BinaryError() {\n    // Default to parse_failed, can be overridden with setErrorCode.\n    setErrorCode(make_error_code(object_error::parse_failed));\n  }\n};\n\n/// Generic binary error.\n///\n/// For errors that don't require their own specific sub-error (most errors)\n/// this class can be used to describe the error via a string message.\nclass GenericBinaryError : public ErrorInfo<GenericBinaryError, BinaryError> {\npublic:\n  static char ID;\n  GenericBinaryError(const Twine &Msg);\n  GenericBinaryError(const Twine &Msg, object_error ECOverride);\n  const std::string &getMessage() const { return Msg; }\n  void log(raw_ostream &OS) const override;\nprivate:\n  std::string Msg;\n};\n\n/// isNotObjectErrorInvalidFileType() is used when looping through the children\n/// of an archive after calling getAsBinary() on the child and it returns an\n/// llvm::Error.  In the cases we want to loop through the children and ignore the\n/// non-objects in the archive this is used to test the error to see if an\n/// error() function needs to called on the llvm::Error.\nError isNotObjectErrorInvalidFileType(llvm::Error Err);\n\n} // end namespace object.\n\n} // end namespace llvm.\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<llvm::object::object_error> : std::true_type {};\n}\n\n#endif\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "content": "//===- MachO.h - MachO object file implementation ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the MachOObjectFile class, which implement the ObjectFile\n// interface for MachO files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_MACHO_H\n#define LLVM_OBJECT_MACHO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/MachO.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <system_error>\n\nnamespace llvm {\nnamespace object {\n\n/// DiceRef - This is a value type class that represents a single\n/// data in code entry in the table in a Mach-O object file.\nclass DiceRef {\n  DataRefImpl DicePimpl;\n  const ObjectFile *OwningObject = nullptr;\n\npublic:\n  DiceRef() = default;\n  DiceRef(DataRefImpl DiceP, const ObjectFile *Owner);\n\n  bool operator==(const DiceRef &Other) const;\n  bool operator<(const DiceRef &Other) const;\n\n  void moveNext();\n\n  std::error_code getOffset(uint32_t &Result) const;\n  std::error_code getLength(uint16_t &Result) const;\n  std::error_code getKind(uint16_t &Result) const;\n\n  DataRefImpl getRawDataRefImpl() const;\n  const ObjectFile *getObjectFile() const;\n};\nusing dice_iterator = content_iterator<DiceRef>;\n\n/// ExportEntry encapsulates the current-state-of-the-walk used when doing a\n/// non-recursive walk of the trie data structure.  This allows you to iterate\n/// across all exported symbols using:\n///      Error Err = Error::success();\n///      for (const llvm::object::ExportEntry &AnExport : Obj->exports(&Err)) {\n///      }\n///      if (Err) { report error ...\nclass ExportEntry {\npublic:\n  ExportEntry(Error *Err, const MachOObjectFile *O, ArrayRef<uint8_t> Trie);\n\n  StringRef name() const;\n  uint64_t flags() const;\n  uint64_t address() const;\n  uint64_t other() const;\n  StringRef otherName() const;\n  uint32_t nodeOffset() const;\n\n  bool operator==(const ExportEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const uint8_t *&p, const char **error);\n  void pushDownUntilBottom();\n  void pushNode(uint64_t Offset);\n\n  // Represents a node in the mach-o exports trie.\n  struct NodeState {\n    NodeState(const uint8_t *Ptr);\n\n    const uint8_t *Start;\n    const uint8_t *Current;\n    uint64_t Flags = 0;\n    uint64_t Address = 0;\n    uint64_t Other = 0;\n    const char *ImportName = nullptr;\n    unsigned ChildCount = 0;\n    unsigned NextChildIndex = 0;\n    unsigned ParentStringLength = 0;\n    bool IsExportNode = false;\n  };\n  using NodeList = SmallVector<NodeState, 16>;\n  using node_iterator = NodeList::const_iterator;\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Trie;\n  SmallString<256> CumulativeString;\n  NodeList Stack;\n  bool Done = false;\n\n  iterator_range<node_iterator> nodes() const {\n    return make_range(Stack.begin(), Stack.end());\n  }\n};\nusing export_iterator = content_iterator<ExportEntry>;\n\n// Segment info so SegIndex/SegOffset pairs in a Mach-O Bind or Rebase entry\n// can be checked and translated.  Only the SegIndex/SegOffset pairs from\n// checked entries are to be used with the segmentName(), sectionName() and\n// address() methods below.\nclass BindRebaseSegInfo {\npublic:\n  BindRebaseSegInfo(const MachOObjectFile *Obj);\n\n  // Used to check a Mach-O Bind or Rebase entry for errors when iterating.\n  const char* checkSegAndOffsets(int32_t SegIndex, uint64_t SegOffset,\n                                 uint8_t PointerSize, uint32_t Count=1,\n                                 uint32_t Skip=0);\n  // Used with valid SegIndex/SegOffset values from checked entries.\n  StringRef segmentName(int32_t SegIndex);\n  StringRef sectionName(int32_t SegIndex, uint64_t SegOffset);\n  uint64_t address(uint32_t SegIndex, uint64_t SegOffset);\n\nprivate:\n  struct SectionInfo {\n    uint64_t Address;\n    uint64_t Size;\n    StringRef SectionName;\n    StringRef SegmentName;\n    uint64_t OffsetInSegment;\n    uint64_t SegmentStartAddress;\n    int32_t SegmentIndex;\n  };\n  const SectionInfo &findSection(int32_t SegIndex, uint64_t SegOffset);\n\n  SmallVector<SectionInfo, 32> Sections;\n  int32_t MaxSegIndex;\n};\n\n/// MachORebaseEntry encapsulates the current state in the decompression of\n/// rebasing opcodes. This allows you to iterate through the compressed table of\n/// rebasing using:\n///    Error Err = Error::success();\n///    for (const llvm::object::MachORebaseEntry &Entry : Obj->rebaseTable(&Err)) {\n///    }\n///    if (Err) { report error ...\nclass MachORebaseEntry {\npublic:\n  MachORebaseEntry(Error *Err, const MachOObjectFile *O,\n                   ArrayRef<uint8_t> opcodes, bool is64Bit);\n\n  int32_t segmentIndex() const;\n  uint64_t segmentOffset() const;\n  StringRef typeName() const;\n  StringRef segmentName() const;\n  StringRef sectionName() const;\n  uint64_t address() const;\n\n  bool operator==(const MachORebaseEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const char **error);\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Opcodes;\n  const uint8_t *Ptr;\n  uint64_t SegmentOffset = 0;\n  int32_t SegmentIndex = -1;\n  uint64_t RemainingLoopCount = 0;\n  uint64_t AdvanceAmount = 0;\n  uint8_t  RebaseType = 0;\n  uint8_t  PointerSize;\n  bool     Done = false;\n};\nusing rebase_iterator = content_iterator<MachORebaseEntry>;\n\n/// MachOBindEntry encapsulates the current state in the decompression of\n/// binding opcodes. This allows you to iterate through the compressed table of\n/// bindings using:\n///    Error Err = Error::success();\n///    for (const llvm::object::MachOBindEntry &Entry : Obj->bindTable(&Err)) {\n///    }\n///    if (Err) { report error ...\nclass MachOBindEntry {\npublic:\n  enum class Kind { Regular, Lazy, Weak };\n\n  MachOBindEntry(Error *Err, const MachOObjectFile *O,\n                 ArrayRef<uint8_t> Opcodes, bool is64Bit, MachOBindEntry::Kind);\n\n  int32_t segmentIndex() const;\n  uint64_t segmentOffset() const;\n  StringRef typeName() const;\n  StringRef symbolName() const;\n  uint32_t flags() const;\n  int64_t addend() const;\n  int ordinal() const;\n\n  StringRef segmentName() const;\n  StringRef sectionName() const;\n  uint64_t address() const;\n\n  bool operator==(const MachOBindEntry &) const;\n\n  void moveNext();\n\nprivate:\n  friend class MachOObjectFile;\n\n  void moveToFirst();\n  void moveToEnd();\n  uint64_t readULEB128(const char **error);\n  int64_t readSLEB128(const char **error);\n\n  Error *E;\n  const MachOObjectFile *O;\n  ArrayRef<uint8_t> Opcodes;\n  const uint8_t *Ptr;\n  uint64_t SegmentOffset = 0;\n  int32_t  SegmentIndex = -1;\n  StringRef SymbolName;\n  bool     LibraryOrdinalSet = false;\n  int      Ordinal = 0;\n  uint32_t Flags = 0;\n  int64_t  Addend = 0;\n  uint64_t RemainingLoopCount = 0;\n  uint64_t AdvanceAmount = 0;\n  uint8_t  BindType = 0;\n  uint8_t  PointerSize;\n  Kind     TableKind;\n  bool     Done = false;\n};\nusing bind_iterator = content_iterator<MachOBindEntry>;\n\nclass MachOObjectFile : public ObjectFile {\npublic:\n  struct LoadCommandInfo {\n    const char *Ptr;      // Where in memory the load command is.\n    MachO::load_command C; // The command itself.\n  };\n  using LoadCommandList = SmallVector<LoadCommandInfo, 4>;\n  using load_command_iterator = LoadCommandList::const_iterator;\n\n  static Expected<std::unique_ptr<MachOObjectFile>>\n  create(MemoryBufferRef Object, bool IsLittleEndian, bool Is64Bits,\n         uint32_t UniversalCputype = 0, uint32_t UniversalIndex = 0);\n\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n\n  uint64_t getNValue(DataRefImpl Sym) const;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n\n  // MachO specific.\n  Error checkSymbolTable() const;\n\n  std::error_code getIndirectName(DataRefImpl Symb, StringRef &Res) const;\n  unsigned getSectionType(SectionRef Sec) const;\n\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n  unsigned getSymbolSectionID(SymbolRef Symb) const;\n  unsigned getSectionID(SectionRef Sec) const;\n\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  ArrayRef<uint8_t> getSectionContents(uint32_t Offset, uint64_t Size) const;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  Expected<SectionRef> getSection(unsigned SectionIndex) const;\n  Expected<SectionRef> getSection(StringRef SectionName) const;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  bool isSectionBitcode(DataRefImpl Sec) const override;\n  bool isDebugSection(StringRef SectionName) const override;\n\n  /// When dsymutil generates the companion file, it strips all unnecessary\n  /// sections (e.g. everything in the _TEXT segment) by omitting their body\n  /// and setting the offset in their corresponding load command to zero.\n  ///\n  /// While the load command itself is valid, reading the section corresponds\n  /// to reading the number of bytes specified in the load command, starting\n  /// from offset 0 (i.e. the Mach-O header at the beginning of the file).\n  bool isSectionStripped(DataRefImpl Sec) const override;\n\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n\n  relocation_iterator extrel_begin() const;\n  relocation_iterator extrel_end() const;\n  iterator_range<relocation_iterator> external_relocations() const {\n    return make_range(extrel_begin(), extrel_end());\n  }\n\n  relocation_iterator locrel_begin() const;\n  relocation_iterator locrel_end() const;\n\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  section_iterator getRelocationSection(DataRefImpl Rel) const;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n  uint8_t getRelocationLength(DataRefImpl Rel) const;\n\n  // MachO specific.\n  std::error_code getLibraryShortNameByIndex(unsigned Index, StringRef &) const;\n  uint32_t getLibraryCount() const;\n\n  section_iterator getRelocationRelocatedSection(relocation_iterator Rel) const;\n\n  // TODO: Would be useful to have an iterator based version\n  // of the load command interface too.\n\n  basic_symbol_iterator symbol_begin() const override;\n  basic_symbol_iterator symbol_end() const override;\n\n  // MachO specific.\n  symbol_iterator getSymbolByIndex(unsigned Index) const;\n  uint64_t getSymbolIndex(DataRefImpl Symb) const;\n\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n\n  uint8_t getBytesInAddress() const override;\n\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  SubtargetFeatures getFeatures() const override { return SubtargetFeatures(); }\n  Triple getArchTriple(const char **McpuDefault = nullptr) const;\n\n  relocation_iterator section_rel_begin(unsigned Index) const;\n  relocation_iterator section_rel_end(unsigned Index) const;\n\n  dice_iterator begin_dices() const;\n  dice_iterator end_dices() const;\n\n  load_command_iterator begin_load_commands() const;\n  load_command_iterator end_load_commands() const;\n  iterator_range<load_command_iterator> load_commands() const;\n\n  /// For use iterating over all exported symbols.\n  iterator_range<export_iterator> exports(Error &Err) const;\n\n  /// For use examining a trie not in a MachOObjectFile.\n  static iterator_range<export_iterator> exports(Error &Err,\n                                                 ArrayRef<uint8_t> Trie,\n                                                 const MachOObjectFile *O =\n                                                                      nullptr);\n\n  /// For use iterating over all rebase table entries.\n  iterator_range<rebase_iterator> rebaseTable(Error &Err);\n\n  /// For use examining rebase opcodes in a MachOObjectFile.\n  static iterator_range<rebase_iterator> rebaseTable(Error &Err,\n                                                     MachOObjectFile *O,\n                                                     ArrayRef<uint8_t> Opcodes,\n                                                     bool is64);\n\n  /// For use iterating over all bind table entries.\n  iterator_range<bind_iterator> bindTable(Error &Err);\n\n  /// For use iterating over all lazy bind table entries.\n  iterator_range<bind_iterator> lazyBindTable(Error &Err);\n\n  /// For use iterating over all weak bind table entries.\n  iterator_range<bind_iterator> weakBindTable(Error &Err);\n\n  /// For use examining bind opcodes in a MachOObjectFile.\n  static iterator_range<bind_iterator> bindTable(Error &Err,\n                                                 MachOObjectFile *O,\n                                                 ArrayRef<uint8_t> Opcodes,\n                                                 bool is64,\n                                                 MachOBindEntry::Kind);\n\n  // Given a SegIndex, SegOffset, and PointerSize, verify a valid section exists\n  // that fully contains a pointer at that location. Multiple fixups in a bind\n  // (such as with the BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB opcode) can\n  // be tested via the Count and Skip parameters.\n  //\n  // This is used by MachOBindEntry::moveNext() to validate a MachOBindEntry.\n  const char *BindEntryCheckSegAndOffsets(int32_t SegIndex, uint64_t SegOffset,\n                                         uint8_t PointerSize, uint32_t Count=1,\n                                          uint32_t Skip=0) const {\n    return BindRebaseSectionTable->checkSegAndOffsets(SegIndex, SegOffset,\n                                                     PointerSize, Count, Skip);\n  }\n\n  // Given a SegIndex, SegOffset, and PointerSize, verify a valid section exists\n  // that fully contains a pointer at that location. Multiple fixups in a rebase\n  // (such as with the REBASE_OPCODE_DO_*_TIMES* opcodes) can be tested via the\n  // Count and Skip parameters.\n  //\n  // This is used by MachORebaseEntry::moveNext() to validate a MachORebaseEntry\n  const char *RebaseEntryCheckSegAndOffsets(int32_t SegIndex,\n                                            uint64_t SegOffset,\n                                            uint8_t PointerSize,\n                                            uint32_t Count=1,\n                                            uint32_t Skip=0) const {\n    return BindRebaseSectionTable->checkSegAndOffsets(SegIndex, SegOffset,\n                                                      PointerSize, Count, Skip);\n  }\n\n  /// For use with the SegIndex of a checked Mach-O Bind or Rebase entry to\n  /// get the segment name.\n  StringRef BindRebaseSegmentName(int32_t SegIndex) const {\n    return BindRebaseSectionTable->segmentName(SegIndex);\n  }\n\n  /// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or\n  /// Rebase entry to get the section name.\n  StringRef BindRebaseSectionName(uint32_t SegIndex, uint64_t SegOffset) const {\n    return BindRebaseSectionTable->sectionName(SegIndex, SegOffset);\n  }\n\n  /// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or\n  /// Rebase entry to get the address.\n  uint64_t BindRebaseAddress(uint32_t SegIndex, uint64_t SegOffset) const {\n    return BindRebaseSectionTable->address(SegIndex, SegOffset);\n  }\n\n  // In a MachO file, sections have a segment name. This is used in the .o\n  // files. They have a single segment, but this field specifies which segment\n  // a section should be put in the final object.\n  StringRef getSectionFinalSegmentName(DataRefImpl Sec) const;\n\n  // Names are stored as 16 bytes. These returns the raw 16 bytes without\n  // interpreting them as a C string.\n  ArrayRef<char> getSectionRawName(DataRefImpl Sec) const;\n  ArrayRef<char> getSectionRawFinalSegmentName(DataRefImpl Sec) const;\n\n  // MachO specific Info about relocations.\n  bool isRelocationScattered(const MachO::any_relocation_info &RE) const;\n  unsigned getPlainRelocationSymbolNum(\n                                    const MachO::any_relocation_info &RE) const;\n  bool getPlainRelocationExternal(const MachO::any_relocation_info &RE) const;\n  bool getScatteredRelocationScattered(\n                                    const MachO::any_relocation_info &RE) const;\n  uint32_t getScatteredRelocationValue(\n                                    const MachO::any_relocation_info &RE) const;\n  uint32_t getScatteredRelocationType(\n                                    const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationAddress(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationPCRel(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationLength(const MachO::any_relocation_info &RE) const;\n  unsigned getAnyRelocationType(const MachO::any_relocation_info &RE) const;\n  SectionRef getAnyRelocationSection(const MachO::any_relocation_info &RE) const;\n\n  // MachO specific structures.\n  MachO::section getSection(DataRefImpl DRI) const;\n  MachO::section_64 getSection64(DataRefImpl DRI) const;\n  MachO::section getSection(const LoadCommandInfo &L, unsigned Index) const;\n  MachO::section_64 getSection64(const LoadCommandInfo &L,unsigned Index) const;\n  MachO::nlist getSymbolTableEntry(DataRefImpl DRI) const;\n  MachO::nlist_64 getSymbol64TableEntry(DataRefImpl DRI) const;\n\n  MachO::linkedit_data_command\n  getLinkeditDataLoadCommand(const LoadCommandInfo &L) const;\n  MachO::segment_command\n  getSegmentLoadCommand(const LoadCommandInfo &L) const;\n  MachO::segment_command_64\n  getSegment64LoadCommand(const LoadCommandInfo &L) const;\n  MachO::linker_option_command\n  getLinkerOptionLoadCommand(const LoadCommandInfo &L) const;\n  MachO::version_min_command\n  getVersionMinLoadCommand(const LoadCommandInfo &L) const;\n  MachO::note_command\n  getNoteLoadCommand(const LoadCommandInfo &L) const;\n  MachO::build_version_command\n  getBuildVersionLoadCommand(const LoadCommandInfo &L) const;\n  MachO::build_tool_version\n  getBuildToolVersion(unsigned index) const;\n  MachO::dylib_command\n  getDylibIDLoadCommand(const LoadCommandInfo &L) const;\n  MachO::dyld_info_command\n  getDyldInfoLoadCommand(const LoadCommandInfo &L) const;\n  MachO::dylinker_command\n  getDylinkerCommand(const LoadCommandInfo &L) const;\n  MachO::uuid_command\n  getUuidCommand(const LoadCommandInfo &L) const;\n  MachO::rpath_command\n  getRpathCommand(const LoadCommandInfo &L) const;\n  MachO::source_version_command\n  getSourceVersionCommand(const LoadCommandInfo &L) const;\n  MachO::entry_point_command\n  getEntryPointCommand(const LoadCommandInfo &L) const;\n  MachO::encryption_info_command\n  getEncryptionInfoCommand(const LoadCommandInfo &L) const;\n  MachO::encryption_info_command_64\n  getEncryptionInfoCommand64(const LoadCommandInfo &L) const;\n  MachO::sub_framework_command\n  getSubFrameworkCommand(const LoadCommandInfo &L) const;\n  MachO::sub_umbrella_command\n  getSubUmbrellaCommand(const LoadCommandInfo &L) const;\n  MachO::sub_library_command\n  getSubLibraryCommand(const LoadCommandInfo &L) const;\n  MachO::sub_client_command\n  getSubClientCommand(const LoadCommandInfo &L) const;\n  MachO::routines_command\n  getRoutinesCommand(const LoadCommandInfo &L) const;\n  MachO::routines_command_64\n  getRoutinesCommand64(const LoadCommandInfo &L) const;\n  MachO::thread_command\n  getThreadCommand(const LoadCommandInfo &L) const;\n\n  MachO::any_relocation_info getRelocation(DataRefImpl Rel) const;\n  MachO::data_in_code_entry getDice(DataRefImpl Rel) const;\n  const MachO::mach_header &getHeader() const;\n  const MachO::mach_header_64 &getHeader64() const;\n  uint32_t\n  getIndirectSymbolTableEntry(const MachO::dysymtab_command &DLC,\n                              unsigned Index) const;\n  MachO::data_in_code_entry getDataInCodeTableEntry(uint32_t DataOffset,\n                                                    unsigned Index) const;\n  MachO::symtab_command getSymtabLoadCommand() const;\n  MachO::dysymtab_command getDysymtabLoadCommand() const;\n  MachO::linkedit_data_command getDataInCodeLoadCommand() const;\n  MachO::linkedit_data_command getLinkOptHintsLoadCommand() const;\n  ArrayRef<uint8_t> getDyldInfoRebaseOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoWeakBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoLazyBindOpcodes() const;\n  ArrayRef<uint8_t> getDyldInfoExportsTrie() const;\n  ArrayRef<uint8_t> getUuid() const;\n\n  StringRef getStringTableData() const;\n  bool is64Bit() const;\n  void ReadULEB128s(uint64_t Index, SmallVectorImpl<uint64_t> &Out) const;\n\n  static StringRef guessLibraryShortName(StringRef Name, bool &isFramework,\n                                         StringRef &Suffix);\n\n  static Triple::ArchType getArch(uint32_t CPUType, uint32_t CPUSubType);\n  static Triple getArchTriple(uint32_t CPUType, uint32_t CPUSubType,\n                              const char **McpuDefault = nullptr,\n                              const char **ArchFlag = nullptr);\n  static bool isValidArch(StringRef ArchFlag);\n  static ArrayRef<StringRef> getValidArchs();\n  static Triple getHostArch();\n\n  bool isRelocatableObject() const override;\n\n  StringRef mapDebugSectionName(StringRef Name) const override;\n\n  bool hasPageZeroSegment() const { return HasPageZeroSegment; }\n\n  static bool classof(const Binary *v) {\n    return v->isMachO();\n  }\n\n  static uint32_t\n  getVersionMinMajor(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return (VersionOrSDK >> 16) & 0xffff;\n  }\n\n  static uint32_t\n  getVersionMinMinor(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return (VersionOrSDK >> 8) & 0xff;\n  }\n\n  static uint32_t\n  getVersionMinUpdate(MachO::version_min_command &C, bool SDK) {\n    uint32_t VersionOrSDK = (SDK) ? C.sdk : C.version;\n    return VersionOrSDK & 0xff;\n  }\n\n  static std::string getBuildPlatform(uint32_t platform) {\n    switch (platform) {\n    case MachO::PLATFORM_MACOS: return \"macos\";\n    case MachO::PLATFORM_IOS: return \"ios\";\n    case MachO::PLATFORM_TVOS: return \"tvos\";\n    case MachO::PLATFORM_WATCHOS: return \"watchos\";\n    case MachO::PLATFORM_BRIDGEOS: return \"bridgeos\";\n    case MachO::PLATFORM_MACCATALYST: return \"macCatalyst\";\n    case MachO::PLATFORM_IOSSIMULATOR: return \"iossimulator\";\n    case MachO::PLATFORM_TVOSSIMULATOR: return \"tvossimulator\";\n    case MachO::PLATFORM_WATCHOSSIMULATOR: return \"watchossimulator\";\n    case MachO::PLATFORM_DRIVERKIT: return \"driverkit\";\n    default:\n      std::string ret;\n      raw_string_ostream ss(ret);\n      ss << format_hex(platform, 8, true);\n      return ss.str();\n    }\n  }\n\n  static std::string getBuildTool(uint32_t tools) {\n    switch (tools) {\n    case MachO::TOOL_CLANG: return \"clang\";\n    case MachO::TOOL_SWIFT: return \"swift\";\n    case MachO::TOOL_LD: return \"ld\";\n    default:\n      std::string ret;\n      raw_string_ostream ss(ret);\n      ss << format_hex(tools, 8, true);\n      return ss.str();\n    }\n  }\n\n  static std::string getVersionString(uint32_t version) {\n    uint32_t major = (version >> 16) & 0xffff;\n    uint32_t minor = (version >> 8) & 0xff;\n    uint32_t update = version & 0xff;\n\n    SmallString<32> Version;\n    Version = utostr(major) + \".\" + utostr(minor);\n    if (update != 0)\n      Version += \".\" + utostr(update);\n    return std::string(std::string(Version.str()));\n  }\n\nprivate:\n  MachOObjectFile(MemoryBufferRef Object, bool IsLittleEndian, bool Is64Bits,\n                  Error &Err, uint32_t UniversalCputype = 0,\n                  uint32_t UniversalIndex = 0);\n\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n\n  union {\n    MachO::mach_header_64 Header64;\n    MachO::mach_header Header;\n  };\n  using SectionList = SmallVector<const char*, 1>;\n  SectionList Sections;\n  using LibraryList = SmallVector<const char*, 1>;\n  LibraryList Libraries;\n  LoadCommandList LoadCommands;\n  using LibraryShortName = SmallVector<StringRef, 1>;\n  using BuildToolList = SmallVector<const char*, 1>;\n  BuildToolList BuildTools;\n  mutable LibraryShortName LibrariesShortNames;\n  std::unique_ptr<BindRebaseSegInfo> BindRebaseSectionTable;\n  const char *SymtabLoadCmd = nullptr;\n  const char *DysymtabLoadCmd = nullptr;\n  const char *DataInCodeLoadCmd = nullptr;\n  const char *LinkOptHintsLoadCmd = nullptr;\n  const char *DyldInfoLoadCmd = nullptr;\n  const char *UuidLoadCmd = nullptr;\n  bool HasPageZeroSegment = false;\n};\n\n/// DiceRef\ninline DiceRef::DiceRef(DataRefImpl DiceP, const ObjectFile *Owner)\n  : DicePimpl(DiceP) , OwningObject(Owner) {}\n\ninline bool DiceRef::operator==(const DiceRef &Other) const {\n  return DicePimpl == Other.DicePimpl;\n}\n\ninline bool DiceRef::operator<(const DiceRef &Other) const {\n  return DicePimpl < Other.DicePimpl;\n}\n\ninline void DiceRef::moveNext() {\n  const MachO::data_in_code_entry *P =\n    reinterpret_cast<const MachO::data_in_code_entry *>(DicePimpl.p);\n  DicePimpl.p = reinterpret_cast<uintptr_t>(P + 1);\n}\n\n// Since a Mach-O data in code reference, a DiceRef, can only be created when\n// the OwningObject ObjectFile is a MachOObjectFile a static_cast<> is used for\n// the methods that get the values of the fields of the reference.\n\ninline std::error_code DiceRef::getOffset(uint32_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.offset;\n  return std::error_code();\n}\n\ninline std::error_code DiceRef::getLength(uint16_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.length;\n  return std::error_code();\n}\n\ninline std::error_code DiceRef::getKind(uint16_t &Result) const {\n  const MachOObjectFile *MachOOF =\n    static_cast<const MachOObjectFile *>(OwningObject);\n  MachO::data_in_code_entry Dice = MachOOF->getDice(DicePimpl);\n  Result = Dice.kind;\n  return std::error_code();\n}\n\ninline DataRefImpl DiceRef::getRawDataRefImpl() const {\n  return DicePimpl;\n}\n\ninline const ObjectFile *DiceRef::getObjectFile() const {\n  return OwningObject;\n}\n\n} // end namespace object\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_MACHO_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Wasm.h", "content": "//===- Wasm.h - Wasm object file implementation -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the WasmObjectFile class, which implements the ObjectFile\n// interface for Wasm files.\n//\n// See: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OBJECT_WASM_H\n#define LLVM_OBJECT_WASM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Wasm.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/MC/MCSymbolWasm.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\nnamespace object {\n\nclass WasmSymbol {\npublic:\n  WasmSymbol(const wasm::WasmSymbolInfo &Info,\n             const wasm::WasmGlobalType *GlobalType,\n             const wasm::WasmTableType *TableType,\n             const wasm::WasmEventType *EventType,\n             const wasm::WasmSignature *Signature)\n      : Info(Info), GlobalType(GlobalType), TableType(TableType),\n        EventType(EventType), Signature(Signature) {}\n\n  const wasm::WasmSymbolInfo &Info;\n  const wasm::WasmGlobalType *GlobalType;\n  const wasm::WasmTableType *TableType;\n  const wasm::WasmEventType *EventType;\n  const wasm::WasmSignature *Signature;\n\n  bool isTypeFunction() const {\n    return Info.Kind == wasm::WASM_SYMBOL_TYPE_FUNCTION;\n  }\n\n  bool isTypeTable() const { return Info.Kind == wasm::WASM_SYMBOL_TYPE_TABLE; }\n\n  bool isTypeData() const { return Info.Kind == wasm::WASM_SYMBOL_TYPE_DATA; }\n\n  bool isTypeGlobal() const {\n    return Info.Kind == wasm::WASM_SYMBOL_TYPE_GLOBAL;\n  }\n\n  bool isTypeSection() const {\n    return Info.Kind == wasm::WASM_SYMBOL_TYPE_SECTION;\n  }\n\n  bool isTypeEvent() const { return Info.Kind == wasm::WASM_SYMBOL_TYPE_EVENT; }\n\n  bool isDefined() const { return !isUndefined(); }\n\n  bool isUndefined() const {\n    return (Info.Flags & wasm::WASM_SYMBOL_UNDEFINED) != 0;\n  }\n\n  bool isBindingWeak() const {\n    return getBinding() == wasm::WASM_SYMBOL_BINDING_WEAK;\n  }\n\n  bool isBindingGlobal() const {\n    return getBinding() == wasm::WASM_SYMBOL_BINDING_GLOBAL;\n  }\n\n  bool isBindingLocal() const {\n    return getBinding() == wasm::WASM_SYMBOL_BINDING_LOCAL;\n  }\n\n  unsigned getBinding() const {\n    return Info.Flags & wasm::WASM_SYMBOL_BINDING_MASK;\n  }\n\n  bool isHidden() const {\n    return getVisibility() == wasm::WASM_SYMBOL_VISIBILITY_HIDDEN;\n  }\n\n  unsigned getVisibility() const {\n    return Info.Flags & wasm::WASM_SYMBOL_VISIBILITY_MASK;\n  }\n\n  void print(raw_ostream &Out) const;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const;\n#endif\n};\n\nstruct WasmSection {\n  WasmSection() = default;\n\n  uint32_t Type = 0;         // Section type (See below)\n  uint32_t Offset = 0;       // Offset with in the file\n  StringRef Name;            // Section name (User-defined sections only)\n  uint32_t Comdat = UINT32_MAX; // From the \"comdat info\" section\n  ArrayRef<uint8_t> Content; // Section content\n  std::vector<wasm::WasmRelocation> Relocations; // Relocations for this section\n};\n\nstruct WasmSegment {\n  uint32_t SectionOffset;\n  wasm::WasmDataSegment Data;\n};\n\nclass WasmObjectFile : public ObjectFile {\n\npublic:\n  WasmObjectFile(MemoryBufferRef Object, Error &Err);\n\n  const wasm::WasmObjectHeader &getHeader() const;\n  const WasmSymbol &getWasmSymbol(const DataRefImpl &Symb) const;\n  const WasmSymbol &getWasmSymbol(const SymbolRef &Symbol) const;\n  const WasmSection &getWasmSection(const SectionRef &Section) const;\n  const wasm::WasmRelocation &getWasmRelocation(const RelocationRef &Ref) const;\n\n  static bool classof(const Binary *v) { return v->isWasm(); }\n\n  const wasm::WasmDylinkInfo &dylinkInfo() const { return DylinkInfo; }\n  const wasm::WasmProducerInfo &getProducerInfo() const { return ProducerInfo; }\n  ArrayRef<wasm::WasmFeatureEntry> getTargetFeatures() const {\n    return TargetFeatures;\n  }\n  ArrayRef<wasm::WasmSignature> types() const { return Signatures; }\n  ArrayRef<uint32_t> functionTypes() const { return FunctionTypes; }\n  ArrayRef<wasm::WasmImport> imports() const { return Imports; }\n  ArrayRef<wasm::WasmTable> tables() const { return Tables; }\n  ArrayRef<wasm::WasmLimits> memories() const { return Memories; }\n  ArrayRef<wasm::WasmGlobal> globals() const { return Globals; }\n  ArrayRef<wasm::WasmEvent> events() const { return Events; }\n  ArrayRef<wasm::WasmExport> exports() const { return Exports; }\n  ArrayRef<WasmSymbol> syms() const { return Symbols; }\n  const wasm::WasmLinkingData &linkingData() const { return LinkingData; }\n  uint32_t getNumberOfSymbols() const { return Symbols.size(); }\n  ArrayRef<wasm::WasmElemSegment> elements() const { return ElemSegments; }\n  ArrayRef<WasmSegment> dataSegments() const { return DataSegments; }\n  ArrayRef<wasm::WasmFunction> functions() const { return Functions; }\n  ArrayRef<wasm::WasmDebugName> debugNames() const { return DebugNames; }\n  uint32_t startFunction() const { return StartFunction; }\n  uint32_t getNumImportedGlobals() const { return NumImportedGlobals; }\n  uint32_t getNumImportedTables() const { return NumImportedTables; }\n  uint32_t getNumImportedFunctions() const { return NumImportedFunctions; }\n  uint32_t getNumImportedEvents() const { return NumImportedEvents; }\n  uint32_t getNumSections() const { return Sections.size(); }\n  void moveSymbolNext(DataRefImpl &Symb) const override;\n\n  Expected<uint32_t> getSymbolFlags(DataRefImpl Symb) const override;\n\n  basic_symbol_iterator symbol_begin() const override;\n\n  basic_symbol_iterator symbol_end() const override;\n  Expected<StringRef> getSymbolName(DataRefImpl Symb) const override;\n\n  Expected<uint64_t> getSymbolAddress(DataRefImpl Symb) const override;\n  uint64_t getWasmSymbolValue(const WasmSymbol &Sym) const;\n  uint64_t getSymbolValueImpl(DataRefImpl Symb) const override;\n  uint32_t getSymbolAlignment(DataRefImpl Symb) const override;\n  uint64_t getCommonSymbolSizeImpl(DataRefImpl Symb) const override;\n  Expected<SymbolRef::Type> getSymbolType(DataRefImpl Symb) const override;\n  Expected<section_iterator> getSymbolSection(DataRefImpl Symb) const override;\n  uint32_t getSymbolSectionId(SymbolRef Sym) const;\n\n  // Overrides from SectionRef.\n  void moveSectionNext(DataRefImpl &Sec) const override;\n  Expected<StringRef> getSectionName(DataRefImpl Sec) const override;\n  uint64_t getSectionAddress(DataRefImpl Sec) const override;\n  uint64_t getSectionIndex(DataRefImpl Sec) const override;\n  uint64_t getSectionSize(DataRefImpl Sec) const override;\n  Expected<ArrayRef<uint8_t>>\n  getSectionContents(DataRefImpl Sec) const override;\n  uint64_t getSectionAlignment(DataRefImpl Sec) const override;\n  bool isSectionCompressed(DataRefImpl Sec) const override;\n  bool isSectionText(DataRefImpl Sec) const override;\n  bool isSectionData(DataRefImpl Sec) const override;\n  bool isSectionBSS(DataRefImpl Sec) const override;\n  bool isSectionVirtual(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_begin(DataRefImpl Sec) const override;\n  relocation_iterator section_rel_end(DataRefImpl Sec) const override;\n\n  // Overrides from RelocationRef.\n  void moveRelocationNext(DataRefImpl &Rel) const override;\n  uint64_t getRelocationOffset(DataRefImpl Rel) const override;\n  symbol_iterator getRelocationSymbol(DataRefImpl Rel) const override;\n  uint64_t getRelocationType(DataRefImpl Rel) const override;\n  void getRelocationTypeName(DataRefImpl Rel,\n                             SmallVectorImpl<char> &Result) const override;\n\n  section_iterator section_begin() const override;\n  section_iterator section_end() const override;\n  uint8_t getBytesInAddress() const override;\n  StringRef getFileFormatName() const override;\n  Triple::ArchType getArch() const override;\n  SubtargetFeatures getFeatures() const override;\n  bool isRelocatableObject() const override;\n  bool isSharedObject() const;\n\n  struct ReadContext {\n    const uint8_t *Start;\n    const uint8_t *Ptr;\n    const uint8_t *End;\n  };\n\nprivate:\n  bool isValidFunctionIndex(uint32_t Index) const;\n  bool isDefinedFunctionIndex(uint32_t Index) const;\n  bool isValidGlobalIndex(uint32_t Index) const;\n  bool isValidTableNumber(uint32_t Index) const;\n  bool isDefinedGlobalIndex(uint32_t Index) const;\n  bool isDefinedTableNumber(uint32_t Index) const;\n  bool isValidEventIndex(uint32_t Index) const;\n  bool isDefinedEventIndex(uint32_t Index) const;\n  bool isValidFunctionSymbol(uint32_t Index) const;\n  bool isValidTableSymbol(uint32_t Index) const;\n  bool isValidGlobalSymbol(uint32_t Index) const;\n  bool isValidEventSymbol(uint32_t Index) const;\n  bool isValidDataSymbol(uint32_t Index) const;\n  bool isValidSectionSymbol(uint32_t Index) const;\n  wasm::WasmFunction &getDefinedFunction(uint32_t Index);\n  const wasm::WasmFunction &getDefinedFunction(uint32_t Index) const;\n  wasm::WasmGlobal &getDefinedGlobal(uint32_t Index);\n  wasm::WasmEvent &getDefinedEvent(uint32_t Index);\n\n  const WasmSection &getWasmSection(DataRefImpl Ref) const;\n  const wasm::WasmRelocation &getWasmRelocation(DataRefImpl Ref) const;\n  uint32_t getSymbolSectionIdImpl(const WasmSymbol &Symb) const;\n\n  Error parseSection(WasmSection &Sec);\n  Error parseCustomSection(WasmSection &Sec, ReadContext &Ctx);\n\n  // Standard section types\n  Error parseTypeSection(ReadContext &Ctx);\n  Error parseImportSection(ReadContext &Ctx);\n  Error parseFunctionSection(ReadContext &Ctx);\n  Error parseTableSection(ReadContext &Ctx);\n  Error parseMemorySection(ReadContext &Ctx);\n  Error parseEventSection(ReadContext &Ctx);\n  Error parseGlobalSection(ReadContext &Ctx);\n  Error parseExportSection(ReadContext &Ctx);\n  Error parseStartSection(ReadContext &Ctx);\n  Error parseElemSection(ReadContext &Ctx);\n  Error parseCodeSection(ReadContext &Ctx);\n  Error parseDataSection(ReadContext &Ctx);\n  Error parseDataCountSection(ReadContext &Ctx);\n\n  // Custom section types\n  Error parseDylinkSection(ReadContext &Ctx);\n  Error parseNameSection(ReadContext &Ctx);\n  Error parseLinkingSection(ReadContext &Ctx);\n  Error parseLinkingSectionSymtab(ReadContext &Ctx);\n  Error parseLinkingSectionComdat(ReadContext &Ctx);\n  Error parseProducersSection(ReadContext &Ctx);\n  Error parseTargetFeaturesSection(ReadContext &Ctx);\n  Error parseRelocSection(StringRef Name, ReadContext &Ctx);\n\n  wasm::WasmObjectHeader Header;\n  std::vector<WasmSection> Sections;\n  wasm::WasmDylinkInfo DylinkInfo;\n  wasm::WasmProducerInfo ProducerInfo;\n  std::vector<wasm::WasmFeatureEntry> TargetFeatures;\n  std::vector<wasm::WasmSignature> Signatures;\n  std::vector<uint32_t> FunctionTypes;\n  std::vector<wasm::WasmTable> Tables;\n  std::vector<wasm::WasmLimits> Memories;\n  std::vector<wasm::WasmGlobal> Globals;\n  std::vector<wasm::WasmEvent> Events;\n  std::vector<wasm::WasmImport> Imports;\n  std::vector<wasm::WasmExport> Exports;\n  std::vector<wasm::WasmElemSegment> ElemSegments;\n  std::vector<WasmSegment> DataSegments;\n  llvm::Optional<size_t> DataCount;\n  std::vector<wasm::WasmFunction> Functions;\n  std::vector<WasmSymbol> Symbols;\n  std::vector<wasm::WasmDebugName> DebugNames;\n  uint32_t StartFunction = -1;\n  bool HasLinkingSection = false;\n  bool HasDylinkSection = false;\n  bool SeenCodeSection = false;\n  bool HasMemory64 = false;\n  wasm::WasmLinkingData LinkingData;\n  uint32_t NumImportedGlobals = 0;\n  uint32_t NumImportedTables = 0;\n  uint32_t NumImportedFunctions = 0;\n  uint32_t NumImportedEvents = 0;\n  uint32_t CodeSection = 0;\n  uint32_t DataSection = 0;\n  uint32_t EventSection = 0;\n  uint32_t GlobalSection = 0;\n  uint32_t TableSection = 0;\n};\n\nclass WasmSectionOrderChecker {\npublic:\n  // We define orders for all core wasm sections and known custom sections.\n  enum : int {\n    // Sentinel, must be zero\n    WASM_SEC_ORDER_NONE = 0,\n\n    // Core sections\n    WASM_SEC_ORDER_TYPE,\n    WASM_SEC_ORDER_IMPORT,\n    WASM_SEC_ORDER_FUNCTION,\n    WASM_SEC_ORDER_TABLE,\n    WASM_SEC_ORDER_MEMORY,\n    WASM_SEC_ORDER_EVENT,\n    WASM_SEC_ORDER_GLOBAL,\n    WASM_SEC_ORDER_EXPORT,\n    WASM_SEC_ORDER_START,\n    WASM_SEC_ORDER_ELEM,\n    WASM_SEC_ORDER_DATACOUNT,\n    WASM_SEC_ORDER_CODE,\n    WASM_SEC_ORDER_DATA,\n\n    // Custom sections\n    // \"dylink\" should be the very first section in the module\n    WASM_SEC_ORDER_DYLINK,\n    // \"linking\" section requires DATA section in order to validate data symbols\n    WASM_SEC_ORDER_LINKING,\n    // Must come after \"linking\" section in order to validate reloc indexes.\n    WASM_SEC_ORDER_RELOC,\n    // \"name\" section must appear after DATA. Comes after \"linking\" to allow\n    // symbol table to set default function name.\n    WASM_SEC_ORDER_NAME,\n    // \"producers\" section must appear after \"name\" section.\n    WASM_SEC_ORDER_PRODUCERS,\n    // \"target_features\" section must appear after producers section\n    WASM_SEC_ORDER_TARGET_FEATURES,\n\n    // Must be last\n    WASM_NUM_SEC_ORDERS\n\n  };\n\n  // Sections that may or may not be present, but cannot be predecessors\n  static int DisallowedPredecessors[WASM_NUM_SEC_ORDERS][WASM_NUM_SEC_ORDERS];\n\n  bool isValidSectionOrder(unsigned ID, StringRef CustomSectionName = \"\");\n\nprivate:\n  bool Seen[WASM_NUM_SEC_ORDERS] = {}; // Sections that have been seen already\n\n  // Returns -1 for unknown sections.\n  int getSectionOrder(unsigned ID, StringRef CustomSectionName = \"\");\n};\n\n} // end namespace object\n\ninline raw_ostream &operator<<(raw_ostream &OS, const object::WasmSymbol &Sym) {\n  Sym.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_OBJECT_WASM_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMAttributeParser.h", "content": "//===- ARMAttributeParser.h - ARM Attribute Information Printer -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ARMATTRIBUTEPARSER_H\n#define LLVM_SUPPORT_ARMATTRIBUTEPARSER_H\n\n#include \"ARMBuildAttributes.h\"\n#include \"ELFAttributeParser.h\"\n#include \"ScopedPrinter.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\nclass StringRef;\n\nclass ARMAttributeParser : public ELFAttributeParser {\n  struct DisplayHandler {\n    ARMBuildAttrs::AttrType attribute;\n    Error (ARMAttributeParser::*routine)(ARMBuildAttrs::AttrType);\n  };\n  static const DisplayHandler displayRoutines[];\n\n  Error handler(uint64_t tag, bool &handled) override;\n\n  Error stringAttribute(ARMBuildAttrs::AttrType tag);\n\n  Error CPU_arch(ARMBuildAttrs::AttrType tag);\n  Error CPU_arch_profile(ARMBuildAttrs::AttrType tag);\n  Error ARM_ISA_use(ARMBuildAttrs::AttrType tag);\n  Error THUMB_ISA_use(ARMBuildAttrs::AttrType tag);\n  Error FP_arch(ARMBuildAttrs::AttrType tag);\n  Error WMMX_arch(ARMBuildAttrs::AttrType tag);\n  Error Advanced_SIMD_arch(ARMBuildAttrs::AttrType tag);\n  Error MVE_arch(ARMBuildAttrs::AttrType tag);\n  Error PCS_config(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_R9_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_RW_data(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_RO_data(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_GOT_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_PCS_wchar_t(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_rounding(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_denormal(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_exceptions(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_user_exceptions(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_number_model(ARMBuildAttrs::AttrType tag);\n  Error ABI_align_needed(ARMBuildAttrs::AttrType tag);\n  Error ABI_align_preserved(ARMBuildAttrs::AttrType tag);\n  Error ABI_enum_size(ARMBuildAttrs::AttrType tag);\n  Error ABI_HardFP_use(ARMBuildAttrs::AttrType tag);\n  Error ABI_VFP_args(ARMBuildAttrs::AttrType tag);\n  Error ABI_WMMX_args(ARMBuildAttrs::AttrType tag);\n  Error ABI_optimization_goals(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_optimization_goals(ARMBuildAttrs::AttrType tag);\n  Error compatibility(ARMBuildAttrs::AttrType tag);\n  Error CPU_unaligned_access(ARMBuildAttrs::AttrType tag);\n  Error FP_HP_extension(ARMBuildAttrs::AttrType tag);\n  Error ABI_FP_16bit_format(ARMBuildAttrs::AttrType tag);\n  Error MPextension_use(ARMBuildAttrs::AttrType tag);\n  Error DIV_use(ARMBuildAttrs::AttrType tag);\n  Error DSP_extension(ARMBuildAttrs::AttrType tag);\n  Error T2EE_use(ARMBuildAttrs::AttrType tag);\n  Error Virtualization_use(ARMBuildAttrs::AttrType tag);\n  Error nodefaults(ARMBuildAttrs::AttrType tag);\n\npublic:\n  ARMAttributeParser(ScopedPrinter *sw)\n      : ELFAttributeParser(sw, ARMBuildAttrs::ARMAttributeTags, \"aeabi\") {}\n  ARMAttributeParser()\n      : ELFAttributeParser(ARMBuildAttrs::ARMAttributeTags, \"aeabi\") {}\n};\n}\n\n#endif\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "content": "//===- BinaryByteStream.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//===----------------------------------------------------------------------===//\n// A BinaryStream which stores data in a single continguous memory buffer.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BINARYBYTESTREAM_H\n#define LLVM_SUPPORT_BINARYBYTESTREAM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/BinaryStream.h\"\n#include \"llvm/Support/BinaryStreamError.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FileOutputBuffer.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <algorithm>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n\nnamespace llvm {\n\n/// An implementation of BinaryStream which holds its entire data set\n/// in a single contiguous buffer.  BinaryByteStream guarantees that no read\n/// operation will ever incur a copy.  Note that BinaryByteStream does not\n/// own the underlying buffer.\nclass BinaryByteStream : public BinaryStream {\npublic:\n  BinaryByteStream() = default;\n  BinaryByteStream(ArrayRef<uint8_t> Data, llvm::support::endianness Endian)\n      : Endian(Endian), Data(Data) {}\n  BinaryByteStream(StringRef Data, llvm::support::endianness Endian)\n      : Endian(Endian), Data(Data.bytes_begin(), Data.bytes_end()) {}\n\n  llvm::support::endianness getEndian() const override { return Endian; }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForRead(Offset, Size))\n      return EC;\n    Buffer = Data.slice(Offset, Size);\n    return Error::success();\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForRead(Offset, 1))\n      return EC;\n    Buffer = Data.slice(Offset);\n    return Error::success();\n  }\n\n  uint32_t getLength() override { return Data.size(); }\n\n  ArrayRef<uint8_t> data() const { return Data; }\n\n  StringRef str() const {\n    const char *CharData = reinterpret_cast<const char *>(Data.data());\n    return StringRef(CharData, Data.size());\n  }\n\nprotected:\n  llvm::support::endianness Endian;\n  ArrayRef<uint8_t> Data;\n};\n\n/// An implementation of BinaryStream whose data is backed by an llvm\n/// MemoryBuffer object.  MemoryBufferByteStream owns the MemoryBuffer in\n/// question.  As with BinaryByteStream, reading from a MemoryBufferByteStream\n/// will never cause a copy.\nclass MemoryBufferByteStream : public BinaryByteStream {\npublic:\n  MemoryBufferByteStream(std::unique_ptr<MemoryBuffer> Buffer,\n                         llvm::support::endianness Endian)\n      : BinaryByteStream(Buffer->getBuffer(), Endian),\n        MemBuffer(std::move(Buffer)) {}\n\n  std::unique_ptr<MemoryBuffer> MemBuffer;\n};\n\n/// An implementation of BinaryStream which holds its entire data set\n/// in a single contiguous buffer.  As with BinaryByteStream, the mutable\n/// version also guarantees that no read operation will ever incur a copy,\n/// and similarly it does not own the underlying buffer.\nclass MutableBinaryByteStream : public WritableBinaryStream {\npublic:\n  MutableBinaryByteStream() = default;\n  MutableBinaryByteStream(MutableArrayRef<uint8_t> Data,\n                          llvm::support::endianness Endian)\n      : Data(Data), ImmutableStream(Data, Endian) {}\n\n  llvm::support::endianness getEndian() const override {\n    return ImmutableStream.getEndian();\n  }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    return ImmutableStream.readBytes(Offset, Size, Buffer);\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    return ImmutableStream.readLongestContiguousChunk(Offset, Buffer);\n  }\n\n  uint32_t getLength() override { return ImmutableStream.getLength(); }\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Buffer) override {\n    if (Buffer.empty())\n      return Error::success();\n\n    if (auto EC = checkOffsetForWrite(Offset, Buffer.size()))\n      return EC;\n\n    uint8_t *DataPtr = const_cast<uint8_t *>(Data.data());\n    ::memcpy(DataPtr + Offset, Buffer.data(), Buffer.size());\n    return Error::success();\n  }\n\n  Error commit() override { return Error::success(); }\n\n  MutableArrayRef<uint8_t> data() const { return Data; }\n\nprivate:\n  MutableArrayRef<uint8_t> Data;\n  BinaryByteStream ImmutableStream;\n};\n\n/// An implementation of WritableBinaryStream which can write at its end\n/// causing the underlying data to grow.  This class owns the underlying data.\nclass AppendingBinaryByteStream : public WritableBinaryStream {\n  std::vector<uint8_t> Data;\n  llvm::support::endianness Endian = llvm::support::little;\n\npublic:\n  AppendingBinaryByteStream() = default;\n  AppendingBinaryByteStream(llvm::support::endianness Endian)\n      : Endian(Endian) {}\n\n  void clear() { Data.clear(); }\n\n  llvm::support::endianness getEndian() const override { return Endian; }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForWrite(Offset, Buffer.size()))\n      return EC;\n\n    Buffer = makeArrayRef(Data).slice(Offset, Size);\n    return Error::success();\n  }\n\n  void insert(uint32_t Offset, ArrayRef<uint8_t> Bytes) {\n    Data.insert(Data.begin() + Offset, Bytes.begin(), Bytes.end());\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForWrite(Offset, 1))\n      return EC;\n\n    Buffer = makeArrayRef(Data).slice(Offset);\n    return Error::success();\n  }\n\n  uint32_t getLength() override { return Data.size(); }\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Buffer) override {\n    if (Buffer.empty())\n      return Error::success();\n\n    // This is well-defined for any case except where offset is strictly\n    // greater than the current length.  If offset is equal to the current\n    // length, we can still grow.  If offset is beyond the current length, we\n    // would have to decide how to deal with the intermediate uninitialized\n    // bytes.  So we punt on that case for simplicity and just say it's an\n    // error.\n    if (Offset > getLength())\n      return make_error<BinaryStreamError>(stream_error_code::invalid_offset);\n\n    uint32_t RequiredSize = Offset + Buffer.size();\n    if (RequiredSize > Data.size())\n      Data.resize(RequiredSize);\n\n    ::memcpy(Data.data() + Offset, Buffer.data(), Buffer.size());\n    return Error::success();\n  }\n\n  Error commit() override { return Error::success(); }\n\n  /// Return the properties of this stream.\n  virtual BinaryStreamFlags getFlags() const override {\n    return BSF_Write | BSF_Append;\n  }\n\n  MutableArrayRef<uint8_t> data() { return Data; }\n};\n\n/// An implementation of WritableBinaryStream backed by an llvm\n/// FileOutputBuffer.\nclass FileBufferByteStream : public WritableBinaryStream {\nprivate:\n  class StreamImpl : public MutableBinaryByteStream {\n  public:\n    StreamImpl(std::unique_ptr<FileOutputBuffer> Buffer,\n               llvm::support::endianness Endian)\n        : MutableBinaryByteStream(\n              MutableArrayRef<uint8_t>(Buffer->getBufferStart(),\n                                       Buffer->getBufferEnd()),\n              Endian),\n          FileBuffer(std::move(Buffer)) {}\n\n    Error commit() override {\n      if (FileBuffer->commit())\n        return make_error<BinaryStreamError>(\n            stream_error_code::filesystem_error);\n      return Error::success();\n    }\n\n    /// Returns a pointer to the start of the buffer.\n    uint8_t *getBufferStart() const { return FileBuffer->getBufferStart(); }\n\n    /// Returns a pointer to the end of the buffer.\n    uint8_t *getBufferEnd() const { return FileBuffer->getBufferEnd(); }\n\n  private:\n    std::unique_ptr<FileOutputBuffer> FileBuffer;\n  };\n\npublic:\n  FileBufferByteStream(std::unique_ptr<FileOutputBuffer> Buffer,\n                       llvm::support::endianness Endian)\n      : Impl(std::move(Buffer), Endian) {}\n\n  llvm::support::endianness getEndian() const override {\n    return Impl.getEndian();\n  }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    return Impl.readBytes(Offset, Size, Buffer);\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    return Impl.readLongestContiguousChunk(Offset, Buffer);\n  }\n\n  uint32_t getLength() override { return Impl.getLength(); }\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Data) override {\n    return Impl.writeBytes(Offset, Data);\n  }\n\n  Error commit() override { return Impl.commit(); }\n\n  /// Returns a pointer to the start of the buffer.\n  uint8_t *getBufferStart() const { return Impl.getBufferStart(); }\n\n  /// Returns a pointer to the end of the buffer.\n  uint8_t *getBufferEnd() const { return Impl.getBufferEnd(); }\n\nprivate:\n  StreamImpl Impl;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_BINARYBYTESTREAM_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamError.h", "content": "//===- BinaryStreamError.h - Error extensions for Binary Streams *- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BINARYSTREAMERROR_H\n#define LLVM_SUPPORT_BINARYSTREAMERROR_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n\n#include <string>\n\nnamespace llvm {\nenum class stream_error_code {\n  unspecified,\n  stream_too_short,\n  invalid_array_size,\n  invalid_offset,\n  filesystem_error\n};\n\n/// Base class for errors originating when parsing raw PDB files\nclass BinaryStreamError : public ErrorInfo<BinaryStreamError> {\npublic:\n  static char ID;\n  explicit BinaryStreamError(stream_error_code C);\n  explicit BinaryStreamError(StringRef Context);\n  BinaryStreamError(stream_error_code C, StringRef Context);\n\n  void log(raw_ostream &OS) const override;\n  std::error_code convertToErrorCode() const override;\n\n  StringRef getErrorMessage() const;\n\n  stream_error_code getErrorCode() const { return Code; }\n\nprivate:\n  std::string ErrMsg;\n  stream_error_code Code;\n};\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_BINARYSTREAMERROR_H\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "content": "//===-- DataExtractor.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DATAEXTRACTOR_H\n#define LLVM_SUPPORT_DATAEXTRACTOR_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\n\n/// An auxiliary type to facilitate extraction of 3-byte entities.\nstruct Uint24 {\n  uint8_t Bytes[3];\n  Uint24(uint8_t U) {\n    Bytes[0] = Bytes[1] = Bytes[2] = U;\n  }\n  Uint24(uint8_t U0, uint8_t U1, uint8_t U2) {\n    Bytes[0] = U0; Bytes[1] = U1; Bytes[2] = U2;\n  }\n  uint32_t getAsUint32(bool IsLittleEndian) const {\n    int LoIx = IsLittleEndian ? 0 : 2;\n    return Bytes[LoIx] + (Bytes[1] << 8) + (Bytes[2-LoIx] << 16);\n  }\n};\n\nusing uint24_t = Uint24;\nstatic_assert(sizeof(uint24_t) == 3, \"sizeof(uint24_t) != 3\");\n\n/// Needed by swapByteOrder().\ninline uint24_t getSwappedBytes(uint24_t C) {\n  return uint24_t(C.Bytes[2], C.Bytes[1], C.Bytes[0]);\n}\n\nclass DataExtractor {\n  StringRef Data;\n  uint8_t IsLittleEndian;\n  uint8_t AddressSize;\npublic:\n  /// A class representing a position in a DataExtractor, as well as any error\n  /// encountered during extraction. It enables one to extract a sequence of\n  /// values without error-checking and then checking for errors in bulk at the\n  /// end. The class holds an Error object, so failing to check the result of\n  /// the parse will result in a runtime error. The error flag is sticky and\n  /// will cause all subsequent extraction functions to fail without even\n  /// attempting to parse and without updating the Cursor offset. After clearing\n  /// the error flag, one can again use the Cursor object for parsing.\n  class Cursor {\n    uint64_t Offset;\n    Error Err;\n\n    friend class DataExtractor;\n\n  public:\n    /// Construct a cursor for extraction from the given offset.\n    explicit Cursor(uint64_t Offset) : Offset(Offset), Err(Error::success()) {}\n\n    /// Checks whether the cursor is valid (i.e. no errors were encountered). In\n    /// case of errors, this does not clear the error flag -- one must call\n    /// takeError() instead.\n    explicit operator bool() { return !Err; }\n\n    /// Return the current position of this Cursor. In the error state this is\n    /// the position of the Cursor before the first error was encountered.\n    uint64_t tell() const { return Offset; }\n\n    /// Return error contained inside this Cursor, if any. Clears the internal\n    /// Cursor state.\n    Error takeError() { return std::move(Err); }\n  };\n\n  /// Construct with a buffer that is owned by the caller.\n  ///\n  /// This constructor allows us to use data that is owned by the\n  /// caller. The data must stay around as long as this object is\n  /// valid.\n  DataExtractor(StringRef Data, bool IsLittleEndian, uint8_t AddressSize)\n    : Data(Data), IsLittleEndian(IsLittleEndian), AddressSize(AddressSize) {}\n  DataExtractor(ArrayRef<uint8_t> Data, bool IsLittleEndian,\n                uint8_t AddressSize)\n      : Data(StringRef(reinterpret_cast<const char *>(Data.data()),\n                       Data.size())),\n        IsLittleEndian(IsLittleEndian), AddressSize(AddressSize) {}\n\n  /// Get the data pointed to by this extractor.\n  StringRef getData() const { return Data; }\n  /// Get the endianness for this extractor.\n  bool isLittleEndian() const { return IsLittleEndian; }\n  /// Get the address size for this extractor.\n  uint8_t getAddressSize() const { return AddressSize; }\n  /// Set the address size for this extractor.\n  void setAddressSize(uint8_t Size) { AddressSize = Size; }\n\n  /// Extract a C string from \\a *offset_ptr.\n  ///\n  /// Returns a pointer to a C String from the data at the offset\n  /// pointed to by \\a offset_ptr. A variable length NULL terminated C\n  /// string will be extracted and the \\a offset_ptr will be\n  /// updated with the offset of the byte that follows the NULL\n  /// terminator byte.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     A pointer to the C string value in the data. If the offset\n  ///     pointed to by \\a offset_ptr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     NULL will be returned.\n  const char *getCStr(uint64_t *OffsetPtr, Error *Err = nullptr) const {\n    return getCStrRef(OffsetPtr, Err).data();\n  }\n\n  /// Extract a C string from the location given by the cursor. In case of an\n  /// extraction error, or if the cursor is already in an error state, a\n  /// nullptr is returned.\n  const char *getCStr(Cursor &C) const { return getCStrRef(C).data(); }\n\n  /// Extract a C string from \\a *offset_ptr.\n  ///\n  /// Returns a StringRef for the C String from the data at the offset\n  /// pointed to by \\a offset_ptr. A variable length NULL terminated C\n  /// string will be extracted and the \\a offset_ptr will be\n  /// updated with the offset of the byte that follows the NULL\n  /// terminator byte.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// \\return\n  ///     A StringRef for the C string value in the data. If the offset\n  ///     pointed to by \\a offset_ptr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     a default-initialized StringRef will be returned.\n  StringRef getCStrRef(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract a C string (as a StringRef) from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, a default-initialized StringRef is returned.\n  StringRef getCStrRef(Cursor &C) const {\n    return getCStrRef(&C.Offset, &C.Err);\n  }\n\n  /// Extract a fixed length string from \\a *OffsetPtr and consume \\a Length\n  /// bytes.\n  ///\n  /// Returns a StringRef for the string from the data at the offset\n  /// pointed to by \\a OffsetPtr. A fixed length C string will be extracted\n  /// and the \\a OffsetPtr will be advanced by \\a Length bytes.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// \\param[in] Length\n  ///     The length of the fixed length string to extract. If there are not\n  ///     enough bytes in the data to extract the full string, the offset will\n  ///     be left unmodified.\n  ///\n  /// \\param[in] TrimChars\n  ///     A set of characters to trim from the end of the string. Fixed length\n  ///     strings are commonly either NULL terminated by one or more zero\n  ///     bytes. Some clients have one or more spaces at the end of the string,\n  ///     but a good default is to trim the NULL characters.\n  ///\n  /// \\return\n  ///     A StringRef for the C string value in the data. If the offset\n  ///     pointed to by \\a OffsetPtr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     a default-initialized StringRef will be returned.\n  StringRef getFixedLengthString(uint64_t *OffsetPtr,\n      uint64_t Length, StringRef TrimChars = {\"\\0\", 1}) const;\n\n  /// Extract a fixed number of bytes from the specified offset.\n  ///\n  /// Returns a StringRef for the bytes from the data at the offset\n  /// pointed to by \\a OffsetPtr. A fixed length C string will be extracted\n  /// and the \\a OffsetPtr will be advanced by \\a Length bytes.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// \\param[in] Length\n  ///     The number of bytes to extract. If there are not enough bytes in the\n  ///     data to extract all of the bytes, the offset will be left unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// \\return\n  ///     A StringRef for the extracted bytes. If the offset pointed to by\n  ///     \\a OffsetPtr is out of bounds, or if the offset plus the length\n  ///     is out of bounds, a default-initialized StringRef will be returned.\n  StringRef getBytes(uint64_t *OffsetPtr, uint64_t Length,\n                     Error *Err = nullptr) const;\n\n  /// Extract a fixed number of bytes from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, a default-initialized StringRef is returned.\n  StringRef getBytes(Cursor &C, uint64_t Length) {\n    return getBytes(&C.Offset, Length, &C.Err);\n  }\n\n  /// Extract an unsigned integer of size \\a byte_size from \\a\n  /// *offset_ptr.\n  ///\n  /// Extract a single unsigned integer value and update the offset\n  /// pointed to by \\a offset_ptr. The size of the extracted integer\n  /// is specified by the \\a byte_size argument. \\a byte_size should\n  /// have a value greater than or equal to one and less than or equal\n  /// to eight since the return value is 64 bits wide. Any\n  /// \\a byte_size values less than 1 or greater than 8 will result in\n  /// nothing being extracted, and zero being returned.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in] byte_size\n  ///     The size in byte of the integer to extract.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The unsigned integer value that was extracted, or zero on\n  ///     failure.\n  uint64_t getUnsigned(uint64_t *offset_ptr, uint32_t byte_size,\n                       Error *Err = nullptr) const;\n\n  /// Extract an unsigned integer of the given size from the location given by\n  /// the cursor. In case of an extraction error, or if the cursor is already in\n  /// an error state, zero is returned.\n  uint64_t getUnsigned(Cursor &C, uint32_t Size) const {\n    return getUnsigned(&C.Offset, Size, &C.Err);\n  }\n\n  /// Extract an signed integer of size \\a byte_size from \\a *offset_ptr.\n  ///\n  /// Extract a single signed integer value (sign extending if required)\n  /// and update the offset pointed to by \\a offset_ptr. The size of\n  /// the extracted integer is specified by the \\a byte_size argument.\n  /// \\a byte_size should have a value greater than or equal to one\n  /// and less than or equal to eight since the return value is 64\n  /// bits wide. Any \\a byte_size values less than 1 or greater than\n  /// 8 will result in nothing being extracted, and zero being returned.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in] size\n  ///     The size in bytes of the integer to extract.\n  ///\n  /// @return\n  ///     The sign extended signed integer value that was extracted,\n  ///     or zero on failure.\n  int64_t getSigned(uint64_t *offset_ptr, uint32_t size) const;\n\n  //------------------------------------------------------------------\n  /// Extract an pointer from \\a *offset_ptr.\n  ///\n  /// Extract a single pointer from the data and update the offset\n  /// pointed to by \\a offset_ptr. The size of the extracted pointer\n  /// is \\a getAddressSize(), so the address size has to be\n  /// set correctly prior to extracting any pointer values.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @return\n  ///     The extracted pointer value as a 64 integer.\n  uint64_t getAddress(uint64_t *offset_ptr) const {\n    return getUnsigned(offset_ptr, AddressSize);\n  }\n\n  /// Extract a pointer-sized unsigned integer from the location given by the\n  /// cursor. In case of an extraction error, or if the cursor is already in\n  /// an error state, zero is returned.\n  uint64_t getAddress(Cursor &C) const { return getUnsigned(C, AddressSize); }\n\n  /// Extract a uint8_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint8_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and advance the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint8_t value.\n  uint8_t getU8(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint8_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint8_t getU8(Cursor &C) const { return getU8(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint8_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint8_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint8_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint8_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint8_t *getU8(uint64_t *offset_ptr, uint8_t *dst, uint32_t count) const;\n\n  /// Extract \\a Count uint8_t values from the location given by the cursor and\n  /// store them into the destination buffer. In case of an extraction error, or\n  /// if the cursor is already in an error state, a nullptr is returned and the\n  /// destination buffer is left unchanged.\n  uint8_t *getU8(Cursor &C, uint8_t *Dst, uint32_t Count) const;\n\n  /// Extract \\a Count uint8_t values from the location given by the cursor and\n  /// store them into the destination vector. The vector is resized to fit the\n  /// extracted data. In case of an extraction error, or if the cursor is\n  /// already in an error state, the destination vector is left unchanged and\n  /// cursor is placed into an error state.\n  void getU8(Cursor &C, SmallVectorImpl<uint8_t> &Dst, uint32_t Count) const {\n    if (isValidOffsetForDataOfSize(C.Offset, Count))\n      Dst.resize(Count);\n\n    // This relies on the fact that getU8 will not attempt to write to the\n    // buffer if isValidOffsetForDataOfSize(C.Offset, Count) is false.\n    getU8(C, Dst.data(), Count);\n  }\n\n  //------------------------------------------------------------------\n  /// Extract a uint16_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint16_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint16_t value.\n  //------------------------------------------------------------------\n  uint16_t getU16(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint16_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint16_t getU16(Cursor &C) const { return getU16(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint16_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint16_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint16_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint16_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint16_t *getU16(uint64_t *offset_ptr, uint16_t *dst, uint32_t count) const;\n\n  /// Extract a 24-bit unsigned value from \\a *offset_ptr and return it\n  /// in a uint32_t.\n  ///\n  /// Extract 3 bytes from the binary data at the offset pointed to by\n  /// \\a offset_ptr, construct a uint32_t from them and update the offset\n  /// on success.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the 3 bytes if the value is extracted correctly. If the offset\n  ///     is out of bounds or there are not enough bytes to extract this value,\n  ///     the offset will be left unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted 24-bit value represented in a uint32_t.\n  uint32_t getU24(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract a single 24-bit unsigned value from the location given by the\n  /// cursor. In case of an extraction error, or if the cursor is already in an\n  /// error state, zero is returned.\n  uint32_t getU24(Cursor &C) const { return getU24(&C.Offset, &C.Err); }\n\n  /// Extract a uint32_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint32_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint32_t value.\n  uint32_t getU32(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint32_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint32_t getU32(Cursor &C) const { return getU32(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint32_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint32_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint32_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint32_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint32_t *getU32(uint64_t *offset_ptr, uint32_t *dst, uint32_t count) const;\n\n  /// Extract a uint64_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint64_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint64_t value.\n  uint64_t getU64(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint64_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint64_t getU64(Cursor &C) const { return getU64(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint64_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint64_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint64_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint64_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint64_t *getU64(uint64_t *offset_ptr, uint64_t *dst, uint32_t count) const;\n\n  /// Extract a signed LEB128 value from \\a *offset_ptr.\n  ///\n  /// Extracts an signed LEB128 number from this object's data\n  /// starting at the offset pointed to by \\a offset_ptr. The offset\n  /// pointed to by \\a offset_ptr will be updated with the offset of\n  /// the byte following the last extracted byte.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted signed integer value.\n  int64_t getSLEB128(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract an signed LEB128 value from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  int64_t getSLEB128(Cursor &C) const { return getSLEB128(&C.Offset, &C.Err); }\n\n  /// Extract a unsigned LEB128 value from \\a *offset_ptr.\n  ///\n  /// Extracts an unsigned LEB128 number from this object's data\n  /// starting at the offset pointed to by \\a offset_ptr. The offset\n  /// pointed to by \\a offset_ptr will be updated with the offset of\n  /// the byte following the last extracted byte.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted unsigned integer value.\n  uint64_t getULEB128(uint64_t *offset_ptr, llvm::Error *Err = nullptr) const;\n\n  /// Extract an unsigned LEB128 value from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint64_t getULEB128(Cursor &C) const { return getULEB128(&C.Offset, &C.Err); }\n\n  /// Advance the Cursor position by the given number of bytes. No-op if the\n  /// cursor is in an error state.\n  void skip(Cursor &C, uint64_t Length) const;\n\n  /// Return true iff the cursor is at the end of the buffer, regardless of the\n  /// error state of the cursor. The only way both eof and error states can be\n  /// true is if one attempts a read while the cursor is at the very end of the\n  /// data buffer.\n  bool eof(const Cursor &C) const { return size() == C.Offset; }\n\n  /// Test the validity of \\a offset.\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset into the data in this\n  ///     object, \\b false otherwise.\n  bool isValidOffset(uint64_t offset) const { return size() > offset; }\n\n  /// Test the availability of \\a length bytes of data from \\a offset.\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset and there are \\a\n  ///     length bytes available at that offset, \\b false otherwise.\n  bool isValidOffsetForDataOfSize(uint64_t offset, uint64_t length) const {\n    return offset + length >= offset && isValidOffset(offset + length - 1);\n  }\n\n  /// Test the availability of enough bytes of data for a pointer from\n  /// \\a offset. The size of a pointer is \\a getAddressSize().\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset and there are enough\n  ///     bytes for a pointer available at that offset, \\b false\n  ///     otherwise.\n  bool isValidOffsetForAddress(uint64_t offset) const {\n    return isValidOffsetForDataOfSize(offset, AddressSize);\n  }\n\n  /// Return the number of bytes in the underlying buffer.\n  size_t size() const { return Data.size(); }\n\nprotected:\n  // Make it possible for subclasses to access these fields without making them\n  // public.\n  static uint64_t &getOffset(Cursor &C) { return C.Offset; }\n  static Error &getError(Cursor &C) { return C.Err; }\n\nprivate:\n  /// If it is possible to read \\a Size bytes at offset \\a Offset, returns \\b\n  /// true. Otherwise, returns \\b false. If \\a E is not nullptr, also sets the\n  /// error object to indicate an error.\n  bool prepareRead(uint64_t Offset, uint64_t Size, Error *E) const;\n\n  template <typename T> T getU(uint64_t *OffsetPtr, Error *Err) const;\n  template <typename T>\n  T *getUs(uint64_t *OffsetPtr, T *Dst, uint32_t Count, Error *Err) const;\n};\n\n} // namespace llvm\n\n#endif\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ELFAttributes.h", "content": "//===-- ELFAttributes.h - ELF Attributes ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ELFATTRIBUTES_H\n#define LLVM_SUPPORT_ELFATTRIBUTES_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\nstruct TagNameItem {\n  unsigned attr;\n  StringRef tagName;\n};\n\nusing TagNameMap = ArrayRef<TagNameItem>;\n\nnamespace ELFAttrs {\n\nenum AttrType : unsigned { File = 1, Section = 2, Symbol = 3 };\n\nStringRef attrTypeAsString(unsigned attr, TagNameMap tagNameMap,\n                           bool hasTagPrefix = true);\nOptional<unsigned> attrTypeFromString(StringRef tag, TagNameMap tagNameMap);\n\n// Magic numbers for ELF attributes.\nenum AttrMagic { Format_Version = 0x41 };\n\n} // namespace ELFAttrs\n} // namespace llvm\n#endif\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "content": "//===- llvm/Support/Error.h - Recoverable error handling --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines an API used to report recoverable errors.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ERROR_H\n#define LLVM_SUPPORT_ERROR_H\n\n#include \"llvm-c/Error.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <memory>\n#include <new>\n#include <string>\n#include <system_error>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass ErrorSuccess;\n\n/// Base class for error info classes. Do not extend this directly: Extend\n/// the ErrorInfo template subclass instead.\nclass ErrorInfoBase {\npublic:\n  virtual ~ErrorInfoBase() = default;\n\n  /// Print an error message to an output stream.\n  virtual void log(raw_ostream &OS) const = 0;\n\n  /// Return the error message as a string.\n  virtual std::string message() const {\n    std::string Msg;\n    raw_string_ostream OS(Msg);\n    log(OS);\n    return OS.str();\n  }\n\n  /// Convert this error to a std::error_code.\n  ///\n  /// This is a temporary crutch to enable interaction with code still\n  /// using std::error_code. It will be removed in the future.\n  virtual std::error_code convertToErrorCode() const = 0;\n\n  // Returns the class ID for this type.\n  static const void *classID() { return &ID; }\n\n  // Returns the class ID for the dynamic type of this ErrorInfoBase instance.\n  virtual const void *dynamicClassID() const = 0;\n\n  // Check whether this instance is a subclass of the class identified by\n  // ClassID.\n  virtual bool isA(const void *const ClassID) const {\n    return ClassID == classID();\n  }\n\n  // Check whether this instance is a subclass of ErrorInfoT.\n  template <typename ErrorInfoT> bool isA() const {\n    return isA(ErrorInfoT::classID());\n  }\n\nprivate:\n  virtual void anchor();\n\n  static char ID;\n};\n\n/// Lightweight error class with error context and mandatory checking.\n///\n/// Instances of this class wrap a ErrorInfoBase pointer. Failure states\n/// are represented by setting the pointer to a ErrorInfoBase subclass\n/// instance containing information describing the failure. Success is\n/// represented by a null pointer value.\n///\n/// Instances of Error also contains a 'Checked' flag, which must be set\n/// before the destructor is called, otherwise the destructor will trigger a\n/// runtime error. This enforces at runtime the requirement that all Error\n/// instances be checked or returned to the caller.\n///\n/// There are two ways to set the checked flag, depending on what state the\n/// Error instance is in. For Error instances indicating success, it\n/// is sufficient to invoke the boolean conversion operator. E.g.:\n///\n///   @code{.cpp}\n///   Error foo(<...>);\n///\n///   if (auto E = foo(<...>))\n///     return E; // <- Return E if it is in the error state.\n///   // We have verified that E was in the success state. It can now be safely\n///   // destroyed.\n///   @endcode\n///\n/// A success value *can not* be dropped. For example, just calling 'foo(<...>)'\n/// without testing the return value will raise a runtime error, even if foo\n/// returns success.\n///\n/// For Error instances representing failure, you must use either the\n/// handleErrors or handleAllErrors function with a typed handler. E.g.:\n///\n///   @code{.cpp}\n///   class MyErrorInfo : public ErrorInfo<MyErrorInfo> {\n///     // Custom error info.\n///   };\n///\n///   Error foo(<...>) { return make_error<MyErrorInfo>(...); }\n///\n///   auto E = foo(<...>); // <- foo returns failure with MyErrorInfo.\n///   auto NewE =\n///     handleErrors(E,\n///       [](const MyErrorInfo &M) {\n///         // Deal with the error.\n///       },\n///       [](std::unique_ptr<OtherError> M) -> Error {\n///         if (canHandle(*M)) {\n///           // handle error.\n///           return Error::success();\n///         }\n///         // Couldn't handle this error instance. Pass it up the stack.\n///         return Error(std::move(M));\n///       );\n///   // Note - we must check or return NewE in case any of the handlers\n///   // returned a new error.\n///   @endcode\n///\n/// The handleAllErrors function is identical to handleErrors, except\n/// that it has a void return type, and requires all errors to be handled and\n/// no new errors be returned. It prevents errors (assuming they can all be\n/// handled) from having to be bubbled all the way to the top-level.\n///\n/// *All* Error instances must be checked before destruction, even if\n/// they're moved-assigned or constructed from Success values that have already\n/// been checked. This enforces checking through all levels of the call stack.\nclass LLVM_NODISCARD Error {\n  // ErrorList needs to be able to yank ErrorInfoBase pointers out of Errors\n  // to add to the error list. It can't rely on handleErrors for this, since\n  // handleErrors does not support ErrorList handlers.\n  friend class ErrorList;\n\n  // handleErrors needs to be able to set the Checked flag.\n  template <typename... HandlerTs>\n  friend Error handleErrors(Error E, HandlerTs &&... Handlers);\n\n  // Expected<T> needs to be able to steal the payload when constructed from an\n  // error.\n  template <typename T> friend class Expected;\n\n  // wrap needs to be able to steal the payload.\n  friend LLVMErrorRef wrap(Error);\n\nprotected:\n  /// Create a success value. Prefer using 'Error::success()' for readability\n  Error() {\n    setPtr(nullptr);\n    setChecked(false);\n  }\n\npublic:\n  /// Create a success value.\n  static ErrorSuccess success();\n\n  // Errors are not copy-constructable.\n  Error(const Error &Other) = delete;\n\n  /// Move-construct an error value. The newly constructed error is considered\n  /// unchecked, even if the source error had been checked. The original error\n  /// becomes a checked Success value, regardless of its original state.\n  Error(Error &&Other) {\n    setChecked(true);\n    *this = std::move(Other);\n  }\n\n  /// Create an error value. Prefer using the 'make_error' function, but\n  /// this constructor can be useful when \"re-throwing\" errors from handlers.\n  Error(std::unique_ptr<ErrorInfoBase> Payload) {\n    setPtr(Payload.release());\n    setChecked(false);\n  }\n\n  // Errors are not copy-assignable.\n  Error &operator=(const Error &Other) = delete;\n\n  /// Move-assign an error value. The current error must represent success, you\n  /// you cannot overwrite an unhandled error. The current error is then\n  /// considered unchecked. The source error becomes a checked success value,\n  /// regardless of its original state.\n  Error &operator=(Error &&Other) {\n    // Don't allow overwriting of unchecked values.\n    assertIsChecked();\n    setPtr(Other.getPtr());\n\n    // This Error is unchecked, even if the source error was checked.\n    setChecked(false);\n\n    // Null out Other's payload and set its checked bit.\n    Other.setPtr(nullptr);\n    Other.setChecked(true);\n\n    return *this;\n  }\n\n  /// Destroy a Error. Fails with a call to abort() if the error is\n  /// unchecked.\n  ~Error() {\n    assertIsChecked();\n    delete getPtr();\n  }\n\n  /// Bool conversion. Returns true if this Error is in a failure state,\n  /// and false if it is in an accept state. If the error is in a Success state\n  /// it will be considered checked.\n  explicit operator bool() {\n    setChecked(getPtr() == nullptr);\n    return getPtr() != nullptr;\n  }\n\n  /// Check whether one error is a subclass of another.\n  template <typename ErrT> bool isA() const {\n    return getPtr() && getPtr()->isA(ErrT::classID());\n  }\n\n  /// Returns the dynamic class id of this error, or null if this is a success\n  /// value.\n  const void* dynamicClassID() const {\n    if (!getPtr())\n      return nullptr;\n    return getPtr()->dynamicClassID();\n  }\n\nprivate:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  // assertIsChecked() happens very frequently, but under normal circumstances\n  // is supposed to be a no-op.  So we want it to be inlined, but having a bunch\n  // of debug prints can cause the function to be too large for inlining.  So\n  // it's important that we define this function out of line so that it can't be\n  // inlined.\n  LLVM_ATTRIBUTE_NORETURN\n  void fatalUncheckedError() const;\n#endif\n\n  void assertIsChecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    if (LLVM_UNLIKELY(!getChecked() || getPtr()))\n      fatalUncheckedError();\n#endif\n  }\n\n  ErrorInfoBase *getPtr() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return reinterpret_cast<ErrorInfoBase*>(\n             reinterpret_cast<uintptr_t>(Payload) &\n             ~static_cast<uintptr_t>(0x1));\n#else\n    return Payload;\n#endif\n  }\n\n  void setPtr(ErrorInfoBase *EI) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Payload = reinterpret_cast<ErrorInfoBase*>(\n                (reinterpret_cast<uintptr_t>(EI) &\n                 ~static_cast<uintptr_t>(0x1)) |\n                (reinterpret_cast<uintptr_t>(Payload) & 0x1));\n#else\n    Payload = EI;\n#endif\n  }\n\n  bool getChecked() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return (reinterpret_cast<uintptr_t>(Payload) & 0x1) == 0;\n#else\n    return true;\n#endif\n  }\n\n  void setChecked(bool V) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Payload = reinterpret_cast<ErrorInfoBase*>(\n                (reinterpret_cast<uintptr_t>(Payload) &\n                  ~static_cast<uintptr_t>(0x1)) |\n                  (V ? 0 : 1));\n#endif\n  }\n\n  std::unique_ptr<ErrorInfoBase> takePayload() {\n    std::unique_ptr<ErrorInfoBase> Tmp(getPtr());\n    setPtr(nullptr);\n    setChecked(true);\n    return Tmp;\n  }\n\n  friend raw_ostream &operator<<(raw_ostream &OS, const Error &E) {\n    if (auto P = E.getPtr())\n      P->log(OS);\n    else\n      OS << \"success\";\n    return OS;\n  }\n\n  ErrorInfoBase *Payload = nullptr;\n};\n\n/// Subclass of Error for the sole purpose of identifying the success path in\n/// the type system. This allows to catch invalid conversion to Expected<T> at\n/// compile time.\nclass ErrorSuccess final : public Error {};\n\ninline ErrorSuccess Error::success() { return ErrorSuccess(); }\n\n/// Make a Error instance representing failure using the given error info\n/// type.\ntemplate <typename ErrT, typename... ArgTs> Error make_error(ArgTs &&... Args) {\n  return Error(std::make_unique<ErrT>(std::forward<ArgTs>(Args)...));\n}\n\n/// Base class for user error types. Users should declare their error types\n/// like:\n///\n/// class MyError : public ErrorInfo<MyError> {\n///   ....\n/// };\n///\n/// This class provides an implementation of the ErrorInfoBase::kind\n/// method, which is used by the Error RTTI system.\ntemplate <typename ThisErrT, typename ParentErrT = ErrorInfoBase>\nclass ErrorInfo : public ParentErrT {\npublic:\n  using ParentErrT::ParentErrT; // inherit constructors\n\n  static const void *classID() { return &ThisErrT::ID; }\n\n  const void *dynamicClassID() const override { return &ThisErrT::ID; }\n\n  bool isA(const void *const ClassID) const override {\n    return ClassID == classID() || ParentErrT::isA(ClassID);\n  }\n};\n\n/// Special ErrorInfo subclass representing a list of ErrorInfos.\n/// Instances of this class are constructed by joinError.\nclass ErrorList final : public ErrorInfo<ErrorList> {\n  // handleErrors needs to be able to iterate the payload list of an\n  // ErrorList.\n  template <typename... HandlerTs>\n  friend Error handleErrors(Error E, HandlerTs &&... Handlers);\n\n  // joinErrors is implemented in terms of join.\n  friend Error joinErrors(Error, Error);\n\npublic:\n  void log(raw_ostream &OS) const override {\n    OS << \"Multiple errors:\\n\";\n    for (auto &ErrPayload : Payloads) {\n      ErrPayload->log(OS);\n      OS << \"\\n\";\n    }\n  }\n\n  std::error_code convertToErrorCode() const override;\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprivate:\n  ErrorList(std::unique_ptr<ErrorInfoBase> Payload1,\n            std::unique_ptr<ErrorInfoBase> Payload2) {\n    assert(!Payload1->isA<ErrorList>() && !Payload2->isA<ErrorList>() &&\n           \"ErrorList constructor payloads should be singleton errors\");\n    Payloads.push_back(std::move(Payload1));\n    Payloads.push_back(std::move(Payload2));\n  }\n\n  static Error join(Error E1, Error E2) {\n    if (!E1)\n      return E2;\n    if (!E2)\n      return E1;\n    if (E1.isA<ErrorList>()) {\n      auto &E1List = static_cast<ErrorList &>(*E1.getPtr());\n      if (E2.isA<ErrorList>()) {\n        auto E2Payload = E2.takePayload();\n        auto &E2List = static_cast<ErrorList &>(*E2Payload);\n        for (auto &Payload : E2List.Payloads)\n          E1List.Payloads.push_back(std::move(Payload));\n      } else\n        E1List.Payloads.push_back(E2.takePayload());\n\n      return E1;\n    }\n    if (E2.isA<ErrorList>()) {\n      auto &E2List = static_cast<ErrorList &>(*E2.getPtr());\n      E2List.Payloads.insert(E2List.Payloads.begin(), E1.takePayload());\n      return E2;\n    }\n    return Error(std::unique_ptr<ErrorList>(\n        new ErrorList(E1.takePayload(), E2.takePayload())));\n  }\n\n  std::vector<std::unique_ptr<ErrorInfoBase>> Payloads;\n};\n\n/// Concatenate errors. The resulting Error is unchecked, and contains the\n/// ErrorInfo(s), if any, contained in E1, followed by the\n/// ErrorInfo(s), if any, contained in E2.\ninline Error joinErrors(Error E1, Error E2) {\n  return ErrorList::join(std::move(E1), std::move(E2));\n}\n\n/// Tagged union holding either a T or a Error.\n///\n/// This class parallels ErrorOr, but replaces error_code with Error. Since\n/// Error cannot be copied, this class replaces getError() with\n/// takeError(). It also adds an bool errorIsA<ErrT>() method for testing the\n/// error class type.\ntemplate <class T> class LLVM_NODISCARD Expected {\n  template <class T1> friend class ExpectedAsOutParameter;\n  template <class OtherT> friend class Expected;\n\n  static constexpr bool isRef = std::is_reference<T>::value;\n\n  using wrap = std::reference_wrapper<std::remove_reference_t<T>>;\n\n  using error_type = std::unique_ptr<ErrorInfoBase>;\n\npublic:\n  using storage_type = std::conditional_t<isRef, wrap, T>;\n  using value_type = T;\n\nprivate:\n  using reference = std::remove_reference_t<T> &;\n  using const_reference = const std::remove_reference_t<T> &;\n  using pointer = std::remove_reference_t<T> *;\n  using const_pointer = const std::remove_reference_t<T> *;\n\npublic:\n  /// Create an Expected<T> error value from the given Error.\n  Expected(Error Err)\n      : HasError(true)\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n        // Expected is unchecked upon construction in Debug builds.\n        , Unchecked(true)\n#endif\n  {\n    assert(Err && \"Cannot create Expected<T> from Error success value.\");\n    new (getErrorStorage()) error_type(Err.takePayload());\n  }\n\n  /// Forbid to convert from Error::success() implicitly, this avoids having\n  /// Expected<T> foo() { return Error::success(); } which compiles otherwise\n  /// but triggers the assertion above.\n  Expected(ErrorSuccess) = delete;\n\n  /// Create an Expected<T> success value from the given OtherT value, which\n  /// must be convertible to T.\n  template <typename OtherT>\n  Expected(OtherT &&Val,\n           std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr)\n      : HasError(false)\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n        // Expected is unchecked upon construction in Debug builds.\n        ,\n        Unchecked(true)\n#endif\n  {\n    new (getStorage()) storage_type(std::forward<OtherT>(Val));\n  }\n\n  /// Move construct an Expected<T> value.\n  Expected(Expected &&Other) { moveConstruct(std::move(Other)); }\n\n  /// Move construct an Expected<T> value from an Expected<OtherT>, where OtherT\n  /// must be convertible to T.\n  template <class OtherT>\n  Expected(\n      Expected<OtherT> &&Other,\n      std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  /// Move construct an Expected<T> value from an Expected<OtherT>, where OtherT\n  /// isn't convertible to T.\n  template <class OtherT>\n  explicit Expected(\n      Expected<OtherT> &&Other,\n      std::enable_if_t<!std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  /// Move-assign from another Expected<T>.\n  Expected &operator=(Expected &&Other) {\n    moveAssign(std::move(Other));\n    return *this;\n  }\n\n  /// Destroy an Expected<T>.\n  ~Expected() {\n    assertIsChecked();\n    if (!HasError)\n      getStorage()->~storage_type();\n    else\n      getErrorStorage()->~error_type();\n  }\n\n  /// Return false if there is an error.\n  explicit operator bool() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = HasError;\n#endif\n    return !HasError;\n  }\n\n  /// Returns a reference to the stored T value.\n  reference get() {\n    assertIsChecked();\n    return *getStorage();\n  }\n\n  /// Returns a const reference to the stored T value.\n  const_reference get() const {\n    assertIsChecked();\n    return const_cast<Expected<T> *>(this)->get();\n  }\n\n  /// Check that this Expected<T> is an error of type ErrT.\n  template <typename ErrT> bool errorIsA() const {\n    return HasError && (*getErrorStorage())->template isA<ErrT>();\n  }\n\n  /// Take ownership of the stored error.\n  /// After calling this the Expected<T> is in an indeterminate state that can\n  /// only be safely destructed. No further calls (beside the destructor) should\n  /// be made on the Expected<T> value.\n  Error takeError() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = false;\n#endif\n    return HasError ? Error(std::move(*getErrorStorage())) : Error::success();\n  }\n\n  /// Returns a pointer to the stored T value.\n  pointer operator->() {\n    assertIsChecked();\n    return toPointer(getStorage());\n  }\n\n  /// Returns a const pointer to the stored T value.\n  const_pointer operator->() const {\n    assertIsChecked();\n    return toPointer(getStorage());\n  }\n\n  /// Returns a reference to the stored T value.\n  reference operator*() {\n    assertIsChecked();\n    return *getStorage();\n  }\n\n  /// Returns a const reference to the stored T value.\n  const_reference operator*() const {\n    assertIsChecked();\n    return *getStorage();\n  }\n\nprivate:\n  template <class T1>\n  static bool compareThisIfSameType(const T1 &a, const T1 &b) {\n    return &a == &b;\n  }\n\n  template <class T1, class T2>\n  static bool compareThisIfSameType(const T1 &a, const T2 &b) {\n    return false;\n  }\n\n  template <class OtherT> void moveConstruct(Expected<OtherT> &&Other) {\n    HasError = Other.HasError;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = true;\n    Other.Unchecked = false;\n#endif\n\n    if (!HasError)\n      new (getStorage()) storage_type(std::move(*Other.getStorage()));\n    else\n      new (getErrorStorage()) error_type(std::move(*Other.getErrorStorage()));\n  }\n\n  template <class OtherT> void moveAssign(Expected<OtherT> &&Other) {\n    assertIsChecked();\n\n    if (compareThisIfSameType(*this, Other))\n      return;\n\n    this->~Expected();\n    new (this) Expected(std::move(Other));\n  }\n\n  pointer toPointer(pointer Val) { return Val; }\n\n  const_pointer toPointer(const_pointer Val) const { return Val; }\n\n  pointer toPointer(wrap *Val) { return &Val->get(); }\n\n  const_pointer toPointer(const wrap *Val) const { return &Val->get(); }\n\n  storage_type *getStorage() {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<storage_type *>(&TStorage);\n  }\n\n  const storage_type *getStorage() const {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<const storage_type *>(&TStorage);\n  }\n\n  error_type *getErrorStorage() {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<error_type *>(&ErrorStorage);\n  }\n\n  const error_type *getErrorStorage() const {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<const error_type *>(&ErrorStorage);\n  }\n\n  // Used by ExpectedAsOutParameter to reset the checked flag.\n  void setUnchecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    Unchecked = true;\n#endif\n  }\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  LLVM_ATTRIBUTE_NORETURN\n  LLVM_ATTRIBUTE_NOINLINE\n  void fatalUncheckedExpected() const {\n    dbgs() << \"Expected<T> must be checked before access or destruction.\\n\";\n    if (HasError) {\n      dbgs() << \"Unchecked Expected<T> contained error:\\n\";\n      (*getErrorStorage())->log(dbgs());\n    } else\n      dbgs() << \"Expected<T> value was in success state. (Note: Expected<T> \"\n                \"values in success mode must still be checked prior to being \"\n                \"destroyed).\\n\";\n    abort();\n  }\n#endif\n\n  void assertIsChecked() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    if (LLVM_UNLIKELY(Unchecked))\n      fatalUncheckedExpected();\n#endif\n  }\n\n  union {\n    AlignedCharArrayUnion<storage_type> TStorage;\n    AlignedCharArrayUnion<error_type> ErrorStorage;\n  };\n  bool HasError : 1;\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool Unchecked : 1;\n#endif\n};\n\n/// Report a serious error, calling any installed error handler. See\n/// ErrorHandling.h.\nLLVM_ATTRIBUTE_NORETURN void report_fatal_error(Error Err,\n                                                bool gen_crash_diag = true);\n\n/// Report a fatal error if Err is a failure value.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns\n///   // Error::success().\n///   Error foo(bool DoFallibleOperation);\n///\n///   cantFail(foo(false));\n///   @endcode\ninline void cantFail(Error Err, const char *Msg = nullptr) {\n  if (Err) {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    OS << Msg << \"\\n\" << Err;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and\n/// returns the contained value.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns an int.\n///   Expected<int> foo(bool DoFallibleOperation);\n///\n///   int X = cantFail(foo(false));\n///   @endcode\ntemplate <typename T>\nT cantFail(Expected<T> ValOrErr, const char *Msg = nullptr) {\n  if (ValOrErr)\n    return std::move(*ValOrErr);\n  else {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    auto E = ValOrErr.takeError();\n    OS << Msg << \"\\n\" << E;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Report a fatal error if ValOrErr is a failure value, otherwise unwraps and\n/// returns the contained reference.\n///\n/// This function can be used to wrap calls to fallible functions ONLY when it\n/// is known that the Error will always be a success value. E.g.\n///\n///   @code{.cpp}\n///   // foo only attempts the fallible operation if DoFallibleOperation is\n///   // true. If DoFallibleOperation is false then foo always returns a Bar&.\n///   Expected<Bar&> foo(bool DoFallibleOperation);\n///\n///   Bar &X = cantFail(foo(false));\n///   @endcode\ntemplate <typename T>\nT& cantFail(Expected<T&> ValOrErr, const char *Msg = nullptr) {\n  if (ValOrErr)\n    return *ValOrErr;\n  else {\n    if (!Msg)\n      Msg = \"Failure value returned from cantFail wrapped call\";\n#ifndef NDEBUG\n    std::string Str;\n    raw_string_ostream OS(Str);\n    auto E = ValOrErr.takeError();\n    OS << Msg << \"\\n\" << E;\n    Msg = OS.str().c_str();\n#endif\n    llvm_unreachable(Msg);\n  }\n}\n\n/// Helper for testing applicability of, and applying, handlers for\n/// ErrorInfo types.\ntemplate <typename HandlerT>\nclass ErrorHandlerTraits\n    : public ErrorHandlerTraits<decltype(\n          &std::remove_reference<HandlerT>::type::operator())> {};\n\n// Specialization functions of the form 'Error (const ErrT&)'.\ntemplate <typename ErrT> class ErrorHandlerTraits<Error (&)(ErrT &)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    return H(static_cast<ErrT &>(*E));\n  }\n};\n\n// Specialization functions of the form 'void (const ErrT&)'.\ntemplate <typename ErrT> class ErrorHandlerTraits<void (&)(ErrT &)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    H(static_cast<ErrT &>(*E));\n    return Error::success();\n  }\n};\n\n/// Specialization for functions of the form 'Error (std::unique_ptr<ErrT>)'.\ntemplate <typename ErrT>\nclass ErrorHandlerTraits<Error (&)(std::unique_ptr<ErrT>)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    std::unique_ptr<ErrT> SubE(static_cast<ErrT *>(E.release()));\n    return H(std::move(SubE));\n  }\n};\n\n/// Specialization for functions of the form 'void (std::unique_ptr<ErrT>)'.\ntemplate <typename ErrT>\nclass ErrorHandlerTraits<void (&)(std::unique_ptr<ErrT>)> {\npublic:\n  static bool appliesTo(const ErrorInfoBase &E) {\n    return E.template isA<ErrT>();\n  }\n\n  template <typename HandlerT>\n  static Error apply(HandlerT &&H, std::unique_ptr<ErrorInfoBase> E) {\n    assert(appliesTo(*E) && \"Applying incorrect handler\");\n    std::unique_ptr<ErrT> SubE(static_cast<ErrT *>(E.release()));\n    H(std::move(SubE));\n    return Error::success();\n  }\n};\n\n// Specialization for member functions of the form 'RetT (const ErrT&)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(ErrT &)>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(ErrT &) const>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(const ErrT &)>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n// Specialization for member functions of the form 'RetT (const ErrT&) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(const ErrT &) const>\n    : public ErrorHandlerTraits<RetT (&)(ErrT &)> {};\n\n/// Specialization for member functions of the form\n/// 'RetT (std::unique_ptr<ErrT>)'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(std::unique_ptr<ErrT>)>\n    : public ErrorHandlerTraits<RetT (&)(std::unique_ptr<ErrT>)> {};\n\n/// Specialization for member functions of the form\n/// 'RetT (std::unique_ptr<ErrT>) const'.\ntemplate <typename C, typename RetT, typename ErrT>\nclass ErrorHandlerTraits<RetT (C::*)(std::unique_ptr<ErrT>) const>\n    : public ErrorHandlerTraits<RetT (&)(std::unique_ptr<ErrT>)> {};\n\ninline Error handleErrorImpl(std::unique_ptr<ErrorInfoBase> Payload) {\n  return Error(std::move(Payload));\n}\n\ntemplate <typename HandlerT, typename... HandlerTs>\nError handleErrorImpl(std::unique_ptr<ErrorInfoBase> Payload,\n                      HandlerT &&Handler, HandlerTs &&... Handlers) {\n  if (ErrorHandlerTraits<HandlerT>::appliesTo(*Payload))\n    return ErrorHandlerTraits<HandlerT>::apply(std::forward<HandlerT>(Handler),\n                                               std::move(Payload));\n  return handleErrorImpl(std::move(Payload),\n                         std::forward<HandlerTs>(Handlers)...);\n}\n\n/// Pass the ErrorInfo(s) contained in E to their respective handlers. Any\n/// unhandled errors (or Errors returned by handlers) are re-concatenated and\n/// returned.\n/// Because this function returns an error, its result must also be checked\n/// or returned. If you intend to handle all errors use handleAllErrors\n/// (which returns void, and will abort() on unhandled errors) instead.\ntemplate <typename... HandlerTs>\nError handleErrors(Error E, HandlerTs &&... Hs) {\n  if (!E)\n    return Error::success();\n\n  std::unique_ptr<ErrorInfoBase> Payload = E.takePayload();\n\n  if (Payload->isA<ErrorList>()) {\n    ErrorList &List = static_cast<ErrorList &>(*Payload);\n    Error R;\n    for (auto &P : List.Payloads)\n      R = ErrorList::join(\n          std::move(R),\n          handleErrorImpl(std::move(P), std::forward<HandlerTs>(Hs)...));\n    return R;\n  }\n\n  return handleErrorImpl(std::move(Payload), std::forward<HandlerTs>(Hs)...);\n}\n\n/// Behaves the same as handleErrors, except that by contract all errors\n/// *must* be handled by the given handlers (i.e. there must be no remaining\n/// errors after running the handlers, or llvm_unreachable is called).\ntemplate <typename... HandlerTs>\nvoid handleAllErrors(Error E, HandlerTs &&... Handlers) {\n  cantFail(handleErrors(std::move(E), std::forward<HandlerTs>(Handlers)...));\n}\n\n/// Check that E is a non-error, then drop it.\n/// If E is an error, llvm_unreachable will be called.\ninline void handleAllErrors(Error E) {\n  cantFail(std::move(E));\n}\n\n/// Handle any errors (if present) in an Expected<T>, then try a recovery path.\n///\n/// If the incoming value is a success value it is returned unmodified. If it\n/// is a failure value then it the contained error is passed to handleErrors.\n/// If handleErrors is able to handle the error then the RecoveryPath functor\n/// is called to supply the final result. If handleErrors is not able to\n/// handle all errors then the unhandled errors are returned.\n///\n/// This utility enables the follow pattern:\n///\n///   @code{.cpp}\n///   enum FooStrategy { Aggressive, Conservative };\n///   Expected<Foo> foo(FooStrategy S);\n///\n///   auto ResultOrErr =\n///     handleExpected(\n///       foo(Aggressive),\n///       []() { return foo(Conservative); },\n///       [](AggressiveStrategyError&) {\n///         // Implicitly conusme this - we'll recover by using a conservative\n///         // strategy.\n///       });\n///\n///   @endcode\ntemplate <typename T, typename RecoveryFtor, typename... HandlerTs>\nExpected<T> handleExpected(Expected<T> ValOrErr, RecoveryFtor &&RecoveryPath,\n                           HandlerTs &&... Handlers) {\n  if (ValOrErr)\n    return ValOrErr;\n\n  if (auto Err = handleErrors(ValOrErr.takeError(),\n                              std::forward<HandlerTs>(Handlers)...))\n    return std::move(Err);\n\n  return RecoveryPath();\n}\n\n/// Log all errors (if any) in E to OS. If there are any errors, ErrorBanner\n/// will be printed before the first one is logged. A newline will be printed\n/// after each error.\n///\n/// This function is compatible with the helpers from Support/WithColor.h. You\n/// can pass any of them as the OS. Please consider using them instead of\n/// including 'error: ' in the ErrorBanner.\n///\n/// This is useful in the base level of your program to allow clean termination\n/// (allowing clean deallocation of resources, etc.), while reporting error\n/// information to the user.\nvoid logAllUnhandledErrors(Error E, raw_ostream &OS, Twine ErrorBanner = {});\n\n/// Write all error messages (if any) in E to a string. The newline character\n/// is used to separate error messages.\ninline std::string toString(Error E) {\n  SmallVector<std::string, 2> Errors;\n  handleAllErrors(std::move(E), [&Errors](const ErrorInfoBase &EI) {\n    Errors.push_back(EI.message());\n  });\n  return join(Errors.begin(), Errors.end(), \"\\n\");\n}\n\n/// Consume a Error without doing anything. This method should be used\n/// only where an error can be considered a reasonable and expected return\n/// value.\n///\n/// Uses of this method are potentially indicative of design problems: If it's\n/// legitimate to do nothing while processing an \"error\", the error-producer\n/// might be more clearly refactored to return an Optional<T>.\ninline void consumeError(Error Err) {\n  handleAllErrors(std::move(Err), [](const ErrorInfoBase &) {});\n}\n\n/// Convert an Expected to an Optional without doing anything. This method\n/// should be used only where an error can be considered a reasonable and\n/// expected return value.\n///\n/// Uses of this method are potentially indicative of problems: perhaps the\n/// error should be propagated further, or the error-producer should just\n/// return an Optional in the first place.\ntemplate <typename T> Optional<T> expectedToOptional(Expected<T> &&E) {\n  if (E)\n    return std::move(*E);\n  consumeError(E.takeError());\n  return None;\n}\n\n/// Helper for converting an Error to a bool.\n///\n/// This method returns true if Err is in an error state, or false if it is\n/// in a success state.  Puts Err in a checked state in both cases (unlike\n/// Error::operator bool(), which only does this for success states).\ninline bool errorToBool(Error Err) {\n  bool IsError = static_cast<bool>(Err);\n  if (IsError)\n    consumeError(std::move(Err));\n  return IsError;\n}\n\n/// Helper for Errors used as out-parameters.\n///\n/// This helper is for use with the Error-as-out-parameter idiom, where an error\n/// is passed to a function or method by reference, rather than being returned.\n/// In such cases it is helpful to set the checked bit on entry to the function\n/// so that the error can be written to (unchecked Errors abort on assignment)\n/// and clear the checked bit on exit so that clients cannot accidentally forget\n/// to check the result. This helper performs these actions automatically using\n/// RAII:\n///\n///   @code{.cpp}\n///   Result foo(Error &Err) {\n///     ErrorAsOutParameter ErrAsOutParam(&Err); // 'Checked' flag set\n///     // <body of foo>\n///     // <- 'Checked' flag auto-cleared when ErrAsOutParam is destructed.\n///   }\n///   @endcode\n///\n/// ErrorAsOutParameter takes an Error* rather than Error& so that it can be\n/// used with optional Errors (Error pointers that are allowed to be null). If\n/// ErrorAsOutParameter took an Error reference, an instance would have to be\n/// created inside every condition that verified that Error was non-null. By\n/// taking an Error pointer we can just create one instance at the top of the\n/// function.\nclass ErrorAsOutParameter {\npublic:\n  ErrorAsOutParameter(Error *Err) : Err(Err) {\n    // Raise the checked bit if Err is success.\n    if (Err)\n      (void)!!*Err;\n  }\n\n  ~ErrorAsOutParameter() {\n    // Clear the checked bit.\n    if (Err && !*Err)\n      *Err = Error::success();\n  }\n\nprivate:\n  Error *Err;\n};\n\n/// Helper for Expected<T>s used as out-parameters.\n///\n/// See ErrorAsOutParameter.\ntemplate <typename T>\nclass ExpectedAsOutParameter {\npublic:\n  ExpectedAsOutParameter(Expected<T> *ValOrErr)\n    : ValOrErr(ValOrErr) {\n    if (ValOrErr)\n      (void)!!*ValOrErr;\n  }\n\n  ~ExpectedAsOutParameter() {\n    if (ValOrErr)\n      ValOrErr->setUnchecked();\n  }\n\nprivate:\n  Expected<T> *ValOrErr;\n};\n\n/// This class wraps a std::error_code in a Error.\n///\n/// This is useful if you're writing an interface that returns a Error\n/// (or Expected) and you want to call code that still returns\n/// std::error_codes.\nclass ECError : public ErrorInfo<ECError> {\n  friend Error errorCodeToError(std::error_code);\n\n  virtual void anchor() override;\n\npublic:\n  void setErrorCode(std::error_code EC) { this->EC = EC; }\n  std::error_code convertToErrorCode() const override { return EC; }\n  void log(raw_ostream &OS) const override { OS << EC.message(); }\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprotected:\n  ECError() = default;\n  ECError(std::error_code EC) : EC(EC) {}\n\n  std::error_code EC;\n};\n\n/// The value returned by this function can be returned from convertToErrorCode\n/// for Error values where no sensible translation to std::error_code exists.\n/// It should only be used in this situation, and should never be used where a\n/// sensible conversion to std::error_code is available, as attempts to convert\n/// to/from this error will result in a fatal error. (i.e. it is a programmatic\n///error to try to convert such a value).\nstd::error_code inconvertibleErrorCode();\n\n/// Helper for converting an std::error_code to a Error.\nError errorCodeToError(std::error_code EC);\n\n/// Helper for converting an ECError to a std::error_code.\n///\n/// This method requires that Err be Error() or an ECError, otherwise it\n/// will trigger a call to abort().\nstd::error_code errorToErrorCode(Error Err);\n\n/// Convert an ErrorOr<T> to an Expected<T>.\ntemplate <typename T> Expected<T> errorOrToExpected(ErrorOr<T> &&EO) {\n  if (auto EC = EO.getError())\n    return errorCodeToError(EC);\n  return std::move(*EO);\n}\n\n/// Convert an Expected<T> to an ErrorOr<T>.\ntemplate <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> &&E) {\n  if (auto Err = E.takeError())\n    return errorToErrorCode(std::move(Err));\n  return std::move(*E);\n}\n\n/// This class wraps a string in an Error.\n///\n/// StringError is useful in cases where the client is not expected to be able\n/// to consume the specific error message programmatically (for example, if the\n/// error message is to be presented to the user).\n///\n/// StringError can also be used when additional information is to be printed\n/// along with a error_code message. Depending on the constructor called, this\n/// class can either display:\n///    1. the error_code message (ECError behavior)\n///    2. a string\n///    3. the error_code message and a string\n///\n/// These behaviors are useful when subtyping is required; for example, when a\n/// specific library needs an explicit error type. In the example below,\n/// PDBError is derived from StringError:\n///\n///   @code{.cpp}\n///   Expected<int> foo() {\n///      return llvm::make_error<PDBError>(pdb_error_code::dia_failed_loading,\n///                                        \"Additional information\");\n///   }\n///   @endcode\n///\nclass StringError : public ErrorInfo<StringError> {\npublic:\n  static char ID;\n\n  // Prints EC + S and converts to EC\n  StringError(std::error_code EC, const Twine &S = Twine());\n\n  // Prints S and converts to EC\n  StringError(const Twine &S, std::error_code EC);\n\n  void log(raw_ostream &OS) const override;\n  std::error_code convertToErrorCode() const override;\n\n  const std::string &getMessage() const { return Msg; }\n\nprivate:\n  std::string Msg;\n  std::error_code EC;\n  const bool PrintMsgOnly = false;\n};\n\n/// Create formatted StringError object.\ntemplate <typename... Ts>\ninline Error createStringError(std::error_code EC, char const *Fmt,\n                               const Ts &... Vals) {\n  std::string Buffer;\n  raw_string_ostream Stream(Buffer);\n  Stream << format(Fmt, Vals...);\n  return make_error<StringError>(Stream.str(), EC);\n}\n\nError createStringError(std::error_code EC, char const *Msg);\n\ninline Error createStringError(std::error_code EC, const Twine &S) {\n  return createStringError(EC, S.str().c_str());\n}\n\ntemplate <typename... Ts>\ninline Error createStringError(std::errc EC, char const *Fmt,\n                               const Ts &... Vals) {\n  return createStringError(std::make_error_code(EC), Fmt, Vals...);\n}\n\n/// This class wraps a filename and another Error.\n///\n/// In some cases, an error needs to live along a 'source' name, in order to\n/// show more detailed information to the user.\nclass FileError final : public ErrorInfo<FileError> {\n\n  friend Error createFileError(const Twine &, Error);\n  friend Error createFileError(const Twine &, size_t, Error);\n\npublic:\n  void log(raw_ostream &OS) const override {\n    assert(Err && !FileName.empty() && \"Trying to log after takeError().\");\n    OS << \"'\" << FileName << \"': \";\n    if (Line.hasValue())\n      OS << \"line \" << Line.getValue() << \": \";\n    Err->log(OS);\n  }\n\n  StringRef getFileName() { return FileName; }\n\n  Error takeError() { return Error(std::move(Err)); }\n\n  std::error_code convertToErrorCode() const override;\n\n  // Used by ErrorInfo::classID.\n  static char ID;\n\nprivate:\n  FileError(const Twine &F, Optional<size_t> LineNum,\n            std::unique_ptr<ErrorInfoBase> E) {\n    assert(E && \"Cannot create FileError from Error success value.\");\n    assert(!F.isTriviallyEmpty() &&\n           \"The file name provided to FileError must not be empty.\");\n    FileName = F.str();\n    Err = std::move(E);\n    Line = std::move(LineNum);\n  }\n\n  static Error build(const Twine &F, Optional<size_t> Line, Error E) {\n    std::unique_ptr<ErrorInfoBase> Payload;\n    handleAllErrors(std::move(E),\n                    [&](std::unique_ptr<ErrorInfoBase> EIB) -> Error {\n                      Payload = std::move(EIB);\n                      return Error::success();\n                    });\n    return Error(\n        std::unique_ptr<FileError>(new FileError(F, Line, std::move(Payload))));\n  }\n\n  std::string FileName;\n  Optional<size_t> Line;\n  std::unique_ptr<ErrorInfoBase> Err;\n};\n\n/// Concatenate a source file path and/or name with an Error. The resulting\n/// Error is unchecked.\ninline Error createFileError(const Twine &F, Error E) {\n  return FileError::build(F, Optional<size_t>(), std::move(E));\n}\n\n/// Concatenate a source file path and/or name with line number and an Error.\n/// The resulting Error is unchecked.\ninline Error createFileError(const Twine &F, size_t Line, Error E) {\n  return FileError::build(F, Optional<size_t>(Line), std::move(E));\n}\n\n/// Concatenate a source file path and/or name with a std::error_code \n/// to form an Error object.\ninline Error createFileError(const Twine &F, std::error_code EC) {\n  return createFileError(F, errorCodeToError(EC));\n}\n\n/// Concatenate a source file path and/or name with line number and\n/// std::error_code to form an Error object.\ninline Error createFileError(const Twine &F, size_t Line, std::error_code EC) {\n  return createFileError(F, Line, errorCodeToError(EC));\n}\n\nError createFileError(const Twine &F, ErrorSuccess) = delete;\n\n/// Helper for check-and-exit error handling.\n///\n/// For tool use only. NOT FOR USE IN LIBRARY CODE.\n///\nclass ExitOnError {\npublic:\n  /// Create an error on exit helper.\n  ExitOnError(std::string Banner = \"\", int DefaultErrorExitCode = 1)\n      : Banner(std::move(Banner)),\n        GetExitCode([=](const Error &) { return DefaultErrorExitCode; }) {}\n\n  /// Set the banner string for any errors caught by operator().\n  void setBanner(std::string Banner) { this->Banner = std::move(Banner); }\n\n  /// Set the exit-code mapper function.\n  void setExitCodeMapper(std::function<int(const Error &)> GetExitCode) {\n    this->GetExitCode = std::move(GetExitCode);\n  }\n\n  /// Check Err. If it's in a failure state log the error(s) and exit.\n  void operator()(Error Err) const { checkError(std::move(Err)); }\n\n  /// Check E. If it's in a success state then return the contained value. If\n  /// it's in a failure state log the error(s) and exit.\n  template <typename T> T operator()(Expected<T> &&E) const {\n    checkError(E.takeError());\n    return std::move(*E);\n  }\n\n  /// Check E. If it's in a success state then return the contained reference. If\n  /// it's in a failure state log the error(s) and exit.\n  template <typename T> T& operator()(Expected<T&> &&E) const {\n    checkError(E.takeError());\n    return *E;\n  }\n\nprivate:\n  void checkError(Error Err) const {\n    if (Err) {\n      int ExitCode = GetExitCode(Err);\n      logAllUnhandledErrors(std::move(Err), errs(), Banner);\n      exit(ExitCode);\n    }\n  }\n\n  std::string Banner;\n  std::function<int(const Error &)> GetExitCode;\n};\n\n/// Conversion from Error to LLVMErrorRef for C error bindings.\ninline LLVMErrorRef wrap(Error Err) {\n  return reinterpret_cast<LLVMErrorRef>(Err.takePayload().release());\n}\n\n/// Conversion from LLVMErrorRef to Error for C error bindings.\ninline Error unwrap(LLVMErrorRef ErrRef) {\n  return Error(std::unique_ptr<ErrorInfoBase>(\n      reinterpret_cast<ErrorInfoBase *>(ErrRef)));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ERROR_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "content": "//===- Format.h - Efficient printf-style formatting for streams -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the format() function, which can be used with other\n// LLVM subsystems to provide printf-style formatting.  This gives all the power\n// and risk of printf.  This can be used like this (with raw_ostreams as an\n// example):\n//\n//    OS << \"mynumber: \" << format(\"%4.5f\", 1234.412) << '\\n';\n//\n// Or if you prefer:\n//\n//  OS << format(\"mynumber: %4.5f\\n\", 1234.412);\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FORMAT_H\n#define LLVM_SUPPORT_FORMAT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <cstdio>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// This is a helper class used for handling formatted output.  It is the\n/// abstract base class of a templated derived class.\nclass format_object_base {\nprotected:\n  const char *Fmt;\n  ~format_object_base() = default; // Disallow polymorphic deletion.\n  format_object_base(const format_object_base &) = default;\n  virtual void home(); // Out of line virtual method.\n\n  /// Call snprintf() for this object, on the given buffer and size.\n  virtual int snprint(char *Buffer, unsigned BufferSize) const = 0;\n\npublic:\n  format_object_base(const char *fmt) : Fmt(fmt) {}\n\n  /// Format the object into the specified buffer.  On success, this returns\n  /// the length of the formatted string.  If the buffer is too small, this\n  /// returns a length to retry with, which will be larger than BufferSize.\n  unsigned print(char *Buffer, unsigned BufferSize) const {\n    assert(BufferSize && \"Invalid buffer size!\");\n\n    // Print the string, leaving room for the terminating null.\n    int N = snprint(Buffer, BufferSize);\n\n    // VC++ and old GlibC return negative on overflow, just double the size.\n    if (N < 0)\n      return BufferSize * 2;\n\n    // Other implementations yield number of bytes needed, not including the\n    // final '\\0'.\n    if (unsigned(N) >= BufferSize)\n      return N + 1;\n\n    // Otherwise N is the length of output (not including the final '\\0').\n    return N;\n  }\n};\n\n/// These are templated helper classes used by the format function that\n/// capture the object to be formatted and the format string. When actually\n/// printed, this synthesizes the string into a temporary buffer provided and\n/// returns whether or not it is big enough.\n\n// Helper to validate that format() parameters are scalars or pointers.\ntemplate <typename... Args> struct validate_format_parameters;\ntemplate <typename Arg, typename... Args>\nstruct validate_format_parameters<Arg, Args...> {\n  static_assert(std::is_scalar<Arg>::value,\n                \"format can't be used with non fundamental / non pointer type\");\n  validate_format_parameters() { validate_format_parameters<Args...>(); }\n};\ntemplate <> struct validate_format_parameters<> {};\n\ntemplate <typename... Ts>\nclass format_object final : public format_object_base {\n  std::tuple<Ts...> Vals;\n\n  template <std::size_t... Is>\n  int snprint_tuple(char *Buffer, unsigned BufferSize,\n                    std::index_sequence<Is...>) const {\n#ifdef _MSC_VER\n    return _snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#else\n    return snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#endif\n  }\n\npublic:\n  format_object(const char *fmt, const Ts &... vals)\n      : format_object_base(fmt), Vals(vals...) {\n    validate_format_parameters<Ts...>();\n  }\n\n  int snprint(char *Buffer, unsigned BufferSize) const override {\n    return snprint_tuple(Buffer, BufferSize, std::index_sequence_for<Ts...>());\n  }\n};\n\n/// These are helper functions used to produce formatted output.  They use\n/// template type deduction to construct the appropriate instance of the\n/// format_object class to simplify their construction.\n///\n/// This is typically used like:\n/// \\code\n///   OS << format(\"%0.4f\", myfloat) << '\\n';\n/// \\endcode\n\ntemplate <typename... Ts>\ninline format_object<Ts...> format(const char *Fmt, const Ts &... Vals) {\n  return format_object<Ts...>(Fmt, Vals...);\n}\n\n/// This is a helper class for left_justify, right_justify, and center_justify.\nclass FormattedString {\npublic:\n  enum Justification { JustifyNone, JustifyLeft, JustifyRight, JustifyCenter };\n  FormattedString(StringRef S, unsigned W, Justification J)\n      : Str(S), Width(W), Justify(J) {}\n\nprivate:\n  StringRef Str;\n  unsigned Width;\n  Justification Justify;\n  friend class raw_ostream;\n};\n\n/// left_justify - append spaces after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString left_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyLeft);\n}\n\n/// right_justify - add spaces before string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString right_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyRight);\n}\n\n/// center_justify - add spaces before and after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString center_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyCenter);\n}\n\n/// This is a helper class used for format_hex() and format_decimal().\nclass FormattedNumber {\n  uint64_t HexValue;\n  int64_t DecValue;\n  unsigned Width;\n  bool Hex;\n  bool Upper;\n  bool HexPrefix;\n  friend class raw_ostream;\n\npublic:\n  FormattedNumber(uint64_t HV, int64_t DV, unsigned W, bool H, bool U,\n                  bool Prefix)\n      : HexValue(HV), DecValue(DV), Width(W), Hex(H), Upper(U),\n        HexPrefix(Prefix) {}\n};\n\n/// format_hex - Output \\p N as a fixed width hexadecimal. If number will not\n/// fit in width, full number is still printed.  Examples:\n///   OS << format_hex(255, 4)              => 0xff\n///   OS << format_hex(255, 4, true)        => 0xFF\n///   OS << format_hex(255, 6)              => 0x00ff\n///   OS << format_hex(255, 2)              => 0xff\ninline FormattedNumber format_hex(uint64_t N, unsigned Width,\n                                  bool Upper = false) {\n  assert(Width <= 18 && \"hex width must be <= 18\");\n  return FormattedNumber(N, 0, Width, true, Upper, true);\n}\n\n/// format_hex_no_prefix - Output \\p N as a fixed width hexadecimal. Does not\n/// prepend '0x' to the outputted string.  If number will not fit in width,\n/// full number is still printed.  Examples:\n///   OS << format_hex_no_prefix(255, 2)              => ff\n///   OS << format_hex_no_prefix(255, 2, true)        => FF\n///   OS << format_hex_no_prefix(255, 4)              => 00ff\n///   OS << format_hex_no_prefix(255, 1)              => ff\ninline FormattedNumber format_hex_no_prefix(uint64_t N, unsigned Width,\n                                            bool Upper = false) {\n  assert(Width <= 16 && \"hex width must be <= 16\");\n  return FormattedNumber(N, 0, Width, true, Upper, false);\n}\n\n/// format_decimal - Output \\p N as a right justified, fixed-width decimal. If\n/// number will not fit in width, full number is still printed.  Examples:\n///   OS << format_decimal(0, 5)     => \"    0\"\n///   OS << format_decimal(255, 5)   => \"  255\"\n///   OS << format_decimal(-1, 3)    => \" -1\"\n///   OS << format_decimal(12345, 3) => \"12345\"\ninline FormattedNumber format_decimal(int64_t N, unsigned Width) {\n  return FormattedNumber(0, N, Width, false, false, false);\n}\n\nclass FormattedBytes {\n  ArrayRef<uint8_t> Bytes;\n\n  // If not None, display offsets for each line relative to starting value.\n  Optional<uint64_t> FirstByteOffset;\n  uint32_t IndentLevel;  // Number of characters to indent each line.\n  uint32_t NumPerLine;   // Number of bytes to show per line.\n  uint8_t ByteGroupSize; // How many hex bytes are grouped without spaces\n  bool Upper;            // Show offset and hex bytes as upper case.\n  bool ASCII;            // Show the ASCII bytes for the hex bytes to the right.\n  friend class raw_ostream;\n\npublic:\n  FormattedBytes(ArrayRef<uint8_t> B, uint32_t IL, Optional<uint64_t> O,\n                 uint32_t NPL, uint8_t BGS, bool U, bool A)\n      : Bytes(B), FirstByteOffset(O), IndentLevel(IL), NumPerLine(NPL),\n        ByteGroupSize(BGS), Upper(U), ASCII(A) {\n\n    if (ByteGroupSize > NumPerLine)\n      ByteGroupSize = NumPerLine;\n  }\n};\n\ninline FormattedBytes\nformat_bytes(ArrayRef<uint8_t> Bytes, Optional<uint64_t> FirstByteOffset = None,\n             uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n             uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, false);\n}\n\ninline FormattedBytes\nformat_bytes_with_ascii(ArrayRef<uint8_t> Bytes,\n                        Optional<uint64_t> FirstByteOffset = None,\n                        uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n                        uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, true);\n}\n\n} // end namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 3, "line": 737}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 737}, "message": "'DenseMap<KeyT, ValueT, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "94705506050e22b07bfbe27f688344eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 3, "line": 916}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 3, "line": 916}, "message": "'SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "9b74a81affd74cd1b669f9723987a268", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 4, "line": 85}, "message": "'HandleBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/EpochTracker.h", "reportHash": "4a7159350c3b9ad01a790d14445e9052", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 45}, "message": "'PointerIntPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerIntPair.h", "reportHash": "28feed63b2768109b760ece1e7a1d38f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 477}, "message": "'ListSeparator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringExtras.h", "reportHash": "98120b76083834be8f6e9b43e029a482", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 45}, "message": "'Triple' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Triple.h", "reportHash": "f0060c07e16b8d117929f0dd7b34cff8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 16, "line": 39}, "message": "'ilist_node_impl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "4de5fdfac33f54918b6f1247b74efd5a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 148}, "message": "'ilist_node' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "9cbb8cd94f8bfaa6fa946264e51d0761", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 256}, "message": "'ilist_node_with_parent' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node.h", "reportHash": "6520a49bd5005d5d14aebc62afc29dfb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 17, "line": 21}, "message": "'ilist_node_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_node_base.h", "reportHash": "b131ef802de9d7c6102d86935157e9c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 67}, "message": "'iterator_facade_base' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "f094ccf98e815c80f35eb01bb1e57eae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 39}, "message": "'WasmDylinkInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "66d19c31dba91976e95831f00eafff5f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 47}, "message": "'WasmProducerInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "8cfd23f6fa2e743ef925162bde323057", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 53}, "message": "'WasmFeatureEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "d2c83b2e3b4a6dc516cfa97ca39b4fb6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 81}, "message": "'WasmInitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "53ff3f306d6012a5a5897a132dd8fce3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 83}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "5777c6e56927fd9ee05f395a725adf50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 134}, "message": "'WasmFunction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "fbff990bcfb5f99fdb13d93e6fd434bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 161}, "message": "'WasmElemSegment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "22048a1b47965779729feecd8f02c7c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 171}, "message": "'WasmDataReference' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "d11d3da28f6b88afa0bacdbbc5747350", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 189}, "message": "'WasmSymbolInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "aa0d7e9874d1fd26acf6c2796d988698", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 199}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "5777c6e56927fd9ee05f395a725adf50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 220}, "message": "'WasmLinkingData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "1455ba3f8bb3cbb85f6bc0bcfa9cb42a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 397}, "message": "'WasmSignature' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "c876078b508bf39b4c7956dc0b9c328e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 88}, "message": "'DIInliningInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "d1b7c75c1127ee8d622778ea661f1cd7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 118}, "message": "'DIGlobal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "279af97683c790ab3bb44710058791f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 126}, "message": "'DILocal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h", "reportHash": "4ee7785b386d8c36f696b446a68e8c64", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 27}, "message": "'DWARFAbbreviationDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAbbreviationDeclaration.h", "reportHash": "c955f2dad1bedcc3dad0b69948ee88bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 24}, "message": "'DWARFAttribute' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAttribute.h", "reportHash": "e973edd7ce349add80169ce7107c4f04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 22}, "message": "'DWARFAbbreviationDeclarationSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h", "reportHash": "79bb5b3ae35cfeb00584ca7f3381a6cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 54}, "message": "'DWARFDebugAbbrev' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugAbbrev.h", "reportHash": "dc7b573cc25d03d7b706d67f9e84185b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 24, "line": 27}, "message": "'DWARFLocationEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "d89f18cd59de56d82d862207ef698152", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 85}, "message": "'DWARFDebugLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "11c6a332c1bfedcd6febe5c234a9352a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 24, "line": 88}, "message": "'LocationList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "157d1aae5231f7bbbbbc9838ad0c5d8d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 122}, "message": "'DWARFDebugLoclists' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLoc.h", "reportHash": "1504dee95640136912afa318ef1f473e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 22}, "message": "'DWARFDebugRangeList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRangeList.h", "reportHash": "5ce7436a0bcdf86b27e162849122250c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 26, "line": 45}, "message": "'DWARFDebugRnglist' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugRnglists.h", "reportHash": "3842a28addb4d886eecacd1148034164", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 27, "line": 300}, "message": "'attribute_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDie.h", "reportHash": "7cc9ab999cec6239878e6994de7b2b10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 28, "line": 38}, "message": "'DWARFListType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "20994fdc58ddf64f76fd446db4e99675", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 56}, "message": "'DWARFListTableHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "d321639c1e8d221188ba13dc775b7ed6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 28, "line": 57}, "message": "'Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "d66018b521e761d3cfa39e35c18ab1af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 28, "line": 146}, "message": "'DWARFListTableBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFListTable.h", "reportHash": "8b2f30e44e99c9b83d3c2fd20946299c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 22}, "message": "'DWARFLocationExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFLocationExpression.h", "reportHash": "9331a9032aa0b13d0bfbeef5f2aa9bb8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 20}, "message": "'RelocAddrEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFRelocMap.h", "reportHash": "74d3107719d71652fa7639fcc906b0db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 47}, "message": "'DWARFUnitHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "1370022cec8df7a8bf23b0ccaf218879", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 120}, "message": "'DWARFUnitVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnit.h", "reportHash": "d896fc74805f80ed72992191f3e0ed6d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 80}, "message": "'DWARFUnitIndex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h", "reportHash": "84bef52b4f37a21cab97cafe8a89ca74", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 32, "line": 81}, "message": "'Header' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h", "reportHash": "442d51e431a03b14a022ce93bb0b4d38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 32, "line": 92}, "message": "'Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFUnitIndex.h", "reportHash": "3f638ab36ae4542f9bb4517c01053ae0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 144}, "message": "'MCConstantExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "reportHash": "0d5c6c0747204b1885e93f86621c7331", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 192}, "message": "'MCSymbolRefExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "reportHash": "6d2a32b822f18ae2629a3e2336251dd2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 421}, "message": "'MCUnaryExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "reportHash": "2c5fea277b7591459f89b170886e57ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 477}, "message": "'MCBinaryExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCExpr.h", "reportHash": "fbef1f2127807b621bd0822aa8a5a136", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 115}, "message": "'MCDummyFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "9a98d8ff8bee8072b4af20305123ee70", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 125}, "message": "'MCEncodedFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "dcc7d11b8efd82d70572a1a14f667431", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 187}, "message": "'MCEncodedFragmentWithContents' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "47e58383a2a6d2391f58b4b0e328d037", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 205}, "message": "'MCEncodedFragmentWithFixups' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "ff060dd0a66b49841053796ba69a7a6a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 242}, "message": "'MCDataFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "306ad84496688c0b38850aa817c43e4d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 257}, "message": "'MCCompactEncodedInstFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "7808ab500d4a6d2c37f62d5332124199", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 271}, "message": "'MCRelaxableFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "d36ac05cc056f9085e617976a808c372", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 295}, "message": "'MCAlignFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "8a06fe5bbd8866722e8a678e890875fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 336}, "message": "'MCFillFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "88238ddcfa55c89f8972f8a975a93bd0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 363}, "message": "'MCNopsFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "a0d8d1428f19dab09aa98733b9050dc0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 388}, "message": "'MCOrgFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "80ea81bb01ff958d70d0c28c5ad2cd7d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 415}, "message": "'MCLEBFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "aafc4178bf9ef53cccd2b267215075bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 444}, "message": "'MCDwarfLineAddrFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "f3fd3b7843d03a58a9b564acf3942ba3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 468}, "message": "'MCDwarfCallFrameFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "324525517c987a4b1628008a4c8b196b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 486}, "message": "'MCSymbolIdFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "6ca5305f4ea8563cf915926844038016", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 503}, "message": "'MCCVInlineLineTableFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "18521140a84b61980f559a0d2b93e961", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 536}, "message": "'MCCVDefRangeFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "654e1f35a083f698db0b7bf8f63eab52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 566}, "message": "'MCBoundaryAlignFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "6061c7ce7aad9bb1e723cb408f12e416", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 597}, "message": "'MCPseudoProbeAddrFragment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCFragment.h", "reportHash": "a15f7c13e6a0f69fc0e6a24d67452891", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 194}, "message": "'MCInst' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCInst.h", "reportHash": "1e9e135343ed05c02b4ff358058c2b99", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 16}, "message": "'MCSymbolWasm' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSymbolWasm.h", "reportHash": "0d38a6ff9c78b243e084f32f586da351", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 37, "line": 193}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 37, "line": 193}, "message": "'OwningBinary<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "7f33d0bf3efae8461d731ba2e8f8d12a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 37, "line": 210}, "message": "mark 'noexcept'"}, {"location": {"col": 18, "file": 37, "line": 210}, "message": "'OwningBinary<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Binary.h", "reportHash": "f937946cd5423d6503383dd7c36871d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 776}, "message": "'COFFObjectFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/COFF.h", "reportHash": "21bb683662ba6d64ec9224a93bb3bc54", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 1216}, "message": "'ResourceSectionRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/COFF.h", "reportHash": "2ade9267b6545bf6dda7c2d268cc249f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 38}, "message": "'VerDef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "8f36ba2b0f333ff21812b0828acbffff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 49}, "message": "'VernAux' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "dcc22f26236dd8b847ee0ec72007d226", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 57}, "message": "'VerNeed' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELF.h", "reportHash": "abfbe4740f301c9c9ebef4c2ad5119ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 49}, "message": "'ELFObjectFileBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "2e82f2797e69401e58b0afa607ca9b31", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 40, "line": 395}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 40, "line": 395}, "message": "'ELFObjectFile<ELFT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "734d59b6257db8d322fcabd89b608ee1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 40, "line": 1077}, "message": "mark 'noexcept'"}, {"location": {"col": 22, "file": 40, "line": 1077}, "message": "'ELFObjectFile<ELFT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h", "reportHash": "97552d929884b3a601b165667246bba7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 53}, "message": "'BinaryError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Error.h", "reportHash": "975ef9d622f935e4b455b61a1fdd2864", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 67}, "message": "'GenericBinaryError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Error.h", "reportHash": "96b17a7f306de8239e796fde2e19c21d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 43}, "message": "'DiceRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "6e2c269e98f2d4101421b520edb64d53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 72}, "message": "'ExportEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "dc93a53852a2208a67e4211b6daa75af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 131}, "message": "'BindRebaseSegInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "0615f0ca6e34b5f71b850492ff47df48", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 262}, "message": "'MachOObjectFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/MachO.h", "reportHash": "437df89195bf8b4f74351a0c3d91e19c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 35}, "message": "'WasmSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Wasm.h", "reportHash": "12e322883243cf9748de08ce07deeb86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 43, "line": 106}, "message": "'WasmSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Wasm.h", "reportHash": "4bf464b642e0f015eafc553bf507f0d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 122}, "message": "'WasmObjectFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Object/Wasm.h", "reportHash": "0b257abd9dca8de8856dd6c6ca782931", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 23}, "message": "'ARMAttributeParser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ARMAttributeParser.h", "reportHash": "c70cc4a858169b6959fe479b9630d4b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 31}, "message": "'BinaryByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "245c88995a21931c95e999510ca6702b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 75}, "message": "'MemoryBufferByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "94f05340d37e29f8e3661fb56acfdfb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 89}, "message": "'MutableBinaryByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "3da1be79ed0e4e0a0d53a116b1325a81", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 135}, "message": "'AppendingBinaryByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "588835619820303c6054c321baf91661", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 205}, "message": "'FileBufferByteStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "7743e20f1e6bcd4e52a4800d355745f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 47, "line": 207}, "message": "'StreamImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h", "reportHash": "51feb395032dd0dc3a0fec77864666e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 27}, "message": "'BinaryStreamError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamError.h", "reportHash": "63710d4513b59e2d29088fda411de3ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 49, "line": 54}, "message": "'Cursor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "623c02410a17a1d2aff51d1845476615", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 17}, "message": "'TagNameItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ELFAttributes.h", "reportHash": "adbceaf3a571291edb526b09b9988f80", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 52, "line": 1104}, "message": "'ECError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Error.h", "reportHash": "96820ce717ccc85786898684b4d1a3ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 90}, "message": "'format_object' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "36f6711cac3da0d2fdfbfbcc86668815", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
