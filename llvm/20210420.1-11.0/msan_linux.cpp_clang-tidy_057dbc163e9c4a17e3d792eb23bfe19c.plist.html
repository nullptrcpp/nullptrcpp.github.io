<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan.h", "content": "//===-- msan.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of MemorySanitizer.\n//\n// Private MSan header.\n//===----------------------------------------------------------------------===//\n\n#ifndef MSAN_H\n#define MSAN_H\n\n#include \"sanitizer_common/sanitizer_flags.h\"\n#include \"sanitizer_common/sanitizer_internal_defs.h\"\n#include \"sanitizer_common/sanitizer_stacktrace.h\"\n#include \"msan_interface_internal.h\"\n#include \"msan_flags.h\"\n#include \"ubsan/ubsan_platform.h\"\n\n#ifndef MSAN_REPLACE_OPERATORS_NEW_AND_DELETE\n# define MSAN_REPLACE_OPERATORS_NEW_AND_DELETE 1\n#endif\n\n#ifndef MSAN_CONTAINS_UBSAN\n# define MSAN_CONTAINS_UBSAN CAN_SANITIZE_UB\n#endif\n\nstruct MappingDesc {\n  uptr start;\n  uptr end;\n  enum Type {\n    INVALID, APP, SHADOW, ORIGIN\n  } type;\n  const char *name;\n};\n\n\n#if SANITIZER_LINUX && defined(__mips64)\n\n// MIPS64 maps:\n// - 0x0000000000-0x0200000000: Program own segments\n// - 0xa200000000-0xc000000000: PIE program segments\n// - 0xe200000000-0xffffffffff: libraries segments.\nconst MappingDesc kMemoryLayout[] = {\n    {0x000000000000ULL, 0x000200000000ULL, MappingDesc::APP, \"app-1\"},\n    {0x000200000000ULL, 0x002200000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x002200000000ULL, 0x004000000000ULL, MappingDesc::SHADOW, \"shadow-2\"},\n    {0x004000000000ULL, 0x004200000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x004200000000ULL, 0x006000000000ULL, MappingDesc::ORIGIN, \"origin-2\"},\n    {0x006000000000ULL, 0x006200000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x006200000000ULL, 0x008000000000ULL, MappingDesc::SHADOW, \"shadow-3\"},\n    {0x008000000000ULL, 0x008200000000ULL, MappingDesc::SHADOW, \"shadow-1\"},\n    {0x008200000000ULL, 0x00a000000000ULL, MappingDesc::ORIGIN, \"origin-3\"},\n    {0x00a000000000ULL, 0x00a200000000ULL, MappingDesc::ORIGIN, \"origin-1\"},\n    {0x00a200000000ULL, 0x00c000000000ULL, MappingDesc::APP, \"app-2\"},\n    {0x00c000000000ULL, 0x00e200000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x00e200000000ULL, 0x00ffffffffffULL, MappingDesc::APP, \"app-3\"}};\n\n#define MEM_TO_SHADOW(mem) (((uptr)(mem)) ^ 0x8000000000ULL)\n#define SHADOW_TO_ORIGIN(shadow) (((uptr)(shadow)) + 0x2000000000ULL)\n\n#elif SANITIZER_LINUX && defined(__aarch64__)\n\n// The mapping describes both 39-bits, 42-bits, and 48-bits VMA.  AArch64\n// maps:\n// - 0x0000000000000-0x0000010000000: 39/42/48-bits program own segments\n// - 0x0005500000000-0x0005600000000: 39-bits PIE program segments\n// - 0x0007f80000000-0x0007fffffffff: 39-bits libraries segments\n// - 0x002aa00000000-0x002ab00000000: 42-bits PIE program segments\n// - 0x003ff00000000-0x003ffffffffff: 42-bits libraries segments\n// - 0x0aaaaa0000000-0x0aaab00000000: 48-bits PIE program segments\n// - 0xffff000000000-0x1000000000000: 48-bits libraries segments\n// It is fragmented in multiples segments to increase the memory available\n// on 42-bits (12.21% of total VMA available for 42-bits and 13.28 for\n// 39 bits). The 48-bits segments only cover the usual PIE/default segments\n// plus some more segments (262144GB total, 0.39% total VMA).\nconst MappingDesc kMemoryLayout[] = {\n    {0x00000000000ULL, 0x01000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x01000000000ULL, 0x02000000000ULL, MappingDesc::SHADOW, \"shadow-2\"},\n    {0x02000000000ULL, 0x03000000000ULL, MappingDesc::ORIGIN, \"origin-2\"},\n    {0x03000000000ULL, 0x04000000000ULL, MappingDesc::SHADOW, \"shadow-1\"},\n    {0x04000000000ULL, 0x05000000000ULL, MappingDesc::ORIGIN, \"origin-1\"},\n    {0x05000000000ULL, 0x06000000000ULL, MappingDesc::APP, \"app-1\"},\n    {0x06000000000ULL, 0x07000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x07000000000ULL, 0x08000000000ULL, MappingDesc::APP, \"app-2\"},\n    {0x08000000000ULL, 0x09000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    // The mappings below are used only for 42-bits VMA.\n    {0x09000000000ULL, 0x0A000000000ULL, MappingDesc::SHADOW, \"shadow-3\"},\n    {0x0A000000000ULL, 0x0B000000000ULL, MappingDesc::ORIGIN, \"origin-3\"},\n    {0x0B000000000ULL, 0x0F000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0F000000000ULL, 0x10000000000ULL, MappingDesc::APP, \"app-3\"},\n    {0x10000000000ULL, 0x11000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x11000000000ULL, 0x12000000000ULL, MappingDesc::APP, \"app-4\"},\n    {0x12000000000ULL, 0x17000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x17000000000ULL, 0x18000000000ULL, MappingDesc::SHADOW, \"shadow-4\"},\n    {0x18000000000ULL, 0x19000000000ULL, MappingDesc::ORIGIN, \"origin-4\"},\n    {0x19000000000ULL, 0x20000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x20000000000ULL, 0x21000000000ULL, MappingDesc::APP, \"app-5\"},\n    {0x21000000000ULL, 0x26000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x26000000000ULL, 0x27000000000ULL, MappingDesc::SHADOW, \"shadow-5\"},\n    {0x27000000000ULL, 0x28000000000ULL, MappingDesc::ORIGIN, \"origin-5\"},\n    {0x28000000000ULL, 0x29000000000ULL, MappingDesc::SHADOW, \"shadow-7\"},\n    {0x29000000000ULL, 0x2A000000000ULL, MappingDesc::ORIGIN, \"origin-7\"},\n    {0x2A000000000ULL, 0x2B000000000ULL, MappingDesc::APP, \"app-6\"},\n    {0x2B000000000ULL, 0x2C000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x2C000000000ULL, 0x2D000000000ULL, MappingDesc::SHADOW, \"shadow-6\"},\n    {0x2D000000000ULL, 0x2E000000000ULL, MappingDesc::ORIGIN, \"origin-6\"},\n    {0x2E000000000ULL, 0x2F000000000ULL, MappingDesc::APP, \"app-7\"},\n    {0x2F000000000ULL, 0x39000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x39000000000ULL, 0x3A000000000ULL, MappingDesc::SHADOW, \"shadow-9\"},\n    {0x3A000000000ULL, 0x3B000000000ULL, MappingDesc::ORIGIN, \"origin-9\"},\n    {0x3B000000000ULL, 0x3C000000000ULL, MappingDesc::APP, \"app-8\"},\n    {0x3C000000000ULL, 0x3D000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x3D000000000ULL, 0x3E000000000ULL, MappingDesc::SHADOW, \"shadow-8\"},\n    {0x3E000000000ULL, 0x3F000000000ULL, MappingDesc::ORIGIN, \"origin-8\"},\n    {0x3F000000000ULL, 0x40000000000ULL, MappingDesc::APP, \"app-9\"},\n    // The mappings below are used only for 48-bits VMA.\n    // TODO(unknown): 48-bit mapping ony covers the usual PIE, non-PIE\n    // segments and some more segments totalizing 262144GB of VMA (which cover\n    // only 0.32% of all 48-bit VMA). Memory avaliability can be increase by\n    // adding multiple application segments like 39 and 42 mapping.\n    {0x0040000000000ULL, 0x0041000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0041000000000ULL, 0x0042000000000ULL, MappingDesc::APP, \"app-10\"},\n    {0x0042000000000ULL, 0x0047000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0047000000000ULL, 0x0048000000000ULL, MappingDesc::SHADOW, \"shadow-10\"},\n    {0x0048000000000ULL, 0x0049000000000ULL, MappingDesc::ORIGIN, \"origin-10\"},\n    {0x0049000000000ULL, 0x0050000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0050000000000ULL, 0x0051000000000ULL, MappingDesc::APP, \"app-11\"},\n    {0x0051000000000ULL, 0x0056000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0056000000000ULL, 0x0057000000000ULL, MappingDesc::SHADOW, \"shadow-11\"},\n    {0x0057000000000ULL, 0x0058000000000ULL, MappingDesc::ORIGIN, \"origin-11\"},\n    {0x0058000000000ULL, 0x0059000000000ULL, MappingDesc::APP, \"app-12\"},\n    {0x0059000000000ULL, 0x005E000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x005E000000000ULL, 0x005F000000000ULL, MappingDesc::SHADOW, \"shadow-12\"},\n    {0x005F000000000ULL, 0x0060000000000ULL, MappingDesc::ORIGIN, \"origin-12\"},\n    {0x0060000000000ULL, 0x0061000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0061000000000ULL, 0x0062000000000ULL, MappingDesc::APP, \"app-13\"},\n    {0x0062000000000ULL, 0x0067000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0067000000000ULL, 0x0068000000000ULL, MappingDesc::SHADOW, \"shadow-13\"},\n    {0x0068000000000ULL, 0x0069000000000ULL, MappingDesc::ORIGIN, \"origin-13\"},\n    {0x0069000000000ULL, 0x0AAAAA0000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0AAAAA0000000ULL, 0x0AAAB00000000ULL, MappingDesc::APP, \"app-14\"},\n    {0x0AAAB00000000ULL, 0x0AACAA0000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0AACAA0000000ULL, 0x0AACB00000000ULL, MappingDesc::SHADOW, \"shadow-14\"},\n    {0x0AACB00000000ULL, 0x0AADAA0000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0AADAA0000000ULL, 0x0AADB00000000ULL, MappingDesc::ORIGIN, \"origin-14\"},\n    {0x0AADB00000000ULL, 0x0FF9F00000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0FF9F00000000ULL, 0x0FFA000000000ULL, MappingDesc::SHADOW, \"shadow-15\"},\n    {0x0FFA000000000ULL, 0x0FFAF00000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0FFAF00000000ULL, 0x0FFB000000000ULL, MappingDesc::ORIGIN, \"origin-15\"},\n    {0x0FFB000000000ULL, 0x0FFFF00000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x0FFFF00000000ULL, 0x1000000000000ULL, MappingDesc::APP, \"app-15\"},\n};\n# define MEM_TO_SHADOW(mem) ((uptr)mem ^ 0x6000000000ULL)\n# define SHADOW_TO_ORIGIN(shadow) (((uptr)(shadow)) + 0x1000000000ULL)\n\n#elif SANITIZER_LINUX && SANITIZER_PPC64\nconst MappingDesc kMemoryLayout[] = {\n    {0x000000000000ULL, 0x000200000000ULL, MappingDesc::APP, \"low memory\"},\n    {0x000200000000ULL, 0x080000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x080000000000ULL, 0x180200000000ULL, MappingDesc::SHADOW, \"shadow\"},\n    {0x180200000000ULL, 0x1C0000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x1C0000000000ULL, 0x2C0200000000ULL, MappingDesc::ORIGIN, \"origin\"},\n    {0x2C0200000000ULL, 0x300000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x300000000000ULL, 0x800000000000ULL, MappingDesc::APP, \"high memory\"}};\n\n// Various kernels use different low end ranges but we can combine them into one\n// big range. They also use different high end ranges but we can map them all to\n// one range.\n// Maps low and high app ranges to contiguous space with zero base:\n//   Low:  0000 0000 0000 - 0001 ffff ffff  ->  1000 0000 0000 - 1001 ffff ffff\n//   High: 3000 0000 0000 - 3fff ffff ffff  ->  0000 0000 0000 - 0fff ffff ffff\n//   High: 4000 0000 0000 - 4fff ffff ffff  ->  0000 0000 0000 - 0fff ffff ffff\n//   High: 7000 0000 0000 - 7fff ffff ffff  ->  0000 0000 0000 - 0fff ffff ffff\n#define LINEARIZE_MEM(mem) \\\n  (((uptr)(mem) & ~0xE00000000000ULL) ^ 0x100000000000ULL)\n#define MEM_TO_SHADOW(mem) (LINEARIZE_MEM((mem)) + 0x080000000000ULL)\n#define SHADOW_TO_ORIGIN(shadow) (((uptr)(shadow)) + 0x140000000000ULL)\n\n#elif SANITIZER_LINUX && SANITIZER_S390_64\nconst MappingDesc kMemoryLayout[] = {\n    {0x000000000000ULL, 0x040000000000ULL, MappingDesc::APP, \"low memory\"},\n    {0x040000000000ULL, 0x080000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x080000000000ULL, 0x180000000000ULL, MappingDesc::SHADOW, \"shadow\"},\n    {0x180000000000ULL, 0x1C0000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x1C0000000000ULL, 0x2C0000000000ULL, MappingDesc::ORIGIN, \"origin\"},\n    {0x2C0000000000ULL, 0x440000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x440000000000ULL, 0x500000000000ULL, MappingDesc::APP, \"high memory\"}};\n\n#define MEM_TO_SHADOW(mem) \\\n  ((((uptr)(mem)) & ~0xC00000000000ULL) + 0x080000000000ULL)\n#define SHADOW_TO_ORIGIN(shadow) (((uptr)(shadow)) + 0x140000000000ULL)\n\n#elif SANITIZER_FREEBSD && SANITIZER_WORDSIZE == 64\n\n// Low memory: main binary, MAP_32BIT mappings and modules\n// High memory: heap, modules and main thread stack\nconst MappingDesc kMemoryLayout[] = {\n    {0x000000000000ULL, 0x010000000000ULL, MappingDesc::APP, \"low memory\"},\n    {0x010000000000ULL, 0x100000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x100000000000ULL, 0x310000000000ULL, MappingDesc::SHADOW, \"shadow\"},\n    {0x310000000000ULL, 0x380000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x380000000000ULL, 0x590000000000ULL, MappingDesc::ORIGIN, \"origin\"},\n    {0x590000000000ULL, 0x600000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x600000000000ULL, 0x800000000000ULL, MappingDesc::APP, \"high memory\"}};\n\n// Maps low and high app ranges to contiguous space with zero base:\n//   Low:  0000 0000 0000 - 00ff ffff ffff  ->  2000 0000 0000 - 20ff ffff ffff\n//   High: 6000 0000 0000 - 7fff ffff ffff  ->  0000 0000 0000 - 1fff ffff ffff\n#define LINEARIZE_MEM(mem) \\\n  (((uptr)(mem) & ~0xc00000000000ULL) ^ 0x200000000000ULL)\n#define MEM_TO_SHADOW(mem) (LINEARIZE_MEM((mem)) + 0x100000000000ULL)\n#define SHADOW_TO_ORIGIN(shadow) (((uptr)(shadow)) + 0x280000000000)\n\n#elif SANITIZER_NETBSD || (SANITIZER_LINUX && SANITIZER_WORDSIZE == 64)\n\n#ifdef MSAN_LINUX_X86_64_OLD_MAPPING\n// Requries PIE binary and ASLR enabled.\n// Main thread stack and DSOs at 0x7f0000000000 (sometimes 0x7e0000000000).\n// Heap at 0x600000000000.\nconst MappingDesc kMemoryLayout[] = {\n    {0x000000000000ULL, 0x200000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x200000000000ULL, 0x400000000000ULL, MappingDesc::SHADOW, \"shadow\"},\n    {0x400000000000ULL, 0x600000000000ULL, MappingDesc::ORIGIN, \"origin\"},\n    {0x600000000000ULL, 0x800000000000ULL, MappingDesc::APP, \"app\"}};\n\n#define MEM_TO_SHADOW(mem) (((uptr)(mem)) & ~0x400000000000ULL)\n#define SHADOW_TO_ORIGIN(mem) (((uptr)(mem)) + 0x200000000000ULL)\n#else  // MSAN_LINUX_X86_64_OLD_MAPPING\n// All of the following configurations are supported.\n// ASLR disabled: main executable and DSOs at 0x555550000000\n// PIE and ASLR: main executable and DSOs at 0x7f0000000000\n// non-PIE: main executable below 0x100000000, DSOs at 0x7f0000000000\n// Heap at 0x700000000000.\nconst MappingDesc kMemoryLayout[] = {\n    {0x000000000000ULL, 0x010000000000ULL, MappingDesc::APP, \"app-1\"},\n    {0x010000000000ULL, 0x100000000000ULL, MappingDesc::SHADOW, \"shadow-2\"},\n    {0x100000000000ULL, 0x110000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x110000000000ULL, 0x200000000000ULL, MappingDesc::ORIGIN, \"origin-2\"},\n    {0x200000000000ULL, 0x300000000000ULL, MappingDesc::SHADOW, \"shadow-3\"},\n    {0x300000000000ULL, 0x400000000000ULL, MappingDesc::ORIGIN, \"origin-3\"},\n    {0x400000000000ULL, 0x500000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x500000000000ULL, 0x510000000000ULL, MappingDesc::SHADOW, \"shadow-1\"},\n    {0x510000000000ULL, 0x600000000000ULL, MappingDesc::APP, \"app-2\"},\n    {0x600000000000ULL, 0x610000000000ULL, MappingDesc::ORIGIN, \"origin-1\"},\n    {0x610000000000ULL, 0x700000000000ULL, MappingDesc::INVALID, \"invalid\"},\n    {0x700000000000ULL, 0x800000000000ULL, MappingDesc::APP, \"app-3\"}};\n#define MEM_TO_SHADOW(mem) (((uptr)(mem)) ^ 0x500000000000ULL)\n#define SHADOW_TO_ORIGIN(mem) (((uptr)(mem)) + 0x100000000000ULL)\n#endif  // MSAN_LINUX_X86_64_OLD_MAPPING\n\n#else\n#error \"Unsupported platform\"\n#endif\n\nconst uptr kMemoryLayoutSize = sizeof(kMemoryLayout) / sizeof(kMemoryLayout[0]);\n\n#define MEM_TO_ORIGIN(mem) (SHADOW_TO_ORIGIN(MEM_TO_SHADOW((mem))))\n\n#ifndef __clang__\n__attribute__((optimize(\"unroll-loops\")))\n#endif\ninline bool addr_is_type(uptr addr, MappingDesc::Type mapping_type) {\n// It is critical for performance that this loop is unrolled (because then it is\n// simplified into just a few constant comparisons).\n#ifdef __clang__\n#pragma unroll\n#endif\n  for (unsigned i = 0; i < kMemoryLayoutSize; ++i)\n    if (kMemoryLayout[i].type == mapping_type &&\n        addr >= kMemoryLayout[i].start && addr < kMemoryLayout[i].end)\n      return true;\n  return false;\n}\n\n#define MEM_IS_APP(mem) addr_is_type((uptr)(mem), MappingDesc::APP)\n#define MEM_IS_SHADOW(mem) addr_is_type((uptr)(mem), MappingDesc::SHADOW)\n#define MEM_IS_ORIGIN(mem) addr_is_type((uptr)(mem), MappingDesc::ORIGIN)\n\n// These constants must be kept in sync with the ones in MemorySanitizer.cpp.\nconst int kMsanParamTlsSize = 800;\nconst int kMsanRetvalTlsSize = 800;\n\nnamespace __msan {\nextern int msan_inited;\nextern bool msan_init_is_running;\nextern int msan_report_count;\n\nbool ProtectRange(uptr beg, uptr end);\nbool InitShadow(bool init_origins);\nchar *GetProcSelfMaps();\nvoid InitializeInterceptors();\n\nvoid MsanAllocatorInit();\nvoid MsanAllocatorThreadFinish();\nvoid MsanDeallocate(StackTrace *stack, void *ptr);\n\nvoid *msan_malloc(uptr size, StackTrace *stack);\nvoid *msan_calloc(uptr nmemb, uptr size, StackTrace *stack);\nvoid *msan_realloc(void *ptr, uptr size, StackTrace *stack);\nvoid *msan_reallocarray(void *ptr, uptr nmemb, uptr size, StackTrace *stack);\nvoid *msan_valloc(uptr size, StackTrace *stack);\nvoid *msan_pvalloc(uptr size, StackTrace *stack);\nvoid *msan_aligned_alloc(uptr alignment, uptr size, StackTrace *stack);\nvoid *msan_memalign(uptr alignment, uptr size, StackTrace *stack);\nint msan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                        StackTrace *stack);\n\nvoid InstallTrapHandler();\nvoid InstallAtExitHandler();\n\nconst char *GetStackOriginDescr(u32 id, uptr *pc);\n\nvoid EnterSymbolizer();\nvoid ExitSymbolizer();\nbool IsInSymbolizer();\n\nstruct SymbolizerScope {\n  SymbolizerScope() { EnterSymbolizer(); }\n  ~SymbolizerScope() { ExitSymbolizer(); }\n};\n\nvoid PrintWarning(uptr pc, uptr bp);\nvoid PrintWarningWithOrigin(uptr pc, uptr bp, u32 origin);\n\n// Unpoison first n function arguments.\nvoid UnpoisonParam(uptr n);\nvoid UnpoisonThreadLocalState();\n\n// Returns a \"chained\" origin id, pointing to the given stack trace followed by\n// the previous origin id.\nu32 ChainOrigin(u32 id, StackTrace *stack);\n\nconst int STACK_TRACE_TAG_POISON = StackTrace::TAG_CUSTOM + 1;\n\n#define GET_MALLOC_STACK_TRACE                                            \\\n  BufferedStackTrace stack;                                               \\\n  if (__msan_get_track_origins() && msan_inited)                          \\\n    stack.Unwind(StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(),         \\\n                 nullptr, common_flags()->fast_unwind_on_malloc,          \\\n                 common_flags()->malloc_context_size)\n\n// For platforms which support slow unwinder only, we restrict the store context\n// size to 1, basically only storing the current pc. We do this because the slow\n// unwinder which is based on libunwind is not async signal safe and causes\n// random freezes in forking applications as well as in signal handlers.\n#define GET_STORE_STACK_TRACE_PC_BP(pc, bp)                                    \\\n  BufferedStackTrace stack;                                                    \\\n  if (__msan_get_track_origins() > 1 && msan_inited) {                         \\\n    int size = flags()->store_context_size;                                    \\\n    if (!SANITIZER_CAN_FAST_UNWIND)                                            \\\n      size = Min(size, 1);                                                     \\\n    stack.Unwind(pc, bp, nullptr, common_flags()->fast_unwind_on_malloc, size);\\\n  }\n\n#define GET_STORE_STACK_TRACE \\\n  GET_STORE_STACK_TRACE_PC_BP(StackTrace::GetCurrentPc(), GET_CURRENT_FRAME())\n\n#define GET_FATAL_STACK_TRACE_PC_BP(pc, bp)                              \\\n  BufferedStackTrace stack;                                              \\\n  if (msan_inited) {                                                     \\\n    stack.Unwind(pc, bp, nullptr, common_flags()->fast_unwind_on_fatal); \\\n  }\n\n#define GET_FATAL_STACK_TRACE_HERE \\\n  GET_FATAL_STACK_TRACE_PC_BP(StackTrace::GetCurrentPc(), GET_CURRENT_FRAME())\n\n#define PRINT_CURRENT_STACK_CHECK() \\\n  {                                 \\\n    GET_FATAL_STACK_TRACE_HERE;     \\\n    stack.Print();                  \\\n  }\n\nclass ScopedThreadLocalStateBackup {\n public:\n  ScopedThreadLocalStateBackup() { Backup(); }\n  ~ScopedThreadLocalStateBackup() { Restore(); }\n  void Backup();\n  void Restore();\n private:\n  u64 va_arg_overflow_size_tls;\n};\n\nvoid MsanTSDInit(void (*destructor)(void *tsd));\nvoid *MsanTSDGet();\nvoid MsanTSDSet(void *tsd);\nvoid MsanTSDDtor(void *tsd);\n\n}  // namespace __msan\n\n#define MSAN_MALLOC_HOOK(ptr, size)       \\\n  do {                                    \\\n    if (&__sanitizer_malloc_hook) {       \\\n      UnpoisonParam(2);                   \\\n      __sanitizer_malloc_hook(ptr, size); \\\n    }                                     \\\n    RunMallocHooks(ptr, size);            \\\n  } while (false)\n#define MSAN_FREE_HOOK(ptr)       \\\n  do {                            \\\n    if (&__sanitizer_free_hook) { \\\n      UnpoisonParam(1);           \\\n      __sanitizer_free_hook(ptr); \\\n    }                             \\\n    RunFreeHooks(ptr);            \\\n  } while (false)\n\n#endif  // MSAN_H\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_allocator.h", "content": "//===-- msan_allocator.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of MemorySanitizer.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef MSAN_ALLOCATOR_H\n#define MSAN_ALLOCATOR_H\n\n#include \"sanitizer_common/sanitizer_common.h\"\n\nnamespace __msan {\n\nstruct MsanThreadLocalMallocStorage {\n  uptr quarantine_cache[16];\n  // Allocator cache contains atomic_uint64_t which must be 8-byte aligned.\n  ALIGNED(8) uptr allocator_cache[96 * (512 * 8 + 16)];  // Opaque.\n  void CommitBack();\n\n private:\n  // These objects are allocated via mmap() and are zero-initialized.\n  MsanThreadLocalMallocStorage() {}\n};\n\n} // namespace __msan\n#endif // MSAN_ALLOCATOR_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_flags.h", "content": "//===-- msan_flags.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of MemorySanitizer.\n//\n//===----------------------------------------------------------------------===//\n#ifndef MSAN_FLAGS_H\n#define MSAN_FLAGS_H\n\nnamespace __msan {\n\nstruct Flags {\n#define MSAN_FLAG(Type, Name, DefaultValue, Description) Type Name;\n#include \"msan_flags.inc\"\n#undef MSAN_FLAG\n\n  void SetDefaults();\n};\n\nFlags *flags();\n\n}  // namespace __msan\n\n#endif  // MSAN_FLAGS_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_interface_internal.h", "content": "//===-- msan_interface_internal.h -------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of MemorySanitizer.\n//\n// Private MSan interface header.\n//===----------------------------------------------------------------------===//\n\n#ifndef MSAN_INTERFACE_INTERNAL_H\n#define MSAN_INTERFACE_INTERNAL_H\n\n#include \"sanitizer_common/sanitizer_internal_defs.h\"\n\nextern \"C\" {\n// FIXME: document all interface functions.\n\nSANITIZER_INTERFACE_ATTRIBUTE\nint __msan_get_track_origins();\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_init();\n\n// Print a warning and maybe return.\n// This function can die based on common_flags()->exitcode.\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_warning();\n\n// Print a warning and die.\n// Intrumentation inserts calls to this function when building in \"fast\" mode\n// (i.e. -mllvm -msan-keep-going)\nSANITIZER_INTERFACE_ATTRIBUTE __attribute__((noreturn))\nvoid __msan_warning_noreturn();\n\nusing __sanitizer::uptr;\nusing __sanitizer::sptr;\nusing __sanitizer::uu64;\nusing __sanitizer::uu32;\nusing __sanitizer::uu16;\nusing __sanitizer::u64;\nusing __sanitizer::u32;\nusing __sanitizer::u16;\nusing __sanitizer::u8;\n\n// Versions of the above which take Origin as a parameter\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_warning_with_origin(u32 origin);\nSANITIZER_INTERFACE_ATTRIBUTE __attribute__((noreturn)) void\n__msan_warning_with_origin_noreturn(u32 origin);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_warning_1(u8 s, u32 o);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_warning_2(u16 s, u32 o);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_warning_4(u32 s, u32 o);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_warning_8(u64 s, u32 o);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_store_origin_1(u8 s, void *p, u32 o);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_store_origin_2(u16 s, void *p, u32 o);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_store_origin_4(u32 s, void *p, u32 o);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_maybe_store_origin_8(u64 s, void *p, u32 o);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_unpoison(const void *a, uptr size);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_unpoison_string(const char *s);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_unpoison_param(uptr n);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_clear_and_unpoison(void *a, uptr size);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid* __msan_memcpy(void *dst, const void *src, uptr size);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid* __msan_memset(void *s, int c, uptr n);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid* __msan_memmove(void* dest, const void* src, uptr n);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_poison(const void *a, uptr size);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_poison_stack(void *a, uptr size);\n\n// Copy size bytes from src to dst and unpoison the result.\n// Useful to implement unsafe loads.\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_load_unpoisoned(void *src, uptr size, void *dst);\n\n// Returns the offset of the first (at least partially) poisoned byte,\n// or -1 if the whole range is good.\nSANITIZER_INTERFACE_ATTRIBUTE\nsptr __msan_test_shadow(const void *x, uptr size);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_check_mem_is_initialized(const void *x, uptr size);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_set_origin(const void *a, uptr size, u32 origin);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_set_alloca_origin(void *a, uptr size, char *descr);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_set_alloca_origin4(void *a, uptr size, char *descr, uptr pc);\nSANITIZER_INTERFACE_ATTRIBUTE\nu32 __msan_chain_origin(u32 id);\nSANITIZER_INTERFACE_ATTRIBUTE\nu32 __msan_get_origin(const void *a);\n\n// Test that this_id is a descendant of prev_id (or they are simply equal).\n// \"descendant\" here means that are part of the same chain, created with\n// __msan_chain_origin.\nSANITIZER_INTERFACE_ATTRIBUTE\nint __msan_origin_is_descendant_or_same(u32 this_id, u32 prev_id);\n\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_clear_on_return();\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_set_keep_going(int keep_going);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nint __msan_set_poison_in_malloc(int do_poison);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nconst char *__msan_default_options();\n\n// For testing.\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_set_expect_umr(int expect_umr);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_print_shadow(const void *x, uptr size);\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_dump_shadow(const void *x, uptr size);\nSANITIZER_INTERFACE_ATTRIBUTE\nint  __msan_has_dynamic_component();\n\n// For testing.\nSANITIZER_INTERFACE_ATTRIBUTE\nu32 __msan_get_umr_origin();\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_partial_poison(const void* data, void* shadow, uptr size);\n\n// Tell MSan about newly allocated memory (ex.: custom allocator).\n// Memory will be marked uninitialized, with origin at the call site.\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_allocated_memory(const void* data, uptr size);\n\n// Tell MSan about newly destroyed memory. Memory will be marked\n// uninitialized.\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __sanitizer_dtor_callback(const void* data, uptr size);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nu16 __sanitizer_unaligned_load16(const uu16 *p);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nu32 __sanitizer_unaligned_load32(const uu32 *p);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nu64 __sanitizer_unaligned_load64(const uu64 *p);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __sanitizer_unaligned_store16(uu16 *p, u16 x);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __sanitizer_unaligned_store32(uu32 *p, u32 x);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __sanitizer_unaligned_store64(uu64 *p, u64 x);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_set_death_callback(void (*callback)(void));\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_copy_shadow(void *dst, const void *src, uptr size);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_scoped_disable_interceptor_checks();\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_scoped_enable_interceptor_checks();\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_start_switch_fiber(const void *bottom, uptr size);\n\nSANITIZER_INTERFACE_ATTRIBUTE\nvoid __msan_finish_switch_fiber(const void **bottom_old, uptr *size_old);\n}  // extern \"C\"\n\n#endif  // MSAN_INTERFACE_INTERNAL_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_report.h", "content": "//===-- msan_report.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file is a part of MemorySanitizer. MSan-private header for error\n/// reporting functions.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef MSAN_REPORT_H\n#define MSAN_REPORT_H\n\n#include \"sanitizer_common/sanitizer_internal_defs.h\"\n#include \"sanitizer_common/sanitizer_stacktrace.h\"\n\nnamespace __msan {\n\nvoid ReportUMR(StackTrace *stack, u32 origin);\nvoid ReportExpectedUMRNotFound(StackTrace *stack);\nvoid ReportStats();\nvoid ReportAtExitStatistics();\nvoid DescribeMemoryRange(const void *x, uptr size);\nvoid ReportUMRInsideAddressRange(const char *what, const void *start, uptr size,\n                                 uptr offset);\n\n}  // namespace __msan\n\n#endif  // MSAN_REPORT_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_thread.h", "content": "//===-- msan_thread.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of MemorySanitizer.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef MSAN_THREAD_H\n#define MSAN_THREAD_H\n\n#include \"msan_allocator.h\"\n#include \"sanitizer_common/sanitizer_common.h\"\n\nnamespace __msan {\n\nclass MsanThread {\n public:\n  static MsanThread *Create(thread_callback_t start_routine, void *arg);\n  static void TSDDtor(void *tsd);\n  void Destroy();\n\n  void Init();  // Should be called from the thread itself.\n  thread_return_t ThreadStart();\n\n  uptr stack_top();\n  uptr stack_bottom();\n  uptr tls_begin() { return tls_begin_; }\n  uptr tls_end() { return tls_end_; }\n  bool IsMainThread() { return start_routine_ == nullptr; }\n\n  bool AddrIsInStack(uptr addr);\n\n  bool InSignalHandler() { return in_signal_handler_; }\n  void EnterSignalHandler() { in_signal_handler_++; }\n  void LeaveSignalHandler() { in_signal_handler_--; }\n\n  void StartSwitchFiber(uptr bottom, uptr size);\n  void FinishSwitchFiber(uptr *bottom_old, uptr *size_old);\n\n  MsanThreadLocalMallocStorage &malloc_storage() { return malloc_storage_; }\n\n  int destructor_iterations_;\n\n private:\n  // NOTE: There is no MsanThread constructor. It is allocated\n  // via mmap() and *must* be valid in zero-initialized state.\n  void SetThreadStackAndTls();\n  void ClearShadowForThreadStackAndTLS();\n  struct StackBounds {\n    uptr bottom;\n    uptr top;\n  };\n  StackBounds GetStackBounds() const;\n  thread_callback_t start_routine_;\n  void *arg_;\n\n  bool stack_switching_;\n\n  StackBounds stack_;\n  StackBounds next_stack_;\n\n  uptr tls_begin_;\n  uptr tls_end_;\n\n  unsigned in_signal_handler_;\n\n  MsanThreadLocalMallocStorage malloc_storage_;\n};\n\nMsanThread *GetCurrentThread();\nvoid SetCurrentThread(MsanThread *t);\n\n} // namespace __msan\n\n#endif // MSAN_THREAD_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_atomic.h", "content": "//===-- sanitizer_atomic.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_ATOMIC_H\n#define SANITIZER_ATOMIC_H\n\n#include \"sanitizer_internal_defs.h\"\n\nnamespace __sanitizer {\n\nenum memory_order {\n  memory_order_relaxed = 1 << 0,\n  memory_order_consume = 1 << 1,\n  memory_order_acquire = 1 << 2,\n  memory_order_release = 1 << 3,\n  memory_order_acq_rel = 1 << 4,\n  memory_order_seq_cst = 1 << 5\n};\n\nstruct atomic_uint8_t {\n  typedef u8 Type;\n  volatile Type val_dont_use;\n};\n\nstruct atomic_uint16_t {\n  typedef u16 Type;\n  volatile Type val_dont_use;\n};\n\nstruct atomic_sint32_t {\n  typedef s32 Type;\n  volatile Type val_dont_use;\n};\n\nstruct atomic_uint32_t {\n  typedef u32 Type;\n  volatile Type val_dont_use;\n};\n\nstruct atomic_uint64_t {\n  typedef u64 Type;\n  // On 32-bit platforms u64 is not necessary aligned on 8 bytes.\n  volatile ALIGNED(8) Type val_dont_use;\n};\n\nstruct atomic_uintptr_t {\n  typedef uptr Type;\n  volatile Type val_dont_use;\n};\n\n}  // namespace __sanitizer\n\n#if defined(__clang__) || defined(__GNUC__)\n# include \"sanitizer_atomic_clang.h\"\n#elif defined(_MSC_VER)\n# include \"sanitizer_atomic_msvc.h\"\n#else\n# error \"Unsupported compiler\"\n#endif\n\nnamespace __sanitizer {\n\n// Clutter-reducing helpers.\n\ntemplate<typename T>\ninline typename T::Type atomic_load_relaxed(const volatile T *a) {\n  return atomic_load(a, memory_order_relaxed);\n}\n\ntemplate<typename T>\ninline void atomic_store_relaxed(volatile T *a, typename T::Type v) {\n  atomic_store(a, v, memory_order_relaxed);\n}\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_ATOMIC_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_atomic_clang.h", "content": "//===-- sanitizer_atomic_clang.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n// Not intended for direct inclusion. Include sanitizer_atomic.h.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_ATOMIC_CLANG_H\n#define SANITIZER_ATOMIC_CLANG_H\n\n#if defined(__i386__) || defined(__x86_64__)\n# include \"sanitizer_atomic_clang_x86.h\"\n#else\n# include \"sanitizer_atomic_clang_other.h\"\n#endif\n\nnamespace __sanitizer {\n\n// We would like to just use compiler builtin atomic operations\n// for loads and stores, but they are mostly broken in clang:\n// - they lead to vastly inefficient code generation\n// (http://llvm.org/bugs/show_bug.cgi?id=17281)\n// - 64-bit atomic operations are not implemented on x86_32\n// (http://llvm.org/bugs/show_bug.cgi?id=15034)\n// - they are not implemented on ARM\n// error: undefined reference to '__atomic_load_4'\n\n// See http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html\n// for mappings of the memory model to different processors.\n\ninline void atomic_signal_fence(memory_order) {\n  __asm__ __volatile__(\"\" ::: \"memory\");\n}\n\ninline void atomic_thread_fence(memory_order) {\n  __sync_synchronize();\n}\n\ntemplate<typename T>\ninline typename T::Type atomic_fetch_add(volatile T *a,\n    typename T::Type v, memory_order mo) {\n  (void)mo;\n  DCHECK(!((uptr)a % sizeof(*a)));\n  return __sync_fetch_and_add(&a->val_dont_use, v);\n}\n\ntemplate<typename T>\ninline typename T::Type atomic_fetch_sub(volatile T *a,\n    typename T::Type v, memory_order mo) {\n  (void)mo;\n  DCHECK(!((uptr)a % sizeof(*a)));\n  return __sync_fetch_and_add(&a->val_dont_use, -v);\n}\n\ntemplate<typename T>\ninline typename T::Type atomic_exchange(volatile T *a,\n    typename T::Type v, memory_order mo) {\n  DCHECK(!((uptr)a % sizeof(*a)));\n  if (mo & (memory_order_release | memory_order_acq_rel | memory_order_seq_cst))\n    __sync_synchronize();\n  v = __sync_lock_test_and_set(&a->val_dont_use, v);\n  if (mo == memory_order_seq_cst)\n    __sync_synchronize();\n  return v;\n}\n\ntemplate <typename T>\ninline bool atomic_compare_exchange_strong(volatile T *a, typename T::Type *cmp,\n                                           typename T::Type xchg,\n                                           memory_order mo) {\n  typedef typename T::Type Type;\n  Type cmpv = *cmp;\n  Type prev;\n  prev = __sync_val_compare_and_swap(&a->val_dont_use, cmpv, xchg);\n  if (prev == cmpv) return true;\n  *cmp = prev;\n  return false;\n}\n\ntemplate<typename T>\ninline bool atomic_compare_exchange_weak(volatile T *a,\n                                         typename T::Type *cmp,\n                                         typename T::Type xchg,\n                                         memory_order mo) {\n  return atomic_compare_exchange_strong(a, cmp, xchg, mo);\n}\n\n}  // namespace __sanitizer\n\n// This include provides explicit template instantiations for atomic_uint64_t\n// on MIPS32, which does not directly support 8 byte atomics. It has to\n// proceed the template definitions above.\n#if defined(_MIPS_SIM) && defined(_ABIO32)\n  #include \"sanitizer_atomic_clang_mips.h\"\n#endif\n\n#undef ATOMIC_ORDER\n\n#endif  // SANITIZER_ATOMIC_CLANG_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_atomic_clang_x86.h", "content": "//===-- sanitizer_atomic_clang_x86.h ----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n// Not intended for direct inclusion. Include sanitizer_atomic.h.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_ATOMIC_CLANG_X86_H\n#define SANITIZER_ATOMIC_CLANG_X86_H\n\nnamespace __sanitizer {\n\ninline void proc_yield(int cnt) {\n  __asm__ __volatile__(\"\" ::: \"memory\");\n  for (int i = 0; i < cnt; i++)\n    __asm__ __volatile__(\"pause\");\n  __asm__ __volatile__(\"\" ::: \"memory\");\n}\n\ntemplate<typename T>\ninline typename T::Type atomic_load(\n    const volatile T *a, memory_order mo) {\n  DCHECK(mo & (memory_order_relaxed | memory_order_consume\n      | memory_order_acquire | memory_order_seq_cst));\n  DCHECK(!((uptr)a % sizeof(*a)));\n  typename T::Type v;\n\n  if (sizeof(*a) < 8 || sizeof(void*) == 8) {\n    // Assume that aligned loads are atomic.\n    if (mo == memory_order_relaxed) {\n      v = a->val_dont_use;\n    } else if (mo == memory_order_consume) {\n      // Assume that processor respects data dependencies\n      // (and that compiler won't break them).\n      __asm__ __volatile__(\"\" ::: \"memory\");\n      v = a->val_dont_use;\n      __asm__ __volatile__(\"\" ::: \"memory\");\n    } else if (mo == memory_order_acquire) {\n      __asm__ __volatile__(\"\" ::: \"memory\");\n      v = a->val_dont_use;\n      // On x86 loads are implicitly acquire.\n      __asm__ __volatile__(\"\" ::: \"memory\");\n    } else {  // seq_cst\n      // On x86 plain MOV is enough for seq_cst store.\n      __asm__ __volatile__(\"\" ::: \"memory\");\n      v = a->val_dont_use;\n      __asm__ __volatile__(\"\" ::: \"memory\");\n    }\n  } else {\n    // 64-bit load on 32-bit platform.\n    __asm__ __volatile__(\n        \"movq %1, %%mm0;\"  // Use mmx reg for 64-bit atomic moves\n        \"movq %%mm0, %0;\"  // (ptr could be read-only)\n        \"emms;\"            // Empty mmx state/Reset FP regs\n        : \"=m\" (v)\n        : \"m\" (a->val_dont_use)\n        : // mark the mmx registers as clobbered\n#ifdef __MMX__\n          \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\",\n#endif  // #ifdef __MMX__\n          \"memory\");\n  }\n  return v;\n}\n\ntemplate<typename T>\ninline void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n  DCHECK(mo & (memory_order_relaxed | memory_order_release\n      | memory_order_seq_cst));\n  DCHECK(!((uptr)a % sizeof(*a)));\n\n  if (sizeof(*a) < 8 || sizeof(void*) == 8) {\n    // Assume that aligned loads are atomic.\n    if (mo == memory_order_relaxed) {\n      a->val_dont_use = v;\n    } else if (mo == memory_order_release) {\n      // On x86 stores are implicitly release.\n      __asm__ __volatile__(\"\" ::: \"memory\");\n      a->val_dont_use = v;\n      __asm__ __volatile__(\"\" ::: \"memory\");\n    } else {  // seq_cst\n      // On x86 stores are implicitly release.\n      __asm__ __volatile__(\"\" ::: \"memory\");\n      a->val_dont_use = v;\n      __sync_synchronize();\n    }\n  } else {\n    // 64-bit store on 32-bit platform.\n    __asm__ __volatile__(\n        \"movq %1, %%mm0;\"  // Use mmx reg for 64-bit atomic moves\n        \"movq %%mm0, %0;\"\n        \"emms;\"            // Empty mmx state/Reset FP regs\n        : \"=m\" (a->val_dont_use)\n        : \"m\" (v)\n        : // mark the mmx registers as clobbered\n#ifdef __MMX__\n          \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\",\n#endif  // #ifdef __MMX__\n          \"memory\");\n    if (mo == memory_order_seq_cst)\n      __sync_synchronize();\n  }\n}\n\n}  // namespace __sanitizer\n\n#endif  // #ifndef SANITIZER_ATOMIC_CLANG_X86_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_common.h", "content": "//===-- sanitizer_common.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between run-time libraries of sanitizers.\n//\n// It declares common functions and classes that are used in both runtimes.\n// Implementation of some functions are provided in sanitizer_common, while\n// others must be defined by run-time library itself.\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_COMMON_H\n#define SANITIZER_COMMON_H\n\n#include \"sanitizer_flags.h\"\n#include \"sanitizer_interface_internal.h\"\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_libc.h\"\n#include \"sanitizer_list.h\"\n#include \"sanitizer_mutex.h\"\n\n#if defined(_MSC_VER) && !defined(__clang__)\nextern \"C\" void _ReadWriteBarrier();\n#pragma intrinsic(_ReadWriteBarrier)\n#endif\n\nnamespace __sanitizer {\n\nstruct AddressInfo;\nstruct BufferedStackTrace;\nstruct SignalContext;\nstruct StackTrace;\n\n// Constants.\nconst uptr kWordSize = SANITIZER_WORDSIZE / 8;\nconst uptr kWordSizeInBits = 8 * kWordSize;\n\nconst uptr kCacheLineSize = SANITIZER_CACHE_LINE_SIZE;\n\nconst uptr kMaxPathLength = 4096;\n\nconst uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n\nconst uptr kErrorMessageBufferSize = 1 << 16;\n\n// Denotes fake PC values that come from JIT/JAVA/etc.\n// For such PC values __tsan_symbolize_external_ex() will be called.\nconst u64 kExternalPCBit = 1ULL << 60;\n\nextern const char *SanitizerToolName;  // Can be changed by the tool.\n\nextern atomic_uint32_t current_verbosity;\ninline void SetVerbosity(int verbosity) {\n  atomic_store(&current_verbosity, verbosity, memory_order_relaxed);\n}\ninline int Verbosity() {\n  return atomic_load(&current_verbosity, memory_order_relaxed);\n}\n\n#if SANITIZER_ANDROID\ninline uptr GetPageSize() {\n// Android post-M sysconf(_SC_PAGESIZE) crashes if called from .preinit_array.\n  return 4096;\n}\ninline uptr GetPageSizeCached() {\n  return 4096;\n}\n#else\nuptr GetPageSize();\nextern uptr PageSizeCached;\ninline uptr GetPageSizeCached() {\n  if (!PageSizeCached)\n    PageSizeCached = GetPageSize();\n  return PageSizeCached;\n}\n#endif\nuptr GetMmapGranularity();\nuptr GetMaxVirtualAddress();\nuptr GetMaxUserVirtualAddress();\n// Threads\ntid_t GetTid();\nint TgKill(pid_t pid, tid_t tid, int sig);\nuptr GetThreadSelf();\nvoid GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                uptr *stack_bottom);\nvoid GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                          uptr *tls_addr, uptr *tls_size);\n\n// Memory management\nvoid *MmapOrDie(uptr size, const char *mem_type, bool raw_report = false);\ninline void *MmapOrDieQuietly(uptr size, const char *mem_type) {\n  return MmapOrDie(size, mem_type, /*raw_report*/ true);\n}\nvoid UnmapOrDie(void *addr, uptr size);\n// Behaves just like MmapOrDie, but tolerates out of memory condition, in that\n// case returns nullptr.\nvoid *MmapOrDieOnFatalError(uptr size, const char *mem_type);\nbool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name = nullptr)\n     WARN_UNUSED_RESULT;\nbool MmapFixedSuperNoReserve(uptr fixed_addr, uptr size,\n                             const char *name = nullptr) WARN_UNUSED_RESULT;\nvoid *MmapNoReserveOrDie(uptr size, const char *mem_type);\nvoid *MmapFixedOrDie(uptr fixed_addr, uptr size, const char *name = nullptr);\n// Behaves just like MmapFixedOrDie, but tolerates out of memory condition, in\n// that case returns nullptr.\nvoid *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size,\n                                 const char *name = nullptr);\nvoid *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name = nullptr);\nvoid *MmapNoAccess(uptr size);\n// Map aligned chunk of address space; size and alignment are powers of two.\n// Dies on all but out of memory errors, in the latter case returns nullptr.\nvoid *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n                                   const char *mem_type);\n// Disallow access to a memory range.  Use MmapFixedNoAccess to allocate an\n// unaccessible memory.\nbool MprotectNoAccess(uptr addr, uptr size);\nbool MprotectReadOnly(uptr addr, uptr size);\n\nvoid MprotectMallocZones(void *addr, int prot);\n\n#if SANITIZER_LINUX\n// Unmap memory. Currently only used on Linux.\nvoid UnmapFromTo(uptr from, uptr to);\n#endif\n\n// Maps shadow_size_bytes of shadow memory and returns shadow address. It will\n// be aligned to the mmap granularity * 2^shadow_scale, or to\n// 2^min_shadow_base_alignment if that is larger. The returned address will\n// have max(2^min_shadow_base_alignment, mmap granularity) on the left, and\n// shadow_size_bytes bytes on the right, which on linux is mapped no access.\n// The high_mem_end may be updated if the original shadow size doesn't fit.\nuptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n                      uptr min_shadow_base_alignment, uptr &high_mem_end);\n\n// Let S = max(shadow_size, num_aliases * alias_size, ring_buffer_size).\n// Reserves 2*S bytes of address space to the right of the returned address and\n// ring_buffer_size bytes to the left.  The returned address is aligned to 2*S.\n// Also creates num_aliases regions of accessible memory starting at offset S\n// from the returned address.  Each region has size alias_size and is backed by\n// the same physical memory.\nuptr MapDynamicShadowAndAliases(uptr shadow_size, uptr alias_size,\n                                uptr num_aliases, uptr ring_buffer_size);\n\n// Reserve memory range [beg, end]. If madvise_shadow is true then apply\n// madvise (e.g. hugepages, core dumping) requested by options.\nvoid ReserveShadowMemoryRange(uptr beg, uptr end, const char *name,\n                              bool madvise_shadow = true);\n\n// Protect size bytes of memory starting at addr. Also try to protect\n// several pages at the start of the address space as specified by\n// zero_base_shadow_start, at most up to the size or zero_base_max_shadow_start.\nvoid ProtectGap(uptr addr, uptr size, uptr zero_base_shadow_start,\n                uptr zero_base_max_shadow_start);\n\n// Find an available address space.\nuptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n                              uptr *largest_gap_found, uptr *max_occupied_addr);\n\n// Used to check if we can map shadow memory to a fixed location.\nbool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n// Releases memory pages entirely within the [beg, end] address range. Noop if\n// the provided range does not contain at least one entire page.\nvoid ReleaseMemoryPagesToOS(uptr beg, uptr end);\nvoid IncreaseTotalMmap(uptr size);\nvoid DecreaseTotalMmap(uptr size);\nuptr GetRSS();\nvoid SetShadowRegionHugePageMode(uptr addr, uptr length);\nbool DontDumpShadowMemory(uptr addr, uptr length);\n// Check if the built VMA size matches the runtime one.\nvoid CheckVMASize();\nvoid RunMallocHooks(const void *ptr, uptr size);\nvoid RunFreeHooks(const void *ptr);\n\nclass ReservedAddressRange {\n public:\n  uptr Init(uptr size, const char *name = nullptr, uptr fixed_addr = 0);\n  uptr InitAligned(uptr size, uptr align, const char *name = nullptr);\n  uptr Map(uptr fixed_addr, uptr size, const char *name = nullptr);\n  uptr MapOrDie(uptr fixed_addr, uptr size, const char *name = nullptr);\n  void Unmap(uptr addr, uptr size);\n  void *base() const { return base_; }\n  uptr size() const { return size_; }\n\n private:\n  void* base_;\n  uptr size_;\n  const char* name_;\n  uptr os_handle_;\n};\n\ntypedef void (*fill_profile_f)(uptr start, uptr rss, bool file,\n                               /*out*/uptr *stats, uptr stats_size);\n\n// Parse the contents of /proc/self/smaps and generate a memory profile.\n// |cb| is a tool-specific callback that fills the |stats| array containing\n// |stats_size| elements.\nvoid GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size);\n\n// Simple low-level (mmap-based) allocator for internal use. Doesn't have\n// constructor, so all instances of LowLevelAllocator should be\n// linker initialized.\nclass LowLevelAllocator {\n public:\n  // Requires an external lock.\n  void *Allocate(uptr size);\n private:\n  char *allocated_end_;\n  char *allocated_current_;\n};\n// Set the min alignment of LowLevelAllocator to at least alignment.\nvoid SetLowLevelAllocateMinAlignment(uptr alignment);\ntypedef void (*LowLevelAllocateCallback)(uptr ptr, uptr size);\n// Allows to register tool-specific callbacks for LowLevelAllocator.\n// Passing NULL removes the callback.\nvoid SetLowLevelAllocateCallback(LowLevelAllocateCallback callback);\n\n// IO\nvoid CatastrophicErrorWrite(const char *buffer, uptr length);\nvoid RawWrite(const char *buffer);\nbool ColorizeReports();\nvoid RemoveANSIEscapeSequencesFromString(char *buffer);\nvoid Printf(const char *format, ...);\nvoid Report(const char *format, ...);\nvoid SetPrintfAndReportCallback(void (*callback)(const char *));\n#define VReport(level, ...)                                              \\\n  do {                                                                   \\\n    if ((uptr)Verbosity() >= (level)) Report(__VA_ARGS__); \\\n  } while (0)\n#define VPrintf(level, ...)                                              \\\n  do {                                                                   \\\n    if ((uptr)Verbosity() >= (level)) Printf(__VA_ARGS__); \\\n  } while (0)\n\n// Lock sanitizer error reporting and protects against nested errors.\nclass ScopedErrorReportLock {\n public:\n  ScopedErrorReportLock();\n  ~ScopedErrorReportLock();\n\n  static void CheckLocked();\n};\n\nextern uptr stoptheworld_tracer_pid;\nextern uptr stoptheworld_tracer_ppid;\n\nbool IsAccessibleMemoryRange(uptr beg, uptr size);\n\n// Error report formatting.\nconst char *StripPathPrefix(const char *filepath,\n                            const char *strip_file_prefix);\n// Strip the directories from the module name.\nconst char *StripModuleName(const char *module);\n\n// OS\nuptr ReadBinaryName(/*out*/char *buf, uptr buf_len);\nuptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len);\nuptr ReadBinaryDir(/*out*/ char *buf, uptr buf_len);\nuptr ReadLongProcessName(/*out*/ char *buf, uptr buf_len);\nconst char *GetProcessName();\nvoid UpdateProcessName();\nvoid CacheBinaryName();\nvoid DisableCoreDumperIfNecessary();\nvoid DumpProcessMap();\nconst char *GetEnv(const char *name);\nbool SetEnv(const char *name, const char *value);\n\nu32 GetUid();\nvoid ReExec();\nvoid CheckASLR();\nvoid CheckMPROTECT();\nchar **GetArgv();\nchar **GetEnviron();\nvoid PrintCmdline();\nbool StackSizeIsUnlimited();\nvoid SetStackSizeLimitInBytes(uptr limit);\nbool AddressSpaceIsUnlimited();\nvoid SetAddressSpaceUnlimited();\nvoid AdjustStackSize(void *attr);\nvoid PlatformPrepareForSandboxing(__sanitizer_sandbox_arguments *args);\nvoid SetSandboxingCallback(void (*f)());\n\nvoid InitializeCoverage(bool enabled, const char *coverage_dir);\n\nvoid InitTlsSize();\nuptr GetTlsSize();\n\n// Other\nvoid SleepForSeconds(int seconds);\nvoid SleepForMillis(int millis);\nu64 NanoTime();\nu64 MonotonicNanoTime();\nint Atexit(void (*function)(void));\nbool TemplateMatch(const char *templ, const char *str);\n\n// Exit\nvoid NORETURN Abort();\nvoid NORETURN Die();\nvoid NORETURN\nCheckFailed(const char *file, int line, const char *cond, u64 v1, u64 v2);\nvoid NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n                                      const char *mmap_type, error_t err,\n                                      bool raw_report = false);\n\n// Specific tools may override behavior of \"Die\" and \"CheckFailed\" functions\n// to do tool-specific job.\ntypedef void (*DieCallbackType)(void);\n\n// It's possible to add several callbacks that would be run when \"Die\" is\n// called. The callbacks will be run in the opposite order. The tools are\n// strongly recommended to setup all callbacks during initialization, when there\n// is only a single thread.\nbool AddDieCallback(DieCallbackType callback);\nbool RemoveDieCallback(DieCallbackType callback);\n\nvoid SetUserDieCallback(DieCallbackType callback);\n\ntypedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n                                       u64, u64);\nvoid SetCheckFailedCallback(CheckFailedCallbackType callback);\n\n// Callback will be called if soft_rss_limit_mb is given and the limit is\n// exceeded (exceeded==true) or if rss went down below the limit\n// (exceeded==false).\n// The callback should be registered once at the tool init time.\nvoid SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded));\n\n// Functions related to signal handling.\ntypedef void (*SignalHandlerType)(int, void *, void *);\nHandleSignalMode GetHandleSignalMode(int signum);\nvoid InstallDeadlySignalHandlers(SignalHandlerType handler);\n\n// Signal reporting.\n// Each sanitizer uses slightly different implementation of stack unwinding.\ntypedef void (*UnwindSignalStackCallbackType)(const SignalContext &sig,\n                                              const void *callback_context,\n                                              BufferedStackTrace *stack);\n// Print deadly signal report and die.\nvoid HandleDeadlySignal(void *siginfo, void *context, u32 tid,\n                        UnwindSignalStackCallbackType unwind,\n                        const void *unwind_context);\n\n// Part of HandleDeadlySignal, exposed for asan.\nvoid StartReportDeadlySignal();\n// Part of HandleDeadlySignal, exposed for asan.\nvoid ReportDeadlySignal(const SignalContext &sig, u32 tid,\n                        UnwindSignalStackCallbackType unwind,\n                        const void *unwind_context);\n\n// Alternative signal stack (POSIX-only).\nvoid SetAlternateSignalStack();\nvoid UnsetAlternateSignalStack();\n\n// Construct a one-line string:\n//   SUMMARY: SanitizerToolName: error_message\n// and pass it to __sanitizer_report_error_summary.\n// If alt_tool_name is provided, it's used in place of SanitizerToolName.\nvoid ReportErrorSummary(const char *error_message,\n                        const char *alt_tool_name = nullptr);\n// Same as above, but construct error_message as:\n//   error_type file:line[:column][ function]\nvoid ReportErrorSummary(const char *error_type, const AddressInfo &info,\n                        const char *alt_tool_name = nullptr);\n// Same as above, but obtains AddressInfo by symbolizing top stack trace frame.\nvoid ReportErrorSummary(const char *error_type, const StackTrace *trace,\n                        const char *alt_tool_name = nullptr);\n\nvoid ReportMmapWriteExec(int prot);\n\n// Math\n#if SANITIZER_WINDOWS && !defined(__clang__) && !defined(__GNUC__)\nextern \"C\" {\nunsigned char _BitScanForward(unsigned long *index, unsigned long mask);\nunsigned char _BitScanReverse(unsigned long *index, unsigned long mask);\n#if defined(_WIN64)\nunsigned char _BitScanForward64(unsigned long *index, unsigned __int64 mask);\nunsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);\n#endif\n}\n#endif\n\ninline uptr MostSignificantSetBitIndex(uptr x) {\n  CHECK_NE(x, 0U);\n  unsigned long up;\n#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n# ifdef _WIN64\n  up = SANITIZER_WORDSIZE - 1 - __builtin_clzll(x);\n# else\n  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(x);\n# endif\n#elif defined(_WIN64)\n  _BitScanReverse64(&up, x);\n#else\n  _BitScanReverse(&up, x);\n#endif\n  return up;\n}\n\ninline uptr LeastSignificantSetBitIndex(uptr x) {\n  CHECK_NE(x, 0U);\n  unsigned long up;\n#if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n# ifdef _WIN64\n  up = __builtin_ctzll(x);\n# else\n  up = __builtin_ctzl(x);\n# endif\n#elif defined(_WIN64)\n  _BitScanForward64(&up, x);\n#else\n  _BitScanForward(&up, x);\n#endif\n  return up;\n}\n\ninline bool IsPowerOfTwo(uptr x) {\n  return (x & (x - 1)) == 0;\n}\n\ninline uptr RoundUpToPowerOfTwo(uptr size) {\n  CHECK(size);\n  if (IsPowerOfTwo(size)) return size;\n\n  uptr up = MostSignificantSetBitIndex(size);\n  CHECK_LT(size, (1ULL << (up + 1)));\n  CHECK_GT(size, (1ULL << up));\n  return 1ULL << (up + 1);\n}\n\ninline uptr RoundUpTo(uptr size, uptr boundary) {\n  RAW_CHECK(IsPowerOfTwo(boundary));\n  return (size + boundary - 1) & ~(boundary - 1);\n}\n\ninline uptr RoundDownTo(uptr x, uptr boundary) {\n  return x & ~(boundary - 1);\n}\n\ninline bool IsAligned(uptr a, uptr alignment) {\n  return (a & (alignment - 1)) == 0;\n}\n\ninline uptr Log2(uptr x) {\n  CHECK(IsPowerOfTwo(x));\n  return LeastSignificantSetBitIndex(x);\n}\n\n// Don't use std::min, std::max or std::swap, to minimize dependency\n// on libstdc++.\ntemplate <class T>\nconstexpr T Min(T a, T b) {\n  return a < b ? a : b;\n}\ntemplate <class T>\nconstexpr T Max(T a, T b) {\n  return a > b ? a : b;\n}\ntemplate<class T> void Swap(T& a, T& b) {\n  T tmp = a;\n  a = b;\n  b = tmp;\n}\n\n// Char handling\ninline bool IsSpace(int c) {\n  return (c == ' ') || (c == '\\n') || (c == '\\t') ||\n         (c == '\\f') || (c == '\\r') || (c == '\\v');\n}\ninline bool IsDigit(int c) {\n  return (c >= '0') && (c <= '9');\n}\ninline int ToLower(int c) {\n  return (c >= 'A' && c <= 'Z') ? (c + 'a' - 'A') : c;\n}\n\n// A low-level vector based on mmap. May incur a significant memory overhead for\n// small vectors.\n// WARNING: The current implementation supports only POD types.\ntemplate<typename T>\nclass InternalMmapVectorNoCtor {\n public:\n  using value_type = T;\n  void Initialize(uptr initial_capacity) {\n    capacity_bytes_ = 0;\n    size_ = 0;\n    data_ = 0;\n    reserve(initial_capacity);\n  }\n  void Destroy() { UnmapOrDie(data_, capacity_bytes_); }\n  T &operator[](uptr i) {\n    CHECK_LT(i, size_);\n    return data_[i];\n  }\n  const T &operator[](uptr i) const {\n    CHECK_LT(i, size_);\n    return data_[i];\n  }\n  void push_back(const T &element) {\n    CHECK_LE(size_, capacity());\n    if (size_ == capacity()) {\n      uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);\n      Realloc(new_capacity);\n    }\n    internal_memcpy(&data_[size_++], &element, sizeof(T));\n  }\n  T &back() {\n    CHECK_GT(size_, 0);\n    return data_[size_ - 1];\n  }\n  void pop_back() {\n    CHECK_GT(size_, 0);\n    size_--;\n  }\n  uptr size() const {\n    return size_;\n  }\n  const T *data() const {\n    return data_;\n  }\n  T *data() {\n    return data_;\n  }\n  uptr capacity() const { return capacity_bytes_ / sizeof(T); }\n  void reserve(uptr new_size) {\n    // Never downsize internal buffer.\n    if (new_size > capacity())\n      Realloc(new_size);\n  }\n  void resize(uptr new_size) {\n    if (new_size > size_) {\n      reserve(new_size);\n      internal_memset(&data_[size_], 0, sizeof(T) * (new_size - size_));\n    }\n    size_ = new_size;\n  }\n\n  void clear() { size_ = 0; }\n  bool empty() const { return size() == 0; }\n\n  const T *begin() const {\n    return data();\n  }\n  T *begin() {\n    return data();\n  }\n  const T *end() const {\n    return data() + size();\n  }\n  T *end() {\n    return data() + size();\n  }\n\n  void swap(InternalMmapVectorNoCtor &other) {\n    Swap(data_, other.data_);\n    Swap(capacity_bytes_, other.capacity_bytes_);\n    Swap(size_, other.size_);\n  }\n\n private:\n  void Realloc(uptr new_capacity) {\n    CHECK_GT(new_capacity, 0);\n    CHECK_LE(size_, new_capacity);\n    uptr new_capacity_bytes =\n        RoundUpTo(new_capacity * sizeof(T), GetPageSizeCached());\n    T *new_data = (T *)MmapOrDie(new_capacity_bytes, \"InternalMmapVector\");\n    internal_memcpy(new_data, data_, size_ * sizeof(T));\n    UnmapOrDie(data_, capacity_bytes_);\n    data_ = new_data;\n    capacity_bytes_ = new_capacity_bytes;\n  }\n\n  T *data_;\n  uptr capacity_bytes_;\n  uptr size_;\n};\n\ntemplate <typename T>\nbool operator==(const InternalMmapVectorNoCtor<T> &lhs,\n                const InternalMmapVectorNoCtor<T> &rhs) {\n  if (lhs.size() != rhs.size()) return false;\n  return internal_memcmp(lhs.data(), rhs.data(), lhs.size() * sizeof(T)) == 0;\n}\n\ntemplate <typename T>\nbool operator!=(const InternalMmapVectorNoCtor<T> &lhs,\n                const InternalMmapVectorNoCtor<T> &rhs) {\n  return !(lhs == rhs);\n}\n\ntemplate<typename T>\nclass InternalMmapVector : public InternalMmapVectorNoCtor<T> {\n public:\n  InternalMmapVector() { InternalMmapVectorNoCtor<T>::Initialize(0); }\n  explicit InternalMmapVector(uptr cnt) {\n    InternalMmapVectorNoCtor<T>::Initialize(cnt);\n    this->resize(cnt);\n  }\n  ~InternalMmapVector() { InternalMmapVectorNoCtor<T>::Destroy(); }\n  // Disallow copies and moves.\n  InternalMmapVector(const InternalMmapVector &) = delete;\n  InternalMmapVector &operator=(const InternalMmapVector &) = delete;\n  InternalMmapVector(InternalMmapVector &&) = delete;\n  InternalMmapVector &operator=(InternalMmapVector &&) = delete;\n};\n\nclass InternalScopedString {\n public:\n  InternalScopedString() : buffer_(1) { buffer_[0] = '\\0'; }\n\n  uptr length() const { return buffer_.size() - 1; }\n  void clear() {\n    buffer_.resize(1);\n    buffer_[0] = '\\0';\n  }\n  void append(const char *format, ...);\n  const char *data() const { return buffer_.data(); }\n  char *data() { return buffer_.data(); }\n\n private:\n  InternalMmapVector<char> buffer_;\n};\n\ntemplate <class T>\nstruct CompareLess {\n  bool operator()(const T &a, const T &b) const { return a < b; }\n};\n\n// HeapSort for arrays and InternalMmapVector.\ntemplate <class T, class Compare = CompareLess<T>>\nvoid Sort(T *v, uptr size, Compare comp = {}) {\n  if (size < 2)\n    return;\n  // Stage 1: insert elements to the heap.\n  for (uptr i = 1; i < size; i++) {\n    uptr j, p;\n    for (j = i; j > 0; j = p) {\n      p = (j - 1) / 2;\n      if (comp(v[p], v[j]))\n        Swap(v[j], v[p]);\n      else\n        break;\n    }\n  }\n  // Stage 2: swap largest element with the last one,\n  // and sink the new top.\n  for (uptr i = size - 1; i > 0; i--) {\n    Swap(v[0], v[i]);\n    uptr j, max_ind;\n    for (j = 0; j < i; j = max_ind) {\n      uptr left = 2 * j + 1;\n      uptr right = 2 * j + 2;\n      max_ind = j;\n      if (left < i && comp(v[max_ind], v[left]))\n        max_ind = left;\n      if (right < i && comp(v[max_ind], v[right]))\n        max_ind = right;\n      if (max_ind != j)\n        Swap(v[j], v[max_ind]);\n      else\n        break;\n    }\n  }\n}\n\n// Works like std::lower_bound: finds the first element that is not less\n// than the val.\ntemplate <class Container,\n          class Compare = CompareLess<typename Container::value_type>>\nuptr InternalLowerBound(const Container &v,\n                        const typename Container::value_type &val,\n                        Compare comp = {}) {\n  uptr first = 0;\n  uptr last = v.size();\n  while (last > first) {\n    uptr mid = (first + last) / 2;\n    if (comp(v[mid], val))\n      first = mid + 1;\n    else\n      last = mid;\n  }\n  return first;\n}\n\nenum ModuleArch {\n  kModuleArchUnknown,\n  kModuleArchI386,\n  kModuleArchX86_64,\n  kModuleArchX86_64H,\n  kModuleArchARMV6,\n  kModuleArchARMV7,\n  kModuleArchARMV7S,\n  kModuleArchARMV7K,\n  kModuleArchARM64,\n  kModuleArchRISCV64\n};\n\n// Sorts and removes duplicates from the container.\ntemplate <class Container,\n          class Compare = CompareLess<typename Container::value_type>>\nvoid SortAndDedup(Container &v, Compare comp = {}) {\n  Sort(v.data(), v.size(), comp);\n  uptr size = v.size();\n  if (size < 2)\n    return;\n  uptr last = 0;\n  for (uptr i = 1; i < size; ++i) {\n    if (comp(v[last], v[i])) {\n      ++last;\n      if (last != i)\n        v[last] = v[i];\n    } else {\n      CHECK(!comp(v[i], v[last]));\n    }\n  }\n  v.resize(last + 1);\n}\n\n// Opens the file 'file_name\" and reads up to 'max_len' bytes.\n// The resulting buffer is mmaped and stored in '*buff'.\n// Returns true if file was successfully opened and read.\nbool ReadFileToVector(const char *file_name,\n                      InternalMmapVectorNoCtor<char> *buff,\n                      uptr max_len = 1 << 26, error_t *errno_p = nullptr);\n\n// Opens the file 'file_name\" and reads up to 'max_len' bytes.\n// This function is less I/O efficient than ReadFileToVector as it may reread\n// file multiple times to avoid mmap during read attempts. It's used to read\n// procmap, so short reads with mmap in between can produce inconsistent result.\n// The resulting buffer is mmaped and stored in '*buff'.\n// The size of the mmaped region is stored in '*buff_size'.\n// The total number of read bytes is stored in '*read_len'.\n// Returns true if file was successfully opened and read.\nbool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n                      uptr *read_len, uptr max_len = 1 << 26,\n                      error_t *errno_p = nullptr);\n\n// When adding a new architecture, don't forget to also update\n// script/asan_symbolize.py and sanitizer_symbolizer_libcdep.cpp.\ninline const char *ModuleArchToString(ModuleArch arch) {\n  switch (arch) {\n    case kModuleArchUnknown:\n      return \"\";\n    case kModuleArchI386:\n      return \"i386\";\n    case kModuleArchX86_64:\n      return \"x86_64\";\n    case kModuleArchX86_64H:\n      return \"x86_64h\";\n    case kModuleArchARMV6:\n      return \"armv6\";\n    case kModuleArchARMV7:\n      return \"armv7\";\n    case kModuleArchARMV7S:\n      return \"armv7s\";\n    case kModuleArchARMV7K:\n      return \"armv7k\";\n    case kModuleArchARM64:\n      return \"arm64\";\n    case kModuleArchRISCV64:\n      return \"riscv64\";\n  }\n  CHECK(0 && \"Invalid module arch\");\n  return \"\";\n}\n\nconst uptr kModuleUUIDSize = 16;\nconst uptr kMaxSegName = 16;\n\n// Represents a binary loaded into virtual memory (e.g. this can be an\n// executable or a shared object).\nclass LoadedModule {\n public:\n  LoadedModule()\n      : full_name_(nullptr),\n        base_address_(0),\n        max_executable_address_(0),\n        arch_(kModuleArchUnknown),\n        instrumented_(false) {\n    internal_memset(uuid_, 0, kModuleUUIDSize);\n    ranges_.clear();\n  }\n  void set(const char *module_name, uptr base_address);\n  void set(const char *module_name, uptr base_address, ModuleArch arch,\n           u8 uuid[kModuleUUIDSize], bool instrumented);\n  void clear();\n  void addAddressRange(uptr beg, uptr end, bool executable, bool writable,\n                       const char *name = nullptr);\n  bool containsAddress(uptr address) const;\n\n  const char *full_name() const { return full_name_; }\n  uptr base_address() const { return base_address_; }\n  uptr max_executable_address() const { return max_executable_address_; }\n  ModuleArch arch() const { return arch_; }\n  const u8 *uuid() const { return uuid_; }\n  bool instrumented() const { return instrumented_; }\n\n  struct AddressRange {\n    AddressRange *next;\n    uptr beg;\n    uptr end;\n    bool executable;\n    bool writable;\n    char name[kMaxSegName];\n\n    AddressRange(uptr beg, uptr end, bool executable, bool writable,\n                 const char *name)\n        : next(nullptr),\n          beg(beg),\n          end(end),\n          executable(executable),\n          writable(writable) {\n      internal_strncpy(this->name, (name ? name : \"\"), ARRAY_SIZE(this->name));\n    }\n  };\n\n  const IntrusiveList<AddressRange> &ranges() const { return ranges_; }\n\n private:\n  char *full_name_;  // Owned.\n  uptr base_address_;\n  uptr max_executable_address_;\n  ModuleArch arch_;\n  u8 uuid_[kModuleUUIDSize];\n  bool instrumented_;\n  IntrusiveList<AddressRange> ranges_;\n};\n\n// List of LoadedModules. OS-dependent implementation is responsible for\n// filling this information.\nclass ListOfModules {\n public:\n  ListOfModules() : initialized(false) {}\n  ~ListOfModules() { clear(); }\n  void init();\n  void fallbackInit();  // Uses fallback init if available, otherwise clears\n  const LoadedModule *begin() const { return modules_.begin(); }\n  LoadedModule *begin() { return modules_.begin(); }\n  const LoadedModule *end() const { return modules_.end(); }\n  LoadedModule *end() { return modules_.end(); }\n  uptr size() const { return modules_.size(); }\n  const LoadedModule &operator[](uptr i) const {\n    CHECK_LT(i, modules_.size());\n    return modules_[i];\n  }\n\n private:\n  void clear() {\n    for (auto &module : modules_) module.clear();\n    modules_.clear();\n  }\n  void clearOrInit() {\n    initialized ? clear() : modules_.Initialize(kInitialCapacity);\n    initialized = true;\n  }\n\n  InternalMmapVectorNoCtor<LoadedModule> modules_;\n  // We rarely have more than 16K loaded modules.\n  static const uptr kInitialCapacity = 1 << 14;\n  bool initialized;\n};\n\n// Callback type for iterating over a set of memory ranges.\ntypedef void (*RangeIteratorCallback)(uptr begin, uptr end, void *arg);\n\nenum AndroidApiLevel {\n  ANDROID_NOT_ANDROID = 0,\n  ANDROID_KITKAT = 19,\n  ANDROID_LOLLIPOP_MR1 = 22,\n  ANDROID_POST_LOLLIPOP = 23\n};\n\nvoid WriteToSyslog(const char *buffer);\n\n#if defined(SANITIZER_WINDOWS) && defined(_MSC_VER) && !defined(__clang__)\n#define SANITIZER_WIN_TRACE 1\n#else\n#define SANITIZER_WIN_TRACE 0\n#endif\n\n#if SANITIZER_MAC || SANITIZER_WIN_TRACE\nvoid LogFullErrorReport(const char *buffer);\n#else\ninline void LogFullErrorReport(const char *buffer) {}\n#endif\n\n#if SANITIZER_LINUX || SANITIZER_MAC\nvoid WriteOneLineToSyslog(const char *s);\nvoid LogMessageOnPrintf(const char *str);\n#else\ninline void WriteOneLineToSyslog(const char *s) {}\ninline void LogMessageOnPrintf(const char *str) {}\n#endif\n\n#if SANITIZER_LINUX || SANITIZER_WIN_TRACE\n// Initialize Android logging. Any writes before this are silently lost.\nvoid AndroidLogInit();\nvoid SetAbortMessage(const char *);\n#else\ninline void AndroidLogInit() {}\n// FIXME: MacOS implementation could use CRSetCrashLogMessage.\ninline void SetAbortMessage(const char *) {}\n#endif\n\n#if SANITIZER_ANDROID\nvoid SanitizerInitializeUnwinder();\nAndroidApiLevel AndroidGetApiLevel();\n#else\ninline void AndroidLogWrite(const char *buffer_unused) {}\ninline void SanitizerInitializeUnwinder() {}\ninline AndroidApiLevel AndroidGetApiLevel() { return ANDROID_NOT_ANDROID; }\n#endif\n\ninline uptr GetPthreadDestructorIterations() {\n#if SANITIZER_ANDROID\n  return (AndroidGetApiLevel() == ANDROID_LOLLIPOP_MR1) ? 8 : 4;\n#elif SANITIZER_POSIX\n  return 4;\n#else\n// Unused on Windows.\n  return 0;\n#endif\n}\n\nvoid *internal_start_thread(void *(*func)(void*), void *arg);\nvoid internal_join_thread(void *th);\nvoid MaybeStartBackgroudThread();\n\n// Make the compiler think that something is going on there.\n// Use this inside a loop that looks like memset/memcpy/etc to prevent the\n// compiler from recognising it and turning it into an actual call to\n// memset/memcpy/etc.\nstatic inline void SanitizerBreakOptimization(void *arg) {\n#if defined(_MSC_VER) && !defined(__clang__)\n  _ReadWriteBarrier();\n#else\n  __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n#endif\n}\n\nstruct SignalContext {\n  void *siginfo;\n  void *context;\n  uptr addr;\n  uptr pc;\n  uptr sp;\n  uptr bp;\n  bool is_memory_access;\n  enum WriteFlag { UNKNOWN, READ, WRITE } write_flag;\n\n  // In some cases the kernel cannot provide the true faulting address; `addr`\n  // will be zero then.  This field allows to distinguish between these cases\n  // and dereferences of null.\n  bool is_true_faulting_addr;\n\n  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n  // constructor\n  SignalContext() = default;\n\n  // Creates signal context in a platform-specific manner.\n  // SignalContext is going to keep pointers to siginfo and context without\n  // owning them.\n  SignalContext(void *siginfo, void *context)\n      : siginfo(siginfo),\n        context(context),\n        addr(GetAddress()),\n        is_memory_access(IsMemoryAccess()),\n        write_flag(GetWriteFlag()),\n        is_true_faulting_addr(IsTrueFaultingAddress()) {\n    InitPcSpBp();\n  }\n\n  static void DumpAllRegisters(void *context);\n\n  // Type of signal e.g. SIGSEGV or EXCEPTION_ACCESS_VIOLATION.\n  int GetType() const;\n\n  // String description of the signal.\n  const char *Describe() const;\n\n  // Returns true if signal is stack overflow.\n  bool IsStackOverflow() const;\n\n private:\n  // Platform specific initialization.\n  void InitPcSpBp();\n  uptr GetAddress() const;\n  WriteFlag GetWriteFlag() const;\n  bool IsMemoryAccess() const;\n  bool IsTrueFaultingAddress() const;\n};\n\nvoid InitializePlatformEarly();\nvoid MaybeReexec();\n\ntemplate <typename Fn>\nclass RunOnDestruction {\n public:\n  explicit RunOnDestruction(Fn fn) : fn_(fn) {}\n  ~RunOnDestruction() { fn_(); }\n\n private:\n  Fn fn_;\n};\n\n// A simple scope guard. Usage:\n// auto cleanup = at_scope_exit([]{ do_cleanup; });\ntemplate <typename Fn>\nRunOnDestruction<Fn> at_scope_exit(Fn fn) {\n  return RunOnDestruction<Fn>(fn);\n}\n\n// Linux on 64-bit s390 had a nasty bug that crashes the whole machine\n// if a process uses virtual memory over 4TB (as many sanitizers like\n// to do).  This function will abort the process if running on a kernel\n// that looks vulnerable.\n#if SANITIZER_LINUX && SANITIZER_S390_64\nvoid AvoidCVE_2016_2143();\n#else\ninline void AvoidCVE_2016_2143() {}\n#endif\n\nstruct StackDepotStats {\n  uptr n_uniq_ids;\n  uptr allocated;\n};\n\n// The default value for allocator_release_to_os_interval_ms common flag to\n// indicate that sanitizer allocator should not attempt to release memory to OS.\nconst s32 kReleaseToOSIntervalNever = -1;\n\nvoid CheckNoDeepBind(const char *filename, int flag);\n\n// Returns the requested amount of random data (up to 256 bytes) that can then\n// be used to seed a PRNG. Defaults to blocking like the underlying syscall.\nbool GetRandom(void *buffer, uptr length, bool blocking = true);\n\n// Returns the number of logical processors on the system.\nu32 GetNumberOfCPUs();\nextern u32 NumberOfCPUsCached;\ninline u32 GetNumberOfCPUsCached() {\n  if (!NumberOfCPUsCached)\n    NumberOfCPUsCached = GetNumberOfCPUs();\n  return NumberOfCPUsCached;\n}\n\ntemplate <typename T>\nclass ArrayRef {\n public:\n  ArrayRef() {}\n  ArrayRef(T *begin, T *end) : begin_(begin), end_(end) {}\n\n  T *begin() { return begin_; }\n  T *end() { return end_; }\n\n private:\n  T *begin_ = nullptr;\n  T *end_ = nullptr;\n};\n\n}  // namespace __sanitizer\n\ninline void *operator new(__sanitizer::operator_new_size_type size,\n                          __sanitizer::LowLevelAllocator &alloc) {  // NOLINT\n  return alloc.Allocate(size);\n}\n\n#endif  // SANITIZER_COMMON_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_flags.h", "content": "//===-- sanitizer_flags.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_FLAGS_H\n#define SANITIZER_FLAGS_H\n\n#include \"sanitizer_internal_defs.h\"\n\nnamespace __sanitizer {\n\nenum HandleSignalMode {\n  kHandleSignalNo,\n  kHandleSignalYes,\n  kHandleSignalExclusive,\n};\n\nstruct CommonFlags {\n#define COMMON_FLAG(Type, Name, DefaultValue, Description) Type Name;\n#include \"sanitizer_flags.inc\"\n#undef COMMON_FLAG\n\n  void SetDefaults();\n  void CopyFrom(const CommonFlags &other);\n};\n\n// Functions to get/set global CommonFlags shared by all sanitizer runtimes:\nextern CommonFlags common_flags_dont_use;\ninline const CommonFlags *common_flags() {\n  return &common_flags_dont_use;\n}\n\ninline void SetCommonFlagsDefaults() {\n  common_flags_dont_use.SetDefaults();\n}\n\n// This function can only be used to setup tool-specific overrides for\n// CommonFlags defaults. Generally, it should only be used right after\n// SetCommonFlagsDefaults(), but before ParseCommonFlagsFromString(), and\n// only during the flags initialization (i.e. before they are used for\n// the first time).\ninline void OverrideCommonFlags(const CommonFlags &cf) {\n  common_flags_dont_use.CopyFrom(cf);\n}\n\nvoid SubstituteForFlagValue(const char *s, char *out, uptr out_size);\n\nclass FlagParser;\nvoid RegisterCommonFlags(FlagParser *parser,\n                         CommonFlags *cf = &common_flags_dont_use);\nvoid RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf);\n\n// Should be called after parsing all flags. Sets up common flag values\n// and perform initializations common to all sanitizers (e.g. setting\n// verbosity).\nvoid InitializeCommonFlags(CommonFlags *cf = &common_flags_dont_use);\n\n// Platform specific flags initialization.\nvoid InitializePlatformCommonFlags(CommonFlags *cf);\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_FLAGS_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_fuchsia.h", "content": "//===-- sanitizer_fuchsia.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===---------------------------------------------------------------------===//\n//\n// Fuchsia-specific sanitizer support.\n//\n//===---------------------------------------------------------------------===//\n#ifndef SANITIZER_FUCHSIA_H\n#define SANITIZER_FUCHSIA_H\n\n#include \"sanitizer_platform.h\"\n#if SANITIZER_FUCHSIA\n\n#include \"sanitizer_common.h\"\n\n#include <zircon/sanitizer.h>\n#include <zircon/syscalls/object.h>\n\nnamespace __sanitizer {\n\nextern uptr MainThreadStackBase, MainThreadStackSize;\nextern sanitizer_shadow_bounds_t ShadowBounds;\n\nstruct MemoryMappingLayoutData {\n  InternalMmapVector<zx_info_maps_t> data;\n  size_t current;  // Current index into the vector.\n};\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_FUCHSIA\n#endif  // SANITIZER_FUCHSIA_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_interface_internal.h", "content": "//===-- sanitizer_interface_internal.h --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between run-time libraries of sanitizers.\n//\n// This header declares the sanitizer runtime interface functions.\n// The runtime library has to define these functions so the instrumented program\n// could call them.\n//\n// See also include/sanitizer/common_interface_defs.h\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_INTERFACE_INTERNAL_H\n#define SANITIZER_INTERFACE_INTERNAL_H\n\n#include \"sanitizer_internal_defs.h\"\n\nextern \"C\" {\n  // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n  // The special values are \"stdout\" and \"stderr\".\n  SANITIZER_INTERFACE_ATTRIBUTE\n  void __sanitizer_set_report_path(const char *path);\n  // Tell the tools to write their reports to the provided file descriptor\n  // (casted to void *).\n  SANITIZER_INTERFACE_ATTRIBUTE\n  void __sanitizer_set_report_fd(void *fd);\n  // Get the current full report file path, if a path was specified by\n  // an earlier call to __sanitizer_set_report_path. Returns null otherwise.\n  SANITIZER_INTERFACE_ATTRIBUTE\n  const char *__sanitizer_get_report_path();\n\n  typedef struct {\n      int coverage_sandboxed;\n      __sanitizer::sptr coverage_fd;\n      unsigned int coverage_max_block_size;\n  } __sanitizer_sandbox_arguments;\n\n  // Notify the tools that the sandbox is going to be turned on.\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n      __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);\n\n  // This function is called by the tool when it has just finished reporting\n  // an error. 'error_summary' is a one-line string that summarizes\n  // the error message. This function can be overridden by the client.\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_report_error_summary(const char *error_summary);\n\n  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump();\n  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_coverage(\n      const __sanitizer::uptr *pcs, const __sanitizer::uptr len);\n  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_dump_trace_pc_guard_coverage();\n\n  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(__sanitizer::u32 *guard);\n\n  // Returns 1 on the first call, then returns 0 thereafter.  Called by the tool\n  // to ensure only one report is printed when multiple errors occur\n  // simultaneously.\n  SANITIZER_INTERFACE_ATTRIBUTE int __sanitizer_acquire_crash_state();\n\n  SANITIZER_INTERFACE_ATTRIBUTE\n  void __sanitizer_annotate_contiguous_container(const void *beg,\n                                                 const void *end,\n                                                 const void *old_mid,\n                                                 const void *new_mid);\n  SANITIZER_INTERFACE_ATTRIBUTE\n  int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n                                              const void *end);\n  SANITIZER_INTERFACE_ATTRIBUTE\n  const void *__sanitizer_contiguous_container_find_bad_address(\n      const void *beg, const void *mid, const void *end);\n\n  SANITIZER_INTERFACE_ATTRIBUTE\n  int __sanitizer_get_module_and_offset_for_pc(\n      __sanitizer::uptr pc, char *module_path,\n      __sanitizer::uptr module_path_len, __sanitizer::uptr *pc_offset);\n\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_cmp();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_cmp1();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_cmp2();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_cmp4();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_cmp8();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_const_cmp1();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_const_cmp2();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_const_cmp4();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_const_cmp8();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_switch();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_div4();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_div8();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_gep();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_pc_indir();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_pc_guard(__sanitizer::u32*);\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_trace_pc_guard_init(__sanitizer::u32*,\n                                           __sanitizer::u32*);\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n  void __sanitizer_cov_8bit_counters_init();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n  __sanitizer_cov_bool_flag_init();\n  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE void\n  __sanitizer_cov_pcs_init();\n} // extern \"C\"\n\n#endif  // SANITIZER_INTERFACE_INTERNAL_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_internal_defs.h", "content": "//===-- sanitizer_internal_defs.h -------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between AddressSanitizer and ThreadSanitizer.\n// It contains macro used in run-time libraries code.\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_DEFS_H\n#define SANITIZER_DEFS_H\n\n#include \"sanitizer_platform.h\"\n\n#ifndef SANITIZER_DEBUG\n# define SANITIZER_DEBUG 0\n#endif\n\n#define SANITIZER_STRINGIFY_(S) #S\n#define SANITIZER_STRINGIFY(S) SANITIZER_STRINGIFY_(S)\n\n// Only use SANITIZER_*ATTRIBUTE* before the function return type!\n#if SANITIZER_WINDOWS\n#if SANITIZER_IMPORT_INTERFACE\n# define SANITIZER_INTERFACE_ATTRIBUTE __declspec(dllimport)\n#else\n# define SANITIZER_INTERFACE_ATTRIBUTE __declspec(dllexport)\n#endif\n# define SANITIZER_WEAK_ATTRIBUTE\n#elif SANITIZER_GO\n# define SANITIZER_INTERFACE_ATTRIBUTE\n# define SANITIZER_WEAK_ATTRIBUTE\n#else\n# define SANITIZER_INTERFACE_ATTRIBUTE __attribute__((visibility(\"default\")))\n# define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n#endif\n\n// TLS is handled differently on different platforms\n#if SANITIZER_LINUX || SANITIZER_NETBSD || \\\n  SANITIZER_FREEBSD\n# define SANITIZER_TLS_INITIAL_EXEC_ATTRIBUTE \\\n    __attribute__((tls_model(\"initial-exec\"))) thread_local\n#else\n# define SANITIZER_TLS_INITIAL_EXEC_ATTRIBUTE\n#endif\n\n//--------------------------- WEAK FUNCTIONS ---------------------------------//\n// When working with weak functions, to simplify the code and make it more\n// portable, when possible define a default implementation using this macro:\n//\n// SANITIZER_INTERFACE_WEAK_DEF(<return_type>, <name>, <parameter list>)\n//\n// For example:\n//   SANITIZER_INTERFACE_WEAK_DEF(bool, compare, int a, int b) { return a > b; }\n//\n#if SANITIZER_WINDOWS\n#include \"sanitizer_win_defs.h\"\n# define SANITIZER_INTERFACE_WEAK_DEF(ReturnType, Name, ...)                   \\\n  WIN_WEAK_EXPORT_DEF(ReturnType, Name, __VA_ARGS__)\n#else\n# define SANITIZER_INTERFACE_WEAK_DEF(ReturnType, Name, ...)                   \\\n  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE            \\\n  ReturnType Name(__VA_ARGS__)\n#endif\n\n// SANITIZER_SUPPORTS_WEAK_HOOKS means that we support real weak functions that\n// will evaluate to a null pointer when not defined.\n#ifndef SANITIZER_SUPPORTS_WEAK_HOOKS\n#if (SANITIZER_LINUX || SANITIZER_SOLARIS) && !SANITIZER_GO\n# define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n// Before Xcode 4.5, the Darwin linker doesn't reliably support undefined\n// weak symbols.  Mac OS X 10.9/Darwin 13 is the first release only supported\n// by Xcode >= 4.5.\n#elif SANITIZER_MAC && \\\n    __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090 && !SANITIZER_GO\n# define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n#else\n# define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n#endif\n#endif // SANITIZER_SUPPORTS_WEAK_HOOKS\n// For some weak hooks that will be called very often and we want to avoid the\n// overhead of executing the default implementation when it is not necessary,\n// we can use the flag SANITIZER_SUPPORTS_WEAK_HOOKS to only define the default\n// implementation for platforms that doesn't support weak symbols. For example:\n//\n//   #if !SANITIZER_SUPPORT_WEAK_HOOKS\n//     SANITIZER_INTERFACE_WEAK_DEF(bool, compare_hook, int a, int b) {\n//       return a > b;\n//     }\n//   #endif\n//\n// And then use it as: if (compare_hook) compare_hook(a, b);\n//----------------------------------------------------------------------------//\n\n\n// We can use .preinit_array section on Linux to call sanitizer initialization\n// functions very early in the process startup (unless PIC macro is defined).\n//\n// On FreeBSD, .preinit_array functions are called with rtld_bind_lock writer\n// lock held. It will lead to dead lock if unresolved PLT functions (which helds\n// rtld_bind_lock reader lock) are called inside .preinit_array functions.\n//\n// FIXME: do we have anything like this on Mac?\n#ifndef SANITIZER_CAN_USE_PREINIT_ARRAY\n#if (SANITIZER_LINUX || SANITIZER_FUCHSIA || SANITIZER_NETBSD) && !defined(PIC)\n#define SANITIZER_CAN_USE_PREINIT_ARRAY 1\n// Before Solaris 11.4, .preinit_array is fully supported only with GNU ld.\n// FIXME: Check for those conditions.\n#elif SANITIZER_SOLARIS && !defined(PIC)\n# define SANITIZER_CAN_USE_PREINIT_ARRAY 1\n#else\n# define SANITIZER_CAN_USE_PREINIT_ARRAY 0\n#endif\n#endif  // SANITIZER_CAN_USE_PREINIT_ARRAY\n\n// GCC does not understand __has_feature\n#if !defined(__has_feature)\n# define __has_feature(x) 0\n#endif\n\n// Older GCCs do not understand __has_attribute.\n#if !defined(__has_attribute)\n# define __has_attribute(x) 0\n#endif\n\n// For portability reasons we do not include stddef.h, stdint.h or any other\n// system header, but we do need some basic types that are not defined\n// in a portable way by the language itself.\nnamespace __sanitizer {\n\n#if defined(_WIN64)\n// 64-bit Windows uses LLP64 data model.\ntypedef unsigned long long uptr;\ntypedef signed long long sptr;\n#else\ntypedef unsigned long uptr;\ntypedef signed long sptr;\n#endif  // defined(_WIN64)\n#if defined(__x86_64__)\n// Since x32 uses ILP32 data model in 64-bit hardware mode, we must use\n// 64-bit pointer to unwind stack frame.\ntypedef unsigned long long uhwptr;\n#else\ntypedef uptr uhwptr;\n#endif\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef signed char s8;\ntypedef signed short s16;\ntypedef signed int s32;\ntypedef signed long long s64;\n#if SANITIZER_WINDOWS\n// On Windows, files are HANDLE, which is a synonim of void*.\n// Use void* to avoid including <windows.h> everywhere.\ntypedef void* fd_t;\ntypedef unsigned error_t;\n#else\ntypedef int fd_t;\ntypedef int error_t;\n#endif\n#if SANITIZER_SOLARIS && !defined(_LP64)\ntypedef long pid_t;\n#else\ntypedef int pid_t;\n#endif\n\n#if SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n    SANITIZER_MAC || \\\n    (SANITIZER_SOLARIS && (defined(_LP64) || _FILE_OFFSET_BITS == 64)) || \\\n    (SANITIZER_LINUX && defined(__x86_64__))\ntypedef u64 OFF_T;\n#else\ntypedef uptr OFF_T;\n#endif\ntypedef u64  OFF64_T;\n\n#if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC\ntypedef uptr operator_new_size_type;\n#else\n# if defined(__s390__) && !defined(__s390x__)\n// Special case: 31-bit s390 has unsigned long as size_t.\ntypedef unsigned long operator_new_size_type;\n# else\ntypedef u32 operator_new_size_type;\n# endif\n#endif\n\ntypedef u64 tid_t;\n\n// ----------- ATTENTION -------------\n// This header should NOT include any other headers to avoid portability issues.\n\n// Common defs.\n#define INTERFACE_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n#define SANITIZER_WEAK_DEFAULT_IMPL \\\n  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n#define SANITIZER_WEAK_CXX_DEFAULT_IMPL \\\n  extern \"C++\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n\n// Platform-specific defs.\n#if defined(_MSC_VER)\n# define ALWAYS_INLINE __forceinline\n// FIXME(timurrrr): do we need this on Windows?\n# define ALIAS(x)\n# define ALIGNED(x) __declspec(align(x))\n# define FORMAT(f, a)\n# define NOINLINE __declspec(noinline)\n# define NORETURN __declspec(noreturn)\n# define THREADLOCAL   __declspec(thread)\n# define LIKELY(x) (x)\n# define UNLIKELY(x) (x)\n# define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */ (void)0\n# define WARN_UNUSED_RESULT\n#else  // _MSC_VER\n# define ALWAYS_INLINE inline __attribute__((always_inline))\n# define ALIAS(x) __attribute__((alias(x)))\n// Please only use the ALIGNED macro before the type.\n// Using ALIGNED after the variable declaration is not portable!\n# define ALIGNED(x) __attribute__((aligned(x)))\n# define FORMAT(f, a)  __attribute__((format(printf, f, a)))\n# define NOINLINE __attribute__((noinline))\n# define NORETURN  __attribute__((noreturn))\n# define THREADLOCAL   __thread\n# define LIKELY(x)     __builtin_expect(!!(x), 1)\n# define UNLIKELY(x)   __builtin_expect(!!(x), 0)\n# if defined(__i386__) || defined(__x86_64__)\n// __builtin_prefetch(x) generates prefetchnt0 on x86\n#  define PREFETCH(x) __asm__(\"prefetchnta (%0)\" : : \"r\" (x))\n# else\n#  define PREFETCH(x) __builtin_prefetch(x)\n# endif\n# define WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#endif  // _MSC_VER\n\n#if !defined(_MSC_VER) || defined(__clang__)\n# define UNUSED __attribute__((unused))\n# define USED __attribute__((used))\n#else\n# define UNUSED\n# define USED\n#endif\n\n#if !defined(_MSC_VER) || defined(__clang__) || MSC_PREREQ(1900)\n# define NOEXCEPT noexcept\n#else\n# define NOEXCEPT throw()\n#endif\n\n// Unaligned versions of basic types.\ntypedef ALIGNED(1) u16 uu16;\ntypedef ALIGNED(1) u32 uu32;\ntypedef ALIGNED(1) u64 uu64;\ntypedef ALIGNED(1) s16 us16;\ntypedef ALIGNED(1) s32 us32;\ntypedef ALIGNED(1) s64 us64;\n\n#if SANITIZER_WINDOWS\n}  // namespace __sanitizer\ntypedef unsigned long DWORD;\nnamespace __sanitizer {\ntypedef DWORD thread_return_t;\n# define THREAD_CALLING_CONV __stdcall\n#else  // _WIN32\ntypedef void* thread_return_t;\n# define THREAD_CALLING_CONV\n#endif  // _WIN32\ntypedef thread_return_t (THREAD_CALLING_CONV *thread_callback_t)(void* arg);\n\n// NOTE: Functions below must be defined in each run-time.\nvoid NORETURN Die();\n\nvoid NORETURN CheckFailed(const char *file, int line, const char *cond,\n                          u64 v1, u64 v2);\n\n// Check macro\n#define RAW_CHECK_MSG(expr, msg) do { \\\n  if (UNLIKELY(!(expr))) { \\\n    RawWrite(msg); \\\n    Die(); \\\n  } \\\n} while (0)\n\n#define RAW_CHECK(expr) RAW_CHECK_MSG(expr, #expr)\n\n#define CHECK_IMPL(c1, op, c2) \\\n  do { \\\n    __sanitizer::u64 v1 = (__sanitizer::u64)(c1); \\\n    __sanitizer::u64 v2 = (__sanitizer::u64)(c2); \\\n    if (UNLIKELY(!(v1 op v2))) \\\n      __sanitizer::CheckFailed(__FILE__, __LINE__, \\\n        \"(\" #c1 \") \" #op \" (\" #c2 \")\", v1, v2); \\\n  } while (false) \\\n/**/\n\n#define CHECK(a)       CHECK_IMPL((a), !=, 0)\n#define CHECK_EQ(a, b) CHECK_IMPL((a), ==, (b))\n#define CHECK_NE(a, b) CHECK_IMPL((a), !=, (b))\n#define CHECK_LT(a, b) CHECK_IMPL((a), <,  (b))\n#define CHECK_LE(a, b) CHECK_IMPL((a), <=, (b))\n#define CHECK_GT(a, b) CHECK_IMPL((a), >,  (b))\n#define CHECK_GE(a, b) CHECK_IMPL((a), >=, (b))\n\n#if SANITIZER_DEBUG\n#define DCHECK(a)       CHECK(a)\n#define DCHECK_EQ(a, b) CHECK_EQ(a, b)\n#define DCHECK_NE(a, b) CHECK_NE(a, b)\n#define DCHECK_LT(a, b) CHECK_LT(a, b)\n#define DCHECK_LE(a, b) CHECK_LE(a, b)\n#define DCHECK_GT(a, b) CHECK_GT(a, b)\n#define DCHECK_GE(a, b) CHECK_GE(a, b)\n#else\n#define DCHECK(a)\n#define DCHECK_EQ(a, b)\n#define DCHECK_NE(a, b)\n#define DCHECK_LT(a, b)\n#define DCHECK_LE(a, b)\n#define DCHECK_GT(a, b)\n#define DCHECK_GE(a, b)\n#endif\n\n#define UNREACHABLE(msg) do { \\\n  CHECK(0 && msg); \\\n  Die(); \\\n} while (0)\n\n#define UNIMPLEMENTED() UNREACHABLE(\"unimplemented\")\n\n#define COMPILER_CHECK(pred) static_assert(pred, \"\")\n\n#define ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))\n\n// Limits for integral types. We have to redefine it in case we don't\n// have stdint.h (like in Visual Studio 9).\n#undef __INT64_C\n#undef __UINT64_C\n#if SANITIZER_WORDSIZE == 64\n# define __INT64_C(c)  c ## L\n# define __UINT64_C(c) c ## UL\n#else\n# define __INT64_C(c)  c ## LL\n# define __UINT64_C(c) c ## ULL\n#endif  // SANITIZER_WORDSIZE == 64\n#undef INT32_MIN\n#define INT32_MIN              (-2147483647-1)\n#undef INT32_MAX\n#define INT32_MAX              (2147483647)\n#undef UINT32_MAX\n#define UINT32_MAX             (4294967295U)\n#undef INT64_MIN\n#define INT64_MIN              (-__INT64_C(9223372036854775807)-1)\n#undef INT64_MAX\n#define INT64_MAX              (__INT64_C(9223372036854775807))\n#undef UINT64_MAX\n#define UINT64_MAX             (__UINT64_C(18446744073709551615))\n#undef UINTPTR_MAX\n#if SANITIZER_WORDSIZE == 64\n# define UINTPTR_MAX           (18446744073709551615UL)\n#else\n# define UINTPTR_MAX           (4294967295U)\n#endif  // SANITIZER_WORDSIZE == 64\n\nenum LinkerInitialized { LINKER_INITIALIZED = 0 };\n\n#if !defined(_MSC_VER) || defined(__clang__)\n#if SANITIZER_S390_31\n#define GET_CALLER_PC() \\\n  (__sanitizer::uptr) __builtin_extract_return_addr(__builtin_return_address(0))\n#else\n#define GET_CALLER_PC() (__sanitizer::uptr) __builtin_return_address(0)\n#endif\n#define GET_CURRENT_FRAME() (__sanitizer::uptr) __builtin_frame_address(0)\ninline void Trap() {\n  __builtin_trap();\n}\n#else\nextern \"C\" void* _ReturnAddress(void);\nextern \"C\" void* _AddressOfReturnAddress(void);\n# pragma intrinsic(_ReturnAddress)\n# pragma intrinsic(_AddressOfReturnAddress)\n#define GET_CALLER_PC() (__sanitizer::uptr) _ReturnAddress()\n// CaptureStackBackTrace doesn't need to know BP on Windows.\n#define GET_CURRENT_FRAME() \\\n  (((__sanitizer::uptr)_AddressOfReturnAddress()) + sizeof(__sanitizer::uptr))\n\nextern \"C\" void __ud2(void);\n# pragma intrinsic(__ud2)\ninline void Trap() {\n  __ud2();\n}\n#endif\n\n#define HANDLE_EINTR(res, f)                                       \\\n  {                                                                \\\n    int rverrno;                                                   \\\n    do {                                                           \\\n      res = (f);                                                   \\\n    } while (internal_iserror(res, &rverrno) && rverrno == EINTR); \\\n  }\n\n// Forces the compiler to generate a frame pointer in the function.\n#define ENABLE_FRAME_POINTER              \\\n  do {                                    \\\n    volatile __sanitizer::uptr enable_fp; \\\n    enable_fp = GET_CURRENT_FRAME();      \\\n    (void)enable_fp;                      \\\n  } while (0)\n\n}  // namespace __sanitizer\n\nnamespace __asan {\nusing namespace __sanitizer;\n}\nnamespace __dsan {\nusing namespace __sanitizer;\n}\nnamespace __dfsan {\nusing namespace __sanitizer;\n}\nnamespace __lsan {\nusing namespace __sanitizer;\n}\nnamespace __msan {\nusing namespace __sanitizer;\n}\nnamespace __hwasan {\nusing namespace __sanitizer;\n}\nnamespace __tsan {\nusing namespace __sanitizer;\n}\nnamespace __scudo {\nusing namespace __sanitizer;\n}\nnamespace __ubsan {\nusing namespace __sanitizer;\n}\nnamespace __xray {\nusing namespace __sanitizer;\n}\nnamespace __interception {\nusing namespace __sanitizer;\n}\nnamespace __hwasan {\nusing namespace __sanitizer;\n}\nnamespace __memprof {\nusing namespace __sanitizer;\n}\n\n#endif  // SANITIZER_DEFS_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_libc.h", "content": "//===-- sanitizer_libc.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between AddressSanitizer and ThreadSanitizer\n// run-time libraries.\n// These tools can not use some of the libc functions directly because those\n// functions are intercepted. Instead, we implement a tiny subset of libc here.\n// FIXME: Some of functions declared in this file are in fact POSIX, not libc.\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_LIBC_H\n#define SANITIZER_LIBC_H\n\n// ----------- ATTENTION -------------\n// This header should NOT include any other headers from sanitizer runtime.\n#include \"sanitizer_internal_defs.h\"\n\nnamespace __sanitizer {\n\n// internal_X() is a custom implementation of X() for use in RTL.\n\n// String functions\ns64 internal_atoll(const char *nptr);\nvoid *internal_memchr(const void *s, int c, uptr n);\nvoid *internal_memrchr(const void *s, int c, uptr n);\nint internal_memcmp(const void* s1, const void* s2, uptr n);\nvoid *internal_memcpy(void *dest, const void *src, uptr n);\nvoid *internal_memmove(void *dest, const void *src, uptr n);\n// Should not be used in performance-critical places.\nvoid *internal_memset(void *s, int c, uptr n);\nchar* internal_strchr(const char *s, int c);\nchar *internal_strchrnul(const char *s, int c);\nint internal_strcmp(const char *s1, const char *s2);\nuptr internal_strcspn(const char *s, const char *reject);\nchar *internal_strdup(const char *s);\nuptr internal_strlen(const char *s);\nuptr internal_strlcat(char *dst, const char *src, uptr maxlen);\nchar *internal_strncat(char *dst, const char *src, uptr n);\nint internal_strncmp(const char *s1, const char *s2, uptr n);\nuptr internal_strlcpy(char *dst, const char *src, uptr maxlen);\nchar *internal_strncpy(char *dst, const char *src, uptr n);\nuptr internal_strnlen(const char *s, uptr maxlen);\nchar *internal_strrchr(const char *s, int c);\nchar *internal_strstr(const char *haystack, const char *needle);\n// Works only for base=10 and doesn't set errno.\ns64 internal_simple_strtoll(const char *nptr, const char **endptr, int base);\nint internal_snprintf(char *buffer, uptr length, const char *format, ...);\n\n// Return true if all bytes in [mem, mem+size) are zero.\n// Optimized for the case when the result is true.\nbool mem_is_zero(const char *mem, uptr size);\n\n// I/O\n// Define these as macros so we can use them in linker initialized global\n// structs without dynamic initialization.\n#define kInvalidFd ((fd_t)-1)\n#define kStdinFd ((fd_t)0)\n#define kStdoutFd ((fd_t)1)\n#define kStderrFd ((fd_t)2)\n\nuptr internal_ftruncate(fd_t fd, uptr size);\n\n// OS\nvoid NORETURN internal__exit(int exitcode);\nunsigned int internal_sleep(unsigned int seconds);\n\nuptr internal_getpid();\nuptr internal_getppid();\n\nint internal_dlinfo(void *handle, int request, void *p);\n\n// Threading\nuptr internal_sched_yield();\n\n// Error handling\nbool internal_iserror(uptr retval, int *rverrno = nullptr);\n\n} // namespace __sanitizer\n\n#endif // SANITIZER_LIBC_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_linux.h", "content": "//===-- sanitizer_linux.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Linux-specific syscall wrappers and classes.\n//\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_LINUX_H\n#define SANITIZER_LINUX_H\n\n#include \"sanitizer_platform.h\"\n#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD ||                \\\n    SANITIZER_SOLARIS\n#include \"sanitizer_common.h\"\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_platform_limits_freebsd.h\"\n#include \"sanitizer_platform_limits_netbsd.h\"\n#include \"sanitizer_platform_limits_posix.h\"\n#include \"sanitizer_platform_limits_solaris.h\"\n#include \"sanitizer_posix.h\"\n\nstruct link_map;  // Opaque type returned by dlopen().\nstruct utsname;\n\nnamespace __sanitizer {\n// Dirent structure for getdents(). Note that this structure is different from\n// the one in <dirent.h>, which is used by readdir().\nstruct linux_dirent;\n\nstruct ProcSelfMapsBuff {\n  char *data;\n  uptr mmaped_size;\n  uptr len;\n};\n\nstruct MemoryMappingLayoutData {\n  ProcSelfMapsBuff proc_self_maps;\n  const char *current;\n};\n\nvoid ReadProcMaps(ProcSelfMapsBuff *proc_maps);\n\n// Syscall wrappers.\nuptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\nuptr internal_sigaltstack(const void* ss, void* oss);\nuptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n    __sanitizer_sigset_t *oldset);\n#if SANITIZER_GLIBC\nuptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp);\n#endif\n\n// Linux-only syscalls.\n#if SANITIZER_LINUX\nuptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n// Used only by sanitizer_stoptheworld. Signal handlers that are actually used\n// (like the process-wide error reporting SEGV handler) must use\n// internal_sigaction instead.\nint internal_sigaction_norestorer(int signum, const void *act, void *oldact);\nvoid internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n#if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__) || \\\n    defined(__powerpc64__) || defined(__s390__) || defined(__i386__) || \\\n    defined(__arm__) || SANITIZER_RISCV64\nuptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                    int *parent_tidptr, void *newtls, int *child_tidptr);\n#endif\nint internal_uname(struct utsname *buf);\n#elif SANITIZER_FREEBSD\nvoid internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n#elif SANITIZER_NETBSD\nvoid internal_sigdelset(__sanitizer_sigset_t *set, int signum);\nuptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg);\n#endif  // SANITIZER_LINUX\n\n// This class reads thread IDs from /proc/<pid>/task using only syscalls.\nclass ThreadLister {\n public:\n  explicit ThreadLister(pid_t pid);\n  ~ThreadLister();\n  enum Result {\n    Error,\n    Incomplete,\n    Ok,\n  };\n  Result ListThreads(InternalMmapVector<tid_t> *threads);\n\n private:\n  bool IsAlive(int tid);\n\n  pid_t pid_;\n  int descriptor_ = -1;\n  InternalMmapVector<char> buffer_;\n};\n\n// Exposed for testing.\nuptr ThreadDescriptorSize();\nuptr ThreadSelf();\n\n// Matches a library's file name against a base name (stripping path and version\n// information).\nbool LibraryNameIs(const char *full_name, const char *base_name);\n\n// Call cb for each region mapped by map.\nvoid ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n\n// Releases memory pages entirely within the [beg, end] address range.\n// The pages no longer count toward RSS; reads are guaranteed to return 0.\n// Requires (but does not verify!) that pages are MAP_PRIVATE.\ninline void ReleaseMemoryPagesToOSAndZeroFill(uptr beg, uptr end) {\n  // man madvise on Linux promises zero-fill for anonymous private pages.\n  // Testing shows the same behaviour for private (but not anonymous) mappings\n  // of shm_open() files, as long as the underlying file is untouched.\n  CHECK(SANITIZER_LINUX);\n  ReleaseMemoryPagesToOS(beg, end);\n}\n\n#if SANITIZER_ANDROID\n\n#if defined(__aarch64__)\n# define __get_tls() \\\n    ({ void** __v; __asm__(\"mrs %0, tpidr_el0\" : \"=r\"(__v)); __v; })\n#elif defined(__arm__)\n# define __get_tls() \\\n    ({ void** __v; __asm__(\"mrc p15, 0, %0, c13, c0, 3\" : \"=r\"(__v)); __v; })\n#elif defined(__mips__)\n// On mips32r1, this goes via a kernel illegal instruction trap that's\n// optimized for v1.\n# define __get_tls() \\\n    ({ register void** __v asm(\"v1\"); \\\n       __asm__(\".set    push\\n\" \\\n               \".set    mips32r2\\n\" \\\n               \"rdhwr   %0,$29\\n\" \\\n               \".set    pop\\n\" : \"=r\"(__v)); \\\n       __v; })\n#elif defined(__i386__)\n# define __get_tls() \\\n    ({ void** __v; __asm__(\"movl %%gs:0, %0\" : \"=r\"(__v)); __v; })\n#elif defined(__x86_64__)\n# define __get_tls() \\\n    ({ void** __v; __asm__(\"mov %%fs:0, %0\" : \"=r\"(__v)); __v; })\n#else\n#error \"Unsupported architecture.\"\n#endif\n\n// The Android Bionic team has allocated a TLS slot for sanitizers starting\n// with Q, given that Android currently doesn't support ELF TLS. It is used to\n// store sanitizer thread specific data.\nstatic const int TLS_SLOT_SANITIZER = 6;\n\nALWAYS_INLINE uptr *get_android_tls_ptr() {\n  return reinterpret_cast<uptr *>(&__get_tls()[TLS_SLOT_SANITIZER]);\n}\n\n#endif  // SANITIZER_ANDROID\n\n}  // namespace __sanitizer\n\n#endif\n#endif  // SANITIZER_LINUX_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_list.h", "content": "//===-- sanitizer_list.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains implementation of a list class to be used by\n// ThreadSanitizer, etc run-times.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_LIST_H\n#define SANITIZER_LIST_H\n\n#include \"sanitizer_internal_defs.h\"\n\nnamespace __sanitizer {\n\n// Intrusive singly-linked list with size(), push_back(), push_front()\n// pop_front(), append_front() and append_back().\n// This class should be a POD (so that it can be put into TLS)\n// and an object with all zero fields should represent a valid empty list.\n// This class does not have a CTOR, so clear() should be called on all\n// non-zero-initialized objects before using.\ntemplate<class Item>\nstruct IntrusiveList {\n  friend class Iterator;\n\n  void clear() {\n    first_ = last_ = nullptr;\n    size_ = 0;\n  }\n\n  bool empty() const { return size_ == 0; }\n  uptr size() const { return size_; }\n\n  void push_back(Item *x) {\n    if (empty()) {\n      x->next = nullptr;\n      first_ = last_ = x;\n      size_ = 1;\n    } else {\n      x->next = nullptr;\n      last_->next = x;\n      last_ = x;\n      size_++;\n    }\n  }\n\n  void push_front(Item *x) {\n    if (empty()) {\n      x->next = nullptr;\n      first_ = last_ = x;\n      size_ = 1;\n    } else {\n      x->next = first_;\n      first_ = x;\n      size_++;\n    }\n  }\n\n  void pop_front() {\n    CHECK(!empty());\n    first_ = first_->next;\n    if (!first_)\n      last_ = nullptr;\n    size_--;\n  }\n\n  void extract(Item *prev, Item *x) {\n    CHECK(!empty());\n    CHECK_NE(prev, nullptr);\n    CHECK_NE(x, nullptr);\n    CHECK_EQ(prev->next, x);\n    prev->next = x->next;\n    if (last_ == x)\n      last_ = prev;\n    size_--;\n  }\n\n  Item *front() { return first_; }\n  const Item *front() const { return first_; }\n  Item *back() { return last_; }\n  const Item *back() const { return last_; }\n\n  void append_front(IntrusiveList<Item> *l) {\n    CHECK_NE(this, l);\n    if (l->empty())\n      return;\n    if (empty()) {\n      *this = *l;\n    } else if (!l->empty()) {\n      l->last_->next = first_;\n      first_ = l->first_;\n      size_ += l->size();\n    }\n    l->clear();\n  }\n\n  void append_back(IntrusiveList<Item> *l) {\n    CHECK_NE(this, l);\n    if (l->empty())\n      return;\n    if (empty()) {\n      *this = *l;\n    } else {\n      last_->next = l->first_;\n      last_ = l->last_;\n      size_ += l->size();\n    }\n    l->clear();\n  }\n\n  void CheckConsistency() {\n    if (size_ == 0) {\n      CHECK_EQ(first_, 0);\n      CHECK_EQ(last_, 0);\n    } else {\n      uptr count = 0;\n      for (Item *i = first_; ; i = i->next) {\n        count++;\n        if (i == last_) break;\n      }\n      CHECK_EQ(size(), count);\n      CHECK_EQ(last_->next, 0);\n    }\n  }\n\n  template<class ItemTy>\n  class IteratorBase {\n   public:\n    explicit IteratorBase(ItemTy *current) : current_(current) {}\n    IteratorBase &operator++() {\n      current_ = current_->next;\n      return *this;\n    }\n    bool operator!=(IteratorBase other) const {\n      return current_ != other.current_;\n    }\n    ItemTy &operator*() {\n      return *current_;\n    }\n   private:\n    ItemTy *current_;\n  };\n\n  typedef IteratorBase<Item> Iterator;\n  typedef IteratorBase<const Item> ConstIterator;\n\n  Iterator begin() { return Iterator(first_); }\n  Iterator end() { return Iterator(0); }\n\n  ConstIterator begin() const { return ConstIterator(first_); }\n  ConstIterator end() const { return ConstIterator(0); }\n\n// private, don't use directly.\n  uptr size_;\n  Item *first_;\n  Item *last_;\n};\n\n} // namespace __sanitizer\n\n#endif // SANITIZER_LIST_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_mac.h", "content": "//===-- sanitizer_mac.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between various sanitizers' runtime libraries and\n// provides definitions for OSX-specific functions.\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_MAC_H\n#define SANITIZER_MAC_H\n\n#include \"sanitizer_common.h\"\n#include \"sanitizer_platform.h\"\n#if SANITIZER_MAC\n#include \"sanitizer_posix.h\"\n\nnamespace __sanitizer {\n\nstruct MemoryMappingLayoutData {\n  int current_image;\n  u32 current_magic;\n  u32 current_filetype;\n  ModuleArch current_arch;\n  u8 current_uuid[kModuleUUIDSize];\n  int current_load_cmd_count;\n  const char *current_load_cmd_addr;\n  bool current_instrumented;\n};\n\ntemplate <typename VersionType>\nstruct VersionBase {\n  u16 major;\n  u16 minor;\n\n  VersionBase(u16 major, u16 minor) : major(major), minor(minor) {}\n\n  bool operator==(const VersionType &other) const {\n    return major == other.major && minor == other.minor;\n  }\n  bool operator>=(const VersionType &other) const {\n    return major > other.major ||\n           (major == other.major && minor >= other.minor);\n  }\n  bool operator<(const VersionType &other) const { return !(*this >= other); }\n};\n\nstruct MacosVersion : VersionBase<MacosVersion> {\n  MacosVersion(u16 major, u16 minor) : VersionBase(major, minor) {}\n};\n\nstruct DarwinKernelVersion : VersionBase<DarwinKernelVersion> {\n  DarwinKernelVersion(u16 major, u16 minor) : VersionBase(major, minor) {}\n};\n\nMacosVersion GetMacosAlignedVersion();\nDarwinKernelVersion GetDarwinKernelVersion();\n\nchar **GetEnviron();\n\nvoid RestrictMemoryToMaxAddress(uptr max_address);\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_MAC\n#endif  // SANITIZER_MAC_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_mutex.h", "content": "//===-- sanitizer_mutex.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of ThreadSanitizer/AddressSanitizer runtime.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_MUTEX_H\n#define SANITIZER_MUTEX_H\n\n#include \"sanitizer_atomic.h\"\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_libc.h\"\n\nnamespace __sanitizer {\n\nclass StaticSpinMutex {\n public:\n  void Init() {\n    atomic_store(&state_, 0, memory_order_relaxed);\n  }\n\n  void Lock() {\n    if (TryLock())\n      return;\n    LockSlow();\n  }\n\n  bool TryLock() {\n    return atomic_exchange(&state_, 1, memory_order_acquire) == 0;\n  }\n\n  void Unlock() {\n    atomic_store(&state_, 0, memory_order_release);\n  }\n\n  void CheckLocked() {\n    CHECK_EQ(atomic_load(&state_, memory_order_relaxed), 1);\n  }\n\n private:\n  atomic_uint8_t state_;\n\n  void NOINLINE LockSlow() {\n    for (int i = 0;; i++) {\n      if (i < 10)\n        proc_yield(10);\n      else\n        internal_sched_yield();\n      if (atomic_load(&state_, memory_order_relaxed) == 0\n          && atomic_exchange(&state_, 1, memory_order_acquire) == 0)\n        return;\n    }\n  }\n};\n\nclass SpinMutex : public StaticSpinMutex {\n public:\n  SpinMutex() {\n    Init();\n  }\n\n private:\n  SpinMutex(const SpinMutex&);\n  void operator=(const SpinMutex&);\n};\n\nclass BlockingMutex {\n public:\n  explicit constexpr BlockingMutex(LinkerInitialized)\n      : opaque_storage_ {0, }, owner_ {0} {}\n  BlockingMutex();\n  void Lock();\n  void Unlock();\n\n  // This function does not guarantee an explicit check that the calling thread\n  // is the thread which owns the mutex. This behavior, while more strictly\n  // correct, causes problems in cases like StopTheWorld, where a parent thread\n  // owns the mutex but a child checks that it is locked. Rather than\n  // maintaining complex state to work around those situations, the check only\n  // checks that the mutex is owned, and assumes callers to be generally\n  // well-behaved.\n  void CheckLocked();\n\n private:\n  // Solaris mutex_t has a member that requires 64-bit alignment.\n  ALIGNED(8) uptr opaque_storage_[10];\n  uptr owner_;  // for debugging\n};\n\n// Reader-writer spin mutex.\nclass RWMutex {\n public:\n  RWMutex() {\n    atomic_store(&state_, kUnlocked, memory_order_relaxed);\n  }\n\n  ~RWMutex() {\n    CHECK_EQ(atomic_load(&state_, memory_order_relaxed), kUnlocked);\n  }\n\n  void Lock() {\n    u32 cmp = kUnlocked;\n    if (atomic_compare_exchange_strong(&state_, &cmp, kWriteLock,\n                                       memory_order_acquire))\n      return;\n    LockSlow();\n  }\n\n  void Unlock() {\n    u32 prev = atomic_fetch_sub(&state_, kWriteLock, memory_order_release);\n    DCHECK_NE(prev & kWriteLock, 0);\n    (void)prev;\n  }\n\n  void ReadLock() {\n    u32 prev = atomic_fetch_add(&state_, kReadLock, memory_order_acquire);\n    if ((prev & kWriteLock) == 0)\n      return;\n    ReadLockSlow();\n  }\n\n  void ReadUnlock() {\n    u32 prev = atomic_fetch_sub(&state_, kReadLock, memory_order_release);\n    DCHECK_EQ(prev & kWriteLock, 0);\n    DCHECK_GT(prev & ~kWriteLock, 0);\n    (void)prev;\n  }\n\n  void CheckLocked() {\n    CHECK_NE(atomic_load(&state_, memory_order_relaxed), kUnlocked);\n  }\n\n private:\n  atomic_uint32_t state_;\n\n  enum {\n    kUnlocked = 0,\n    kWriteLock = 1,\n    kReadLock = 2\n  };\n\n  void NOINLINE LockSlow() {\n    for (int i = 0;; i++) {\n      if (i < 10)\n        proc_yield(10);\n      else\n        internal_sched_yield();\n      u32 cmp = atomic_load(&state_, memory_order_relaxed);\n      if (cmp == kUnlocked &&\n          atomic_compare_exchange_weak(&state_, &cmp, kWriteLock,\n                                       memory_order_acquire))\n          return;\n    }\n  }\n\n  void NOINLINE ReadLockSlow() {\n    for (int i = 0;; i++) {\n      if (i < 10)\n        proc_yield(10);\n      else\n        internal_sched_yield();\n      u32 prev = atomic_load(&state_, memory_order_acquire);\n      if ((prev & kWriteLock) == 0)\n        return;\n    }\n  }\n\n  RWMutex(const RWMutex&);\n  void operator = (const RWMutex&);\n};\n\ntemplate<typename MutexType>\nclass GenericScopedLock {\n public:\n  explicit GenericScopedLock(MutexType *mu)\n      : mu_(mu) {\n    mu_->Lock();\n  }\n\n  ~GenericScopedLock() {\n    mu_->Unlock();\n  }\n\n private:\n  MutexType *mu_;\n\n  GenericScopedLock(const GenericScopedLock&);\n  void operator=(const GenericScopedLock&);\n};\n\ntemplate<typename MutexType>\nclass GenericScopedReadLock {\n public:\n  explicit GenericScopedReadLock(MutexType *mu)\n      : mu_(mu) {\n    mu_->ReadLock();\n  }\n\n  ~GenericScopedReadLock() {\n    mu_->ReadUnlock();\n  }\n\n private:\n  MutexType *mu_;\n\n  GenericScopedReadLock(const GenericScopedReadLock&);\n  void operator=(const GenericScopedReadLock&);\n};\n\ntypedef GenericScopedLock<StaticSpinMutex> SpinMutexLock;\ntypedef GenericScopedLock<BlockingMutex> BlockingMutexLock;\ntypedef GenericScopedLock<RWMutex> RWMutexLock;\ntypedef GenericScopedReadLock<RWMutex> RWMutexReadLock;\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_MUTEX_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_freebsd.h", "content": "//===-- sanitizer_platform_limits_freebsd.h -------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of Sanitizer common code.\n//\n// Sizes and layouts of platform-specific FreeBSD data structures.\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_PLATFORM_LIMITS_FREEBSD_H\n#define SANITIZER_PLATFORM_LIMITS_FREEBSD_H\n\n#if SANITIZER_FREEBSD\n\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_platform.h\"\n#include \"sanitizer_platform_limits_posix.h\"\n\n// Get sys/_types.h, because that tells us whether 64-bit inodes are\n// used in struct dirent below.\n#include <sys/_types.h>\n\nnamespace __sanitizer {\nvoid *__sanitizer_get_link_map_by_dlopen_handle(void *handle);\n#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n  (link_map *)__sanitizer_get_link_map_by_dlopen_handle(handle)\n\nextern unsigned struct_utsname_sz;\nextern unsigned struct_stat_sz;\n#if defined(__powerpc64__)\nconst unsigned struct___old_kernel_stat_sz = 0;\n#else\nconst unsigned struct___old_kernel_stat_sz = 32;\n#endif\nextern unsigned struct_rusage_sz;\nextern unsigned siginfo_t_sz;\nextern unsigned struct_itimerval_sz;\nextern unsigned pthread_t_sz;\nextern unsigned pthread_mutex_t_sz;\nextern unsigned pthread_cond_t_sz;\nextern unsigned pid_t_sz;\nextern unsigned timeval_sz;\nextern unsigned uid_t_sz;\nextern unsigned gid_t_sz;\nextern unsigned fpos_t_sz;\nextern unsigned mbstate_t_sz;\nextern unsigned struct_timezone_sz;\nextern unsigned struct_tms_sz;\nextern unsigned struct_itimerspec_sz;\nextern unsigned struct_sigevent_sz;\nextern unsigned struct_stack_t_sz;\nextern unsigned struct_sched_param_sz;\nextern unsigned struct_statfs64_sz;\nextern unsigned struct_statfs_sz;\nextern unsigned struct_sockaddr_sz;\nextern unsigned ucontext_t_sz;\nextern unsigned struct_rlimit_sz;\nextern unsigned struct_utimbuf_sz;\nextern unsigned struct_timespec_sz;\nextern unsigned struct_regmatch_sz;\nextern unsigned struct_regex_sz;\nextern unsigned struct_FTS_sz;\nextern unsigned struct_FTSENT_sz;\nextern const int unvis_valid;\nextern const int unvis_validpush;\n\nstruct __sanitizer_iocb {\n  u64 aio_data;\n  u32 aio_key_or_aio_reserved1;  // Simply crazy.\n  u32 aio_reserved1_or_aio_key;  // Luckily, we don't need these.\n  u16 aio_lio_opcode;\n  s16 aio_reqprio;\n  u32 aio_fildes;\n  u64 aio_buf;\n  u64 aio_nbytes;\n  s64 aio_offset;\n  u64 aio_reserved2;\n  u64 aio_reserved3;\n};\n\nstruct __sanitizer_io_event {\n  u64 data;\n  u64 obj;\n  u64 res;\n  u64 res2;\n};\n\nconst unsigned iocb_cmd_pread = 0;\nconst unsigned iocb_cmd_pwrite = 1;\nconst unsigned iocb_cmd_preadv = 7;\nconst unsigned iocb_cmd_pwritev = 8;\n\nstruct __sanitizer___sysctl_args {\n  int *name;\n  int nlen;\n  void *oldval;\n  uptr *oldlenp;\n  void *newval;\n  uptr newlen;\n  unsigned long ___unused[4];\n};\n\nstruct __sanitizer_ipc_perm {\n  unsigned int cuid;\n  unsigned int cgid;\n  unsigned int uid;\n  unsigned int gid;\n  unsigned short mode;\n  unsigned short seq;\n  long key;\n};\n\n#if !defined(__i386__)\ntypedef long long __sanitizer_time_t;\n#else\ntypedef long __sanitizer_time_t;\n#endif\n\nstruct __sanitizer_shmid_ds {\n  __sanitizer_ipc_perm shm_perm;\n  unsigned long shm_segsz;\n  unsigned int shm_lpid;\n  unsigned int shm_cpid;\n  int shm_nattch;\n  __sanitizer_time_t shm_atime;\n  __sanitizer_time_t shm_dtime;\n  __sanitizer_time_t shm_ctime;\n};\n\nextern unsigned struct_msqid_ds_sz;\nextern unsigned struct_mq_attr_sz;\nextern unsigned struct_timeb_sz;\nextern unsigned struct_statvfs_sz;\n\nstruct __sanitizer_iovec {\n  void *iov_base;\n  uptr iov_len;\n};\n\nstruct __sanitizer_ifaddrs {\n  struct __sanitizer_ifaddrs *ifa_next;\n  char *ifa_name;\n  unsigned int ifa_flags;\n  void *ifa_addr;     // (struct sockaddr *)\n  void *ifa_netmask;  // (struct sockaddr *)\n#undef ifa_dstaddr\n  void *ifa_dstaddr;  // (struct sockaddr *)\n  void *ifa_data;\n};\n\ntypedef unsigned __sanitizer_pthread_key_t;\n\nstruct __sanitizer_passwd {\n  char *pw_name;\n  char *pw_passwd;\n  int pw_uid;\n  int pw_gid;\n  __sanitizer_time_t pw_change;\n  char *pw_class;\n  char *pw_gecos;\n  char *pw_dir;\n  char *pw_shell;\n  __sanitizer_time_t pw_expire;\n  int pw_fields;\n};\n\nstruct __sanitizer_group {\n  char *gr_name;\n  char *gr_passwd;\n  int gr_gid;\n  char **gr_mem;\n};\n\ntypedef long __sanitizer_suseconds_t;\n\nstruct __sanitizer_timeval {\n  __sanitizer_time_t tv_sec;\n  __sanitizer_suseconds_t tv_usec;\n};\n\nstruct __sanitizer_itimerval {\n  struct __sanitizer_timeval it_interval;\n  struct __sanitizer_timeval it_value;\n};\n\nstruct __sanitizer_timeb {\n  __sanitizer_time_t time;\n  unsigned short millitm;\n  short timezone;\n  short dstflag;\n};\n\nstruct __sanitizer_ether_addr {\n  u8 octet[6];\n};\n\nstruct __sanitizer_tm {\n  int tm_sec;\n  int tm_min;\n  int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n  long int tm_gmtoff;\n  const char *tm_zone;\n};\n\nstruct __sanitizer_msghdr {\n  void *msg_name;\n  unsigned msg_namelen;\n  struct __sanitizer_iovec *msg_iov;\n  unsigned msg_iovlen;\n  void *msg_control;\n  unsigned msg_controllen;\n  int msg_flags;\n};\n\nstruct __sanitizer_cmsghdr {\n  unsigned cmsg_len;\n  int cmsg_level;\n  int cmsg_type;\n};\n\nstruct __sanitizer_dirent {\n#if defined(__INO64)\n  unsigned long long d_fileno;\n  unsigned long long d_off;\n#else\n  unsigned int d_fileno;\n#endif\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n\n// 'clock_t' is 32 bits wide on x64 FreeBSD\ntypedef int __sanitizer_clock_t;\ntypedef int __sanitizer_clockid_t;\n\n#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__) || \\\n    defined(__mips__)\ntypedef unsigned __sanitizer___kernel_uid_t;\ntypedef unsigned __sanitizer___kernel_gid_t;\n#else\ntypedef unsigned short __sanitizer___kernel_uid_t;\ntypedef unsigned short __sanitizer___kernel_gid_t;\n#endif\ntypedef long long __sanitizer___kernel_off_t;\n\n#if defined(__powerpc__) || defined(__mips__)\ntypedef unsigned int __sanitizer___kernel_old_uid_t;\ntypedef unsigned int __sanitizer___kernel_old_gid_t;\n#else\ntypedef unsigned short __sanitizer___kernel_old_uid_t;\ntypedef unsigned short __sanitizer___kernel_old_gid_t;\n#endif\n\ntypedef long long __sanitizer___kernel_loff_t;\ntypedef struct {\n  unsigned long fds_bits[1024 / (8 * sizeof(long))];\n} __sanitizer___kernel_fd_set;\n\n// This thing depends on the platform. We are only interested in the upper\n// limit. Verified with a compiler assert in .cpp.\nunion __sanitizer_pthread_attr_t {\n  char size[128];\n  void *align;\n};\n\nconst unsigned old_sigset_t_sz = sizeof(unsigned long);\n\nstruct __sanitizer_sigset_t {\n  // uint32_t * 4\n  unsigned int __bits[4];\n};\n\ntypedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n\nstruct __sanitizer_siginfo {\n  // The size is determined by looking at sizeof of real siginfo_t on linux.\n  u64 opaque[128 / sizeof(u64)];\n};\n\nusing __sanitizer_sighandler_ptr = void (*)(int sig);\nusing __sanitizer_sigactionhandler_ptr = void (*)(int sig,\n                                                  __sanitizer_siginfo *siginfo,\n                                                  void *uctx);\n\nstruct __sanitizer_sigaction {\n  union {\n    __sanitizer_sigactionhandler_ptr sigaction;\n    __sanitizer_sighandler_ptr handler;\n  };\n  int sa_flags;\n  __sanitizer_sigset_t sa_mask;\n};\n\nstruct __sanitizer_sem_t {\n  u32 data[4];\n};\n\nextern const uptr sig_ign;\nextern const uptr sig_dfl;\nextern const uptr sig_err;\nextern const uptr sa_siginfo;\n\nextern int af_inet;\nextern int af_inet6;\nuptr __sanitizer_in_addr_sz(int af);\n\nstruct __sanitizer_dl_phdr_info {\n  uptr dlpi_addr;\n  const char *dlpi_name;\n  const void *dlpi_phdr;\n  short dlpi_phnum;\n};\n\nextern unsigned struct_ElfW_Phdr_sz;\n\nstruct __sanitizer_addrinfo {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n  unsigned ai_addrlen;\n  char *ai_canonname;\n  void *ai_addr;\n  struct __sanitizer_addrinfo *ai_next;\n};\n\nstruct __sanitizer_hostent {\n  char *h_name;\n  char **h_aliases;\n  int h_addrtype;\n  int h_length;\n  char **h_addr_list;\n};\n\nstruct __sanitizer_pollfd {\n  int fd;\n  short events;\n  short revents;\n};\n\ntypedef unsigned __sanitizer_nfds_t;\n\nstruct __sanitizer_glob_t {\n  uptr gl_pathc;\n  uptr gl_matchc;\n  uptr gl_offs;\n  int gl_flags;\n  char **gl_pathv;\n  int (*gl_errfunc)(const char *, int);\n  void (*gl_closedir)(void *dirp);\n  struct dirent *(*gl_readdir)(void *dirp);\n  void *(*gl_opendir)(const char *);\n  int (*gl_lstat)(const char *, void * /* struct stat* */);\n  int (*gl_stat)(const char *, void * /* struct stat* */);\n};\n\nextern int glob_nomatch;\nextern int glob_altdirfunc;\n\nextern unsigned path_max;\n\nstruct __sanitizer_wordexp_t {\n  uptr we_wordc;\n  char **we_wordv;\n  uptr we_offs;\n  char *we_strings;\n  uptr we_nbytes;\n};\n\ntypedef void __sanitizer_FILE;\n\nextern unsigned struct_shminfo_sz;\nextern unsigned struct_shm_info_sz;\nextern int shmctl_ipc_stat;\nextern int shmctl_ipc_info;\nextern int shmctl_shm_info;\nextern int shmctl_shm_stat;\n\nextern unsigned struct_utmpx_sz;\n\nextern int map_fixed;\n\n// ioctl arguments\nstruct __sanitizer_ifconf {\n  int ifc_len;\n  union {\n    void *ifcu_req;\n  } ifc_ifcu;\n};\n\n#define IOC_NRBITS 8\n#define IOC_TYPEBITS 8\n#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__)\n#define IOC_SIZEBITS 13\n#define IOC_DIRBITS 3\n#define IOC_NONE 1U\n#define IOC_WRITE 4U\n#define IOC_READ 2U\n#else\n#define IOC_SIZEBITS 14\n#define IOC_DIRBITS 2\n#define IOC_NONE 0U\n#define IOC_WRITE 1U\n#define IOC_READ 2U\n#endif\n#define IOC_NRMASK ((1 << IOC_NRBITS) - 1)\n#define IOC_TYPEMASK ((1 << IOC_TYPEBITS) - 1)\n#define IOC_SIZEMASK ((1 << IOC_SIZEBITS) - 1)\n#if defined(IOC_DIRMASK)\n#undef IOC_DIRMASK\n#endif\n#define IOC_DIRMASK ((1 << IOC_DIRBITS) - 1)\n#define IOC_NRSHIFT 0\n#define IOC_TYPESHIFT (IOC_NRSHIFT + IOC_NRBITS)\n#define IOC_SIZESHIFT (IOC_TYPESHIFT + IOC_TYPEBITS)\n#define IOC_DIRSHIFT (IOC_SIZESHIFT + IOC_SIZEBITS)\n#define EVIOC_EV_MAX 0x1f\n#define EVIOC_ABS_MAX 0x3f\n\n#define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n#define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n#define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n#define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n\nextern unsigned struct_ifreq_sz;\nextern unsigned struct_termios_sz;\nextern unsigned struct_winsize_sz;\n\nextern unsigned struct_copr_buffer_sz;\nextern unsigned struct_copr_debug_buf_sz;\nextern unsigned struct_copr_msg_sz;\nextern unsigned struct_midi_info_sz;\nextern unsigned struct_mtget_sz;\nextern unsigned struct_mtop_sz;\nextern unsigned struct_rtentry_sz;\nextern unsigned struct_sbi_instrument_sz;\nextern unsigned struct_seq_event_rec_sz;\nextern unsigned struct_synth_info_sz;\nextern unsigned struct_vt_mode_sz;\n\nextern const unsigned long __sanitizer_bufsiz;\nextern unsigned struct_audio_buf_info_sz;\nextern unsigned struct_ppp_stats_sz;\nextern unsigned struct_sioc_sg_req_sz;\nextern unsigned struct_sioc_vif_req_sz;\n\n// ioctl request identifiers\n\n// A special value to mark ioctls that are not present on the target platform,\n// when it can not be determined without including any system headers.\nextern const unsigned IOCTL_NOT_PRESENT;\n\nextern unsigned IOCTL_FIOASYNC;\nextern unsigned IOCTL_FIOCLEX;\nextern unsigned IOCTL_FIOGETOWN;\nextern unsigned IOCTL_FIONBIO;\nextern unsigned IOCTL_FIONCLEX;\nextern unsigned IOCTL_FIOSETOWN;\nextern unsigned IOCTL_SIOCADDMULTI;\nextern unsigned IOCTL_SIOCATMARK;\nextern unsigned IOCTL_SIOCDELMULTI;\nextern unsigned IOCTL_SIOCGIFADDR;\nextern unsigned IOCTL_SIOCGIFBRDADDR;\nextern unsigned IOCTL_SIOCGIFCONF;\nextern unsigned IOCTL_SIOCGIFDSTADDR;\nextern unsigned IOCTL_SIOCGIFFLAGS;\nextern unsigned IOCTL_SIOCGIFMETRIC;\nextern unsigned IOCTL_SIOCGIFMTU;\nextern unsigned IOCTL_SIOCGIFNETMASK;\nextern unsigned IOCTL_SIOCGPGRP;\nextern unsigned IOCTL_SIOCSIFADDR;\nextern unsigned IOCTL_SIOCSIFBRDADDR;\nextern unsigned IOCTL_SIOCSIFDSTADDR;\nextern unsigned IOCTL_SIOCSIFFLAGS;\nextern unsigned IOCTL_SIOCSIFMETRIC;\nextern unsigned IOCTL_SIOCSIFMTU;\nextern unsigned IOCTL_SIOCSIFNETMASK;\nextern unsigned IOCTL_SIOCSPGRP;\nextern unsigned IOCTL_TIOCCONS;\nextern unsigned IOCTL_TIOCEXCL;\nextern unsigned IOCTL_TIOCGETD;\nextern unsigned IOCTL_TIOCGPGRP;\nextern unsigned IOCTL_TIOCGWINSZ;\nextern unsigned IOCTL_TIOCMBIC;\nextern unsigned IOCTL_TIOCMBIS;\nextern unsigned IOCTL_TIOCMGET;\nextern unsigned IOCTL_TIOCMSET;\nextern unsigned IOCTL_TIOCNOTTY;\nextern unsigned IOCTL_TIOCNXCL;\nextern unsigned IOCTL_TIOCOUTQ;\nextern unsigned IOCTL_TIOCPKT;\nextern unsigned IOCTL_TIOCSCTTY;\nextern unsigned IOCTL_TIOCSETD;\nextern unsigned IOCTL_TIOCSPGRP;\nextern unsigned IOCTL_TIOCSTI;\nextern unsigned IOCTL_TIOCSWINSZ;\nextern unsigned IOCTL_SIOCGETSGCNT;\nextern unsigned IOCTL_SIOCGETVIFCNT;\nextern unsigned IOCTL_MTIOCGET;\nextern unsigned IOCTL_MTIOCTOP;\nextern unsigned IOCTL_SIOCADDRT;\nextern unsigned IOCTL_SIOCDELRT;\nextern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\nextern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\nextern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\nextern unsigned IOCTL_SNDCTL_DSP_POST;\nextern unsigned IOCTL_SNDCTL_DSP_RESET;\nextern unsigned IOCTL_SNDCTL_DSP_SETFMT;\nextern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\nextern unsigned IOCTL_SNDCTL_DSP_SPEED;\nextern unsigned IOCTL_SNDCTL_DSP_STEREO;\nextern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\nextern unsigned IOCTL_SNDCTL_DSP_SYNC;\nextern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\nextern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\nextern unsigned IOCTL_SNDCTL_MIDI_INFO;\nextern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\nextern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\nextern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\nextern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\nextern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\nextern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\nextern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\nextern unsigned IOCTL_SNDCTL_SEQ_PANIC;\nextern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\nextern unsigned IOCTL_SNDCTL_SEQ_RESET;\nextern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\nextern unsigned IOCTL_SNDCTL_SEQ_SYNC;\nextern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\nextern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\nextern unsigned IOCTL_SNDCTL_SYNTH_INFO;\nextern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\nextern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\nextern unsigned IOCTL_SNDCTL_TMR_METRONOME;\nextern unsigned IOCTL_SNDCTL_TMR_SELECT;\nextern unsigned IOCTL_SNDCTL_TMR_SOURCE;\nextern unsigned IOCTL_SNDCTL_TMR_START;\nextern unsigned IOCTL_SNDCTL_TMR_STOP;\nextern unsigned IOCTL_SNDCTL_TMR_TEMPO;\nextern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\nextern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\nextern unsigned IOCTL_SOUND_MIXER_READ_BASS;\nextern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\nextern unsigned IOCTL_SOUND_MIXER_READ_CD;\nextern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\nextern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\nextern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\nextern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE;\nextern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\nextern unsigned IOCTL_SOUND_MIXER_READ_MIC;\nextern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\nextern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\nextern unsigned IOCTL_SOUND_MIXER_READ_PCM;\nextern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\nextern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\nextern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\nextern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\nextern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\nextern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\nextern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\nextern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\nextern unsigned IOCTL_SOUND_PCM_READ_BITS;\nextern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\nextern unsigned IOCTL_SOUND_PCM_READ_FILTER;\nextern unsigned IOCTL_SOUND_PCM_READ_RATE;\nextern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\nextern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\nextern unsigned IOCTL_VT_ACTIVATE;\nextern unsigned IOCTL_VT_GETMODE;\nextern unsigned IOCTL_VT_OPENQRY;\nextern unsigned IOCTL_VT_RELDISP;\nextern unsigned IOCTL_VT_SETMODE;\nextern unsigned IOCTL_VT_WAITACTIVE;\nextern unsigned IOCTL_GIO_SCRNMAP;\nextern unsigned IOCTL_KDDISABIO;\nextern unsigned IOCTL_KDENABIO;\nextern unsigned IOCTL_KDGETLED;\nextern unsigned IOCTL_KDGETMODE;\nextern unsigned IOCTL_KDGKBMODE;\nextern unsigned IOCTL_KDGKBTYPE;\nextern unsigned IOCTL_KDMKTONE;\nextern unsigned IOCTL_KDSETLED;\nextern unsigned IOCTL_KDSETMODE;\nextern unsigned IOCTL_KDSKBMODE;\n\nextern const int si_SEGV_MAPERR;\nextern const int si_SEGV_ACCERR;\n\nstruct __sanitizer_cap_rights {\n  u64 cr_rights[2];\n};\n\ntypedef struct __sanitizer_cap_rights __sanitizer_cap_rights_t;\nextern unsigned struct_cap_rights_sz;\n\nextern unsigned struct_fstab_sz;\nextern unsigned struct_StringList_sz;\n}  // namespace __sanitizer\n\n#define CHECK_TYPE_SIZE(TYPE) \\\n  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n\n#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *)NULL)->MEMBER) == \\\n                 sizeof(((CLASS *)NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==         \\\n                 offsetof(CLASS, MEMBER))\n\n// For sigaction, which is a function and struct at the same time,\n// and thus requires explicit \"struct\" in sizeof() expression.\n#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *)NULL)->MEMBER) == \\\n                 sizeof(((struct CLASS *)NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==         \\\n                 offsetof(struct CLASS, MEMBER))\n\n#define SIGACTION_SYMNAME sigaction\n\n#endif\n\n#endif  // SANITIZER_FREEBSD\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_netbsd.h", "content": "//===-- sanitizer_platform_limits_netbsd.h --------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of Sanitizer common code.\n//\n// Sizes and layouts of platform-specific NetBSD data structures.\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_PLATFORM_LIMITS_NETBSD_H\n#define SANITIZER_PLATFORM_LIMITS_NETBSD_H\n\n#if SANITIZER_NETBSD\n\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_platform.h\"\n\nnamespace __sanitizer {\nvoid *__sanitizer_get_link_map_by_dlopen_handle(void *handle);\n#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n  (link_map *)__sanitizer_get_link_map_by_dlopen_handle(handle)\n\nextern unsigned struct_utsname_sz;\nextern unsigned struct_stat_sz;\nextern unsigned struct_rusage_sz;\nextern unsigned siginfo_t_sz;\nextern unsigned struct_itimerval_sz;\nextern unsigned pthread_t_sz;\nextern unsigned pthread_mutex_t_sz;\nextern unsigned pthread_cond_t_sz;\nextern unsigned pid_t_sz;\nextern unsigned timeval_sz;\nextern unsigned uid_t_sz;\nextern unsigned gid_t_sz;\nextern unsigned mbstate_t_sz;\nextern unsigned struct_timezone_sz;\nextern unsigned struct_tms_sz;\nextern unsigned struct_itimerspec_sz;\nextern unsigned struct_sigevent_sz;\nextern unsigned struct_stack_t_sz;\nextern unsigned struct_sched_param_sz;\nextern unsigned struct_statfs_sz;\nextern unsigned struct_sockaddr_sz;\nextern unsigned ucontext_t_sz;\n\nextern unsigned struct_rlimit_sz;\nextern unsigned struct_utimbuf_sz;\nextern unsigned struct_timespec_sz;\nextern unsigned struct_sembuf_sz;\n\nextern unsigned struct_kevent_sz;\nextern unsigned struct_FTS_sz;\nextern unsigned struct_FTSENT_sz;\n\nextern unsigned struct_regex_sz;\nextern unsigned struct_regmatch_sz;\n\nextern unsigned struct_fstab_sz;\n\nstruct __sanitizer_regmatch {\n  OFF_T rm_so;\n  OFF_T rm_eo;\n};\n\ntypedef struct __sanitizer_modctl_load {\n  const char *ml_filename;\n  int ml_flags;\n  const char *ml_props;\n  uptr ml_propslen;\n} __sanitizer_modctl_load_t;\nextern const int modctl_load;\nextern const int modctl_unload;\nextern const int modctl_stat;\nextern const int modctl_exists;\n\nunion __sanitizer_sigval {\n  int sival_int;\n  uptr sival_ptr;\n};\n\nstruct __sanitizer_sigevent {\n  int sigev_notify;\n  int sigev_signo;\n  union __sanitizer_sigval sigev_value;\n  uptr sigev_notify_function;\n  uptr sigev_notify_attributes;\n};\n\nstruct __sanitizer_aiocb {\n  u64 aio_offset;\n  uptr aio_buf;\n  uptr aio_nbytes;\n  int aio_fildes;\n  int aio_lio_opcode;\n  int aio_reqprio;\n  struct __sanitizer_sigevent aio_sigevent;\n  int _state;\n  int _errno;\n  long _retval;\n};\n\nstruct __sanitizer_sem_t {\n  uptr data[5];\n};\n\nstruct __sanitizer_ipc_perm {\n  u32 uid;\n  u32 gid;\n  u32 cuid;\n  u32 cgid;\n  u32 mode;\n  unsigned short _seq;\n  long _key;\n};\n\nstruct __sanitizer_shmid_ds {\n  __sanitizer_ipc_perm shm_perm;\n  unsigned long shm_segsz;\n  u32 shm_lpid;\n  u32 shm_cpid;\n  unsigned int shm_nattch;\n  u64 shm_atime;\n  u64 shm_dtime;\n  u64 shm_ctime;\n  void *_shm_internal;\n};\n\nstruct __sanitizer_protoent {\n  char *p_name;\n  char **p_aliases;\n  int p_proto;\n};\n\nstruct __sanitizer_netent {\n  char *n_name;\n  char **n_aliases;\n  int n_addrtype;\n  u32 n_net;\n};\n\nextern unsigned struct_msqid_ds_sz;\nextern unsigned struct_mq_attr_sz;\nextern unsigned struct_timex_sz;\nextern unsigned struct_statvfs_sz;\n\nstruct __sanitizer_iovec {\n  void *iov_base;\n  uptr iov_len;\n};\n\nstruct __sanitizer_ifaddrs {\n  struct __sanitizer_ifaddrs *ifa_next;\n  char *ifa_name;\n  unsigned int ifa_flags;\n  void *ifa_addr;     // (struct sockaddr *)\n  void *ifa_netmask;  // (struct sockaddr *)\n  void *ifa_dstaddr;  // (struct sockaddr *)\n  void *ifa_data;\n  unsigned int ifa_addrflags;\n};\n\ntypedef unsigned int __sanitizer_socklen_t;\n\ntypedef unsigned __sanitizer_pthread_key_t;\n\ntypedef long long __sanitizer_time_t;\ntypedef int __sanitizer_suseconds_t;\n\nstruct __sanitizer_timeval {\n  __sanitizer_time_t tv_sec;\n  __sanitizer_suseconds_t tv_usec;\n};\n\nstruct __sanitizer_itimerval {\n  struct __sanitizer_timeval it_interval;\n  struct __sanitizer_timeval it_value;\n};\n\nstruct __sanitizer_timespec {\n  __sanitizer_time_t tv_sec;\n  long tv_nsec;\n};\n\nstruct __sanitizer_passwd {\n  char *pw_name;\n  char *pw_passwd;\n  int pw_uid;\n  int pw_gid;\n  __sanitizer_time_t pw_change;\n  char *pw_class;\n  char *pw_gecos;\n  char *pw_dir;\n  char *pw_shell;\n  __sanitizer_time_t pw_expire;\n};\n\nstruct __sanitizer_group {\n  char *gr_name;\n  char *gr_passwd;\n  int gr_gid;\n  char **gr_mem;\n};\n\nstruct __sanitizer_timeb {\n  __sanitizer_time_t time;\n  unsigned short millitm;\n  short timezone;\n  short dstflag;\n};\n\nstruct __sanitizer_ether_addr {\n  u8 octet[6];\n};\n\nstruct __sanitizer_tm {\n  int tm_sec;\n  int tm_min;\n  int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n  long int tm_gmtoff;\n  const char *tm_zone;\n};\n\nstruct __sanitizer_msghdr {\n  void *msg_name;\n  unsigned msg_namelen;\n  struct __sanitizer_iovec *msg_iov;\n  unsigned msg_iovlen;\n  void *msg_control;\n  unsigned msg_controllen;\n  int msg_flags;\n};\n\nstruct __sanitizer_mmsghdr {\n  struct __sanitizer_msghdr msg_hdr;\n  unsigned int msg_len;\n};\n\nstruct __sanitizer_cmsghdr {\n  unsigned cmsg_len;\n  int cmsg_level;\n  int cmsg_type;\n};\n\nstruct __sanitizer_dirent {\n  u64 d_fileno;\n  u16 d_reclen;\n  // more fields that we don't care about\n};\n\ntypedef int __sanitizer_clock_t;\ntypedef int __sanitizer_clockid_t;\n\ntypedef u32 __sanitizer___kernel_uid_t;\ntypedef u32 __sanitizer___kernel_gid_t;\ntypedef u64 __sanitizer___kernel_off_t;\ntypedef struct {\n  u32 fds_bits[8];\n} __sanitizer___kernel_fd_set;\n\ntypedef struct {\n  unsigned int pta_magic;\n  int pta_flags;\n  void *pta_private;\n} __sanitizer_pthread_attr_t;\n\nstruct __sanitizer_sigset_t {\n  // uint32_t * 4\n  unsigned int __bits[4];\n};\n\nstruct __sanitizer_siginfo {\n  // The size is determined by looking at sizeof of real siginfo_t on linux.\n  u64 opaque[128 / sizeof(u64)];\n};\n\nusing __sanitizer_sighandler_ptr = void (*)(int sig);\nusing __sanitizer_sigactionhandler_ptr = void (*)(int sig,\n                                                  __sanitizer_siginfo *siginfo,\n                                                  void *uctx);\n\nstruct __sanitizer_sigaction {\n  union {\n    __sanitizer_sighandler_ptr handler;\n    __sanitizer_sigactionhandler_ptr sigaction;\n  };\n  __sanitizer_sigset_t sa_mask;\n  int sa_flags;\n};\n\nextern unsigned struct_sigaltstack_sz;\n\ntypedef unsigned int __sanitizer_sigset13_t;\n\nstruct __sanitizer_sigaction13 {\n  __sanitizer_sighandler_ptr osa_handler;\n  __sanitizer_sigset13_t osa_mask;\n  int osa_flags;\n};\n\nstruct __sanitizer_sigaltstack {\n  void *ss_sp;\n  uptr ss_size;\n  int ss_flags;\n};\n\ntypedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n\nstruct __sanitizer_kernel_sigaction_t {\n  union {\n    void (*handler)(int signo);\n    void (*sigaction)(int signo, void *info, void *ctx);\n  };\n  unsigned long sa_flags;\n  void (*sa_restorer)(void);\n  __sanitizer_kernel_sigset_t sa_mask;\n};\n\nextern const uptr sig_ign;\nextern const uptr sig_dfl;\nextern const uptr sig_err;\nextern const uptr sa_siginfo;\n\nextern int af_inet;\nextern int af_inet6;\nuptr __sanitizer_in_addr_sz(int af);\n\nstruct __sanitizer_dl_phdr_info {\n  uptr dlpi_addr;\n  const char *dlpi_name;\n  const void *dlpi_phdr;\n  short dlpi_phnum;\n};\n\nextern unsigned struct_ElfW_Phdr_sz;\n\nstruct __sanitizer_addrinfo {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n#if defined(__sparc__) && defined(_LP64)\n  int __ai_pad0;\n#endif\n  unsigned ai_addrlen;\n#if defined(__alpha__) || (defined(__i386__) && defined(_LP64))\n  int __ai_pad0;\n#endif\n  char *ai_canonname;\n  void *ai_addr;\n  struct __sanitizer_addrinfo *ai_next;\n};\n\nstruct __sanitizer_hostent {\n  char *h_name;\n  char **h_aliases;\n  int h_addrtype;\n  int h_length;\n  char **h_addr_list;\n};\n\nstruct __sanitizer_pollfd {\n  int fd;\n  short events;\n  short revents;\n};\n\ntypedef unsigned __sanitizer_nfds_t;\n\ntypedef int __sanitizer_lwpid_t;\n\nstruct __sanitizer_glob_t {\n  uptr gl_pathc;\n  uptr gl_matchc;\n  uptr gl_offs;\n  int gl_flags;\n  char **gl_pathv;\n  int (*gl_errfunc)(const char *, int);\n  void (*gl_closedir)(void *dirp);\n  struct dirent *(*gl_readdir)(void *dirp);\n  void *(*gl_opendir)(const char *);\n  int (*gl_lstat)(const char *, void * /* struct stat* */);\n  int (*gl_stat)(const char *, void * /* struct stat* */);\n};\n\nextern int glob_nomatch;\nextern int glob_altdirfunc;\n\nextern unsigned path_max;\n\nextern int struct_ttyent_sz;\n\nextern int ptrace_pt_io;\nextern int ptrace_pt_lwpinfo;\nextern int ptrace_pt_set_event_mask;\nextern int ptrace_pt_get_event_mask;\nextern int ptrace_pt_get_process_state;\nextern int ptrace_pt_set_siginfo;\nextern int ptrace_pt_get_siginfo;\nextern int ptrace_pt_lwpstatus;\nextern int ptrace_pt_lwpnext;\nextern int ptrace_piod_read_d;\nextern int ptrace_piod_write_d;\nextern int ptrace_piod_read_i;\nextern int ptrace_piod_write_i;\nextern int ptrace_piod_read_auxv;\nextern int ptrace_pt_setregs;\nextern int ptrace_pt_getregs;\nextern int ptrace_pt_setfpregs;\nextern int ptrace_pt_getfpregs;\nextern int ptrace_pt_setdbregs;\nextern int ptrace_pt_getdbregs;\n\nstruct __sanitizer_ptrace_io_desc {\n  int piod_op;\n  void *piod_offs;\n  void *piod_addr;\n  uptr piod_len;\n};\n\nstruct __sanitizer_ptrace_lwpinfo {\n  __sanitizer_lwpid_t pl_lwpid;\n  int pl_event;\n};\n\nstruct __sanitizer_ptrace_lwpstatus {\n  __sanitizer_lwpid_t pl_lwpid;\n  __sanitizer_sigset_t pl_sigpend;\n  __sanitizer_sigset_t pl_sigmask;\n  char pl_name[20];\n  void *pl_private;\n};\n\nextern unsigned struct_ptrace_ptrace_io_desc_struct_sz;\nextern unsigned struct_ptrace_ptrace_lwpinfo_struct_sz;\nextern unsigned struct_ptrace_ptrace_lwpstatus_struct_sz;\nextern unsigned struct_ptrace_ptrace_event_struct_sz;\nextern unsigned struct_ptrace_ptrace_siginfo_struct_sz;\n\nextern unsigned struct_ptrace_reg_struct_sz;\nextern unsigned struct_ptrace_fpreg_struct_sz;\nextern unsigned struct_ptrace_dbreg_struct_sz;\n\nstruct __sanitizer_wordexp_t {\n  uptr we_wordc;\n  char **we_wordv;\n  uptr we_offs;\n  char *we_strings;\n  uptr we_nbytes;\n};\n\nstruct __sanitizer_FILE {\n  unsigned char *_p;\n  int _r;\n  int _w;\n  unsigned short _flags;\n  short _file;\n  struct {\n    unsigned char *_base;\n    int _size;\n  } _bf;\n  int _lbfsize;\n  void *_cookie;\n  int (*_close)(void *ptr);\n  u64 (*_read)(void *, void *, uptr);\n  u64 (*_seek)(void *, u64, int);\n  uptr (*_write)(void *, const void *, uptr);\n  struct {\n    unsigned char *_base;\n    int _size;\n  } _ext;\n  unsigned char *_up;\n  int _ur;\n  unsigned char _ubuf[3];\n  unsigned char _nbuf[1];\n  int (*_flush)(void *ptr);\n  char _lb_unused[sizeof(uptr)];\n  int _blksize;\n  u64 _offset;\n};\n#define SANITIZER_HAS_STRUCT_FILE 1\n\nextern int shmctl_ipc_stat;\n\n// This simplifies generic code\n#define struct_shminfo_sz -1\n#define struct_shm_info_sz -1\n#define shmctl_shm_stat -1\n#define shmctl_ipc_info -1\n#define shmctl_shm_info -1\n\nextern unsigned struct_utmp_sz;\nextern unsigned struct_utmpx_sz;\n\nextern int map_fixed;\n\n// ioctl arguments\nstruct __sanitizer_ifconf {\n  int ifc_len;\n  union {\n    void *ifcu_req;\n  } ifc_ifcu;\n};\n\nstruct __sanitizer_ttyent {\n  char *ty_name;\n  char *ty_getty;\n  char *ty_type;\n  int ty_status;\n  char *ty_window;\n  char *ty_comment;\n  char *ty_class;\n};\n\nextern const unsigned long __sanitizer_bufsiz;\n\n#define IOC_NRBITS 8\n#define IOC_TYPEBITS 8\n#define IOC_SIZEBITS 14\n#define IOC_DIRBITS 2\n#define IOC_NONE 0U\n#define IOC_WRITE 1U\n#define IOC_READ 2U\n#define IOC_NRMASK ((1 << IOC_NRBITS) - 1)\n#define IOC_TYPEMASK ((1 << IOC_TYPEBITS) - 1)\n#define IOC_SIZEMASK ((1 << IOC_SIZEBITS) - 1)\n#undef IOC_DIRMASK\n#define IOC_DIRMASK ((1 << IOC_DIRBITS) - 1)\n#define IOC_NRSHIFT 0\n#define IOC_TYPESHIFT (IOC_NRSHIFT + IOC_NRBITS)\n#define IOC_SIZESHIFT (IOC_TYPESHIFT + IOC_TYPEBITS)\n#define IOC_DIRSHIFT (IOC_SIZESHIFT + IOC_SIZEBITS)\n#define EVIOC_EV_MAX 0x1f\n#define EVIOC_ABS_MAX 0x3f\n\n#define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n#define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n#define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n#define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n\n// ioctl request identifiers\n\nextern unsigned struct_altqreq_sz;\nextern unsigned struct_amr_user_ioctl_sz;\nextern unsigned struct_ap_control_sz;\nextern unsigned struct_apm_ctl_sz;\nextern unsigned struct_apm_event_info_sz;\nextern unsigned struct_apm_power_info_sz;\nextern unsigned struct_atabusiodetach_args_sz;\nextern unsigned struct_atabusioscan_args_sz;\nextern unsigned struct_ath_diag_sz;\nextern unsigned struct_atm_flowmap_sz;\nextern unsigned struct_audio_buf_info_sz;\nextern unsigned struct_audio_device_sz;\nextern unsigned struct_audio_encoding_sz;\nextern unsigned struct_audio_info_sz;\nextern unsigned struct_audio_offset_sz;\nextern unsigned struct_bio_locate_sz;\nextern unsigned struct_bioc_alarm_sz;\nextern unsigned struct_bioc_blink_sz;\nextern unsigned struct_bioc_disk_sz;\nextern unsigned struct_bioc_inq_sz;\nextern unsigned struct_bioc_setstate_sz;\nextern unsigned struct_bioc_vol_sz;\nextern unsigned struct_bioc_volops_sz;\nextern unsigned struct_bktr_chnlset_sz;\nextern unsigned struct_bktr_remote_sz;\nextern unsigned struct_blue_conf_sz;\nextern unsigned struct_blue_interface_sz;\nextern unsigned struct_blue_stats_sz;\nextern unsigned struct_bpf_dltlist_sz;\nextern unsigned struct_bpf_program_sz;\nextern unsigned struct_bpf_stat_old_sz;\nextern unsigned struct_bpf_stat_sz;\nextern unsigned struct_bpf_version_sz;\nextern unsigned struct_btreq_sz;\nextern unsigned struct_btsco_info_sz;\nextern unsigned struct_buffmem_desc_sz;\nextern unsigned struct_cbq_add_class_sz;\nextern unsigned struct_cbq_add_filter_sz;\nextern unsigned struct_cbq_delete_class_sz;\nextern unsigned struct_cbq_delete_filter_sz;\nextern unsigned struct_cbq_getstats_sz;\nextern unsigned struct_cbq_interface_sz;\nextern unsigned struct_cbq_modify_class_sz;\nextern unsigned struct_ccd_ioctl_sz;\nextern unsigned struct_cdnr_add_element_sz;\nextern unsigned struct_cdnr_add_filter_sz;\nextern unsigned struct_cdnr_add_tbmeter_sz;\nextern unsigned struct_cdnr_add_trtcm_sz;\nextern unsigned struct_cdnr_add_tswtcm_sz;\nextern unsigned struct_cdnr_delete_element_sz;\nextern unsigned struct_cdnr_delete_filter_sz;\nextern unsigned struct_cdnr_get_stats_sz;\nextern unsigned struct_cdnr_interface_sz;\nextern unsigned struct_cdnr_modify_tbmeter_sz;\nextern unsigned struct_cdnr_modify_trtcm_sz;\nextern unsigned struct_cdnr_modify_tswtcm_sz;\nextern unsigned struct_cdnr_tbmeter_stats_sz;\nextern unsigned struct_cdnr_tcm_stats_sz;\nextern unsigned struct_cgd_ioctl_sz;\nextern unsigned struct_cgd_user_sz;\nextern unsigned struct_changer_element_status_request_sz;\nextern unsigned struct_changer_exchange_request_sz;\nextern unsigned struct_changer_move_request_sz;\nextern unsigned struct_changer_params_sz;\nextern unsigned struct_changer_position_request_sz;\nextern unsigned struct_changer_set_voltag_request_sz;\nextern unsigned struct_clockctl_adjtime_sz;\nextern unsigned struct_clockctl_clock_settime_sz;\nextern unsigned struct_clockctl_ntp_adjtime_sz;\nextern unsigned struct_clockctl_settimeofday_sz;\nextern unsigned struct_cnwistats_sz;\nextern unsigned struct_cnwitrail_sz;\nextern unsigned struct_cnwstatus_sz;\nextern unsigned struct_count_info_sz;\nextern unsigned struct_cpu_ucode_sz;\nextern unsigned struct_cpu_ucode_version_sz;\nextern unsigned struct_crypt_kop_sz;\nextern unsigned struct_crypt_mkop_sz;\nextern unsigned struct_crypt_mop_sz;\nextern unsigned struct_crypt_op_sz;\nextern unsigned struct_crypt_result_sz;\nextern unsigned struct_crypt_sfop_sz;\nextern unsigned struct_crypt_sgop_sz;\nextern unsigned struct_cryptret_sz;\nextern unsigned struct_devdetachargs_sz;\nextern unsigned struct_devlistargs_sz;\nextern unsigned struct_devpmargs_sz;\nextern unsigned struct_devrescanargs_sz;\nextern unsigned struct_disk_badsecinfo_sz;\nextern unsigned struct_disk_strategy_sz;\nextern unsigned struct_disklabel_sz;\nextern unsigned struct_dkbad_sz;\nextern unsigned struct_dkwedge_info_sz;\nextern unsigned struct_dkwedge_list_sz;\nextern unsigned struct_dmio_setfunc_sz;\nextern unsigned struct_dmx_pes_filter_params_sz;\nextern unsigned struct_dmx_sct_filter_params_sz;\nextern unsigned struct_dmx_stc_sz;\nextern unsigned struct_dvb_diseqc_master_cmd_sz;\nextern unsigned struct_dvb_diseqc_slave_reply_sz;\nextern unsigned struct_dvb_frontend_event_sz;\nextern unsigned struct_dvb_frontend_info_sz;\nextern unsigned struct_dvb_frontend_parameters_sz;\nextern unsigned struct_eccapreq_sz;\nextern unsigned struct_fbcmap_sz;\nextern unsigned struct_fbcurpos_sz;\nextern unsigned struct_fbcursor_sz;\nextern unsigned struct_fbgattr_sz;\nextern unsigned struct_fbsattr_sz;\nextern unsigned struct_fbtype_sz;\nextern unsigned struct_fdformat_cmd_sz;\nextern unsigned struct_fdformat_parms_sz;\nextern unsigned struct_fifoq_conf_sz;\nextern unsigned struct_fifoq_getstats_sz;\nextern unsigned struct_fifoq_interface_sz;\nextern unsigned struct_format_op_sz;\nextern unsigned struct_fss_get_sz;\nextern unsigned struct_fss_set_sz;\nextern unsigned struct_gpio_attach_sz;\nextern unsigned struct_gpio_info_sz;\nextern unsigned struct_gpio_req_sz;\nextern unsigned struct_gpio_set_sz;\nextern unsigned struct_hfsc_add_class_sz;\nextern unsigned struct_hfsc_add_filter_sz;\nextern unsigned struct_hfsc_attach_sz;\nextern unsigned struct_hfsc_class_stats_sz;\nextern unsigned struct_hfsc_delete_class_sz;\nextern unsigned struct_hfsc_delete_filter_sz;\nextern unsigned struct_hfsc_interface_sz;\nextern unsigned struct_hfsc_modify_class_sz;\nextern unsigned struct_hpcfb_dsp_op_sz;\nextern unsigned struct_hpcfb_dspconf_sz;\nextern unsigned struct_hpcfb_fbconf_sz;\nextern unsigned struct_if_addrprefreq_sz;\nextern unsigned struct_if_clonereq_sz;\nextern unsigned struct_if_laddrreq_sz;\nextern unsigned struct_ifaddr_sz;\nextern unsigned struct_ifaliasreq_sz;\nextern unsigned struct_ifcapreq_sz;\nextern unsigned struct_ifconf_sz;\nextern unsigned struct_ifdatareq_sz;\nextern unsigned struct_ifdrv_sz;\nextern unsigned struct_ifmediareq_sz;\nextern unsigned struct_ifpppcstatsreq_sz;\nextern unsigned struct_ifpppstatsreq_sz;\nextern unsigned struct_ifreq_sz;\nextern unsigned struct_in6_addrpolicy_sz;\nextern unsigned struct_in6_ndireq_sz;\nextern unsigned struct_ioc_load_unload_sz;\nextern unsigned struct_ioc_patch_sz;\nextern unsigned struct_ioc_play_blocks_sz;\nextern unsigned struct_ioc_play_msf_sz;\nextern unsigned struct_ioc_play_track_sz;\nextern unsigned struct_ioc_read_subchannel_sz;\nextern unsigned struct_ioc_read_toc_entry_sz;\nextern unsigned struct_ioc_toc_header_sz;\nextern unsigned struct_ioc_vol_sz;\nextern unsigned struct_ioctl_pt_sz;\nextern unsigned struct_ioppt_sz;\nextern unsigned struct_iovec_sz;\nextern unsigned struct_ipfobj_sz;\nextern unsigned struct_irda_params_sz;\nextern unsigned struct_isp_fc_device_sz;\nextern unsigned struct_isp_fc_tsk_mgmt_sz;\nextern unsigned struct_isp_hba_device_sz;\nextern unsigned struct_isv_cmd_sz;\nextern unsigned struct_jobs_add_class_sz;\nextern unsigned struct_jobs_add_filter_sz;\nextern unsigned struct_jobs_attach_sz;\nextern unsigned struct_jobs_class_stats_sz;\nextern unsigned struct_jobs_delete_class_sz;\nextern unsigned struct_jobs_delete_filter_sz;\nextern unsigned struct_jobs_interface_sz;\nextern unsigned struct_jobs_modify_class_sz;\nextern unsigned struct_kbentry_sz;\nextern unsigned struct_kfilter_mapping_sz;\nextern unsigned struct_kiockeymap_sz;\nextern unsigned struct_ksyms_gsymbol_sz;\nextern unsigned struct_ksyms_gvalue_sz;\nextern unsigned struct_ksyms_ogsymbol_sz;\nextern unsigned struct_kttcp_io_args_sz;\nextern unsigned struct_ltchars_sz;\nextern unsigned struct_lua_create_sz;\nextern unsigned struct_lua_info_sz;\nextern unsigned struct_lua_load_sz;\nextern unsigned struct_lua_require_sz;\nextern unsigned struct_mbpp_param_sz;\nextern unsigned struct_md_conf_sz;\nextern unsigned struct_meteor_capframe_sz;\nextern unsigned struct_meteor_counts_sz;\nextern unsigned struct_meteor_geomet_sz;\nextern unsigned struct_meteor_pixfmt_sz;\nextern unsigned struct_meteor_video_sz;\nextern unsigned struct_mlx_cinfo_sz;\nextern unsigned struct_mlx_pause_sz;\nextern unsigned struct_mlx_rebuild_request_sz;\nextern unsigned struct_mlx_rebuild_status_sz;\nextern unsigned struct_mlx_usercommand_sz;\nextern unsigned struct_mly_user_command_sz;\nextern unsigned struct_mly_user_health_sz;\nextern unsigned struct_mtget_sz;\nextern unsigned struct_mtop_sz;\nextern unsigned struct_npf_ioctl_table_sz;\nextern unsigned struct_npioctl_sz;\nextern unsigned struct_nvme_pt_command_sz;\nextern unsigned struct_ochanger_element_status_request_sz;\nextern unsigned struct_ofiocdesc_sz;\nextern unsigned struct_okiockey_sz;\nextern unsigned struct_ortentry_sz;\nextern unsigned struct_oscsi_addr_sz;\nextern unsigned struct_oss_audioinfo_sz;\nextern unsigned struct_oss_sysinfo_sz;\nextern unsigned struct_pciio_bdf_cfgreg_sz;\nextern unsigned struct_pciio_businfo_sz;\nextern unsigned struct_pciio_cfgreg_sz;\nextern unsigned struct_pciio_drvname_sz;\nextern unsigned struct_pciio_drvnameonbus_sz;\nextern unsigned struct_pcvtid_sz;\nextern unsigned struct_pf_osfp_ioctl_sz;\nextern unsigned struct_pf_status_sz;\nextern unsigned struct_pfioc_altq_sz;\nextern unsigned struct_pfioc_if_sz;\nextern unsigned struct_pfioc_iface_sz;\nextern unsigned struct_pfioc_limit_sz;\nextern unsigned struct_pfioc_natlook_sz;\nextern unsigned struct_pfioc_pooladdr_sz;\nextern unsigned struct_pfioc_qstats_sz;\nextern unsigned struct_pfioc_rule_sz;\nextern unsigned struct_pfioc_ruleset_sz;\nextern unsigned struct_pfioc_src_node_kill_sz;\nextern unsigned struct_pfioc_src_nodes_sz;\nextern unsigned struct_pfioc_state_kill_sz;\nextern unsigned struct_pfioc_state_sz;\nextern unsigned struct_pfioc_states_sz;\nextern unsigned struct_pfioc_table_sz;\nextern unsigned struct_pfioc_tm_sz;\nextern unsigned struct_pfioc_trans_sz;\nextern unsigned struct_plistref_sz;\nextern unsigned struct_power_type_sz;\nextern unsigned struct_ppp_idle_sz;\nextern unsigned struct_ppp_option_data_sz;\nextern unsigned struct_ppp_rawin_sz;\nextern unsigned struct_pppoeconnectionstate_sz;\nextern unsigned struct_pppoediscparms_sz;\nextern unsigned struct_priq_add_class_sz;\nextern unsigned struct_priq_add_filter_sz;\nextern unsigned struct_priq_class_stats_sz;\nextern unsigned struct_priq_delete_class_sz;\nextern unsigned struct_priq_delete_filter_sz;\nextern unsigned struct_priq_interface_sz;\nextern unsigned struct_priq_modify_class_sz;\nextern unsigned struct_ptmget_sz;\nextern unsigned struct_pvctxreq_sz;\nextern unsigned struct_radio_info_sz;\nextern unsigned struct_red_conf_sz;\nextern unsigned struct_red_interface_sz;\nextern unsigned struct_red_stats_sz;\nextern unsigned struct_redparams_sz;\nextern unsigned struct_rf_pmparams_sz;\nextern unsigned struct_rf_pmstat_sz;\nextern unsigned struct_rf_recon_req_sz;\nextern unsigned struct_rio_conf_sz;\nextern unsigned struct_rio_interface_sz;\nextern unsigned struct_rio_stats_sz;\nextern unsigned struct_scan_io_sz;\nextern unsigned struct_scbusaccel_args_sz;\nextern unsigned struct_scbusiodetach_args_sz;\nextern unsigned struct_scbusioscan_args_sz;\nextern unsigned struct_scsi_addr_sz;\nextern unsigned struct_seq_event_rec_sz;\nextern unsigned struct_session_op_sz;\nextern unsigned struct_sgttyb_sz;\nextern unsigned struct_sioc_sg_req_sz;\nextern unsigned struct_sioc_vif_req_sz;\nextern unsigned struct_smbioc_flags_sz;\nextern unsigned struct_smbioc_lookup_sz;\nextern unsigned struct_smbioc_oshare_sz;\nextern unsigned struct_smbioc_ossn_sz;\nextern unsigned struct_smbioc_rq_sz;\nextern unsigned struct_smbioc_rw_sz;\nextern unsigned struct_spppauthcfg_sz;\nextern unsigned struct_spppauthfailuresettings_sz;\nextern unsigned struct_spppauthfailurestats_sz;\nextern unsigned struct_spppdnsaddrs_sz;\nextern unsigned struct_spppdnssettings_sz;\nextern unsigned struct_spppidletimeout_sz;\nextern unsigned struct_spppkeepalivesettings_sz;\nextern unsigned struct_sppplcpcfg_sz;\nextern unsigned struct_spppstatus_sz;\nextern unsigned struct_spppstatusncp_sz;\nextern unsigned struct_srt_rt_sz;\nextern unsigned struct_stic_xinfo_sz;\nextern unsigned struct_sun_dkctlr_sz;\nextern unsigned struct_sun_dkgeom_sz;\nextern unsigned struct_sun_dkpart_sz;\nextern unsigned struct_synth_info_sz;\nextern unsigned struct_tbrreq_sz;\nextern unsigned struct_tchars_sz;\nextern unsigned struct_termios_sz;\nextern unsigned struct_timeval_sz;\nextern unsigned struct_twe_drivecommand_sz;\nextern unsigned struct_twe_paramcommand_sz;\nextern unsigned struct_twe_usercommand_sz;\nextern unsigned struct_ukyopon_identify_sz;\nextern unsigned struct_urio_command_sz;\nextern unsigned struct_usb_alt_interface_sz;\nextern unsigned struct_usb_bulk_ra_wb_opt_sz;\nextern unsigned struct_usb_config_desc_sz;\nextern unsigned struct_usb_ctl_report_desc_sz;\nextern unsigned struct_usb_ctl_report_sz;\nextern unsigned struct_usb_ctl_request_sz;\n#if defined(__x86_64__)\nextern unsigned struct_nvmm_ioc_capability_sz;\nextern unsigned struct_nvmm_ioc_machine_create_sz;\nextern unsigned struct_nvmm_ioc_machine_destroy_sz;\nextern unsigned struct_nvmm_ioc_machine_configure_sz;\nextern unsigned struct_nvmm_ioc_vcpu_create_sz;\nextern unsigned struct_nvmm_ioc_vcpu_destroy_sz;\nextern unsigned struct_nvmm_ioc_vcpu_configure_sz;\nextern unsigned struct_nvmm_ioc_vcpu_setstate_sz;\nextern unsigned struct_nvmm_ioc_vcpu_getstate_sz;\nextern unsigned struct_nvmm_ioc_vcpu_inject_sz;\nextern unsigned struct_nvmm_ioc_vcpu_run_sz;\nextern unsigned struct_nvmm_ioc_gpa_map_sz;\nextern unsigned struct_nvmm_ioc_gpa_unmap_sz;\nextern unsigned struct_nvmm_ioc_hva_map_sz;\nextern unsigned struct_nvmm_ioc_hva_unmap_sz;\nextern unsigned struct_nvmm_ioc_ctl_sz;\n#endif\nextern unsigned struct_spi_ioctl_configure_sz;\nextern unsigned struct_spi_ioctl_transfer_sz;\nextern unsigned struct_autofs_daemon_request_sz;\nextern unsigned struct_autofs_daemon_done_sz;\nextern unsigned struct_sctp_connectx_addrs_sz;\nextern unsigned struct_usb_device_info_old_sz;\nextern unsigned struct_usb_device_info_sz;\nextern unsigned struct_usb_device_stats_sz;\nextern unsigned struct_usb_endpoint_desc_sz;\nextern unsigned struct_usb_full_desc_sz;\nextern unsigned struct_usb_interface_desc_sz;\nextern unsigned struct_usb_string_desc_sz;\nextern unsigned struct_utoppy_readfile_sz;\nextern unsigned struct_utoppy_rename_sz;\nextern unsigned struct_utoppy_stats_sz;\nextern unsigned struct_utoppy_writefile_sz;\nextern unsigned struct_v4l2_audio_sz;\nextern unsigned struct_v4l2_audioout_sz;\nextern unsigned struct_v4l2_buffer_sz;\nextern unsigned struct_v4l2_capability_sz;\nextern unsigned struct_v4l2_control_sz;\nextern unsigned struct_v4l2_crop_sz;\nextern unsigned struct_v4l2_cropcap_sz;\nextern unsigned struct_v4l2_fmtdesc_sz;\nextern unsigned struct_v4l2_format_sz;\nextern unsigned struct_v4l2_framebuffer_sz;\nextern unsigned struct_v4l2_frequency_sz;\nextern unsigned struct_v4l2_frmivalenum_sz;\nextern unsigned struct_v4l2_frmsizeenum_sz;\nextern unsigned struct_v4l2_input_sz;\nextern unsigned struct_v4l2_jpegcompression_sz;\nextern unsigned struct_v4l2_modulator_sz;\nextern unsigned struct_v4l2_output_sz;\nextern unsigned struct_v4l2_queryctrl_sz;\nextern unsigned struct_v4l2_querymenu_sz;\nextern unsigned struct_v4l2_requestbuffers_sz;\nextern unsigned struct_v4l2_standard_sz;\nextern unsigned struct_v4l2_streamparm_sz;\nextern unsigned struct_v4l2_tuner_sz;\nextern unsigned struct_vnd_ioctl_sz;\nextern unsigned struct_vnd_user_sz;\nextern unsigned struct_vt_stat_sz;\nextern unsigned struct_wdog_conf_sz;\nextern unsigned struct_wdog_mode_sz;\nextern unsigned struct_ipmi_recv_sz;\nextern unsigned struct_ipmi_req_sz;\nextern unsigned struct_ipmi_cmdspec_sz;\nextern unsigned struct_wfq_conf_sz;\nextern unsigned struct_wfq_getqid_sz;\nextern unsigned struct_wfq_getstats_sz;\nextern unsigned struct_wfq_interface_sz;\nextern unsigned struct_wfq_setweight_sz;\nextern unsigned struct_winsize_sz;\nextern unsigned struct_wscons_event_sz;\nextern unsigned struct_wsdisplay_addscreendata_sz;\nextern unsigned struct_wsdisplay_char_sz;\nextern unsigned struct_wsdisplay_cmap_sz;\nextern unsigned struct_wsdisplay_curpos_sz;\nextern unsigned struct_wsdisplay_cursor_sz;\nextern unsigned struct_wsdisplay_delscreendata_sz;\nextern unsigned struct_wsdisplay_fbinfo_sz;\nextern unsigned struct_wsdisplay_font_sz;\nextern unsigned struct_wsdisplay_kbddata_sz;\nextern unsigned struct_wsdisplay_msgattrs_sz;\nextern unsigned struct_wsdisplay_param_sz;\nextern unsigned struct_wsdisplay_scroll_data_sz;\nextern unsigned struct_wsdisplay_usefontdata_sz;\nextern unsigned struct_wsdisplayio_blit_sz;\nextern unsigned struct_wsdisplayio_bus_id_sz;\nextern unsigned struct_wsdisplayio_edid_info_sz;\nextern unsigned struct_wsdisplayio_fbinfo_sz;\nextern unsigned struct_wskbd_bell_data_sz;\nextern unsigned struct_wskbd_keyrepeat_data_sz;\nextern unsigned struct_wskbd_map_data_sz;\nextern unsigned struct_wskbd_scroll_data_sz;\nextern unsigned struct_wsmouse_calibcoords_sz;\nextern unsigned struct_wsmouse_id_sz;\nextern unsigned struct_wsmouse_repeat_sz;\nextern unsigned struct_wsmux_device_list_sz;\nextern unsigned struct_wsmux_device_sz;\nextern unsigned struct_xd_iocmd_sz;\n\nextern unsigned struct_scsireq_sz;\nextern unsigned struct_tone_sz;\nextern unsigned union_twe_statrequest_sz;\nextern unsigned struct_usb_device_descriptor_sz;\nextern unsigned struct_vt_mode_sz;\nextern unsigned struct__old_mixer_info_sz;\nextern unsigned struct__agp_allocate_sz;\nextern unsigned struct__agp_bind_sz;\nextern unsigned struct__agp_info_sz;\nextern unsigned struct__agp_setup_sz;\nextern unsigned struct__agp_unbind_sz;\nextern unsigned struct_atareq_sz;\nextern unsigned struct_cpustate_sz;\nextern unsigned struct_dmx_caps_sz;\nextern unsigned enum_dmx_source_sz;\nextern unsigned union_dvd_authinfo_sz;\nextern unsigned union_dvd_struct_sz;\nextern unsigned enum_v4l2_priority_sz;\nextern unsigned struct_envsys_basic_info_sz;\nextern unsigned struct_envsys_tre_data_sz;\nextern unsigned enum_fe_sec_mini_cmd_sz;\nextern unsigned enum_fe_sec_tone_mode_sz;\nextern unsigned enum_fe_sec_voltage_sz;\nextern unsigned enum_fe_status_sz;\nextern unsigned struct_gdt_ctrt_sz;\nextern unsigned struct_gdt_event_sz;\nextern unsigned struct_gdt_osv_sz;\nextern unsigned struct_gdt_rescan_sz;\nextern unsigned struct_gdt_statist_sz;\nextern unsigned struct_gdt_ucmd_sz;\nextern unsigned struct_iscsi_conn_status_parameters_sz;\nextern unsigned struct_iscsi_get_version_parameters_sz;\nextern unsigned struct_iscsi_iocommand_parameters_sz;\nextern unsigned struct_iscsi_login_parameters_sz;\nextern unsigned struct_iscsi_logout_parameters_sz;\nextern unsigned struct_iscsi_register_event_parameters_sz;\nextern unsigned struct_iscsi_remove_parameters_sz;\nextern unsigned struct_iscsi_send_targets_parameters_sz;\nextern unsigned struct_iscsi_set_node_name_parameters_sz;\nextern unsigned struct_iscsi_wait_event_parameters_sz;\nextern unsigned struct_isp_stats_sz;\nextern unsigned struct_lsenable_sz;\nextern unsigned struct_lsdisable_sz;\nextern unsigned struct_audio_format_query_sz;\nextern unsigned struct_mixer_ctrl_sz;\nextern unsigned struct_mixer_devinfo_sz;\nextern unsigned struct_mpu_command_rec_sz;\nextern unsigned struct_rndstat_sz;\nextern unsigned struct_rndstat_name_sz;\nextern unsigned struct_rndctl_sz;\nextern unsigned struct_rnddata_sz;\nextern unsigned struct_rndpoolstat_sz;\nextern unsigned struct_rndstat_est_sz;\nextern unsigned struct_rndstat_est_name_sz;\nextern unsigned struct_pps_params_sz;\nextern unsigned struct_pps_info_sz;\nextern unsigned struct_mixer_info_sz;\nextern unsigned struct_RF_SparetWait_sz;\nextern unsigned struct_RF_ComponentLabel_sz;\nextern unsigned struct_RF_SingleComponent_sz;\nextern unsigned struct_RF_ProgressInfo_sz;\nextern unsigned struct_nvlist_ref_sz;\nextern unsigned struct_StringList_sz;\n\n// A special value to mark ioctls that are not present on the target platform,\n// when it can not be determined without including any system headers.\nextern const unsigned IOCTL_NOT_PRESENT;\n\nextern unsigned IOCTL_AFM_ADDFMAP;\nextern unsigned IOCTL_AFM_DELFMAP;\nextern unsigned IOCTL_AFM_CLEANFMAP;\nextern unsigned IOCTL_AFM_GETFMAP;\nextern unsigned IOCTL_ALTQGTYPE;\nextern unsigned IOCTL_ALTQTBRSET;\nextern unsigned IOCTL_ALTQTBRGET;\nextern unsigned IOCTL_BLUE_IF_ATTACH;\nextern unsigned IOCTL_BLUE_IF_DETACH;\nextern unsigned IOCTL_BLUE_ENABLE;\nextern unsigned IOCTL_BLUE_DISABLE;\nextern unsigned IOCTL_BLUE_CONFIG;\nextern unsigned IOCTL_BLUE_GETSTATS;\nextern unsigned IOCTL_CBQ_IF_ATTACH;\nextern unsigned IOCTL_CBQ_IF_DETACH;\nextern unsigned IOCTL_CBQ_ENABLE;\nextern unsigned IOCTL_CBQ_DISABLE;\nextern unsigned IOCTL_CBQ_CLEAR_HIERARCHY;\nextern unsigned IOCTL_CBQ_ADD_CLASS;\nextern unsigned IOCTL_CBQ_DEL_CLASS;\nextern unsigned IOCTL_CBQ_MODIFY_CLASS;\nextern unsigned IOCTL_CBQ_ADD_FILTER;\nextern unsigned IOCTL_CBQ_DEL_FILTER;\nextern unsigned IOCTL_CBQ_GETSTATS;\nextern unsigned IOCTL_CDNR_IF_ATTACH;\nextern unsigned IOCTL_CDNR_IF_DETACH;\nextern unsigned IOCTL_CDNR_ENABLE;\nextern unsigned IOCTL_CDNR_DISABLE;\nextern unsigned IOCTL_CDNR_ADD_FILTER;\nextern unsigned IOCTL_CDNR_DEL_FILTER;\nextern unsigned IOCTL_CDNR_GETSTATS;\nextern unsigned IOCTL_CDNR_ADD_ELEM;\nextern unsigned IOCTL_CDNR_DEL_ELEM;\nextern unsigned IOCTL_CDNR_ADD_TBM;\nextern unsigned IOCTL_CDNR_MOD_TBM;\nextern unsigned IOCTL_CDNR_TBM_STATS;\nextern unsigned IOCTL_CDNR_ADD_TCM;\nextern unsigned IOCTL_CDNR_MOD_TCM;\nextern unsigned IOCTL_CDNR_TCM_STATS;\nextern unsigned IOCTL_CDNR_ADD_TSW;\nextern unsigned IOCTL_CDNR_MOD_TSW;\nextern unsigned IOCTL_FIFOQ_IF_ATTACH;\nextern unsigned IOCTL_FIFOQ_IF_DETACH;\nextern unsigned IOCTL_FIFOQ_ENABLE;\nextern unsigned IOCTL_FIFOQ_DISABLE;\nextern unsigned IOCTL_FIFOQ_CONFIG;\nextern unsigned IOCTL_FIFOQ_GETSTATS;\nextern unsigned IOCTL_HFSC_IF_ATTACH;\nextern unsigned IOCTL_HFSC_IF_DETACH;\nextern unsigned IOCTL_HFSC_ENABLE;\nextern unsigned IOCTL_HFSC_DISABLE;\nextern unsigned IOCTL_HFSC_CLEAR_HIERARCHY;\nextern unsigned IOCTL_HFSC_ADD_CLASS;\nextern unsigned IOCTL_HFSC_DEL_CLASS;\nextern unsigned IOCTL_HFSC_MOD_CLASS;\nextern unsigned IOCTL_HFSC_ADD_FILTER;\nextern unsigned IOCTL_HFSC_DEL_FILTER;\nextern unsigned IOCTL_HFSC_GETSTATS;\nextern unsigned IOCTL_JOBS_IF_ATTACH;\nextern unsigned IOCTL_JOBS_IF_DETACH;\nextern unsigned IOCTL_JOBS_ENABLE;\nextern unsigned IOCTL_JOBS_DISABLE;\nextern unsigned IOCTL_JOBS_CLEAR;\nextern unsigned IOCTL_JOBS_ADD_CLASS;\nextern unsigned IOCTL_JOBS_DEL_CLASS;\nextern unsigned IOCTL_JOBS_MOD_CLASS;\nextern unsigned IOCTL_JOBS_ADD_FILTER;\nextern unsigned IOCTL_JOBS_DEL_FILTER;\nextern unsigned IOCTL_JOBS_GETSTATS;\nextern unsigned IOCTL_PRIQ_IF_ATTACH;\nextern unsigned IOCTL_PRIQ_IF_DETACH;\nextern unsigned IOCTL_PRIQ_ENABLE;\nextern unsigned IOCTL_PRIQ_DISABLE;\nextern unsigned IOCTL_PRIQ_CLEAR;\nextern unsigned IOCTL_PRIQ_ADD_CLASS;\nextern unsigned IOCTL_PRIQ_DEL_CLASS;\nextern unsigned IOCTL_PRIQ_MOD_CLASS;\nextern unsigned IOCTL_PRIQ_ADD_FILTER;\nextern unsigned IOCTL_PRIQ_DEL_FILTER;\nextern unsigned IOCTL_PRIQ_GETSTATS;\nextern unsigned IOCTL_RED_IF_ATTACH;\nextern unsigned IOCTL_RED_IF_DETACH;\nextern unsigned IOCTL_RED_ENABLE;\nextern unsigned IOCTL_RED_DISABLE;\nextern unsigned IOCTL_RED_CONFIG;\nextern unsigned IOCTL_RED_GETSTATS;\nextern unsigned IOCTL_RED_SETDEFAULTS;\nextern unsigned IOCTL_RIO_IF_ATTACH;\nextern unsigned IOCTL_RIO_IF_DETACH;\nextern unsigned IOCTL_RIO_ENABLE;\nextern unsigned IOCTL_RIO_DISABLE;\nextern unsigned IOCTL_RIO_CONFIG;\nextern unsigned IOCTL_RIO_GETSTATS;\nextern unsigned IOCTL_RIO_SETDEFAULTS;\nextern unsigned IOCTL_WFQ_IF_ATTACH;\nextern unsigned IOCTL_WFQ_IF_DETACH;\nextern unsigned IOCTL_WFQ_ENABLE;\nextern unsigned IOCTL_WFQ_DISABLE;\nextern unsigned IOCTL_WFQ_CONFIG;\nextern unsigned IOCTL_WFQ_GET_STATS;\nextern unsigned IOCTL_WFQ_GET_QID;\nextern unsigned IOCTL_WFQ_SET_WEIGHT;\nextern unsigned IOCTL_CRIOGET;\nextern unsigned IOCTL_CIOCFSESSION;\nextern unsigned IOCTL_CIOCKEY;\nextern unsigned IOCTL_CIOCNFKEYM;\nextern unsigned IOCTL_CIOCNFSESSION;\nextern unsigned IOCTL_CIOCNCRYPTRETM;\nextern unsigned IOCTL_CIOCNCRYPTRET;\nextern unsigned IOCTL_CIOCGSESSION;\nextern unsigned IOCTL_CIOCNGSESSION;\nextern unsigned IOCTL_CIOCCRYPT;\nextern unsigned IOCTL_CIOCNCRYPTM;\nextern unsigned IOCTL_CIOCASYMFEAT;\nextern unsigned IOCTL_APM_IOC_REJECT;\nextern unsigned IOCTL_APM_IOC_STANDBY;\nextern unsigned IOCTL_APM_IOC_SUSPEND;\nextern unsigned IOCTL_OAPM_IOC_GETPOWER;\nextern unsigned IOCTL_APM_IOC_GETPOWER;\nextern unsigned IOCTL_APM_IOC_NEXTEVENT;\nextern unsigned IOCTL_APM_IOC_DEV_CTL;\nextern unsigned IOCTL_NETBSD_DM_IOCTL;\nextern unsigned IOCTL_DMIO_SETFUNC;\nextern unsigned IOCTL_DMX_START;\nextern unsigned IOCTL_DMX_STOP;\nextern unsigned IOCTL_DMX_SET_FILTER;\nextern unsigned IOCTL_DMX_SET_PES_FILTER;\nextern unsigned IOCTL_DMX_SET_BUFFER_SIZE;\nextern unsigned IOCTL_DMX_GET_STC;\nextern unsigned IOCTL_DMX_ADD_PID;\nextern unsigned IOCTL_DMX_REMOVE_PID;\nextern unsigned IOCTL_DMX_GET_CAPS;\nextern unsigned IOCTL_DMX_SET_SOURCE;\nextern unsigned IOCTL_FE_READ_STATUS;\nextern unsigned IOCTL_FE_READ_BER;\nextern unsigned IOCTL_FE_READ_SNR;\nextern unsigned IOCTL_FE_READ_SIGNAL_STRENGTH;\nextern unsigned IOCTL_FE_READ_UNCORRECTED_BLOCKS;\nextern unsigned IOCTL_FE_SET_FRONTEND;\nextern unsigned IOCTL_FE_GET_FRONTEND;\nextern unsigned IOCTL_FE_GET_EVENT;\nextern unsigned IOCTL_FE_GET_INFO;\nextern unsigned IOCTL_FE_DISEQC_RESET_OVERLOAD;\nextern unsigned IOCTL_FE_DISEQC_SEND_MASTER_CMD;\nextern unsigned IOCTL_FE_DISEQC_RECV_SLAVE_REPLY;\nextern unsigned IOCTL_FE_DISEQC_SEND_BURST;\nextern unsigned IOCTL_FE_SET_TONE;\nextern unsigned IOCTL_FE_SET_VOLTAGE;\nextern unsigned IOCTL_FE_ENABLE_HIGH_LNB_VOLTAGE;\nextern unsigned IOCTL_FE_SET_FRONTEND_TUNE_MODE;\nextern unsigned IOCTL_FE_DISHNETWORK_SEND_LEGACY_CMD;\nextern unsigned IOCTL_FILEMON_SET_FD;\nextern unsigned IOCTL_FILEMON_SET_PID;\nextern unsigned IOCTL_HDAUDIO_FGRP_INFO;\nextern unsigned IOCTL_HDAUDIO_FGRP_GETCONFIG;\nextern unsigned IOCTL_HDAUDIO_FGRP_SETCONFIG;\nextern unsigned IOCTL_HDAUDIO_FGRP_WIDGET_INFO;\nextern unsigned IOCTL_HDAUDIO_FGRP_CODEC_INFO;\nextern unsigned IOCTL_HDAUDIO_AFG_WIDGET_INFO;\nextern unsigned IOCTL_HDAUDIO_AFG_CODEC_INFO;\nextern unsigned IOCTL_CEC_GET_PHYS_ADDR;\nextern unsigned IOCTL_CEC_GET_LOG_ADDRS;\nextern unsigned IOCTL_CEC_SET_LOG_ADDRS;\nextern unsigned IOCTL_CEC_GET_VENDOR_ID;\nextern unsigned IOCTL_HPCFBIO_GCONF;\nextern unsigned IOCTL_HPCFBIO_SCONF;\nextern unsigned IOCTL_HPCFBIO_GDSPCONF;\nextern unsigned IOCTL_HPCFBIO_SDSPCONF;\nextern unsigned IOCTL_HPCFBIO_GOP;\nextern unsigned IOCTL_HPCFBIO_SOP;\nextern unsigned IOCTL_IOPIOCPT;\nextern unsigned IOCTL_IOPIOCGLCT;\nextern unsigned IOCTL_IOPIOCGSTATUS;\nextern unsigned IOCTL_IOPIOCRECONFIG;\nextern unsigned IOCTL_IOPIOCGTIDMAP;\nextern unsigned IOCTL_SIOCGATHSTATS;\nextern unsigned IOCTL_SIOCGATHDIAG;\nextern unsigned IOCTL_METEORCAPTUR;\nextern unsigned IOCTL_METEORCAPFRM;\nextern unsigned IOCTL_METEORSETGEO;\nextern unsigned IOCTL_METEORGETGEO;\nextern unsigned IOCTL_METEORSTATUS;\nextern unsigned IOCTL_METEORSHUE;\nextern unsigned IOCTL_METEORGHUE;\nextern unsigned IOCTL_METEORSFMT;\nextern unsigned IOCTL_METEORGFMT;\nextern unsigned IOCTL_METEORSINPUT;\nextern unsigned IOCTL_METEORGINPUT;\nextern unsigned IOCTL_METEORSCHCV;\nextern unsigned IOCTL_METEORGCHCV;\nextern unsigned IOCTL_METEORSCOUNT;\nextern unsigned IOCTL_METEORGCOUNT;\nextern unsigned IOCTL_METEORSFPS;\nextern unsigned IOCTL_METEORGFPS;\nextern unsigned IOCTL_METEORSSIGNAL;\nextern unsigned IOCTL_METEORGSIGNAL;\nextern unsigned IOCTL_METEORSVIDEO;\nextern unsigned IOCTL_METEORGVIDEO;\nextern unsigned IOCTL_METEORSBRIG;\nextern unsigned IOCTL_METEORGBRIG;\nextern unsigned IOCTL_METEORSCSAT;\nextern unsigned IOCTL_METEORGCSAT;\nextern unsigned IOCTL_METEORSCONT;\nextern unsigned IOCTL_METEORGCONT;\nextern unsigned IOCTL_METEORSHWS;\nextern unsigned IOCTL_METEORGHWS;\nextern unsigned IOCTL_METEORSVWS;\nextern unsigned IOCTL_METEORGVWS;\nextern unsigned IOCTL_METEORSTS;\nextern unsigned IOCTL_METEORGTS;\nextern unsigned IOCTL_TVTUNER_SETCHNL;\nextern unsigned IOCTL_TVTUNER_GETCHNL;\nextern unsigned IOCTL_TVTUNER_SETTYPE;\nextern unsigned IOCTL_TVTUNER_GETTYPE;\nextern unsigned IOCTL_TVTUNER_GETSTATUS;\nextern unsigned IOCTL_TVTUNER_SETFREQ;\nextern unsigned IOCTL_TVTUNER_GETFREQ;\nextern unsigned IOCTL_TVTUNER_SETAFC;\nextern unsigned IOCTL_TVTUNER_GETAFC;\nextern unsigned IOCTL_RADIO_SETMODE;\nextern unsigned IOCTL_RADIO_GETMODE;\nextern unsigned IOCTL_RADIO_SETFREQ;\nextern unsigned IOCTL_RADIO_GETFREQ;\nextern unsigned IOCTL_METEORSACTPIXFMT;\nextern unsigned IOCTL_METEORGACTPIXFMT;\nextern unsigned IOCTL_METEORGSUPPIXFMT;\nextern unsigned IOCTL_TVTUNER_GETCHNLSET;\nextern unsigned IOCTL_REMOTE_GETKEY;\nextern unsigned IOCTL_GDT_IOCTL_GENERAL;\nextern unsigned IOCTL_GDT_IOCTL_DRVERS;\nextern unsigned IOCTL_GDT_IOCTL_CTRTYPE;\nextern unsigned IOCTL_GDT_IOCTL_OSVERS;\nextern unsigned IOCTL_GDT_IOCTL_CTRCNT;\nextern unsigned IOCTL_GDT_IOCTL_EVENT;\nextern unsigned IOCTL_GDT_IOCTL_STATIST;\nextern unsigned IOCTL_GDT_IOCTL_RESCAN;\nextern unsigned IOCTL_ISP_SDBLEV;\nextern unsigned IOCTL_ISP_RESETHBA;\nextern unsigned IOCTL_ISP_RESCAN;\nextern unsigned IOCTL_ISP_SETROLE;\nextern unsigned IOCTL_ISP_GETROLE;\nextern unsigned IOCTL_ISP_GET_STATS;\nextern unsigned IOCTL_ISP_CLR_STATS;\nextern unsigned IOCTL_ISP_FC_LIP;\nextern unsigned IOCTL_ISP_FC_GETDINFO;\nextern unsigned IOCTL_ISP_GET_FW_CRASH_DUMP;\nextern unsigned IOCTL_ISP_FORCE_CRASH_DUMP;\nextern unsigned IOCTL_ISP_FC_GETHINFO;\nextern unsigned IOCTL_ISP_TSK_MGMT;\nextern unsigned IOCTL_ISP_FC_GETDLIST;\nextern unsigned IOCTL_MLXD_STATUS;\nextern unsigned IOCTL_MLXD_CHECKASYNC;\nextern unsigned IOCTL_MLXD_DETACH;\nextern unsigned IOCTL_MLX_RESCAN_DRIVES;\nextern unsigned IOCTL_MLX_PAUSE_CHANNEL;\nextern unsigned IOCTL_MLX_COMMAND;\nextern unsigned IOCTL_MLX_REBUILDASYNC;\nextern unsigned IOCTL_MLX_REBUILDSTAT;\nextern unsigned IOCTL_MLX_GET_SYSDRIVE;\nextern unsigned IOCTL_MLX_GET_CINFO;\nextern unsigned IOCTL_NVME_PASSTHROUGH_CMD;\nextern unsigned IOCTL_FWCFGIO_SET_INDEX;\nextern unsigned IOCTL_IRDA_RESET_PARAMS;\nextern unsigned IOCTL_IRDA_SET_PARAMS;\nextern unsigned IOCTL_IRDA_GET_SPEEDMASK;\nextern unsigned IOCTL_IRDA_GET_TURNAROUNDMASK;\nextern unsigned IOCTL_IRFRAMETTY_GET_DEVICE;\nextern unsigned IOCTL_IRFRAMETTY_GET_DONGLE;\nextern unsigned IOCTL_IRFRAMETTY_SET_DONGLE;\nextern unsigned IOCTL_ISV_CMD;\nextern unsigned IOCTL_WTQICMD;\nextern unsigned IOCTL_ISCSI_GET_VERSION;\nextern unsigned IOCTL_ISCSI_LOGIN;\nextern unsigned IOCTL_ISCSI_LOGOUT;\nextern unsigned IOCTL_ISCSI_ADD_CONNECTION;\nextern unsigned IOCTL_ISCSI_RESTORE_CONNECTION;\nextern unsigned IOCTL_ISCSI_REMOVE_CONNECTION;\nextern unsigned IOCTL_ISCSI_CONNECTION_STATUS;\nextern unsigned IOCTL_ISCSI_SEND_TARGETS;\nextern unsigned IOCTL_ISCSI_SET_NODE_NAME;\nextern unsigned IOCTL_ISCSI_IO_COMMAND;\nextern unsigned IOCTL_ISCSI_REGISTER_EVENT;\nextern unsigned IOCTL_ISCSI_DEREGISTER_EVENT;\nextern unsigned IOCTL_ISCSI_WAIT_EVENT;\nextern unsigned IOCTL_ISCSI_POLL_EVENT;\nextern unsigned IOCTL_OFIOCGET;\nextern unsigned IOCTL_OFIOCSET;\nextern unsigned IOCTL_OFIOCNEXTPROP;\nextern unsigned IOCTL_OFIOCGETOPTNODE;\nextern unsigned IOCTL_OFIOCGETNEXT;\nextern unsigned IOCTL_OFIOCGETCHILD;\nextern unsigned IOCTL_OFIOCFINDDEVICE;\nextern unsigned IOCTL_AMR_IO_VERSION;\nextern unsigned IOCTL_AMR_IO_COMMAND;\nextern unsigned IOCTL_MLYIO_COMMAND;\nextern unsigned IOCTL_MLYIO_HEALTH;\nextern unsigned IOCTL_PCI_IOC_CFGREAD;\nextern unsigned IOCTL_PCI_IOC_CFGWRITE;\nextern unsigned IOCTL_PCI_IOC_BDF_CFGREAD;\nextern unsigned IOCTL_PCI_IOC_BDF_CFGWRITE;\nextern unsigned IOCTL_PCI_IOC_BUSINFO;\nextern unsigned IOCTL_PCI_IOC_DRVNAME;\nextern unsigned IOCTL_PCI_IOC_DRVNAMEONBUS;\nextern unsigned IOCTL_TWEIO_COMMAND;\nextern unsigned IOCTL_TWEIO_STATS;\nextern unsigned IOCTL_TWEIO_AEN_POLL;\nextern unsigned IOCTL_TWEIO_AEN_WAIT;\nextern unsigned IOCTL_TWEIO_SET_PARAM;\nextern unsigned IOCTL_TWEIO_GET_PARAM;\nextern unsigned IOCTL_TWEIO_RESET;\nextern unsigned IOCTL_TWEIO_ADD_UNIT;\nextern unsigned IOCTL_TWEIO_DEL_UNIT;\nextern unsigned IOCTL_SIOCSCNWDOMAIN;\nextern unsigned IOCTL_SIOCGCNWDOMAIN;\nextern unsigned IOCTL_SIOCSCNWKEY;\nextern unsigned IOCTL_SIOCGCNWSTATUS;\nextern unsigned IOCTL_SIOCGCNWSTATS;\nextern unsigned IOCTL_SIOCGCNWTRAIL;\nextern unsigned IOCTL_SIOCGRAYSIGLEV;\nextern unsigned IOCTL_RAIDFRAME_SHUTDOWN;\nextern unsigned IOCTL_RAIDFRAME_TUR;\nextern unsigned IOCTL_RAIDFRAME_FAIL_DISK;\nextern unsigned IOCTL_RAIDFRAME_CHECK_RECON_STATUS;\nextern unsigned IOCTL_RAIDFRAME_REWRITEPARITY;\nextern unsigned IOCTL_RAIDFRAME_COPYBACK;\nextern unsigned IOCTL_RAIDFRAME_SPARET_WAIT;\nextern unsigned IOCTL_RAIDFRAME_SEND_SPARET;\nextern unsigned IOCTL_RAIDFRAME_ABORT_SPARET_WAIT;\nextern unsigned IOCTL_RAIDFRAME_START_ATRACE;\nextern unsigned IOCTL_RAIDFRAME_STOP_ATRACE;\nextern unsigned IOCTL_RAIDFRAME_GET_SIZE;\nextern unsigned IOCTL_RAIDFRAME_RESET_ACCTOTALS;\nextern unsigned IOCTL_RAIDFRAME_KEEP_ACCTOTALS;\nextern unsigned IOCTL_RAIDFRAME_GET_COMPONENT_LABEL;\nextern unsigned IOCTL_RAIDFRAME_SET_COMPONENT_LABEL;\nextern unsigned IOCTL_RAIDFRAME_INIT_LABELS;\nextern unsigned IOCTL_RAIDFRAME_ADD_HOT_SPARE;\nextern unsigned IOCTL_RAIDFRAME_REMOVE_HOT_SPARE;\nextern unsigned IOCTL_RAIDFRAME_REBUILD_IN_PLACE;\nextern unsigned IOCTL_RAIDFRAME_CHECK_PARITY;\nextern unsigned IOCTL_RAIDFRAME_CHECK_PARITYREWRITE_STATUS;\nextern unsigned IOCTL_RAIDFRAME_CHECK_COPYBACK_STATUS;\nextern unsigned IOCTL_RAIDFRAME_SET_AUTOCONFIG;\nextern unsigned IOCTL_RAIDFRAME_SET_ROOT;\nextern unsigned IOCTL_RAIDFRAME_DELETE_COMPONENT;\nextern unsigned IOCTL_RAIDFRAME_INCORPORATE_HOT_SPARE;\nextern unsigned IOCTL_RAIDFRAME_CHECK_RECON_STATUS_EXT;\nextern unsigned IOCTL_RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT;\nextern unsigned IOCTL_RAIDFRAME_CHECK_COPYBACK_STATUS_EXT;\nextern unsigned IOCTL_RAIDFRAME_CONFIGURE;\nextern unsigned IOCTL_RAIDFRAME_GET_INFO;\nextern unsigned IOCTL_RAIDFRAME_PARITYMAP_STATUS;\nextern unsigned IOCTL_RAIDFRAME_PARITYMAP_GET_DISABLE;\nextern unsigned IOCTL_RAIDFRAME_PARITYMAP_SET_DISABLE;\nextern unsigned IOCTL_RAIDFRAME_PARITYMAP_SET_PARAMS;\nextern unsigned IOCTL_RAIDFRAME_SET_LAST_UNIT;\nextern unsigned IOCTL_MBPPIOCSPARAM;\nextern unsigned IOCTL_MBPPIOCGPARAM;\nextern unsigned IOCTL_MBPPIOCGSTAT;\nextern unsigned IOCTL_SESIOC_GETNOBJ;\nextern unsigned IOCTL_SESIOC_GETOBJMAP;\nextern unsigned IOCTL_SESIOC_GETENCSTAT;\nextern unsigned IOCTL_SESIOC_SETENCSTAT;\nextern unsigned IOCTL_SESIOC_GETOBJSTAT;\nextern unsigned IOCTL_SESIOC_SETOBJSTAT;\nextern unsigned IOCTL_SESIOC_GETTEXT;\nextern unsigned IOCTL_SESIOC_INIT;\nextern unsigned IOCTL_SUN_DKIOCGGEOM;\nextern unsigned IOCTL_SUN_DKIOCINFO;\nextern unsigned IOCTL_SUN_DKIOCGPART;\nextern unsigned IOCTL_FBIOGTYPE;\nextern unsigned IOCTL_FBIOPUTCMAP;\nextern unsigned IOCTL_FBIOGETCMAP;\nextern unsigned IOCTL_FBIOGATTR;\nextern unsigned IOCTL_FBIOSVIDEO;\nextern unsigned IOCTL_FBIOGVIDEO;\nextern unsigned IOCTL_FBIOSCURSOR;\nextern unsigned IOCTL_FBIOGCURSOR;\nextern unsigned IOCTL_FBIOSCURPOS;\nextern unsigned IOCTL_FBIOGCURPOS;\nextern unsigned IOCTL_FBIOGCURMAX;\nextern unsigned IOCTL_KIOCTRANS;\nextern unsigned IOCTL_KIOCSETKEY;\nextern unsigned IOCTL_KIOCGETKEY;\nextern unsigned IOCTL_KIOCGTRANS;\nextern unsigned IOCTL_KIOCCMD;\nextern unsigned IOCTL_KIOCTYPE;\nextern unsigned IOCTL_KIOCSDIRECT;\nextern unsigned IOCTL_KIOCSKEY;\nextern unsigned IOCTL_KIOCGKEY;\nextern unsigned IOCTL_KIOCSLED;\nextern unsigned IOCTL_KIOCGLED;\nextern unsigned IOCTL_KIOCLAYOUT;\nextern unsigned IOCTL_VUIDSFORMAT;\nextern unsigned IOCTL_VUIDGFORMAT;\nextern unsigned IOCTL_STICIO_GXINFO;\nextern unsigned IOCTL_STICIO_RESET;\nextern unsigned IOCTL_STICIO_STARTQ;\nextern unsigned IOCTL_STICIO_STOPQ;\nextern unsigned IOCTL_UKYOPON_IDENTIFY;\nextern unsigned IOCTL_URIO_SEND_COMMAND;\nextern unsigned IOCTL_URIO_RECV_COMMAND;\nextern unsigned IOCTL_USB_REQUEST;\nextern unsigned IOCTL_USB_SETDEBUG;\nextern unsigned IOCTL_USB_DISCOVER;\nextern unsigned IOCTL_USB_DEVICEINFO;\nextern unsigned IOCTL_USB_DEVICEINFO_OLD;\nextern unsigned IOCTL_USB_DEVICESTATS;\nextern unsigned IOCTL_USB_GET_REPORT_DESC;\nextern unsigned IOCTL_USB_SET_IMMED;\nextern unsigned IOCTL_USB_GET_REPORT;\nextern unsigned IOCTL_USB_SET_REPORT;\nextern unsigned IOCTL_USB_GET_REPORT_ID;\nextern unsigned IOCTL_USB_GET_CONFIG;\nextern unsigned IOCTL_USB_SET_CONFIG;\nextern unsigned IOCTL_USB_GET_ALTINTERFACE;\nextern unsigned IOCTL_USB_SET_ALTINTERFACE;\nextern unsigned IOCTL_USB_GET_NO_ALT;\nextern unsigned IOCTL_USB_GET_DEVICE_DESC;\nextern unsigned IOCTL_USB_GET_CONFIG_DESC;\nextern unsigned IOCTL_USB_GET_INTERFACE_DESC;\nextern unsigned IOCTL_USB_GET_ENDPOINT_DESC;\nextern unsigned IOCTL_USB_GET_FULL_DESC;\nextern unsigned IOCTL_USB_GET_STRING_DESC;\nextern unsigned IOCTL_USB_DO_REQUEST;\nextern unsigned IOCTL_USB_GET_DEVICEINFO;\nextern unsigned IOCTL_USB_GET_DEVICEINFO_OLD;\nextern unsigned IOCTL_USB_SET_SHORT_XFER;\nextern unsigned IOCTL_USB_SET_TIMEOUT;\nextern unsigned IOCTL_USB_SET_BULK_RA;\nextern unsigned IOCTL_USB_SET_BULK_WB;\nextern unsigned IOCTL_USB_SET_BULK_RA_OPT;\nextern unsigned IOCTL_USB_SET_BULK_WB_OPT;\nextern unsigned IOCTL_USB_GET_CM_OVER_DATA;\nextern unsigned IOCTL_USB_SET_CM_OVER_DATA;\nextern unsigned IOCTL_UTOPPYIOTURBO;\nextern unsigned IOCTL_UTOPPYIOCANCEL;\nextern unsigned IOCTL_UTOPPYIOREBOOT;\nextern unsigned IOCTL_UTOPPYIOSTATS;\nextern unsigned IOCTL_UTOPPYIORENAME;\nextern unsigned IOCTL_UTOPPYIOMKDIR;\nextern unsigned IOCTL_UTOPPYIODELETE;\nextern unsigned IOCTL_UTOPPYIOREADDIR;\nextern unsigned IOCTL_UTOPPYIOREADFILE;\nextern unsigned IOCTL_UTOPPYIOWRITEFILE;\nextern unsigned IOCTL_DIOSXDCMD;\nextern unsigned IOCTL_VT_OPENQRY;\nextern unsigned IOCTL_VT_SETMODE;\nextern unsigned IOCTL_VT_GETMODE;\nextern unsigned IOCTL_VT_RELDISP;\nextern unsigned IOCTL_VT_ACTIVATE;\nextern unsigned IOCTL_VT_WAITACTIVE;\nextern unsigned IOCTL_VT_GETACTIVE;\nextern unsigned IOCTL_VT_GETSTATE;\nextern unsigned IOCTL_KDGETKBENT;\nextern unsigned IOCTL_KDGKBMODE;\nextern unsigned IOCTL_KDSKBMODE;\nextern unsigned IOCTL_KDMKTONE;\nextern unsigned IOCTL_KDSETMODE;\nextern unsigned IOCTL_KDENABIO;\nextern unsigned IOCTL_KDDISABIO;\nextern unsigned IOCTL_KDGKBTYPE;\nextern unsigned IOCTL_KDGETLED;\nextern unsigned IOCTL_KDSETLED;\nextern unsigned IOCTL_KDSETRAD;\nextern unsigned IOCTL_VGAPCVTID;\nextern unsigned IOCTL_CONS_GETVERS;\nextern unsigned IOCTL_WSKBDIO_GTYPE;\nextern unsigned IOCTL_WSKBDIO_BELL;\nextern unsigned IOCTL_WSKBDIO_COMPLEXBELL;\nextern unsigned IOCTL_WSKBDIO_SETBELL;\nextern unsigned IOCTL_WSKBDIO_GETBELL;\nextern unsigned IOCTL_WSKBDIO_SETDEFAULTBELL;\nextern unsigned IOCTL_WSKBDIO_GETDEFAULTBELL;\nextern unsigned IOCTL_WSKBDIO_SETKEYREPEAT;\nextern unsigned IOCTL_WSKBDIO_GETKEYREPEAT;\nextern unsigned IOCTL_WSKBDIO_SETDEFAULTKEYREPEAT;\nextern unsigned IOCTL_WSKBDIO_GETDEFAULTKEYREPEAT;\nextern unsigned IOCTL_WSKBDIO_SETLEDS;\nextern unsigned IOCTL_WSKBDIO_GETLEDS;\nextern unsigned IOCTL_WSKBDIO_GETMAP;\nextern unsigned IOCTL_WSKBDIO_SETMAP;\nextern unsigned IOCTL_WSKBDIO_GETENCODING;\nextern unsigned IOCTL_WSKBDIO_SETENCODING;\nextern unsigned IOCTL_WSKBDIO_SETMODE;\nextern unsigned IOCTL_WSKBDIO_GETMODE;\nextern unsigned IOCTL_WSKBDIO_SETKEYCLICK;\nextern unsigned IOCTL_WSKBDIO_GETKEYCLICK;\nextern unsigned IOCTL_WSKBDIO_GETSCROLL;\nextern unsigned IOCTL_WSKBDIO_SETSCROLL;\nextern unsigned IOCTL_WSKBDIO_SETVERSION;\nextern unsigned IOCTL_WSMOUSEIO_GTYPE;\nextern unsigned IOCTL_WSMOUSEIO_SRES;\nextern unsigned IOCTL_WSMOUSEIO_SSCALE;\nextern unsigned IOCTL_WSMOUSEIO_SRATE;\nextern unsigned IOCTL_WSMOUSEIO_SCALIBCOORDS;\nextern unsigned IOCTL_WSMOUSEIO_GCALIBCOORDS;\nextern unsigned IOCTL_WSMOUSEIO_GETID;\nextern unsigned IOCTL_WSMOUSEIO_GETREPEAT;\nextern unsigned IOCTL_WSMOUSEIO_SETREPEAT;\nextern unsigned IOCTL_WSMOUSEIO_SETVERSION;\nextern unsigned IOCTL_WSDISPLAYIO_GTYPE;\nextern unsigned IOCTL_WSDISPLAYIO_GINFO;\nextern unsigned IOCTL_WSDISPLAYIO_GETCMAP;\nextern unsigned IOCTL_WSDISPLAYIO_PUTCMAP;\nextern unsigned IOCTL_WSDISPLAYIO_GVIDEO;\nextern unsigned IOCTL_WSDISPLAYIO_SVIDEO;\nextern unsigned IOCTL_WSDISPLAYIO_GCURPOS;\nextern unsigned IOCTL_WSDISPLAYIO_SCURPOS;\nextern unsigned IOCTL_WSDISPLAYIO_GCURMAX;\nextern unsigned IOCTL_WSDISPLAYIO_GCURSOR;\nextern unsigned IOCTL_WSDISPLAYIO_SCURSOR;\nextern unsigned IOCTL_WSDISPLAYIO_GMODE;\nextern unsigned IOCTL_WSDISPLAYIO_SMODE;\nextern unsigned IOCTL_WSDISPLAYIO_LDFONT;\nextern unsigned IOCTL_WSDISPLAYIO_ADDSCREEN;\nextern unsigned IOCTL_WSDISPLAYIO_DELSCREEN;\nextern unsigned IOCTL_WSDISPLAYIO_SFONT;\nextern unsigned IOCTL__O_WSDISPLAYIO_SETKEYBOARD;\nextern unsigned IOCTL_WSDISPLAYIO_GETPARAM;\nextern unsigned IOCTL_WSDISPLAYIO_SETPARAM;\nextern unsigned IOCTL_WSDISPLAYIO_GETACTIVESCREEN;\nextern unsigned IOCTL_WSDISPLAYIO_GETWSCHAR;\nextern unsigned IOCTL_WSDISPLAYIO_PUTWSCHAR;\nextern unsigned IOCTL_WSDISPLAYIO_DGSCROLL;\nextern unsigned IOCTL_WSDISPLAYIO_DSSCROLL;\nextern unsigned IOCTL_WSDISPLAYIO_GMSGATTRS;\nextern unsigned IOCTL_WSDISPLAYIO_SMSGATTRS;\nextern unsigned IOCTL_WSDISPLAYIO_GBORDER;\nextern unsigned IOCTL_WSDISPLAYIO_SBORDER;\nextern unsigned IOCTL_WSDISPLAYIO_SSPLASH;\nextern unsigned IOCTL_WSDISPLAYIO_SPROGRESS;\nextern unsigned IOCTL_WSDISPLAYIO_LINEBYTES;\nextern unsigned IOCTL_WSDISPLAYIO_SETVERSION;\nextern unsigned IOCTL_WSMUXIO_ADD_DEVICE;\nextern unsigned IOCTL_WSMUXIO_REMOVE_DEVICE;\nextern unsigned IOCTL_WSMUXIO_LIST_DEVICES;\nextern unsigned IOCTL_WSMUXIO_INJECTEVENT;\nextern unsigned IOCTL_WSDISPLAYIO_GET_BUSID;\nextern unsigned IOCTL_WSDISPLAYIO_GET_EDID;\nextern unsigned IOCTL_WSDISPLAYIO_SET_POLLING;\nextern unsigned IOCTL_WSDISPLAYIO_GET_FBINFO;\nextern unsigned IOCTL_WSDISPLAYIO_DOBLIT;\nextern unsigned IOCTL_WSDISPLAYIO_WAITBLIT;\nextern unsigned IOCTL_BIOCLOCATE;\nextern unsigned IOCTL_BIOCINQ;\nextern unsigned IOCTL_BIOCDISK_NOVOL;\nextern unsigned IOCTL_BIOCDISK;\nextern unsigned IOCTL_BIOCVOL;\nextern unsigned IOCTL_BIOCALARM;\nextern unsigned IOCTL_BIOCBLINK;\nextern unsigned IOCTL_BIOCSETSTATE;\nextern unsigned IOCTL_BIOCVOLOPS;\nextern unsigned IOCTL_MD_GETCONF;\nextern unsigned IOCTL_MD_SETCONF;\nextern unsigned IOCTL_CCDIOCSET;\nextern unsigned IOCTL_CCDIOCCLR;\nextern unsigned IOCTL_CGDIOCSET;\nextern unsigned IOCTL_CGDIOCCLR;\nextern unsigned IOCTL_CGDIOCGET;\nextern unsigned IOCTL_FSSIOCSET;\nextern unsigned IOCTL_FSSIOCGET;\nextern unsigned IOCTL_FSSIOCCLR;\nextern unsigned IOCTL_FSSIOFSET;\nextern unsigned IOCTL_FSSIOFGET;\nextern unsigned IOCTL_BTDEV_ATTACH;\nextern unsigned IOCTL_BTDEV_DETACH;\nextern unsigned IOCTL_BTSCO_GETINFO;\nextern unsigned IOCTL_KTTCP_IO_SEND;\nextern unsigned IOCTL_KTTCP_IO_RECV;\nextern unsigned IOCTL_IOC_LOCKSTAT_GVERSION;\nextern unsigned IOCTL_IOC_LOCKSTAT_ENABLE;\nextern unsigned IOCTL_IOC_LOCKSTAT_DISABLE;\nextern unsigned IOCTL_VNDIOCSET;\nextern unsigned IOCTL_VNDIOCCLR;\nextern unsigned IOCTL_VNDIOCGET;\nextern unsigned IOCTL_SPKRTONE;\nextern unsigned IOCTL_SPKRTUNE;\nextern unsigned IOCTL_SPKRGETVOL;\nextern unsigned IOCTL_SPKRSETVOL;\n#if defined(__x86_64__)\nextern unsigned IOCTL_NVMM_IOC_CAPABILITY;\nextern unsigned IOCTL_NVMM_IOC_MACHINE_CREATE;\nextern unsigned IOCTL_NVMM_IOC_MACHINE_DESTROY;\nextern unsigned IOCTL_NVMM_IOC_MACHINE_CONFIGURE;\nextern unsigned IOCTL_NVMM_IOC_VCPU_CREATE;\nextern unsigned IOCTL_NVMM_IOC_VCPU_DESTROY;\nextern unsigned IOCTL_NVMM_IOC_VCPU_CONFIGURE;\nextern unsigned IOCTL_NVMM_IOC_VCPU_SETSTATE;\nextern unsigned IOCTL_NVMM_IOC_VCPU_GETSTATE;\nextern unsigned IOCTL_NVMM_IOC_VCPU_INJECT;\nextern unsigned IOCTL_NVMM_IOC_VCPU_RUN;\nextern unsigned IOCTL_NVMM_IOC_GPA_MAP;\nextern unsigned IOCTL_NVMM_IOC_GPA_UNMAP;\nextern unsigned IOCTL_NVMM_IOC_HVA_MAP;\nextern unsigned IOCTL_NVMM_IOC_HVA_UNMAP;\nextern unsigned IOCTL_NVMM_IOC_CTL;\n#endif\nextern unsigned IOCTL_AUTOFSREQUEST;\nextern unsigned IOCTL_AUTOFSDONE;\nextern unsigned IOCTL_BIOCGBLEN;\nextern unsigned IOCTL_BIOCSBLEN;\nextern unsigned IOCTL_BIOCSETF;\nextern unsigned IOCTL_BIOCFLUSH;\nextern unsigned IOCTL_BIOCPROMISC;\nextern unsigned IOCTL_BIOCGDLT;\nextern unsigned IOCTL_BIOCGETIF;\nextern unsigned IOCTL_BIOCSETIF;\nextern unsigned IOCTL_BIOCGSTATS;\nextern unsigned IOCTL_BIOCGSTATSOLD;\nextern unsigned IOCTL_BIOCIMMEDIATE;\nextern unsigned IOCTL_BIOCVERSION;\nextern unsigned IOCTL_BIOCSTCPF;\nextern unsigned IOCTL_BIOCSUDPF;\nextern unsigned IOCTL_BIOCGHDRCMPLT;\nextern unsigned IOCTL_BIOCSHDRCMPLT;\nextern unsigned IOCTL_BIOCSDLT;\nextern unsigned IOCTL_BIOCGDLTLIST;\nextern unsigned IOCTL_BIOCGDIRECTION;\nextern unsigned IOCTL_BIOCSDIRECTION;\nextern unsigned IOCTL_BIOCSRTIMEOUT;\nextern unsigned IOCTL_BIOCGRTIMEOUT;\nextern unsigned IOCTL_BIOCGFEEDBACK;\nextern unsigned IOCTL_BIOCSFEEDBACK;\nextern unsigned IOCTL_GRESADDRS;\nextern unsigned IOCTL_GRESADDRD;\nextern unsigned IOCTL_GREGADDRS;\nextern unsigned IOCTL_GREGADDRD;\nextern unsigned IOCTL_GRESPROTO;\nextern unsigned IOCTL_GREGPROTO;\nextern unsigned IOCTL_GRESSOCK;\nextern unsigned IOCTL_GREDSOCK;\nextern unsigned IOCTL_PPPIOCGRAWIN;\nextern unsigned IOCTL_PPPIOCGFLAGS;\nextern unsigned IOCTL_PPPIOCSFLAGS;\nextern unsigned IOCTL_PPPIOCGASYNCMAP;\nextern unsigned IOCTL_PPPIOCSASYNCMAP;\nextern unsigned IOCTL_PPPIOCGUNIT;\nextern unsigned IOCTL_PPPIOCGRASYNCMAP;\nextern unsigned IOCTL_PPPIOCSRASYNCMAP;\nextern unsigned IOCTL_PPPIOCGMRU;\nextern unsigned IOCTL_PPPIOCSMRU;\nextern unsigned IOCTL_PPPIOCSMAXCID;\nextern unsigned IOCTL_PPPIOCGXASYNCMAP;\nextern unsigned IOCTL_PPPIOCSXASYNCMAP;\nextern unsigned IOCTL_PPPIOCXFERUNIT;\nextern unsigned IOCTL_PPPIOCSCOMPRESS;\nextern unsigned IOCTL_PPPIOCGNPMODE;\nextern unsigned IOCTL_PPPIOCSNPMODE;\nextern unsigned IOCTL_PPPIOCGIDLE;\nextern unsigned IOCTL_PPPIOCGMTU;\nextern unsigned IOCTL_PPPIOCSMTU;\nextern unsigned IOCTL_SIOCGPPPSTATS;\nextern unsigned IOCTL_SIOCGPPPCSTATS;\nextern unsigned IOCTL_IOC_NPF_VERSION;\nextern unsigned IOCTL_IOC_NPF_SWITCH;\nextern unsigned IOCTL_IOC_NPF_LOAD;\nextern unsigned IOCTL_IOC_NPF_TABLE;\nextern unsigned IOCTL_IOC_NPF_STATS;\nextern unsigned IOCTL_IOC_NPF_SAVE;\nextern unsigned IOCTL_IOC_NPF_RULE;\nextern unsigned IOCTL_IOC_NPF_CONN_LOOKUP;\nextern unsigned IOCTL_IOC_NPF_TABLE_REPLACE;\nextern unsigned IOCTL_PPPOESETPARMS;\nextern unsigned IOCTL_PPPOEGETPARMS;\nextern unsigned IOCTL_PPPOEGETSESSION;\nextern unsigned IOCTL_SPPPGETAUTHCFG;\nextern unsigned IOCTL_SPPPSETAUTHCFG;\nextern unsigned IOCTL_SPPPGETLCPCFG;\nextern unsigned IOCTL_SPPPSETLCPCFG;\nextern unsigned IOCTL_SPPPGETSTATUS;\nextern unsigned IOCTL_SPPPGETSTATUSNCP;\nextern unsigned IOCTL_SPPPGETIDLETO;\nextern unsigned IOCTL_SPPPSETIDLETO;\nextern unsigned IOCTL_SPPPGETAUTHFAILURES;\nextern unsigned IOCTL_SPPPSETAUTHFAILURE;\nextern unsigned IOCTL_SPPPSETDNSOPTS;\nextern unsigned IOCTL_SPPPGETDNSOPTS;\nextern unsigned IOCTL_SPPPGETDNSADDRS;\nextern unsigned IOCTL_SPPPSETKEEPALIVE;\nextern unsigned IOCTL_SPPPGETKEEPALIVE;\nextern unsigned IOCTL_SRT_GETNRT;\nextern unsigned IOCTL_SRT_GETRT;\nextern unsigned IOCTL_SRT_SETRT;\nextern unsigned IOCTL_SRT_DELRT;\nextern unsigned IOCTL_SRT_SFLAGS;\nextern unsigned IOCTL_SRT_GFLAGS;\nextern unsigned IOCTL_SRT_SGFLAGS;\nextern unsigned IOCTL_SRT_DEBUG;\nextern unsigned IOCTL_TAPGIFNAME;\nextern unsigned IOCTL_TUNSDEBUG;\nextern unsigned IOCTL_TUNGDEBUG;\nextern unsigned IOCTL_TUNSIFMODE;\nextern unsigned IOCTL_TUNSLMODE;\nextern unsigned IOCTL_TUNSIFHEAD;\nextern unsigned IOCTL_TUNGIFHEAD;\nextern unsigned IOCTL_DIOCSTART;\nextern unsigned IOCTL_DIOCSTOP;\nextern unsigned IOCTL_DIOCADDRULE;\nextern unsigned IOCTL_DIOCGETRULES;\nextern unsigned IOCTL_DIOCGETRULE;\nextern unsigned IOCTL_DIOCSETLCK;\nextern unsigned IOCTL_DIOCCLRSTATES;\nextern unsigned IOCTL_DIOCGETSTATE;\nextern unsigned IOCTL_DIOCSETSTATUSIF;\nextern unsigned IOCTL_DIOCGETSTATUS;\nextern unsigned IOCTL_DIOCCLRSTATUS;\nextern unsigned IOCTL_DIOCNATLOOK;\nextern unsigned IOCTL_DIOCSETDEBUG;\nextern unsigned IOCTL_DIOCGETSTATES;\nextern unsigned IOCTL_DIOCCHANGERULE;\nextern unsigned IOCTL_DIOCSETTIMEOUT;\nextern unsigned IOCTL_DIOCGETTIMEOUT;\nextern unsigned IOCTL_DIOCADDSTATE;\nextern unsigned IOCTL_DIOCCLRRULECTRS;\nextern unsigned IOCTL_DIOCGETLIMIT;\nextern unsigned IOCTL_DIOCSETLIMIT;\nextern unsigned IOCTL_DIOCKILLSTATES;\nextern unsigned IOCTL_DIOCSTARTALTQ;\nextern unsigned IOCTL_DIOCSTOPALTQ;\nextern unsigned IOCTL_DIOCADDALTQ;\nextern unsigned IOCTL_DIOCGETALTQS;\nextern unsigned IOCTL_DIOCGETALTQ;\nextern unsigned IOCTL_DIOCCHANGEALTQ;\nextern unsigned IOCTL_DIOCGETQSTATS;\nextern unsigned IOCTL_DIOCBEGINADDRS;\nextern unsigned IOCTL_DIOCADDADDR;\nextern unsigned IOCTL_DIOCGETADDRS;\nextern unsigned IOCTL_DIOCGETADDR;\nextern unsigned IOCTL_DIOCCHANGEADDR;\nextern unsigned IOCTL_DIOCADDSTATES;\nextern unsigned IOCTL_DIOCGETRULESETS;\nextern unsigned IOCTL_DIOCGETRULESET;\nextern unsigned IOCTL_DIOCRCLRTABLES;\nextern unsigned IOCTL_DIOCRADDTABLES;\nextern unsigned IOCTL_DIOCRDELTABLES;\nextern unsigned IOCTL_DIOCRGETTABLES;\nextern unsigned IOCTL_DIOCRGETTSTATS;\nextern unsigned IOCTL_DIOCRCLRTSTATS;\nextern unsigned IOCTL_DIOCRCLRADDRS;\nextern unsigned IOCTL_DIOCRADDADDRS;\nextern unsigned IOCTL_DIOCRDELADDRS;\nextern unsigned IOCTL_DIOCRSETADDRS;\nextern unsigned IOCTL_DIOCRGETADDRS;\nextern unsigned IOCTL_DIOCRGETASTATS;\nextern unsigned IOCTL_DIOCRCLRASTATS;\nextern unsigned IOCTL_DIOCRTSTADDRS;\nextern unsigned IOCTL_DIOCRSETTFLAGS;\nextern unsigned IOCTL_DIOCRINADEFINE;\nextern unsigned IOCTL_DIOCOSFPFLUSH;\nextern unsigned IOCTL_DIOCOSFPADD;\nextern unsigned IOCTL_DIOCOSFPGET;\nextern unsigned IOCTL_DIOCXBEGIN;\nextern unsigned IOCTL_DIOCXCOMMIT;\nextern unsigned IOCTL_DIOCXROLLBACK;\nextern unsigned IOCTL_DIOCGETSRCNODES;\nextern unsigned IOCTL_DIOCCLRSRCNODES;\nextern unsigned IOCTL_DIOCSETHOSTID;\nextern unsigned IOCTL_DIOCIGETIFACES;\nextern unsigned IOCTL_DIOCSETIFFLAG;\nextern unsigned IOCTL_DIOCCLRIFFLAG;\nextern unsigned IOCTL_DIOCKILLSRCNODES;\nextern unsigned IOCTL_SLIOCGUNIT;\nextern unsigned IOCTL_SIOCGBTINFO;\nextern unsigned IOCTL_SIOCGBTINFOA;\nextern unsigned IOCTL_SIOCNBTINFO;\nextern unsigned IOCTL_SIOCSBTFLAGS;\nextern unsigned IOCTL_SIOCSBTPOLICY;\nextern unsigned IOCTL_SIOCSBTPTYPE;\nextern unsigned IOCTL_SIOCGBTSTATS;\nextern unsigned IOCTL_SIOCZBTSTATS;\nextern unsigned IOCTL_SIOCBTDUMP;\nextern unsigned IOCTL_SIOCSBTSCOMTU;\nextern unsigned IOCTL_SIOCGBTFEAT;\nextern unsigned IOCTL_SIOCADNAT;\nextern unsigned IOCTL_SIOCRMNAT;\nextern unsigned IOCTL_SIOCGNATS;\nextern unsigned IOCTL_SIOCGNATL;\nextern unsigned IOCTL_SIOCPURGENAT;\nextern unsigned IOCTL_SIOCCONNECTX;\nextern unsigned IOCTL_SIOCCONNECTXDEL;\nextern unsigned IOCTL_SIOCSIFINFO_FLAGS;\nextern unsigned IOCTL_SIOCAADDRCTL_POLICY;\nextern unsigned IOCTL_SIOCDADDRCTL_POLICY;\nextern unsigned IOCTL_SMBIOC_OPENSESSION;\nextern unsigned IOCTL_SMBIOC_OPENSHARE;\nextern unsigned IOCTL_SMBIOC_REQUEST;\nextern unsigned IOCTL_SMBIOC_SETFLAGS;\nextern unsigned IOCTL_SMBIOC_LOOKUP;\nextern unsigned IOCTL_SMBIOC_READ;\nextern unsigned IOCTL_SMBIOC_WRITE;\nextern unsigned IOCTL_AGPIOC_INFO;\nextern unsigned IOCTL_AGPIOC_ACQUIRE;\nextern unsigned IOCTL_AGPIOC_RELEASE;\nextern unsigned IOCTL_AGPIOC_SETUP;\nextern unsigned IOCTL_AGPIOC_ALLOCATE;\nextern unsigned IOCTL_AGPIOC_DEALLOCATE;\nextern unsigned IOCTL_AGPIOC_BIND;\nextern unsigned IOCTL_AGPIOC_UNBIND;\nextern unsigned IOCTL_AUDIO_GETINFO;\nextern unsigned IOCTL_AUDIO_SETINFO;\nextern unsigned IOCTL_AUDIO_DRAIN;\nextern unsigned IOCTL_AUDIO_FLUSH;\nextern unsigned IOCTL_AUDIO_WSEEK;\nextern unsigned IOCTL_AUDIO_RERROR;\nextern unsigned IOCTL_AUDIO_GETDEV;\nextern unsigned IOCTL_AUDIO_GETENC;\nextern unsigned IOCTL_AUDIO_GETFD;\nextern unsigned IOCTL_AUDIO_SETFD;\nextern unsigned IOCTL_AUDIO_PERROR;\nextern unsigned IOCTL_AUDIO_GETIOFFS;\nextern unsigned IOCTL_AUDIO_GETOOFFS;\nextern unsigned IOCTL_AUDIO_GETPROPS;\nextern unsigned IOCTL_AUDIO_GETBUFINFO;\nextern unsigned IOCTL_AUDIO_SETCHAN;\nextern unsigned IOCTL_AUDIO_GETCHAN;\nextern unsigned IOCTL_AUDIO_QUERYFORMAT;\nextern unsigned IOCTL_AUDIO_GETFORMAT;\nextern unsigned IOCTL_AUDIO_SETFORMAT;\nextern unsigned IOCTL_AUDIO_MIXER_READ;\nextern unsigned IOCTL_AUDIO_MIXER_WRITE;\nextern unsigned IOCTL_AUDIO_MIXER_DEVINFO;\nextern unsigned IOCTL_ATAIOCCOMMAND;\nextern unsigned IOCTL_ATABUSIOSCAN;\nextern unsigned IOCTL_ATABUSIORESET;\nextern unsigned IOCTL_ATABUSIODETACH;\nextern unsigned IOCTL_CDIOCPLAYTRACKS;\nextern unsigned IOCTL_CDIOCPLAYBLOCKS;\nextern unsigned IOCTL_CDIOCREADSUBCHANNEL;\nextern unsigned IOCTL_CDIOREADTOCHEADER;\nextern unsigned IOCTL_CDIOREADTOCENTRIES;\nextern unsigned IOCTL_CDIOREADMSADDR;\nextern unsigned IOCTL_CDIOCSETPATCH;\nextern unsigned IOCTL_CDIOCGETVOL;\nextern unsigned IOCTL_CDIOCSETVOL;\nextern unsigned IOCTL_CDIOCSETMONO;\nextern unsigned IOCTL_CDIOCSETSTEREO;\nextern unsigned IOCTL_CDIOCSETMUTE;\nextern unsigned IOCTL_CDIOCSETLEFT;\nextern unsigned IOCTL_CDIOCSETRIGHT;\nextern unsigned IOCTL_CDIOCSETDEBUG;\nextern unsigned IOCTL_CDIOCCLRDEBUG;\nextern unsigned IOCTL_CDIOCPAUSE;\nextern unsigned IOCTL_CDIOCRESUME;\nextern unsigned IOCTL_CDIOCRESET;\nextern unsigned IOCTL_CDIOCSTART;\nextern unsigned IOCTL_CDIOCSTOP;\nextern unsigned IOCTL_CDIOCEJECT;\nextern unsigned IOCTL_CDIOCALLOW;\nextern unsigned IOCTL_CDIOCPREVENT;\nextern unsigned IOCTL_CDIOCCLOSE;\nextern unsigned IOCTL_CDIOCPLAYMSF;\nextern unsigned IOCTL_CDIOCLOADUNLOAD;\nextern unsigned IOCTL_CHIOMOVE;\nextern unsigned IOCTL_CHIOEXCHANGE;\nextern unsigned IOCTL_CHIOPOSITION;\nextern unsigned IOCTL_CHIOGPICKER;\nextern unsigned IOCTL_CHIOSPICKER;\nextern unsigned IOCTL_CHIOGPARAMS;\nextern unsigned IOCTL_CHIOIELEM;\nextern unsigned IOCTL_OCHIOGSTATUS;\nextern unsigned IOCTL_CHIOGSTATUS;\nextern unsigned IOCTL_CHIOSVOLTAG;\nextern unsigned IOCTL_CLOCKCTL_SETTIMEOFDAY;\nextern unsigned IOCTL_CLOCKCTL_ADJTIME;\nextern unsigned IOCTL_CLOCKCTL_CLOCK_SETTIME;\nextern unsigned IOCTL_CLOCKCTL_NTP_ADJTIME;\nextern unsigned IOCTL_IOC_CPU_SETSTATE;\nextern unsigned IOCTL_IOC_CPU_GETSTATE;\nextern unsigned IOCTL_IOC_CPU_GETCOUNT;\nextern unsigned IOCTL_IOC_CPU_MAPID;\nextern unsigned IOCTL_IOC_CPU_UCODE_GET_VERSION;\nextern unsigned IOCTL_IOC_CPU_UCODE_APPLY;\nextern unsigned IOCTL_DIOCGDINFO;\nextern unsigned IOCTL_DIOCSDINFO;\nextern unsigned IOCTL_DIOCWDINFO;\nextern unsigned IOCTL_DIOCRFORMAT;\nextern unsigned IOCTL_DIOCWFORMAT;\nextern unsigned IOCTL_DIOCSSTEP;\nextern unsigned IOCTL_DIOCSRETRIES;\nextern unsigned IOCTL_DIOCKLABEL;\nextern unsigned IOCTL_DIOCWLABEL;\nextern unsigned IOCTL_DIOCSBAD;\nextern unsigned IOCTL_DIOCEJECT;\nextern unsigned IOCTL_ODIOCEJECT;\nextern unsigned IOCTL_DIOCLOCK;\nextern unsigned IOCTL_DIOCGDEFLABEL;\nextern unsigned IOCTL_DIOCCLRLABEL;\nextern unsigned IOCTL_DIOCGCACHE;\nextern unsigned IOCTL_DIOCSCACHE;\nextern unsigned IOCTL_DIOCCACHESYNC;\nextern unsigned IOCTL_DIOCBSLIST;\nextern unsigned IOCTL_DIOCBSFLUSH;\nextern unsigned IOCTL_DIOCAWEDGE;\nextern unsigned IOCTL_DIOCGWEDGEINFO;\nextern unsigned IOCTL_DIOCDWEDGE;\nextern unsigned IOCTL_DIOCLWEDGES;\nextern unsigned IOCTL_DIOCGSTRATEGY;\nextern unsigned IOCTL_DIOCSSTRATEGY;\nextern unsigned IOCTL_DIOCGDISKINFO;\nextern unsigned IOCTL_DIOCTUR;\nextern unsigned IOCTL_DIOCMWEDGES;\nextern unsigned IOCTL_DIOCGSECTORSIZE;\nextern unsigned IOCTL_DIOCGMEDIASIZE;\nextern unsigned IOCTL_DIOCRMWEDGES;\nextern unsigned IOCTL_DRVDETACHDEV;\nextern unsigned IOCTL_DRVRESCANBUS;\nextern unsigned IOCTL_DRVCTLCOMMAND;\nextern unsigned IOCTL_DRVRESUMEDEV;\nextern unsigned IOCTL_DRVLISTDEV;\nextern unsigned IOCTL_DRVGETEVENT;\nextern unsigned IOCTL_DRVSUSPENDDEV;\nextern unsigned IOCTL_DVD_READ_STRUCT;\nextern unsigned IOCTL_DVD_WRITE_STRUCT;\nextern unsigned IOCTL_DVD_AUTH;\nextern unsigned IOCTL_ENVSYS_GETDICTIONARY;\nextern unsigned IOCTL_ENVSYS_SETDICTIONARY;\nextern unsigned IOCTL_ENVSYS_REMOVEPROPS;\nextern unsigned IOCTL_ENVSYS_GTREDATA;\nextern unsigned IOCTL_ENVSYS_GTREINFO;\nextern unsigned IOCTL_KFILTER_BYFILTER;\nextern unsigned IOCTL_KFILTER_BYNAME;\nextern unsigned IOCTL_FDIOCGETOPTS;\nextern unsigned IOCTL_FDIOCSETOPTS;\nextern unsigned IOCTL_FDIOCSETFORMAT;\nextern unsigned IOCTL_FDIOCGETFORMAT;\nextern unsigned IOCTL_FDIOCFORMAT_TRACK;\nextern unsigned IOCTL_FIOCLEX;\nextern unsigned IOCTL_FIONCLEX;\nextern unsigned IOCTL_FIOSEEKDATA;\nextern unsigned IOCTL_FIOSEEKHOLE;\nextern unsigned IOCTL_FIONREAD;\nextern unsigned IOCTL_FIONBIO;\nextern unsigned IOCTL_FIOASYNC;\nextern unsigned IOCTL_FIOSETOWN;\nextern unsigned IOCTL_FIOGETOWN;\nextern unsigned IOCTL_OFIOGETBMAP;\nextern unsigned IOCTL_FIOGETBMAP;\nextern unsigned IOCTL_FIONWRITE;\nextern unsigned IOCTL_FIONSPACE;\nextern unsigned IOCTL_GPIOINFO;\nextern unsigned IOCTL_GPIOSET;\nextern unsigned IOCTL_GPIOUNSET;\nextern unsigned IOCTL_GPIOREAD;\nextern unsigned IOCTL_GPIOWRITE;\nextern unsigned IOCTL_GPIOTOGGLE;\nextern unsigned IOCTL_GPIOATTACH;\nextern unsigned IOCTL_PTIOCNETBSD;\nextern unsigned IOCTL_PTIOCSUNOS;\nextern unsigned IOCTL_PTIOCLINUX;\nextern unsigned IOCTL_PTIOCFREEBSD;\nextern unsigned IOCTL_PTIOCULTRIX;\nextern unsigned IOCTL_TIOCHPCL;\nextern unsigned IOCTL_TIOCGETP;\nextern unsigned IOCTL_TIOCSETP;\nextern unsigned IOCTL_TIOCSETN;\nextern unsigned IOCTL_TIOCSETC;\nextern unsigned IOCTL_TIOCGETC;\nextern unsigned IOCTL_TIOCLBIS;\nextern unsigned IOCTL_TIOCLBIC;\nextern unsigned IOCTL_TIOCLSET;\nextern unsigned IOCTL_TIOCLGET;\nextern unsigned IOCTL_TIOCSLTC;\nextern unsigned IOCTL_TIOCGLTC;\nextern unsigned IOCTL_OTIOCCONS;\nextern unsigned IOCTL_JOY_SETTIMEOUT;\nextern unsigned IOCTL_JOY_GETTIMEOUT;\nextern unsigned IOCTL_JOY_SET_X_OFFSET;\nextern unsigned IOCTL_JOY_SET_Y_OFFSET;\nextern unsigned IOCTL_JOY_GET_X_OFFSET;\nextern unsigned IOCTL_JOY_GET_Y_OFFSET;\nextern unsigned IOCTL_OKIOCGSYMBOL;\nextern unsigned IOCTL_OKIOCGVALUE;\nextern unsigned IOCTL_KIOCGSIZE;\nextern unsigned IOCTL_KIOCGVALUE;\nextern unsigned IOCTL_KIOCGSYMBOL;\nextern unsigned IOCTL_LUAINFO;\nextern unsigned IOCTL_LUACREATE;\nextern unsigned IOCTL_LUADESTROY;\nextern unsigned IOCTL_LUAREQUIRE;\nextern unsigned IOCTL_LUALOAD;\nextern unsigned IOCTL_MIDI_PRETIME;\nextern unsigned IOCTL_MIDI_MPUMODE;\nextern unsigned IOCTL_MIDI_MPUCMD;\nextern unsigned IOCTL_SEQUENCER_RESET;\nextern unsigned IOCTL_SEQUENCER_SYNC;\nextern unsigned IOCTL_SEQUENCER_INFO;\nextern unsigned IOCTL_SEQUENCER_CTRLRATE;\nextern unsigned IOCTL_SEQUENCER_GETOUTCOUNT;\nextern unsigned IOCTL_SEQUENCER_GETINCOUNT;\nextern unsigned IOCTL_SEQUENCER_RESETSAMPLES;\nextern unsigned IOCTL_SEQUENCER_NRSYNTHS;\nextern unsigned IOCTL_SEQUENCER_NRMIDIS;\nextern unsigned IOCTL_SEQUENCER_THRESHOLD;\nextern unsigned IOCTL_SEQUENCER_MEMAVL;\nextern unsigned IOCTL_SEQUENCER_PANIC;\nextern unsigned IOCTL_SEQUENCER_OUTOFBAND;\nextern unsigned IOCTL_SEQUENCER_GETTIME;\nextern unsigned IOCTL_SEQUENCER_TMR_TIMEBASE;\nextern unsigned IOCTL_SEQUENCER_TMR_START;\nextern unsigned IOCTL_SEQUENCER_TMR_STOP;\nextern unsigned IOCTL_SEQUENCER_TMR_CONTINUE;\nextern unsigned IOCTL_SEQUENCER_TMR_TEMPO;\nextern unsigned IOCTL_SEQUENCER_TMR_SOURCE;\nextern unsigned IOCTL_SEQUENCER_TMR_METRONOME;\nextern unsigned IOCTL_SEQUENCER_TMR_SELECT;\nextern unsigned IOCTL_SPI_IOCTL_CONFIGURE;\nextern unsigned IOCTL_SPI_IOCTL_TRANSFER;\nextern unsigned IOCTL_MTIOCTOP;\nextern unsigned IOCTL_MTIOCGET;\nextern unsigned IOCTL_MTIOCIEOT;\nextern unsigned IOCTL_MTIOCEEOT;\nextern unsigned IOCTL_MTIOCRDSPOS;\nextern unsigned IOCTL_MTIOCRDHPOS;\nextern unsigned IOCTL_MTIOCSLOCATE;\nextern unsigned IOCTL_MTIOCHLOCATE;\nextern unsigned IOCTL_POWER_EVENT_RECVDICT;\nextern unsigned IOCTL_POWER_IOC_GET_TYPE;\nextern unsigned IOCTL_RIOCGINFO;\nextern unsigned IOCTL_RIOCSINFO;\nextern unsigned IOCTL_RIOCSSRCH;\nextern unsigned IOCTL_RNDGETENTCNT;\nextern unsigned IOCTL_RNDGETSRCNUM;\nextern unsigned IOCTL_RNDGETSRCNAME;\nextern unsigned IOCTL_RNDCTL;\nextern unsigned IOCTL_RNDADDDATA;\nextern unsigned IOCTL_RNDGETPOOLSTAT;\nextern unsigned IOCTL_RNDGETESTNUM;\nextern unsigned IOCTL_RNDGETESTNAME;\nextern unsigned IOCTL_SCIOCGET;\nextern unsigned IOCTL_SCIOCSET;\nextern unsigned IOCTL_SCIOCRESTART;\nextern unsigned IOCTL_SCIOC_USE_ADF;\nextern unsigned IOCTL_SCIOCCOMMAND;\nextern unsigned IOCTL_SCIOCDEBUG;\nextern unsigned IOCTL_SCIOCIDENTIFY;\nextern unsigned IOCTL_OSCIOCIDENTIFY;\nextern unsigned IOCTL_SCIOCDECONFIG;\nextern unsigned IOCTL_SCIOCRECONFIG;\nextern unsigned IOCTL_SCIOCRESET;\nextern unsigned IOCTL_SCBUSIOSCAN;\nextern unsigned IOCTL_SCBUSIORESET;\nextern unsigned IOCTL_SCBUSIODETACH;\nextern unsigned IOCTL_SCBUSACCEL;\nextern unsigned IOCTL_SCBUSIOLLSCAN;\nextern unsigned IOCTL_SIOCSHIWAT;\nextern unsigned IOCTL_SIOCGHIWAT;\nextern unsigned IOCTL_SIOCSLOWAT;\nextern unsigned IOCTL_SIOCGLOWAT;\nextern unsigned IOCTL_SIOCATMARK;\nextern unsigned IOCTL_SIOCSPGRP;\nextern unsigned IOCTL_SIOCGPGRP;\nextern unsigned IOCTL_SIOCPEELOFF;\nextern unsigned IOCTL_SIOCADDRT;\nextern unsigned IOCTL_SIOCDELRT;\nextern unsigned IOCTL_SIOCSIFADDR;\nextern unsigned IOCTL_SIOCGIFADDR;\nextern unsigned IOCTL_SIOCSIFDSTADDR;\nextern unsigned IOCTL_SIOCGIFDSTADDR;\nextern unsigned IOCTL_SIOCSIFFLAGS;\nextern unsigned IOCTL_SIOCGIFFLAGS;\nextern unsigned IOCTL_SIOCGIFBRDADDR;\nextern unsigned IOCTL_SIOCSIFBRDADDR;\nextern unsigned IOCTL_SIOCGIFCONF;\nextern unsigned IOCTL_SIOCGIFNETMASK;\nextern unsigned IOCTL_SIOCSIFNETMASK;\nextern unsigned IOCTL_SIOCGIFMETRIC;\nextern unsigned IOCTL_SIOCSIFMETRIC;\nextern unsigned IOCTL_SIOCDIFADDR;\nextern unsigned IOCTL_SIOCAIFADDR;\nextern unsigned IOCTL_SIOCGIFALIAS;\nextern unsigned IOCTL_SIOCGIFAFLAG_IN;\nextern unsigned IOCTL_SIOCALIFADDR;\nextern unsigned IOCTL_SIOCGLIFADDR;\nextern unsigned IOCTL_SIOCDLIFADDR;\nextern unsigned IOCTL_SIOCSIFADDRPREF;\nextern unsigned IOCTL_SIOCGIFADDRPREF;\nextern unsigned IOCTL_SIOCADDMULTI;\nextern unsigned IOCTL_SIOCDELMULTI;\nextern unsigned IOCTL_SIOCGETVIFCNT;\nextern unsigned IOCTL_SIOCGETSGCNT;\nextern unsigned IOCTL_SIOCSIFMEDIA;\nextern unsigned IOCTL_SIOCGIFMEDIA;\nextern unsigned IOCTL_SIOCSIFGENERIC;\nextern unsigned IOCTL_SIOCGIFGENERIC;\nextern unsigned IOCTL_SIOCSIFPHYADDR;\nextern unsigned IOCTL_SIOCGIFPSRCADDR;\nextern unsigned IOCTL_SIOCGIFPDSTADDR;\nextern unsigned IOCTL_SIOCDIFPHYADDR;\nextern unsigned IOCTL_SIOCSLIFPHYADDR;\nextern unsigned IOCTL_SIOCGLIFPHYADDR;\nextern unsigned IOCTL_SIOCSIFMTU;\nextern unsigned IOCTL_SIOCGIFMTU;\nextern unsigned IOCTL_SIOCSDRVSPEC;\nextern unsigned IOCTL_SIOCGDRVSPEC;\nextern unsigned IOCTL_SIOCIFCREATE;\nextern unsigned IOCTL_SIOCIFDESTROY;\nextern unsigned IOCTL_SIOCIFGCLONERS;\nextern unsigned IOCTL_SIOCGIFDLT;\nextern unsigned IOCTL_SIOCGIFCAP;\nextern unsigned IOCTL_SIOCSIFCAP;\nextern unsigned IOCTL_SIOCSVH;\nextern unsigned IOCTL_SIOCGVH;\nextern unsigned IOCTL_SIOCINITIFADDR;\nextern unsigned IOCTL_SIOCGIFDATA;\nextern unsigned IOCTL_SIOCZIFDATA;\nextern unsigned IOCTL_SIOCGLINKSTR;\nextern unsigned IOCTL_SIOCSLINKSTR;\nextern unsigned IOCTL_SIOCGETHERCAP;\nextern unsigned IOCTL_SIOCGIFINDEX;\nextern unsigned IOCTL_SIOCSETHERCAP;\nextern unsigned IOCTL_SIOCSIFDESCR;\nextern unsigned IOCTL_SIOCGIFDESCR;\nextern unsigned IOCTL_SIOCGUMBINFO;\nextern unsigned IOCTL_SIOCSUMBPARAM;\nextern unsigned IOCTL_SIOCGUMBPARAM;\nextern unsigned IOCTL_SIOCSETPFSYNC;\nextern unsigned IOCTL_SIOCGETPFSYNC;\nextern unsigned IOCTL_PPS_IOC_CREATE;\nextern unsigned IOCTL_PPS_IOC_DESTROY;\nextern unsigned IOCTL_PPS_IOC_SETPARAMS;\nextern unsigned IOCTL_PPS_IOC_GETPARAMS;\nextern unsigned IOCTL_PPS_IOC_GETCAP;\nextern unsigned IOCTL_PPS_IOC_FETCH;\nextern unsigned IOCTL_PPS_IOC_KCBIND;\nextern unsigned IOCTL_TIOCEXCL;\nextern unsigned IOCTL_TIOCNXCL;\nextern unsigned IOCTL_TIOCFLUSH;\nextern unsigned IOCTL_TIOCGETA;\nextern unsigned IOCTL_TIOCSETA;\nextern unsigned IOCTL_TIOCSETAW;\nextern unsigned IOCTL_TIOCSETAF;\nextern unsigned IOCTL_TIOCGETD;\nextern unsigned IOCTL_TIOCSETD;\nextern unsigned IOCTL_TIOCGLINED;\nextern unsigned IOCTL_TIOCSLINED;\nextern unsigned IOCTL_TIOCSBRK;\nextern unsigned IOCTL_TIOCCBRK;\nextern unsigned IOCTL_TIOCSDTR;\nextern unsigned IOCTL_TIOCCDTR;\nextern unsigned IOCTL_TIOCGPGRP;\nextern unsigned IOCTL_TIOCSPGRP;\nextern unsigned IOCTL_TIOCOUTQ;\nextern unsigned IOCTL_TIOCSTI;\nextern unsigned IOCTL_TIOCNOTTY;\nextern unsigned IOCTL_TIOCPKT;\nextern unsigned IOCTL_TIOCSTOP;\nextern unsigned IOCTL_TIOCSTART;\nextern unsigned IOCTL_TIOCMSET;\nextern unsigned IOCTL_TIOCMBIS;\nextern unsigned IOCTL_TIOCMBIC;\nextern unsigned IOCTL_TIOCMGET;\nextern unsigned IOCTL_TIOCREMOTE;\nextern unsigned IOCTL_TIOCGWINSZ;\nextern unsigned IOCTL_TIOCSWINSZ;\nextern unsigned IOCTL_TIOCUCNTL;\nextern unsigned IOCTL_TIOCSTAT;\nextern unsigned IOCTL_TIOCGSID;\nextern unsigned IOCTL_TIOCCONS;\nextern unsigned IOCTL_TIOCSCTTY;\nextern unsigned IOCTL_TIOCEXT;\nextern unsigned IOCTL_TIOCSIG;\nextern unsigned IOCTL_TIOCDRAIN;\nextern unsigned IOCTL_TIOCGFLAGS;\nextern unsigned IOCTL_TIOCSFLAGS;\nextern unsigned IOCTL_TIOCDCDTIMESTAMP;\nextern unsigned IOCTL_TIOCRCVFRAME;\nextern unsigned IOCTL_TIOCXMTFRAME;\nextern unsigned IOCTL_TIOCPTMGET;\nextern unsigned IOCTL_TIOCGRANTPT;\nextern unsigned IOCTL_TIOCPTSNAME;\nextern unsigned IOCTL_TIOCSQSIZE;\nextern unsigned IOCTL_TIOCGQSIZE;\nextern unsigned IOCTL_VERIEXEC_LOAD;\nextern unsigned IOCTL_VERIEXEC_TABLESIZE;\nextern unsigned IOCTL_VERIEXEC_DELETE;\nextern unsigned IOCTL_VERIEXEC_QUERY;\nextern unsigned IOCTL_VERIEXEC_DUMP;\nextern unsigned IOCTL_VERIEXEC_FLUSH;\nextern unsigned IOCTL_VIDIOC_QUERYCAP;\nextern unsigned IOCTL_VIDIOC_RESERVED;\nextern unsigned IOCTL_VIDIOC_ENUM_FMT;\nextern unsigned IOCTL_VIDIOC_G_FMT;\nextern unsigned IOCTL_VIDIOC_S_FMT;\nextern unsigned IOCTL_VIDIOC_REQBUFS;\nextern unsigned IOCTL_VIDIOC_QUERYBUF;\nextern unsigned IOCTL_VIDIOC_G_FBUF;\nextern unsigned IOCTL_VIDIOC_S_FBUF;\nextern unsigned IOCTL_VIDIOC_OVERLAY;\nextern unsigned IOCTL_VIDIOC_QBUF;\nextern unsigned IOCTL_VIDIOC_DQBUF;\nextern unsigned IOCTL_VIDIOC_STREAMON;\nextern unsigned IOCTL_VIDIOC_STREAMOFF;\nextern unsigned IOCTL_VIDIOC_G_PARM;\nextern unsigned IOCTL_VIDIOC_S_PARM;\nextern unsigned IOCTL_VIDIOC_G_STD;\nextern unsigned IOCTL_VIDIOC_S_STD;\nextern unsigned IOCTL_VIDIOC_ENUMSTD;\nextern unsigned IOCTL_VIDIOC_ENUMINPUT;\nextern unsigned IOCTL_VIDIOC_G_CTRL;\nextern unsigned IOCTL_VIDIOC_S_CTRL;\nextern unsigned IOCTL_VIDIOC_G_TUNER;\nextern unsigned IOCTL_VIDIOC_S_TUNER;\nextern unsigned IOCTL_VIDIOC_G_AUDIO;\nextern unsigned IOCTL_VIDIOC_S_AUDIO;\nextern unsigned IOCTL_VIDIOC_QUERYCTRL;\nextern unsigned IOCTL_VIDIOC_QUERYMENU;\nextern unsigned IOCTL_VIDIOC_G_INPUT;\nextern unsigned IOCTL_VIDIOC_S_INPUT;\nextern unsigned IOCTL_VIDIOC_G_OUTPUT;\nextern unsigned IOCTL_VIDIOC_S_OUTPUT;\nextern unsigned IOCTL_VIDIOC_ENUMOUTPUT;\nextern unsigned IOCTL_VIDIOC_G_AUDOUT;\nextern unsigned IOCTL_VIDIOC_S_AUDOUT;\nextern unsigned IOCTL_VIDIOC_G_MODULATOR;\nextern unsigned IOCTL_VIDIOC_S_MODULATOR;\nextern unsigned IOCTL_VIDIOC_G_FREQUENCY;\nextern unsigned IOCTL_VIDIOC_S_FREQUENCY;\nextern unsigned IOCTL_VIDIOC_CROPCAP;\nextern unsigned IOCTL_VIDIOC_G_CROP;\nextern unsigned IOCTL_VIDIOC_S_CROP;\nextern unsigned IOCTL_VIDIOC_G_JPEGCOMP;\nextern unsigned IOCTL_VIDIOC_S_JPEGCOMP;\nextern unsigned IOCTL_VIDIOC_QUERYSTD;\nextern unsigned IOCTL_VIDIOC_TRY_FMT;\nextern unsigned IOCTL_VIDIOC_ENUMAUDIO;\nextern unsigned IOCTL_VIDIOC_ENUMAUDOUT;\nextern unsigned IOCTL_VIDIOC_G_PRIORITY;\nextern unsigned IOCTL_VIDIOC_S_PRIORITY;\nextern unsigned IOCTL_VIDIOC_ENUM_FRAMESIZES;\nextern unsigned IOCTL_VIDIOC_ENUM_FRAMEINTERVALS;\nextern unsigned IOCTL_WDOGIOC_GMODE;\nextern unsigned IOCTL_WDOGIOC_SMODE;\nextern unsigned IOCTL_WDOGIOC_WHICH;\nextern unsigned IOCTL_WDOGIOC_TICKLE;\nextern unsigned IOCTL_WDOGIOC_GTICKLER;\nextern unsigned IOCTL_WDOGIOC_GWDOGS;\nextern unsigned IOCTL_KCOV_IOC_SETBUFSIZE;\nextern unsigned IOCTL_KCOV_IOC_ENABLE;\nextern unsigned IOCTL_KCOV_IOC_DISABLE;\nextern unsigned IOCTL_IPMICTL_RECEIVE_MSG_TRUNC;\nextern unsigned IOCTL_IPMICTL_RECEIVE_MSG;\nextern unsigned IOCTL_IPMICTL_SEND_COMMAND;\nextern unsigned IOCTL_IPMICTL_REGISTER_FOR_CMD;\nextern unsigned IOCTL_IPMICTL_UNREGISTER_FOR_CMD;\nextern unsigned IOCTL_IPMICTL_SET_GETS_EVENTS_CMD;\nextern unsigned IOCTL_IPMICTL_SET_MY_ADDRESS_CMD;\nextern unsigned IOCTL_IPMICTL_GET_MY_ADDRESS_CMD;\nextern unsigned IOCTL_IPMICTL_SET_MY_LUN_CMD;\nextern unsigned IOCTL_IPMICTL_GET_MY_LUN_CMD;\nextern unsigned IOCTL_SNDCTL_DSP_RESET;\nextern unsigned IOCTL_SNDCTL_DSP_SYNC;\nextern unsigned IOCTL_SNDCTL_DSP_SPEED;\nextern unsigned IOCTL_SOUND_PCM_READ_RATE;\nextern unsigned IOCTL_SNDCTL_DSP_STEREO;\nextern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\nextern unsigned IOCTL_SNDCTL_DSP_SETFMT;\nextern unsigned IOCTL_SOUND_PCM_READ_BITS;\nextern unsigned IOCTL_SNDCTL_DSP_CHANNELS;\nextern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\nextern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\nextern unsigned IOCTL_SOUND_PCM_READ_FILTER;\nextern unsigned IOCTL_SNDCTL_DSP_POST;\nextern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\nextern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\nextern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\nextern unsigned IOCTL_SNDCTL_DSP_GETOSPACE;\nextern unsigned IOCTL_SNDCTL_DSP_GETISPACE;\nextern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\nextern unsigned IOCTL_SNDCTL_DSP_GETCAPS;\nextern unsigned IOCTL_SNDCTL_DSP_GETTRIGGER;\nextern unsigned IOCTL_SNDCTL_DSP_SETTRIGGER;\nextern unsigned IOCTL_SNDCTL_DSP_GETIPTR;\nextern unsigned IOCTL_SNDCTL_DSP_GETOPTR;\nextern unsigned IOCTL_SNDCTL_DSP_MAPINBUF;\nextern unsigned IOCTL_SNDCTL_DSP_MAPOUTBUF;\nextern unsigned IOCTL_SNDCTL_DSP_SETSYNCRO;\nextern unsigned IOCTL_SNDCTL_DSP_SETDUPLEX;\nextern unsigned IOCTL_SNDCTL_DSP_PROFILE;\nextern unsigned IOCTL_SNDCTL_DSP_GETODELAY;\nextern unsigned IOCTL_SOUND_MIXER_INFO;\nextern unsigned IOCTL_SOUND_OLD_MIXER_INFO;\nextern unsigned IOCTL_OSS_GETVERSION;\nextern unsigned IOCTL_SNDCTL_SYSINFO;\nextern unsigned IOCTL_SNDCTL_AUDIOINFO;\nextern unsigned IOCTL_SNDCTL_ENGINEINFO;\nextern unsigned IOCTL_SNDCTL_DSP_GETPLAYVOL;\nextern unsigned IOCTL_SNDCTL_DSP_SETPLAYVOL;\nextern unsigned IOCTL_SNDCTL_DSP_GETRECVOL;\nextern unsigned IOCTL_SNDCTL_DSP_SETRECVOL;\nextern unsigned IOCTL_SNDCTL_DSP_SKIP;\nextern unsigned IOCTL_SNDCTL_DSP_SILENCE;\n\nextern const int si_SEGV_MAPERR;\nextern const int si_SEGV_ACCERR;\n\nextern const unsigned SHA1_CTX_sz;\nextern const unsigned SHA1_return_length;\n\nextern const unsigned MD4_CTX_sz;\nextern const unsigned MD4_return_length;\n\nextern const unsigned RMD160_CTX_sz;\nextern const unsigned RMD160_return_length;\n\nextern const unsigned MD5_CTX_sz;\nextern const unsigned MD5_return_length;\n\nextern const unsigned fpos_t_sz;\n\nextern const unsigned MD2_CTX_sz;\nextern const unsigned MD2_return_length;\n\n#define SHA2_EXTERN(LEN)                          \\\n  extern const unsigned SHA##LEN##_CTX_sz;        \\\n  extern const unsigned SHA##LEN##_return_length; \\\n  extern const unsigned SHA##LEN##_block_length;  \\\n  extern const unsigned SHA##LEN##_digest_length\n\nSHA2_EXTERN(224);\nSHA2_EXTERN(256);\nSHA2_EXTERN(384);\nSHA2_EXTERN(512);\n\n#undef SHA2_EXTERN\n\nextern const int unvis_valid;\nextern const int unvis_validpush;\n\nstruct __sanitizer_cdbr {\n  void (*unmap)(void *, void *, uptr);\n  void *cookie;\n  u8 *mmap_base;\n  uptr mmap_size;\n\n  u8 *hash_base;\n  u8 *offset_base;\n  u8 *data_base;\n\n  u32 data_size;\n  u32 entries;\n  u32 entries_index;\n  u32 seed;\n\n  u8 offset_size;\n  u8 index_size;\n\n  u32 entries_m;\n  u32 entries_index_m;\n  u8 entries_s1, entries_s2;\n  u8 entries_index_s1, entries_index_s2;\n};\n\nstruct __sanitizer_cdbw {\n  uptr data_counter;\n  uptr data_allocated;\n  uptr data_size;\n  uptr *data_len;\n  void **data_ptr;\n  uptr hash_size;\n  void *hash;\n  uptr key_counter;\n};\n}  // namespace __sanitizer\n\n#define CHECK_TYPE_SIZE(TYPE) \\\n  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n\n#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *)NULL)->MEMBER) == \\\n                 sizeof(((CLASS *)NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==         \\\n                 offsetof(CLASS, MEMBER))\n\n// For sigaction, which is a function and struct at the same time,\n// and thus requires explicit \"struct\" in sizeof() expression.\n#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *)NULL)->MEMBER) == \\\n                 sizeof(((struct CLASS *)NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==         \\\n                 offsetof(struct CLASS, MEMBER))\n\n#define SIGACTION_SYMNAME __sigaction14\n\n// Compat with 9.0\nextern unsigned struct_statvfs90_sz;\n\n#endif  // SANITIZER_NETBSD\n\n#endif\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.h", "content": "//===-- sanitizer_platform_limits_posix.h ---------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of Sanitizer common code.\n//\n// Sizes and layouts of platform-specific POSIX data structures.\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_PLATFORM_LIMITS_POSIX_H\n#define SANITIZER_PLATFORM_LIMITS_POSIX_H\n\n#if SANITIZER_LINUX || SANITIZER_MAC\n\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_platform.h\"\n\n#if defined(__sparc__)\n// FIXME: This can't be included from tsan which does not support sparc yet.\n#include \"sanitizer_glibc_version.h\"\n#endif\n\n# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) ((link_map*)(handle))\n\nnamespace __sanitizer {\nextern unsigned struct_utsname_sz;\nextern unsigned struct_stat_sz;\n#if !SANITIZER_IOS\nextern unsigned struct_stat64_sz;\n#endif\nextern unsigned struct_rusage_sz;\nextern unsigned siginfo_t_sz;\nextern unsigned struct_itimerval_sz;\nextern unsigned pthread_t_sz;\nextern unsigned pthread_mutex_t_sz;\nextern unsigned pthread_cond_t_sz;\nextern unsigned pid_t_sz;\nextern unsigned timeval_sz;\nextern unsigned uid_t_sz;\nextern unsigned gid_t_sz;\nextern unsigned mbstate_t_sz;\nextern unsigned struct_timezone_sz;\nextern unsigned struct_tms_sz;\nextern unsigned struct_itimerspec_sz;\nextern unsigned struct_sigevent_sz;\nextern unsigned struct_stack_t_sz;\nextern unsigned struct_sched_param_sz;\nextern unsigned struct_statfs64_sz;\nextern unsigned struct_regex_sz;\nextern unsigned struct_regmatch_sz;\n\n#if !SANITIZER_ANDROID\nextern unsigned struct_fstab_sz;\nextern unsigned struct_statfs_sz;\nextern unsigned struct_sockaddr_sz;\nextern unsigned ucontext_t_sz;\n#endif // !SANITIZER_ANDROID\n\n#if SANITIZER_LINUX\n\n#if defined(__x86_64__)\nconst unsigned struct_kernel_stat_sz = 144;\nconst unsigned struct_kernel_stat64_sz = 0;\n#elif defined(__i386__)\nconst unsigned struct_kernel_stat_sz = 64;\nconst unsigned struct_kernel_stat64_sz = 96;\n#elif defined(__arm__)\nconst unsigned struct_kernel_stat_sz = 64;\nconst unsigned struct_kernel_stat64_sz = 104;\n#elif defined(__aarch64__)\nconst unsigned struct_kernel_stat_sz = 128;\nconst unsigned struct_kernel_stat64_sz = 104;\n#elif defined(__powerpc__) && !defined(__powerpc64__)\nconst unsigned struct_kernel_stat_sz = 72;\nconst unsigned struct_kernel_stat64_sz = 104;\n#elif defined(__powerpc64__)\nconst unsigned struct_kernel_stat_sz = 144;\nconst unsigned struct_kernel_stat64_sz = 104;\n#elif defined(__mips__)\nconst unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n                                           ? FIRST_32_SECOND_64(104, 128)\n                                           : FIRST_32_SECOND_64(160, 216);\nconst unsigned struct_kernel_stat64_sz = 104;\n#elif defined(__s390__) && !defined(__s390x__)\nconst unsigned struct_kernel_stat_sz = 64;\nconst unsigned struct_kernel_stat64_sz = 104;\n#elif defined(__s390x__)\nconst unsigned struct_kernel_stat_sz = 144;\nconst unsigned struct_kernel_stat64_sz = 0;\n#elif defined(__sparc__) && defined(__arch64__)\nconst unsigned struct___old_kernel_stat_sz = 0;\nconst unsigned struct_kernel_stat_sz = 104;\nconst unsigned struct_kernel_stat64_sz = 144;\n#elif defined(__sparc__) && !defined(__arch64__)\nconst unsigned struct___old_kernel_stat_sz = 0;\nconst unsigned struct_kernel_stat_sz = 64;\nconst unsigned struct_kernel_stat64_sz = 104;\n#elif SANITIZER_RISCV64\nconst unsigned struct_kernel_stat_sz = 128;\nconst unsigned struct_kernel_stat64_sz = 0;  // RISCV64 does not use stat64\n#endif\nstruct __sanitizer_perf_event_attr {\n  unsigned type;\n  unsigned size;\n  // More fields that vary with the kernel version.\n};\n\nextern unsigned struct_epoll_event_sz;\nextern unsigned struct_sysinfo_sz;\nextern unsigned __user_cap_header_struct_sz;\nextern unsigned __user_cap_data_struct_sz;\nextern unsigned struct_new_utsname_sz;\nextern unsigned struct_old_utsname_sz;\nextern unsigned struct_oldold_utsname_sz;\n\nconst unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n#endif  // SANITIZER_LINUX\n\n#if SANITIZER_LINUX\n\n#if defined(__powerpc64__) || defined(__s390__)\nconst unsigned struct___old_kernel_stat_sz = 0;\n#elif !defined(__sparc__)\nconst unsigned struct___old_kernel_stat_sz = 32;\n#endif\n\nextern unsigned struct_rlimit_sz;\nextern unsigned struct_utimbuf_sz;\nextern unsigned struct_timespec_sz;\n\nstruct __sanitizer_iocb {\n  u64 aio_data;\n  u32 aio_key_or_aio_reserved1;  // Simply crazy.\n  u32 aio_reserved1_or_aio_key;  // Luckily, we don't need these.\n  u16 aio_lio_opcode;\n  s16 aio_reqprio;\n  u32 aio_fildes;\n  u64 aio_buf;\n  u64 aio_nbytes;\n  s64 aio_offset;\n  u64 aio_reserved2;\n  u64 aio_reserved3;\n};\n\nstruct __sanitizer_io_event {\n  u64 data;\n  u64 obj;\n  u64 res;\n  u64 res2;\n};\n\nconst unsigned iocb_cmd_pread = 0;\nconst unsigned iocb_cmd_pwrite = 1;\nconst unsigned iocb_cmd_preadv = 7;\nconst unsigned iocb_cmd_pwritev = 8;\n\nstruct __sanitizer___sysctl_args {\n  int *name;\n  int nlen;\n  void *oldval;\n  uptr *oldlenp;\n  void *newval;\n  uptr newlen;\n  unsigned long ___unused[4];\n};\n\nconst unsigned old_sigset_t_sz = sizeof(unsigned long);\n\nstruct __sanitizer_sem_t {\n#if SANITIZER_ANDROID && defined(_LP64)\n  int data[4];\n#elif SANITIZER_ANDROID && !defined(_LP64)\n  int data;\n#elif SANITIZER_LINUX\n  uptr data[4];\n#endif\n};\n#endif // SANITIZER_LINUX\n\n#if SANITIZER_ANDROID\nstruct __sanitizer_struct_mallinfo {\n  uptr v[10];\n};\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nstruct __sanitizer_struct_mallinfo {\n  int v[10];\n};\n\nextern unsigned struct_ustat_sz;\nextern unsigned struct_rlimit64_sz;\nextern unsigned struct_statvfs64_sz;\n\nstruct __sanitizer_ipc_perm {\n  int __key;\n  int uid;\n  int gid;\n  int cuid;\n  int cgid;\n#ifdef __powerpc__\n  unsigned mode;\n  unsigned __seq;\n  u64 __unused1;\n  u64 __unused2;\n#elif defined(__sparc__)\n  unsigned mode;\n  unsigned short __pad2;\n  unsigned short __seq;\n  unsigned long long __unused1;\n  unsigned long long __unused2;\n#else\n  unsigned int mode;\n  unsigned short __seq;\n  unsigned short __pad2;\n#if defined(__x86_64__) && !defined(_LP64)\n  u64 __unused1;\n  u64 __unused2;\n#else\n  unsigned long __unused1;\n  unsigned long __unused2;\n#endif\n#endif\n};\n\nstruct __sanitizer_shmid_ds {\n  __sanitizer_ipc_perm shm_perm;\n#if defined(__sparc__)\n#if !defined(__arch64__)\n  u32 __pad1;\n#endif\n  long shm_atime;\n#if !defined(__arch64__)\n  u32 __pad2;\n#endif\n  long shm_dtime;\n#if !defined(__arch64__)\n  u32 __pad3;\n#endif\n  long shm_ctime;\n  uptr shm_segsz;\n  int shm_cpid;\n  int shm_lpid;\n  unsigned long shm_nattch;\n  unsigned long __glibc_reserved1;\n  unsigned long __glibc_reserved2;\n#else\n#ifndef __powerpc__\n  uptr shm_segsz;\n#elif !defined(__powerpc64__)\n  uptr __unused0;\n#endif\n#if defined(__x86_64__) && !defined(_LP64)\n  u64 shm_atime;\n  u64 shm_dtime;\n  u64 shm_ctime;\n#else\n  uptr shm_atime;\n#if !defined(_LP64) && !defined(__mips__)\n  uptr __unused1;\n#endif\n  uptr shm_dtime;\n#if !defined(_LP64) && !defined(__mips__)\n  uptr __unused2;\n#endif\n  uptr shm_ctime;\n#if !defined(_LP64) && !defined(__mips__)\n  uptr __unused3;\n#endif\n#endif\n#ifdef __powerpc__\n  uptr shm_segsz;\n#endif\n  int shm_cpid;\n  int shm_lpid;\n#if defined(__x86_64__) && !defined(_LP64)\n  u64 shm_nattch;\n  u64 __unused4;\n  u64 __unused5;\n#else\n  uptr shm_nattch;\n  uptr __unused4;\n  uptr __unused5;\n#endif\n#endif\n};\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nextern unsigned struct_msqid_ds_sz;\nextern unsigned struct_mq_attr_sz;\nextern unsigned struct_timex_sz;\nextern unsigned struct_statvfs_sz;\nextern unsigned struct_crypt_data_sz;\n#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n\nstruct __sanitizer_iovec {\n  void *iov_base;\n  uptr iov_len;\n};\n\n#if !SANITIZER_ANDROID\nstruct __sanitizer_ifaddrs {\n  struct __sanitizer_ifaddrs *ifa_next;\n  char *ifa_name;\n  unsigned int ifa_flags;\n  void *ifa_addr;     // (struct sockaddr *)\n  void *ifa_netmask;  // (struct sockaddr *)\n  // This is a union on Linux.\n# ifdef ifa_dstaddr\n# undef ifa_dstaddr\n# endif\n  void *ifa_dstaddr;  // (struct sockaddr *)\n  void *ifa_data;\n};\n#endif  // !SANITIZER_ANDROID\n\n#if SANITIZER_MAC\ntypedef unsigned long __sanitizer_pthread_key_t;\n#else\ntypedef unsigned __sanitizer_pthread_key_t;\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\n\nstruct __sanitizer_XDR {\n  int x_op;\n  void *x_ops;\n  uptr x_public;\n  uptr x_private;\n  uptr x_base;\n  unsigned x_handy;\n};\n\nconst int __sanitizer_XDR_ENCODE = 0;\nconst int __sanitizer_XDR_DECODE = 1;\nconst int __sanitizer_XDR_FREE = 2;\n#endif\n\nstruct __sanitizer_passwd {\n  char *pw_name;\n  char *pw_passwd;\n  int pw_uid;\n  int pw_gid;\n#if SANITIZER_MAC\n  long pw_change;\n  char *pw_class;\n#endif\n#if !(SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 32))\n  char *pw_gecos;\n#endif\n  char *pw_dir;\n  char *pw_shell;\n#if SANITIZER_MAC\n  long pw_expire;\n#endif\n};\n\nstruct __sanitizer_group {\n  char *gr_name;\n  char *gr_passwd;\n  int gr_gid;\n  char **gr_mem;\n};\n\n#if defined(__x86_64__) && !defined(_LP64)\ntypedef long long __sanitizer_time_t;\n#else\ntypedef long __sanitizer_time_t;\n#endif\n\ntypedef long __sanitizer_suseconds_t;\n\nstruct __sanitizer_timeval {\n  __sanitizer_time_t tv_sec;\n  __sanitizer_suseconds_t tv_usec;\n};\n\nstruct __sanitizer_itimerval {\n  struct __sanitizer_timeval it_interval;\n  struct __sanitizer_timeval it_value;\n};\n\nstruct __sanitizer_timeb {\n  __sanitizer_time_t time;\n  unsigned short millitm;\n  short timezone;\n  short dstflag;\n};\n\nstruct __sanitizer_ether_addr {\n  u8 octet[6];\n};\n\nstruct __sanitizer_tm {\n  int tm_sec;\n  int tm_min;\n  int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n  long int tm_gmtoff;\n  const char *tm_zone;\n};\n\n#if SANITIZER_LINUX\nstruct __sanitizer_mntent {\n  char *mnt_fsname;\n  char *mnt_dir;\n  char *mnt_type;\n  char *mnt_opts;\n  int mnt_freq;\n  int mnt_passno;\n};\n\nstruct __sanitizer_file_handle {\n  unsigned int handle_bytes;\n  int handle_type;\n  unsigned char f_handle[1];  // variable sized\n};\n#endif\n\n#if SANITIZER_MAC\nstruct __sanitizer_msghdr {\n  void *msg_name;\n  unsigned msg_namelen;\n  struct __sanitizer_iovec *msg_iov;\n  unsigned msg_iovlen;\n  void *msg_control;\n  unsigned msg_controllen;\n  int msg_flags;\n};\nstruct __sanitizer_cmsghdr {\n  unsigned cmsg_len;\n  int cmsg_level;\n  int cmsg_type;\n};\n#else\n// In POSIX, int msg_iovlen; socklen_t msg_controllen; socklen_t cmsg_len; but\n// many implementations don't conform to the standard.\nstruct __sanitizer_msghdr {\n  void *msg_name;\n  unsigned msg_namelen;\n  struct __sanitizer_iovec *msg_iov;\n  uptr msg_iovlen;\n  void *msg_control;\n  uptr msg_controllen;\n  int msg_flags;\n};\nstruct __sanitizer_cmsghdr {\n  uptr cmsg_len;\n  int cmsg_level;\n  int cmsg_type;\n};\n#endif\n\n#if SANITIZER_LINUX\nstruct __sanitizer_mmsghdr {\n  __sanitizer_msghdr msg_hdr;\n  unsigned int msg_len;\n};\n#endif\n\n#if SANITIZER_MAC\nstruct __sanitizer_dirent {\n  unsigned long long d_ino;\n  unsigned long long d_seekoff;\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n#elif SANITIZER_ANDROID || defined(__x86_64__)\nstruct __sanitizer_dirent {\n  unsigned long long d_ino;\n  unsigned long long d_off;\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n#else\nstruct __sanitizer_dirent {\n  uptr d_ino;\n  uptr d_off;\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nstruct __sanitizer_dirent64 {\n  unsigned long long d_ino;\n  unsigned long long d_off;\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n#endif\n\n#if defined(__x86_64__) && !defined(_LP64)\ntypedef long long __sanitizer_clock_t;\n#else\ntypedef long __sanitizer_clock_t;\n#endif\n\n#if SANITIZER_LINUX\ntypedef int __sanitizer_clockid_t;\n#endif\n\n#if SANITIZER_LINUX\n#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__) || \\\n    defined(__mips__)\ntypedef unsigned __sanitizer___kernel_uid_t;\ntypedef unsigned __sanitizer___kernel_gid_t;\n#else\ntypedef unsigned short __sanitizer___kernel_uid_t;\ntypedef unsigned short __sanitizer___kernel_gid_t;\n#endif\n#if defined(__x86_64__) && !defined(_LP64)\ntypedef long long __sanitizer___kernel_off_t;\n#else\ntypedef long __sanitizer___kernel_off_t;\n#endif\n\n#if defined(__powerpc__) || defined(__mips__)\ntypedef unsigned int __sanitizer___kernel_old_uid_t;\ntypedef unsigned int __sanitizer___kernel_old_gid_t;\n#else\ntypedef unsigned short __sanitizer___kernel_old_uid_t;\ntypedef unsigned short __sanitizer___kernel_old_gid_t;\n#endif\n\ntypedef long long __sanitizer___kernel_loff_t;\ntypedef struct {\n  unsigned long fds_bits[1024 / (8 * sizeof(long))];\n} __sanitizer___kernel_fd_set;\n#endif\n\n// This thing depends on the platform. We are only interested in the upper\n// limit. Verified with a compiler assert in .cpp.\nunion __sanitizer_pthread_attr_t {\n  char size[128];\n  void *align;\n};\n\n#if SANITIZER_ANDROID\n# if SANITIZER_MIPS\ntypedef unsigned long __sanitizer_sigset_t[16 / sizeof(unsigned long)];\n# else\ntypedef unsigned long __sanitizer_sigset_t;\n# endif\n#elif SANITIZER_MAC\ntypedef unsigned __sanitizer_sigset_t;\n#elif SANITIZER_LINUX\nstruct __sanitizer_sigset_t {\n  // The size is determined by looking at sizeof of real sigset_t on linux.\n  uptr val[128 / sizeof(uptr)];\n};\n#endif\n\nstruct __sanitizer_siginfo {\n  // The size is determined by looking at sizeof of real siginfo_t on linux.\n  u64 opaque[128 / sizeof(u64)];\n};\n\nusing __sanitizer_sighandler_ptr = void (*)(int sig);\nusing __sanitizer_sigactionhandler_ptr = void (*)(int sig,\n                                                  __sanitizer_siginfo *siginfo,\n                                                  void *uctx);\n\n// Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n#if SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 64)\nstruct __sanitizer_sigaction {\n  unsigned sa_flags;\n  union {\n    __sanitizer_sigactionhandler_ptr sigaction;\n    __sanitizer_sighandler_ptr handler;\n  };\n  __sanitizer_sigset_t sa_mask;\n  void (*sa_restorer)();\n};\n#elif SANITIZER_ANDROID && SANITIZER_MIPS32  // check this before WORDSIZE == 32\nstruct __sanitizer_sigaction {\n  unsigned sa_flags;\n  union {\n    __sanitizer_sigactionhandler_ptr sigaction;\n    __sanitizer_sighandler_ptr handler;\n  };\n  __sanitizer_sigset_t sa_mask;\n};\n#elif SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 32)\nstruct __sanitizer_sigaction {\n  union {\n    __sanitizer_sigactionhandler_ptr sigaction;\n    __sanitizer_sighandler_ptr handler;\n  };\n  __sanitizer_sigset_t sa_mask;\n  uptr sa_flags;\n  void (*sa_restorer)();\n};\n#else // !SANITIZER_ANDROID\nstruct __sanitizer_sigaction {\n#if defined(__mips__) && !SANITIZER_FREEBSD\n  unsigned int sa_flags;\n#endif\n  union {\n    __sanitizer_sigactionhandler_ptr sigaction;\n    __sanitizer_sighandler_ptr handler;\n  };\n#if SANITIZER_FREEBSD\n  int sa_flags;\n  __sanitizer_sigset_t sa_mask;\n#else\n#if defined(__s390x__)\n  int sa_resv;\n#else\n  __sanitizer_sigset_t sa_mask;\n#endif\n#ifndef __mips__\n#if defined(__sparc__)\n#if __GLIBC_PREREQ (2, 20)\n  // On sparc glibc 2.19 and earlier sa_flags was unsigned long.\n#if defined(__arch64__)\n  // To maintain ABI compatibility on sparc64 when switching to an int,\n  // __glibc_reserved0 was added.\n  int __glibc_reserved0;\n#endif\n  int sa_flags;\n#else\n  unsigned long sa_flags;\n#endif\n#else\n  int sa_flags;\n#endif\n#endif\n#endif\n#if SANITIZER_LINUX\n  void (*sa_restorer)();\n#endif\n#if defined(__mips__) && (SANITIZER_WORDSIZE == 32)\n  int sa_resv[1];\n#endif\n#if defined(__s390x__)\n  __sanitizer_sigset_t sa_mask;\n#endif\n};\n#endif // !SANITIZER_ANDROID\n\n#if defined(__mips__)\nstruct __sanitizer_kernel_sigset_t {\n  uptr sig[2];\n};\n#else\nstruct __sanitizer_kernel_sigset_t {\n  u8 sig[8];\n};\n#endif\n\n// Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n#if SANITIZER_MIPS\nstruct __sanitizer_kernel_sigaction_t {\n  unsigned int sa_flags;\n  union {\n    void (*handler)(int signo);\n    void (*sigaction)(int signo, __sanitizer_siginfo *info, void *ctx);\n  };\n  __sanitizer_kernel_sigset_t sa_mask;\n  void (*sa_restorer)(void);\n};\n#else\nstruct __sanitizer_kernel_sigaction_t {\n  union {\n    void (*handler)(int signo);\n    void (*sigaction)(int signo, __sanitizer_siginfo *info, void *ctx);\n  };\n  unsigned long sa_flags;\n  void (*sa_restorer)(void);\n  __sanitizer_kernel_sigset_t sa_mask;\n};\n#endif\n\nextern const uptr sig_ign;\nextern const uptr sig_dfl;\nextern const uptr sig_err;\nextern const uptr sa_siginfo;\n\n#if SANITIZER_LINUX\nextern int e_tabsz;\n#endif\n\nextern int af_inet;\nextern int af_inet6;\nuptr __sanitizer_in_addr_sz(int af);\n\n#if SANITIZER_LINUX\nstruct __sanitizer_dl_phdr_info {\n  uptr dlpi_addr;\n  const char *dlpi_name;\n  const void *dlpi_phdr;\n  short dlpi_phnum;\n};\n\nextern unsigned struct_ElfW_Phdr_sz;\n#endif\n\nstruct __sanitizer_protoent {\n  char *p_name;\n  char **p_aliases;\n  int p_proto;\n};\n\nstruct __sanitizer_addrinfo {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n#if SANITIZER_ANDROID || SANITIZER_MAC\n  unsigned ai_addrlen;\n  char *ai_canonname;\n  void *ai_addr;\n#else // LINUX\n  unsigned ai_addrlen;\n  void *ai_addr;\n  char *ai_canonname;\n#endif\n  struct __sanitizer_addrinfo *ai_next;\n};\n\nstruct __sanitizer_hostent {\n  char *h_name;\n  char **h_aliases;\n  int h_addrtype;\n  int h_length;\n  char **h_addr_list;\n};\n\nstruct __sanitizer_pollfd {\n  int fd;\n  short events;\n  short revents;\n};\n\n#if SANITIZER_ANDROID || SANITIZER_MAC\ntypedef unsigned __sanitizer_nfds_t;\n#else\ntypedef unsigned long __sanitizer_nfds_t;\n#endif\n\n#if !SANITIZER_ANDROID\n# if SANITIZER_LINUX\nstruct __sanitizer_glob_t {\n  uptr gl_pathc;\n  char **gl_pathv;\n  uptr gl_offs;\n  int gl_flags;\n\n  void (*gl_closedir)(void *dirp);\n  void *(*gl_readdir)(void *dirp);\n  void *(*gl_opendir)(const char *);\n  int (*gl_lstat)(const char *, void *);\n  int (*gl_stat)(const char *, void *);\n};\n# endif  // SANITIZER_LINUX\n\n# if SANITIZER_LINUX\nextern int glob_nomatch;\nextern int glob_altdirfunc;\n# endif\n#endif  // !SANITIZER_ANDROID\n\nextern unsigned path_max;\n\nstruct __sanitizer_wordexp_t {\n  uptr we_wordc;\n  char **we_wordv;\n  uptr we_offs;\n};\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nstruct __sanitizer_FILE {\n  int _flags;\n  char *_IO_read_ptr;\n  char *_IO_read_end;\n  char *_IO_read_base;\n  char *_IO_write_base;\n  char *_IO_write_ptr;\n  char *_IO_write_end;\n  char *_IO_buf_base;\n  char *_IO_buf_end;\n  char *_IO_save_base;\n  char *_IO_backup_base;\n  char *_IO_save_end;\n  void *_markers;\n  __sanitizer_FILE *_chain;\n  int _fileno;\n};\n# define SANITIZER_HAS_STRUCT_FILE 1\n#else\ntypedef void __sanitizer_FILE;\n# define SANITIZER_HAS_STRUCT_FILE 0\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID &&                               \\\n    (defined(__i386) || defined(__x86_64) || defined(__mips64) ||          \\\n     defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n     defined(__s390__) || SANITIZER_RISCV64)\nextern unsigned struct_user_regs_struct_sz;\nextern unsigned struct_user_fpregs_struct_sz;\nextern unsigned struct_user_fpxregs_struct_sz;\nextern unsigned struct_user_vfpregs_struct_sz;\n\nextern int ptrace_peektext;\nextern int ptrace_peekdata;\nextern int ptrace_peekuser;\nextern int ptrace_getregs;\nextern int ptrace_setregs;\nextern int ptrace_getfpregs;\nextern int ptrace_setfpregs;\nextern int ptrace_getfpxregs;\nextern int ptrace_setfpxregs;\nextern int ptrace_getvfpregs;\nextern int ptrace_setvfpregs;\nextern int ptrace_getsiginfo;\nextern int ptrace_setsiginfo;\nextern int ptrace_getregset;\nextern int ptrace_setregset;\nextern int ptrace_geteventmsg;\n#endif\n\n#if SANITIZER_LINUX  && !SANITIZER_ANDROID\nextern unsigned struct_shminfo_sz;\nextern unsigned struct_shm_info_sz;\nextern int shmctl_ipc_stat;\nextern int shmctl_ipc_info;\nextern int shmctl_shm_info;\nextern int shmctl_shm_stat;\n#endif\n\n#if !SANITIZER_MAC && !SANITIZER_FREEBSD\nextern unsigned struct_utmp_sz;\n#endif\n#if !SANITIZER_ANDROID\nextern unsigned struct_utmpx_sz;\n#endif\n\nextern int map_fixed;\n\n// ioctl arguments\nstruct __sanitizer_ifconf {\n  int ifc_len;\n  union {\n    void *ifcu_req;\n  } ifc_ifcu;\n#if SANITIZER_MAC\n} __attribute__((packed));\n#else\n};\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nstruct __sanitizer__obstack_chunk {\n  char *limit;\n  struct __sanitizer__obstack_chunk *prev;\n};\n\nstruct __sanitizer_obstack {\n  long chunk_size;\n  struct __sanitizer__obstack_chunk *chunk;\n  char *object_base;\n  char *next_free;\n  uptr more_fields[7];\n};\n\ntypedef uptr (*__sanitizer_cookie_io_read)(void *cookie, char *buf, uptr size);\ntypedef uptr (*__sanitizer_cookie_io_write)(void *cookie, const char *buf,\n                                            uptr size);\ntypedef int (*__sanitizer_cookie_io_seek)(void *cookie, u64 *offset,\n                                          int whence);\ntypedef int (*__sanitizer_cookie_io_close)(void *cookie);\n\nstruct __sanitizer_cookie_io_functions_t {\n  __sanitizer_cookie_io_read read;\n  __sanitizer_cookie_io_write write;\n  __sanitizer_cookie_io_seek seek;\n  __sanitizer_cookie_io_close close;\n};\n#endif\n\n#define IOC_NRBITS 8\n#define IOC_TYPEBITS 8\n#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__) || \\\n    defined(__sparc__)\n#define IOC_SIZEBITS 13\n#define IOC_DIRBITS 3\n#define IOC_NONE 1U\n#define IOC_WRITE 4U\n#define IOC_READ 2U\n#else\n#define IOC_SIZEBITS 14\n#define IOC_DIRBITS 2\n#define IOC_NONE 0U\n#define IOC_WRITE 1U\n#define IOC_READ 2U\n#endif\n#define IOC_NRMASK ((1 << IOC_NRBITS) - 1)\n#define IOC_TYPEMASK ((1 << IOC_TYPEBITS) - 1)\n#define IOC_SIZEMASK ((1 << IOC_SIZEBITS) - 1)\n#if defined(IOC_DIRMASK)\n#undef IOC_DIRMASK\n#endif\n#define IOC_DIRMASK ((1 << IOC_DIRBITS) - 1)\n#define IOC_NRSHIFT 0\n#define IOC_TYPESHIFT (IOC_NRSHIFT + IOC_NRBITS)\n#define IOC_SIZESHIFT (IOC_TYPESHIFT + IOC_TYPEBITS)\n#define IOC_DIRSHIFT (IOC_SIZESHIFT + IOC_SIZEBITS)\n#define EVIOC_EV_MAX 0x1f\n#define EVIOC_ABS_MAX 0x3f\n\n#define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n#define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n#define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n\n#if defined(__sparc__)\n// In sparc the 14 bits SIZE field overlaps with the\n// least significant bit of DIR, so either IOC_READ or\n// IOC_WRITE shall be 1 in order to get a non-zero SIZE.\n#define IOC_SIZE(nr) \\\n  ((((((nr) >> 29) & 0x7) & (4U | 2U)) == 0) ? 0 : (((nr) >> 16) & 0x3fff))\n#else\n#define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n#endif\n\nextern unsigned struct_ifreq_sz;\nextern unsigned struct_termios_sz;\nextern unsigned struct_winsize_sz;\n\n#if SANITIZER_LINUX\nextern unsigned struct_arpreq_sz;\nextern unsigned struct_cdrom_msf_sz;\nextern unsigned struct_cdrom_multisession_sz;\nextern unsigned struct_cdrom_read_audio_sz;\nextern unsigned struct_cdrom_subchnl_sz;\nextern unsigned struct_cdrom_ti_sz;\nextern unsigned struct_cdrom_tocentry_sz;\nextern unsigned struct_cdrom_tochdr_sz;\nextern unsigned struct_cdrom_volctrl_sz;\nextern unsigned struct_ff_effect_sz;\nextern unsigned struct_floppy_drive_params_sz;\nextern unsigned struct_floppy_drive_struct_sz;\nextern unsigned struct_floppy_fdc_state_sz;\nextern unsigned struct_floppy_max_errors_sz;\nextern unsigned struct_floppy_raw_cmd_sz;\nextern unsigned struct_floppy_struct_sz;\nextern unsigned struct_floppy_write_errors_sz;\nextern unsigned struct_format_descr_sz;\nextern unsigned struct_hd_driveid_sz;\nextern unsigned struct_hd_geometry_sz;\nextern unsigned struct_input_absinfo_sz;\nextern unsigned struct_input_id_sz;\nextern unsigned struct_mtpos_sz;\nextern unsigned struct_termio_sz;\nextern unsigned struct_vt_consize_sz;\nextern unsigned struct_vt_sizes_sz;\nextern unsigned struct_vt_stat_sz;\n#endif  // SANITIZER_LINUX\n\n#if SANITIZER_LINUX\nextern unsigned struct_copr_buffer_sz;\nextern unsigned struct_copr_debug_buf_sz;\nextern unsigned struct_copr_msg_sz;\nextern unsigned struct_midi_info_sz;\nextern unsigned struct_mtget_sz;\nextern unsigned struct_mtop_sz;\nextern unsigned struct_rtentry_sz;\nextern unsigned struct_sbi_instrument_sz;\nextern unsigned struct_seq_event_rec_sz;\nextern unsigned struct_synth_info_sz;\nextern unsigned struct_vt_mode_sz;\n#endif // SANITIZER_LINUX\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nextern unsigned struct_ax25_parms_struct_sz;\nextern unsigned struct_cyclades_monitor_sz;\nextern unsigned struct_input_keymap_entry_sz;\nextern unsigned struct_ipx_config_data_sz;\nextern unsigned struct_kbdiacrs_sz;\nextern unsigned struct_kbentry_sz;\nextern unsigned struct_kbkeycode_sz;\nextern unsigned struct_kbsentry_sz;\nextern unsigned struct_mtconfiginfo_sz;\nextern unsigned struct_nr_parms_struct_sz;\nextern unsigned struct_scc_modem_sz;\nextern unsigned struct_scc_stat_sz;\nextern unsigned struct_serial_multiport_struct_sz;\nextern unsigned struct_serial_struct_sz;\nextern unsigned struct_sockaddr_ax25_sz;\nextern unsigned struct_unimapdesc_sz;\nextern unsigned struct_unimapinit_sz;\n#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n\nextern const unsigned long __sanitizer_bufsiz;\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nextern unsigned struct_audio_buf_info_sz;\nextern unsigned struct_ppp_stats_sz;\n#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n\n#if !SANITIZER_ANDROID && !SANITIZER_MAC\nextern unsigned struct_sioc_sg_req_sz;\nextern unsigned struct_sioc_vif_req_sz;\n#endif\n\n// ioctl request identifiers\n\n// A special value to mark ioctls that are not present on the target platform,\n// when it can not be determined without including any system headers.\nextern const unsigned IOCTL_NOT_PRESENT;\n\nextern unsigned IOCTL_FIOASYNC;\nextern unsigned IOCTL_FIOCLEX;\nextern unsigned IOCTL_FIOGETOWN;\nextern unsigned IOCTL_FIONBIO;\nextern unsigned IOCTL_FIONCLEX;\nextern unsigned IOCTL_FIOSETOWN;\nextern unsigned IOCTL_SIOCADDMULTI;\nextern unsigned IOCTL_SIOCATMARK;\nextern unsigned IOCTL_SIOCDELMULTI;\nextern unsigned IOCTL_SIOCGIFADDR;\nextern unsigned IOCTL_SIOCGIFBRDADDR;\nextern unsigned IOCTL_SIOCGIFCONF;\nextern unsigned IOCTL_SIOCGIFDSTADDR;\nextern unsigned IOCTL_SIOCGIFFLAGS;\nextern unsigned IOCTL_SIOCGIFMETRIC;\nextern unsigned IOCTL_SIOCGIFMTU;\nextern unsigned IOCTL_SIOCGIFNETMASK;\nextern unsigned IOCTL_SIOCGPGRP;\nextern unsigned IOCTL_SIOCSIFADDR;\nextern unsigned IOCTL_SIOCSIFBRDADDR;\nextern unsigned IOCTL_SIOCSIFDSTADDR;\nextern unsigned IOCTL_SIOCSIFFLAGS;\nextern unsigned IOCTL_SIOCSIFMETRIC;\nextern unsigned IOCTL_SIOCSIFMTU;\nextern unsigned IOCTL_SIOCSIFNETMASK;\nextern unsigned IOCTL_SIOCSPGRP;\nextern unsigned IOCTL_TIOCCONS;\nextern unsigned IOCTL_TIOCEXCL;\nextern unsigned IOCTL_TIOCGETD;\nextern unsigned IOCTL_TIOCGPGRP;\nextern unsigned IOCTL_TIOCGWINSZ;\nextern unsigned IOCTL_TIOCMBIC;\nextern unsigned IOCTL_TIOCMBIS;\nextern unsigned IOCTL_TIOCMGET;\nextern unsigned IOCTL_TIOCMSET;\nextern unsigned IOCTL_TIOCNOTTY;\nextern unsigned IOCTL_TIOCNXCL;\nextern unsigned IOCTL_TIOCOUTQ;\nextern unsigned IOCTL_TIOCPKT;\nextern unsigned IOCTL_TIOCSCTTY;\nextern unsigned IOCTL_TIOCSETD;\nextern unsigned IOCTL_TIOCSPGRP;\nextern unsigned IOCTL_TIOCSTI;\nextern unsigned IOCTL_TIOCSWINSZ;\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nextern unsigned IOCTL_SIOCGETSGCNT;\nextern unsigned IOCTL_SIOCGETVIFCNT;\n#endif\n#if SANITIZER_LINUX\nextern unsigned IOCTL_EVIOCGABS;\nextern unsigned IOCTL_EVIOCGBIT;\nextern unsigned IOCTL_EVIOCGEFFECTS;\nextern unsigned IOCTL_EVIOCGID;\nextern unsigned IOCTL_EVIOCGKEY;\nextern unsigned IOCTL_EVIOCGKEYCODE;\nextern unsigned IOCTL_EVIOCGLED;\nextern unsigned IOCTL_EVIOCGNAME;\nextern unsigned IOCTL_EVIOCGPHYS;\nextern unsigned IOCTL_EVIOCGRAB;\nextern unsigned IOCTL_EVIOCGREP;\nextern unsigned IOCTL_EVIOCGSND;\nextern unsigned IOCTL_EVIOCGSW;\nextern unsigned IOCTL_EVIOCGUNIQ;\nextern unsigned IOCTL_EVIOCGVERSION;\nextern unsigned IOCTL_EVIOCRMFF;\nextern unsigned IOCTL_EVIOCSABS;\nextern unsigned IOCTL_EVIOCSFF;\nextern unsigned IOCTL_EVIOCSKEYCODE;\nextern unsigned IOCTL_EVIOCSREP;\nextern unsigned IOCTL_BLKFLSBUF;\nextern unsigned IOCTL_BLKGETSIZE;\nextern unsigned IOCTL_BLKRAGET;\nextern unsigned IOCTL_BLKRASET;\nextern unsigned IOCTL_BLKROGET;\nextern unsigned IOCTL_BLKROSET;\nextern unsigned IOCTL_BLKRRPART;\nextern unsigned IOCTL_CDROMAUDIOBUFSIZ;\nextern unsigned IOCTL_CDROMEJECT;\nextern unsigned IOCTL_CDROMEJECT_SW;\nextern unsigned IOCTL_CDROMMULTISESSION;\nextern unsigned IOCTL_CDROMPAUSE;\nextern unsigned IOCTL_CDROMPLAYMSF;\nextern unsigned IOCTL_CDROMPLAYTRKIND;\nextern unsigned IOCTL_CDROMREADAUDIO;\nextern unsigned IOCTL_CDROMREADCOOKED;\nextern unsigned IOCTL_CDROMREADMODE1;\nextern unsigned IOCTL_CDROMREADMODE2;\nextern unsigned IOCTL_CDROMREADRAW;\nextern unsigned IOCTL_CDROMREADTOCENTRY;\nextern unsigned IOCTL_CDROMREADTOCHDR;\nextern unsigned IOCTL_CDROMRESET;\nextern unsigned IOCTL_CDROMRESUME;\nextern unsigned IOCTL_CDROMSEEK;\nextern unsigned IOCTL_CDROMSTART;\nextern unsigned IOCTL_CDROMSTOP;\nextern unsigned IOCTL_CDROMSUBCHNL;\nextern unsigned IOCTL_CDROMVOLCTRL;\nextern unsigned IOCTL_CDROMVOLREAD;\nextern unsigned IOCTL_CDROM_GET_UPC;\nextern unsigned IOCTL_FDCLRPRM;\nextern unsigned IOCTL_FDDEFPRM;\nextern unsigned IOCTL_FDFLUSH;\nextern unsigned IOCTL_FDFMTBEG;\nextern unsigned IOCTL_FDFMTEND;\nextern unsigned IOCTL_FDFMTTRK;\nextern unsigned IOCTL_FDGETDRVPRM;\nextern unsigned IOCTL_FDGETDRVSTAT;\nextern unsigned IOCTL_FDGETDRVTYP;\nextern unsigned IOCTL_FDGETFDCSTAT;\nextern unsigned IOCTL_FDGETMAXERRS;\nextern unsigned IOCTL_FDGETPRM;\nextern unsigned IOCTL_FDMSGOFF;\nextern unsigned IOCTL_FDMSGON;\nextern unsigned IOCTL_FDPOLLDRVSTAT;\nextern unsigned IOCTL_FDRAWCMD;\nextern unsigned IOCTL_FDRESET;\nextern unsigned IOCTL_FDSETDRVPRM;\nextern unsigned IOCTL_FDSETEMSGTRESH;\nextern unsigned IOCTL_FDSETMAXERRS;\nextern unsigned IOCTL_FDSETPRM;\nextern unsigned IOCTL_FDTWADDLE;\nextern unsigned IOCTL_FDWERRORCLR;\nextern unsigned IOCTL_FDWERRORGET;\nextern unsigned IOCTL_HDIO_DRIVE_CMD;\nextern unsigned IOCTL_HDIO_GETGEO;\nextern unsigned IOCTL_HDIO_GET_32BIT;\nextern unsigned IOCTL_HDIO_GET_DMA;\nextern unsigned IOCTL_HDIO_GET_IDENTITY;\nextern unsigned IOCTL_HDIO_GET_KEEPSETTINGS;\nextern unsigned IOCTL_HDIO_GET_MULTCOUNT;\nextern unsigned IOCTL_HDIO_GET_NOWERR;\nextern unsigned IOCTL_HDIO_GET_UNMASKINTR;\nextern unsigned IOCTL_HDIO_SET_32BIT;\nextern unsigned IOCTL_HDIO_SET_DMA;\nextern unsigned IOCTL_HDIO_SET_KEEPSETTINGS;\nextern unsigned IOCTL_HDIO_SET_MULTCOUNT;\nextern unsigned IOCTL_HDIO_SET_NOWERR;\nextern unsigned IOCTL_HDIO_SET_UNMASKINTR;\nextern unsigned IOCTL_MTIOCPOS;\nextern unsigned IOCTL_PPPIOCGASYNCMAP;\nextern unsigned IOCTL_PPPIOCGDEBUG;\nextern unsigned IOCTL_PPPIOCGFLAGS;\nextern unsigned IOCTL_PPPIOCGUNIT;\nextern unsigned IOCTL_PPPIOCGXASYNCMAP;\nextern unsigned IOCTL_PPPIOCSASYNCMAP;\nextern unsigned IOCTL_PPPIOCSDEBUG;\nextern unsigned IOCTL_PPPIOCSFLAGS;\nextern unsigned IOCTL_PPPIOCSMAXCID;\nextern unsigned IOCTL_PPPIOCSMRU;\nextern unsigned IOCTL_PPPIOCSXASYNCMAP;\nextern unsigned IOCTL_SIOCDARP;\nextern unsigned IOCTL_SIOCDRARP;\nextern unsigned IOCTL_SIOCGARP;\nextern unsigned IOCTL_SIOCGIFENCAP;\nextern unsigned IOCTL_SIOCGIFHWADDR;\nextern unsigned IOCTL_SIOCGIFMAP;\nextern unsigned IOCTL_SIOCGIFMEM;\nextern unsigned IOCTL_SIOCGIFNAME;\nextern unsigned IOCTL_SIOCGIFSLAVE;\nextern unsigned IOCTL_SIOCGRARP;\nextern unsigned IOCTL_SIOCGSTAMP;\nextern unsigned IOCTL_SIOCSARP;\nextern unsigned IOCTL_SIOCSIFENCAP;\nextern unsigned IOCTL_SIOCSIFHWADDR;\nextern unsigned IOCTL_SIOCSIFLINK;\nextern unsigned IOCTL_SIOCSIFMAP;\nextern unsigned IOCTL_SIOCSIFMEM;\nextern unsigned IOCTL_SIOCSIFSLAVE;\nextern unsigned IOCTL_SIOCSRARP;\nextern unsigned IOCTL_SNDCTL_COPR_HALT;\nextern unsigned IOCTL_SNDCTL_COPR_LOAD;\nextern unsigned IOCTL_SNDCTL_COPR_RCODE;\nextern unsigned IOCTL_SNDCTL_COPR_RCVMSG;\nextern unsigned IOCTL_SNDCTL_COPR_RDATA;\nextern unsigned IOCTL_SNDCTL_COPR_RESET;\nextern unsigned IOCTL_SNDCTL_COPR_RUN;\nextern unsigned IOCTL_SNDCTL_COPR_SENDMSG;\nextern unsigned IOCTL_SNDCTL_COPR_WCODE;\nextern unsigned IOCTL_SNDCTL_COPR_WDATA;\nextern unsigned IOCTL_TCFLSH;\nextern unsigned IOCTL_TCGETA;\nextern unsigned IOCTL_TCGETS;\nextern unsigned IOCTL_TCSBRK;\nextern unsigned IOCTL_TCSBRKP;\nextern unsigned IOCTL_TCSETA;\nextern unsigned IOCTL_TCSETAF;\nextern unsigned IOCTL_TCSETAW;\nextern unsigned IOCTL_TCSETS;\nextern unsigned IOCTL_TCSETSF;\nextern unsigned IOCTL_TCSETSW;\nextern unsigned IOCTL_TCXONC;\nextern unsigned IOCTL_TIOCGLCKTRMIOS;\nextern unsigned IOCTL_TIOCGSOFTCAR;\nextern unsigned IOCTL_TIOCINQ;\nextern unsigned IOCTL_TIOCLINUX;\nextern unsigned IOCTL_TIOCSERCONFIG;\nextern unsigned IOCTL_TIOCSERGETLSR;\nextern unsigned IOCTL_TIOCSERGWILD;\nextern unsigned IOCTL_TIOCSERSWILD;\nextern unsigned IOCTL_TIOCSLCKTRMIOS;\nextern unsigned IOCTL_TIOCSSOFTCAR;\nextern unsigned IOCTL_VT_DISALLOCATE;\nextern unsigned IOCTL_VT_GETSTATE;\nextern unsigned IOCTL_VT_RESIZE;\nextern unsigned IOCTL_VT_RESIZEX;\nextern unsigned IOCTL_VT_SENDSIG;\nextern unsigned IOCTL_MTIOCGET;\nextern unsigned IOCTL_MTIOCTOP;\nextern unsigned IOCTL_SIOCADDRT;\nextern unsigned IOCTL_SIOCDELRT;\nextern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\nextern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\nextern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\nextern unsigned IOCTL_SNDCTL_DSP_POST;\nextern unsigned IOCTL_SNDCTL_DSP_RESET;\nextern unsigned IOCTL_SNDCTL_DSP_SETFMT;\nextern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\nextern unsigned IOCTL_SNDCTL_DSP_SPEED;\nextern unsigned IOCTL_SNDCTL_DSP_STEREO;\nextern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\nextern unsigned IOCTL_SNDCTL_DSP_SYNC;\nextern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\nextern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\nextern unsigned IOCTL_SNDCTL_MIDI_INFO;\nextern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\nextern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\nextern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\nextern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\nextern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\nextern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\nextern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\nextern unsigned IOCTL_SNDCTL_SEQ_PANIC;\nextern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\nextern unsigned IOCTL_SNDCTL_SEQ_RESET;\nextern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\nextern unsigned IOCTL_SNDCTL_SEQ_SYNC;\nextern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\nextern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\nextern unsigned IOCTL_SNDCTL_SYNTH_INFO;\nextern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\nextern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\nextern unsigned IOCTL_SNDCTL_TMR_METRONOME;\nextern unsigned IOCTL_SNDCTL_TMR_SELECT;\nextern unsigned IOCTL_SNDCTL_TMR_SOURCE;\nextern unsigned IOCTL_SNDCTL_TMR_START;\nextern unsigned IOCTL_SNDCTL_TMR_STOP;\nextern unsigned IOCTL_SNDCTL_TMR_TEMPO;\nextern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\nextern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\nextern unsigned IOCTL_SOUND_MIXER_READ_BASS;\nextern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\nextern unsigned IOCTL_SOUND_MIXER_READ_CD;\nextern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\nextern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\nextern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\nextern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\nextern unsigned IOCTL_SOUND_MIXER_READ_LINE;\nextern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\nextern unsigned IOCTL_SOUND_MIXER_READ_MIC;\nextern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\nextern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\nextern unsigned IOCTL_SOUND_MIXER_READ_PCM;\nextern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\nextern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\nextern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\nextern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\nextern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\nextern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\nextern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\nextern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\nextern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\nextern unsigned IOCTL_SOUND_PCM_READ_BITS;\nextern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\nextern unsigned IOCTL_SOUND_PCM_READ_FILTER;\nextern unsigned IOCTL_SOUND_PCM_READ_RATE;\nextern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\nextern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\nextern unsigned IOCTL_VT_ACTIVATE;\nextern unsigned IOCTL_VT_GETMODE;\nextern unsigned IOCTL_VT_OPENQRY;\nextern unsigned IOCTL_VT_RELDISP;\nextern unsigned IOCTL_VT_SETMODE;\nextern unsigned IOCTL_VT_WAITACTIVE;\n#endif  // SANITIZER_LINUX\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nextern unsigned IOCTL_CYGETDEFTHRESH;\nextern unsigned IOCTL_CYGETDEFTIMEOUT;\nextern unsigned IOCTL_CYGETMON;\nextern unsigned IOCTL_CYGETTHRESH;\nextern unsigned IOCTL_CYGETTIMEOUT;\nextern unsigned IOCTL_CYSETDEFTHRESH;\nextern unsigned IOCTL_CYSETDEFTIMEOUT;\nextern unsigned IOCTL_CYSETTHRESH;\nextern unsigned IOCTL_CYSETTIMEOUT;\nextern unsigned IOCTL_EQL_EMANCIPATE;\nextern unsigned IOCTL_EQL_ENSLAVE;\nextern unsigned IOCTL_EQL_GETMASTRCFG;\nextern unsigned IOCTL_EQL_GETSLAVECFG;\nextern unsigned IOCTL_EQL_SETMASTRCFG;\nextern unsigned IOCTL_EQL_SETSLAVECFG;\nextern unsigned IOCTL_EVIOCGKEYCODE_V2;\nextern unsigned IOCTL_EVIOCGPROP;\nextern unsigned IOCTL_EVIOCSKEYCODE_V2;\nextern unsigned IOCTL_FS_IOC_GETFLAGS;\nextern unsigned IOCTL_FS_IOC_GETVERSION;\nextern unsigned IOCTL_FS_IOC_SETFLAGS;\nextern unsigned IOCTL_FS_IOC_SETVERSION;\nextern unsigned IOCTL_GIO_CMAP;\nextern unsigned IOCTL_GIO_FONT;\nextern unsigned IOCTL_GIO_UNIMAP;\nextern unsigned IOCTL_GIO_UNISCRNMAP;\nextern unsigned IOCTL_KDADDIO;\nextern unsigned IOCTL_KDDELIO;\nextern unsigned IOCTL_KDGETKEYCODE;\nextern unsigned IOCTL_KDGKBDIACR;\nextern unsigned IOCTL_KDGKBENT;\nextern unsigned IOCTL_KDGKBLED;\nextern unsigned IOCTL_KDGKBMETA;\nextern unsigned IOCTL_KDGKBSENT;\nextern unsigned IOCTL_KDMAPDISP;\nextern unsigned IOCTL_KDSETKEYCODE;\nextern unsigned IOCTL_KDSIGACCEPT;\nextern unsigned IOCTL_KDSKBDIACR;\nextern unsigned IOCTL_KDSKBENT;\nextern unsigned IOCTL_KDSKBLED;\nextern unsigned IOCTL_KDSKBMETA;\nextern unsigned IOCTL_KDSKBSENT;\nextern unsigned IOCTL_KDUNMAPDISP;\nextern unsigned IOCTL_LPABORT;\nextern unsigned IOCTL_LPABORTOPEN;\nextern unsigned IOCTL_LPCAREFUL;\nextern unsigned IOCTL_LPCHAR;\nextern unsigned IOCTL_LPGETIRQ;\nextern unsigned IOCTL_LPGETSTATUS;\nextern unsigned IOCTL_LPRESET;\nextern unsigned IOCTL_LPSETIRQ;\nextern unsigned IOCTL_LPTIME;\nextern unsigned IOCTL_LPWAIT;\nextern unsigned IOCTL_MTIOCGETCONFIG;\nextern unsigned IOCTL_MTIOCSETCONFIG;\nextern unsigned IOCTL_PIO_CMAP;\nextern unsigned IOCTL_PIO_FONT;\nextern unsigned IOCTL_PIO_UNIMAP;\nextern unsigned IOCTL_PIO_UNIMAPCLR;\nextern unsigned IOCTL_PIO_UNISCRNMAP;\nextern unsigned IOCTL_SCSI_IOCTL_GET_IDLUN;\nextern unsigned IOCTL_SCSI_IOCTL_PROBE_HOST;\nextern unsigned IOCTL_SCSI_IOCTL_TAGGED_DISABLE;\nextern unsigned IOCTL_SCSI_IOCTL_TAGGED_ENABLE;\nextern unsigned IOCTL_SIOCAIPXITFCRT;\nextern unsigned IOCTL_SIOCAIPXPRISLT;\nextern unsigned IOCTL_SIOCAX25ADDUID;\nextern unsigned IOCTL_SIOCAX25DELUID;\nextern unsigned IOCTL_SIOCAX25GETPARMS;\nextern unsigned IOCTL_SIOCAX25GETUID;\nextern unsigned IOCTL_SIOCAX25NOUID;\nextern unsigned IOCTL_SIOCAX25SETPARMS;\nextern unsigned IOCTL_SIOCDEVPLIP;\nextern unsigned IOCTL_SIOCIPXCFGDATA;\nextern unsigned IOCTL_SIOCNRDECOBS;\nextern unsigned IOCTL_SIOCNRGETPARMS;\nextern unsigned IOCTL_SIOCNRRTCTL;\nextern unsigned IOCTL_SIOCNRSETPARMS;\nextern unsigned IOCTL_SNDCTL_DSP_GETISPACE;\nextern unsigned IOCTL_SNDCTL_DSP_GETOSPACE;\nextern unsigned IOCTL_TIOCGSERIAL;\nextern unsigned IOCTL_TIOCSERGETMULTI;\nextern unsigned IOCTL_TIOCSERSETMULTI;\nextern unsigned IOCTL_TIOCSSERIAL;\nextern unsigned IOCTL_GIO_SCRNMAP;\nextern unsigned IOCTL_KDDISABIO;\nextern unsigned IOCTL_KDENABIO;\nextern unsigned IOCTL_KDGETLED;\nextern unsigned IOCTL_KDGETMODE;\nextern unsigned IOCTL_KDGKBMODE;\nextern unsigned IOCTL_KDGKBTYPE;\nextern unsigned IOCTL_KDMKTONE;\nextern unsigned IOCTL_KDSETLED;\nextern unsigned IOCTL_KDSETMODE;\nextern unsigned IOCTL_KDSKBMODE;\nextern unsigned IOCTL_KIOCSOUND;\nextern unsigned IOCTL_PIO_SCRNMAP;\n#endif\n\nextern const int si_SEGV_MAPERR;\nextern const int si_SEGV_ACCERR;\n}  // namespace __sanitizer\n\n#define CHECK_TYPE_SIZE(TYPE) \\\n  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n\n#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *)NULL)->MEMBER) == \\\n                 sizeof(((CLASS *)NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==         \\\n                 offsetof(CLASS, MEMBER))\n\n// For sigaction, which is a function and struct at the same time,\n// and thus requires explicit \"struct\" in sizeof() expression.\n#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                      \\\n  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *)NULL)->MEMBER) == \\\n                 sizeof(((struct CLASS *)NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==         \\\n                 offsetof(struct CLASS, MEMBER))\n\n#define SIGACTION_SYMNAME sigaction\n\n#endif  // SANITIZER_LINUX || SANITIZER_MAC\n\n#endif\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_solaris.h", "content": "//===-- sanitizer_platform_limits_solaris.h -------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of Sanitizer common code.\n//\n// Sizes and layouts of platform-specific Solaris data structures.\n//===----------------------------------------------------------------------===//\n\n#ifndef SANITIZER_PLATFORM_LIMITS_SOLARIS_H\n#define SANITIZER_PLATFORM_LIMITS_SOLARIS_H\n\n#if SANITIZER_SOLARIS\n\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_platform.h\"\n\nnamespace __sanitizer {\nextern unsigned struct_utsname_sz;\nextern unsigned struct_stat_sz;\nextern unsigned struct_stat64_sz;\nextern unsigned struct_rusage_sz;\nextern unsigned siginfo_t_sz;\nextern unsigned struct_itimerval_sz;\nextern unsigned pthread_t_sz;\nextern unsigned pthread_mutex_t_sz;\nextern unsigned pthread_cond_t_sz;\nextern unsigned pid_t_sz;\nextern unsigned timeval_sz;\nextern unsigned uid_t_sz;\nextern unsigned gid_t_sz;\nextern unsigned mbstate_t_sz;\nextern unsigned struct_timezone_sz;\nextern unsigned struct_tms_sz;\nextern unsigned struct_itimerspec_sz;\nextern unsigned struct_sigevent_sz;\nextern unsigned struct_stack_t_sz;\nextern unsigned struct_sched_param_sz;\nextern unsigned struct_statfs64_sz;\nextern unsigned struct_statfs_sz;\nextern unsigned struct_sockaddr_sz;\nextern unsigned ucontext_t_sz;\n\nextern unsigned struct_timespec_sz;\nextern unsigned struct_rlimit_sz;\nextern unsigned struct_utimbuf_sz;\n\nstruct __sanitizer_sem_t {\n  //u64 data[6];\n  u32 sem_count;\n  u16 sem_type;\n  u16 sem_magic;\n  u64 sem_pad1[3];\n  u64 sem_pad2[2];\n};\n\nstruct __sanitizer_ipc_perm {\n  unsigned int uid;           // uid_t\n  unsigned int gid;           // gid_t\n  unsigned int cuid;          // uid_t\n  unsigned int cgid;          // gid_t\n  unsigned int mode;          // mode_t\n  unsigned int seq;           // uint_t\n  int key;                    // key_t\n#if !defined(_LP64)\n  int pad[4];\n#endif\n};\n\nstruct __sanitizer_shmid_ds {\n  __sanitizer_ipc_perm shm_perm;\n  unsigned long shm_segsz;    // size_t\n  unsigned long shm_flags;    // uintptr_t\n  unsigned short shm_lkcnt;   // ushort_t\n  int shm_lpid;               // pid_t\n  int shm_cpid;               // pid_t\n  unsigned long shm_nattch;   // shmatt_t\n  unsigned long shm_cnattch;  // ulong_t\n#if defined(_LP64)\n  long shm_atime;             // time_t\n  long shm_dtime;\n  long shm_ctime;\n  void *shm_amp;\n  u64 shm_gransize;           // uint64_t\n  u64 shm_allocated;          // uint64_t\n  u64 shm_pad4[1];            // int64_t\n#else\n  long shm_atime;             // time_t\n  int shm_pad1;               // int32_t\n  long shm_dtime;             // time_t\n  int shm_pad2;               // int32_t\n  long shm_ctime;             // time_t\n  void *shm_amp;\n  u64 shm_gransize;           // uint64_t\n  u64 shm_allocated;          // uint64_t\n#endif\n};\n\nextern unsigned struct_statvfs_sz;\n#if SANITIZER_SOLARIS32\nextern unsigned struct_statvfs64_sz;\n#endif\n\nstruct __sanitizer_iovec {\n  void *iov_base;\n  uptr iov_len;\n};\n\nstruct __sanitizer_ifaddrs {\n  struct __sanitizer_ifaddrs *ifa_next;\n  char *ifa_name;\n  u64 ifa_flags;     // uint64_t\n  void *ifa_addr;    // (struct sockaddr *)\n  void *ifa_netmask; // (struct sockaddr *)\n  // This is a union on Linux.\n# ifdef ifa_dstaddr\n# undef ifa_dstaddr\n# endif\n  void *ifa_dstaddr; // (struct sockaddr *)\n  void *ifa_data;\n};\n\ntypedef unsigned __sanitizer_pthread_key_t;\n\nstruct __sanitizer_XDR {\n  int x_op;\n  void *x_ops;\n  uptr x_public;\n  uptr x_private;\n  uptr x_base;\n  unsigned x_handy;\n};\n\nconst int __sanitizer_XDR_ENCODE = 0;\nconst int __sanitizer_XDR_DECODE = 1;\nconst int __sanitizer_XDR_FREE = 2;\n\nstruct __sanitizer_passwd {\n  char *pw_name;\n  char *pw_passwd;\n  unsigned int pw_uid;    // uid_t\n  unsigned int pw_gid;    // gid_t\n  char *pw_age;\n  char *pw_comment;\n  char *pw_gecos;\n  char *pw_dir;\n  char *pw_shell;\n};\n\nstruct __sanitizer_group {\n  char *gr_name;\n  char *gr_passwd;\n  int gr_gid;\n  char **gr_mem;\n};\n\ntypedef long __sanitizer_time_t;\n\ntypedef long __sanitizer_suseconds_t;\n\nstruct __sanitizer_timeval {\n  __sanitizer_time_t tv_sec;\n  __sanitizer_suseconds_t tv_usec;\n};\n\nstruct __sanitizer_itimerval {\n  struct __sanitizer_timeval it_interval;\n  struct __sanitizer_timeval it_value;\n};\n\nstruct __sanitizer_timeb {\n  __sanitizer_time_t time;\n  unsigned short millitm;\n  short timezone;\n  short dstflag;\n};\n\nstruct __sanitizer_ether_addr {\n  u8 octet[6];\n};\n\nstruct __sanitizer_tm {\n  int tm_sec;\n  int tm_min;\n  int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n};\n\nstruct __sanitizer_msghdr {\n  void *msg_name;\n  unsigned msg_namelen;\n  struct __sanitizer_iovec *msg_iov;\n  unsigned msg_iovlen;\n  void *msg_control;\n  unsigned msg_controllen;\n  int msg_flags;\n};\nstruct __sanitizer_cmsghdr {\n  unsigned cmsg_len;\n  int cmsg_level;\n  int cmsg_type;\n};\n\n#if SANITIZER_SOLARIS && (defined(_LP64) || _FILE_OFFSET_BITS == 64)\nstruct __sanitizer_dirent {\n  unsigned long long d_ino;\n  long long d_off;\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n#else\nstruct __sanitizer_dirent {\n  unsigned long d_ino;\n  long d_off;\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n#endif\n\nstruct __sanitizer_dirent64 {\n  unsigned long long d_ino;\n  unsigned long long d_off;\n  unsigned short d_reclen;\n  // more fields that we don't care about\n};\n\ntypedef long __sanitizer_clock_t;\ntypedef int __sanitizer_clockid_t;\n\n// This thing depends on the platform. We are only interested in the upper\n// limit. Verified with a compiler assert in .cpp.\nunion __sanitizer_pthread_attr_t {\n  char size[128];\n  void *align;\n};\n\nstruct __sanitizer_sigset_t {\n  // uint32_t * 4\n  unsigned int __bits[4];\n};\n\nstruct __sanitizer_siginfo {\n  // The size is determined by looking at sizeof of real siginfo_t on linux.\n  u64 opaque[128 / sizeof(u64)];\n};\n\nusing __sanitizer_sighandler_ptr = void (*)(int sig);\nusing __sanitizer_sigactionhandler_ptr =\n    void (*)(int sig, __sanitizer_siginfo *siginfo, void *uctx);\n\nstruct __sanitizer_sigaction {\n  int sa_flags;\n  union {\n    __sanitizer_sigactionhandler_ptr sigaction;\n    __sanitizer_sighandler_ptr handler;\n  };\n  __sanitizer_sigset_t sa_mask;\n#if !defined(_LP64)\n  int sa_resv[2];\n#endif\n};\n\nstruct __sanitizer_kernel_sigset_t {\n  u8 sig[8];\n};\n\nstruct __sanitizer_kernel_sigaction_t {\n  union {\n    void (*handler)(int signo);\n    void (*sigaction)(int signo, __sanitizer_siginfo *info, void *ctx);\n  };\n  unsigned long sa_flags;\n  void (*sa_restorer)(void);\n  __sanitizer_kernel_sigset_t sa_mask;\n};\n\nextern const uptr sig_ign;\nextern const uptr sig_dfl;\nextern const uptr sig_err;\nextern const uptr sa_siginfo;\n\nextern int af_inet;\nextern int af_inet6;\nuptr __sanitizer_in_addr_sz(int af);\n\nstruct __sanitizer_dl_phdr_info {\n  uptr dlpi_addr;\n  const char *dlpi_name;\n  const void *dlpi_phdr;\n  short dlpi_phnum;\n};\n\nextern unsigned struct_ElfW_Phdr_sz;\n\nstruct __sanitizer_addrinfo {\n  int ai_flags;\n  int ai_family;\n  int ai_socktype;\n  int ai_protocol;\n#if defined(__sparcv9)\n  int _ai_pad;\n#endif\n  unsigned ai_addrlen;\n  char *ai_canonname;\n  void *ai_addr;\n  struct __sanitizer_addrinfo *ai_next;\n};\n\nstruct __sanitizer_hostent {\n  char *h_name;\n  char **h_aliases;\n  int h_addrtype;\n  int h_length;\n  char **h_addr_list;\n};\n\nstruct __sanitizer_pollfd {\n  int fd;\n  short events;\n  short revents;\n};\n\ntypedef unsigned long __sanitizer_nfds_t;\n\nstruct __sanitizer_glob_t {\n  uptr gl_pathc;\n  char **gl_pathv;\n  uptr gl_offs;\n  char **gl_pathp;\n  int gl_pathn;\n};\n\nextern int glob_nomatch;\nextern int glob_altdirfunc;\n\nextern unsigned path_max;\n\nstruct __sanitizer_wordexp_t {\n  uptr we_wordc;\n  char **we_wordv;\n  uptr we_offs;\n  char **we_wordp;\n  int we_wordn;\n};\n\ntypedef void __sanitizer_FILE;\n#define SANITIZER_HAS_STRUCT_FILE 0\n\n// This simplifies generic code\n#define struct_shminfo_sz -1\n#define struct_shm_info_sz -1\n#define shmctl_shm_stat -1\n#define shmctl_ipc_info -1\n#define shmctl_shm_info -1\n\nextern int shmctl_ipc_stat;\n\nextern unsigned struct_utmp_sz;\nextern unsigned struct_utmpx_sz;\n\nextern int map_fixed;\n\n// ioctl arguments\nstruct __sanitizer_ifconf {\n  int ifc_len;\n  union {\n    void *ifcu_req;\n  } ifc_ifcu;\n};\n\n// <sys/ioccom.h>\n#define IOC_NRBITS 8\n#define IOC_TYPEBITS 8\n#define IOC_SIZEBITS 12\n#define IOC_DIRBITS 4\n#undef IOC_NONE\n#define IOC_NONE 2U     // IOC_VOID\n#define IOC_READ 4U     // IOC_OUT\n#define IOC_WRITE 8U    // IOC_IN\n\n#define IOC_NRMASK ((1 << IOC_NRBITS) - 1)\n#define IOC_TYPEMASK ((1 << IOC_TYPEBITS) - 1)\n#define IOC_SIZEMASK ((1 << IOC_SIZEBITS) - 1)\n#define IOC_DIRMASK ((1 << IOC_DIRBITS) - 1)\n#define IOC_NRSHIFT 0\n#define IOC_TYPESHIFT (IOC_NRSHIFT + IOC_NRBITS)\n#define IOC_SIZESHIFT (IOC_TYPESHIFT + IOC_TYPEBITS)\n#define IOC_DIRSHIFT (IOC_SIZESHIFT + IOC_SIZEBITS)\n\n#define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n#define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n#define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n\n#if defined(__sparc__)\n// In sparc the 14 bits SIZE field overlaps with the\n// least significant bit of DIR, so either IOC_READ or\n// IOC_WRITE shall be 1 in order to get a non-zero SIZE.\n#define IOC_SIZE(nr) \\\n  ((((((nr) >> 29) & 0x7) & (4U | 2U)) == 0) ? 0 : (((nr) >> 16) & 0x3fff))\n#else\n#define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n#endif\n\nextern unsigned struct_ifreq_sz;\nextern unsigned struct_termios_sz;\nextern unsigned struct_winsize_sz;\n\nextern unsigned struct_sioc_sg_req_sz;\nextern unsigned struct_sioc_vif_req_sz;\n\n// ioctl request identifiers\n\n// A special value to mark ioctls that are not present on the target platform,\n// when it can not be determined without including any system headers.\nextern const unsigned IOCTL_NOT_PRESENT;\n\nextern unsigned IOCTL_FIOASYNC;\nextern unsigned IOCTL_FIOCLEX;\nextern unsigned IOCTL_FIOGETOWN;\nextern unsigned IOCTL_FIONBIO;\nextern unsigned IOCTL_FIONCLEX;\nextern unsigned IOCTL_FIOSETOWN;\nextern unsigned IOCTL_SIOCADDMULTI;\nextern unsigned IOCTL_SIOCATMARK;\nextern unsigned IOCTL_SIOCDELMULTI;\nextern unsigned IOCTL_SIOCGIFADDR;\nextern unsigned IOCTL_SIOCGIFBRDADDR;\nextern unsigned IOCTL_SIOCGIFCONF;\nextern unsigned IOCTL_SIOCGIFDSTADDR;\nextern unsigned IOCTL_SIOCGIFFLAGS;\nextern unsigned IOCTL_SIOCGIFMETRIC;\nextern unsigned IOCTL_SIOCGIFMTU;\nextern unsigned IOCTL_SIOCGIFNETMASK;\nextern unsigned IOCTL_SIOCGPGRP;\nextern unsigned IOCTL_SIOCSIFADDR;\nextern unsigned IOCTL_SIOCSIFBRDADDR;\nextern unsigned IOCTL_SIOCSIFDSTADDR;\nextern unsigned IOCTL_SIOCSIFFLAGS;\nextern unsigned IOCTL_SIOCSIFMETRIC;\nextern unsigned IOCTL_SIOCSIFMTU;\nextern unsigned IOCTL_SIOCSIFNETMASK;\nextern unsigned IOCTL_SIOCSPGRP;\nextern unsigned IOCTL_TIOCEXCL;\nextern unsigned IOCTL_TIOCGETD;\nextern unsigned IOCTL_TIOCGPGRP;\nextern unsigned IOCTL_TIOCGWINSZ;\nextern unsigned IOCTL_TIOCMBIC;\nextern unsigned IOCTL_TIOCMBIS;\nextern unsigned IOCTL_TIOCMGET;\nextern unsigned IOCTL_TIOCMSET;\nextern unsigned IOCTL_TIOCNOTTY;\nextern unsigned IOCTL_TIOCNXCL;\nextern unsigned IOCTL_TIOCOUTQ;\nextern unsigned IOCTL_TIOCPKT;\nextern unsigned IOCTL_TIOCSCTTY;\nextern unsigned IOCTL_TIOCSETD;\nextern unsigned IOCTL_TIOCSPGRP;\nextern unsigned IOCTL_TIOCSTI;\nextern unsigned IOCTL_TIOCSWINSZ;\nextern unsigned IOCTL_MTIOCGET;\nextern unsigned IOCTL_MTIOCTOP;\n\nextern const int si_SEGV_MAPERR;\nextern const int si_SEGV_ACCERR;\n}  // namespace __sanitizer\n\n#define CHECK_TYPE_SIZE(TYPE) \\\n  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n\n#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *) NULL)->MEMBER) == \\\n                 sizeof(((CLASS *) NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==          \\\n                 offsetof(CLASS, MEMBER))\n\n// For sigaction, which is a function and struct at the same time,\n// and thus requires explicit \"struct\" in sizeof() expression.\n#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *) NULL)->MEMBER) == \\\n                 sizeof(((struct CLASS *) NULL)->MEMBER));                \\\n  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n                 offsetof(struct CLASS, MEMBER))\n\n#endif  // SANITIZER_SOLARIS\n\n#endif\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_posix.h", "content": "//===-- sanitizer_posix.h -------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between AddressSanitizer and ThreadSanitizer\n// run-time libraries and declares some useful POSIX-specific functions.\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_POSIX_H\n#define SANITIZER_POSIX_H\n\n// ----------- ATTENTION -------------\n// This header should NOT include any other headers from sanitizer runtime.\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_platform_limits_freebsd.h\"\n#include \"sanitizer_platform_limits_netbsd.h\"\n#include \"sanitizer_platform_limits_posix.h\"\n#include \"sanitizer_platform_limits_solaris.h\"\n\n#if !SANITIZER_POSIX\n// Make it hard to accidentally use any of functions declared in this file:\n#error This file should only be included on POSIX\n#endif\n\nnamespace __sanitizer {\n\n// I/O\n// Don't use directly, use __sanitizer::OpenFile() instead.\nuptr internal_open(const char *filename, int flags);\nuptr internal_open(const char *filename, int flags, u32 mode);\nuptr internal_close(fd_t fd);\n\nuptr internal_read(fd_t fd, void *buf, uptr count);\nuptr internal_write(fd_t fd, const void *buf, uptr count);\n\n// Memory\nuptr internal_mmap(void *addr, uptr length, int prot, int flags,\n                   int fd, u64 offset);\nuptr internal_munmap(void *addr, uptr length);\n#if SANITIZER_LINUX\nuptr internal_mremap(void *old_address, uptr old_size, uptr new_size, int flags,\n                     void *new_address);\n#endif\nint internal_mprotect(void *addr, uptr length, int prot);\nint internal_madvise(uptr addr, uptr length, int advice);\n\n// OS\nuptr internal_filesize(fd_t fd);  // -1 on error.\nuptr internal_stat(const char *path, void *buf);\nuptr internal_lstat(const char *path, void *buf);\nuptr internal_fstat(fd_t fd, void *buf);\nuptr internal_dup(int oldfd);\nuptr internal_dup2(int oldfd, int newfd);\nuptr internal_readlink(const char *path, char *buf, uptr bufsize);\nuptr internal_unlink(const char *path);\nuptr internal_rename(const char *oldpath, const char *newpath);\nuptr internal_lseek(fd_t fd, OFF_T offset, int whence);\n\n#if SANITIZER_NETBSD\nuptr internal_ptrace(int request, int pid, void *addr, int data);\n#else\nuptr internal_ptrace(int request, int pid, void *addr, void *data);\n#endif\nuptr internal_waitpid(int pid, int *status, int options);\n\nint internal_fork();\nfd_t internal_spawn(const char *argv[], const char *envp[], pid_t *pid);\n\nint internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n                    uptr *oldlenp, const void *newp, uptr newlen);\nint internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n                          const void *newp, uptr newlen);\n\n// These functions call appropriate pthread_ functions directly, bypassing\n// the interceptor. They are weak and may not be present in some tools.\nSANITIZER_WEAK_ATTRIBUTE\nint real_pthread_create(void *th, void *attr, void *(*callback)(void *),\n                        void *param);\nSANITIZER_WEAK_ATTRIBUTE\nint real_pthread_join(void *th, void **ret);\n\n#define DEFINE_REAL_PTHREAD_FUNCTIONS                                          \\\n  namespace __sanitizer {                                                      \\\n  int real_pthread_create(void *th, void *attr, void *(*callback)(void *),     \\\n                          void *param) {                                       \\\n    return REAL(pthread_create)(th, attr, callback, param);                    \\\n  }                                                                            \\\n  int real_pthread_join(void *th, void **ret) {                                \\\n    return REAL(pthread_join(th, ret));                                        \\\n  }                                                                            \\\n  }  // namespace __sanitizer\n\nint my_pthread_attr_getstack(void *attr, void **addr, uptr *size);\n\n// A routine named real_sigaction() must be implemented by each sanitizer in\n// order for internal_sigaction() to bypass interceptors.\nint internal_sigaction(int signum, const void *act, void *oldact);\nvoid internal_sigfillset(__sanitizer_sigset_t *set);\nvoid internal_sigemptyset(__sanitizer_sigset_t *set);\nbool internal_sigismember(__sanitizer_sigset_t *set, int signum);\n\nuptr internal_execve(const char *filename, char *const argv[],\n                     char *const envp[]);\n\nbool IsStateDetached(int state);\n\n// Move the fd out of {0, 1, 2} range.\nfd_t ReserveStandardFds(fd_t fd);\n\nbool ShouldMockFailureToOpen(const char *path);\n\n// Create a non-file mapping with a given /proc/self/maps name.\nuptr MmapNamed(void *addr, uptr length, int prot, int flags, const char *name);\n\n// Platforms should implement at most one of these.\n// 1. Provide a pre-decorated file descriptor to use instead of an anonymous\n// mapping.\nint GetNamedMappingFd(const char *name, uptr size, int *flags);\n// 2. Add name to an existing anonymous mapping. The caller must keep *name\n// alive at least as long as the mapping exists.\nvoid DecorateMapping(uptr addr, uptr size, const char *name);\n\n\n}  // namespace __sanitizer\n\n#endif  // SANITIZER_POSIX_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_procmaps.h", "content": "//===-- sanitizer_procmaps.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between AddressSanitizer and ThreadSanitizer.\n//\n// Information about the process mappings.\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_PROCMAPS_H\n#define SANITIZER_PROCMAPS_H\n\n#include \"sanitizer_platform.h\"\n\n#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n    SANITIZER_MAC || SANITIZER_SOLARIS ||  \\\n    SANITIZER_FUCHSIA\n\n#include \"sanitizer_common.h\"\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_fuchsia.h\"\n#include \"sanitizer_linux.h\"\n#include \"sanitizer_mac.h\"\n#include \"sanitizer_mutex.h\"\n\nnamespace __sanitizer {\n\n// Memory protection masks.\nstatic const uptr kProtectionRead = 1;\nstatic const uptr kProtectionWrite = 2;\nstatic const uptr kProtectionExecute = 4;\nstatic const uptr kProtectionShared = 8;\n\nstruct MemoryMappedSegmentData;\n\nclass MemoryMappedSegment {\n public:\n  explicit MemoryMappedSegment(char *buff = nullptr, uptr size = 0)\n      : filename(buff), filename_size(size), data_(nullptr) {}\n  ~MemoryMappedSegment() {}\n\n  bool IsReadable() const { return protection & kProtectionRead; }\n  bool IsWritable() const { return protection & kProtectionWrite; }\n  bool IsExecutable() const { return protection & kProtectionExecute; }\n  bool IsShared() const { return protection & kProtectionShared; }\n\n  void AddAddressRanges(LoadedModule *module);\n\n  uptr start;\n  uptr end;\n  uptr offset;\n  char *filename;  // owned by caller\n  uptr filename_size;\n  uptr protection;\n  ModuleArch arch;\n  u8 uuid[kModuleUUIDSize];\n\n private:\n  friend class MemoryMappingLayout;\n\n  // This field is assigned and owned by MemoryMappingLayout if needed\n  MemoryMappedSegmentData *data_;\n};\n\nclass MemoryMappingLayout {\n public:\n  explicit MemoryMappingLayout(bool cache_enabled);\n  ~MemoryMappingLayout();\n  bool Next(MemoryMappedSegment *segment);\n  bool Error() const;\n  void Reset();\n  // In some cases, e.g. when running under a sandbox on Linux, ASan is unable\n  // to obtain the memory mappings. It should fall back to pre-cached data\n  // instead of aborting.\n  static void CacheMemoryMappings();\n\n  // Adds all mapped objects into a vector.\n  void DumpListOfModules(InternalMmapVectorNoCtor<LoadedModule> *modules);\n\n private:\n  void LoadFromCache();\n\n  MemoryMappingLayoutData data_;\n};\n\n// Returns code range for the specified module.\nbool GetCodeRangeForFile(const char *module, uptr *start, uptr *end);\n\nbool IsDecimal(char c);\nuptr ParseDecimal(const char **p);\nbool IsHex(char c);\nuptr ParseHex(const char **p);\n\n}  // namespace __sanitizer\n\n#endif\n#endif  // SANITIZER_PROCMAPS_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_stacktrace.h", "content": "//===-- sanitizer_stacktrace.h ----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is shared between AddressSanitizer and ThreadSanitizer\n// run-time libraries.\n//===----------------------------------------------------------------------===//\n#ifndef SANITIZER_STACKTRACE_H\n#define SANITIZER_STACKTRACE_H\n\n#include \"sanitizer_internal_defs.h\"\n#include \"sanitizer_platform.h\"\n\nnamespace __sanitizer {\n\nstruct BufferedStackTrace;\n\nstatic const u32 kStackTraceMax = 256;\n\n#if SANITIZER_LINUX && defined(__mips__)\n# define SANITIZER_CAN_FAST_UNWIND 0\n#elif SANITIZER_WINDOWS\n# define SANITIZER_CAN_FAST_UNWIND 0\n#else\n# define SANITIZER_CAN_FAST_UNWIND 1\n#endif\n\n// Fast unwind is the only option on Mac for now; we will need to\n// revisit this macro when slow unwind works on Mac, see\n// https://github.com/google/sanitizers/issues/137\n#if SANITIZER_MAC || SANITIZER_RTEMS\n# define SANITIZER_CAN_SLOW_UNWIND 0\n#else\n# define SANITIZER_CAN_SLOW_UNWIND 1\n#endif\n\nstruct StackTrace {\n  const uptr *trace;\n  u32 size;\n  u32 tag;\n\n  static const int TAG_UNKNOWN = 0;\n  static const int TAG_ALLOC = 1;\n  static const int TAG_DEALLOC = 2;\n  static const int TAG_CUSTOM = 100; // Tool specific tags start here.\n\n  StackTrace() : trace(nullptr), size(0), tag(0) {}\n  StackTrace(const uptr *trace, u32 size) : trace(trace), size(size), tag(0) {}\n  StackTrace(const uptr *trace, u32 size, u32 tag)\n      : trace(trace), size(size), tag(tag) {}\n\n  // Prints a symbolized stacktrace, followed by an empty line.\n  void Print() const;\n\n  static bool WillUseFastUnwind(bool request_fast_unwind) {\n    if (!SANITIZER_CAN_FAST_UNWIND)\n      return false;\n    if (!SANITIZER_CAN_SLOW_UNWIND)\n      return true;\n    return request_fast_unwind;\n  }\n\n  static uptr GetCurrentPc();\n  static inline uptr GetPreviousInstructionPc(uptr pc);\n  static uptr GetNextInstructionPc(uptr pc);\n};\n\n// Performance-critical, must be in the header.\nALWAYS_INLINE\nuptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n#if defined(__arm__)\n  // T32 (Thumb) branch instructions might be 16 or 32 bit long,\n  // so we return (pc-2) in that case in order to be safe.\n  // For A32 mode we return (pc-4) because all instructions are 32 bit long.\n  return (pc - 3) & (~1);\n#elif defined(__powerpc__) || defined(__powerpc64__) || defined(__aarch64__)\n  // PCs are always 4 byte aligned.\n  return pc - 4;\n#elif defined(__sparc__) || defined(__mips__)\n  return pc - 8;\n#elif SANITIZER_RISCV64\n  // RV-64 has variable instruciton length...\n  // C extentions gives us 2-byte instructoins\n  // RV-64 has 4-byte instructions\n  // + RISCV architecture allows instructions up to 8 bytes\n  // It seems difficult to figure out the exact instruction length -\n  // pc - 2 seems like a safe option for the purposes of stack tracing\n  return pc - 2;\n#else\n  return pc - 1;\n#endif\n}\n\n// StackTrace that owns the buffer used to store the addresses.\nstruct BufferedStackTrace : public StackTrace {\n  uptr trace_buffer[kStackTraceMax];\n  uptr top_frame_bp;  // Optional bp of a top frame.\n\n  BufferedStackTrace() : StackTrace(trace_buffer, 0), top_frame_bp(0) {}\n\n  void Init(const uptr *pcs, uptr cnt, uptr extra_top_pc = 0);\n\n  // Get the stack trace with the given pc and bp.\n  // The pc will be in the position 0 of the resulting stack trace.\n  // The bp may refer to the current frame or to the caller's frame.\n  void Unwind(uptr pc, uptr bp, void *context, bool request_fast,\n              u32 max_depth = kStackTraceMax) {\n    top_frame_bp = (max_depth > 0) ? bp : 0;\n    // Small max_depth optimization\n    if (max_depth <= 1) {\n      if (max_depth == 1)\n        trace_buffer[0] = pc;\n      size = max_depth;\n      return;\n    }\n    UnwindImpl(pc, bp, context, request_fast, max_depth);\n  }\n\n  void Unwind(u32 max_depth, uptr pc, uptr bp, void *context, uptr stack_top,\n              uptr stack_bottom, bool request_fast_unwind);\n\n  void Reset() {\n    *static_cast<StackTrace *>(this) = StackTrace(trace_buffer, 0);\n    top_frame_bp = 0;\n  }\n\n private:\n  // Every runtime defines its own implementation of this method\n  void UnwindImpl(uptr pc, uptr bp, void *context, bool request_fast,\n                  u32 max_depth);\n\n  // UnwindFast/Slow have platform-specific implementations\n  void UnwindFast(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom,\n                  u32 max_depth);\n  void UnwindSlow(uptr pc, u32 max_depth);\n  void UnwindSlow(uptr pc, void *context, u32 max_depth);\n\n  void PopStackFrames(uptr count);\n  uptr LocatePcInTrace(uptr pc);\n\n  BufferedStackTrace(const BufferedStackTrace &) = delete;\n  void operator=(const BufferedStackTrace &) = delete;\n\n  friend class FastUnwindTest;\n};\n\n#if defined(__s390x__)\nstatic const uptr kFrameSize = 160;\n#elif defined(__s390__)\nstatic const uptr kFrameSize = 96;\n#else\nstatic const uptr kFrameSize = 2 * sizeof(uhwptr);\n#endif\n\n// Check if given pointer points into allocated stack area.\nstatic inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n  return frame > stack_bottom && frame < stack_top - kFrameSize;\n}\n\n}  // namespace __sanitizer\n\n// Use this macro if you want to print stack trace with the caller\n// of the current function in the top frame.\n#define GET_CALLER_PC_BP \\\n  uptr bp = GET_CURRENT_FRAME();              \\\n  uptr pc = GET_CALLER_PC();\n\n#define GET_CALLER_PC_BP_SP \\\n  GET_CALLER_PC_BP;                           \\\n  uptr local_stack;                           \\\n  uptr sp = (uptr)&local_stack\n\n// Use this macro if you want to print stack trace with the current\n// function in the top frame.\n#define GET_CURRENT_PC_BP \\\n  uptr bp = GET_CURRENT_FRAME();              \\\n  uptr pc = StackTrace::GetCurrentPc()\n\n#define GET_CURRENT_PC_BP_SP \\\n  GET_CURRENT_PC_BP;                          \\\n  uptr local_stack;                           \\\n  uptr sp = (uptr)&local_stack\n\n\n#endif  // SANITIZER_STACKTRACE_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/ubsan/ubsan_platform.h", "content": "//===-- ubsan_platform.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Defines the platforms which UBSan is supported at.\n//\n//===----------------------------------------------------------------------===//\n#ifndef UBSAN_PLATFORM_H\n#define UBSAN_PLATFORM_H\n\n// Other platforms should be easy to add, and probably work as-is.\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n    defined(__NetBSD__) || defined(__DragonFly__) || \\\n    (defined(__sun__) && defined(__svr4__)) || \\\n    defined(_WIN32) || defined(__Fuchsia__) || defined(__rtems__)\n# define CAN_SANITIZE_UB 1\n#else\n# define CAN_SANITIZE_UB 0\n#endif\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_MSAN_MSAN_H (fixit)"}, {"location": {"col": 9, "file": 0, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan.h", "reportHash": "0f168f8843b8bb4fd1bd3c307bddff91", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 13}, "message": "LLVM_COMPILER_RT_LIB_MSAN_MSAN_ALLOCATOR_H (fixit)"}, {"location": {"col": 9, "file": 1, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_allocator.h", "reportHash": "f3bcd5ab9eab9d34a83911d9ce27b939", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 2, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_MSAN_MSAN_FLAGS_H (fixit)"}, {"location": {"col": 9, "file": 2, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_flags.h", "reportHash": "2002bedc28001935b59f7772076a683b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_MSAN_MSAN_INTERFACE_INTERNAL_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_interface_internal.h", "reportHash": "5835fc5c2dd2b47d3c219ebaceb2485d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 4, "line": 15}, "message": "LLVM_COMPILER_RT_LIB_MSAN_MSAN_REPORT_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 15}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_report.h", "reportHash": "17746ebf56f95ed8c21c8982c364519b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 5, "line": 13}, "message": "LLVM_COMPILER_RT_LIB_MSAN_MSAN_THREAD_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/msan/msan_thread.h", "reportHash": "f50e5372036b7842aa41cc20b1ff7fbc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 13}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_ATOMIC_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_atomic.h", "reportHash": "77b725261ef5a994079e25bc7ff1d2c4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 7, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_ATOMIC_CLANG_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_atomic_clang.h", "reportHash": "89d4a5cb7b9c35aff31ec8d2ef8cbee0", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_ATOMIC_CLANG_X86_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_atomic_clang_x86.h", "reportHash": "60a22e1cd2b1520c708784a858e73c82", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 15}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_COMMON_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 15}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_common.h", "reportHash": "0b2e5d8f36b2683d556fe127dc31b033", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 10, "line": 13}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_FLAGS_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_flags.h", "reportHash": "eff869216b6e38f68c03fb6f79168d6a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 11, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_FUCHSIA_H (fixit)"}, {"location": {"col": 9, "file": 11, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_fuchsia.h", "reportHash": "cca25ddd27fe7082c382e259628764b8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 12, "line": 17}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_INTERFACE_INTERNAL_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 17}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_interface_internal.h", "reportHash": "3d057f687dcc747a78459f9faccf23a1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_INTERNAL_DEFS_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_internal_defs.h", "reportHash": "3636b027ee6423cc4b5cffcd5bbe3574", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 14, "line": 16}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_LIBC_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 16}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_libc.h", "reportHash": "c5a6066bd51f626ebc8f2255f7757527", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_LINUX_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_linux.h", "reportHash": "b4a347bef1ec1e65f97bb7425fdcb881", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 16, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_LIST_H (fixit)"}, {"location": {"col": 9, "file": 16, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_list.h", "reportHash": "8a2584e6ab5c42989a527d6416aab558", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 17, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_MAC_H (fixit)"}, {"location": {"col": 9, "file": 17, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_mac.h", "reportHash": "c263d9b8f1fce5d8e184b375b8e74df6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 18, "line": 13}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_MUTEX_H (fixit)"}, {"location": {"col": 9, "file": 18, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_mutex.h", "reportHash": "c4d3920e8b22f00163ebefb199c15071", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 20, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_PLATFORM_LIMITS_FREEBSD_H (fixit)"}, {"location": {"col": 9, "file": 20, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_freebsd.h", "reportHash": "3d2adc7e8fb37fed402c630402f9f0fd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 21, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_PLATFORM_LIMITS_NETBSD_H (fixit)"}, {"location": {"col": 9, "file": 21, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_netbsd.h", "reportHash": "5dfa62a2d8cba94671ee92f267b0d6c4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 22, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_PLATFORM_LIMITS_POSIX_H (fixit)"}, {"location": {"col": 9, "file": 22, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.h", "reportHash": "3950753952dfff3f3127ca08d2c1cd8c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 23, "line": 14}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_PLATFORM_LIMITS_SOLARIS_H (fixit)"}, {"location": {"col": 9, "file": 23, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_solaris.h", "reportHash": "8ca2de9f096f4318fe5799709a6923f5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 24, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_POSIX_H (fixit)"}, {"location": {"col": 9, "file": 24, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_posix.h", "reportHash": "45d37633657fc5fad6592b5797df370c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 25, "line": 13}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_PROCMAPS_H (fixit)"}, {"location": {"col": 9, "file": 25, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_procmaps.h", "reportHash": "9862bf50026a7462d60f3359362543d1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 26, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_SANITIZER_COMMON_SANITIZER_STACKTRACE_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_stacktrace.h", "reportHash": "2b8aa608c57532d1812cab035547acd4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 12}, "message": "LLVM_COMPILER_RT_LIB_UBSAN_UBSAN_PLATFORM_H (fixit)"}, {"location": {"col": 9, "file": 27, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/ubsan/ubsan_platform.h", "reportHash": "7631047f4f752e9bc8e580f23f058131", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
