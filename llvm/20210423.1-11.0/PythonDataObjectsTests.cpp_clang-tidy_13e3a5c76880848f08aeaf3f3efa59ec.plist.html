<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h", "content": "//===-- PythonDataObjects.h--------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n//\n// !! FIXME FIXME FIXME !!\n//\n// Python APIs nearly all can return an exception.   They do this\n// by returning NULL, or -1, or some such value and setting\n// the exception state with PyErr_Set*().   Exceptions must be\n// handled before further python API functions are called.   Failure\n// to do so will result in asserts on debug builds of python.\n// It will also sometimes, but not usually result in crashes of\n// release builds.\n//\n// Nearly all the code in this header does not handle python exceptions\n// correctly.  It should all be converted to return Expected<> or\n// Error types to capture the exception.\n//\n// Everything in this file except functions that return Error or\n// Expected<> is considered deprecated and should not be\n// used in new code.  If you need to use it, fix it first.\n//\n//\n// TODOs for this file\n//\n// * Make all methods safe for exceptions.\n//\n// * Eliminate method signatures that must translate exceptions into\n//   empty objects or NULLs.   Almost everything here should return\n//   Expected<>.   It should be acceptable for certain operations that\n//   can never fail to assert instead, such as the creation of\n//   PythonString from a string literal.\n//\n// * Eliminate Reset(), and make all non-default constructors private.\n//   Python objects should be created with Retain<> or Take<>, and they\n//   should be assigned with operator=\n//\n// * Eliminate default constructors, make python objects always\n//   nonnull, and use optionals where necessary.\n//\n\n\n#ifndef LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_PYTHONDATAOBJECTS_H\n#define LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_PYTHONDATAOBJECTS_H\n\n#include \"lldb/Host/Config.h\"\n\n#if LLDB_ENABLE_PYTHON\n\n// LLDB Python header must be included first\n#include \"lldb-python.h\"\n\n#include \"lldb/Host/File.h\"\n#include \"lldb/Utility/StructuredData.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n\nnamespace lldb_private {\nnamespace python {\n\nclass PythonObject;\nclass PythonBytes;\nclass PythonString;\nclass PythonList;\nclass PythonDictionary;\nclass PythonInteger;\nclass PythonException;\n\nclass StructuredPythonObject : public StructuredData::Generic {\npublic:\n  StructuredPythonObject() : StructuredData::Generic() {}\n\n  StructuredPythonObject(void *obj) : StructuredData::Generic(obj) {\n    Py_XINCREF(GetValue());\n  }\n\n  ~StructuredPythonObject() override {\n    if (Py_IsInitialized())\n      Py_XDECREF(GetValue());\n    SetValue(nullptr);\n  }\n\n  bool IsValid() const override { return GetValue() && GetValue() != Py_None; }\n\n  void Serialize(llvm::json::OStream &s) const override;\n\nprivate:\n  StructuredPythonObject(const StructuredPythonObject &) = delete;\n  const StructuredPythonObject &\n  operator=(const StructuredPythonObject &) = delete;\n};\n\nenum class PyObjectType {\n  Unknown,\n  None,\n  Boolean,\n  Integer,\n  Dictionary,\n  List,\n  String,\n  Bytes,\n  ByteArray,\n  Module,\n  Callable,\n  Tuple,\n  File\n};\n\nenum class PyRefType {\n  Borrowed, // We are not given ownership of the incoming PyObject.\n            // We cannot safely hold it without calling Py_INCREF.\n  Owned     // We have ownership of the incoming PyObject.  We should\n            // not call Py_INCREF.\n};\n\n\n// Take a reference that you already own, and turn it into\n// a PythonObject.\n//\n// Most python API methods will return a +1 reference\n// if they succeed or NULL if and only if\n// they set an exception.   Use this to collect such return\n// values, after checking for NULL.\n//\n// If T is not just PythonObject, then obj must be already be\n// checked to be of the correct type.\ntemplate <typename T> T Take(PyObject *obj) {\n  assert(obj);\n  assert(!PyErr_Occurred());\n  T thing(PyRefType::Owned, obj);\n  assert(thing.IsValid());\n  return thing;\n}\n\n// Retain a reference you have borrowed, and turn it into\n// a PythonObject.\n//\n// A minority of python APIs return a borrowed reference\n// instead of a +1.   They will also return NULL if and only\n// if they set an exception.   Use this to collect such return\n// values, after checking for NULL.\n//\n// If T is not just PythonObject, then obj must be already be\n// checked to be of the correct type.\ntemplate <typename T> T Retain(PyObject *obj) {\n  assert(obj);\n  assert(!PyErr_Occurred());\n  T thing(PyRefType::Borrowed, obj);\n  assert(thing.IsValid());\n  return thing;\n}\n\n// This class can be used like a utility function to convert from\n// a llvm-friendly Twine into a null-terminated const char *,\n// which is the form python C APIs want their strings in.\n//\n// Example:\n// const llvm::Twine &some_twine;\n// PyFoo_Bar(x, y, z, NullTerminated(some_twine));\n//\n// Why a class instead of a function?  If the twine isn't already null\n// terminated, it will need a temporary buffer to copy the string\n// into.   We need that buffer to stick around for the lifetime of the\n// statement.\nclass NullTerminated {\n  const char *str;\n  llvm::SmallString<32> storage;\n\npublic:\n  NullTerminated(const llvm::Twine &twine) {\n    llvm::StringRef ref = twine.toNullTerminatedStringRef(storage);\n    str = ref.begin();\n  }\n  operator const char *() { return str; }\n};\n\ninline llvm::Error nullDeref() {\n  return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                 \"A NULL PyObject* was dereferenced\");\n}\n\ninline llvm::Error exception(const char *s = nullptr) {\n  return llvm::make_error<PythonException>(s);\n}\n\ninline llvm::Error keyError() {\n  return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                 \"key not in dict\");\n}\n\n#if PY_MAJOR_VERSION < 3\n// The python 2 API declares some arguments as char* that should\n// be const char *, but it doesn't actually modify them.\ninline char *py2_const_cast(const char *s) { return const_cast<char *>(s); }\n#else\ninline const char *py2_const_cast(const char *s) { return s; }\n#endif\n\nenum class PyInitialValue { Invalid, Empty };\n\ntemplate <typename T, typename Enable = void> struct PythonFormat;\n\ntemplate <> struct PythonFormat<unsigned long long> {\n  static constexpr char format = 'K';\n  static auto get(unsigned long long value) { return value; }\n};\n\ntemplate <> struct PythonFormat<long long> {\n  static constexpr char format = 'L';\n  static auto get(long long value) { return value; }\n};\n\ntemplate <> struct PythonFormat<PyObject *> {\n  static constexpr char format = 'O';\n  static auto get(PyObject *value) { return value; }\n};\n\ntemplate <typename T>\nstruct PythonFormat<\n    T, typename std::enable_if<std::is_base_of<PythonObject, T>::value>::type> {\n  static constexpr char format = 'O';\n  static auto get(const T &value) { return value.get(); }\n};\n\nclass PythonObject {\npublic:\n  PythonObject() : m_py_obj(nullptr) {}\n\n  PythonObject(PyRefType type, PyObject *py_obj) {\n    m_py_obj = py_obj;\n    // If this is a borrowed reference, we need to convert it to\n    // an owned reference by incrementing it.  If it is an owned\n    // reference (for example the caller allocated it with PyDict_New()\n    // then we must *not* increment it.\n    if (m_py_obj && Py_IsInitialized() && type == PyRefType::Borrowed)\n      Py_XINCREF(m_py_obj);\n  }\n\n  PythonObject(const PythonObject &rhs)\n      : PythonObject(PyRefType::Borrowed, rhs.m_py_obj) {}\n\n  PythonObject(PythonObject &&rhs) {\n    m_py_obj = rhs.m_py_obj;\n    rhs.m_py_obj = nullptr;\n  }\n\n  ~PythonObject() { Reset(); }\n\n  void Reset() {\n    if (m_py_obj && Py_IsInitialized())\n      Py_DECREF(m_py_obj);\n    m_py_obj = nullptr;\n  }\n\n  void Dump() const {\n    if (m_py_obj)\n      _PyObject_Dump(m_py_obj);\n    else\n      puts(\"NULL\");\n  }\n\n  void Dump(Stream &strm) const;\n\n  PyObject *get() const { return m_py_obj; }\n\n  PyObject *release() {\n    PyObject *result = m_py_obj;\n    m_py_obj = nullptr;\n    return result;\n  }\n\n  PythonObject &operator=(PythonObject other) {\n    Reset();\n    m_py_obj = std::exchange(other.m_py_obj, nullptr);\n    return *this;\n  }\n\n  PyObjectType GetObjectType() const;\n\n  PythonString Repr() const;\n\n  PythonString Str() const;\n\n  static PythonObject ResolveNameWithDictionary(llvm::StringRef name,\n                                                const PythonDictionary &dict);\n\n  template <typename T>\n  static T ResolveNameWithDictionary(llvm::StringRef name,\n                                     const PythonDictionary &dict) {\n    return ResolveNameWithDictionary(name, dict).AsType<T>();\n  }\n\n  PythonObject ResolveName(llvm::StringRef name) const;\n\n  template <typename T> T ResolveName(llvm::StringRef name) const {\n    return ResolveName(name).AsType<T>();\n  }\n\n  bool HasAttribute(llvm::StringRef attribute) const;\n\n  PythonObject GetAttributeValue(llvm::StringRef attribute) const;\n\n  bool IsNone() const { return m_py_obj == Py_None; }\n\n  bool IsValid() const { return m_py_obj != nullptr; }\n\n  bool IsAllocated() const { return IsValid() && !IsNone(); }\n\n  explicit operator bool() const { return IsValid() && !IsNone(); }\n\n  template <typename T> T AsType() const {\n    if (!T::Check(m_py_obj))\n      return T();\n    return T(PyRefType::Borrowed, m_py_obj);\n  }\n\n  StructuredData::ObjectSP CreateStructuredObject() const;\n\n  template <typename... T>\n  llvm::Expected<PythonObject> CallMethod(const char *name,\n                                          const T &... t) const {\n    const char format[] = {'(', PythonFormat<T>::format..., ')', 0};\n    PyObject *obj =\n        PyObject_CallMethod(m_py_obj, py2_const_cast(name),\n                            py2_const_cast(format), PythonFormat<T>::get(t)...);\n    if (!obj)\n      return exception();\n    return python::Take<PythonObject>(obj);\n  }\n\n  template <typename... T>\n  llvm::Expected<PythonObject> Call(const T &... t) const {\n    const char format[] = {'(', PythonFormat<T>::format..., ')', 0};\n    PyObject *obj = PyObject_CallFunction(m_py_obj, py2_const_cast(format),\n                                          PythonFormat<T>::get(t)...);\n    if (!obj)\n      return exception();\n    return python::Take<PythonObject>(obj);\n  }\n\n  llvm::Expected<PythonObject> GetAttribute(const llvm::Twine &name) const {\n    if (!m_py_obj)\n      return nullDeref();\n    PyObject *obj = PyObject_GetAttrString(m_py_obj, NullTerminated(name));\n    if (!obj)\n      return exception();\n    return python::Take<PythonObject>(obj);\n  }\n\n  llvm::Expected<bool> IsTrue() {\n    if (!m_py_obj)\n      return nullDeref();\n    int r = PyObject_IsTrue(m_py_obj);\n    if (r < 0)\n      return exception();\n    return !!r;\n  }\n\n  llvm::Expected<long long> AsLongLong() const;\n\n  llvm::Expected<long long> AsUnsignedLongLong() const;\n\n  // wraps on overflow, instead of raising an error.\n  llvm::Expected<unsigned long long> AsModuloUnsignedLongLong() const;\n\n  llvm::Expected<bool> IsInstance(const PythonObject &cls) {\n    if (!m_py_obj || !cls.IsValid())\n      return nullDeref();\n    int r = PyObject_IsInstance(m_py_obj, cls.get());\n    if (r < 0)\n      return exception();\n    return !!r;\n  }\n\nprotected:\n  PyObject *m_py_obj;\n};\n\n\n// This is why C++ needs monads.\ntemplate <typename T> llvm::Expected<T> As(llvm::Expected<PythonObject> &&obj) {\n  if (!obj)\n    return obj.takeError();\n  if (!T::Check(obj.get().get()))\n    return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                   \"type error\");\n  return T(PyRefType::Borrowed, std::move(obj.get().get()));\n}\n\ntemplate <> llvm::Expected<bool> As<bool>(llvm::Expected<PythonObject> &&obj);\n\ntemplate <>\nllvm::Expected<long long> As<long long>(llvm::Expected<PythonObject> &&obj);\n\ntemplate <>\nllvm::Expected<unsigned long long>\nAs<unsigned long long>(llvm::Expected<PythonObject> &&obj);\n\ntemplate <>\nllvm::Expected<std::string> As<std::string>(llvm::Expected<PythonObject> &&obj);\n\n\ntemplate <class T> class TypedPythonObject : public PythonObject {\npublic:\n  // override to perform implicit type conversions on Reset\n  // This can be eliminated once we drop python 2 support.\n  static void Convert(PyRefType &type, PyObject *&py_obj) {}\n\n  TypedPythonObject(PyRefType type, PyObject *py_obj) {\n    if (!py_obj)\n      return;\n    T::Convert(type, py_obj);\n    if (T::Check(py_obj))\n      PythonObject::operator=(PythonObject(type, py_obj));\n    else if (type == PyRefType::Owned)\n      Py_DECREF(py_obj);\n  }\n\n  TypedPythonObject() {}\n};\n\nclass PythonBytes : public TypedPythonObject<PythonBytes> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n  explicit PythonBytes(llvm::ArrayRef<uint8_t> bytes);\n  PythonBytes(const uint8_t *bytes, size_t length);\n\n  static bool Check(PyObject *py_obj);\n\n  llvm::ArrayRef<uint8_t> GetBytes() const;\n\n  size_t GetSize() const;\n\n  void SetBytes(llvm::ArrayRef<uint8_t> stringbytes);\n\n  StructuredData::StringSP CreateStructuredString() const;\n};\n\nclass PythonByteArray : public TypedPythonObject<PythonByteArray> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n  explicit PythonByteArray(llvm::ArrayRef<uint8_t> bytes);\n  PythonByteArray(const uint8_t *bytes, size_t length);\n  PythonByteArray(const PythonBytes &object);\n\n  static bool Check(PyObject *py_obj);\n\n  llvm::ArrayRef<uint8_t> GetBytes() const;\n\n  size_t GetSize() const;\n\n  void SetBytes(llvm::ArrayRef<uint8_t> stringbytes);\n\n  StructuredData::StringSP CreateStructuredString() const;\n};\n\nclass PythonString : public TypedPythonObject<PythonString> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n  static llvm::Expected<PythonString> FromUTF8(llvm::StringRef string);\n\n  PythonString() : TypedPythonObject() {} // MSVC requires this for some reason\n\n  explicit PythonString(llvm::StringRef string); // safe, null on error\n\n  static bool Check(PyObject *py_obj);\n  static void Convert(PyRefType &type, PyObject *&py_obj);\n\n  llvm::StringRef GetString() const; // safe, empty string on error\n\n  llvm::Expected<llvm::StringRef> AsUTF8() const;\n\n  size_t GetSize() const;\n\n  void SetString(llvm::StringRef string); // safe, null on error\n\n  StructuredData::StringSP CreateStructuredString() const;\n};\n\nclass PythonInteger : public TypedPythonObject<PythonInteger> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  PythonInteger() : TypedPythonObject() {} // MSVC requires this for some reason\n\n  explicit PythonInteger(int64_t value);\n\n  static bool Check(PyObject *py_obj);\n  static void Convert(PyRefType &type, PyObject *&py_obj);\n\n  void SetInteger(int64_t value);\n\n  StructuredData::IntegerSP CreateStructuredInteger() const;\n};\n\nclass PythonBoolean : public TypedPythonObject<PythonBoolean> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  explicit PythonBoolean(bool value);\n\n  static bool Check(PyObject *py_obj);\n\n  bool GetValue() const;\n\n  void SetValue(bool value);\n\n  StructuredData::BooleanSP CreateStructuredBoolean() const;\n};\n\nclass PythonList : public TypedPythonObject<PythonList> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  PythonList() : TypedPythonObject() {} // MSVC requires this for some reason\n\n  explicit PythonList(PyInitialValue value);\n  explicit PythonList(int list_size);\n\n  static bool Check(PyObject *py_obj);\n\n  uint32_t GetSize() const;\n\n  PythonObject GetItemAtIndex(uint32_t index) const;\n\n  void SetItemAtIndex(uint32_t index, const PythonObject &object);\n\n  void AppendItem(const PythonObject &object);\n\n  StructuredData::ArraySP CreateStructuredArray() const;\n};\n\nclass PythonTuple : public TypedPythonObject<PythonTuple> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  explicit PythonTuple(PyInitialValue value);\n  explicit PythonTuple(int tuple_size);\n  PythonTuple(std::initializer_list<PythonObject> objects);\n  PythonTuple(std::initializer_list<PyObject *> objects);\n\n  static bool Check(PyObject *py_obj);\n\n  uint32_t GetSize() const;\n\n  PythonObject GetItemAtIndex(uint32_t index) const;\n\n  void SetItemAtIndex(uint32_t index, const PythonObject &object);\n\n  StructuredData::ArraySP CreateStructuredArray() const;\n};\n\nclass PythonDictionary : public TypedPythonObject<PythonDictionary> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  PythonDictionary() : TypedPythonObject() {} // MSVC requires this for some reason\n\n  explicit PythonDictionary(PyInitialValue value);\n\n  static bool Check(PyObject *py_obj);\n\n  uint32_t GetSize() const;\n\n  PythonList GetKeys() const;\n\n  PythonObject GetItemForKey(const PythonObject &key) const; // DEPRECATED\n  void SetItemForKey(const PythonObject &key,\n                     const PythonObject &value); // DEPRECATED\n\n  llvm::Expected<PythonObject> GetItem(const PythonObject &key) const;\n  llvm::Expected<PythonObject> GetItem(const llvm::Twine &key) const;\n  llvm::Error SetItem(const PythonObject &key, const PythonObject &value) const;\n  llvm::Error SetItem(const llvm::Twine &key, const PythonObject &value) const;\n\n  StructuredData::DictionarySP CreateStructuredDictionary() const;\n};\n\nclass PythonModule : public TypedPythonObject<PythonModule> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  static bool Check(PyObject *py_obj);\n\n  static PythonModule BuiltinsModule();\n\n  static PythonModule MainModule();\n\n  static PythonModule AddModule(llvm::StringRef module);\n\n  // safe, returns invalid on error;\n  static PythonModule ImportModule(llvm::StringRef name) {\n    std::string s = std::string(name);\n    auto mod = Import(s.c_str());\n    if (!mod) {\n      llvm::consumeError(mod.takeError());\n      return PythonModule();\n    }\n    return std::move(mod.get());\n  }\n\n  static llvm::Expected<PythonModule> Import(const llvm::Twine &name);\n\n  llvm::Expected<PythonObject> Get(const llvm::Twine &name);\n\n  PythonDictionary GetDictionary() const;\n};\n\nclass PythonCallable : public TypedPythonObject<PythonCallable> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  struct ArgInfo {\n    /* the largest number of positional arguments this callable\n     * can accept, or UNBOUNDED, ie UINT_MAX if it's a varargs\n     * function and can accept an arbitrary number */\n    unsigned max_positional_args;\n    static constexpr unsigned UNBOUNDED = UINT_MAX; // FIXME c++17 inline\n  };\n\n  static bool Check(PyObject *py_obj);\n\n  llvm::Expected<ArgInfo> GetArgInfo() const;\n\n  PythonObject operator()();\n\n  PythonObject operator()(std::initializer_list<PyObject *> args);\n\n  PythonObject operator()(std::initializer_list<PythonObject> args);\n\n  template <typename Arg, typename... Args>\n  PythonObject operator()(const Arg &arg, Args... args) {\n    return operator()({arg, args...});\n  }\n};\n\nclass PythonFile : public TypedPythonObject<PythonFile> {\npublic:\n  using TypedPythonObject::TypedPythonObject;\n\n  PythonFile() : TypedPythonObject() {} // MSVC requires this for some reason\n\n  static bool Check(PyObject *py_obj);\n\n  static llvm::Expected<PythonFile> FromFile(File &file,\n                                             const char *mode = nullptr);\n\n  llvm::Expected<lldb::FileSP> ConvertToFile(bool borrowed = false);\n  llvm::Expected<lldb::FileSP>\n  ConvertToFileForcingUseOfScriptingIOMethods(bool borrowed = false);\n};\n\nclass PythonException : public llvm::ErrorInfo<PythonException> {\nprivate:\n  PyObject *m_exception_type, *m_exception, *m_traceback;\n  PyObject *m_repr_bytes;\n\npublic:\n  static char ID;\n  const char *toCString() const;\n  PythonException(const char *caller = nullptr);\n  void Restore();\n  ~PythonException();\n  void log(llvm::raw_ostream &OS) const override;\n  std::error_code convertToErrorCode() const override;\n  bool Matches(PyObject *exc) const;\n  std::string ReadBacktrace() const;\n};\n\n// This extracts the underlying T out of an Expected<T> and returns it.\n// If the Expected is an Error instead of a T, that error will be converted\n// into a python exception, and this will return a default-constructed T.\n//\n// This is appropriate for use right at the boundary of python calling into\n// C++, such as in a SWIG typemap.   In such a context you should simply\n// check if the returned T is valid, and if it is, return a NULL back\n// to python.   This will result in the Error being raised as an exception\n// from python code's point of view.\n//\n// For example:\n// ```\n// Expected<Foo *> efoop = some_cpp_function();\n// Foo *foop = unwrapOrSetPythonException(efoop);\n// if (!foop)\n//    return NULL;\n// do_something(*foop);\n//\n// If the Error returned was itself created because a python exception was\n// raised when C++ code called into python, then the original exception\n// will be restored.   Otherwise a simple string exception will be raised.\ntemplate <typename T> T unwrapOrSetPythonException(llvm::Expected<T> expected) {\n  if (expected)\n    return expected.get();\n  llvm::handleAllErrors(\n      expected.takeError(), [](PythonException &E) { E.Restore(); },\n      [](const llvm::ErrorInfoBase &E) {\n        PyErr_SetString(PyExc_Exception, E.message().c_str());\n      });\n  return T();\n}\n\n// This is only here to help incrementally migrate old, exception-unsafe\n// code.\ntemplate <typename T> T unwrapIgnoringErrors(llvm::Expected<T> expected) {\n  if (expected)\n    return std::move(expected.get());\n  llvm::consumeError(expected.takeError());\n  return T();\n}\n\nllvm::Expected<PythonObject> runStringOneLine(const llvm::Twine &string,\n                                              const PythonDictionary &globals,\n                                              const PythonDictionary &locals);\n\nllvm::Expected<PythonObject> runStringMultiLine(const llvm::Twine &string,\n                                                const PythonDictionary &globals,\n                                                const PythonDictionary &locals);\n\n// Sometimes the best way to interact with a python interpreter is\n// to run some python code.   You construct a PythonScript with\n// script string.   The script assigns some function to `_function_`\n// and you get a C++ callable object that calls the python function.\n//\n// Example:\n//\n// const char script[] = R\"(\n// def main(x, y):\n//    ....\n// )\";\n//\n// Expected<PythonObject> cpp_foo_wrapper(PythonObject x, PythonObject y) {\n//   // no need to synchronize access to this global, we already have the GIL\n//   static PythonScript foo(script)\n//   return  foo(x, y);\n// }\nclass PythonScript {\n  const char *script;\n  PythonCallable function;\n\n  llvm::Error Init();\n\npublic:\n  PythonScript(const char *script) : script(script), function() {}\n\n  template <typename... Args>\n  llvm::Expected<PythonObject> operator()(Args &&... args) {\n    if (llvm::Error error = Init())\n      return std::move(error);\n    return function.Call(std::forward<Args>(args)...);\n  }\n};\n\n} // namespace python\n} // namespace lldb_private\n\n#endif\n\n#endif // LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_PYTHONDATAOBJECTS_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.h", "content": "//===-- ScriptInterpreterPython.h -------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTINTERPRETERPYTHON_H\n#define LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTINTERPRETERPYTHON_H\n\n#include \"lldb/Host/Config.h\"\n\n#if LLDB_ENABLE_PYTHON\n\n#include \"ScriptedProcessPythonInterface.h\"\n\n#include \"lldb/Breakpoint/BreakpointOptions.h\"\n#include \"lldb/Core/IOHandler.h\"\n#include \"lldb/Core/StructuredDataImpl.h\"\n#include \"lldb/Interpreter/ScriptInterpreter.h\"\n#include \"lldb/lldb-private.h\"\n\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace lldb_private {\n/// Abstract interface for the Python script interpreter.\nclass ScriptInterpreterPython : public ScriptInterpreter,\n                                public IOHandlerDelegateMultiline {\npublic:\n  class CommandDataPython : public BreakpointOptions::CommandData {\n  public:\n    CommandDataPython() : BreakpointOptions::CommandData() {\n      interpreter = lldb::eScriptLanguagePython;\n    }\n    CommandDataPython(StructuredData::ObjectSP extra_args_sp) :\n        BreakpointOptions::CommandData(),\n        m_extra_args_up(new StructuredDataImpl()) {\n        interpreter = lldb::eScriptLanguagePython;\n        m_extra_args_up->SetObjectSP(extra_args_sp);\n    }\n    lldb::StructuredDataImplUP m_extra_args_up;\n  };\n\n  ScriptInterpreterPython(Debugger &debugger)\n      : ScriptInterpreter(debugger, lldb::eScriptLanguagePython),\n        IOHandlerDelegateMultiline(\"DONE\") {}\n\n  static void Initialize();\n  static void Terminate();\n  static lldb_private::ConstString GetPluginNameStatic();\n  static const char *GetPluginDescriptionStatic();\n  static FileSpec GetPythonDir();\n  static void SharedLibraryDirectoryHelper(FileSpec &this_file);\n\nprotected:\n  static void ComputePythonDirForApple(llvm::SmallVectorImpl<char> &path);\n  static void ComputePythonDir(llvm::SmallVectorImpl<char> &path);\n};\n} // namespace lldb_private\n\n#endif // LLDB_ENABLE_PYTHON\n#endif // LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTINTERPRETERPYTHON_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/ScriptedProcessPythonInterface.h", "content": "//===-- ScriptedProcessPythonInterface.h ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTEDPROCESSPYTHONINTERFACE_H\n#define LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTEDPROCESSPYTHONINTERFACE_H\n\n#include \"lldb/Host/Config.h\"\n\n#if LLDB_ENABLE_PYTHON\n\n#include \"lldb/Interpreter/ScriptedProcessInterface.h\"\n\nnamespace lldb_private {\nclass ScriptInterpreterPythonImpl;\nclass ScriptedProcessPythonInterface : public ScriptedProcessInterface {\npublic:\n  ScriptedProcessPythonInterface(ScriptInterpreterPythonImpl &interpreter)\n      : ScriptedProcessInterface(), m_interpreter(interpreter) {}\n\n  StructuredData::GenericSP\n  CreatePluginObject(const llvm::StringRef class_name, lldb::TargetSP target_sp,\n                     StructuredData::DictionarySP args_sp) override;\n\n  Status Launch() override;\n\n  Status Resume() override;\n\n  lldb::MemoryRegionInfoSP\n  GetMemoryRegionContainingAddress(lldb::addr_t address) override;\n\n  StructuredData::DictionarySP GetThreadWithID(lldb::tid_t tid) override;\n\n  StructuredData::DictionarySP GetRegistersForThread(lldb::tid_t tid) override;\n\n  lldb::DataExtractorSP ReadMemoryAtAddress(lldb::addr_t address, size_t size,\n                                            Status &error) override;\n\n  StructuredData::DictionarySP GetLoadedImages() override;\n\n  lldb::pid_t GetProcessID() override;\n\n  bool IsAlive() override;\n\nprotected:\n  size_t GetGenericInteger(llvm::StringRef method_name);\n  Status LaunchOrResume(llvm::StringRef method_name);\n\nprivate:\n  // The lifetime is managed by the ScriptInterpreter\n  ScriptInterpreterPythonImpl &m_interpreter;\n  StructuredData::GenericSP m_object_instance_sp;\n};\n} // namespace lldb_private\n\n#endif // LLDB_ENABLE_PYTHON\n#endif // LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTEDPROCESSPYTHONINTERFACE_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/lldb-python.h", "content": "//===-- lldb-python.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_LLDB_PYTHON_H\n#define LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_LLDB_PYTHON_H\n\n#include \"lldb/Host/Config.h\"\n\n// Python.h needs to be included before any system headers in order to avoid\n// redefinition of macros\n\n#if LLDB_ENABLE_PYTHON\n#include \"llvm/Support/Compiler.h\"\n#if defined(_WIN32)\n// If anyone #includes Host/PosixApi.h later, it will try to typedef pid_t.  We\n// need to ensure this doesn't happen.  At the same time, Python.h will also try\n// to redefine a bunch of stuff that PosixApi.h defines.  So define it all now\n// so that PosixApi.h doesn't redefine it.\n#define NO_PID_T\n#endif\n#if defined(__linux__)\n// features.h will define _POSIX_C_SOURCE if _GNU_SOURCE is defined.  This value\n// may be different from the value that Python defines it to be which results\n// in a warning.  Undefine _POSIX_C_SOURCE before including Python.h  The same\n// holds for _XOPEN_SOURCE.\n#undef _POSIX_C_SOURCE\n#undef _XOPEN_SOURCE\n#endif\n\n// Include locale before Python so _PY_PORT_CTYPE_UTF8_ISSUE doesn't cause\n// macro redefinitions.\n#if defined(__APPLE__)\n#include <locale>\n#endif\n\n// Include python for non windows machines\n#include <Python.h>\n#endif\n\n#endif // LLDB_PLUGINS_SCRIPTINTERPRETER_PYTHON_LLDB_PYTHON_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/lldb/unittests/ScriptInterpreter/Python/PythonTestSuite.h", "content": "//===-- PythonTestSuite.cpp -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"gtest/gtest.h\"\n\nusing namespace lldb_private;\n\nclass PythonTestSuite : public testing::Test {\npublic:\n  void SetUp() override;\n\n  void TearDown() override;\n\nprivate:\n  PyGILState_STATE m_gil_state;\n};\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan)\n//\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don't\n// end with _ are part of Google Test's public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don't need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it's necessary for a user to define some of the following\n// macros in the build script to override Google Test's decisions.\n//\n// If the user doesn't define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don't use #ifdef or \"#if\n//     defined(...)\", which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn't available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_GLOBAL_STRING  - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::string, which is different to std::string).\n//   GTEST_HAS_GLOBAL_WSTRING - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::wstring, which is different to std::wstring).\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren't available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that <pthread.h>\n//                              is/isn't available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn't\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn't work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_TR1_TUPLE      - Define it to 1/0 to indicate tr1::tuple\n//                              is/isn't available.\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft's \"Structured\n//                              Exception Handling\".\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_USE_OWN_TR1_TUPLE  - Define it to 1/0 to indicate whether Google\n//                              Test's own tr1 tuple implementation should be\n//                              used.  Unused when the user sets\n//                              GTEST_HAS_TR1_TUPLE to 0.\n//   GTEST_LANG_CXX11         - Define it to 1/0 to indicate that Google Test\n//                              is building in C++11/C++98 mode.\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_MINIX    - Minix\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_SYMBIAN  - Symbian\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Max OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don't have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #if\n// which controls that code.  For example:\n//\n// #if GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_COMBINE      - the Combine() function (for value-parameterized\n//                            tests)\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_PARAM_TEST   - value-parameterized tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above two are mutually exclusive.\n//   GTEST_CAN_COMPARE_NULL - accepts untyped NULL in EXPECT_EQ().\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test's INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_ATTRIBUTE_UNUSED_  - declares that a class' instances or a\n//                              variable don't have to be used.\n//   GTEST_DISALLOW_ASSIGN_   - disables operator=.\n//   GTEST_DISALLOW_COPY_AND_ASSIGN_ - disables copy ctor and operator=.\n//   GTEST_MUST_USE_RESULT_   - declares that a function's result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//\n// C++11 feature wrappers:\n//\n//   testing::internal::move  - portability wrapper for std::move.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Template meta programming:\n//   is_pointer     - as in TR1; needed on Symbian and IBM XL C/C++ only.\n//   IteratorTraits - partial implementation of std::iterator_traits, which\n//                    is not available in libCstd when compiled with Sun C++.\n//\n// Smart pointers:\n//   scoped_ptr     - as in TR2.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using the POSIX\n//                    Extended Regular Expression syntax on UNIX-like\n//                    platforms, or a reduced regular exception syntax on\n//                    other platforms, including Windows.\n//\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   Int32, UInt32, Int64, UInt64, TimeInMillis\n//                  - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GTEST_DECLARE_*()  - declares a flag.\n//   GTEST_DEFINE_*()   - defines a flag.\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an Int32 environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n\n#include <ctype.h>   // for isspace, etc\n#include <stddef.h>  // for ptrdiff_t\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#ifndef _WIN32_WCE\n# include <sys/types.h>\n# include <sys/stat.h>\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n# include <AvailabilityMacros.h>\n# include <TargetConditionals.h>\n#endif\n\n#include <algorithm>  // NOLINT\n#include <iostream>  // NOLINT\n#include <sstream>  // NOLINT\n#include <string>  // NOLINT\n#include <utility>\n#include <vector>  // NOLINT\n\n#include \"gtest/internal/gtest-port-arch.h\"\n#include \"gtest/internal/custom/gtest-port.h\"\n\n#if !defined(GTEST_DEV_EMAIL_)\n# define GTEST_DEV_EMAIL_ \"googletestframework@@googlegroups.com\"\n# define GTEST_FLAG_PREFIX_ \"gtest_\"\n# define GTEST_FLAG_PREFIX_DASH_ \"gtest-\"\n# define GTEST_FLAG_PREFIX_UPPER_ \"GTEST_\"\n# define GTEST_NAME_ \"Google Test\"\n# define GTEST_PROJECT_URL_ \"https://github.com/google/googletest/\"\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n# define GTEST_INIT_GOOGLE_TEST_NAME_ \"testing::InitGoogleTest\"\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n# define GTEST_GCC_VER_ \\\n    (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if _MSC_VER >= 1500\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n    __pragma(warning(push))                        \\\n    __pragma(warning(disable: warnings))\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()          \\\n    __pragma(warning(pop))\n#else\n// Older versions of MSVC don't have __pragma.\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n#ifndef GTEST_LANG_CXX11\n// gcc and clang define __GXX_EXPERIMENTAL_CXX0X__ when\n// -std={c,gnu}++{0x,11} is passed.  The C++11 standard specifies a\n// value for __cplusplus, and recent versions of clang, gcc, and\n// probably other compilers set that too in C++11 mode.\n# if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L\n// Compiling in at least C++11 mode.\n#  define GTEST_LANG_CXX11 1\n# else\n#  define GTEST_LANG_CXX11 0\n# endif\n#endif\n\n// Distinct from C++11 language support, some environments don't provide\n// proper C++11 library support. Notably, it's possible to build in\n// C++11 mode when targeting Mac OS X 10.6, which has an old libstdc++\n// with no C++11 support.\n//\n// libstdc++ has sufficient C++11 support as of GCC 4.6.0, __GLIBCXX__\n// 20110325, but maintenance releases in the 4.4 and 4.5 series followed\n// this date, so check for those versions by their date stamps.\n// https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html#abi.versioning\n#if GTEST_LANG_CXX11 && \\\n    (!defined(__GLIBCXX__) || ( \\\n        __GLIBCXX__ >= 20110325ul &&  /* GCC >= 4.6.0 */ \\\n        /* Exclude patch releases of older branches: */ \\\n        __GLIBCXX__ != 20110416ul &&  /* GCC 4.4.6 */ \\\n        __GLIBCXX__ != 20120313ul &&  /* GCC 4.4.7 */ \\\n        __GLIBCXX__ != 20110428ul &&  /* GCC 4.5.3 */ \\\n        __GLIBCXX__ != 20120702ul))   /* GCC 4.5.4 */\n# define GTEST_STDLIB_CXX11 1\n#endif\n\n// Only use C++11 library features if the library provides them.\n#if GTEST_STDLIB_CXX11\n# define GTEST_HAS_STD_BEGIN_AND_END_ 1\n# define GTEST_HAS_STD_FORWARD_LIST_ 1\n# define GTEST_HAS_STD_FUNCTION_ 1\n# define GTEST_HAS_STD_INITIALIZER_LIST_ 1\n# define GTEST_HAS_STD_MOVE_ 1\n# define GTEST_HAS_STD_SHARED_PTR_ 1\n# define GTEST_HAS_STD_TYPE_TRAITS_ 1\n# define GTEST_HAS_STD_UNIQUE_PTR_ 1\n#endif\n\n// C++11 specifies that <tuple> provides std::tuple.\n// Some platforms still might not have it, however.\n#if GTEST_LANG_CXX11\n# define GTEST_HAS_STD_TUPLE_ 1\n# if defined(__clang__)\n// Inspired by http://clang.llvm.org/docs/LanguageExtensions.html#__has_include\n#  if defined(__has_include) && !__has_include(<tuple>)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(_MSC_VER)\n// Inspired by boost/config/stdlib/dinkumware.hpp\n#  if defined(_CPPLIB_VER) && _CPPLIB_VER < 520\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(__GLIBCXX__)\n// Inspired by boost/config/stdlib/libstdcpp3.hpp,\n// http://gcc.gnu.org/gcc-4.2/changes.html and\n// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01.html#manual.intro.status.standard.200x\n#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# endif\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#if GTEST_OS_WINDOWS\n# if !GTEST_OS_WINDOWS_MOBILE\n#  include <direct.h>\n#  include <io.h>\n# endif\n// In order to avoid having to include <windows.h>, use forward declaration\n// assuming CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\nstruct _RTL_CRITICAL_SECTION;\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n# include <unistd.h>\n# include <strings.h>\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#  include <android/api-level.h>  // NOLINT\n#endif\n\n// Defines this to true iff Google Test can use POSIX regular expressions.\n#ifndef GTEST_HAS_POSIX_RE\n# if GTEST_OS_LINUX_ANDROID\n// On Android, <regex.h> is only available starting with Gingerbread.\n#  define GTEST_HAS_POSIX_RE (__ANDROID_API__ >= 9)\n# else\n#  define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS)\n# endif\n#endif\n\n#if GTEST_USES_PCRE\n// The appropriate headers have already been included.\n\n#elif GTEST_HAS_POSIX_RE\n\n// On some platforms, <regex.h> needs someone to define size_t, and\n// won't compile otherwise.  We can #include it here as we already\n// included <stdlib.h>, which is guaranteed to define size_t through\n// <stddef.h>.\n# include <regex.h>  // NOLINT\n\n# define GTEST_USES_POSIX_RE 1\n\n#elif GTEST_OS_WINDOWS\n\n// <regex.h> is not available on Windows.  Use our own simple regex\n// implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#else\n\n// <regex.h> may not be available on this platform.  Use our own\n// simple regex implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#endif  // GTEST_USES_PCRE\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn't tell us whether exceptions are enabled, so we need\n// to figure it out.\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// MSVC's and C++Builder's implementations of the STL use the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we'll do the same.\n// Assumes that exceptions are enabled by default.\n#  ifndef _HAS_EXCEPTIONS\n#   define _HAS_EXCEPTIONS 1\n#  endif  // _HAS_EXCEPTIONS\n#  define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n# elif defined(__clang__)\n// clang defines __EXCEPTIONS iff exceptions are enabled before clang 220714,\n// but iff cleanups are enabled after that. In Obj-C++ files, there can be\n// cleanups for ObjC exceptions which also need cleanups, even if C++ exceptions\n// are disabled. clang has __has_feature(cxx_exceptions) which checks for C++\n// exceptions starting at clang r206352, but which checked for cleanups prior to\n// that. To reliably check for C++ exception availability with clang, check for\n// __EXCEPTIONS && __has_feature(cxx_exceptions).\n#  define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS && __has_feature(cxx_exceptions))\n# elif defined(__GNUC__) && __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__IBMCPP__) && __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#  define GTEST_HAS_EXCEPTIONS 1\n# else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#  define GTEST_HAS_EXCEPTIONS 0\n# endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#if !defined(GTEST_HAS_STD_STRING)\n// Even though we don't use this macro any longer, we keep it in case\n// some clients still depend on it.\n# define GTEST_HAS_STD_STRING 1\n#elif !GTEST_HAS_STD_STRING\n// The user told us that ::std::string isn't available.\n# error \"Google Test cannot be used where ::std::string isn't available.\"\n#endif  // !defined(GTEST_HAS_STD_STRING)\n\n#ifndef GTEST_HAS_GLOBAL_STRING\n// The user didn't tell us whether ::string is available, so we need\n// to figure it out.\n\n# define GTEST_HAS_GLOBAL_STRING 0\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn't tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// TODO(wan@google.com): uses autoconf to detect whether ::std::wstring\n//   is available.\n\n// Cygwin 1.7 and below doesn't support ::std::wstring.\n// Solaris' libc++ doesn't support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n// Minix currently doesn't support it either.\n# define GTEST_HAS_STD_WSTRING \\\n    (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || GTEST_OS_HAIKU || GTEST_OS_MINIX))\n\n#endif  // GTEST_HAS_STD_WSTRING\n\n#ifndef GTEST_HAS_GLOBAL_WSTRING\n// The user didn't tell us whether ::wstring is available, so we need\n// to figure it out.\n# define GTEST_HAS_GLOBAL_WSTRING \\\n    (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn't tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n# ifdef _MSC_VER\n\n#  ifdef _CPPRTTI  // MSVC defines this macro iff RTTI is enabled.\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI iff RTTI is enabled.\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)\n\n#  ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#   if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && \\\n       !defined(__EXCEPTIONS)\n#    define GTEST_HAS_RTTI 0\n#   else\n#    define GTEST_HAS_RTTI 1\n#   endif  // GTEST_OS_LINUX_ANDROID && __STLPORT_MAJOR && !__EXCEPTIONS\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n# elif defined(__clang__)\n\n#  define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n# elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)\n\n#  ifdef __RTTI_ALL__\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n# else\n\n// For all other compilers, we assume RTTI is enabled.\n#  define GTEST_HAS_RTTI 1\n\n# endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It's this header's responsibility to #include <typeinfo> when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n# include <typeinfo>\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn't tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n# define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \\\n    || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL)\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is\n// true.\n# include <pthread.h>  // NOLINT\n\n// For timespec and nanosleep, used below.\n# include <time.h>  // NOLINT\n#endif\n\n// Determines if hash_map/hash_set are available.\n// Only used for testing against those containers.\n#if !defined(GTEST_HAS_HASH_MAP_)\n# if _MSC_VER\n#  define GTEST_HAS_HASH_MAP_ 1  // Indicates that hash_map is available.\n#  define GTEST_HAS_HASH_SET_ 1  // Indicates that hash_set is available.\n# endif  // _MSC_VER\n#endif  // !defined(GTEST_HAS_HASH_MAP_)\n\n// Determines whether Google Test can use tr1/tuple.  You can define\n// this macro to 0 to prevent Google Test from using tuple (any\n// feature depending on tuple with be disabled in this mode).\n#ifndef GTEST_HAS_TR1_TUPLE\n# if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)\n// STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.\n#  define GTEST_HAS_TR1_TUPLE 0\n# else\n// The user didn't tell us not to do it, so we assume it's OK.\n#  define GTEST_HAS_TR1_TUPLE 1\n# endif\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether Google Test's own tr1 tuple implementation\n// should be used.\n#ifndef GTEST_USE_OWN_TR1_TUPLE\n// The user didn't tell us, so we need to figure it out.\n\n// We use our own TR1 tuple if we aren't sure the user has an\n// implementation of it already.  At this time, libstdc++ 4.0.0+ and\n// MSVC 2010 are the only mainstream standard libraries that come\n// with a TR1 tuple implementation.  NVIDIA's CUDA NVCC compiler\n// pretends to be GCC by defining __GNUC__ and friends, but cannot\n// compile GCC's tuple implementation.  MSVC 2008 (9.0) provides TR1\n// tuple in a 323 MB Feature Pack download, which we cannot assume the\n// user has.  QNX's QCC compiler is a modified GCC but it doesn't\n// support TR1 tuple.  libc++ only provides std::tuple, in C++11 mode,\n// and it can be used with some compilers that define __GNUC__.\n# if (defined(__GNUC__) && !defined(__CUDACC__) && (GTEST_GCC_VER_ >= 40000) \\\n      && !GTEST_OS_QNX && !defined(_LIBCPP_VERSION)) || _MSC_VER >= 1600\n#  define GTEST_ENV_HAS_TR1_TUPLE_ 1\n# endif\n\n// C++11 specifies that <tuple> provides std::tuple. Use that if gtest is used\n// in C++11 mode and libstdc++ isn't very old (binaries targeting OS X 10.6\n// can build with clang but need to use gcc4.2's libstdc++).\n# if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)\n#  define GTEST_ENV_HAS_STD_TUPLE_ 1\n# endif\n\n# if GTEST_ENV_HAS_TR1_TUPLE_ || GTEST_ENV_HAS_STD_TUPLE_\n#  define GTEST_USE_OWN_TR1_TUPLE 0\n# else\n#  define GTEST_USE_OWN_TR1_TUPLE 1\n# endif\n\n#endif  // GTEST_USE_OWN_TR1_TUPLE\n\n// To avoid conditional compilation everywhere, we make it\n// gtest-port.h's responsibility to #include the header implementing\n// tuple.\n#if GTEST_HAS_STD_TUPLE_\n# include <tuple>  // IWYU pragma: export\n# define GTEST_TUPLE_NAMESPACE_ ::std\n#endif  // GTEST_HAS_STD_TUPLE_\n\n// We include tr1::tuple even if std::tuple is available to define printers for\n// them.\n#if GTEST_HAS_TR1_TUPLE\n# ifndef GTEST_TUPLE_NAMESPACE_\n#  define GTEST_TUPLE_NAMESPACE_ ::std::tr1\n# endif  // GTEST_TUPLE_NAMESPACE_\n\n# if GTEST_USE_OWN_TR1_TUPLE\n#  include \"gtest/internal/gtest-tuple.h\"  // IWYU pragma: export  // NOLINT\n# elif GTEST_ENV_HAS_STD_TUPLE_\n#  include <tuple>\n// C++11 puts its tuple into the ::std namespace rather than\n// ::std::tr1.  gtest expects tuple to live in ::std::tr1, so put it there.\n// This causes undefined behavior, but supported compilers react in\n// the way we intend.\nnamespace std {\nnamespace tr1 {\nusing ::std::get;\nusing ::std::make_tuple;\nusing ::std::tuple;\nusing ::std::tuple_element;\nusing ::std::tuple_size;\n}\n}\n\n# elif GTEST_OS_SYMBIAN\n\n// On Symbian, BOOST_HAS_TR1_TUPLE causes Boost's TR1 tuple library to\n// use STLport's tuple implementation, which unfortunately doesn't\n// work as the copy of STLport distributed with Symbian is incomplete.\n// By making sure BOOST_HAS_TR1_TUPLE is undefined, we force Boost to\n// use its own tuple implementation.\n#  ifdef BOOST_HAS_TR1_TUPLE\n#   undef BOOST_HAS_TR1_TUPLE\n#  endif  // BOOST_HAS_TR1_TUPLE\n\n// This prevents <boost/tr1/detail/config.hpp>, which defines\n// BOOST_HAS_TR1_TUPLE, from being #included by Boost's <tuple>.\n#  define BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)\n// GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header.  This does\n// not conform to the TR1 spec, which requires the header to be <tuple>.\n\n#  if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n// Until version 4.3.2, gcc has a bug that causes <tr1/functional>,\n// which is #included by <tr1/tuple>, to not compile when RTTI is\n// disabled.  _TR1_FUNCTIONAL is the header guard for\n// <tr1/functional>.  Hence the following #define is a hack to prevent\n// <tr1/functional> from being included.\n#   define _TR1_FUNCTIONAL 1\n#   include <tr1/tuple>\n#   undef _TR1_FUNCTIONAL  // Allows the user to #include\n                        // <tr1/functional> if he chooses to.\n#  else\n#   include <tr1/tuple>  // NOLINT\n#  endif  // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n\n# else\n// If the compiler is not GCC 4.0+, we assume the user is using a\n// spec-conforming TR1 implementation.\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n# endif  // GTEST_USE_OWN_TR1_TUPLE\n\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see http://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn't tell us, so we need to figure it out.\n\n# if GTEST_OS_LINUX && !defined(__ia64__)\n#  if GTEST_OS_LINUX_ANDROID\n// On Android, clone() is only available on ARM starting with Gingerbread.\n#    if defined(__arm__) && __ANDROID_API__ >= 9\n#     define GTEST_HAS_CLONE 1\n#    else\n#     define GTEST_HAS_CLONE 0\n#    endif\n#  else\n#   define GTEST_HAS_CLONE 1\n#  endif\n# else\n#  define GTEST_HAS_CLONE 0\n# endif  // GTEST_OS_LINUX && !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile ones.\n# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || \\\n    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT\n#  define GTEST_HAS_STREAM_REDIRECTION 0\n# else\n#  define GTEST_HAS_STREAM_REDIRECTION 1\n# endif  // !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_SYMBIAN\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// Google Test does not support death tests for VC 7.1 and earlier as\n// abort() in a VC 7.1 application compiled as GUI in debug config\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\\n     (GTEST_OS_MAC && !GTEST_OS_IOS) || \\\n     (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \\\n     GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \\\n     GTEST_OS_OPENBSD || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NETBSD)\n# define GTEST_HAS_DEATH_TEST 1\n#endif\n\n// We don't support MSVC 7.1 with exceptions disabled now.  Therefore\n// all the compilers we care about are adequate for supporting\n// value-parameterized tests.\n#define GTEST_HAS_PARAM_TEST 1\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need <typeinfo> and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n# define GTEST_HAS_TYPED_TEST 1\n# define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether to support Combine(). This only makes sense when\n// value-parameterized tests are enabled.  The implementation doesn't\n// work on Sun Studio since it doesn't understand templated conversion\n// operators.\n#if GTEST_HAS_PARAM_TEST && GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)\n# define GTEST_HAS_COMBINE 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#define GTEST_WIDE_STRING_USES_UTF16_ \\\n    (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)\n\n// Determines whether test results can be streamed to a socket.\n#if GTEST_OS_LINUX\n# define GTEST_CAN_STREAM_RESULTS_ 1\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested \"if\" statements are followed by\n// an \"else\" statement and braces are not used to explicitly disambiguate the\n// \"else\" binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) << \"Some message\";\n//\n// The \"switch (0) case 0:\" idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_ switch (0) case 0: default:  // NOLINT\n#endif\n\n// Use this annotation at the end of a struct/class definition to\n// prevent the compiler from optimizing away instances that are never\n// used.  This is useful when all interesting logic happens inside the\n// c'tor and / or d'tor.  Example:\n//\n//   struct Foo {\n//     Foo() { ... }\n//   } GTEST_ATTRIBUTE_UNUSED_;\n//\n// Also use it after a variable or parameter declaration to tell the\n// compiler the variable/parameter does not have to be used.\n#if defined(__GNUC__) && !defined(COMPILER_ICC)\n# define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n#elif defined(__clang__)\n# if __has_attribute(unused)\n#  define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n# endif\n#endif\n#ifndef GTEST_ATTRIBUTE_UNUSED_\n# define GTEST_ATTRIBUTE_UNUSED_\n#endif\n\n// A macro to disallow operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_ASSIGN_(type)\\\n  void operator=(type const &) = delete\n\n// A macro to disallow copy constructor and operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)\\\n  type(type const &) = delete;\\\n  GTEST_DISALLOW_ASSIGN_(type)\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if defined(__GNUC__) && (GTEST_GCC_VER_ >= 30400) && !defined(COMPILER_ICC)\n# define GTEST_MUST_USE_RESULT_ __attribute__ ((warn_unused_result))\n#else\n# define GTEST_MUST_USE_RESULT_\n#endif  // __GNUC__ && (GTEST_GCC_VER_ >= 30400) && !COMPILER_ICC\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n# define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n    GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n# define GTEST_INTENTIONAL_CONST_COND_POP_() \\\n    GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft's Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn't tell us, so we need to figure it out.\n\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#  define GTEST_HAS_SEH 1\n# else\n// Assume no SEH.\n#  define GTEST_HAS_SEH 0\n# endif\n\n#endif  // GTEST_HAS_SEH\n\n#define GTEST_IS_THREADSAFE \\\n    (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \\\n     || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \\\n     || GTEST_HAS_PTHREAD)\n\n#ifdef _MSC_VER\n# if GTEST_LINKED_AS_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllimport)\n# elif GTEST_CREATE_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllexport)\n# endif\n#elif __GNUC__ >= 4 || defined(__clang__)\n# define GTEST_API_ __attribute__((visibility (\"default\")))\n#endif // _MSC_VER\n\n#ifndef GTEST_API_\n# define GTEST_API_\n#endif\n\n#ifdef __GNUC__\n// Ask the compiler to never inline a given function.\n# define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n# define GTEST_NO_INLINE_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if defined(__has_include)\n# if __has_include(<cxxabi.h>)\n#  define GTEST_HAS_CXXABI_H_ 1\n# else\n#  define GTEST_HAS_CXXABI_H_ 0\n# endif\n#elif defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)\n# define GTEST_HAS_CXXABI_H_ 1\n#else\n# define GTEST_HAS_CXXABI_H_ 0\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if defined(__clang__)\n# if __has_feature(memory_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ \\\n       __attribute__((no_sanitize_memory))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n# endif  // __has_feature(memory_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif  // __clang__\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(address_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n       __attribute__((no_sanitize_address))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n# endif  // __has_feature(address_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif  // __clang__\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(thread_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ \\\n       __attribute__((no_sanitize_thread))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n# endif  // __has_feature(thread_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif  // __clang__\n\nnamespace testing {\n\nclass Message;\n\n#if defined(GTEST_TUPLE_NAMESPACE_)\n// Import tuple and friends into the ::testing namespace.\n// It is part of our interface, having them in ::testing allows us to change\n// their types as needed.\nusing GTEST_TUPLE_NAMESPACE_::get;\nusing GTEST_TUPLE_NAMESPACE_::make_tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple_size;\nusing GTEST_TUPLE_NAMESPACE_::tuple_element;\n#endif  // defined(GTEST_TUPLE_NAMESPACE_)\n\nnamespace internal {\n\n// A secret type that Google Test users don't know about.  It has no\n// definition on purpose.  Therefore it's impossible to create a\n// Secret object, which is what we want.\nclass Secret;\n\n// The GTEST_COMPILE_ASSERT_ macro can be used to verify that a compile time\n// expression is true. For example, you could use it to verify the\n// size of a static array:\n//\n//   GTEST_COMPILE_ASSERT_(GTEST_ARRAY_SIZE_(names) == NUM_NAMES,\n//                         names_incorrect_size);\n//\n// or to make sure a struct is smaller than a certain size:\n//\n//   GTEST_COMPILE_ASSERT_(sizeof(foo) < 128, foo_too_large);\n//\n// The second argument to the macro is the name of the variable. If\n// the expression is false, most compilers will issue a warning/error\n// containing the name of the variable.\n\n#if GTEST_LANG_CXX11\n# define GTEST_COMPILE_ASSERT_(expr, msg) static_assert(expr, #msg)\n#else  // !GTEST_LANG_CXX11\ntemplate <bool>\n  struct CompileAssert {\n};\n\n# define GTEST_COMPILE_ASSERT_(expr, msg) \\\n  typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \\\n      msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_\n#endif  // !GTEST_LANG_CXX11\n\n// Implementation details of GTEST_COMPILE_ASSERT_:\n//\n// (In C++11, we simply use static_assert instead of the following)\n//\n// - GTEST_COMPILE_ASSERT_ works by defining an array type that has -1\n//   elements (and thus is invalid) when the expression is false.\n//\n// - The simpler definition\n//\n//    #define GTEST_COMPILE_ASSERT_(expr, msg) typedef char msg[(expr) ? 1 : -1]\n//\n//   does not work, as gcc supports variable-length arrays whose sizes\n//   are determined at run-time (this is gcc's extension and not part\n//   of the C++ standard).  As a result, gcc fails to reject the\n//   following code with the simple definition:\n//\n//     int foo;\n//     GTEST_COMPILE_ASSERT_(foo, msg); // not supposed to compile as foo is\n//                                      // not a compile-time constant.\n//\n// - By using the type CompileAssert<(bool(expr))>, we ensures that\n//   expr is a compile-time constant.  (Template arguments must be\n//   determined at compile-time.)\n//\n// - The outter parentheses in CompileAssert<(bool(expr))> are necessary\n//   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written\n//\n//     CompileAssert<bool(expr)>\n//\n//   instead, these compilers will refuse to compile\n//\n//     GTEST_COMPILE_ASSERT_(5 > 0, some_message);\n//\n//   (They seem to think the \">\" in \"5 > 0\" marks the end of the\n//   template argument list.)\n//\n// - The array size is (bool(expr) ? 1 : -1), instead of simply\n//\n//     ((expr) ? 1 : -1).\n//\n//   This is to avoid running into a bug in MS VC 7.1, which\n//   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.\n\n// StaticAssertTypeEqHelper is used by StaticAssertTypeEq defined in gtest.h.\n//\n// This template is declared, but intentionally undefined.\ntemplate <typename T1, typename T2>\nstruct StaticAssertTypeEqHelper;\n\ntemplate <typename T>\nstruct StaticAssertTypeEqHelper<T, T> {\n  enum { value = true };\n};\n\n// Evaluates to the number of elements in 'array'.\n#define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))\n\n#if GTEST_HAS_GLOBAL_STRING\ntypedef ::string string;\n#else\ntypedef ::std::string string;\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#if GTEST_HAS_GLOBAL_WSTRING\ntypedef ::wstring wstring;\n#elif GTEST_HAS_STD_WSTRING\ntypedef ::std::wstring wstring;\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns 'condition'.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines scoped_ptr.\n\n// This implementation of scoped_ptr is PARTIAL - it only contains\n// enough stuff to satisfy Google Test's need.\ntemplate <typename T>\nclass scoped_ptr {\n public:\n  typedef T element_type;\n\n  explicit scoped_ptr(T* p = NULL) : ptr_(p) {}\n  ~scoped_ptr() { reset(); }\n\n  T& operator*() const { return *ptr_; }\n  T* operator->() const { return ptr_; }\n  T* get() const { return ptr_; }\n\n  T* release() {\n    T* const ptr = ptr_;\n    ptr_ = NULL;\n    return ptr;\n  }\n\n  void reset(T* p = NULL) {\n    if (p != ptr_) {\n      if (IsTrue(sizeof(T) > 0)) {  // Makes sure T is a complete type.\n        delete ptr_;\n      }\n      ptr_ = p;\n    }\n  }\n\n  friend void swap(scoped_ptr& a, scoped_ptr& b) {\n    using std::swap;\n    swap(a.ptr_, b.ptr_);\n  }\n\n private:\n  T* ptr_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr);\n};\n\n// Defines RE.\n\n// A simple C++ wrapper for <regex.h>.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE& other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  RE(const ::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_; }\n\n  // FullMatch(str, re) returns true iff regular expression re matches\n  // the entire str.\n  // PartialMatch(str, re) returns true iff regular expression re\n  // matches a substring of str (including str itself).\n  //\n  // TODO(wan@google.com): make FullMatch() and PartialMatch() work\n  // when str contains NUL characters.\n  static bool FullMatch(const ::std::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const ::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const char* str, const RE& re);\n  static bool PartialMatch(const char* str, const RE& re);\n\n private:\n  void Init(const char* regex);\n\n  // We use a const char* instead of an std::string, as Google Test used to be\n  // used where std::string is not available.  TODO(wan@google.com): change to\n  // std::string.\n  const char* pattern_;\n  bool is_valid_;\n\n#if GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  const char* full_pattern_;  // For FullMatch();\n\n#endif\n\n  GTEST_DISALLOW_ASSIGN_(RE);\n};\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity {\n  GTEST_INFO,\n  GTEST_WARNING,\n  GTEST_ERROR,\n  GTEST_FATAL\n};\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream& GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);\n};\n\n#if !defined(GTEST_LOG_)\n\n# define GTEST_LOG_(severity) \\\n    ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                  __FILE__, __LINE__).GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(NULL); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsys:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) << \"Additional message\";\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n# define GTEST_CHECK_(condition) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::IsTrue(condition)) \\\n      ; \\\n    else \\\n      GTEST_LOG_(FATAL) << \"Condition \" #condition \" failed. \"\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn't expand to a balanced 'if' statement, so enclose the macro\n// in {} if you need to use it as the only statement in an 'if'\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call)) \\\n    GTEST_LOG_(FATAL) << #posix_call << \"failed with error \" \\\n                      << gtest_error\n\n#if GTEST_HAS_STD_MOVE_\nusing std::move;\n#else  // GTEST_HAS_STD_MOVE_\ntemplate <typename T>\nconst T& move(const T& t) {\n  return t;\n}\n#endif  // GTEST_HAS_STD_MOVE_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertable to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_<ToType>(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To>\ninline To ImplicitCast_(To x) { return x; }\n\n// When you upcast (that is, cast a pointer from type Foo to type\n// SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts\n// always succeed.  When you downcast (that is, cast a pointer from\n// type Foo to type SubclassOfFoo), static_cast<> isn't safe, because\n// how do you know the pointer is really of type SubclassOfFoo?  It\n// could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,\n// when you downcast, you should use this macro.  In debug mode, we\n// use dynamic_cast<> to double-check the downcast is legal (we die\n// if it's not).  In normal mode, we do the efficient static_cast<>\n// instead.  Thus, it's important to test in debug mode to make sure\n// the cast is legal!\n//    This is the only place in the code we should use dynamic_cast<>.\n// In particular, you SHOULDN'T be using dynamic_cast<> in order to\n// do RTTI (eg code like this:\n//    if (dynamic_cast<Subclass1>(foo)) HandleASubclass1Object(foo);\n//    if (dynamic_cast<Subclass2>(foo)) HandleASubclass2Object(foo);\n// You should design the code some other way not to need this.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., down_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To, typename From>  // use like this: DownCast_<T*>(foo);\ninline To DownCast_(From* f) {  // so we only accept pointers\n  // Ensures that To is a sub-type of From *.  This test is here only\n  // for compile-time type checking, and has no overhead in an\n  // optimized build at run-time, as it will be optimized away\n  // completely.\n  GTEST_INTENTIONAL_CONST_COND_PUSH_()\n  if (false) {\n  GTEST_INTENTIONAL_CONST_COND_POP_()\n    const To to = NULL;\n    ::testing::internal::ImplicitCast_<From*>(to);\n  }\n\n#if GTEST_HAS_RTTI\n  // RTTI: debug mode only!\n  GTEST_CHECK_(f == NULL || dynamic_cast<To>(f) != NULL);\n#endif\n  return static_cast<To>(f);\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate <class Derived, class Base>\nDerived* CheckedDowncastToActualType(Base* base) {\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(typeid(*base) == typeid(Derived));\n#endif\n\n#if GTEST_HAS_DOWNCAST_\n  return ::down_cast<Derived*>(base);\n#elif GTEST_HAS_RTTI\n  return dynamic_cast<Derived*>(base);  // NOLINT\n#else\n  return static_cast<Derived*>(base);  // Poor man's downcast.\n#endif\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Returns a path to temporary directory.\nGTEST_API_ std::string TempDir();\n\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ const ::std::vector<testing::internal::string>& GetArgvs();\n\n#if GTEST_HAS_DEATH_TEST\n\nconst ::std::vector<testing::internal::string>& GetInjectableArgvs();\nvoid SetInjectableArgvs(const ::std::vector<testing::internal::string>*\n                             new_argvs);\n\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#if GTEST_IS_THREADSAFE\n# if GTEST_HAS_PTHREAD\n// Sleeps for (roughly) n milliseconds.  This function is only for testing\n// Google Test's own constructs.  Don't use it in user tests, either\n// directly or indirectly.\ninline void SleepMilliseconds(int n) {\n  const timespec time = {\n    0,                  // 0 seconds.\n    n * 1000L * 1000L,  // And n ms.\n  };\n  nanosleep(&time, NULL);\n}\n# endif  // GTEST_HAS_PTHREAD\n\n# if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_HAS_PTHREAD\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass Notification {\n public:\n  Notification() : notified_(false) {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n  }\n  ~Notification() {\n    pthread_mutex_destroy(&mutex_);\n  }\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    pthread_mutex_lock(&mutex_);\n    notified_ = true;\n    pthread_mutex_unlock(&mutex_);\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    for (;;) {\n      pthread_mutex_lock(&mutex_);\n      const bool notified = notified_;\n      pthread_mutex_unlock(&mutex_);\n      if (notified)\n        break;\n      SleepMilliseconds(10);\n    }\n  }\n\n private:\n  pthread_mutex_t mutex_;\n  bool notified_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\nGTEST_API_ void SleepMilliseconds(int n);\n\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including <windows.h> in this header file. Including <windows.h> is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true iff the handle is a valid handle object that can be closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);\n};\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass GTEST_API_ Notification {\n public:\n  Notification();\n  void Notify();\n  void WaitForNotification();\n\n private:\n  AutoHandle event_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n# endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don't want to use MinGW's pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n# if GTEST_HAS_PTHREAD && !GTEST_OS_WINDOWS_MINGW\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() {}\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern \"C\" inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast<ThreadWithParamBase*>(thread)->Run();\n  return NULL;\n}\n\n// Helper class for testing Google Test's multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam<int> thread(&ThreadFunc, 5, &thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test's own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&thread_, 0, &ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, 0));\n      finished_ = true;\n    }\n  }\n\n  virtual void Run() {\n    if (thread_can_start_ != NULL)\n      thread_can_start_->WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true iff we know that the thread function has finished.\n  pthread_t thread_;  // The native thread object.\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n# endif  // !GTEST_OS_WINDOWS && GTEST_HAS_PTHREAD ||\n         // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n# if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  _RTL_CRITICAL_SECTION* critical_section_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n    extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n    ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder<T>.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder<T> object holding a default value passed to\n  // this ThreadLocal<T>'s constructor and returns it.  It is the caller's\n  // responsibility not to call this when the ThreadLocal<T> instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocalBase);\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test's multi-threading constructs.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {\n  }\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param)\n        : func_(func),\n          param_(param) {\n    }\n    virtual ~RunnableImpl() {}\n    virtual void Run() {\n      func_(param_);\n    }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(RunnableImpl);\n  };\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal<int> tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate <typename T>\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n\n  T* GetOrCreateValue() const {\n    return static_cast<ValueHolder*>(\n        ThreadLocalRegistry::GetValueOnCurrentThread(this))->pointer();\n  }\n\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const {\n    return default_factory_->MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don't protect writing to has_owner_ here, as it's\n    // the caller's responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))\n        << \"The current thread is not holding the mutex @\" << this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there's no\n  // guarantee that a zero'd pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#  define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n     extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n#  define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n     ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, pthread_t() }\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n    has_owner_ = false;\n  }\n  ~Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal<T>.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern \"C\" inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast<ThreadLocalValueHolderBase*>(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&key, &DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast<ThreadLocalValueHolderBase*>(pthread_getspecific(key_));\n    if (holder != NULL) {\n      return CheckedDowncastToActualType<ValueHolder>(holder)->pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_->MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder->pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T& value) : value_(value) {}\n  T* pointer() { return &value_; }\n  const T* pointer() const { return &value_; }\n  const T& get() const { return value_; }\n  void set(const T& value) { value_ = value; }\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n// Passing non-POD classes through ellipsis (...) crashes the ARM\n// compiler and generates a warning in Sun Studio.  The Nokia Symbian\n// and the IBM XL C/C++ compiler try to instantiate a copy constructor\n// for objects passed through ellipsis (...), failing for uncopyable\n// objects.  We define this to ensure that only POD is passed through\n// ellipsis on these systems.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_ELLIPSIS_NEEDS_POD_ 1\n#else\n# define GTEST_CAN_COMPARE_NULL 1\n#endif\n\n// The Nokia Symbian and IBM XL C/C++ compilers cannot decide between\n// const T& and const T* in a function template.  These compilers\n// _can_ decide between class template specializations for T and T*,\n// so a tr1::type_traits-like is_pointer works.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__)\n# define GTEST_NEEDS_IS_POINTER_ 1\n#endif\n\ntemplate <bool bool_value>\nstruct bool_constant {\n  typedef bool_constant<bool_value> type;\n  static const bool value = bool_value;\n};\ntemplate <bool bool_value> const bool bool_constant<bool_value>::value;\n\ntypedef bool_constant<false> false_type;\ntypedef bool_constant<true> true_type;\n\ntemplate <typename T>\nstruct is_pointer : public false_type {};\n\ntemplate <typename T>\nstruct is_pointer<T*> : public true_type {};\n\ntemplate <typename Iterator>\nstruct IteratorTraits {\n  typedef typename Iterator::value_type value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<T*> {\n  typedef T value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<const T*> {\n  typedef T value_type;\n};\n\n#if GTEST_OS_WINDOWS\n# define GTEST_PATH_SEP_ \"\\\\\"\n# define GTEST_HAS_ALT_PATH_SEP_ 1\n// The biggest signed integer type the compiler supports.\ntypedef __int64 BiggestInt;\n#else\n# define GTEST_PATH_SEP_ \"/\"\n# define GTEST_HAS_ALT_PATH_SEP_ 0\ntypedef long long BiggestInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast<unsigned char>(ch);\n  return ch == low_byte && isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() && IsSpace(*--it))\n    it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// Functions with a different name on Windows.\n\n#if GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n# ifdef __BORLANDC__\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\n# else  // !__BORLANDC__\n#  if GTEST_OS_WINDOWS_MOBILE\ninline int IsATTY(int /* fd */) { return 0; }\n#  else\ninline int IsATTY(int fd) { return _isatty(fd); }\n#  endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return _strdup(src); }\n# endif  // __BORLANDC__\n\n# if GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast<int>(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n# else\ninline int FileNo(FILE* file) { return _fileno(file); }\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct& st) {\n  return (_S_IFDIR & st.st_mode) != 0;\n}\n# endif  // GTEST_OS_WINDOWS_MOBILE\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }\n\n#endif  // GTEST_OS_WINDOWS\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4996 /* deprecated function */)\n\ninline const char* StrNCpy(char* dest, const char* src, size_t n) {\n  return strncpy(dest, src, n);\n}\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren't needed on Windows CE at this time and thus not\n// defined there.\n\n#if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n  return fopen(path, mode);\n}\n#if !GTEST_OS_WINDOWS_MOBILE\ninline FILE *FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !GTEST_OS_WINDOWS_MOBILE\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast<int>(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast<int>(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif\ninline const char* GetEnv(const char* name) {\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT\n  // We are on Windows CE, which has no environment variables.\n  static_cast<void>(name);  // To prevent 'unused argument' warning.\n  return NULL;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != NULL && env[0] != '\\0') ? env : NULL;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n#if GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\nvoid Abort();\n#else\ninline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC \"deprecates\" snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE\n// MSVC 2005 and above support variadic macros.\n# define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n     _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s and MSVC prior to 2005 doesn't\n// complain about _snprintf.\n# define GTEST_SNPRINTF_ _snprintf\n#else\n# define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The maximum number a BiggestInt can represent.  This definition\n// works no matter BiggestInt is represented in one's complement or\n// two's complement.\n//\n// We cannot rely on numeric_limits in STL, as __int64 and long long\n// are not part of standard C++ and numeric_limits doesn't need to be\n// defined for them.\nconst BiggestInt kMaxBiggestInt =\n    ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize<4>::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that's all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate <size_t size>\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize<N> with incorrect\n  // values of N.\n  typedef void UInt;\n};\n\n// The specialization for size 4.\ntemplate <>\nclass TypeWithSize<4> {\n public:\n  // unsigned int has size 4 in both gcc and MSVC.\n  //\n  // As base/basictypes.h doesn't compile on Windows, we cannot use\n  // uint32, uint64, and etc here.\n  typedef int Int;\n  typedef unsigned int UInt;\n};\n\n// The specialization for size 8.\ntemplate <>\nclass TypeWithSize<8> {\n public:\n#if GTEST_OS_WINDOWS\n  typedef __int64 Int;\n  typedef unsigned __int64 UInt;\n#else\n  typedef long long Int;  // NOLINT\n  typedef unsigned long long UInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n};\n\n// Integer types of known sizes.\ntypedef TypeWithSize<4>::Int Int32;\ntypedef TypeWithSize<4>::UInt UInt32;\ntypedef TypeWithSize<8>::Int Int64;\ntypedef TypeWithSize<8>::UInt UInt64;\ntypedef TypeWithSize<8>::Int TimeInMillis;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n# define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n#if !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n# define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n#endif  // !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n\n#if !defined(GTEST_DECLARE_bool_)\n# define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n// Macros for declaring flags.\n# define GTEST_DECLARE_bool_(name) GTEST_API_ extern bool GTEST_FLAG(name)\n# define GTEST_DECLARE_int32_(name) \\\n    GTEST_API_ extern ::testing::internal::Int32 GTEST_FLAG(name)\n#define GTEST_DECLARE_string_(name) \\\n    GTEST_API_ extern ::std::string GTEST_FLAG(name)\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n    GTEST_API_ bool GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n    GTEST_API_ ::testing::internal::Int32 GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n    GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val)\n\n#endif  // !defined(GTEST_DECLARE_bool_)\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n# define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n# define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses 'str' for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\n// TODO(chandlerc): Find a better way to refactor flag and environment parsing\n// out of both gtest-port.cc and gtest.cc to avoid exporting this utility\n// function.\nbool ParseInt32(const Message& src_text, const char* str, Int32* value);\n\n// Parses a bool/Int32/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);\nstd::string StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp", "content": "//===-- PythonDataObjectsTests.cpp ----------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"Plugins/ScriptInterpreter/Python/lldb-python.h\"\n#include \"gtest/gtest.h\"\n\n#include \"Plugins/ScriptInterpreter/Python/PythonDataObjects.h\"\n#include \"Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.h\"\n#include \"lldb/Host/File.h\"\n#include \"lldb/Host/FileSystem.h\"\n#include \"lldb/Host/HostInfo.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"llvm/Testing/Support/Error.h\"\n\n#include \"PythonTestSuite.h\"\n\nusing namespace lldb_private;\nusing namespace lldb_private::python;\nusing llvm::Error;\nusing llvm::Expected;\n\nclass PythonDataObjectsTest : public PythonTestSuite {\npublic:\n  void SetUp() override {\n    PythonTestSuite::SetUp();\n\n    m_sys_module = unwrapIgnoringErrors(PythonModule::Import(\"sys\"));\n    m_main_module = PythonModule::MainModule();\n    m_builtins_module = PythonModule::BuiltinsModule();\n  }\n\n  void TearDown() override {\n    m_sys_module.Reset();\n    m_main_module.Reset();\n    m_builtins_module.Reset();\n\n    PythonTestSuite::TearDown();\n  }\n\nprotected:\n  PythonModule m_sys_module;\n  PythonModule m_main_module;\n  PythonModule m_builtins_module;\n};\n\nTEST_F(PythonDataObjectsTest, TestOwnedReferences) {\n  // After creating a new object, the refcount should be >= 1\n  PyObject *obj = PyLong_FromLong(3);\n  Py_ssize_t original_refcnt = obj->ob_refcnt;\n  EXPECT_LE(1, original_refcnt);\n\n  // If we take an owned reference, the refcount should be the same\n  PythonObject owned_long(PyRefType::Owned, obj);\n  EXPECT_EQ(original_refcnt, owned_long.get()->ob_refcnt);\n\n  // Take another reference and verify that the refcount increases by 1\n  PythonObject strong_ref(owned_long);\n  EXPECT_EQ(original_refcnt + 1, strong_ref.get()->ob_refcnt);\n\n  // If we reset the first one, the refcount should be the original value.\n  owned_long.Reset();\n  EXPECT_EQ(original_refcnt, strong_ref.get()->ob_refcnt);\n}\n\nTEST_F(PythonDataObjectsTest, TestResetting) {\n  PythonDictionary dict(PyInitialValue::Empty);\n\n  PyObject *new_dict = PyDict_New();\n  dict = Take<PythonDictionary>(new_dict);\n  EXPECT_EQ(new_dict, dict.get());\n\n  dict = Take<PythonDictionary>(PyDict_New());\n  EXPECT_NE(nullptr, dict.get());\n  dict.Reset();\n  EXPECT_EQ(nullptr, dict.get());\n}\n\nTEST_F(PythonDataObjectsTest, TestBorrowedReferences) {\n  PythonInteger long_value(PyRefType::Owned, PyLong_FromLong(3));\n  Py_ssize_t original_refcnt = long_value.get()->ob_refcnt;\n  EXPECT_LE(1, original_refcnt);\n\n  PythonInteger borrowed_long(PyRefType::Borrowed, long_value.get());\n  EXPECT_EQ(original_refcnt + 1, borrowed_long.get()->ob_refcnt);\n}\n\nTEST_F(PythonDataObjectsTest, TestGlobalNameResolutionNoDot) {\n  PythonObject sys_module = m_main_module.ResolveName(\"sys\");\n  EXPECT_EQ(m_sys_module.get(), sys_module.get());\n  EXPECT_TRUE(sys_module.IsAllocated());\n  EXPECT_TRUE(PythonModule::Check(sys_module.get()));\n}\n\nTEST_F(PythonDataObjectsTest, TestModuleNameResolutionNoDot) {\n  PythonObject sys_path = m_sys_module.ResolveName(\"path\");\n  PythonObject sys_version_info = m_sys_module.ResolveName(\"version_info\");\n  EXPECT_TRUE(sys_path.IsAllocated());\n  EXPECT_TRUE(sys_version_info.IsAllocated());\n\n  EXPECT_TRUE(PythonList::Check(sys_path.get()));\n}\n\nTEST_F(PythonDataObjectsTest, TestTypeNameResolutionNoDot) {\n  PythonObject sys_version_info = m_sys_module.ResolveName(\"version_info\");\n\n  PythonObject version_info_type(PyRefType::Owned,\n                                 PyObject_Type(sys_version_info.get()));\n  EXPECT_TRUE(version_info_type.IsAllocated());\n  PythonObject major_version_field = version_info_type.ResolveName(\"major\");\n  EXPECT_TRUE(major_version_field.IsAllocated());\n}\n\nTEST_F(PythonDataObjectsTest, TestInstanceNameResolutionNoDot) {\n  PythonObject sys_version_info = m_sys_module.ResolveName(\"version_info\");\n  PythonObject major_version_field = sys_version_info.ResolveName(\"major\");\n  PythonObject minor_version_field = sys_version_info.ResolveName(\"minor\");\n\n  EXPECT_TRUE(major_version_field.IsAllocated());\n  EXPECT_TRUE(minor_version_field.IsAllocated());\n\n  auto major_version_value = As<long long>(major_version_field);\n  auto minor_version_value = As<long long>(minor_version_field);\n\n  EXPECT_THAT_EXPECTED(major_version_value, llvm::HasValue(PY_MAJOR_VERSION));\n  EXPECT_THAT_EXPECTED(minor_version_value, llvm::HasValue(PY_MINOR_VERSION));\n}\n\nTEST_F(PythonDataObjectsTest, TestGlobalNameResolutionWithDot) {\n  PythonObject sys_path = m_main_module.ResolveName(\"sys.path\");\n  EXPECT_TRUE(sys_path.IsAllocated());\n  EXPECT_TRUE(PythonList::Check(sys_path.get()));\n\n  auto version_major =\n      As<long long>(m_main_module.ResolveName(\"sys.version_info.major\"));\n\n  auto version_minor =\n      As<long long>(m_main_module.ResolveName(\"sys.version_info.minor\"));\n\n  EXPECT_THAT_EXPECTED(version_major, llvm::HasValue(PY_MAJOR_VERSION));\n  EXPECT_THAT_EXPECTED(version_minor, llvm::HasValue(PY_MINOR_VERSION));\n}\n\nTEST_F(PythonDataObjectsTest, TestDictionaryResolutionWithDot) {\n  // Make up a custom dictionary with \"sys\" pointing to the `sys` module.\n  PythonDictionary dict(PyInitialValue::Empty);\n  dict.SetItemForKey(PythonString(\"sys\"), m_sys_module);\n\n  // Now use that dictionary to resolve `sys.version_info.major`\n  auto version_major = As<long long>(\n      PythonObject::ResolveNameWithDictionary(\"sys.version_info.major\", dict));\n\n  auto version_minor = As<long long>(\n      PythonObject::ResolveNameWithDictionary(\"sys.version_info.minor\", dict));\n\n  EXPECT_THAT_EXPECTED(version_major, llvm::HasValue(PY_MAJOR_VERSION));\n  EXPECT_THAT_EXPECTED(version_minor, llvm::HasValue(PY_MINOR_VERSION));\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonInteger) {\n  // Test that integers behave correctly when wrapped by a PythonInteger.\n\n#if PY_MAJOR_VERSION < 3\n  // Verify that `PythonInt` works correctly when given a PyInt object.\n  // Note that PyInt doesn't exist in Python 3.x, so this is only for 2.x\n  PyObject *py_int = PyInt_FromLong(12);\n  EXPECT_TRUE(PythonInteger::Check(py_int));\n  PythonInteger python_int(PyRefType::Owned, py_int);\n\n  EXPECT_EQ(PyObjectType::Integer, python_int.GetObjectType());\n  auto python_int_value = As<long long>(python_int);\n  EXPECT_THAT_EXPECTED(python_int_value, llvm::HasValue(12));\n#endif\n\n  // Verify that `PythonInteger` works correctly when given a PyLong object.\n  PyObject *py_long = PyLong_FromLong(12);\n  EXPECT_TRUE(PythonInteger::Check(py_long));\n  PythonInteger python_long(PyRefType::Owned, py_long);\n  EXPECT_EQ(PyObjectType::Integer, python_long.GetObjectType());\n\n  // Verify that you can reset the value and that it is reflected properly.\n  python_long.SetInteger(40);\n  auto e = As<long long>(python_long);\n  EXPECT_THAT_EXPECTED(e, llvm::HasValue(40));\n\n  // Test that creating a `PythonInteger` object works correctly with the\n  // int constructor.\n  PythonInteger constructed_int(7);\n  auto value = As<long long>(constructed_int);\n  EXPECT_THAT_EXPECTED(value, llvm::HasValue(7));\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonBoolean) {\n  // Test PythonBoolean constructed from Py_True\n  EXPECT_TRUE(PythonBoolean::Check(Py_True));\n  PythonBoolean python_true(PyRefType::Owned, Py_True);\n  EXPECT_EQ(PyObjectType::Boolean, python_true.GetObjectType());\n\n  // Test PythonBoolean constructed from Py_False\n  EXPECT_TRUE(PythonBoolean::Check(Py_False));\n  PythonBoolean python_false(PyRefType::Owned, Py_False);\n  EXPECT_EQ(PyObjectType::Boolean, python_false.GetObjectType());\n\n  auto test_from_long = [](long value) {\n    PyObject *py_bool = PyBool_FromLong(value);\n    EXPECT_TRUE(PythonBoolean::Check(py_bool));\n    PythonBoolean python_boolean(PyRefType::Owned, py_bool);\n    EXPECT_EQ(PyObjectType::Boolean, python_boolean.GetObjectType());\n    EXPECT_EQ(bool(value), python_boolean.GetValue());\n  };\n\n  // Test PythonBoolean constructed from long integer values.\n  test_from_long(0); // Test 'false' value.\n  test_from_long(1); // Test 'true' value.\n  test_from_long(~0); // Any value != 0 is 'true'.\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonBytes) {\n  static const char *test_bytes = \"PythonDataObjectsTest::TestPythonBytes\";\n  PyObject *py_bytes = PyBytes_FromString(test_bytes);\n  EXPECT_TRUE(PythonBytes::Check(py_bytes));\n  PythonBytes python_bytes(PyRefType::Owned, py_bytes);\n\n#if PY_MAJOR_VERSION < 3\n  EXPECT_TRUE(PythonString::Check(py_bytes));\n  EXPECT_EQ(PyObjectType::String, python_bytes.GetObjectType());\n#else\n  EXPECT_FALSE(PythonString::Check(py_bytes));\n  EXPECT_EQ(PyObjectType::Bytes, python_bytes.GetObjectType());\n#endif\n\n  llvm::ArrayRef<uint8_t> bytes = python_bytes.GetBytes();\n  EXPECT_EQ(bytes.size(), strlen(test_bytes));\n  EXPECT_EQ(0, ::memcmp(bytes.data(), test_bytes, bytes.size()));\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonByteArray) {\n  static const char *test_bytes = \"PythonDataObjectsTest::TestPythonByteArray\";\n  llvm::StringRef orig_bytes(test_bytes);\n  PyObject *py_bytes =\n      PyByteArray_FromStringAndSize(test_bytes, orig_bytes.size());\n  EXPECT_TRUE(PythonByteArray::Check(py_bytes));\n  PythonByteArray python_bytes(PyRefType::Owned, py_bytes);\n  EXPECT_EQ(PyObjectType::ByteArray, python_bytes.GetObjectType());\n\n  llvm::ArrayRef<uint8_t> after_bytes = python_bytes.GetBytes();\n  EXPECT_EQ(after_bytes.size(), orig_bytes.size());\n  EXPECT_EQ(0, ::memcmp(orig_bytes.data(), test_bytes, orig_bytes.size()));\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonString) {\n  // Test that strings behave correctly when wrapped by a PythonString.\n\n  static const char *test_string = \"PythonDataObjectsTest::TestPythonString1\";\n  static const char *test_string2 = \"PythonDataObjectsTest::TestPythonString2\";\n\n#if PY_MAJOR_VERSION < 3\n  // Verify that `PythonString` works correctly when given a PyString object.\n  // Note that PyString doesn't exist in Python 3.x, so this is only for 2.x\n  PyObject *py_string = PyString_FromString(test_string);\n  EXPECT_TRUE(PythonString::Check(py_string));\n  PythonString python_string(PyRefType::Owned, py_string);\n\n  EXPECT_EQ(PyObjectType::String, python_string.GetObjectType());\n  EXPECT_STREQ(test_string, python_string.GetString().data());\n#else\n  // Verify that `PythonString` works correctly when given a PyUnicode object.\n  PyObject *py_unicode = PyUnicode_FromString(test_string);\n  EXPECT_TRUE(PythonString::Check(py_unicode));\n  PythonString python_unicode(PyRefType::Owned, py_unicode);\n  EXPECT_EQ(PyObjectType::String, python_unicode.GetObjectType());\n  EXPECT_STREQ(test_string, python_unicode.GetString().data());\n#endif\n\n  // Test that creating a `PythonString` object works correctly with the\n  // string constructor\n  PythonString constructed_string(test_string2);\n  EXPECT_EQ(test_string2, constructed_string.GetString());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonStringToStr) {\n  const char *GetString = \"PythonDataObjectsTest::TestPythonStringToStr\";\n\n  PythonString str(GetString);\n  EXPECT_EQ(GetString, str.GetString());\n\n  PythonString str_str = str.Str();\n  EXPECT_EQ(GetString, str_str.GetString());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonIntegerToStr) {}\n\nTEST_F(PythonDataObjectsTest, TestPythonIntegerToStructuredInteger) {\n  PythonInteger integer(7);\n  auto int_sp = integer.CreateStructuredInteger();\n  EXPECT_EQ(7U, int_sp->GetValue());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonStringToStructuredString) {\n  static const char *test_string =\n      \"PythonDataObjectsTest::TestPythonStringToStructuredString\";\n  PythonString constructed_string(test_string);\n  auto string_sp = constructed_string.CreateStructuredString();\n  EXPECT_EQ(test_string, string_sp->GetStringValue());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonListValueEquality) {\n  // Test that a list which is built through the native\n  // Python API behaves correctly when wrapped by a PythonList.\n  static const unsigned list_size = 2;\n  static const long long_value0 = 5;\n  static const char *const string_value1 = \"String Index 1\";\n\n  PyObject *py_list = PyList_New(2);\n  EXPECT_TRUE(PythonList::Check(py_list));\n  PythonList list(PyRefType::Owned, py_list);\n\n  PythonObject list_items[list_size];\n  list_items[0] = PythonInteger(long_value0);\n  list_items[1] = PythonString(string_value1);\n\n  for (unsigned i = 0; i < list_size; ++i)\n    list.SetItemAtIndex(i, list_items[i]);\n\n  EXPECT_EQ(list_size, list.GetSize());\n  EXPECT_EQ(PyObjectType::List, list.GetObjectType());\n\n  // Verify that the values match\n  PythonObject chk_value1 = list.GetItemAtIndex(0);\n  PythonObject chk_value2 = list.GetItemAtIndex(1);\n  EXPECT_TRUE(PythonInteger::Check(chk_value1.get()));\n  EXPECT_TRUE(PythonString::Check(chk_value2.get()));\n\n  PythonInteger chk_int(PyRefType::Borrowed, chk_value1.get());\n  PythonString chk_str(PyRefType::Borrowed, chk_value2.get());\n\n  auto chkint = As<long long>(chk_value1);\n  ASSERT_THAT_EXPECTED(chkint, llvm::HasValue(long_value0));\n  EXPECT_EQ(string_value1, chk_str.GetString());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonListManipulation) {\n  // Test that manipulation of a PythonList behaves correctly when\n  // wrapped by a PythonDictionary.\n\n  static const long long_value0 = 5;\n  static const char *const string_value1 = \"String Index 1\";\n\n  PythonList list(PyInitialValue::Empty);\n  PythonInteger integer(long_value0);\n  PythonString string(string_value1);\n\n  list.AppendItem(integer);\n  list.AppendItem(string);\n  EXPECT_EQ(2U, list.GetSize());\n\n  // Verify that the values match\n  PythonObject chk_value1 = list.GetItemAtIndex(0);\n  PythonObject chk_value2 = list.GetItemAtIndex(1);\n  EXPECT_TRUE(PythonInteger::Check(chk_value1.get()));\n  EXPECT_TRUE(PythonString::Check(chk_value2.get()));\n\n  PythonInteger chk_int(PyRefType::Borrowed, chk_value1.get());\n  PythonString chk_str(PyRefType::Borrowed, chk_value2.get());\n\n  auto e = As<long long>(chk_int);\n  EXPECT_THAT_EXPECTED(e, llvm::HasValue(long_value0));\n  EXPECT_EQ(string_value1, chk_str.GetString());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonListToStructuredList) {\n  static const long long_value0 = 5;\n  static const char *const string_value1 = \"String Index 1\";\n\n  PythonList list(PyInitialValue::Empty);\n  list.AppendItem(PythonInteger(long_value0));\n  list.AppendItem(PythonString(string_value1));\n\n  auto array_sp = list.CreateStructuredArray();\n  EXPECT_EQ(lldb::eStructuredDataTypeInteger,\n            array_sp->GetItemAtIndex(0)->GetType());\n  EXPECT_EQ(lldb::eStructuredDataTypeString,\n            array_sp->GetItemAtIndex(1)->GetType());\n\n  auto int_sp = array_sp->GetItemAtIndex(0)->GetAsInteger();\n  auto string_sp = array_sp->GetItemAtIndex(1)->GetAsString();\n\n  EXPECT_EQ(long_value0, long(int_sp->GetValue()));\n  EXPECT_EQ(string_value1, string_sp->GetValue());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonTupleSize) {\n  PythonTuple tuple(PyInitialValue::Empty);\n  EXPECT_EQ(0U, tuple.GetSize());\n\n  tuple = PythonTuple(3);\n  EXPECT_EQ(3U, tuple.GetSize());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonTupleValues) {\n  PythonTuple tuple(3);\n\n  PythonInteger int_value(1);\n  PythonString string_value(\"Test\");\n  PythonObject none_value(PyRefType::Borrowed, Py_None);\n\n  tuple.SetItemAtIndex(0, int_value);\n  tuple.SetItemAtIndex(1, string_value);\n  tuple.SetItemAtIndex(2, none_value);\n\n  EXPECT_EQ(tuple.GetItemAtIndex(0).get(), int_value.get());\n  EXPECT_EQ(tuple.GetItemAtIndex(1).get(), string_value.get());\n  EXPECT_EQ(tuple.GetItemAtIndex(2).get(), none_value.get());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonTupleInitializerList) {\n  PythonInteger int_value(1);\n  PythonString string_value(\"Test\");\n  PythonObject none_value(PyRefType::Borrowed, Py_None);\n  PythonTuple tuple{int_value, string_value, none_value};\n  EXPECT_EQ(3U, tuple.GetSize());\n\n  EXPECT_EQ(tuple.GetItemAtIndex(0).get(), int_value.get());\n  EXPECT_EQ(tuple.GetItemAtIndex(1).get(), string_value.get());\n  EXPECT_EQ(tuple.GetItemAtIndex(2).get(), none_value.get());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonTupleInitializerList2) {\n  PythonInteger int_value(1);\n  PythonString string_value(\"Test\");\n  PythonObject none_value(PyRefType::Borrowed, Py_None);\n\n  PythonTuple tuple{int_value.get(), string_value.get(), none_value.get()};\n  EXPECT_EQ(3U, tuple.GetSize());\n\n  EXPECT_EQ(tuple.GetItemAtIndex(0).get(), int_value.get());\n  EXPECT_EQ(tuple.GetItemAtIndex(1).get(), string_value.get());\n  EXPECT_EQ(tuple.GetItemAtIndex(2).get(), none_value.get());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonTupleToStructuredList) {\n  PythonInteger int_value(1);\n  PythonString string_value(\"Test\");\n\n  PythonTuple tuple{int_value.get(), string_value.get()};\n\n  auto array_sp = tuple.CreateStructuredArray();\n  EXPECT_EQ(tuple.GetSize(), array_sp->GetSize());\n  EXPECT_EQ(lldb::eStructuredDataTypeInteger,\n            array_sp->GetItemAtIndex(0)->GetType());\n  EXPECT_EQ(lldb::eStructuredDataTypeString,\n            array_sp->GetItemAtIndex(1)->GetType());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonDictionaryValueEquality) {\n  // Test that a dictionary which is built through the native\n  // Python API behaves correctly when wrapped by a PythonDictionary.\n  static const unsigned dict_entries = 2;\n  const char *key_0 = \"Key 0\";\n  int key_1 = 1;\n  const int value_0 = 0;\n  const char *value_1 = \"Value 1\";\n\n  PythonObject py_keys[dict_entries];\n  PythonObject py_values[dict_entries];\n\n  py_keys[0] = PythonString(key_0);\n  py_keys[1] = PythonInteger(key_1);\n  py_values[0] = PythonInteger(value_0);\n  py_values[1] = PythonString(value_1);\n\n  PyObject *py_dict = PyDict_New();\n  EXPECT_TRUE(PythonDictionary::Check(py_dict));\n  PythonDictionary dict(PyRefType::Owned, py_dict);\n\n  for (unsigned i = 0; i < dict_entries; ++i)\n    PyDict_SetItem(py_dict, py_keys[i].get(), py_values[i].get());\n  EXPECT_EQ(dict.GetSize(), dict_entries);\n  EXPECT_EQ(PyObjectType::Dictionary, dict.GetObjectType());\n\n  // Verify that the values match\n  PythonObject chk_value1 = dict.GetItemForKey(py_keys[0]);\n  PythonObject chk_value2 = dict.GetItemForKey(py_keys[1]);\n  EXPECT_TRUE(PythonInteger::Check(chk_value1.get()));\n  EXPECT_TRUE(PythonString::Check(chk_value2.get()));\n\n  PythonString chk_str(PyRefType::Borrowed, chk_value2.get());\n  auto chkint = As<long long>(chk_value1);\n\n  EXPECT_THAT_EXPECTED(chkint, llvm::HasValue(value_0));\n  EXPECT_EQ(value_1, chk_str.GetString());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonDictionaryManipulation) {\n  // Test that manipulation of a dictionary behaves correctly when wrapped\n  // by a PythonDictionary.\n  static const unsigned dict_entries = 2;\n\n  const char *const key_0 = \"Key 0\";\n  const char *const key_1 = \"Key 1\";\n  const long value_0 = 1;\n  const char *const value_1 = \"Value 1\";\n\n  PythonString keys[dict_entries];\n  PythonObject values[dict_entries];\n\n  keys[0] = PythonString(key_0);\n  keys[1] = PythonString(key_1);\n  values[0] = PythonInteger(value_0);\n  values[1] = PythonString(value_1);\n\n  PythonDictionary dict(PyInitialValue::Empty);\n  for (int i = 0; i < 2; ++i)\n    dict.SetItemForKey(keys[i], values[i]);\n\n  EXPECT_EQ(dict_entries, dict.GetSize());\n\n  // Verify that the keys and values match\n  PythonObject chk_value1 = dict.GetItemForKey(keys[0]);\n  PythonObject chk_value2 = dict.GetItemForKey(keys[1]);\n  EXPECT_TRUE(PythonInteger::Check(chk_value1.get()));\n  EXPECT_TRUE(PythonString::Check(chk_value2.get()));\n\n  auto chkint = As<long long>(chk_value1);\n  PythonString chk_str(PyRefType::Borrowed, chk_value2.get());\n\n  EXPECT_THAT_EXPECTED(chkint, llvm::HasValue(value_0));\n  EXPECT_EQ(value_1, chk_str.GetString());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonDictionaryToStructuredDictionary) {\n  static const char *const string_key0 = \"String Key 0\";\n  static const char *const string_key1 = \"String Key 1\";\n\n  static const char *const string_value0 = \"String Value 0\";\n  static const long int_value1 = 7;\n\n  PythonDictionary dict(PyInitialValue::Empty);\n  dict.SetItemForKey(PythonString(string_key0), PythonString(string_value0));\n  dict.SetItemForKey(PythonString(string_key1), PythonInteger(int_value1));\n\n  auto dict_sp = dict.CreateStructuredDictionary();\n  EXPECT_EQ(2U, dict_sp->GetSize());\n\n  EXPECT_TRUE(dict_sp->HasKey(string_key0));\n  EXPECT_TRUE(dict_sp->HasKey(string_key1));\n\n  auto string_sp = dict_sp->GetValueForKey(string_key0)->GetAsString();\n  auto int_sp = dict_sp->GetValueForKey(string_key1)->GetAsInteger();\n\n  EXPECT_EQ(string_value0, string_sp->GetValue());\n  EXPECT_EQ(int_value1, long(int_sp->GetValue()));\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonCallableCheck) {\n  PythonObject sys_exc_info = m_sys_module.ResolveName(\"exc_info\");\n  PythonObject none(PyRefType::Borrowed, Py_None);\n\n  EXPECT_TRUE(PythonCallable::Check(sys_exc_info.get()));\n  EXPECT_FALSE(PythonCallable::Check(none.get()));\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonCallableInvoke) {\n  auto list = m_builtins_module.ResolveName(\"list\").AsType<PythonCallable>();\n  PythonInteger one(1);\n  PythonString two(\"two\");\n  PythonTuple three = {one, two};\n\n  PythonTuple tuple_to_convert = {one, two, three};\n  PythonObject result = list({tuple_to_convert});\n\n  EXPECT_TRUE(PythonList::Check(result.get()));\n  auto list_result = result.AsType<PythonList>();\n  EXPECT_EQ(3U, list_result.GetSize());\n  EXPECT_EQ(one.get(), list_result.GetItemAtIndex(0).get());\n  EXPECT_EQ(two.get(), list_result.GetItemAtIndex(1).get());\n  EXPECT_EQ(three.get(), list_result.GetItemAtIndex(2).get());\n}\n\nTEST_F(PythonDataObjectsTest, TestPythonFile) {\n  auto file = FileSystem::Instance().Open(FileSpec(FileSystem::DEV_NULL),\n                                          File::eOpenOptionRead);\n  ASSERT_THAT_EXPECTED(file, llvm::Succeeded());\n  auto py_file = PythonFile::FromFile(*file.get(), \"r\");\n  ASSERT_THAT_EXPECTED(py_file, llvm::Succeeded());\n  EXPECT_TRUE(PythonFile::Check(py_file.get().get()));\n}\n\nTEST_F(PythonDataObjectsTest, TestObjectAttributes) {\n  PythonInteger py_int(42);\n  EXPECT_TRUE(py_int.HasAttribute(\"numerator\"));\n  EXPECT_FALSE(py_int.HasAttribute(\"this_should_not_exist\"));\n\n  auto numerator_attr = As<long long>(py_int.GetAttributeValue(\"numerator\"));\n\n  EXPECT_THAT_EXPECTED(numerator_attr, llvm::HasValue(42));\n}\n\nTEST_F(PythonDataObjectsTest, TestExtractingUInt64ThroughStructuredData) {\n  // Make up a custom dictionary with \"sys\" pointing to the `sys` module.\n  const char *key_name = \"addr\";\n  const uint64_t value = 0xf000000000000000ull;\n  PythonDictionary python_dict(PyInitialValue::Empty);\n  PythonInteger python_ull_value(PyRefType::Owned,\n                                 PyLong_FromUnsignedLongLong(value));\n  python_dict.SetItemForKey(PythonString(key_name), python_ull_value);\n  StructuredData::ObjectSP structured_data_sp =\n      python_dict.CreateStructuredObject();\n  EXPECT_TRUE((bool)structured_data_sp);\n  if (structured_data_sp) {\n    StructuredData::Dictionary *structured_dict_ptr =\n        structured_data_sp->GetAsDictionary();\n    EXPECT_TRUE(structured_dict_ptr != nullptr);\n    if (structured_dict_ptr) {\n      StructuredData::ObjectSP structured_addr_value_sp =\n          structured_dict_ptr->GetValueForKey(key_name);\n      EXPECT_TRUE((bool)structured_addr_value_sp);\n      const uint64_t extracted_value =\n          structured_addr_value_sp->GetIntegerValue(123);\n      EXPECT_TRUE(extracted_value == value);\n    }\n  }\n}\n\nTEST_F(PythonDataObjectsTest, TestCallable) {\n\n  PythonDictionary globals(PyInitialValue::Empty);\n  auto builtins = PythonModule::BuiltinsModule();\n  llvm::Error error = globals.SetItem(\"__builtins__\", builtins);\n  ASSERT_FALSE(error);\n\n  {\n    PyObject *o = PyRun_String(\"lambda x : x\", Py_eval_input, globals.get(),\n                               globals.get());\n    ASSERT_FALSE(o == NULL);\n    auto lambda = Take<PythonCallable>(o);\n    auto arginfo = lambda.GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 1u);\n  }\n\n  {\n    PyObject *o = PyRun_String(\"lambda x,y=0: x\", Py_eval_input, globals.get(),\n                               globals.get());\n    ASSERT_FALSE(o == NULL);\n    auto lambda = Take<PythonCallable>(o);\n    auto arginfo = lambda.GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 2u);\n  }\n\n  {\n    PyObject *o = PyRun_String(\"lambda x,y=0, **kw: x\", Py_eval_input,\n                               globals.get(), globals.get());\n    ASSERT_FALSE(o == NULL);\n    auto lambda = Take<PythonCallable>(o);\n    auto arginfo = lambda.GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 2u);\n  }\n\n  {\n    PyObject *o = PyRun_String(\"lambda x,y,*a: x\", Py_eval_input, globals.get(),\n                               globals.get());\n    ASSERT_FALSE(o == NULL);\n    auto lambda = Take<PythonCallable>(o);\n    auto arginfo = lambda.GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args,\n              PythonCallable::ArgInfo::UNBOUNDED);\n  }\n\n  {\n    PyObject *o = PyRun_String(\"lambda x,y,*a,**kw: x\", Py_eval_input,\n                               globals.get(), globals.get());\n    ASSERT_FALSE(o == NULL);\n    auto lambda = Take<PythonCallable>(o);\n    auto arginfo = lambda.GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args,\n              PythonCallable::ArgInfo::UNBOUNDED);\n  }\n\n  {\n    const char *script = R\"(\nclass Foo:\n  def bar(self, x):\n     return x\n  @classmethod\n  def classbar(cls, x):\n     return x\n  @staticmethod\n  def staticbar(x):\n     return x\n  def __call__(self, x):\n     return x\nobj = Foo()\nbar_bound   = Foo().bar\nbar_class   = Foo().classbar\nbar_static  = Foo().staticbar\nbar_unbound = Foo.bar\n\n\nclass OldStyle:\n  def __init__(self, one, two, three):\n    pass\n\nclass NewStyle(object):\n  def __init__(self, one, two, three):\n    pass\n\n)\";\n    PyObject *o =\n        PyRun_String(script, Py_file_input, globals.get(), globals.get());\n    ASSERT_FALSE(o == NULL);\n    Take<PythonObject>(o);\n\n    auto bar_bound = As<PythonCallable>(globals.GetItem(\"bar_bound\"));\n    ASSERT_THAT_EXPECTED(bar_bound, llvm::Succeeded());\n    auto arginfo = bar_bound.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 1u);\n\n    auto bar_unbound = As<PythonCallable>(globals.GetItem(\"bar_unbound\"));\n    ASSERT_THAT_EXPECTED(bar_unbound, llvm::Succeeded());\n    arginfo = bar_unbound.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 2u);\n\n    auto bar_class = As<PythonCallable>(globals.GetItem(\"bar_class\"));\n    ASSERT_THAT_EXPECTED(bar_class, llvm::Succeeded());\n    arginfo = bar_class.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 1u);\n\n    auto bar_static = As<PythonCallable>(globals.GetItem(\"bar_static\"));\n    ASSERT_THAT_EXPECTED(bar_static, llvm::Succeeded());\n    arginfo = bar_static.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 1u);\n\n    auto obj = As<PythonCallable>(globals.GetItem(\"obj\"));\n    ASSERT_THAT_EXPECTED(obj, llvm::Succeeded());\n    arginfo = obj.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 1u);\n\n    auto oldstyle = As<PythonCallable>(globals.GetItem(\"OldStyle\"));\n    ASSERT_THAT_EXPECTED(oldstyle, llvm::Succeeded());\n    arginfo = oldstyle.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 3u);\n\n    auto newstyle = As<PythonCallable>(globals.GetItem(\"NewStyle\"));\n    ASSERT_THAT_EXPECTED(newstyle, llvm::Succeeded());\n    arginfo = newstyle.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 3u);\n  }\n\n#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3\n\n  // the old implementation of GetArgInfo just doesn't work on builtins.\n\n  {\n    auto builtins = PythonModule::BuiltinsModule();\n    auto hex = As<PythonCallable>(builtins.GetAttribute(\"hex\"));\n    ASSERT_THAT_EXPECTED(hex, llvm::Succeeded());\n    auto arginfo = hex.get().GetArgInfo();\n    ASSERT_THAT_EXPECTED(arginfo, llvm::Succeeded());\n    EXPECT_EQ(arginfo.get().max_positional_args, 1u);\n  }\n\n#endif\n}\n\nTEST_F(PythonDataObjectsTest, TestScript) {\n\n  static const char script[] = R\"(\ndef factorial(n):\n  if n > 1:\n    return n * factorial(n-1)\n  else:\n    return 1;\nmain = factorial\n)\";\n\n  PythonScript factorial(script);\n\n  EXPECT_THAT_EXPECTED(As<long long>(factorial(5ll)), llvm::HasValue(120));\n}\n\nTEST_F(PythonDataObjectsTest, TestExceptions) {\n\n  static const char script[] = R\"(\ndef foo():\n  return bar()\ndef bar():\n  return baz()\ndef baz():\n  return 1 / 0\nmain = foo\n)\";\n\n  PythonScript foo(script);\n\n  EXPECT_THAT_EXPECTED(\n      foo(), llvm::Failed<PythonException>(testing::Property(\n                 &PythonException::ReadBacktrace,\n                 testing::AllOf(testing::ContainsRegex(\"line 3, in foo\"),\n                                testing::ContainsRegex(\"line 5, in bar\"),\n                                testing::ContainsRegex(\"line 7, in baz\"),\n                                testing::ContainsRegex(\"ZeroDivisionError\")))));\n\n  static const char script2[] = R\"(\nclass MyError(Exception):\n  def __str__(self):\n    return self.my_message\n\ndef main():\n  raise MyError(\"lol\")\n\n)\";\n\n  PythonScript lol(script2);\n\n  EXPECT_THAT_EXPECTED(lol(),\n                       llvm::Failed<PythonException>(testing::Property(\n                           &PythonException::ReadBacktrace,\n                           testing::ContainsRegex(\"unprintable MyError\"))));\n}\n\nTEST_F(PythonDataObjectsTest, TestRun) {\n\n  PythonDictionary globals(PyInitialValue::Empty);\n\n  auto x = As<long long>(runStringOneLine(\"40 + 2\", globals, globals));\n  ASSERT_THAT_EXPECTED(x, llvm::Succeeded());\n  EXPECT_EQ(x.get(), 42l);\n\n  Expected<PythonObject> r = runStringOneLine(\"n = 42\", globals, globals);\n  ASSERT_THAT_EXPECTED(r, llvm::Succeeded());\n  auto y = As<long long>(globals.GetItem(\"n\"));\n  ASSERT_THAT_EXPECTED(y, llvm::Succeeded());\n  EXPECT_EQ(y.get(), 42l);\n\n  const char script[] = R\"(\ndef foobar():\n  return \"foo\" + \"bar\" + \"baz\"\ng = foobar()\n)\";\n\n  r = runStringMultiLine(script, globals, globals);\n  ASSERT_THAT_EXPECTED(r, llvm::Succeeded());\n  auto g = As<std::string>(globals.GetItem(\"g\"));\n  ASSERT_THAT_EXPECTED(g, llvm::HasValue(\"foobarbaz\"));\n}"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used argument matchers.  More\n// matchers can be defined by the user implementing the\n// MatcherInterface<T> interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n\n#include <math.h>\n#include <algorithm>\n#include <iterator>\n#include <limits>\n#include <ostream>  // NOLINT\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n# include <initializer_list>  // NOLINT -- must be after gtest.h\n#endif\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherImpl that implements the\n//      MatcherInterface<T> interface, and\n//   2. a factory function that creates a Matcher<T> object from a\n//      FooMatcherImpl*.\n//\n// The two-level delegation design makes it possible to allow a user\n// to write \"v\" instead of \"Eq(v)\" where a Matcher is expected, which\n// is impossible if we pass matchers by pointers.  It also eases\n// ownership management as Matcher objects can now be copied like\n// plain values.\n\n// MatchResultListener is an abstract class.  Its << operator can be\n// used by a matcher to explain why a value matches or doesn't match.\n//\n// TODO(wan@google.com): add method\n//   bool InterestedInWhy(bool result) const;\n// to indicate whether the listener is interested in why the match\n// result is 'result'.\nclass MatchResultListener {\n public:\n  // Creates a listener object with the given underlying ostream.  The\n  // listener does not own the ostream, and does not dereference it\n  // in the constructor or destructor.\n  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}\n  virtual ~MatchResultListener() = 0;  // Makes this class abstract.\n\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template <typename T>\n  MatchResultListener& operator<<(const T& x) {\n    if (stream_ != NULL)\n      *stream_ << x;\n    return *this;\n  }\n\n  // Returns the underlying ostream.\n  ::std::ostream* stream() { return stream_; }\n\n  // Returns true iff the listener is interested in an explanation of\n  // the match result.  A matcher's MatchAndExplain() method can use\n  // this information to avoid generating the explanation when no one\n  // intends to hear it.\n  bool IsInterested() const { return stream_ != NULL; }\n\n private:\n  ::std::ostream* const stream_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);\n};\n\ninline MatchResultListener::~MatchResultListener() {\n}\n\n// An instance of a subclass of this knows how to describe itself as a\n// matcher.\nclass MatcherDescriberInterface {\n public:\n  virtual ~MatcherDescriberInterface() {}\n\n  // Describes this matcher to an ostream.  The function should print\n  // a verb phrase that describes the property a value matching this\n  // matcher should have.  The subject of the verb phrase is the value\n  // being matched.  For example, the DescribeTo() method of the Gt(7)\n  // matcher prints \"is greater than 7\".\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.  For\n  // example, if the description of this matcher is \"is greater than\n  // 7\", the negated description could be \"is not greater than 7\".\n  // You are not required to override this when implementing\n  // MatcherInterface, but it is highly advised so that your matcher\n  // can produce good error messages.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"not (\";\n    DescribeTo(os);\n    *os << \")\";\n  }\n};\n\n// The implementation of a matcher.\ntemplate <typename T>\nclass MatcherInterface : public MatcherDescriberInterface {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener' if necessary (see the next paragraph), in\n  // the form of a non-restrictive relative clause (\"which ...\",\n  // \"whose ...\", etc) that describes x.  For example, the\n  // MatchAndExplain() method of the Pointee(...) matcher should\n  // generate an explanation like \"which points to ...\".\n  //\n  // Implementations of MatchAndExplain() should add an explanation of\n  // the match result *if and only if* they can provide additional\n  // information that's not already present (or not obvious) in the\n  // print-out of x and the matcher's description.  Whether the match\n  // succeeds is not a factor in deciding whether an explanation is\n  // needed, as sometimes the caller needs to print a failure message\n  // when the match succeeds (e.g. when the matcher is used inside\n  // Not()).\n  //\n  // For example, a \"has at least 10 elements\" matcher should explain\n  // what the actual element count is, regardless of the match result,\n  // as it is useful information to the reader; on the other hand, an\n  // \"is empty\" matcher probably only needs to explain what the actual\n  // size is when the match fails, as it's redundant to say that the\n  // size is 0 when the value is already known to be empty.\n  //\n  // You should override this method when defining a new matcher.\n  //\n  // It's the responsibility of the caller (Google Mock) to guarantee\n  // that 'listener' is not NULL.  This helps to simplify a matcher's\n  // implementation when it doesn't care about the performance, as it\n  // can talk to 'listener' without checking its validity first.\n  // However, in order to implement dummy listeners efficiently,\n  // listener->stream() may be NULL.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Inherits these methods from MatcherDescriberInterface:\n  //   virtual void DescribeTo(::std::ostream* os) const = 0;\n  //   virtual void DescribeNegationTo(::std::ostream* os) const;\n};\n\n// A match result listener that stores the explanation in a string.\nclass StringMatchResultListener : public MatchResultListener {\n public:\n  StringMatchResultListener() : MatchResultListener(&ss_) {}\n\n  // Returns the explanation accumulated so far.\n  internal::string str() const { return ss_.str(); }\n\n  // Clears the explanation accumulated so far.\n  void Clear() { ss_.str(\"\"); }\n\n private:\n  ::std::stringstream ss_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);\n};\n\nnamespace internal {\n\nstruct AnyEq {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a == b; }\n};\nstruct AnyNe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a != b; }\n};\nstruct AnyLt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a < b; }\n};\nstruct AnyGt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a > b; }\n};\nstruct AnyLe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a <= b; }\n};\nstruct AnyGe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a >= b; }\n};\n\n// A match result listener that ignores the explanation.\nclass DummyMatchResultListener : public MatchResultListener {\n public:\n  DummyMatchResultListener() : MatchResultListener(NULL) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);\n};\n\n// A match result listener that forwards the explanation to a given\n// ostream.  The difference between this and MatchResultListener is\n// that the former is concrete.\nclass StreamMatchResultListener : public MatchResultListener {\n public:\n  explicit StreamMatchResultListener(::std::ostream* os)\n      : MatchResultListener(os) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);\n};\n\n// An internal class for implementing Matcher<T>, which will derive\n// from it.  We put functionalities common to all Matcher<T>\n// specializations here to avoid code duplication.\ntemplate <typename T>\nclass MatcherBase {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener'.\n  bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return impl_->MatchAndExplain(x, listener);\n  }\n\n  // Returns true iff this matcher matches x.\n  bool Matches(T x) const {\n    DummyMatchResultListener dummy;\n    return MatchAndExplain(x, &dummy);\n  }\n\n  // Describes this matcher to an ostream.\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the negation of this matcher to an ostream.\n  void DescribeNegationTo(::std::ostream* os) const {\n    impl_->DescribeNegationTo(os);\n  }\n\n  // Explains why x matches, or doesn't match, the matcher.\n  void ExplainMatchResultTo(T x, ::std::ostream* os) const {\n    StreamMatchResultListener listener(os);\n    MatchAndExplain(x, &listener);\n  }\n\n  // Returns the describer for this matcher object; retains ownership\n  // of the describer, which is only guaranteed to be alive when\n  // this matcher object is alive.\n  const MatcherDescriberInterface* GetDescriber() const {\n    return impl_.get();\n  }\n\n protected:\n  MatcherBase() {}\n\n  // Constructs a matcher from its implementation.\n  explicit MatcherBase(const MatcherInterface<T>* impl)\n      : impl_(impl) {}\n\n  virtual ~MatcherBase() {}\n\n private:\n  // shared_ptr (util/gtl/shared_ptr.h) and linked_ptr have similar\n  // interfaces.  The former dynamically allocates a chunk of memory\n  // to hold the reference count, while the latter tracks all\n  // references using a circular linked list without allocating\n  // memory.  It has been observed that linked_ptr performs better in\n  // typical scenarios.  However, shared_ptr can out-perform\n  // linked_ptr when there are many more uses of the copy constructor\n  // than the default constructor.\n  //\n  // If performance becomes a problem, we should see if using\n  // shared_ptr helps.\n  ::testing::internal::linked_ptr<const MatcherInterface<T> > impl_;\n};\n\n}  // namespace internal\n\n// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)\n// object that can check whether a value of type T matches.  The\n// implementation of Matcher<T> is just a linked_ptr to const\n// MatcherInterface<T>, so copying is fairly cheap.  Don't inherit\n// from Matcher!\ntemplate <typename T>\nclass Matcher : public internal::MatcherBase<T> {\n public:\n  // Constructs a null matcher.  Needed for storing Matcher objects in STL\n  // containers.  A default-constructed matcher is not yet initialized.  You\n  // cannot use it until a valid value has been assigned to it.\n  explicit Matcher() {}  // NOLINT\n\n  // Constructs a matcher from its implementation.\n  explicit Matcher(const MatcherInterface<T>* impl)\n      : internal::MatcherBase<T>(impl) {}\n\n  // Implicit constructor here allows people to write\n  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes\n  Matcher(T value);  // NOLINT\n};\n\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a string\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const internal::string&>\n    : public internal::MatcherBase<const internal::string&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const internal::string&>* impl)\n      : internal::MatcherBase<const internal::string&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<internal::string>\n    : public internal::MatcherBase<internal::string> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<internal::string>* impl)\n      : internal::MatcherBase<internal::string>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\n#if GTEST_HAS_STRING_PIECE_\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a StringPiece\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const StringPiece&>\n    : public internal::MatcherBase<const StringPiece&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const StringPiece&>* impl)\n      : internal::MatcherBase<const StringPiece&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<StringPiece>\n    : public internal::MatcherBase<StringPiece> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<StringPiece>* impl)\n      : internal::MatcherBase<StringPiece>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n#endif  // GTEST_HAS_STRING_PIECE_\n\n// The PolymorphicMatcher class template makes it easy to implement a\n// polymorphic matcher (i.e. a matcher that can match values of more\n// than one type, e.g. Eq(n) and NotNull()).\n//\n// To define a polymorphic matcher, a user should provide an Impl\n// class that has a DescribeTo() method and a DescribeNegationTo()\n// method, and define a member function (or member function template)\n//\n//   bool MatchAndExplain(const Value& value,\n//                        MatchResultListener* listener) const;\n//\n// See the definition of NotNull() for a complete example.\ntemplate <class Impl>\nclass PolymorphicMatcher {\n public:\n  explicit PolymorphicMatcher(const Impl& an_impl) : impl_(an_impl) {}\n\n  // Returns a mutable reference to the underlying matcher\n  // implementation object.\n  Impl& mutable_impl() { return impl_; }\n\n  // Returns an immutable reference to the underlying matcher\n  // implementation object.\n  const Impl& impl() const { return impl_; }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new MonomorphicImpl<T>(impl_));\n  }\n\n private:\n  template <typename T>\n  class MonomorphicImpl : public MatcherInterface<T> {\n   public:\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      impl_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      impl_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return impl_.MatchAndExplain(x, listener);\n    }\n\n   private:\n    const Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);\n};\n\n// Creates a matcher from its implementation.  This is easier to use\n// than the Matcher<T> constructor as it doesn't require you to\n// explicitly write the template argument, e.g.\n//\n//   MakeMatcher(foo);\n// vs\n//   Matcher<const string&>(foo);\ntemplate <typename T>\ninline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {\n  return Matcher<T>(impl);\n}\n\n// Creates a polymorphic matcher from its implementation.  This is\n// easier to use than the PolymorphicMatcher<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicMatcher(foo);\n// vs\n//   PolymorphicMatcher<TypeOfFoo>(foo);\ntemplate <class Impl>\ninline PolymorphicMatcher<Impl> MakePolymorphicMatcher(const Impl& impl) {\n  return PolymorphicMatcher<Impl>(impl);\n}\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// The MatcherCastImpl class template is a helper for implementing\n// MatcherCast().  We need this helper in order to partially\n// specialize the implementation of MatcherCast() (C++ allows\n// class/struct templates to be partially specialized, but not\n// function templates.).\n\n// This general version is used when MatcherCast()'s argument is a\n// polymorphic matcher (i.e. something that can be converted to a\n// Matcher but is not one yet; for example, Eq(value)) or a value (for\n// example, \"hello\").\ntemplate <typename T, typename M>\nclass MatcherCastImpl {\n public:\n  static Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    // M can be a polymorhic matcher, in which case we want to use\n    // its conversion operator to create Matcher<T>.  Or it can be a value\n    // that should be passed to the Matcher<T>'s constructor.\n    //\n    // We can't call Matcher<T>(polymorphic_matcher_or_value) when M is a\n    // polymorphic matcher because it'll be ambiguous if T has an implicit\n    // constructor from M (this usually happens when T has an implicit\n    // constructor from any type).\n    //\n    // It won't work to unconditionally implict_cast\n    // polymorphic_matcher_or_value to Matcher<T> because it won't trigger\n    // a user-defined conversion from M to T if one exists (assuming M is\n    // a value).\n    return CastImpl(\n        polymorphic_matcher_or_value,\n        BooleanConstant<\n            internal::ImplicitlyConvertible<M, Matcher<T> >::value>());\n  }\n\n private:\n  static Matcher<T> CastImpl(const M& value, BooleanConstant<false>) {\n    // M can't be implicitly converted to Matcher<T>, so M isn't a polymorphic\n    // matcher.  It must be a value then.  Use direct initialization to create\n    // a matcher.\n    return Matcher<T>(ImplicitCast_<T>(value));\n  }\n\n  static Matcher<T> CastImpl(const M& polymorphic_matcher_or_value,\n                             BooleanConstant<true>) {\n    // M is implicitly convertible to Matcher<T>, which means that either\n    // M is a polymorhpic matcher or Matcher<T> has an implicit constructor\n    // from M.  In both cases using the implicit conversion will produce a\n    // matcher.\n    //\n    // Even if T has an implicit constructor from M, it won't be called because\n    // creating Matcher<T> would require a chain of two user-defined conversions\n    // (first to create T from M and then to create Matcher<T> from T).\n    return polymorphic_matcher_or_value;\n  }\n};\n\n// This more specialized version is used when MatcherCast()'s argument\n// is already a Matcher.  This only compiles when type T can be\n// statically converted to type U.\ntemplate <typename T, typename U>\nclass MatcherCastImpl<T, Matcher<U> > {\n public:\n  static Matcher<T> Cast(const Matcher<U>& source_matcher) {\n    return Matcher<T>(new Impl(source_matcher));\n  }\n\n private:\n  class Impl : public MatcherInterface<T> {\n   public:\n    explicit Impl(const Matcher<U>& source_matcher)\n        : source_matcher_(source_matcher) {}\n\n    // We delegate the matching logic to the source matcher.\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return source_matcher_.MatchAndExplain(static_cast<U>(x), listener);\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      source_matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      source_matcher_.DescribeNegationTo(os);\n    }\n\n   private:\n    const Matcher<U> source_matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n};\n\n// This even more specialized version is used for efficiently casting\n// a matcher to its own type.\ntemplate <typename T>\nclass MatcherCastImpl<T, Matcher<T> > {\n public:\n  static Matcher<T> Cast(const Matcher<T>& matcher) { return matcher; }\n};\n\n}  // namespace internal\n\n// In order to be safe and clear, casting between different matcher\n// types is done explicitly via MatcherCast<T>(m), which takes a\n// matcher m and returns a Matcher<T>.  It compiles only when T can be\n// statically converted to the argument type of m.\ntemplate <typename T, typename M>\ninline Matcher<T> MatcherCast(const M& matcher) {\n  return internal::MatcherCastImpl<T, M>::Cast(matcher);\n}\n\n// Implements SafeMatcherCast().\n//\n// We use an intermediate class to do the actual safe casting as Nokia's\n// Symbian compiler cannot decide between\n// template <T, M> ... (M) and\n// template <T, U> ... (const Matcher<U>&)\n// for function templates but can for member function templates.\ntemplate <typename T>\nclass SafeMatcherCastImpl {\n public:\n  // This overload handles polymorphic matchers and values only since\n  // monomorphic matchers are handled by the next one.\n  template <typename M>\n  static inline Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    return internal::MatcherCastImpl<T, M>::Cast(polymorphic_matcher_or_value);\n  }\n\n  // This overload handles monomorphic matchers.\n  //\n  // In general, if type T can be implicitly converted to type U, we can\n  // safely convert a Matcher<U> to a Matcher<T> (i.e. Matcher is\n  // contravariant): just keep a copy of the original Matcher<U>, convert the\n  // argument from type T to U, and then pass it to the underlying Matcher<U>.\n  // The only exception is when U is a reference and T is not, as the\n  // underlying Matcher<U> may be interested in the argument's address, which\n  // is not preserved in the conversion from T to U.\n  template <typename U>\n  static inline Matcher<T> Cast(const Matcher<U>& matcher) {\n    // Enforce that T can be implicitly converted to U.\n    GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible<T, U>::value),\n                          T_must_be_implicitly_convertible_to_U);\n    // Enforce that we are not converting a non-reference type T to a reference\n    // type U.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<T>::value || !internal::is_reference<U>::value,\n        cannot_convert_non_referentce_arg_to_reference);\n    // In case both T and U are arithmetic types, enforce that the\n    // conversion is not lossy.\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;\n    const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;\n    const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;\n    GTEST_COMPILE_ASSERT_(\n        kTIsOther || kUIsOther ||\n        (internal::LosslessArithmeticConvertible<RawT, RawU>::value),\n        conversion_of_arithmetic_types_must_be_lossless);\n    return MatcherCast<T>(matcher);\n  }\n};\n\ntemplate <typename T, typename M>\ninline Matcher<T> SafeMatcherCast(const M& polymorphic_matcher) {\n  return SafeMatcherCastImpl<T>::Cast(polymorphic_matcher);\n}\n\n// A<T>() returns a matcher that matches any value of type T.\ntemplate <typename T>\nMatcher<T> A();\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// If the explanation is not empty, prints it to the ostream.\ninline void PrintIfNotEmpty(const internal::string& explanation,\n                            ::std::ostream* os) {\n  if (explanation != \"\" && os != NULL) {\n    *os << \", \" << explanation;\n  }\n}\n\n// Returns true if the given type name is easy to read by a human.\n// This is used to decide whether printing the type of a value might\n// be helpful.\ninline bool IsReadableTypeName(const string& type_name) {\n  // We consider a type name readable if it's short or doesn't contain\n  // a template or function type.\n  return (type_name.length() <= 20 ||\n          type_name.find_first_of(\"<(\") == string::npos);\n}\n\n// Matches the value against the given matcher, prints the value and explains\n// the match result to the listener. Returns the match result.\n// 'listener' must not be NULL.\n// Value cannot be passed by const reference, because some matchers take a\n// non-const argument.\ntemplate <typename Value, typename T>\nbool MatchPrintAndExplain(Value& value, const Matcher<T>& matcher,\n                          MatchResultListener* listener) {\n  if (!listener->IsInterested()) {\n    // If the listener is not interested, we do not need to construct the\n    // inner explanation.\n    return matcher.Matches(value);\n  }\n\n  StringMatchResultListener inner_listener;\n  const bool match = matcher.MatchAndExplain(value, &inner_listener);\n\n  UniversalPrint(value, listener->stream());\n#if GTEST_HAS_RTTI\n  const string& type_name = GetTypeName<Value>();\n  if (IsReadableTypeName(type_name))\n    *listener->stream() << \" (of type \" << type_name << \")\";\n#endif\n  PrintIfNotEmpty(inner_listener.str(), listener->stream());\n\n  return match;\n}\n\n// An internal helper class for doing compile-time loop on a tuple's\n// fields.\ntemplate <size_t N>\nclass TuplePrefix {\n public:\n  // TuplePrefix<N>::Matches(matcher_tuple, value_tuple) returns true\n  // iff the first N fields of matcher_tuple matches the first N\n  // fields of value_tuple, respectively.\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& matcher_tuple,\n                      const ValueTuple& value_tuple) {\n    return TuplePrefix<N - 1>::Matches(matcher_tuple, value_tuple)\n        && get<N - 1>(matcher_tuple).Matches(get<N - 1>(value_tuple));\n  }\n\n  // TuplePrefix<N>::ExplainMatchFailuresTo(matchers, values, os)\n  // describes failures in matching the first N fields of matchers\n  // against the first N fields of values.  If there is no failure,\n  // nothing will be streamed to os.\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& matchers,\n                                     const ValueTuple& values,\n                                     ::std::ostream* os) {\n    // First, describes failures in the first N - 1 fields.\n    TuplePrefix<N - 1>::ExplainMatchFailuresTo(matchers, values, os);\n\n    // Then describes the failure (if any) in the (N - 1)-th (0-based)\n    // field.\n    typename tuple_element<N - 1, MatcherTuple>::type matcher =\n        get<N - 1>(matchers);\n    typedef typename tuple_element<N - 1, ValueTuple>::type Value;\n    Value value = get<N - 1>(values);\n    StringMatchResultListener listener;\n    if (!matcher.MatchAndExplain(value, &listener)) {\n      // TODO(wan): include in the message the name of the parameter\n      // as used in MOCK_METHOD*() when possible.\n      *os << \"  Expected arg #\" << N - 1 << \": \";\n      get<N - 1>(matchers).DescribeTo(os);\n      *os << \"\\n           Actual: \";\n      // We remove the reference in type Value to prevent the\n      // universal printer from printing the address of value, which\n      // isn't interesting to the user most of the time.  The\n      // matcher's MatchAndExplain() method handles the case when\n      // the address is interesting.\n      internal::UniversalPrint(value, os);\n      PrintIfNotEmpty(listener.str(), os);\n      *os << \"\\n\";\n    }\n  }\n};\n\n// The base case.\ntemplate <>\nclass TuplePrefix<0> {\n public:\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& /* matcher_tuple */,\n                      const ValueTuple& /* value_tuple */) {\n    return true;\n  }\n\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& /* matchers */,\n                                     const ValueTuple& /* values */,\n                                     ::std::ostream* /* os */) {}\n};\n\n// TupleMatches(matcher_tuple, value_tuple) returns true iff all\n// matchers in matcher_tuple match the corresponding fields in\n// value_tuple.  It is a compiler error if matcher_tuple and\n// value_tuple have different number of fields or incompatible field\n// types.\ntemplate <typename MatcherTuple, typename ValueTuple>\nbool TupleMatches(const MatcherTuple& matcher_tuple,\n                  const ValueTuple& value_tuple) {\n  // Makes sure that matcher_tuple and value_tuple have the same\n  // number of fields.\n  GTEST_COMPILE_ASSERT_(tuple_size<MatcherTuple>::value ==\n                        tuple_size<ValueTuple>::value,\n                        matcher_and_value_have_different_numbers_of_fields);\n  return TuplePrefix<tuple_size<ValueTuple>::value>::\n      Matches(matcher_tuple, value_tuple);\n}\n\n// Describes failures in matching matchers against values.  If there\n// is no failure, nothing will be streamed to os.\ntemplate <typename MatcherTuple, typename ValueTuple>\nvoid ExplainMatchFailureTupleTo(const MatcherTuple& matchers,\n                                const ValueTuple& values,\n                                ::std::ostream* os) {\n  TuplePrefix<tuple_size<MatcherTuple>::value>::ExplainMatchFailuresTo(\n      matchers, values, os);\n}\n\n// TransformTupleValues and its helper.\n//\n// TransformTupleValuesHelper hides the internal machinery that\n// TransformTupleValues uses to implement a tuple traversal.\ntemplate <typename Tuple, typename Func, typename OutIter>\nclass TransformTupleValuesHelper {\n private:\n  typedef ::testing::tuple_size<Tuple> TupleSize;\n\n public:\n  // For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.\n  // Returns the final value of 'out' in case the caller needs it.\n  static OutIter Run(Func f, const Tuple& t, OutIter out) {\n    return IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);\n  }\n\n private:\n  template <typename Tup, size_t kRemainingSize>\n  struct IterateOverTuple {\n    OutIter operator() (Func f, const Tup& t, OutIter out) const {\n      *out++ = f(::testing::get<TupleSize::value - kRemainingSize>(t));\n      return IterateOverTuple<Tup, kRemainingSize - 1>()(f, t, out);\n    }\n  };\n  template <typename Tup>\n  struct IterateOverTuple<Tup, 0> {\n    OutIter operator() (Func /* f */, const Tup& /* t */, OutIter out) const {\n      return out;\n    }\n  };\n};\n\n// Successively invokes 'f(element)' on each element of the tuple 't',\n// appending each result to the 'out' iterator. Returns the final value\n// of 'out'.\ntemplate <typename Tuple, typename Func, typename OutIter>\nOutIter TransformTupleValues(Func f, const Tuple& t, OutIter out) {\n  return TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(f, t, out);\n}\n\n// Implements A<T>().\ntemplate <typename T>\nclass AnyMatcherImpl : public MatcherInterface<T> {\n public:\n  virtual bool MatchAndExplain(\n      T /* x */, MatchResultListener* /* listener */) const { return true; }\n  virtual void DescribeTo(::std::ostream* os) const { *os << \"is anything\"; }\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    // This is mostly for completeness' safe, as it's not very useful\n    // to write Not(A<bool>()).  However we cannot completely rule out\n    // such a possibility, and it doesn't hurt to be prepared.\n    *os << \"never matches\";\n  }\n};\n\n// Implements _, a matcher that matches any value of any\n// type.  This is a polymorphic matcher, so we need a template type\n// conversion operator to make it appearing as a Matcher<T> for any\n// type T.\nclass AnythingMatcher {\n public:\n  template <typename T>\n  operator Matcher<T>() const { return A<T>(); }\n};\n\n// Implements a matcher that compares a given value with a\n// pre-supplied value using one of the ==, <=, <, etc, operators.  The\n// two values being compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq(5) can be\n// used to match an int, a short, a double, etc).  Therefore we use\n// a template type conversion operator in the implementation.\n//\n// The following template definition assumes that the Rhs parameter is\n// a \"bare\" type (i.e. neither 'const T' nor 'T&').\ntemplate <typename D, typename Rhs, typename Op>\nclass ComparisonBase {\n public:\n  explicit ComparisonBase(const Rhs& rhs) : rhs_(rhs) {}\n  template <typename Lhs>\n  operator Matcher<Lhs>() const {\n    return MakeMatcher(new Impl<Lhs>(rhs_));\n  }\n\n private:\n  template <typename Lhs>\n  class Impl : public MatcherInterface<Lhs> {\n   public:\n    explicit Impl(const Rhs& rhs) : rhs_(rhs) {}\n    virtual bool MatchAndExplain(\n        Lhs lhs, MatchResultListener* /* listener */) const {\n      return Op()(lhs, rhs_);\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << D::Desc() << \" \";\n      UniversalPrint(rhs_, os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << D::NegatedDesc() <<  \" \";\n      UniversalPrint(rhs_, os);\n    }\n   private:\n    Rhs rhs_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n  Rhs rhs_;\n  GTEST_DISALLOW_ASSIGN_(ComparisonBase);\n};\n\ntemplate <typename Rhs>\nclass EqMatcher : public ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq> {\n public:\n  explicit EqMatcher(const Rhs& rhs)\n      : ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq>(rhs) { }\n  static const char* Desc() { return \"is equal to\"; }\n  static const char* NegatedDesc() { return \"isn't equal to\"; }\n};\ntemplate <typename Rhs>\nclass NeMatcher : public ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe> {\n public:\n  explicit NeMatcher(const Rhs& rhs)\n      : ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe>(rhs) { }\n  static const char* Desc() { return \"isn't equal to\"; }\n  static const char* NegatedDesc() { return \"is equal to\"; }\n};\ntemplate <typename Rhs>\nclass LtMatcher : public ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt> {\n public:\n  explicit LtMatcher(const Rhs& rhs)\n      : ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt>(rhs) { }\n  static const char* Desc() { return \"is <\"; }\n  static const char* NegatedDesc() { return \"isn't <\"; }\n};\ntemplate <typename Rhs>\nclass GtMatcher : public ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt> {\n public:\n  explicit GtMatcher(const Rhs& rhs)\n      : ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt>(rhs) { }\n  static const char* Desc() { return \"is >\"; }\n  static const char* NegatedDesc() { return \"isn't >\"; }\n};\ntemplate <typename Rhs>\nclass LeMatcher : public ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe> {\n public:\n  explicit LeMatcher(const Rhs& rhs)\n      : ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe>(rhs) { }\n  static const char* Desc() { return \"is <=\"; }\n  static const char* NegatedDesc() { return \"isn't <=\"; }\n};\ntemplate <typename Rhs>\nclass GeMatcher : public ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe> {\n public:\n  explicit GeMatcher(const Rhs& rhs)\n      : ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe>(rhs) { }\n  static const char* Desc() { return \"is >=\"; }\n  static const char* NegatedDesc() { return \"isn't >=\"; }\n};\n\n// Implements the polymorphic IsNull() matcher, which matches any raw or smart\n// pointer that is NULL.\nclass IsNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p == nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) == NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"is NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"isn't NULL\";\n  }\n};\n\n// Implements the polymorphic NotNull() matcher, which matches any raw or smart\n// pointer that is not NULL.\nclass NotNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p != nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) != NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"isn't NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is NULL\";\n  }\n};\n\n// Ref(variable) matches any argument that is a reference to\n// 'variable'.  This matcher is polymorphic as it can match any\n// super type of the type of 'variable'.\n//\n// The RefMatcher template class implements Ref(variable).  It can\n// only be instantiated with a reference type.  This prevents a user\n// from mistakenly using Ref(x) to match a non-reference function\n// argument.  For example, the following will righteously cause a\n// compiler error:\n//\n//   int n;\n//   Matcher<int> m1 = Ref(n);   // This won't compile.\n//   Matcher<int&> m2 = Ref(n);  // This will compile.\ntemplate <typename T>\nclass RefMatcher;\n\ntemplate <typename T>\nclass RefMatcher<T&> {\n  // Google Mock is a generic framework and thus needs to support\n  // mocking any function types, including those that take non-const\n  // reference arguments.  Therefore the template parameter T (and\n  // Super below) can be instantiated to either a const type or a\n  // non-const type.\n public:\n  // RefMatcher() takes a T& instead of const T&, as we want the\n  // compiler to catch using Ref(const_value) as a matcher for a\n  // non-const reference.\n  explicit RefMatcher(T& x) : object_(x) {}  // NOLINT\n\n  template <typename Super>\n  operator Matcher<Super&>() const {\n    // By passing object_ (type T&) to Impl(), which expects a Super&,\n    // we make sure that Super is a super type of T.  In particular,\n    // this catches using Ref(const_value) as a matcher for a\n    // non-const reference, as you cannot implicitly convert a const\n    // reference to a non-const reference.\n    return MakeMatcher(new Impl<Super>(object_));\n  }\n\n private:\n  template <typename Super>\n  class Impl : public MatcherInterface<Super&> {\n   public:\n    explicit Impl(Super& x) : object_(x) {}  // NOLINT\n\n    // MatchAndExplain() takes a Super& (as opposed to const Super&)\n    // in order to match the interface MatcherInterface<Super&>.\n    virtual bool MatchAndExplain(\n        Super& x, MatchResultListener* listener) const {\n      *listener << \"which is located @\" << static_cast<const void*>(&x);\n      return &x == &object_;\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"references the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not reference the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n   private:\n    const Super& object_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& object_;\n\n  GTEST_DISALLOW_ASSIGN_(RefMatcher);\n};\n\n// Polymorphic helper functions for narrow and wide string matchers.\ninline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  return String::CaseInsensitiveCStringEquals(lhs, rhs);\n}\n\ninline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,\n                                         const wchar_t* rhs) {\n  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);\n}\n\n// String comparison for narrow or wide strings that can have embedded NUL\n// characters.\ntemplate <typename StringType>\nbool CaseInsensitiveStringEquals(const StringType& s1,\n                                 const StringType& s2) {\n  // Are the heads equal?\n  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {\n    return false;\n  }\n\n  // Skip the equal heads.\n  const typename StringType::value_type nul = 0;\n  const size_t i1 = s1.find(nul), i2 = s2.find(nul);\n\n  // Are we at the end of either s1 or s2?\n  if (i1 == StringType::npos || i2 == StringType::npos) {\n    return i1 == i2;\n  }\n\n  // Are the tails equal?\n  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));\n}\n\n// String matchers.\n\n// Implements equality-based string matchers like StrEq, StrCaseNe, and etc.\ntemplate <typename StringType>\nclass StrEqualityMatcher {\n public:\n  StrEqualityMatcher(const StringType& str, bool expect_eq,\n                     bool case_sensitive)\n      : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    if (s == NULL) {\n      return !expect_eq_;\n    }\n    return MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    const bool eq = case_sensitive_ ? s2 == string_ :\n        CaseInsensitiveStringEquals(s2, string_);\n    return expect_eq_ == eq;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    DescribeToHelper(expect_eq_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    DescribeToHelper(!expect_eq_, os);\n  }\n\n private:\n  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {\n    *os << (expect_eq ? \"is \" : \"isn't \");\n    *os << \"equal to \";\n    if (!case_sensitive_) {\n      *os << \"(ignoring case) \";\n    }\n    UniversalPrint(string_, os);\n  }\n\n  const StringType string_;\n  const bool expect_eq_;\n  const bool case_sensitive_;\n\n  GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);\n};\n\n// Implements the polymorphic HasSubstr(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass HasSubstrMatcher {\n public:\n  explicit HasSubstrMatcher(const StringType& substring)\n      : substring_(substring) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.find(substring_) != StringType::npos;\n  }\n\n  // Describes what this matcher matches.\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"has substring \";\n    UniversalPrint(substring_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has no substring \";\n    UniversalPrint(substring_, os);\n  }\n\n private:\n  const StringType substring_;\n\n  GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);\n};\n\n// Implements the polymorphic StartsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass StartsWithMatcher {\n public:\n  explicit StartsWithMatcher(const StringType& prefix) : prefix_(prefix) {\n  }\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= prefix_.length() &&\n        s2.substr(0, prefix_.length()) == prefix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"starts with \";\n    UniversalPrint(prefix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't start with \";\n    UniversalPrint(prefix_, os);\n  }\n\n private:\n  const StringType prefix_;\n\n  GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);\n};\n\n// Implements the polymorphic EndsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass EndsWithMatcher {\n public:\n  explicit EndsWithMatcher(const StringType& suffix) : suffix_(suffix) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= suffix_.length() &&\n        s2.substr(s2.length() - suffix_.length()) == suffix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"ends with \";\n    UniversalPrint(suffix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't end with \";\n    UniversalPrint(suffix_, os);\n  }\n\n private:\n  const StringType suffix_;\n\n  GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);\n};\n\n// Implements polymorphic matchers MatchesRegex(regex) and\n// ContainsRegex(regex), which can be used as a Matcher<T> as long as\n// T can be converted to a string.\nclass MatchesRegexMatcher {\n public:\n  MatchesRegexMatcher(const RE* regex, bool full_match)\n      : regex_(regex), full_match_(full_match) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(internal::string(s), listener);\n  }\n\n  // Matches anything that can convert to internal::string.\n  //\n  // This is a template, not just a plain function with const internal::string&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <class MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const internal::string& s2(s);\n    return full_match_ ? RE::FullMatch(s2, *regex_) :\n        RE::PartialMatch(s2, *regex_);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << (full_match_ ? \"matches\" : \"contains\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't \" << (full_match_ ? \"match\" : \"contain\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n private:\n  const internal::linked_ptr<const RE> regex_;\n  const bool full_match_;\n\n  GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);\n};\n\n// Implements a matcher that compares the two fields of a 2-tuple\n// using one of the ==, <=, <, etc, operators.  The two fields being\n// compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq() can be\n// used to match a tuple<int, short>, a tuple<const long&, double>,\n// etc).  Therefore we use a template type conversion operator in the\n// implementation.\ntemplate <typename D, typename Op>\nclass PairMatchBase {\n public:\n  template <typename T1, typename T2>\n  operator Matcher< ::testing::tuple<T1, T2> >() const {\n    return MakeMatcher(new Impl< ::testing::tuple<T1, T2> >);\n  }\n  template <typename T1, typename T2>\n  operator Matcher<const ::testing::tuple<T1, T2>&>() const {\n    return MakeMatcher(new Impl<const ::testing::tuple<T1, T2>&>);\n  }\n\n private:\n  static ::std::ostream& GetDesc(::std::ostream& os) {  // NOLINT\n    return os << D::Desc();\n  }\n\n  template <typename Tuple>\n  class Impl : public MatcherInterface<Tuple> {\n   public:\n    virtual bool MatchAndExplain(\n        Tuple args,\n        MatchResultListener* /* listener */) const {\n      return Op()(::testing::get<0>(args), ::testing::get<1>(args));\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"are \" << GetDesc;\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"aren't \" << GetDesc;\n    }\n  };\n};\n\nclass Eq2Matcher : public PairMatchBase<Eq2Matcher, AnyEq> {\n public:\n  static const char* Desc() { return \"an equal pair\"; }\n};\nclass Ne2Matcher : public PairMatchBase<Ne2Matcher, AnyNe> {\n public:\n  static const char* Desc() { return \"an unequal pair\"; }\n};\nclass Lt2Matcher : public PairMatchBase<Lt2Matcher, AnyLt> {\n public:\n  static const char* Desc() { return \"a pair where the first < the second\"; }\n};\nclass Gt2Matcher : public PairMatchBase<Gt2Matcher, AnyGt> {\n public:\n  static const char* Desc() { return \"a pair where the first > the second\"; }\n};\nclass Le2Matcher : public PairMatchBase<Le2Matcher, AnyLe> {\n public:\n  static const char* Desc() { return \"a pair where the first <= the second\"; }\n};\nclass Ge2Matcher : public PairMatchBase<Ge2Matcher, AnyGe> {\n public:\n  static const char* Desc() { return \"a pair where the first >= the second\"; }\n};\n\n// Implements the Not(...) matcher for a particular argument type T.\n// We do not nest it inside the NotMatcher class template, as that\n// will prevent different instantiations of NotMatcher from sharing\n// the same NotMatcherImpl<T> class.\ntemplate <typename T>\nclass NotMatcherImpl : public MatcherInterface<T> {\n public:\n  explicit NotMatcherImpl(const Matcher<T>& matcher)\n      : matcher_(matcher) {}\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return !matcher_.MatchAndExplain(x, listener);\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    matcher_.DescribeNegationTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<T> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);\n};\n\n// Implements the Not(m) matcher, which matches a value that doesn't\n// match matcher m.\ntemplate <typename InnerMatcher>\nclass NotMatcher {\n public:\n  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}\n\n  // This template type conversion operator allows Not(m) to be used\n  // to match any type m can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new NotMatcherImpl<T>(SafeMatcherCast<T>(matcher_)));\n  }\n\n private:\n  InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcher);\n};\n\n// Implements the AllOf(m1, m2) matcher for a particular argument type\n// T. We do not nest it inside the BothOfMatcher class template, as\n// that will prevent different instantiations of BothOfMatcher from\n// sharing the same BothOfMatcherImpl<T> class.\ntemplate <typename T>\nclass BothOfMatcherImpl : public MatcherInterface<T> {\n public:\n  BothOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ doesn't match x, we only need\n    // to explain why one of them fails.\n    StringMatchResultListener listener1;\n    if (!matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return false;\n    }\n\n    StringMatchResultListener listener2;\n    if (!matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return false;\n    }\n\n    // Otherwise we need to explain why *both* of them match.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return true;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// MatcherList provides mechanisms for storing a variable number of matchers in\n// a list structure (ListType) and creating a combining matcher from such a\n// list.\n// The template is defined recursively using the following template paramters:\n//   * kSize is the length of the MatcherList.\n//   * Head is the type of the first matcher of the list.\n//   * Tail denotes the types of the remaining matchers of the list.\ntemplate <int kSize, typename Head, typename... Tail>\nstruct MatcherList {\n  typedef MatcherList<kSize - 1, Tail...> MatcherListTail;\n  typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;\n\n  // BuildList stores variadic type values in a nested pair structure.\n  // Example:\n  // MatcherList<3, int, string, float>::BuildList(5, \"foo\", 2.0) will return\n  // the corresponding result of type pair<int, pair<string, float>>.\n  static ListType BuildList(const Head& matcher, const Tail&... tail) {\n    return ListType(matcher, MatcherListTail::BuildList(tail...));\n  }\n\n  // CreateMatcher<T> creates a Matcher<T> from a given list of matchers (built\n  // by BuildList()). CombiningMatcher<T> is used to combine the matchers of the\n  // list. CombiningMatcher<T> must implement MatcherInterface<T> and have a\n  // constructor taking two Matcher<T>s as input.\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        MatcherListTail::template CreateMatcher<T, CombiningMatcher>(\n            matchers.second)));\n  }\n};\n\n// The following defines the base case for the recursive definition of\n// MatcherList.\ntemplate <typename Matcher1, typename Matcher2>\nstruct MatcherList<2, Matcher1, Matcher2> {\n  typedef ::std::pair<Matcher1, Matcher2> ListType;\n\n  static ListType BuildList(const Matcher1& matcher1,\n                            const Matcher2& matcher2) {\n    return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);\n  }\n\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        SafeMatcherCast<T>(matchers.second)));\n  }\n};\n\n// VariadicMatcher is used for the variadic implementation of\n// AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).\n// CombiningMatcher<T> is used to recursively combine the provided matchers\n// (of type Args...).\ntemplate <template <typename T> class CombiningMatcher, typename... Args>\nclass VariadicMatcher {\n public:\n  VariadicMatcher(const Args&... matchers)  // NOLINT\n      : matchers_(MatcherListType::BuildList(matchers...)) {}\n\n  // This template type conversion operator allows an\n  // VariadicMatcher<Matcher1, Matcher2...> object to match any type that\n  // all of the provided matchers (Matcher1, Matcher2, ...) can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return MatcherListType::template CreateMatcher<T, CombiningMatcher>(\n        matchers_);\n  }\n\n private:\n  typedef MatcherList<sizeof...(Args), Args...> MatcherListType;\n\n  const typename MatcherListType::ListType matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(VariadicMatcher);\n};\n\ntemplate <typename... Args>\nusing AllOfMatcher = VariadicMatcher<BothOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AllOf(m_1, ..., m_n) matcher, which\n// matches a value that matches all of the matchers m_1, ..., and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass BothOfMatcher {\n public:\n  BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // BothOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new BothOfMatcherImpl<T>(SafeMatcherCast<T>(matcher1_),\n                                               SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcher);\n};\n\n// Implements the AnyOf(m1, m2) matcher for a particular argument type\n// T.  We do not nest it inside the AnyOfMatcher class template, as\n// that will prevent different instantiations of AnyOfMatcher from\n// sharing the same EitherOfMatcherImpl<T> class.\ntemplate <typename T>\nclass EitherOfMatcherImpl : public MatcherInterface<T> {\n public:\n  EitherOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ matches x, we just need to\n    // explain why *one* of them matches.\n    StringMatchResultListener listener1;\n    if (matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return true;\n    }\n\n    StringMatchResultListener listener2;\n    if (matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return true;\n    }\n\n    // Otherwise we need to explain why *both* of them fail.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return false;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).\ntemplate <typename... Args>\nusing AnyOfMatcher = VariadicMatcher<EitherOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AnyOf(m_1, ..., m_n) matcher, which\n// matches a value that matches at least one of the matchers m_1, ...,\n// and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass EitherOfMatcher {\n public:\n  EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // EitherOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new EitherOfMatcherImpl<T>(\n        SafeMatcherCast<T>(matcher1_), SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcher);\n};\n\n// Used for implementing Truly(pred), which turns a predicate into a\n// matcher.\ntemplate <typename Predicate>\nclass TrulyMatcher {\n public:\n  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}\n\n  // This method template allows Truly(pred) to be used as a matcher\n  // for type T where T is the argument type of predicate 'pred'.  The\n  // argument is passed by reference as the predicate may be\n  // interested in the address of the argument.\n  template <typename T>\n  bool MatchAndExplain(T& x,  // NOLINT\n                       MatchResultListener* /* listener */) const {\n    // Without the if-statement, MSVC sometimes warns about converting\n    // a value to bool (warning 4800).\n    //\n    // We cannot write 'return !!predicate_(x);' as that doesn't work\n    // when predicate_(x) returns a class convertible to bool but\n    // having no operator!().\n    if (predicate_(x))\n      return true;\n    return false;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"satisfies the given predicate\";\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't satisfy the given predicate\";\n  }\n\n private:\n  Predicate predicate_;\n\n  GTEST_DISALLOW_ASSIGN_(TrulyMatcher);\n};\n\n// Used for implementing Matches(matcher), which turns a matcher into\n// a predicate.\ntemplate <typename M>\nclass MatcherAsPredicate {\n public:\n  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}\n\n  // This template operator() allows Matches(m) to be used as a\n  // predicate on type T where m is a matcher on type T.\n  //\n  // The argument x is passed by reference instead of by value, as\n  // some matcher may be interested in its address (e.g. as in\n  // Matches(Ref(n))(x)).\n  template <typename T>\n  bool operator()(const T& x) const {\n    // We let matcher_ commit to a particular type here instead of\n    // when the MatcherAsPredicate object was constructed.  This\n    // allows us to write Matches(m) where m is a polymorphic matcher\n    // (e.g. Eq(5)).\n    //\n    // If we write Matcher<T>(matcher_).Matches(x) here, it won't\n    // compile when matcher_ has type Matcher<const T&>; if we write\n    // Matcher<const T&>(matcher_).Matches(x) here, it won't compile\n    // when matcher_ has type Matcher<T>; if we just write\n    // matcher_.Matches(x), it won't compile when matcher_ is\n    // polymorphic, e.g. Eq(5).\n    //\n    // MatcherCast<const T&>() is necessary for making the code work\n    // in all of the above situations.\n    return MatcherCast<const T&>(matcher_).Matches(x);\n  }\n\n private:\n  M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);\n};\n\n// For implementing ASSERT_THAT() and EXPECT_THAT().  The template\n// argument M must be a type that can be converted to a matcher.\ntemplate <typename M>\nclass PredicateFormatterFromMatcher {\n public:\n  explicit PredicateFormatterFromMatcher(M m) : matcher_(internal::move(m)) {}\n\n  // This template () operator allows a PredicateFormatterFromMatcher\n  // object to act as a predicate-formatter suitable for using with\n  // Google Test's EXPECT_PRED_FORMAT1() macro.\n  template <typename T>\n  AssertionResult operator()(const char* value_text, const T& x) const {\n    // We convert matcher_ to a Matcher<const T&> *now* instead of\n    // when the PredicateFormatterFromMatcher object was constructed,\n    // as matcher_ may be polymorphic (e.g. NotNull()) and we won't\n    // know which type to instantiate it to until we actually see the\n    // type of x here.\n    //\n    // We write SafeMatcherCast<const T&>(matcher_) instead of\n    // Matcher<const T&>(matcher_), as the latter won't compile when\n    // matcher_ has type Matcher<T> (e.g. An<int>()).\n    // We don't write MatcherCast<const T&> either, as that allows\n    // potentially unsafe downcasting of the matcher argument.\n    const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);\n    StringMatchResultListener listener;\n    if (MatchPrintAndExplain(x, matcher, &listener))\n      return AssertionSuccess();\n\n    ::std::stringstream ss;\n    ss << \"Value of: \" << value_text << \"\\n\"\n       << \"Expected: \";\n    matcher.DescribeTo(&ss);\n    ss << \"\\n  Actual: \" << listener.str();\n    return AssertionFailure() << ss.str();\n  }\n\n private:\n  const M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);\n};\n\n// A helper function for converting a matcher to a predicate-formatter\n// without the user needing to explicitly write the type.  This is\n// used for implementing ASSERT_THAT() and EXPECT_THAT().\n// Implementation detail: 'matcher' is received by-value to force decaying.\ntemplate <typename M>\ninline PredicateFormatterFromMatcher<M>\nMakePredicateFormatterFromMatcher(M matcher) {\n  return PredicateFormatterFromMatcher<M>(internal::move(matcher));\n}\n\n// Implements the polymorphic floating point equality matcher, which matches\n// two float values using ULP-based approximation or, optionally, a\n// user-specified epsilon.  The template is meant to be instantiated with\n// FloatType being either float or double.\ntemplate <typename FloatType>\nclass FloatingEqMatcher {\n public:\n  // Constructor for FloatingEqMatcher.\n  // The matcher's input will be compared with expected.  The matcher treats two\n  // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,\n  // equality comparisons between NANs will always return false.  We specify a\n  // negative max_abs_error_ term to indicate that ULP-based approximation will\n  // be used for comparison.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :\n    expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {\n  }\n\n  // Constructor that supports a user-specified max_abs_error that will be used\n  // for comparison instead of ULP-based approximation.  The max absolute\n  // should be non-negative.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,\n                    FloatType max_abs_error)\n      : expected_(expected),\n        nan_eq_nan_(nan_eq_nan),\n        max_abs_error_(max_abs_error) {\n    GTEST_CHECK_(max_abs_error >= 0)\n        << \", where max_abs_error is\" << max_abs_error;\n  }\n\n  // Implements floating point equality matcher as a Matcher<T>.\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)\n        : expected_(expected),\n          nan_eq_nan_(nan_eq_nan),\n          max_abs_error_(max_abs_error) {}\n\n    virtual bool MatchAndExplain(T value,\n                                 MatchResultListener* listener) const {\n      const FloatingPoint<FloatType> actual(value), expected(expected_);\n\n      // Compares NaNs first, if nan_eq_nan_ is true.\n      if (actual.is_nan() || expected.is_nan()) {\n        if (actual.is_nan() && expected.is_nan()) {\n          return nan_eq_nan_;\n        }\n        // One is nan; the other is not nan.\n        return false;\n      }\n      if (HasMaxAbsError()) {\n        // We perform an equality check so that inf will match inf, regardless\n        // of error bounds.  If the result of value - expected_ would result in\n        // overflow or if either value is inf, the default result is infinity,\n        // which should only match if max_abs_error_ is also infinity.\n        if (value == expected_) {\n          return true;\n        }\n\n        const FloatType diff = value - expected_;\n        if (fabs(diff) <= max_abs_error_) {\n          return true;\n        }\n\n        if (listener->IsInterested()) {\n          *listener << \"which is \" << diff << \" from \" << expected_;\n        }\n        return false;\n      } else {\n        return actual.AlmostEquals(expected);\n      }\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      // os->precision() returns the previously set precision, which we\n      // store to restore the ostream to its original configuration\n      // after outputting.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"is NaN\";\n        } else {\n          *os << \"never matches\";\n        }\n      } else {\n        *os << \"is approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error <= \" << max_abs_error_ << \")\";\n        }\n      }\n      os->precision(old_precision);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      // As before, get original precision.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"isn't NaN\";\n        } else {\n          *os << \"is anything\";\n        }\n      } else {\n        *os << \"isn't approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error > \" << max_abs_error_ << \")\";\n        }\n      }\n      // Restore original precision.\n      os->precision(old_precision);\n    }\n\n   private:\n    bool HasMaxAbsError() const {\n      return max_abs_error_ >= 0;\n    }\n\n    const FloatType expected_;\n    const bool nan_eq_nan_;\n    // max_abs_error will be used for value comparison when >= 0.\n    const FloatType max_abs_error_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  // The following 3 type conversion operators allow FloatEq(expected) and\n  // NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a\n  // Matcher<const float&>, or a Matcher<float&>, but nothing else.\n  // (While Google's C++ coding style doesn't allow arguments passed\n  // by non-const reference, we may see them in code not conforming to\n  // the style.  Therefore Google Mock needs to support them.)\n  operator Matcher<FloatType>() const {\n    return MakeMatcher(\n        new Impl<FloatType>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<const FloatType&>() const {\n    return MakeMatcher(\n        new Impl<const FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<FloatType&>() const {\n    return MakeMatcher(\n        new Impl<FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n private:\n  const FloatType expected_;\n  const bool nan_eq_nan_;\n  // max_abs_error will be used for value comparison when >= 0.\n  const FloatType max_abs_error_;\n\n  GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);\n};\n\n// Implements the Pointee(m) matcher for matching a pointer whose\n// pointee matches matcher m.  The pointer can be either raw or smart.\ntemplate <typename InnerMatcher>\nclass PointeeMatcher {\n public:\n  explicit PointeeMatcher(const InnerMatcher& matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Pointee(m) to be\n  // used as a matcher for any pointer type whose pointee type is\n  // compatible with the inner matcher, where type Pointer can be\n  // either a raw pointer or a smart pointer.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Pointee().\n  template <typename Pointer>\n  operator Matcher<Pointer>() const {\n    return MakeMatcher(new Impl<Pointer>(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular pointer type.\n  template <typename Pointer>\n  class Impl : public MatcherInterface<Pointer> {\n   public:\n    typedef typename PointeeOf<GTEST_REMOVE_CONST_(  // NOLINT\n        GTEST_REMOVE_REFERENCE_(Pointer))>::type Pointee;\n\n    explicit Impl(const InnerMatcher& matcher)\n        : matcher_(MatcherCast<const Pointee&>(matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"points to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not point to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(Pointer pointer,\n                                 MatchResultListener* listener) const {\n      if (GetRawPointer(pointer) == NULL)\n        return false;\n\n      *listener << \"which points to \";\n      return MatchPrintAndExplain(*pointer, matcher_, listener);\n    }\n\n   private:\n    const Matcher<const Pointee&> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PointeeMatcher);\n};\n\n// Implements the WhenDynamicCastTo<T>(m) matcher that matches a pointer or\n// reference that matches inner_matcher when dynamic_cast<T> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\nclass WhenDynamicCastToMatcherBase {\n public:\n  explicit WhenDynamicCastToMatcherBase(const Matcher<To>& matcher)\n      : matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeNegationTo(os);\n  }\n\n protected:\n  const Matcher<To> matcher_;\n\n  static string GetToName() {\n#if GTEST_HAS_RTTI\n    return GetTypeName<To>();\n#else  // GTEST_HAS_RTTI\n    return \"the target type\";\n#endif  // GTEST_HAS_RTTI\n  }\n\n private:\n  static void GetCastTypeDescription(::std::ostream* os) {\n    *os << \"when dynamic_cast to \" << GetToName() << \", \";\n  }\n\n  GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);\n};\n\n// Primary template.\n// To is a pointer. Cast and forward the result.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase<To> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To>& matcher)\n      : WhenDynamicCastToMatcherBase<To>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From from, MatchResultListener* listener) const {\n    // TODO(sbenza): Add more detail on failures. ie did the dyn_cast fail?\n    To to = dynamic_cast<To>(from);\n    return MatchPrintAndExplain(to, this->matcher_, listener);\n  }\n};\n\n// Specialize for references.\n// In this case we return false if the dynamic_cast fails.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher<To&> : public WhenDynamicCastToMatcherBase<To&> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To&>& matcher)\n      : WhenDynamicCastToMatcherBase<To&>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From& from, MatchResultListener* listener) const {\n    // We don't want an std::bad_cast here, so do the cast with pointers.\n    To* to = dynamic_cast<To*>(&from);\n    if (to == NULL) {\n      *listener << \"which cannot be dynamic_cast to \" << this->GetToName();\n      return false;\n    }\n    return MatchPrintAndExplain(*to, this->matcher_, listener);\n  }\n};\n\n// Implements the Field() matcher for matching a field (i.e. member\n// variable) of an object.\ntemplate <typename Class, typename FieldType>\nclass FieldMatcher {\n public:\n  FieldMatcher(FieldType Class::*field,\n               const Matcher<const FieldType&>& matcher)\n      : field_(field), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T& value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Field() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given field is \";\n    return MatchPrintAndExplain(obj.*field_, matcher_, listener);\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a field, it must be a class/struct/union type and\n    // thus cannot be a pointer.  Therefore we pass false_type() as\n    // the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  const FieldType Class::*field_;\n  const Matcher<const FieldType&> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(FieldMatcher);\n};\n\n// Implements the Property() matcher for matching a property\n// (i.e. return value of a getter method) of an object.\ntemplate <typename Class, typename PropertyType>\nclass PropertyMatcher {\n public:\n  // The property may have a reference type, so 'const PropertyType&'\n  // may cause double references and fail to compile.  That's why we\n  // need GTEST_REFERENCE_TO_CONST, which works regardless of\n  // PropertyType being a reference or not.\n  typedef GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty;\n\n  PropertyMatcher(PropertyType (Class::*property)() const,\n                  const Matcher<RefToConstProperty>& matcher)\n      : property_(property), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T&value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Property() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given property is \";\n    // Cannot pass the return value (for example, int) to MatchPrintAndExplain,\n    // which takes a non-const reference as argument.\n#if defined(_PREFAST_ ) && _MSC_VER == 1800\n    // Workaround bug in VC++ 2013's /analyze parser.\n    // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move\n    posix::Abort();  // To make sure it is never run.\n    return false;\n#else\n    RefToConstProperty result = (obj.*property_)();\n    return MatchPrintAndExplain(result, matcher_, listener);\n#endif\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a property method, it must be a class/struct/union\n    // type and thus cannot be a pointer.  Therefore we pass\n    // false_type() as the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  PropertyType (Class::*property_)() const;\n  const Matcher<RefToConstProperty> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PropertyMatcher);\n};\n\n// Type traits specifying various features of different functors for ResultOf.\n// The default template specifies features for functor objects.\n// Functor classes have to typedef argument_type and result_type\n// to be compatible with ResultOf.\ntemplate <typename Functor>\nstruct CallableTraits {\n  typedef typename Functor::result_type ResultType;\n  typedef Functor StorageType;\n\n  static void CheckIsValid(Functor /* functor */) {}\n  template <typename T>\n  static ResultType Invoke(Functor f, T arg) { return f(arg); }\n};\n\n// Specialization for function pointers.\ntemplate <typename ArgType, typename ResType>\nstruct CallableTraits<ResType(*)(ArgType)> {\n  typedef ResType ResultType;\n  typedef ResType(*StorageType)(ArgType);\n\n  static void CheckIsValid(ResType(*f)(ArgType)) {\n    GTEST_CHECK_(f != NULL)\n        << \"NULL function pointer is passed into ResultOf().\";\n  }\n  template <typename T>\n  static ResType Invoke(ResType(*f)(ArgType), T arg) {\n    return (*f)(arg);\n  }\n};\n\n// Implements the ResultOf() matcher for matching a return value of a\n// unary function of an object.\ntemplate <typename Callable>\nclass ResultOfMatcher {\n public:\n  typedef typename CallableTraits<Callable>::ResultType ResultType;\n\n  ResultOfMatcher(Callable callable, const Matcher<ResultType>& matcher)\n      : callable_(callable), matcher_(matcher) {\n    CallableTraits<Callable>::CheckIsValid(callable_);\n  }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new Impl<T>(callable_, matcher_));\n  }\n\n private:\n  typedef typename CallableTraits<Callable>::StorageType CallableStorageType;\n\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(CallableStorageType callable, const Matcher<ResultType>& matcher)\n        : callable_(callable), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T obj, MatchResultListener* listener) const {\n      *listener << \"which is mapped by the given callable to \";\n      // Cannot pass the return value (for example, int) to\n      // MatchPrintAndExplain, which takes a non-const reference as argument.\n      ResultType result =\n          CallableTraits<Callable>::template Invoke<T>(callable_, obj);\n      return MatchPrintAndExplain(result, matcher_, listener);\n    }\n\n   private:\n    // Functors often define operator() as non-const method even though\n    // they are actualy stateless. But we need to use them even when\n    // 'this' is a const pointer. It's the user's responsibility not to\n    // use stateful callables with ResultOf(), which does't guarantee\n    // how many times the callable will be invoked.\n    mutable CallableStorageType callable_;\n    const Matcher<ResultType> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };  // class Impl\n\n  const CallableStorageType callable_;\n  const Matcher<ResultType> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);\n};\n\n// Implements a matcher that checks the size of an STL-style container.\ntemplate <typename SizeMatcher>\nclass SizeIsMatcher {\n public:\n  explicit SizeIsMatcher(const SizeMatcher& size_matcher)\n       : size_matcher_(size_matcher) {\n  }\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(size_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)> ContainerView;\n    typedef typename ContainerView::type::size_type SizeType;\n    explicit Impl(const SizeMatcher& size_matcher)\n        : size_matcher_(MatcherCast<SizeType>(size_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n      SizeType size = container.size();\n      StringMatchResultListener size_listener;\n      const bool result = size_matcher_.MatchAndExplain(size, &size_listener);\n      *listener\n          << \"whose size \" << size << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(size_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<SizeType> size_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const SizeMatcher size_matcher_;\n  GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);\n};\n\n// Implements a matcher that checks the begin()..end() distance of an STL-style\n// container.\ntemplate <typename DistanceMatcher>\nclass BeginEndDistanceIsMatcher {\n public:\n  explicit BeginEndDistanceIsMatcher(const DistanceMatcher& distance_matcher)\n      : distance_matcher_(distance_matcher) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(distance_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::type StlContainer;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef typename std::iterator_traits<\n        StlContainerConstIterator>::difference_type DistanceType;\n    explicit Impl(const DistanceMatcher& distance_matcher)\n        : distance_matcher_(MatcherCast<DistanceType>(distance_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n#if GTEST_HAS_STD_BEGIN_AND_END_\n      using std::begin;\n      using std::end;\n      DistanceType distance = std::distance(begin(container), end(container));\n#else\n      DistanceType distance = std::distance(container.begin(), container.end());\n#endif\n      StringMatchResultListener distance_listener;\n      const bool result =\n          distance_matcher_.MatchAndExplain(distance, &distance_listener);\n      *listener << \"whose distance between begin() and end() \" << distance\n                << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(distance_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<DistanceType> distance_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const DistanceMatcher distance_matcher_;\n  GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);\n};\n\n// Implements an equality matcher for any STL-style container whose elements\n// support ==. This matcher is like Eq(), but its failure explanations provide\n// more detailed information that is useful when the container is used as a set.\n// The failure message reports elements that are in one of the operands but not\n// the other. The failure messages do not report duplicate or out-of-order\n// elements in the containers (which don't properly matter to sets, but can\n// occur if the containers are vectors or lists, for example).\n//\n// Uses the container's const_iterator, value_type, operator ==,\n// begin(), and end().\ntemplate <typename Container>\nclass ContainerEqMatcher {\n public:\n  typedef internal::StlContainerView<Container> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n\n  // We make a copy of expected in case the elements in it are modified\n  // after this matcher is created.\n  explicit ContainerEqMatcher(const Container& expected)\n      : expected_(View::Copy(expected)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<Container,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(Container)>();\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"equals \";\n    UniversalPrint(expected_, os);\n  }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"does not equal \";\n    UniversalPrint(expected_, os);\n  }\n\n  template <typename LhsContainer>\n  bool MatchAndExplain(const LhsContainer& lhs,\n                       MatchResultListener* listener) const {\n    // GTEST_REMOVE_CONST_() is needed to work around an MSVC 8.0 bug\n    // that causes LhsContainer to be a const type sometimes.\n    typedef internal::StlContainerView<GTEST_REMOVE_CONST_(LhsContainer)>\n        LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n    if (lhs_stl_container == expected_)\n      return true;\n\n    ::std::ostream* const os = listener->stream();\n    if (os != NULL) {\n      // Something is different. Check for extra values first.\n      bool printed_header = false;\n      for (typename LhsStlContainer::const_iterator it =\n               lhs_stl_container.begin();\n           it != lhs_stl_container.end(); ++it) {\n        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==\n            expected_.end()) {\n          if (printed_header) {\n            *os << \", \";\n          } else {\n            *os << \"which has these unexpected elements: \";\n            printed_header = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n\n      // Now check for missing values.\n      bool printed_header2 = false;\n      for (typename StlContainer::const_iterator it = expected_.begin();\n           it != expected_.end(); ++it) {\n        if (internal::ArrayAwareFind(\n                lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==\n            lhs_stl_container.end()) {\n          if (printed_header2) {\n            *os << \", \";\n          } else {\n            *os << (printed_header ? \",\\nand\" : \"which\")\n                << \" doesn't have these expected elements: \";\n            printed_header2 = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n    }\n\n    return false;\n  }\n\n private:\n  const StlContainer expected_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);\n};\n\n// A comparator functor that uses the < operator to compare two values.\nstruct LessComparator {\n  template <typename T, typename U>\n  bool operator()(const T& lhs, const U& rhs) const { return lhs < rhs; }\n};\n\n// Implements WhenSortedBy(comparator, container_matcher).\ntemplate <typename Comparator, typename ContainerMatcher>\nclass WhenSortedByMatcher {\n public:\n  WhenSortedByMatcher(const Comparator& comparator,\n                      const ContainerMatcher& matcher)\n      : comparator_(comparator), matcher_(matcher) {}\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(comparator_, matcher_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    // Transforms std::pair<const Key, Value> into std::pair<Key, Value>\n    // so that we can match associative containers.\n    typedef typename RemoveConstFromKey<\n        typename LhsStlContainer::value_type>::type LhsValue;\n\n    Impl(const Comparator& comparator, const ContainerMatcher& matcher)\n        : comparator_(comparator), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      ::std::vector<LhsValue> sorted_container(lhs_stl_container.begin(),\n                                               lhs_stl_container.end());\n      ::std::sort(\n           sorted_container.begin(), sorted_container.end(), comparator_);\n\n      if (!listener->IsInterested()) {\n        // If the listener is not interested, we do not need to\n        // construct the inner explanation.\n        return matcher_.Matches(sorted_container);\n      }\n\n      *listener << \"which is \";\n      UniversalPrint(sorted_container, listener->stream());\n      *listener << \" when sorted\";\n\n      StringMatchResultListener inner_listener;\n      const bool match = matcher_.MatchAndExplain(sorted_container,\n                                                  &inner_listener);\n      PrintIfNotEmpty(inner_listener.str(), listener->stream());\n      return match;\n    }\n\n   private:\n    const Comparator comparator_;\n    const Matcher<const ::std::vector<LhsValue>&> matcher_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n private:\n  const Comparator comparator_;\n  const ContainerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);\n};\n\n// Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher\n// must be able to be safely cast to Matcher<tuple<const T1&, const\n// T2&> >, where T1 and T2 are the types of elements in the LHS\n// container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename RhsContainer>\nclass PointwiseMatcher {\n public:\n  typedef internal::StlContainerView<RhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type RhsValue;\n\n  // Like ContainerEq, we make a copy of rhs in case the elements in\n  // it are modified after this matcher is created.\n  PointwiseMatcher(const TupleMatcher& tuple_matcher, const RhsContainer& rhs)\n      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<RhsContainer,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)>();\n  }\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(tuple_matcher_, rhs_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    typedef typename LhsStlContainer::value_type LhsValue;\n    // We pass the LHS value and the RHS value to the inner matcher by\n    // reference, as they may be expensive to copy.  We must use tuple\n    // instead of pair here, as a pair cannot hold references (C++ 98,\n    // 20.2.2 [lib.pairs]).\n    typedef ::testing::tuple<const LhsValue&, const RhsValue&> InnerMatcherArg;\n\n    Impl(const TupleMatcher& tuple_matcher, const RhsStlContainer& rhs)\n        // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.\n        : mono_tuple_matcher_(SafeMatcherCast<InnerMatcherArg>(tuple_matcher)),\n          rhs_(rhs) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"contains \" << rhs_.size()\n          << \" values, where each value and its corresponding value in \";\n      UniversalPrinter<RhsStlContainer>::Print(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"doesn't contain exactly \" << rhs_.size()\n          << \" values, or contains a value x at some index i\"\n          << \" where x and the i-th value of \";\n      UniversalPrint(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      const size_t actual_size = lhs_stl_container.size();\n      if (actual_size != rhs_.size()) {\n        *listener << \"which contains \" << actual_size << \" values\";\n        return false;\n      }\n\n      typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();\n      typename RhsStlContainer::const_iterator right = rhs_.begin();\n      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {\n        const InnerMatcherArg value_pair(*left, *right);\n\n        if (listener->IsInterested()) {\n          StringMatchResultListener inner_listener;\n          if (!mono_tuple_matcher_.MatchAndExplain(\n                  value_pair, &inner_listener)) {\n            *listener << \"where the value pair (\";\n            UniversalPrint(*left, listener->stream());\n            *listener << \", \";\n            UniversalPrint(*right, listener->stream());\n            *listener << \") at index #\" << i << \" don't match\";\n            PrintIfNotEmpty(inner_listener.str(), listener->stream());\n            return false;\n          }\n        } else {\n          if (!mono_tuple_matcher_.Matches(value_pair))\n            return false;\n        }\n      }\n\n      return true;\n    }\n\n   private:\n    const Matcher<InnerMatcherArg> mono_tuple_matcher_;\n    const RhsStlContainer rhs_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const TupleMatcher tuple_matcher_;\n  const RhsStlContainer rhs_;\n\n  GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);\n};\n\n// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.\ntemplate <typename Container>\nclass QuantifierMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  template <typename InnerMatcher>\n  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n           testing::SafeMatcherCast<const Element&>(inner_matcher)) {}\n\n  // Checks whether:\n  // * All elements in the container match, if all_elements_should_match.\n  // * Any element in the container matches, if !all_elements_should_match.\n  bool MatchAndExplainImpl(bool all_elements_should_match,\n                           Container container,\n                           MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    size_t i = 0;\n    for (typename StlContainer::const_iterator it = stl_container.begin();\n         it != stl_container.end(); ++it, ++i) {\n      StringMatchResultListener inner_listener;\n      const bool matches = inner_matcher_.MatchAndExplain(*it, &inner_listener);\n\n      if (matches != all_elements_should_match) {\n        *listener << \"whose element #\" << i\n                  << (matches ? \" matches\" : \" doesn't match\");\n        PrintIfNotEmpty(inner_listener.str(), listener->stream());\n        return !all_elements_should_match;\n      }\n    }\n    return all_elements_should_match;\n  }\n\n protected:\n  const Matcher<const Element&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);\n};\n\n// Implements Contains(element_matcher) for the given argument type Container.\n// Symmetric to EachMatcherImpl.\ntemplate <typename Container>\nclass ContainsMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"contains at least one element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't contain any element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(false, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);\n};\n\n// Implements Each(element_matcher) for the given argument type Container.\n// Symmetric to ContainsMatcherImpl.\ntemplate <typename Container>\nclass EachMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit EachMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"only contains elements that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"contains some element that \";\n    this->inner_matcher_.DescribeNegationTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(true, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);\n};\n\n// Implements polymorphic Contains(element_matcher).\ntemplate <typename M>\nclass ContainsMatcher {\n public:\n  explicit ContainsMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ContainsMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcher);\n};\n\n// Implements polymorphic Each(element_matcher).\ntemplate <typename M>\nclass EachMatcher {\n public:\n  explicit EachMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new EachMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(EachMatcher);\n};\n\n// Implements Key(inner_matcher) for the given argument pair type.\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename PairType>\nclass KeyMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type KeyType;\n\n  template <typename InnerMatcher>\n  explicit KeyMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n          testing::SafeMatcherCast<const KeyType&>(inner_matcher)) {\n  }\n\n  // Returns true iff 'key_value.first' (the key) matches the inner matcher.\n  virtual bool MatchAndExplain(PairType key_value,\n                               MatchResultListener* listener) const {\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(key_value.first,\n                                                      &inner_listener);\n    const internal::string explanation = inner_listener.str();\n    if (explanation != \"\") {\n      *listener << \"whose first field is a value \" << explanation;\n    }\n    return match;\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't have a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<const KeyType&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);\n};\n\n// Implements polymorphic Key(matcher_for_key).\ntemplate <typename M>\nclass KeyMatcher {\n public:\n  explicit KeyMatcher(M m) : matcher_for_key_(m) {}\n\n  template <typename PairType>\n  operator Matcher<PairType>() const {\n    return MakeMatcher(new KeyMatcherImpl<PairType>(matcher_for_key_));\n  }\n\n private:\n  const M matcher_for_key_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcher);\n};\n\n// Implements Pair(first_matcher, second_matcher) for the given argument pair\n// type with its two matchers. See Pair() function below.\ntemplate <typename PairType>\nclass PairMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type FirstType;\n  typedef typename RawPairType::second_type SecondType;\n\n  template <typename FirstMatcher, typename SecondMatcher>\n  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(\n            testing::SafeMatcherCast<const FirstType&>(first_matcher)),\n        second_matcher_(\n            testing::SafeMatcherCast<const SecondType&>(second_matcher)) {\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeTo(os);\n    *os << \", and has a second field that \";\n    second_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeNegationTo(os);\n    *os << \", or has a second field that \";\n    second_matcher_.DescribeNegationTo(os);\n  }\n\n  // Returns true iff 'a_pair.first' matches first_matcher and 'a_pair.second'\n  // matches second_matcher.\n  virtual bool MatchAndExplain(PairType a_pair,\n                               MatchResultListener* listener) const {\n    if (!listener->IsInterested()) {\n      // If the listener is not interested, we don't need to construct the\n      // explanation.\n      return first_matcher_.Matches(a_pair.first) &&\n             second_matcher_.Matches(a_pair.second);\n    }\n    StringMatchResultListener first_inner_listener;\n    if (!first_matcher_.MatchAndExplain(a_pair.first,\n                                        &first_inner_listener)) {\n      *listener << \"whose first field does not match\";\n      PrintIfNotEmpty(first_inner_listener.str(), listener->stream());\n      return false;\n    }\n    StringMatchResultListener second_inner_listener;\n    if (!second_matcher_.MatchAndExplain(a_pair.second,\n                                         &second_inner_listener)) {\n      *listener << \"whose second field does not match\";\n      PrintIfNotEmpty(second_inner_listener.str(), listener->stream());\n      return false;\n    }\n    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),\n                   listener);\n    return true;\n  }\n\n private:\n  void ExplainSuccess(const internal::string& first_explanation,\n                      const internal::string& second_explanation,\n                      MatchResultListener* listener) const {\n    *listener << \"whose both fields match\";\n    if (first_explanation != \"\") {\n      *listener << \", where the first field is a value \" << first_explanation;\n    }\n    if (second_explanation != \"\") {\n      *listener << \", \";\n      if (first_explanation != \"\") {\n        *listener << \"and \";\n      } else {\n        *listener << \"where \";\n      }\n      *listener << \"the second field is a value \" << second_explanation;\n    }\n  }\n\n  const Matcher<const FirstType&> first_matcher_;\n  const Matcher<const SecondType&> second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);\n};\n\n// Implements polymorphic Pair(first_matcher, second_matcher).\ntemplate <typename FirstMatcher, typename SecondMatcher>\nclass PairMatcher {\n public:\n  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}\n\n  template <typename PairType>\n  operator Matcher<PairType> () const {\n    return MakeMatcher(\n        new PairMatcherImpl<PairType>(\n            first_matcher_, second_matcher_));\n  }\n\n private:\n  const FirstMatcher first_matcher_;\n  const SecondMatcher second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcher);\n};\n\n// Implements ElementsAre() and ElementsAreArray().\ntemplate <typename Container>\nclass ElementsAreMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  ElementsAreMatcherImpl(InputIter first, InputIter last) {\n    while (first != last) {\n      matchers_.push_back(MatcherCast<const Element&>(*first++));\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"is empty\";\n    } else if (count() == 1) {\n      *os << \"has 1 element that \";\n      matchers_[0].DescribeTo(os);\n    } else {\n      *os << \"has \" << Elements(count()) << \" where\\n\";\n      for (size_t i = 0; i != count(); ++i) {\n        *os << \"element #\" << i << \" \";\n        matchers_[i].DescribeTo(os);\n        if (i + 1 < count()) {\n          *os << \",\\n\";\n        }\n      }\n    }\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"isn't empty\";\n      return;\n    }\n\n    *os << \"doesn't have \" << Elements(count()) << \", or\\n\";\n    for (size_t i = 0; i != count(); ++i) {\n      *os << \"element #\" << i << \" \";\n      matchers_[i].DescribeNegationTo(os);\n      if (i + 1 < count()) {\n        *os << \", or\\n\";\n      }\n    }\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    // To work with stream-like \"containers\", we must only walk\n    // through the elements in one pass.\n\n    const bool listener_interested = listener->IsInterested();\n\n    // explanations[i] is the explanation of the element at index i.\n    ::std::vector<internal::string> explanations(count());\n    StlContainerReference stl_container = View::ConstReference(container);\n    StlContainerConstIterator it = stl_container.begin();\n    size_t exam_pos = 0;\n    bool mismatch_found = false;  // Have we found a mismatched element yet?\n\n    // Go through the elements and matchers in pairs, until we reach\n    // the end of either the elements or the matchers, or until we find a\n    // mismatch.\n    for (; it != stl_container.end() && exam_pos != count(); ++it, ++exam_pos) {\n      bool match;  // Does the current element match the current matcher?\n      if (listener_interested) {\n        StringMatchResultListener s;\n        match = matchers_[exam_pos].MatchAndExplain(*it, &s);\n        explanations[exam_pos] = s.str();\n      } else {\n        match = matchers_[exam_pos].Matches(*it);\n      }\n\n      if (!match) {\n        mismatch_found = true;\n        break;\n      }\n    }\n    // If mismatch_found is true, 'exam_pos' is the index of the mismatch.\n\n    // Find how many elements the actual container has.  We avoid\n    // calling size() s.t. this code works for stream-like \"containers\"\n    // that don't define size().\n    size_t actual_count = exam_pos;\n    for (; it != stl_container.end(); ++it) {\n      ++actual_count;\n    }\n\n    if (actual_count != count()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container.  Otherwise we just need to show\n      // how many elements there actually are.\n      if (listener_interested && (actual_count != 0)) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    if (mismatch_found) {\n      // The element count matches, but the exam_pos-th element doesn't match.\n      if (listener_interested) {\n        *listener << \"whose element #\" << exam_pos << \" doesn't match\";\n        PrintIfNotEmpty(explanations[exam_pos], listener->stream());\n      }\n      return false;\n    }\n\n    // Every element matches its expectation.  We need to explain why\n    // (the obvious ones can be skipped).\n    if (listener_interested) {\n      bool reason_printed = false;\n      for (size_t i = 0; i != count(); ++i) {\n        const internal::string& s = explanations[i];\n        if (!s.empty()) {\n          if (reason_printed) {\n            *listener << \",\\nand \";\n          }\n          *listener << \"whose element #\" << i << \" matches, \" << s;\n          reason_printed = true;\n        }\n      }\n    }\n    return true;\n  }\n\n private:\n  static Message Elements(size_t count) {\n    return Message() << count << (count == 1 ? \" element\" : \" elements\");\n  }\n\n  size_t count() const { return matchers_.size(); }\n\n  ::std::vector<Matcher<const Element&> > matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);\n};\n\n// Connectivity matrix of (elements X matchers), in element-major order.\n// Initially, there are no edges.\n// Use NextGraph() to iterate over all possible edge configurations.\n// Use Randomize() to generate a random edge configuration.\nclass GTEST_API_ MatchMatrix {\n public:\n  MatchMatrix(size_t num_elements, size_t num_matchers)\n      : num_elements_(num_elements),\n        num_matchers_(num_matchers),\n        matched_(num_elements_* num_matchers_, 0) {\n  }\n\n  size_t LhsSize() const { return num_elements_; }\n  size_t RhsSize() const { return num_matchers_; }\n  bool HasEdge(size_t ilhs, size_t irhs) const {\n    return matched_[SpaceIndex(ilhs, irhs)] == 1;\n  }\n  void SetEdge(size_t ilhs, size_t irhs, bool b) {\n    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;\n  }\n\n  // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,\n  // adds 1 to that number; returns false if incrementing the graph left it\n  // empty.\n  bool NextGraph();\n\n  void Randomize();\n\n  string DebugString() const;\n\n private:\n  size_t SpaceIndex(size_t ilhs, size_t irhs) const {\n    return ilhs * num_matchers_ + irhs;\n  }\n\n  size_t num_elements_;\n  size_t num_matchers_;\n\n  // Each element is a char interpreted as bool. They are stored as a\n  // flattened array in lhs-major order, use 'SpaceIndex()' to translate\n  // a (ilhs, irhs) matrix coordinate into an offset.\n  ::std::vector<char> matched_;\n};\n\ntypedef ::std::pair<size_t, size_t> ElementMatcherPair;\ntypedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;\n\n// Returns a maximum bipartite matching for the specified graph 'g'.\n// The matching is represented as a vector of {element, matcher} pairs.\nGTEST_API_ ElementMatcherPairs\nFindMaxBipartiteMatching(const MatchMatrix& g);\n\nGTEST_API_ bool FindPairing(const MatchMatrix& matrix,\n                            MatchResultListener* listener);\n\n// Untyped base class for implementing UnorderedElementsAre.  By\n// putting logic that's not specific to the element type here, we\n// reduce binary bloat and increase compilation speed.\nclass GTEST_API_ UnorderedElementsAreMatcherImplBase {\n protected:\n  // A vector of matcher describers, one for each element matcher.\n  // Does not own the describers (and thus can be used only when the\n  // element matchers are alive).\n  typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;\n\n  // Describes this UnorderedElementsAre matcher.\n  void DescribeToImpl(::std::ostream* os) const;\n\n  // Describes the negation of this UnorderedElementsAre matcher.\n  void DescribeNegationToImpl(::std::ostream* os) const;\n\n  bool VerifyAllElementsAndMatchersAreMatched(\n      const ::std::vector<string>& element_printouts,\n      const MatchMatrix& matrix,\n      MatchResultListener* listener) const;\n\n  MatcherDescriberVec& matcher_describers() {\n    return matcher_describers_;\n  }\n\n  static Message Elements(size_t n) {\n    return Message() << n << \" element\" << (n == 1 ? \"\" : \"s\");\n  }\n\n private:\n  MatcherDescriberVec matcher_describers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);\n};\n\n// Implements unordered ElementsAre and unordered ElementsAreArray.\ntemplate <typename Container>\nclass UnorderedElementsAreMatcherImpl\n    : public MatcherInterface<Container>,\n      public UnorderedElementsAreMatcherImplBase {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  UnorderedElementsAreMatcherImpl(InputIter first, InputIter last) {\n    for (; first != last; ++first) {\n      matchers_.push_back(MatcherCast<const Element&>(*first));\n      matcher_describers().push_back(matchers_.back().GetDescriber());\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    ::std::vector<string> element_printouts;\n    MatchMatrix matrix = AnalyzeElements(stl_container.begin(),\n                                         stl_container.end(),\n                                         &element_printouts,\n                                         listener);\n\n    const size_t actual_count = matrix.LhsSize();\n    if (actual_count == 0 && matchers_.empty()) {\n      return true;\n    }\n    if (actual_count != matchers_.size()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container. Otherwise we just need to show\n      // how many elements there actually are.\n      if (actual_count != 0 && listener->IsInterested()) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    return VerifyAllElementsAndMatchersAreMatched(element_printouts,\n                                                  matrix, listener) &&\n           FindPairing(matrix, listener);\n  }\n\n private:\n  typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n\n  template <typename ElementIter>\n  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,\n                              ::std::vector<string>* element_printouts,\n                              MatchResultListener* listener) const {\n    element_printouts->clear();\n    ::std::vector<char> did_match;\n    size_t num_elements = 0;\n    for (; elem_first != elem_last; ++num_elements, ++elem_first) {\n      if (listener->IsInterested()) {\n        element_printouts->push_back(PrintToString(*elem_first));\n      }\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        did_match.push_back(Matches(matchers_[irhs])(*elem_first));\n      }\n    }\n\n    MatchMatrix matrix(num_elements, matchers_.size());\n    ::std::vector<char>::const_iterator did_match_iter = did_match.begin();\n    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);\n      }\n    }\n    return matrix;\n  }\n\n  MatcherVec matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);\n};\n\n// Functor for use in TransformTuple.\n// Performs MatcherCast<Target> on an input argument of any type.\ntemplate <typename Target>\nstruct CastAndAppendTransform {\n  template <typename Arg>\n  Matcher<Target> operator()(const Arg& a) const {\n    return MatcherCast<Target>(a);\n  }\n};\n\n// Implements UnorderedElementsAre.\ntemplate <typename MatcherTuple>\nclass UnorderedElementsAreMatcher {\n public:\n  explicit UnorderedElementsAreMatcher(const MatcherTuple& args)\n      : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new UnorderedElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);\n};\n\n// Implements ElementsAre.\ntemplate <typename MatcherTuple>\nclass ElementsAreMatcher {\n public:\n  explicit ElementsAreMatcher(const MatcherTuple& args) : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);\n};\n\n// Implements UnorderedElementsAreArray().\ntemplate <typename T>\nclass UnorderedElementsAreArrayMatcher {\n public:\n  UnorderedElementsAreArrayMatcher() {}\n\n  template <typename Iter>\n  UnorderedElementsAreArrayMatcher(Iter first, Iter last)\n      : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(\n        new UnorderedElementsAreMatcherImpl<Container>(matchers_.begin(),\n                                                       matchers_.end()));\n  }\n\n private:\n  ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);\n};\n\n// Implements ElementsAreArray().\ntemplate <typename T>\nclass ElementsAreArrayMatcher {\n public:\n  template <typename Iter>\n  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n        matchers_.begin(), matchers_.end()));\n  }\n\n private:\n  const ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);\n};\n\n// Given a 2-tuple matcher tm of type Tuple2Matcher and a value second\n// of type Second, BoundSecondMatcher<Tuple2Matcher, Second>(tm,\n// second) is a polymorphic matcher that matches a value x iff tm\n// matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\n//\n// BoundSecondMatcher is copyable and assignable, as we need to put\n// instances of this class in a vector when implementing\n// UnorderedPointwise().\ntemplate <typename Tuple2Matcher, typename Second>\nclass BoundSecondMatcher {\n public:\n  BoundSecondMatcher(const Tuple2Matcher& tm, const Second& second)\n      : tuple2_matcher_(tm), second_value_(second) {}\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return MakeMatcher(new Impl<T>(tuple2_matcher_, second_value_));\n  }\n\n  // We have to define this for UnorderedPointwise() to compile in\n  // C++98 mode, as it puts BoundSecondMatcher instances in a vector,\n  // which requires the elements to be assignable in C++98.  The\n  // compiler cannot generate the operator= for us, as Tuple2Matcher\n  // and Second may not be assignable.\n  //\n  // However, this should never be called, so the implementation just\n  // need to assert.\n  void operator=(const BoundSecondMatcher& /*rhs*/) {\n    GTEST_LOG_(FATAL) << \"BoundSecondMatcher should never be assigned.\";\n  }\n\n  BoundSecondMatcher(const BoundSecondMatcher &) = default;\n\n private:\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    typedef ::testing::tuple<T, Second> ArgTuple;\n\n    Impl(const Tuple2Matcher& tm, const Second& second)\n        : mono_tuple2_matcher_(SafeMatcherCast<const ArgTuple&>(tm)),\n          second_value_(second) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"and \";\n      UniversalPrint(second_value_, os);\n      *os << \" \";\n      mono_tuple2_matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),\n                                                  listener);\n    }\n\n   private:\n    const Matcher<const ArgTuple&> mono_tuple2_matcher_;\n    const Second second_value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const Tuple2Matcher tuple2_matcher_;\n  const Second second_value_;\n};\n\n// Given a 2-tuple matcher tm and a value second,\n// MatcherBindSecond(tm, second) returns a matcher that matches a\n// value x iff tm matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\ntemplate <typename Tuple2Matcher, typename Second>\nBoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(\n    const Tuple2Matcher& tm, const Second& second) {\n  return BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);\n}\n\n// Returns the description for a matcher defined using the MATCHER*()\n// macro where the user-supplied description string is \"\", if\n// 'negation' is false; otherwise returns the description of the\n// negation of the matcher.  'param_values' contains a list of strings\n// that are the print-out of the matcher's parameters.\nGTEST_API_ string FormatMatcherDescription(bool negation,\n                                           const char* matcher_name,\n                                           const Strings& param_values);\n\n}  // namespace internal\n\n// ElementsAreArray(first, last)\n// ElementsAreArray(pointer, count)\n// ElementsAreArray(array)\n// ElementsAreArray(container)\n// ElementsAreArray({ e1, e2, ..., en })\n//\n// The ElementsAreArray() functions are like ElementsAre(...), except\n// that they are given a homogeneous sequence rather than taking each\n// element as a function argument. The sequence can be specified as an\n// array, a pointer and count, a vector, an initializer list, or an\n// STL iterator range. In each of these cases, the underlying sequence\n// can be either a sequence of values or a sequence of matchers.\n//\n// All forms of ElementsAreArray() make a copy of the input matcher sequence.\n\ntemplate <typename Iter>\ninline internal::ElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::ElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T* pointer, size_t count) {\n  return ElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T (&array)[N]) {\n  return ElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::ElementsAreArrayMatcher<typename Container::value_type>\nElementsAreArray(const Container& container) {\n  return ElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T>\nElementsAreArray(::std::initializer_list<T> xs) {\n  return ElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// UnorderedElementsAreArray(first, last)\n// UnorderedElementsAreArray(pointer, count)\n// UnorderedElementsAreArray(array)\n// UnorderedElementsAreArray(container)\n// UnorderedElementsAreArray({ e1, e2, ..., en })\n//\n// The UnorderedElementsAreArray() functions are like\n// ElementsAreArray(...), but allow matching the elements in any order.\ntemplate <typename Iter>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nUnorderedElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T* pointer, size_t count) {\n  return UnorderedElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T (&array)[N]) {\n  return UnorderedElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename Container::value_type>\nUnorderedElementsAreArray(const Container& container) {\n  return UnorderedElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(::std::initializer_list<T> xs) {\n  return UnorderedElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// _ is a matcher that matches anything of any type.\n//\n// This definition is fine as:\n//\n//   1. The C++ standard permits using the name _ in a namespace that\n//      is not the global namespace or ::std.\n//   2. The AnythingMatcher class has no data member or constructor,\n//      so it's OK to create global variables of this type.\n//   3. c-style has approved of using _ in this case.\nconst internal::AnythingMatcher _ = {};\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> A() { return MakeMatcher(new internal::AnyMatcherImpl<T>()); }\n\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> An() { return A<T>(); }\n\n// Creates a polymorphic matcher that matches anything equal to x.\n// Note: if the parameter of Eq() were declared as const T&, Eq(\"foo\")\n// wouldn't compile.\ntemplate <typename T>\ninline internal::EqMatcher<T> Eq(T x) { return internal::EqMatcher<T>(x); }\n\n// Constructs a Matcher<T> from a 'value' of type T.  The constructed\n// matcher matches any value that's equal to 'value'.\ntemplate <typename T>\nMatcher<T>::Matcher(T value) { *this = Eq(value); }\n\n// Creates a monomorphic matcher that matches anything with type Lhs\n// and equal to rhs.  A user may need to use this instead of Eq(...)\n// in order to resolve an overloading ambiguity.\n//\n// TypedEq<T>(x) is just a convenient short-hand for Matcher<T>(Eq(x))\n// or Matcher<T>(x), but more readable than the latter.\n//\n// We could define similar monomorphic matchers for other comparison\n// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do\n// it yet as those are used much less than Eq() in practice.  A user\n// can always write Matcher<T>(Lt(5)) to be explicit about the type,\n// for example.\ntemplate <typename Lhs, typename Rhs>\ninline Matcher<Lhs> TypedEq(const Rhs& rhs) { return Eq(rhs); }\n\n// Creates a polymorphic matcher that matches anything >= x.\ntemplate <typename Rhs>\ninline internal::GeMatcher<Rhs> Ge(Rhs x) {\n  return internal::GeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything > x.\ntemplate <typename Rhs>\ninline internal::GtMatcher<Rhs> Gt(Rhs x) {\n  return internal::GtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything <= x.\ntemplate <typename Rhs>\ninline internal::LeMatcher<Rhs> Le(Rhs x) {\n  return internal::LeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything < x.\ntemplate <typename Rhs>\ninline internal::LtMatcher<Rhs> Lt(Rhs x) {\n  return internal::LtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything != x.\ntemplate <typename Rhs>\ninline internal::NeMatcher<Rhs> Ne(Rhs x) {\n  return internal::NeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches any NULL pointer.\ninline PolymorphicMatcher<internal::IsNullMatcher > IsNull() {\n  return MakePolymorphicMatcher(internal::IsNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any non-NULL pointer.\n// This is convenient as Not(NULL) doesn't compile (the compiler\n// thinks that that expression is comparing a pointer with an integer).\ninline PolymorphicMatcher<internal::NotNullMatcher > NotNull() {\n  return MakePolymorphicMatcher(internal::NotNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any argument that\n// references variable x.\ntemplate <typename T>\ninline internal::RefMatcher<T&> Ref(T& x) {  // NOLINT\n  return internal::RefMatcher<T&>(x);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<double> DoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, false);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, true);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> DoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<float> FloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, false);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, true);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> FloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches a pointer (raw or smart) that points\n// to a value that matches inner_matcher.\ntemplate <typename InnerMatcher>\ninline internal::PointeeMatcher<InnerMatcher> Pointee(\n    const InnerMatcher& inner_matcher) {\n  return internal::PointeeMatcher<InnerMatcher>(inner_matcher);\n}\n\n// Creates a matcher that matches a pointer or reference that matches\n// inner_matcher when dynamic_cast<To> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\ninline PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To> >\nWhenDynamicCastTo(const Matcher<To>& inner_matcher) {\n  return MakePolymorphicMatcher(\n      internal::WhenDynamicCastToMatcher<To>(inner_matcher));\n}\n\n// Creates a matcher that matches an object whose given field matches\n// 'matcher'.  For example,\n//   Field(&Foo::number, Ge(5))\n// matches a Foo object x iff x.number >= 5.\ntemplate <typename Class, typename FieldType, typename FieldMatcher>\ninline PolymorphicMatcher<\n  internal::FieldMatcher<Class, FieldType> > Field(\n    FieldType Class::*field, const FieldMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::FieldMatcher<Class, FieldType>(\n          field, MatcherCast<const FieldType&>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Field(&Foo::bar, m)\n  // to compile where bar is an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object whose given property\n// matches 'matcher'.  For example,\n//   Property(&Foo::str, StartsWith(\"hi\"))\n// matches a Foo object x iff x.str() starts with \"hi\".\ntemplate <typename Class, typename PropertyType, typename PropertyMatcher>\ninline PolymorphicMatcher<\n  internal::PropertyMatcher<Class, PropertyType> > Property(\n    PropertyType (Class::*property)() const, const PropertyMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher<Class, PropertyType>(\n          property,\n          MatcherCast<GTEST_REFERENCE_TO_CONST_(PropertyType)>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Property(&Foo::bar, m)\n  // to compile where bar() returns an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object iff the result of applying\n// a callable to x matches 'matcher'.\n// For example,\n//   ResultOf(f, StartsWith(\"hi\"))\n// matches a Foo object x iff f(x) starts with \"hi\".\n// callable parameter can be a function, function pointer, or a functor.\n// Callable has to satisfy the following conditions:\n//   * It is required to keep no state affecting the results of\n//     the calls on it and make no assumptions about how many calls\n//     will be made. Any state it keeps must be protected from the\n//     concurrent access.\n//   * If it is a function object, it has to define type result_type.\n//     We recommend deriving your functor classes from std::unary_function.\ntemplate <typename Callable, typename ResultOfMatcher>\ninternal::ResultOfMatcher<Callable> ResultOf(\n    Callable callable, const ResultOfMatcher& matcher) {\n  return internal::ResultOfMatcher<Callable>(\n          callable,\n          MatcherCast<typename internal::CallableTraits<Callable>::ResultType>(\n              matcher));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   ResultOf(Function, m)\n  // to compile where Function() returns an int32 and m is a matcher for int64.\n}\n\n// String matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any string, std::string, or C string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::string> >\n    HasSubstr(const internal::string& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::string>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::string> >\n    StartsWith(const internal::string& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::string>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::string> >\n    EndsWith(const internal::string& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::string>(\n      suffix));\n}\n\n// Matches a string that fully matches regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::string& regex) {\n  return MatchesRegex(new internal::RE(regex));\n}\n\n// Matches a string that contains regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::string& regex) {\n  return ContainsRegex(new internal::RE(regex));\n}\n\n#if GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n// Wide string matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any wstring, std::wstring, or C wide string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::wstring> >\n    HasSubstr(const internal::wstring& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::wstring>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::wstring> >\n    StartsWith(const internal::wstring& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::wstring>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::wstring> >\n    EndsWith(const internal::wstring& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::wstring>(\n      suffix));\n}\n\n#endif  // GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field == the second field.\ninline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field >= the second field.\ninline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field > the second field.\ninline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field <= the second field.\ninline internal::Le2Matcher Le() { return internal::Le2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field < the second field.\ninline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field != the second field.\ninline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }\n\n// Creates a matcher that matches any value of type T that m doesn't\n// match.\ntemplate <typename InnerMatcher>\ninline internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) {\n  return internal::NotMatcher<InnerMatcher>(m);\n}\n\n// Returns a matcher that matches anything that satisfies the given\n// predicate.  The predicate can be any unary function or functor\n// whose return type can be implicitly converted to bool.\ntemplate <typename Predicate>\ninline PolymorphicMatcher<internal::TrulyMatcher<Predicate> >\nTruly(Predicate pred) {\n  return MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));\n}\n\n// Returns a matcher that matches the container size. The container must\n// support both size() and size_type which all STL-like containers provide.\n// Note that the parameter 'size' can be a value of type size_type as well as\n// matcher. For instance:\n//   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.\n//   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.\ntemplate <typename SizeMatcher>\ninline internal::SizeIsMatcher<SizeMatcher>\nSizeIs(const SizeMatcher& size_matcher) {\n  return internal::SizeIsMatcher<SizeMatcher>(size_matcher);\n}\n\n// Returns a matcher that matches the distance between the container's begin()\n// iterator and its end() iterator, i.e. the size of the container. This matcher\n// can be used instead of SizeIs with containers such as std::forward_list which\n// do not implement size(). The container must provide const_iterator (with\n// valid iterator_traits), begin() and end().\ntemplate <typename DistanceMatcher>\ninline internal::BeginEndDistanceIsMatcher<DistanceMatcher>\nBeginEndDistanceIs(const DistanceMatcher& distance_matcher) {\n  return internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance_matcher);\n}\n\n// Returns a matcher that matches an equal container.\n// This matcher behaves like Eq(), but in the event of mismatch lists the\n// values that are included in one container but not the other. (Duplicate\n// values and order differences are not explained.)\ntemplate <typename Container>\ninline PolymorphicMatcher<internal::ContainerEqMatcher<  // NOLINT\n                            GTEST_REMOVE_CONST_(Container)> >\n    ContainerEq(const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes.\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return MakePolymorphicMatcher(\n      internal::ContainerEqMatcher<RawContainer>(rhs));\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the given comparator, matches container_matcher.\ntemplate <typename Comparator, typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<Comparator, ContainerMatcher>\nWhenSortedBy(const Comparator& comparator,\n             const ContainerMatcher& container_matcher) {\n  return internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(\n      comparator, container_matcher);\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the < operator, matches container_matcher.\ntemplate <typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>\nWhenSorted(const ContainerMatcher& container_matcher) {\n  return\n      internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>(\n          internal::LessComparator(), container_matcher);\n}\n\n// Matches an STL-style container or a native array that contains the\n// same number of elements as in rhs, where its i-th element and rhs's\n// i-th element (as a pair) satisfy the given pair matcher, for all i.\n// TupleMatcher must be able to be safely cast to Matcher<tuple<const\n// T1&, const T2&> >, where T1 and T2 are the types of elements in the\n// LHS container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename Container>\ninline internal::PointwiseMatcher<TupleMatcher,\n                                  GTEST_REMOVE_CONST_(Container)>\nPointwise(const TupleMatcher& tuple_matcher, const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes (e.g. when\n  // rhs is a const int[])..\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return internal::PointwiseMatcher<TupleMatcher, RawContainer>(\n      tuple_matcher, rhs);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the Pointwise(m, {a, b, c}) syntax.\ntemplate <typename TupleMatcher, typename T>\ninline internal::PointwiseMatcher<TupleMatcher, std::vector<T> > Pointwise(\n    const TupleMatcher& tuple_matcher, std::initializer_list<T> rhs) {\n  return Pointwise(tuple_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// UnorderedPointwise(pair_matcher, rhs) matches an STL-style\n// container or a native array that contains the same number of\n// elements as in rhs, where in some permutation of the container, its\n// i-th element and rhs's i-th element (as a pair) satisfy the given\n// pair matcher, for all i.  Tuple2Matcher must be able to be safely\n// cast to Matcher<tuple<const T1&, const T2&> >, where T1 and T2 are\n// the types of elements in the LHS container and the RHS container\n// respectively.\n//\n// This is like Pointwise(pair_matcher, rhs), except that the element\n// order doesn't matter.\ntemplate <typename Tuple2Matcher, typename RhsContainer>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<\n        Tuple2Matcher, typename internal::StlContainerView<GTEST_REMOVE_CONST_(\n                           RhsContainer)>::type::value_type> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   const RhsContainer& rhs_container) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes RhsContainer to be a const type sometimes (e.g. when\n  // rhs_container is a const int[]).\n  typedef GTEST_REMOVE_CONST_(RhsContainer) RawRhsContainer;\n\n  // RhsView allows the same code to handle RhsContainer being a\n  // STL-style container and it being a native C-style array.\n  typedef typename internal::StlContainerView<RawRhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type Second;\n  const RhsStlContainer& rhs_stl_container =\n      RhsView::ConstReference(rhs_container);\n\n  // Create a matcher for each element in rhs_container.\n  ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher, Second> > matchers;\n  for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();\n       it != rhs_stl_container.end(); ++it) {\n    matchers.push_back(\n        internal::MatcherBindSecond(tuple2_matcher, *it));\n  }\n\n  // Delegate the work to UnorderedElementsAreArray().\n  return UnorderedElementsAreArray(matchers);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the UnorderedPointwise(m, {a, b, c}) syntax.\ntemplate <typename Tuple2Matcher, typename T>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<Tuple2Matcher, T> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   std::initializer_list<T> rhs) {\n  return UnorderedPointwise(tuple2_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Matches an STL-style container or a native array that contains at\n// least one element matching the given value or matcher.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   page_ids.insert(3);\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Contains(1));\n//   EXPECT_THAT(page_ids, Contains(Gt(2)));\n//   EXPECT_THAT(page_ids, Not(Contains(4)));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   EXPECT_THAT(page_lengths,\n//               Contains(::std::pair<const int, size_t>(1, 100)));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Contains(Eq(::std::string(\"tom\"))));\ntemplate <typename M>\ninline internal::ContainsMatcher<M> Contains(M matcher) {\n  return internal::ContainsMatcher<M>(matcher);\n}\n\n// Matches an STL-style container or a native array that contains only\n// elements matching the given value or matcher.\n//\n// Each(m) is semantically equivalent to Not(Contains(Not(m))). Only\n// the messages are different.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   // Each(m) matches an empty container, regardless of what m is.\n//   EXPECT_THAT(page_ids, Each(Eq(1)));\n//   EXPECT_THAT(page_ids, Each(Eq(77)));\n//\n//   page_ids.insert(3);\n//   EXPECT_THAT(page_ids, Each(Gt(0)));\n//   EXPECT_THAT(page_ids, Not(Each(Gt(4))));\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Not(Each(Lt(2))));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   page_lengths[2] = 200;\n//   page_lengths[3] = 300;\n//   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));\n//   EXPECT_THAT(page_lengths, Each(Key(Le(3))));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string(\"tom\")))));\ntemplate <typename M>\ninline internal::EachMatcher<M> Each(M matcher) {\n  return internal::EachMatcher<M>(matcher);\n}\n\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename M>\ninline internal::KeyMatcher<M> Key(M inner_matcher) {\n  return internal::KeyMatcher<M>(inner_matcher);\n}\n\n// Pair(first_matcher, second_matcher) matches a std::pair whose 'first' field\n// matches first_matcher and whose 'second' field matches second_matcher.  For\n// example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), \"foo\"))) can be used\n// to match a std::map<int, string> that contains exactly one element whose key\n// is >= 5 and whose value equals \"foo\".\ntemplate <typename FirstMatcher, typename SecondMatcher>\ninline internal::PairMatcher<FirstMatcher, SecondMatcher>\nPair(FirstMatcher first_matcher, SecondMatcher second_matcher) {\n  return internal::PairMatcher<FirstMatcher, SecondMatcher>(\n      first_matcher, second_matcher);\n}\n\n// Returns a predicate that is satisfied by anything that matches the\n// given matcher.\ntemplate <typename M>\ninline internal::MatcherAsPredicate<M> Matches(M matcher) {\n  return internal::MatcherAsPredicate<M>(matcher);\n}\n\n// Returns true iff the value matches the matcher.\ntemplate <typename T, typename M>\ninline bool Value(const T& value, M matcher) {\n  return testing::Matches(matcher)(value);\n}\n\n// Matches the value against the given matcher and explains the match\n// result to listener.\ntemplate <typename T, typename M>\ninline bool ExplainMatchResult(\n    M matcher, const T& value, MatchResultListener* listener) {\n  return SafeMatcherCast<const T&>(matcher).MatchAndExplain(value, listener);\n}\n\n#if GTEST_LANG_CXX11\n// Define variadic matcher versions. They are overloaded in\n// gmock-generated-matchers.h for the cases supported by pre C++11 compilers.\ntemplate <typename... Args>\ninline internal::AllOfMatcher<Args...> AllOf(const Args&... matchers) {\n  return internal::AllOfMatcher<Args...>(matchers...);\n}\n\ntemplate <typename... Args>\ninline internal::AnyOfMatcher<Args...> AnyOf(const Args&... matchers) {\n  return internal::AnyOfMatcher<Args...>(matchers...);\n}\n\n#endif  // GTEST_LANG_CXX11\n\n// AllArgs(m) is a synonym of m.  This is useful in\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));\n//\n// which is easier to read than\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(Eq());\ntemplate <typename InnerMatcher>\ninline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }\n\n// These macros allow using matchers to check values in Google Test\n// tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)\n// succeed iff the value matches the matcher.  If the assertion fails,\n// the value and the description of the matcher will be printed.\n#define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n#define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n\n}  // namespace testing\n\n// Include any custom callback matchers added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-matchers.h\"\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Testing/Support/Error.h", "content": "//===- llvm/Testing/Support/Error.h ---------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TESTING_SUPPORT_ERROR_H\n#define LLVM_TESTING_SUPPORT_ERROR_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Testing/Support/SupportHelpers.h\"\n\n#include \"gmock/gmock.h\"\n#include <ostream>\n\nnamespace llvm {\nnamespace detail {\nErrorHolder TakeError(Error Err);\n\ntemplate <typename T> ExpectedHolder<T> TakeExpected(Expected<T> &Exp) {\n  return {TakeError(Exp.takeError()), Exp};\n}\n\ntemplate <typename T> ExpectedHolder<T> TakeExpected(Expected<T> &&Exp) {\n  return TakeExpected(Exp);\n}\n\ntemplate <typename T>\nclass ValueMatchesMono\n    : public testing::MatcherInterface<const ExpectedHolder<T> &> {\npublic:\n  explicit ValueMatchesMono(const testing::Matcher<T> &Matcher)\n      : Matcher(Matcher) {}\n\n  bool MatchAndExplain(const ExpectedHolder<T> &Holder,\n                       testing::MatchResultListener *listener) const override {\n    if (!Holder.Success())\n      return false;\n\n    bool result = Matcher.MatchAndExplain(*Holder.Exp, listener);\n\n    if (result)\n      return result;\n    *listener << \"(\";\n    Matcher.DescribeNegationTo(listener->stream());\n    *listener << \")\";\n    return result;\n  }\n\n  void DescribeTo(std::ostream *OS) const override {\n    *OS << \"succeeded with value (\";\n    Matcher.DescribeTo(OS);\n    *OS << \")\";\n  }\n\n  void DescribeNegationTo(std::ostream *OS) const override {\n    *OS << \"did not succeed or value (\";\n    Matcher.DescribeNegationTo(OS);\n    *OS << \")\";\n  }\n\nprivate:\n  testing::Matcher<T> Matcher;\n};\n\ntemplate<typename M>\nclass ValueMatchesPoly {\npublic:\n  explicit ValueMatchesPoly(const M &Matcher) : Matcher(Matcher) {}\n\n  template <typename T>\n  operator testing::Matcher<const ExpectedHolder<T> &>() const {\n    return MakeMatcher(\n        new ValueMatchesMono<T>(testing::SafeMatcherCast<T>(Matcher)));\n  }\n\nprivate:\n  M Matcher;\n};\n\ntemplate <typename InfoT>\nclass ErrorMatchesMono : public testing::MatcherInterface<const ErrorHolder &> {\npublic:\n  explicit ErrorMatchesMono(Optional<testing::Matcher<InfoT &>> Matcher)\n      : Matcher(std::move(Matcher)) {}\n\n  bool MatchAndExplain(const ErrorHolder &Holder,\n                       testing::MatchResultListener *listener) const override {\n    if (Holder.Success())\n      return false;\n\n    if (Holder.Infos.size() > 1) {\n      *listener << \"multiple errors\";\n      return false;\n    }\n\n    auto &Info = *Holder.Infos[0];\n    if (!Info.isA<InfoT>()) {\n      *listener << \"Error was not of given type\";\n      return false;\n    }\n\n    if (!Matcher)\n      return true;\n\n    return Matcher->MatchAndExplain(static_cast<InfoT &>(Info), listener);\n  }\n\n  void DescribeTo(std::ostream *OS) const override {\n    *OS << \"failed with Error of given type\";\n    if (Matcher) {\n      *OS << \" and the error \";\n      Matcher->DescribeTo(OS);\n    }\n  }\n\n  void DescribeNegationTo(std::ostream *OS) const override {\n    *OS << \"succeeded or did not fail with the error of given type\";\n    if (Matcher) {\n      *OS << \" or the error \";\n      Matcher->DescribeNegationTo(OS);\n    }\n  }\n\nprivate:\n  Optional<testing::Matcher<InfoT &>> Matcher;\n};\n\nclass ErrorMessageMatches\n    : public testing::MatcherInterface<const ErrorHolder &> {\npublic:\n  explicit ErrorMessageMatches(\n      testing::Matcher<std::vector<std::string>> Matcher)\n      : Matcher(std::move(Matcher)) {}\n\n  bool MatchAndExplain(const ErrorHolder &Holder,\n                       testing::MatchResultListener *listener) const override {\n    std::vector<std::string> Messages;\n    for (const std::shared_ptr<ErrorInfoBase> &Info: Holder.Infos)\n      Messages.push_back(Info->message());\n\n    return Matcher.MatchAndExplain(Messages, listener);\n  }\n\n  void DescribeTo(std::ostream *OS) const override {\n    *OS << \"failed with Error whose message \";\n    Matcher.DescribeTo(OS);\n  }\n\n  void DescribeNegationTo(std::ostream *OS) const override {\n    *OS << \"failed with an Error whose message \";\n    Matcher.DescribeNegationTo(OS);\n  }\n\nprivate:\n  testing::Matcher<std::vector<std::string>> Matcher;\n};\n} // namespace detail\n\n#define EXPECT_THAT_ERROR(Err, Matcher)                                        \\\n  EXPECT_THAT(llvm::detail::TakeError(Err), Matcher)\n#define ASSERT_THAT_ERROR(Err, Matcher)                                        \\\n  ASSERT_THAT(llvm::detail::TakeError(Err), Matcher)\n\n#define EXPECT_THAT_EXPECTED(Err, Matcher)                                     \\\n  EXPECT_THAT(llvm::detail::TakeExpected(Err), Matcher)\n#define ASSERT_THAT_EXPECTED(Err, Matcher)                                     \\\n  ASSERT_THAT(llvm::detail::TakeExpected(Err), Matcher)\n\nMATCHER(Succeeded, \"\") { return arg.Success(); }\nMATCHER(Failed, \"\") { return !arg.Success(); }\n\ntemplate <typename InfoT>\ntesting::Matcher<const detail::ErrorHolder &> Failed() {\n  return MakeMatcher(new detail::ErrorMatchesMono<InfoT>(None));\n}\n\ntemplate <typename InfoT, typename M>\ntesting::Matcher<const detail::ErrorHolder &> Failed(M Matcher) {\n  return MakeMatcher(new detail::ErrorMatchesMono<InfoT>(\n      testing::SafeMatcherCast<InfoT &>(Matcher)));\n}\n\ntemplate <typename... M>\ntesting::Matcher<const detail::ErrorHolder &> FailedWithMessage(M... Matcher) {\n  static_assert(sizeof...(M) > 0, \"\");\n  return MakeMatcher(\n      new detail::ErrorMessageMatches(testing::ElementsAre(Matcher...)));\n}\n\ntemplate <typename M>\ntesting::Matcher<const detail::ErrorHolder &> FailedWithMessageArray(M Matcher) {\n  return MakeMatcher(new detail::ErrorMessageMatches(Matcher));\n}\n\ntemplate <typename M>\ndetail::ValueMatchesPoly<M> HasValue(M Matcher) {\n  return detail::ValueMatchesPoly<M>(Matcher);\n}\n\n} // namespace llvm\n\n#endif\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_pred_impl.h", "content": "// Copyright 2006, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// This file is AUTOMATICALLY GENERATED on 10/31/2011 by command\n// 'gen_gtest_pred_impl.py 5'.  DO NOT EDIT BY HAND!\n//\n// Implements a family of generic predicate assertion macros.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n\n// Makes sure this header is not included before gtest.h.\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n# error Do not include gtest_pred_impl.h directly.  Include gtest.h instead.\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n\n// This header implements a family of generic predicate assertion\n// macros:\n//\n//   ASSERT_PRED_FORMAT1(pred_format, v1)\n//   ASSERT_PRED_FORMAT2(pred_format, v1, v2)\n//   ...\n//\n// where pred_format is a function or functor that takes n (in the\n// case of ASSERT_PRED_FORMATn) values and their source expression\n// text, and returns a testing::AssertionResult.  See the definition\n// of ASSERT_EQ in gtest.h for an example.\n//\n// If you don't care about formatting, you can use the more\n// restrictive version:\n//\n//   ASSERT_PRED1(pred, v1)\n//   ASSERT_PRED2(pred, v1, v2)\n//   ...\n//\n// where pred is an n-ary function or functor that returns bool,\n// and the values v1, v2, ..., must support the << operator for\n// streaming to std::ostream.\n//\n// We also define the EXPECT_* variations.\n//\n// For now we only support predicates whose arity is at most 5.\n// Please email googletestframework@googlegroups.com if you need\n// support for higher arities.\n\n// GTEST_ASSERT_ is the basic statement to which all of the assertions\n// in this file reduce.  Don't use this in your code.\n\n#define GTEST_ASSERT_(expression, on_failure) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar = (expression)) \\\n    ; \\\n  else \\\n    on_failure(gtest_ar.failure_message())\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1>\nAssertionResult AssertPred1Helper(const char* pred_text,\n                                  const char* e1,\n                                  Pred pred,\n                                  const T1& v1) {\n  if (pred(v1)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT1.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT1_(pred_format, v1, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, v1), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\n#define GTEST_PRED1_(pred, v1, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred1Helper(#pred, \\\n                                             #v1, \\\n                                             pred, \\\n                                             v1), on_failure)\n\n// Unary predicate assertion macros.\n#define EXPECT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2>\nAssertionResult AssertPred2Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2) {\n  if (pred(v1, v2)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT2.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT2_(pred_format, v1, v2, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\n#define GTEST_PRED2_(pred, v1, v2, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred2Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2), on_failure)\n\n// Binary predicate assertion macros.\n#define EXPECT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3>\nAssertionResult AssertPred3Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3) {\n  if (pred(v1, v2, v3)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT3.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\n#define GTEST_PRED3_(pred, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred3Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3), on_failure)\n\n// Ternary predicate assertion macros.\n#define EXPECT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4>\nAssertionResult AssertPred4Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4) {\n  if (pred(v1, v2, v3, v4)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT4.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, v1, v2, v3, v4), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\n#define GTEST_PRED4_(pred, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred4Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4), on_failure)\n\n// 4-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4,\n          typename T5>\nAssertionResult AssertPred5Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  const char* e5,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4,\n                                  const T5& v5) {\n  if (pred(v1, v2, v3, v4, v5)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \", \"\n                            << e5 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4\n                            << \"\\n\" << e5 << \" evaluates to \" << v5;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT5.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, #v5, v1, v2, v3, v4, v5), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\n#define GTEST_PRED5_(pred, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred5Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             #v5, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4, \\\n                                             v5), on_failure)\n\n// 5-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n\n\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-matchers.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-matchers.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used variadic matchers.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <vector>\n#include \"gmock/gmock-matchers.h\"\n\nnamespace testing {\nnamespace internal {\n\n// The type of the i-th (0-based) field of Tuple.\n#define GMOCK_FIELD_TYPE_(Tuple, i) \\\n    typename ::testing::tuple_element<i, Tuple>::type\n\n// TupleFields<Tuple, k0, ..., kn> is for selecting fields from a\n// tuple of type Tuple.  It has two members:\n//\n//   type: a tuple type whose i-th field is the ki-th field of Tuple.\n//   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.\n//\n// For example, in class TupleFields<tuple<bool, char, int>, 2, 0>, we have:\n//\n//   type is tuple<int, bool>, and\n//   GetSelectedFields(make_tuple(true, 'a', 42)) is (42, true).\n\ntemplate <class Tuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass TupleFields;\n\n// This generic version is used when there are 10 selectors.\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8, int k9>\nclass TupleFields {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8),\n      GMOCK_FIELD_TYPE_(Tuple, k9)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t), get<k9>(t));\n  }\n};\n\n// The following specialization is used for 0 ~ 9 selectors.\n\ntemplate <class Tuple>\nclass TupleFields<Tuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<> type;\n  static type GetSelectedFields(const Tuple& /* t */) {\n    return type();\n  }\n};\n\ntemplate <class Tuple, int k0>\nclass TupleFields<Tuple, k0, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1>\nclass TupleFields<Tuple, k0, k1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2>\nclass TupleFields<Tuple, k0, k1, k2, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3>\nclass TupleFields<Tuple, k0, k1, k2, k3, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t));\n  }\n};\n\n#undef GMOCK_FIELD_TYPE_\n\n// Implements the Args() matcher.\ntemplate <class ArgsTuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass ArgsMatcherImpl : public MatcherInterface<ArgsTuple> {\n public:\n  // ArgsTuple may have top-level const or reference modifiers.\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(ArgsTuple) RawArgsTuple;\n  typedef typename internal::TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5,\n      k6, k7, k8, k9>::type SelectedArgs;\n  typedef Matcher<const SelectedArgs&> MonomorphicInnerMatcher;\n\n  template <typename InnerMatcher>\n  explicit ArgsMatcherImpl(const InnerMatcher& inner_matcher)\n      : inner_matcher_(SafeMatcherCast<const SelectedArgs&>(inner_matcher)) {}\n\n  virtual bool MatchAndExplain(ArgsTuple args,\n                               MatchResultListener* listener) const {\n    const SelectedArgs& selected_args = GetSelectedArgs(args);\n    if (!listener->IsInterested())\n      return inner_matcher_.Matches(selected_args);\n\n    PrintIndices(listener->stream());\n    *listener << \"are \" << PrintToString(selected_args);\n\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(selected_args,\n                                                      &inner_listener);\n    PrintIfNotEmpty(inner_listener.str(), listener->stream());\n    return match;\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeNegationTo(os);\n  }\n\n private:\n  static SelectedArgs GetSelectedArgs(ArgsTuple args) {\n    return TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8,\n        k9>::GetSelectedFields(args);\n  }\n\n  // Prints the indices of the selected fields.\n  static void PrintIndices(::std::ostream* os) {\n    *os << \"whose fields (\";\n    const int indices[10] = { k0, k1, k2, k3, k4, k5, k6, k7, k8, k9 };\n    for (int i = 0; i < 10; i++) {\n      if (indices[i] < 0)\n        break;\n\n      if (i >= 1)\n        *os << \", \";\n\n      *os << \"#\" << indices[i];\n    }\n    *os << \") \";\n  }\n\n  const MonomorphicInnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcherImpl);\n};\n\ntemplate <class InnerMatcher, int k0 = -1, int k1 = -1, int k2 = -1,\n    int k3 = -1, int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1,\n    int k8 = -1, int k9 = -1>\nclass ArgsMatcher {\n public:\n  explicit ArgsMatcher(const InnerMatcher& inner_matcher)\n      : inner_matcher_(inner_matcher) {}\n\n  template <typename ArgsTuple>\n  operator Matcher<ArgsTuple>() const {\n    return MakeMatcher(new ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5,\n        k6, k7, k8, k9>(inner_matcher_));\n  }\n\n private:\n  const InnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcher);\n};\n\n// A set of metafunctions for computing the result type of AllOf.\n// AllOf(m1, ..., mN) returns\n// AllOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AllOf isn't defined for one argument, AllOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AllOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AllOfResult2 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AllOfResult3 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AllOfResult4 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AllOfResult5 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AllOfResult6 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AllOfResult7 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AllOfResult8 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AllOfResult9 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AllOfResult10 {\n  typedef BothOfMatcher<\n      typename AllOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AllOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n// A set of metafunctions for computing the result type of AnyOf.\n// AnyOf(m1, ..., mN) returns\n// AnyOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AnyOf isn't defined for one argument, AnyOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AnyOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AnyOfResult2 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AnyOfResult3 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AnyOfResult4 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AnyOfResult5 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AnyOfResult6 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AnyOfResult7 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AnyOfResult8 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AnyOfResult9 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AnyOfResult10 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AnyOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n}  // namespace internal\n\n// Args<N1, N2, ..., Nk>(a_matcher) matches a tuple if the selected\n// fields of it matches a_matcher.  C++ doesn't support default\n// arguments for function templates, so we have to overload it.\ntemplate <typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher>(matcher);\n}\n\ntemplate <int k1, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1>(matcher);\n}\n\ntemplate <int k1, int k2, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6,\n      k7>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7,\n      k8>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, int k10, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9,\n    k10>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9, k10>(matcher);\n}\n\n// ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with\n// n elements, where the i-th element in the container must\n// match the i-th argument in the list.  Each argument of\n// ElementsAre() can be either a value or a matcher.  We support up to\n// 10 arguments.\n//\n// The use of DecayArray in the implementation allows ElementsAre()\n// to accept string literals, whose type is const char[N], but we\n// want to treat them as const char*.\n//\n// NOTE: Since ElementsAre() cares about the order of the elements, it\n// must not be used with containers whose elements's order is\n// undefined (e.g. hash_map).\n\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<> >\nElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::ElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9, e10));\n}\n\n// UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension\n// that matches n elements in any order.  We support up to n=10 arguments.\n\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<> >\nUnorderedElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nUnorderedElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9, e10));\n}\n\n// AllOf(m1, m2, ..., mk) matches any value that matches all of the given\n// sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AllOfResult2<M1, M2>::type\nAllOf(M1 m1, M2 m2) {\n  return typename internal::AllOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AllOfResult3<M1, M2, M3>::type\nAllOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AllOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AllOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AllOfResult4<M1, M2, M3, M4>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AllOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AllOf(m1, m2, m3, m4, m5),\n      ::testing::AllOf(m6, m7, m8, m9, m10));\n}\n\n// AnyOf(m1, m2, ..., mk) matches any value that matches any of the given\n// sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AnyOfResult2<M1, M2>::type\nAnyOf(M1 m1, M2 m2) {\n  return typename internal::AnyOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AnyOfResult3<M1, M2, M3>::type\nAnyOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AnyOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AnyOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AnyOfResult4<M1, M2, M3, M4>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AnyOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AnyOf(m1, m2, m3, m4, m5),\n      ::testing::AnyOf(m6, m7, m8, m9, m10));\n}\n\n}  // namespace testing\n\n\n// The MATCHER* family of macros can be used in a namespace scope to\n// define custom matchers easily.\n//\n// Basic Usage\n// ===========\n//\n// The syntax\n//\n//   MATCHER(name, description_string) { statements; }\n//\n// defines a matcher with the given name that executes the statements,\n// which must return a bool to indicate if the match succeeds.  Inside\n// the statements, you can refer to the value being matched by 'arg',\n// and refer to its type by 'arg_type'.\n//\n// The description string documents what the matcher does, and is used\n// to generate the failure message when the match fails.  Since a\n// MATCHER() is usually defined in a header file shared by multiple\n// C++ source files, we require the description to be a C-string\n// literal to avoid possible side effects.  It can be empty, in which\n// case we'll use the sequence of words in the matcher name as the\n// description.\n//\n// For example:\n//\n//   MATCHER(IsEven, \"\") { return (arg % 2) == 0; }\n//\n// allows you to write\n//\n//   // Expects mock_foo.Bar(n) to be called where n is even.\n//   EXPECT_CALL(mock_foo, Bar(IsEven()));\n//\n// or,\n//\n//   // Verifies that the value of some_expression is even.\n//   EXPECT_THAT(some_expression, IsEven());\n//\n// If the above assertion fails, it will print something like:\n//\n//   Value of: some_expression\n//   Expected: is even\n//     Actual: 7\n//\n// where the description \"is even\" is automatically calculated from the\n// matcher name IsEven.\n//\n// Argument Type\n// =============\n//\n// Note that the type of the value being matched (arg_type) is\n// determined by the context in which you use the matcher and is\n// supplied to you by the compiler, so you don't need to worry about\n// declaring it (nor can you).  This allows the matcher to be\n// polymorphic.  For example, IsEven() can be used to match any type\n// where the value of \"(arg % 2) == 0\" can be implicitly converted to\n// a bool.  In the \"Bar(IsEven())\" example above, if method Bar()\n// takes an int, 'arg_type' will be int; if it takes an unsigned long,\n// 'arg_type' will be unsigned long; and so on.\n//\n// Parameterizing Matchers\n// =======================\n//\n// Sometimes you'll want to parameterize the matcher.  For that you\n// can use another macro:\n//\n//   MATCHER_P(name, param_name, description_string) { statements; }\n//\n// For example:\n//\n//   MATCHER_P(HasAbsoluteValue, value, \"\") { return abs(arg) == value; }\n//\n// will allow you to write:\n//\n//   EXPECT_THAT(Blah(\"a\"), HasAbsoluteValue(n));\n//\n// which may lead to this message (assuming n is 10):\n//\n//   Value of: Blah(\"a\")\n//   Expected: has absolute value 10\n//     Actual: -9\n//\n// Note that both the matcher description and its parameter are\n// printed, making the message human-friendly.\n//\n// In the matcher definition body, you can write 'foo_type' to\n// reference the type of a parameter named 'foo'.  For example, in the\n// body of MATCHER_P(HasAbsoluteValue, value) above, you can write\n// 'value_type' to refer to the type of 'value'.\n//\n// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to\n// support multi-parameter matchers.\n//\n// Describing Parameterized Matchers\n// =================================\n//\n// The last argument to MATCHER*() is a string-typed expression.  The\n// expression can reference all of the matcher's parameters and a\n// special bool-typed variable named 'negation'.  When 'negation' is\n// false, the expression should evaluate to the matcher's description;\n// otherwise it should evaluate to the description of the negation of\n// the matcher.  For example,\n//\n//   using testing::PrintToString;\n//\n//   MATCHER_P2(InClosedRange, low, hi,\n//       string(negation ? \"is not\" : \"is\") + \" in range [\" +\n//       PrintToString(low) + \", \" + PrintToString(hi) + \"]\") {\n//     return low <= arg && arg <= hi;\n//   }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: is in range [4, 6]\n//   ...\n//   Expected: is not in range [2, 4]\n//\n// If you specify \"\" as the description, the failure message will\n// contain the sequence of words in the matcher name followed by the\n// parameter values printed as a tuple.  For example,\n//\n//   MATCHER_P2(InClosedRange, low, hi, \"\") { ... }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: in closed range (4, 6)\n//   ...\n//   Expected: not (in closed range (2, 4))\n//\n// Types of Matcher Parameters\n// ===========================\n//\n// For the purpose of typing, you can view\n//\n//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }\n//\n// as shorthand for\n//\n//   template <typename p1_type, ..., typename pk_type>\n//   FooMatcherPk<p1_type, ..., pk_type>\n//   Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// When you write Foo(v1, ..., vk), the compiler infers the types of\n// the parameters v1, ..., and vk for you.  If you are not happy with\n// the result of the type inference, you can specify the types by\n// explicitly instantiating the template, as in Foo<long, bool>(5,\n// false).  As said earlier, you don't get to (or need to) specify\n// 'arg_type' as that's determined by the context in which the matcher\n// is used.  You can assign the result of expression Foo(p1, ..., pk)\n// to a variable of type FooMatcherPk<p1_type, ..., pk_type>.  This\n// can be useful when composing matchers.\n//\n// While you can instantiate a matcher template with reference types,\n// passing the parameters by pointer usually makes your code more\n// readable.  If, however, you still want to pass a parameter by\n// reference, be aware that in the failure message generated by the\n// matcher you will see the value of the referenced object but not its\n// address.\n//\n// Explaining Match Results\n// ========================\n//\n// Sometimes the matcher description alone isn't enough to explain why\n// the match has failed or succeeded.  For example, when expecting a\n// long string, it can be very helpful to also print the diff between\n// the expected string and the actual one.  To achieve that, you can\n// optionally stream additional information to a special variable\n// named result_listener, whose type is a pointer to class\n// MatchResultListener:\n//\n//   MATCHER_P(EqualsLongString, str, \"\") {\n//     if (arg == str) return true;\n//\n//     *result_listener << \"the difference: \"\n///                     << DiffStrings(str, arg);\n//     return false;\n//   }\n//\n// Overloading Matchers\n// ====================\n//\n// You can overload matchers with different numbers of parameters:\n//\n//   MATCHER_P(Blah, a, description_string1) { ... }\n//   MATCHER_P2(Blah, a, b, description_string2) { ... }\n//\n// Caveats\n// =======\n//\n// When defining a new matcher, you should also consider implementing\n// MatcherInterface or using MakePolymorphicMatcher().  These\n// approaches require more work than the MATCHER* macros, but also\n// give you more control on the types of the value being matched and\n// the matcher parameters, which may leads to better compiler error\n// messages when the matcher is used wrong.  They also allow\n// overloading matchers based on parameter types (as opposed to just\n// based on the number of parameters).\n//\n// MATCHER*() can only be used in a namespace scope.  The reason is\n// that C++ doesn't yet allow function-local types to be used to\n// instantiate templates.  The up-coming C++0x standard will fix this.\n// Once that's done, we'll consider supporting using MATCHER*() inside\n// a function.\n//\n// More Information\n// ================\n//\n// To learn more about using these macros, please search for 'MATCHER'\n// on http://code.google.com/p/googlemock/wiki/CookBook.\n\n#define MATCHER(name, description)\\\n  class name##Matcher {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl()\\\n           {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<>()));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>());\\\n    }\\\n    name##Matcher() {\\\n    }\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##Matcher);\\\n  };\\\n  inline name##Matcher name() {\\\n    return name##Matcher();\\\n  }\\\n  template <typename arg_type>\\\n  bool name##Matcher::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P(name, p0, description)\\\n  template <typename p0##_type>\\\n  class name##MatcherP {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      explicit gmock_Impl(p0##_type gmock_p0)\\\n           : p0(gmock_p0) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type>(p0)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0));\\\n    }\\\n    explicit name##MatcherP(p0##_type gmock_p0) : p0(gmock_p0) {\\\n    }\\\n    p0##_type p0;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP);\\\n  };\\\n  template <typename p0##_type>\\\n  inline name##MatcherP<p0##_type> name(p0##_type p0) {\\\n    return name##MatcherP<p0##_type>(p0);\\\n  }\\\n  template <typename p0##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP<p0##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P2(name, p0, p1, description)\\\n  template <typename p0##_type, typename p1##_type>\\\n  class name##MatcherP2 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1)\\\n           : p0(gmock_p0), p1(gmock_p1) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type>(p0, p1)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1));\\\n    }\\\n    name##MatcherP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n        p1(gmock_p1) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP2);\\\n  };\\\n  template <typename p0##_type, typename p1##_type>\\\n  inline name##MatcherP2<p0##_type, p1##_type> name(p0##_type p0, \\\n      p1##_type p1) {\\\n    return name##MatcherP2<p0##_type, p1##_type>(p0, p1);\\\n  }\\\n  template <typename p0##_type, typename p1##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP2<p0##_type, \\\n      p1##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P3(name, p0, p1, p2, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  class name##MatcherP3 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type>(p0, p1, \\\n                    p2)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2));\\\n    }\\\n    name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP3);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  inline name##MatcherP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2) {\\\n    return name##MatcherP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP3<p0##_type, p1##_type, \\\n      p2##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P4(name, p0, p1, p2, p3, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  class name##MatcherP4 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, \\\n                    p3##_type>(p0, p1, p2, p3)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3));\\\n    }\\\n    name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP4);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  inline name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3) {\\\n    return name##MatcherP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, \\\n        p1, p2, p3);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P5(name, p0, p1, p2, p3, p4, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  class name##MatcherP5 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type>(p0, p1, p2, p3, p4)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4));\\\n    }\\\n    name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, \\\n        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP5);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  inline name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4) {\\\n    return name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type>(p0, p1, p2, p3, p4);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  class name##MatcherP6 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5));\\\n    }\\\n    name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP6);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  inline name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3, p4##_type p4, p5##_type p5) {\\\n    return name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  class name##MatcherP7 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, \\\n                    p6)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6));\\\n    }\\\n    name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \\\n        p6(gmock_p6) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP7);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  inline name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \\\n      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6) {\\\n    return name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  class name##MatcherP8 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, \\\n                    p3, p4, p5, p6, p7)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7));\\\n    }\\\n    name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, \\\n        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP8);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  inline name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6, p7##_type p7) {\\\n    return name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \\\n        p6, p7);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, \\\n      p7##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  class name##MatcherP9 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, \\\n                    p8##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8));\\\n    }\\\n    name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP9);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  inline name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, \\\n      p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \\\n      p8##_type p8) {\\\n    return name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \\\n        p3, p4, p5, p6, p7, p8);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, p7##_type, \\\n      p8##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  class name##MatcherP10 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n          p9##_type gmock_p9)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8), p9(gmock_p9) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n      p9##_type p9;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n                    p9##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));\\\n    }\\\n    name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n    p9##_type p9;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP10);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  inline name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n      p9##_type p9) {\\\n    return name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \\\n        p1, p2, p3, p4, p5, p6, p7, p8, p9);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n"}, "52": {"id": 52, "path": "/usr/include/python3.8/Python.h", "content": "#ifndef Py_PYTHON_H\n#define Py_PYTHON_H\n/* Since this is a \"meta-include\" file, no #ifdef __cplusplus / extern \"C\" { */\n\n/* Include nearly all Python header files */\n\n#include \"patchlevel.h\"\n#include \"pyconfig.h\"\n#include \"pymacconfig.h\"\n\n#include <limits.h>\n\n#ifndef UCHAR_MAX\n#error \"Something's broken.  UCHAR_MAX should be defined in limits.h.\"\n#endif\n\n#if UCHAR_MAX != 255\n#error \"Python's source code assumes C's unsigned char is an 8-bit type.\"\n#endif\n\n#if defined(__sgi) && !defined(_SGI_MP_SOURCE)\n#define _SGI_MP_SOURCE\n#endif\n\n#include <stdio.h>\n#ifndef NULL\n#   error \"Python.h requires that stdio.h define NULL.\"\n#endif\n\n#include <string.h>\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#include <stdlib.h>\n#ifndef MS_WINDOWS\n#include <unistd.h>\n#endif\n#ifdef HAVE_CRYPT_H\n#if defined(HAVE_CRYPT_R) && !defined(_GNU_SOURCE)\n/* Required for glibc to expose the crypt_r() function prototype. */\n#  define _GNU_SOURCE\n#  define _Py_GNU_SOURCE_FOR_CRYPT\n#endif\n#include <crypt.h>\n#ifdef _Py_GNU_SOURCE_FOR_CRYPT\n/* Don't leak the _GNU_SOURCE define to other headers. */\n#  undef _GNU_SOURCE\n#  undef _Py_GNU_SOURCE_FOR_CRYPT\n#endif\n#endif\n\n/* For size_t? */\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n/* CAUTION:  Build setups should ensure that NDEBUG is defined on the\n * compiler command line when building Python in release mode; else\n * assert() calls won't be removed.\n */\n#include <assert.h>\n\n#include \"pyport.h\"\n#include \"pymacro.h\"\n\n/* A convenient way for code to know if clang's memory sanitizer is enabled. */\n#if defined(__has_feature)\n#  if __has_feature(memory_sanitizer)\n#    if !defined(_Py_MEMORY_SANITIZER)\n#      define _Py_MEMORY_SANITIZER\n#    endif\n#  endif\n#endif\n\n/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.\n *  PYMALLOC_DEBUG is in error if pymalloc is not in use.\n */\n#if defined(Py_DEBUG) && defined(WITH_PYMALLOC) && !defined(PYMALLOC_DEBUG)\n#define PYMALLOC_DEBUG\n#endif\n#if defined(PYMALLOC_DEBUG) && !defined(WITH_PYMALLOC)\n#error \"PYMALLOC_DEBUG requires WITH_PYMALLOC\"\n#endif\n#include \"pymath.h\"\n#include \"pytime.h\"\n#include \"pymem.h\"\n\n#include \"object.h\"\n#include \"objimpl.h\"\n#include \"typeslots.h\"\n#include \"pyhash.h\"\n\n#include \"pydebug.h\"\n\n#include \"bytearrayobject.h\"\n#include \"bytesobject.h\"\n#include \"unicodeobject.h\"\n#include \"longobject.h\"\n#include \"longintrepr.h\"\n#include \"boolobject.h\"\n#include \"floatobject.h\"\n#include \"complexobject.h\"\n#include \"rangeobject.h\"\n#include \"memoryobject.h\"\n#include \"tupleobject.h\"\n#include \"listobject.h\"\n#include \"dictobject.h\"\n#include \"odictobject.h\"\n#include \"enumobject.h\"\n#include \"setobject.h\"\n#include \"methodobject.h\"\n#include \"moduleobject.h\"\n#include \"funcobject.h\"\n#include \"classobject.h\"\n#include \"fileobject.h\"\n#include \"pycapsule.h\"\n#include \"traceback.h\"\n#include \"sliceobject.h\"\n#include \"cellobject.h\"\n#include \"iterobject.h\"\n#include \"genobject.h\"\n#include \"descrobject.h\"\n#include \"warnings.h\"\n#include \"weakrefobject.h\"\n#include \"structseq.h\"\n#include \"namespaceobject.h\"\n#include \"picklebufobject.h\"\n\n#include \"codecs.h\"\n#include \"pyerrors.h\"\n\n#include \"cpython/initconfig.h\"\n#include \"pystate.h\"\n#include \"context.h\"\n\n#include \"pyarena.h\"\n#include \"modsupport.h\"\n#include \"compile.h\"\n#include \"pythonrun.h\"\n#include \"pylifecycle.h\"\n#include \"ceval.h\"\n#include \"sysmodule.h\"\n#include \"osmodule.h\"\n#include \"intrcheck.h\"\n#include \"import.h\"\n\n#include \"abstract.h\"\n#include \"bltinmodule.h\"\n\n#include \"eval.h\"\n\n#include \"pyctype.h\"\n#include \"pystrtod.h\"\n#include \"pystrcmp.h\"\n#include \"dtoa.h\"\n#include \"fileutils.h\"\n#include \"pyfpe.h\"\n#include \"tracemalloc.h\"\n\n#endif /* !Py_PYTHON_H */\n"}, "53": {"id": 53, "path": "/usr/include/python3.8/abstract.h", "content": "/* Abstract Object Interface (many thanks to Jim Fulton) */\n\n#ifndef Py_ABSTRACTOBJECT_H\n#define Py_ABSTRACTOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* === Object Protocol ================================================== */\n\n/* Implemented elsewhere:\n\n   int PyObject_Print(PyObject *o, FILE *fp, int flags);\n\n   Print an object 'o' on file 'fp'.  Returns -1 on error. The flags argument\n   is used to enable certain printing options. The only option currently\n   supported is Py_Print_RAW.\n\n   (What should be said about Py_Print_RAW?). */\n\n\n/* Implemented elsewhere:\n\n   int PyObject_HasAttrString(PyObject *o, const char *attr_name);\n\n   Returns 1 if object 'o' has the attribute attr_name, and 0 otherwise.\n\n   This is equivalent to the Python expression: hasattr(o,attr_name).\n\n   This function always succeeds. */\n\n\n/* Implemented elsewhere:\n\n   PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name);\n\n   Retrieve an attributed named attr_name form object o.\n   Returns the attribute value on success, or NULL on failure.\n\n   This is the equivalent of the Python expression: o.attr_name. */\n\n\n/* Implemented elsewhere:\n\n   int PyObject_HasAttr(PyObject *o, PyObject *attr_name);\n\n   Returns 1 if o has the attribute attr_name, and 0 otherwise.\n\n   This is equivalent to the Python expression: hasattr(o,attr_name).\n\n   This function always succeeds. */\n\n/* Implemented elsewhere:\n\n   PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);\n\n   Retrieve an attributed named 'attr_name' form object 'o'.\n   Returns the attribute value on success, or NULL on failure.\n\n   This is the equivalent of the Python expression: o.attr_name. */\n\n\n/* Implemented elsewhere:\n\n   int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v);\n\n   Set the value of the attribute named attr_name, for object 'o',\n   to the value 'v'. Raise an exception and return -1 on failure; return 0 on\n   success.\n\n   This is the equivalent of the Python statement o.attr_name=v. */\n\n\n/* Implemented elsewhere:\n\n   int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);\n\n   Set the value of the attribute named attr_name, for object 'o', to the value\n   'v'. an exception and return -1 on failure; return 0 on success.\n\n   This is the equivalent of the Python statement o.attr_name=v. */\n\n/* Implemented as a macro:\n\n   int PyObject_DelAttrString(PyObject *o, const char *attr_name);\n\n   Delete attribute named attr_name, for object o. Returns\n   -1 on failure.\n\n   This is the equivalent of the Python statement: del o.attr_name. */\n#define PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A), NULL)\n\n\n/* Implemented as a macro:\n\n   int PyObject_DelAttr(PyObject *o, PyObject *attr_name);\n\n   Delete attribute named attr_name, for object o. Returns -1\n   on failure.  This is the equivalent of the Python\n   statement: del o.attr_name. */\n#define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A), NULL)\n\n\n/* Implemented elsewhere:\n\n   PyObject *PyObject_Repr(PyObject *o);\n\n   Compute the string representation of object 'o'.  Returns the\n   string representation on success, NULL on failure.\n\n   This is the equivalent of the Python expression: repr(o).\n\n   Called by the repr() built-in function. */\n\n\n/* Implemented elsewhere:\n\n   PyObject *PyObject_Str(PyObject *o);\n\n   Compute the string representation of object, o.  Returns the\n   string representation on success, NULL on failure.\n\n   This is the equivalent of the Python expression: str(o).\n\n   Called by the str() and print() built-in functions. */\n\n\n/* Declared elsewhere\n\n   PyAPI_FUNC(int) PyCallable_Check(PyObject *o);\n\n   Determine if the object, o, is callable.  Return 1 if the object is callable\n   and 0 otherwise.\n\n   This function always succeeds. */\n\n\n#ifdef PY_SSIZE_T_CLEAN\n#  define PyObject_CallFunction _PyObject_CallFunction_SizeT\n#  define PyObject_CallMethod _PyObject_CallMethod_SizeT\n#endif\n\n\n/* Call a callable Python object 'callable' with arguments given by the\n   tuple 'args' and keywords arguments given by the dictionary 'kwargs'.\n\n   'args' must not be NULL, use an empty tuple if no arguments are\n   needed. If no named arguments are needed, 'kwargs' can be NULL.\n\n   This is the equivalent of the Python expression:\n   callable(*args, **kwargs). */\nPyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable,\n                                     PyObject *args, PyObject *kwargs);\n\n\n/* Call a callable Python object 'callable', with arguments given by the\n   tuple 'args'.  If no arguments are needed, then 'args' can be NULL.\n\n   Returns the result of the call on success, or NULL on failure.\n\n   This is the equivalent of the Python expression:\n   callable(*args). */\nPyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable,\n                                           PyObject *args);\n\n/* Call a callable Python object, callable, with a variable number of C\n   arguments. The C arguments are described using a mkvalue-style format\n   string.\n\n   The format may be NULL, indicating that no arguments are provided.\n\n   Returns the result of the call on success, or NULL on failure.\n\n   This is the equivalent of the Python expression:\n   callable(arg1, arg2, ...). */\nPyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable,\n                                             const char *format, ...);\n\n/* Call the method named 'name' of object 'obj' with a variable number of\n   C arguments.  The C arguments are described by a mkvalue format string.\n\n   The format can be NULL, indicating that no arguments are provided.\n\n   Returns the result of the call on success, or NULL on failure.\n\n   This is the equivalent of the Python expression:\n   obj.name(arg1, arg2, ...). */\nPyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *obj,\n                                           const char *name,\n                                           const char *format, ...);\n\nPyAPI_FUNC(PyObject *) _PyObject_CallFunction_SizeT(PyObject *callable,\n                                                    const char *format,\n                                                    ...);\n\nPyAPI_FUNC(PyObject *) _PyObject_CallMethod_SizeT(PyObject *obj,\n                                                  const char *name,\n                                                  const char *format,\n                                                  ...);\n\n/* Call a callable Python object 'callable' with a variable number of C\n   arguments. The C arguments are provided as PyObject* values, terminated\n   by a NULL.\n\n   Returns the result of the call on success, or NULL on failure.\n\n   This is the equivalent of the Python expression:\n   callable(arg1, arg2, ...). */\nPyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,\n                                                    ...);\n\n/* Call the method named 'name' of object 'obj' with a variable number of\n   C arguments.  The C arguments are provided as PyObject* values, terminated\n   by NULL.\n\n   Returns the result of the call on success, or NULL on failure.\n\n   This is the equivalent of the Python expression: obj.name(*args). */\n\nPyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(\n    PyObject *obj,\n    PyObject *name,\n    ...);\n\n\n/* Implemented elsewhere:\n\n   Py_hash_t PyObject_Hash(PyObject *o);\n\n   Compute and return the hash, hash_value, of an object, o.  On\n   failure, return -1.\n\n   This is the equivalent of the Python expression: hash(o). */\n\n\n/* Implemented elsewhere:\n\n   int PyObject_IsTrue(PyObject *o);\n\n   Returns 1 if the object, o, is considered to be true, 0 if o is\n   considered to be false and -1 on failure.\n\n   This is equivalent to the Python expression: not not o. */\n\n\n/* Implemented elsewhere:\n\n   int PyObject_Not(PyObject *o);\n\n   Returns 0 if the object, o, is considered to be true, 1 if o is\n   considered to be false and -1 on failure.\n\n   This is equivalent to the Python expression: not o. */\n\n\n/* Get the type of an object.\n\n   On success, returns a type object corresponding to the object type of object\n   'o'. On failure, returns NULL.\n\n   This is equivalent to the Python expression: type(o) */\nPyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);\n\n\n/* Return the size of object 'o'.  If the object 'o' provides both sequence and\n   mapping protocols, the sequence size is returned.\n\n   On error, -1 is returned.\n\n   This is the equivalent to the Python expression: len(o) */\nPyAPI_FUNC(Py_ssize_t) PyObject_Size(PyObject *o);\n\n\n/* For DLL compatibility */\n#undef PyObject_Length\nPyAPI_FUNC(Py_ssize_t) PyObject_Length(PyObject *o);\n#define PyObject_Length PyObject_Size\n\n/* Return element of 'o' corresponding to the object 'key'. Return NULL\n  on failure.\n\n  This is the equivalent of the Python expression: o[key] */\nPyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);\n\n\n/* Map the object 'key' to the value 'v' into 'o'.\n\n   Raise an exception and return -1 on failure; return 0 on success.\n\n   This is the equivalent of the Python statement: o[key]=v. */\nPyAPI_FUNC(int) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);\n\n/* Remove the mapping for the string 'key' from the object 'o'.\n   Returns -1 on failure.\n\n   This is equivalent to the Python statement: del o[key]. */\nPyAPI_FUNC(int) PyObject_DelItemString(PyObject *o, const char *key);\n\n/* Delete the mapping for the object 'key' from the object 'o'.\n   Returns -1 on failure.\n\n   This is the equivalent of the Python statement: del o[key]. */\nPyAPI_FUNC(int) PyObject_DelItem(PyObject *o, PyObject *key);\n\n\n/* === Old Buffer API ============================================ */\n\n/* FIXME:  usage of these should all be replaced in Python itself\n   but for backwards compatibility we will implement them.\n   Their usage without a corresponding \"unlock\" mechanism\n   may create issues (but they would already be there). */\n\n/* Takes an arbitrary object which must support the (character, single segment)\n   buffer interface and returns a pointer to a read-only memory location\n   useable as character based input for subsequent processing.\n\n   Return 0 on success.  buffer and buffer_len are only set in case no error\n   occurs. Otherwise, -1 is returned and an exception set. */\nPy_DEPRECATED(3.0)\nPyAPI_FUNC(int) PyObject_AsCharBuffer(PyObject *obj,\n                                      const char **buffer,\n                                      Py_ssize_t *buffer_len);\n\n/* Checks whether an arbitrary object supports the (character, single segment)\n   buffer interface.\n\n   Returns 1 on success, 0 on failure. */\nPy_DEPRECATED(3.0) PyAPI_FUNC(int) PyObject_CheckReadBuffer(PyObject *obj);\n\n/* Same as PyObject_AsCharBuffer() except that this API expects (readable,\n   single segment) buffer interface and returns a pointer to a read-only memory\n   location which can contain arbitrary data.\n\n   0 is returned on success.  buffer and buffer_len are only set in case no\n   error occurs.  Otherwise, -1 is returned and an exception set. */\nPy_DEPRECATED(3.0)\nPyAPI_FUNC(int) PyObject_AsReadBuffer(PyObject *obj,\n                                      const void **buffer,\n                                      Py_ssize_t *buffer_len);\n\n/* Takes an arbitrary object which must support the (writable, single segment)\n   buffer interface and returns a pointer to a writable memory location in\n   buffer of size 'buffer_len'.\n\n   Return 0 on success.  buffer and buffer_len are only set in case no error\n   occurs. Otherwise, -1 is returned and an exception set. */\nPy_DEPRECATED(3.0)\nPyAPI_FUNC(int) PyObject_AsWriteBuffer(PyObject *obj,\n                                       void **buffer,\n                                       Py_ssize_t *buffer_len);\n\n\n/* === New Buffer API ============================================ */\n\n/* Takes an arbitrary object and returns the result of calling\n   obj.__format__(format_spec). */\nPyAPI_FUNC(PyObject *) PyObject_Format(PyObject *obj,\n                                       PyObject *format_spec);\n\n\n/* ==== Iterators ================================================ */\n\n/* Takes an object and returns an iterator for it.\n   This is typically a new iterator but if the argument is an iterator, this\n   returns itself. */\nPyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);\n\n/* Returns 1 if the object 'obj' provides iterator protocols, and 0 otherwise.\n\n   This function always succeeds. */\nPyAPI_FUNC(int) PyIter_Check(PyObject *);\n\n/* Takes an iterator object and calls its tp_iternext slot,\n   returning the next value.\n\n   If the iterator is exhausted, this returns NULL without setting an\n   exception.\n\n   NULL with an exception means an error occurred. */\nPyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);\n\n\n/* === Number Protocol ================================================== */\n\n/* Returns 1 if the object 'o' provides numeric protocols, and 0 otherwise.\n\n   This function always succeeds. */\nPyAPI_FUNC(int) PyNumber_Check(PyObject *o);\n\n/* Returns the result of adding o1 and o2, or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 + o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);\n\n/* Returns the result of subtracting o2 from o1, or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 - o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);\n\n/* Returns the result of multiplying o1 and o2, or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 * o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* This is the equivalent of the Python expression: o1 @ o2. */\nPyAPI_FUNC(PyObject *) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);\n#endif\n\n/* Returns the result of dividing o1 by o2 giving an integral result,\n   or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 // o2. */\nPyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);\n\n/* Returns the result of dividing o1 by o2 giving a float result, or NULL on\n   failure.\n\n   This is the equivalent of the Python expression: o1 / o2. */\nPyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);\n\n/* Returns the remainder of dividing o1 by o2, or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 % o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);\n\n/* See the built-in function divmod.\n\n   Returns NULL on failure.\n\n   This is the equivalent of the Python expression: divmod(o1, o2). */\nPyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);\n\n/* See the built-in function pow. Returns NULL on failure.\n\n   This is the equivalent of the Python expression: pow(o1, o2, o3),\n   where o3 is optional. */\nPyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,\n                                      PyObject *o3);\n\n/* Returns the negation of o on success, or NULL on failure.\n\n This is the equivalent of the Python expression: -o. */\nPyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);\n\n/* Returns the positive of o on success, or NULL on failure.\n\n   This is the equivalent of the Python expression: +o. */\nPyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);\n\n/* Returns the absolute value of 'o', or NULL on failure.\n\n   This is the equivalent of the Python expression: abs(o). */\nPyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);\n\n/* Returns the bitwise negation of 'o' on success, or NULL on failure.\n\n   This is the equivalent of the Python expression: ~o. */\nPyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);\n\n/* Returns the result of left shifting o1 by o2 on success, or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 << o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);\n\n/* Returns the result of right shifting o1 by o2 on success, or NULL on\n   failure.\n\n   This is the equivalent of the Python expression: o1 >> o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);\n\n/* Returns the result of bitwise and of o1 and o2 on success, or NULL on\n   failure.\n\n   This is the equivalent of the Python expression: o1 & o2. */\nPyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);\n\n/* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 ^ o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);\n\n/* Returns the result of bitwise or on o1 and o2 on success, or NULL on\n   failure.\n\n   This is the equivalent of the Python expression: o1 | o2. */\nPyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);\n\n/* Returns 1 if obj is an index integer (has the nb_index slot of the\n   tp_as_number structure filled in), and 0 otherwise. */\nPyAPI_FUNC(int) PyIndex_Check(PyObject *);\n\n/* Returns the object 'o' converted to a Python int, or NULL with an exception\n   raised on failure. */\nPyAPI_FUNC(PyObject *) PyNumber_Index(PyObject *o);\n\n/* Returns the object 'o' converted to Py_ssize_t by going through\n   PyNumber_Index() first.\n\n   If an overflow error occurs while converting the int to Py_ssize_t, then the\n   second argument 'exc' is the error-type to return.  If it is NULL, then the\n   overflow error is cleared and the value is clipped. */\nPyAPI_FUNC(Py_ssize_t) PyNumber_AsSsize_t(PyObject *o, PyObject *exc);\n\n/* Returns the object 'o' converted to an integer object on success, or NULL\n   on failure.\n\n   This is the equivalent of the Python expression: int(o). */\nPyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);\n\n/* Returns the object 'o' converted to a float object on success, or NULL\n  on failure.\n\n  This is the equivalent of the Python expression: float(o). */\nPyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);\n\n\n/* --- In-place variants of (some of) the above number protocol functions -- */\n\n/* Returns the result of adding o2 to o1, possibly in-place, or NULL\n   on failure.\n\n   This is the equivalent of the Python expression: o1 += o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);\n\n/* Returns the result of subtracting o2 from o1, possibly in-place or\n   NULL on failure.\n\n   This is the equivalent of the Python expression: o1 -= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);\n\n/* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on\n   failure.\n\n   This is the equivalent of the Python expression: o1 *= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* This is the equivalent of the Python expression: o1 @= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);\n#endif\n\n/* Returns the result of dividing o1 by o2 giving an integral result, possibly\n   in-place, or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 /= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,\n                                                   PyObject *o2);\n\n/* Returns the result of dividing o1 by o2 giving a float result, possibly\n   in-place, or null on failure.\n\n   This is the equivalent of the Python expression: o1 /= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,\n                                                  PyObject *o2);\n\n/* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on\n   failure.\n\n   This is the equivalent of the Python expression: o1 %= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);\n\n/* Returns the result of raising o1 to the power of o2, possibly in-place,\n   or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 **= o2,\n   or o1 = pow(o1, o2, o3) if o3 is present. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,\n                                             PyObject *o3);\n\n/* Returns the result of left shifting o1 by o2, possibly in-place, or NULL\n   on failure.\n\n   This is the equivalent of the Python expression: o1 <<= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);\n\n/* Returns the result of right shifting o1 by o2, possibly in-place or NULL\n   on failure.\n\n   This is the equivalent of the Python expression: o1 >>= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);\n\n/* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL\n   on failure.\n\n   This is the equivalent of the Python expression: o1 &= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);\n\n/* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL\n   on failure.\n\n   This is the equivalent of the Python expression: o1 ^= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);\n\n/* Returns the result of bitwise or of o1 and o2, possibly in-place,\n   or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 |= o2. */\nPyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);\n\n/* Returns the integer n converted to a string with a base, with a base\n   marker of 0b, 0o or 0x prefixed if applicable.\n\n   If n is not an int object, it is converted with PyNumber_Index first. */\nPyAPI_FUNC(PyObject *) PyNumber_ToBase(PyObject *n, int base);\n\n\n/* === Sequence protocol ================================================ */\n\n/* Return 1 if the object provides sequence protocol, and zero\n   otherwise.\n\n   This function always succeeds. */\nPyAPI_FUNC(int) PySequence_Check(PyObject *o);\n\n/* Return the size of sequence object o, or -1 on failure. */\nPyAPI_FUNC(Py_ssize_t) PySequence_Size(PyObject *o);\n\n/* For DLL compatibility */\n#undef PySequence_Length\nPyAPI_FUNC(Py_ssize_t) PySequence_Length(PyObject *o);\n#define PySequence_Length PySequence_Size\n\n\n/* Return the concatenation of o1 and o2 on success, and NULL on failure.\n\n   This is the equivalent of the Python expression: o1 + o2. */\nPyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);\n\n/* Return the result of repeating sequence object 'o' 'count' times,\n  or NULL on failure.\n\n  This is the equivalent of the Python expression: o * count. */\nPyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, Py_ssize_t count);\n\n/* Return the ith element of o, or NULL on failure.\n\n   This is the equivalent of the Python expression: o[i]. */\nPyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, Py_ssize_t i);\n\n/* Return the slice of sequence object o between i1 and i2, or NULL on failure.\n\n   This is the equivalent of the Python expression: o[i1:i2]. */\nPyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);\n\n/* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception\n   and return -1 on failure; return 0 on success.\n\n   This is the equivalent of the Python statement o[i] = v. */\nPyAPI_FUNC(int) PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v);\n\n/* Delete the 'i'-th element of the sequence 'v'. Returns -1 on failure.\n\n   This is the equivalent of the Python statement: del o[i]. */\nPyAPI_FUNC(int) PySequence_DelItem(PyObject *o, Py_ssize_t i);\n\n/* Assign the sequence object 'v' to the slice in sequence object 'o',\n   from 'i1' to 'i2'. Returns -1 on failure.\n\n   This is the equivalent of the Python statement: o[i1:i2] = v. */\nPyAPI_FUNC(int) PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2,\n                                    PyObject *v);\n\n/* Delete the slice in sequence object 'o' from 'i1' to 'i2'.\n   Returns -1 on failure.\n\n   This is the equivalent of the Python statement: del o[i1:i2]. */\nPyAPI_FUNC(int) PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);\n\n/* Returns the sequence 'o' as a tuple on success, and NULL on failure.\n\n   This is equivalent to the Python expression: tuple(o). */\nPyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);\n\n/* Returns the sequence 'o' as a list on success, and NULL on failure.\n   This is equivalent to the Python expression: list(o) */\nPyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);\n\n/* Return the sequence 'o' as a list, unless it's already a tuple or list.\n\n   Use PySequence_Fast_GET_ITEM to access the members of this list, and\n   PySequence_Fast_GET_SIZE to get its length.\n\n   Returns NULL on failure.  If the object does not support iteration, raises a\n   TypeError exception with 'm' as the message text. */\nPyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);\n\n/* Return the size of the sequence 'o', assuming that 'o' was returned by\n   PySequence_Fast and is not NULL. */\n#define PySequence_Fast_GET_SIZE(o) \\\n    (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))\n\n/* Return the 'i'-th element of the sequence 'o', assuming that o was returned\n   by PySequence_Fast, and that i is within bounds. */\n#define PySequence_Fast_GET_ITEM(o, i)\\\n     (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))\n\n/* Return a pointer to the underlying item array for\n   an object retured by PySequence_Fast */\n#define PySequence_Fast_ITEMS(sf) \\\n    (PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item \\\n                      : ((PyTupleObject *)(sf))->ob_item)\n\n/* Return the number of occurrences on value on 'o', that is, return\n   the number of keys for which o[key] == value.\n\n   On failure, return -1.  This is equivalent to the Python expression:\n   o.count(value). */\nPyAPI_FUNC(Py_ssize_t) PySequence_Count(PyObject *o, PyObject *value);\n\n/* Return 1 if 'ob' is in the sequence 'seq'; 0 if 'ob' is not in the sequence\n   'seq'; -1 on error.\n\n   Use __contains__ if possible, else _PySequence_IterSearch(). */\nPyAPI_FUNC(int) PySequence_Contains(PyObject *seq, PyObject *ob);\n\n/* For DLL-level backwards compatibility */\n#undef PySequence_In\n/* Determine if the sequence 'o' contains 'value'. If an item in 'o' is equal\n   to 'value', return 1, otherwise return 0. On error, return -1.\n\n   This is equivalent to the Python expression: value in o. */\nPyAPI_FUNC(int) PySequence_In(PyObject *o, PyObject *value);\n\n/* For source-level backwards compatibility */\n#define PySequence_In PySequence_Contains\n\n\n/* Return the first index for which o[i] == value.\n   On error, return -1.\n\n   This is equivalent to the Python expression: o.index(value). */\nPyAPI_FUNC(Py_ssize_t) PySequence_Index(PyObject *o, PyObject *value);\n\n\n/* --- In-place versions of some of the above Sequence functions --- */\n\n/* Append sequence 'o2' to sequence 'o1', in-place when possible. Return the\n   resulting object, which could be 'o1', or NULL on failure.\n\n  This is the equivalent of the Python expression: o1 += o2. */\nPyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);\n\n/* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting\n   object, which could be 'o', or NULL on failure.\n\n   This is the equivalent of the Python expression: o1 *= count.  */\nPyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);\n\n\n/* === Mapping protocol ================================================= */\n\n/* Return 1 if the object provides mapping protocol, and 0 otherwise.\n\n   This function always succeeds. */\nPyAPI_FUNC(int) PyMapping_Check(PyObject *o);\n\n/* Returns the number of keys in mapping object 'o' on success, and -1 on\n  failure. This is equivalent to the Python expression: len(o). */\nPyAPI_FUNC(Py_ssize_t) PyMapping_Size(PyObject *o);\n\n/* For DLL compatibility */\n#undef PyMapping_Length\nPyAPI_FUNC(Py_ssize_t) PyMapping_Length(PyObject *o);\n#define PyMapping_Length PyMapping_Size\n\n\n/* Implemented as a macro:\n\n   int PyMapping_DelItemString(PyObject *o, const char *key);\n\n   Remove the mapping for the string 'key' from the mapping 'o'. Returns -1 on\n   failure.\n\n   This is equivalent to the Python statement: del o[key]. */\n#define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))\n\n/* Implemented as a macro:\n\n   int PyMapping_DelItem(PyObject *o, PyObject *key);\n\n   Remove the mapping for the object 'key' from the mapping object 'o'.\n   Returns -1 on failure.\n\n   This is equivalent to the Python statement: del o[key]. */\n#define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))\n\n/* On success, return 1 if the mapping object 'o' has the key 'key',\n   and 0 otherwise.\n\n   This is equivalent to the Python expression: key in o.\n\n   This function always succeeds. */\nPyAPI_FUNC(int) PyMapping_HasKeyString(PyObject *o, const char *key);\n\n/* Return 1 if the mapping object has the key 'key', and 0 otherwise.\n\n   This is equivalent to the Python expression: key in o.\n\n   This function always succeeds. */\nPyAPI_FUNC(int) PyMapping_HasKey(PyObject *o, PyObject *key);\n\n/* On success, return a list or tuple of the keys in mapping object 'o'.\n   On failure, return NULL. */\nPyAPI_FUNC(PyObject *) PyMapping_Keys(PyObject *o);\n\n/* On success, return a list or tuple of the values in mapping object 'o'.\n   On failure, return NULL. */\nPyAPI_FUNC(PyObject *) PyMapping_Values(PyObject *o);\n\n/* On success, return a list or tuple of the items in mapping object 'o',\n   where each item is a tuple containing a key-value pair. On failure, return\n   NULL. */\nPyAPI_FUNC(PyObject *) PyMapping_Items(PyObject *o);\n\n/* Return element of 'o' corresponding to the string 'key' or NULL on failure.\n\n   This is the equivalent of the Python expression: o[key]. */\nPyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o,\n                                               const char *key);\n\n/* Map the string 'key' to the value 'v' in the mapping 'o'.\n   Returns -1 on failure.\n\n   This is the equivalent of the Python statement: o[key]=v. */\nPyAPI_FUNC(int) PyMapping_SetItemString(PyObject *o, const char *key,\n                                        PyObject *value);\n\n/* isinstance(object, typeorclass) */\nPyAPI_FUNC(int) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);\n\n/* issubclass(object, typeorclass) */\nPyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_ABSTRACTOBJECT_H\n#  include  \"cpython/abstract.h\"\n#  undef Py_CPYTHON_ABSTRACTOBJECT_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* Py_ABSTRACTOBJECT_H */\n"}, "54": {"id": 54, "path": "/usr/include/python3.8/bltinmodule.h", "content": "#ifndef Py_BLTINMODULE_H\n#define Py_BLTINMODULE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_DATA(PyTypeObject) PyFilter_Type;\nPyAPI_DATA(PyTypeObject) PyMap_Type;\nPyAPI_DATA(PyTypeObject) PyZip_Type;\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_BLTINMODULE_H */\n"}, "55": {"id": 55, "path": "/usr/include/python3.8/boolobject.h", "content": "/* Boolean object interface */\n\n#ifndef Py_BOOLOBJECT_H\n#define Py_BOOLOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n\n#define PyBool_Check(x) (Py_TYPE(x) == &PyBool_Type)\n\n/* Py_False and Py_True are the only two bools in existence.\nDon't forget to apply Py_INCREF() when returning either!!! */\n\n/* Don't use these directly */\nPyAPI_DATA(struct _longobject) _Py_FalseStruct, _Py_TrueStruct;\n\n/* Use these macros */\n#define Py_False ((PyObject *) &_Py_FalseStruct)\n#define Py_True ((PyObject *) &_Py_TrueStruct)\n\n/* Macros for returning Py_True or Py_False, respectively */\n#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True\n#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False\n\n/* Function to return a bool from a C long */\nPyAPI_FUNC(PyObject *) PyBool_FromLong(long);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_BOOLOBJECT_H */\n"}, "56": {"id": 56, "path": "/usr/include/python3.8/bytearrayobject.h", "content": "/* ByteArray object interface */\n\n#ifndef Py_BYTEARRAYOBJECT_H\n#define Py_BYTEARRAYOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdarg.h>\n\n/* Type PyByteArrayObject represents a mutable array of bytes.\n * The Python API is that of a sequence;\n * the bytes are mapped to ints in [0, 256).\n * Bytes are not characters; they may be used to encode characters.\n * The only way to go between bytes and str/unicode is via encoding\n * and decoding.\n * For the convenience of C programmers, the bytes type is considered\n * to contain a char pointer, not an unsigned char pointer.\n */\n\n/* Object layout */\n#ifndef Py_LIMITED_API\ntypedef struct {\n    PyObject_VAR_HEAD\n    Py_ssize_t ob_alloc; /* How many bytes allocated in ob_bytes */\n    char *ob_bytes;      /* Physical backing buffer */\n    char *ob_start;      /* Logical start inside ob_bytes */\n    /* XXX(nnorwitz): should ob_exports be Py_ssize_t? */\n    int ob_exports;      /* How many buffer exports */\n} PyByteArrayObject;\n#endif\n\n/* Type object */\nPyAPI_DATA(PyTypeObject) PyByteArray_Type;\nPyAPI_DATA(PyTypeObject) PyByteArrayIter_Type;\n\n/* Type check macros */\n#define PyByteArray_Check(self) PyObject_TypeCheck(self, &PyByteArray_Type)\n#define PyByteArray_CheckExact(self) (Py_TYPE(self) == &PyByteArray_Type)\n\n/* Direct API functions */\nPyAPI_FUNC(PyObject *) PyByteArray_FromObject(PyObject *);\nPyAPI_FUNC(PyObject *) PyByteArray_Concat(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);\nPyAPI_FUNC(Py_ssize_t) PyByteArray_Size(PyObject *);\nPyAPI_FUNC(char *) PyByteArray_AsString(PyObject *);\nPyAPI_FUNC(int) PyByteArray_Resize(PyObject *, Py_ssize_t);\n\n/* Macros, trading safety for speed */\n#ifndef Py_LIMITED_API\n#define PyByteArray_AS_STRING(self) \\\n    (assert(PyByteArray_Check(self)), \\\n     Py_SIZE(self) ? ((PyByteArrayObject *)(self))->ob_start : _PyByteArray_empty_string)\n#define PyByteArray_GET_SIZE(self) (assert(PyByteArray_Check(self)), Py_SIZE(self))\n\nPyAPI_DATA(char) _PyByteArray_empty_string[];\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_BYTEARRAYOBJECT_H */\n"}, "57": {"id": 57, "path": "/usr/include/python3.8/bytesobject.h", "content": "\n/* Bytes (String) object interface */\n\n#ifndef Py_BYTESOBJECT_H\n#define Py_BYTESOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdarg.h>\n\n/*\nType PyBytesObject represents a character string.  An extra zero byte is\nreserved at the end to ensure it is zero-terminated, but a size is\npresent so strings with null bytes in them can be represented.  This\nis an immutable object type.\n\nThere are functions to create new string objects, to test\nan object for string-ness, and to get the\nstring value.  The latter function returns a null pointer\nif the object is not of the proper type.\nThere is a variant that takes an explicit size as well as a\nvariant that assumes a zero-terminated string.  Note that none of the\nfunctions should be applied to nil objects.\n*/\n\n/* Caching the hash (ob_shash) saves recalculation of a string's hash value.\n   This significantly speeds up dict lookups. */\n\n#ifndef Py_LIMITED_API\ntypedef struct {\n    PyObject_VAR_HEAD\n    Py_hash_t ob_shash;\n    char ob_sval[1];\n\n    /* Invariants:\n     *     ob_sval contains space for 'ob_size+1' elements.\n     *     ob_sval[ob_size] == 0.\n     *     ob_shash is the hash of the string or -1 if not computed yet.\n     */\n} PyBytesObject;\n#endif\n\nPyAPI_DATA(PyTypeObject) PyBytes_Type;\nPyAPI_DATA(PyTypeObject) PyBytesIter_Type;\n\n#define PyBytes_Check(op) \\\n                 PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)\n#define PyBytes_CheckExact(op) (Py_TYPE(op) == &PyBytes_Type)\n\nPyAPI_FUNC(PyObject *) PyBytes_FromStringAndSize(const char *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyBytes_FromString(const char *);\nPyAPI_FUNC(PyObject *) PyBytes_FromObject(PyObject *);\nPyAPI_FUNC(PyObject *) PyBytes_FromFormatV(const char*, va_list)\n                                Py_GCC_ATTRIBUTE((format(printf, 1, 0)));\nPyAPI_FUNC(PyObject *) PyBytes_FromFormat(const char*, ...)\n                                Py_GCC_ATTRIBUTE((format(printf, 1, 2)));\nPyAPI_FUNC(Py_ssize_t) PyBytes_Size(PyObject *);\nPyAPI_FUNC(char *) PyBytes_AsString(PyObject *);\nPyAPI_FUNC(PyObject *) PyBytes_Repr(PyObject *, int);\nPyAPI_FUNC(void) PyBytes_Concat(PyObject **, PyObject *);\nPyAPI_FUNC(void) PyBytes_ConcatAndDel(PyObject **, PyObject *);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyBytes_Resize(PyObject **, Py_ssize_t);\nPyAPI_FUNC(PyObject*) _PyBytes_FormatEx(\n    const char *format,\n    Py_ssize_t format_len,\n    PyObject *args,\n    int use_bytearray);\nPyAPI_FUNC(PyObject*) _PyBytes_FromHex(\n    PyObject *string,\n    int use_bytearray);\n#endif\nPyAPI_FUNC(PyObject *) PyBytes_DecodeEscape(const char *, Py_ssize_t,\n                                            const char *, Py_ssize_t,\n                                            const char *);\n#ifndef Py_LIMITED_API\n/* Helper for PyBytes_DecodeEscape that detects invalid escape chars. */\nPyAPI_FUNC(PyObject *) _PyBytes_DecodeEscape(const char *, Py_ssize_t,\n                                             const char *, Py_ssize_t,\n                                             const char *,\n                                             const char **);\n#endif\n\n/* Macro, trading safety for speed */\n#ifndef Py_LIMITED_API\n#define PyBytes_AS_STRING(op) (assert(PyBytes_Check(op)), \\\n                                (((PyBytesObject *)(op))->ob_sval))\n#define PyBytes_GET_SIZE(op)  (assert(PyBytes_Check(op)),Py_SIZE(op))\n#endif\n\n/* _PyBytes_Join(sep, x) is like sep.join(x).  sep must be PyBytesObject*,\n   x must be an iterable object. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyBytes_Join(PyObject *sep, PyObject *x);\n#endif\n\n/* Provides access to the internal data buffer and size of a string\n   object or the default encoded version of a Unicode object. Passing\n   NULL as *len parameter will force the string buffer to be\n   0-terminated (passing a string with embedded NULL characters will\n   cause an exception).  */\nPyAPI_FUNC(int) PyBytes_AsStringAndSize(\n    PyObject *obj,      /* string or Unicode object */\n    char **s,           /* pointer to buffer variable */\n    Py_ssize_t *len     /* pointer to length variable or NULL\n                           (only possible for 0-terminated\n                           strings) */\n    );\n\n/* Using the current locale, insert the thousands grouping\n   into the string pointed to by buffer.  For the argument descriptions,\n   see Objects/stringlib/localeutil.h */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(Py_ssize_t) _PyBytes_InsertThousandsGroupingLocale(char *buffer,\n                                                   Py_ssize_t n_buffer,\n                                                   char *digits,\n                                                   Py_ssize_t n_digits,\n                                                   Py_ssize_t min_width);\n\n/* Using explicit passed-in values, insert the thousands grouping\n   into the string pointed to by buffer.  For the argument descriptions,\n   see Objects/stringlib/localeutil.h */\nPyAPI_FUNC(Py_ssize_t) _PyBytes_InsertThousandsGrouping(char *buffer,\n                                                   Py_ssize_t n_buffer,\n                                                   char *digits,\n                                                   Py_ssize_t n_digits,\n                                                   Py_ssize_t min_width,\n                                                   const char *grouping,\n                                                   const char *thousands_sep);\n#endif\n\n/* Flags used by string formatting */\n#define F_LJUST (1<<0)\n#define F_SIGN  (1<<1)\n#define F_BLANK (1<<2)\n#define F_ALT   (1<<3)\n#define F_ZERO  (1<<4)\n\n#ifndef Py_LIMITED_API\n/* The _PyBytesWriter structure is big: it contains an embedded \"stack buffer\".\n   A _PyBytesWriter variable must be declared at the end of variables in a\n   function to optimize the memory allocation on the stack. */\ntypedef struct {\n    /* bytes, bytearray or NULL (when the small buffer is used) */\n    PyObject *buffer;\n\n    /* Number of allocated size. */\n    Py_ssize_t allocated;\n\n    /* Minimum number of allocated bytes,\n       incremented by _PyBytesWriter_Prepare() */\n    Py_ssize_t min_size;\n\n    /* If non-zero, use a bytearray instead of a bytes object for buffer. */\n    int use_bytearray;\n\n    /* If non-zero, overallocate the buffer (default: 0).\n       This flag must be zero if use_bytearray is non-zero. */\n    int overallocate;\n\n    /* Stack buffer */\n    int use_small_buffer;\n    char small_buffer[512];\n} _PyBytesWriter;\n\n/* Initialize a bytes writer\n\n   By default, the overallocation is disabled. Set the overallocate attribute\n   to control the allocation of the buffer. */\nPyAPI_FUNC(void) _PyBytesWriter_Init(_PyBytesWriter *writer);\n\n/* Get the buffer content and reset the writer.\n   Return a bytes object, or a bytearray object if use_bytearray is non-zero.\n   Raise an exception and return NULL on error. */\nPyAPI_FUNC(PyObject *) _PyBytesWriter_Finish(_PyBytesWriter *writer,\n    void *str);\n\n/* Deallocate memory of a writer (clear its internal buffer). */\nPyAPI_FUNC(void) _PyBytesWriter_Dealloc(_PyBytesWriter *writer);\n\n/* Allocate the buffer to write size bytes.\n   Return the pointer to the beginning of buffer data.\n   Raise an exception and return NULL on error. */\nPyAPI_FUNC(void*) _PyBytesWriter_Alloc(_PyBytesWriter *writer,\n    Py_ssize_t size);\n\n/* Ensure that the buffer is large enough to write *size* bytes.\n   Add size to the writer minimum size (min_size attribute).\n\n   str is the current pointer inside the buffer.\n   Return the updated current pointer inside the buffer.\n   Raise an exception and return NULL on error. */\nPyAPI_FUNC(void*) _PyBytesWriter_Prepare(_PyBytesWriter *writer,\n    void *str,\n    Py_ssize_t size);\n\n/* Resize the buffer to make it larger.\n   The new buffer may be larger than size bytes because of overallocation.\n   Return the updated current pointer inside the buffer.\n   Raise an exception and return NULL on error.\n\n   Note: size must be greater than the number of allocated bytes in the writer.\n\n   This function doesn't use the writer minimum size (min_size attribute).\n\n   See also _PyBytesWriter_Prepare().\n   */\nPyAPI_FUNC(void*) _PyBytesWriter_Resize(_PyBytesWriter *writer,\n    void *str,\n    Py_ssize_t size);\n\n/* Write bytes.\n   Raise an exception and return NULL on error. */\nPyAPI_FUNC(void*) _PyBytesWriter_WriteBytes(_PyBytesWriter *writer,\n    void *str,\n    const void *bytes,\n    Py_ssize_t size);\n#endif   /* Py_LIMITED_API */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_BYTESOBJECT_H */\n"}, "58": {"id": 58, "path": "/usr/include/python3.8/cellobject.h", "content": "/* Cell object interface */\n#ifndef Py_LIMITED_API\n#ifndef Py_CELLOBJECT_H\n#define Py_CELLOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *ob_ref;       /* Content of the cell or NULL when empty */\n} PyCellObject;\n\nPyAPI_DATA(PyTypeObject) PyCell_Type;\n\n#define PyCell_Check(op) (Py_TYPE(op) == &PyCell_Type)\n\nPyAPI_FUNC(PyObject *) PyCell_New(PyObject *);\nPyAPI_FUNC(PyObject *) PyCell_Get(PyObject *);\nPyAPI_FUNC(int) PyCell_Set(PyObject *, PyObject *);\n\n#define PyCell_GET(op) (((PyCellObject *)(op))->ob_ref)\n#define PyCell_SET(op, v) (((PyCellObject *)(op))->ob_ref = v)\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_TUPLEOBJECT_H */\n#endif /* Py_LIMITED_API */\n"}, "59": {"id": 59, "path": "/usr/include/python3.8/ceval.h", "content": "#ifndef Py_CEVAL_H\n#define Py_CEVAL_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Interface to random parts in ceval.c */\n\n/* PyEval_CallObjectWithKeywords(), PyEval_CallObject(), PyEval_CallFunction\n * and PyEval_CallMethod are kept for backward compatibility: PyObject_Call(),\n * PyObject_CallFunction() and PyObject_CallMethod() are recommended to call\n * a callable object.\n */\n\nPyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(\n    PyObject *callable,\n    PyObject *args,\n    PyObject *kwargs);\n\n/* Inline this */\n#define PyEval_CallObject(callable, arg) \\\n    PyEval_CallObjectWithKeywords(callable, arg, (PyObject *)NULL)\n\nPyAPI_FUNC(PyObject *) PyEval_CallFunction(PyObject *callable,\n                                           const char *format, ...);\nPyAPI_FUNC(PyObject *) PyEval_CallMethod(PyObject *obj,\n                                         const char *name,\n                                         const char *format, ...);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(void) PyEval_SetProfile(Py_tracefunc, PyObject *);\nPyAPI_FUNC(void) PyEval_SetTrace(Py_tracefunc, PyObject *);\nPyAPI_FUNC(void) _PyEval_SetCoroutineOriginTrackingDepth(int new_depth);\nPyAPI_FUNC(int) _PyEval_GetCoroutineOriginTrackingDepth(void);\nPyAPI_FUNC(void) _PyEval_SetAsyncGenFirstiter(PyObject *);\nPyAPI_FUNC(PyObject *) _PyEval_GetAsyncGenFirstiter(void);\nPyAPI_FUNC(void) _PyEval_SetAsyncGenFinalizer(PyObject *);\nPyAPI_FUNC(PyObject *) _PyEval_GetAsyncGenFinalizer(void);\n#endif\n\nstruct _frame; /* Avoid including frameobject.h */\n\nPyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);\nPyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);\nPyAPI_FUNC(PyObject *) PyEval_GetLocals(void);\nPyAPI_FUNC(struct _frame *) PyEval_GetFrame(void);\n\n#ifndef Py_LIMITED_API\n/* Helper to look up a builtin object */\nPyAPI_FUNC(PyObject *) _PyEval_GetBuiltinId(_Py_Identifier *);\n/* Look at the current frame's (if any) code's co_flags, and turn on\n   the corresponding compiler flags in cf->cf_flags.  Return 1 if any\n   flag was set, else return 0. */\nPyAPI_FUNC(int) PyEval_MergeCompilerFlags(PyCompilerFlags *cf);\n#endif\n\nPyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);\nPyAPI_FUNC(int) Py_MakePendingCalls(void);\n\n/* Protection against deeply nested recursive calls\n\n   In Python 3.0, this protection has two levels:\n   * normal anti-recursion protection is triggered when the recursion level\n     exceeds the current recursion limit. It raises a RecursionError, and sets\n     the \"overflowed\" flag in the thread state structure. This flag\n     temporarily *disables* the normal protection; this allows cleanup code\n     to potentially outgrow the recursion limit while processing the\n     RecursionError.\n   * \"last chance\" anti-recursion protection is triggered when the recursion\n     level exceeds \"current recursion limit + 50\". By construction, this\n     protection can only be triggered when the \"overflowed\" flag is set. It\n     means the cleanup code has itself gone into an infinite loop, or the\n     RecursionError has been mistakingly ignored. When this protection is\n     triggered, the interpreter aborts with a Fatal Error.\n\n   In addition, the \"overflowed\" flag is automatically reset when the\n   recursion level drops below \"current recursion limit - 50\". This heuristic\n   is meant to ensure that the normal anti-recursion protection doesn't get\n   disabled too long.\n\n   Please note: this scheme has its own limitations. See:\n   http://mail.python.org/pipermail/python-dev/2008-August/082106.html\n   for some observations.\n*/\nPyAPI_FUNC(void) Py_SetRecursionLimit(int);\nPyAPI_FUNC(int) Py_GetRecursionLimit(void);\n\n#define Py_EnterRecursiveCall(where)  \\\n            (_Py_MakeRecCheck(PyThreadState_GET()->recursion_depth) &&  \\\n             _Py_CheckRecursiveCall(where))\n#define Py_LeaveRecursiveCall()                         \\\n    do{ if(_Py_MakeEndRecCheck(PyThreadState_GET()->recursion_depth))  \\\n      PyThreadState_GET()->overflowed = 0;  \\\n    } while(0)\nPyAPI_FUNC(int) _Py_CheckRecursiveCall(const char *where);\n\n/* Due to the macros in which it's used, _Py_CheckRecursionLimit is in\n   the stable ABI.  It should be removed therefrom when possible.\n*/\nPyAPI_DATA(int) _Py_CheckRecursionLimit;\n\n#ifdef USE_STACKCHECK\n/* With USE_STACKCHECK, trigger stack checks in _Py_CheckRecursiveCall()\n   on every 64th call to Py_EnterRecursiveCall.\n*/\n#  define _Py_MakeRecCheck(x)  \\\n    (++(x) > _Py_CheckRecursionLimit || \\\n     ++(PyThreadState_GET()->stackcheck_counter) > 64)\n#else\n#  define _Py_MakeRecCheck(x)  (++(x) > _Py_CheckRecursionLimit)\n#endif\n\n/* Compute the \"lower-water mark\" for a recursion limit. When\n * Py_LeaveRecursiveCall() is called with a recursion depth below this mark,\n * the overflowed flag is reset to 0. */\n#define _Py_RecursionLimitLowerWaterMark(limit) \\\n    (((limit) > 200) \\\n        ? ((limit) - 50) \\\n        : (3 * ((limit) >> 2)))\n\n#define _Py_MakeEndRecCheck(x) \\\n    (--(x) < _Py_RecursionLimitLowerWaterMark(_Py_CheckRecursionLimit))\n\n#define Py_ALLOW_RECURSION \\\n  do { unsigned char _old = PyThreadState_GET()->recursion_critical;\\\n    PyThreadState_GET()->recursion_critical = 1;\n\n#define Py_END_ALLOW_RECURSION \\\n    PyThreadState_GET()->recursion_critical = _old; \\\n  } while(0);\n\nPyAPI_FUNC(const char *) PyEval_GetFuncName(PyObject *);\nPyAPI_FUNC(const char *) PyEval_GetFuncDesc(PyObject *);\n\nPyAPI_FUNC(PyObject *) PyEval_EvalFrame(struct _frame *);\nPyAPI_FUNC(PyObject *) PyEval_EvalFrameEx(struct _frame *f, int exc);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyEval_EvalFrameDefault(struct _frame *f, int exc);\n#endif\n\n/* Interface for threads.\n\n   A module that plans to do a blocking system call (or something else\n   that lasts a long time and doesn't touch Python data) can allow other\n   threads to run as follows:\n\n    ...preparations here...\n    Py_BEGIN_ALLOW_THREADS\n    ...blocking system call here...\n    Py_END_ALLOW_THREADS\n    ...interpret result here...\n\n   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a\n   {}-surrounded block.\n   To leave the block in the middle (e.g., with return), you must insert\n   a line containing Py_BLOCK_THREADS before the return, e.g.\n\n    if (...premature_exit...) {\n        Py_BLOCK_THREADS\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n\n   An alternative is:\n\n    Py_BLOCK_THREADS\n    if (...premature_exit...) {\n        PyErr_SetFromErrno(PyExc_OSError);\n        return NULL;\n    }\n    Py_UNBLOCK_THREADS\n\n   For convenience, that the value of 'errno' is restored across\n   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.\n\n   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND\n   Py_END_ALLOW_THREADS!!!\n\n   The function PyEval_InitThreads() should be called only from\n   init_thread() in \"_threadmodule.c\".\n\n   Note that not yet all candidates have been converted to use this\n   mechanism!\n*/\n\nPyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);\nPyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);\n\nPyAPI_FUNC(int)  PyEval_ThreadsInitialized(void);\nPyAPI_FUNC(void) PyEval_InitThreads(void);\nPy_DEPRECATED(3.2) PyAPI_FUNC(void) PyEval_AcquireLock(void);\n/* Py_DEPRECATED(3.2) */ PyAPI_FUNC(void) PyEval_ReleaseLock(void);\nPyAPI_FUNC(void) PyEval_AcquireThread(PyThreadState *tstate);\nPyAPI_FUNC(void) PyEval_ReleaseThread(PyThreadState *tstate);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(void) _PyEval_SetSwitchInterval(unsigned long microseconds);\nPyAPI_FUNC(unsigned long) _PyEval_GetSwitchInterval(void);\n#endif\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(Py_ssize_t) _PyEval_RequestCodeExtraIndex(freefunc);\n#endif\n\n#define Py_BEGIN_ALLOW_THREADS { \\\n                        PyThreadState *_save; \\\n                        _save = PyEval_SaveThread();\n#define Py_BLOCK_THREADS        PyEval_RestoreThread(_save);\n#define Py_UNBLOCK_THREADS      _save = PyEval_SaveThread();\n#define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save); \\\n                 }\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, Py_ssize_t *);\nPyAPI_FUNC(int) _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *);\n#endif\n\n/* Masks and values used by FORMAT_VALUE opcode. */\n#define FVC_MASK      0x3\n#define FVC_NONE      0x0\n#define FVC_STR       0x1\n#define FVC_REPR      0x2\n#define FVC_ASCII     0x3\n#define FVS_MASK      0x4\n#define FVS_HAVE_SPEC 0x4\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_CEVAL_H */\n"}, "60": {"id": 60, "path": "/usr/include/python3.8/classobject.h", "content": "/* Former class object interface -- now only bound methods are here  */\n\n/* Revealing some structures (not for general use) */\n\n#ifndef Py_LIMITED_API\n#ifndef Py_CLASSOBJECT_H\n#define Py_CLASSOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *im_func;   /* The callable object implementing the method */\n    PyObject *im_self;   /* The instance it is bound to */\n    PyObject *im_weakreflist; /* List of weak references */\n    vectorcallfunc vectorcall;\n} PyMethodObject;\n\nPyAPI_DATA(PyTypeObject) PyMethod_Type;\n\n#define PyMethod_Check(op) ((op)->ob_type == &PyMethod_Type)\n\nPyAPI_FUNC(PyObject *) PyMethod_New(PyObject *, PyObject *);\n\nPyAPI_FUNC(PyObject *) PyMethod_Function(PyObject *);\nPyAPI_FUNC(PyObject *) PyMethod_Self(PyObject *);\n\n/* Macros for direct access to these values. Type checks are *not*\n   done, so use with care. */\n#define PyMethod_GET_FUNCTION(meth) \\\n        (((PyMethodObject *)meth) -> im_func)\n#define PyMethod_GET_SELF(meth) \\\n        (((PyMethodObject *)meth) -> im_self)\n\nPyAPI_FUNC(int) PyMethod_ClearFreeList(void);\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *func;\n} PyInstanceMethodObject;\n\nPyAPI_DATA(PyTypeObject) PyInstanceMethod_Type;\n\n#define PyInstanceMethod_Check(op) ((op)->ob_type == &PyInstanceMethod_Type)\n\nPyAPI_FUNC(PyObject *) PyInstanceMethod_New(PyObject *);\nPyAPI_FUNC(PyObject *) PyInstanceMethod_Function(PyObject *);\n\n/* Macros for direct access to these values. Type checks are *not*\n   done, so use with care. */\n#define PyInstanceMethod_GET_FUNCTION(meth) \\\n        (((PyInstanceMethodObject *)meth) -> func)\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_CLASSOBJECT_H */\n#endif /* Py_LIMITED_API */\n"}, "61": {"id": 61, "path": "/usr/include/python3.8/code.h", "content": "/* Definitions for bytecode */\n\n#ifndef Py_LIMITED_API\n#ifndef Py_CODE_H\n#define Py_CODE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef uint16_t _Py_CODEUNIT;\n\n#ifdef WORDS_BIGENDIAN\n#  define _Py_OPCODE(word) ((word) >> 8)\n#  define _Py_OPARG(word) ((word) & 255)\n#else\n#  define _Py_OPCODE(word) ((word) & 255)\n#  define _Py_OPARG(word) ((word) >> 8)\n#endif\n\ntypedef struct _PyOpcache _PyOpcache;\n\n/* Bytecode object */\ntypedef struct {\n    PyObject_HEAD\n    int co_argcount;            /* #arguments, except *args */\n    int co_posonlyargcount;     /* #positional only arguments */\n    int co_kwonlyargcount;      /* #keyword only arguments */\n    int co_nlocals;             /* #local variables */\n    int co_stacksize;           /* #entries needed for evaluation stack */\n    int co_flags;               /* CO_..., see below */\n    int co_firstlineno;         /* first source line number */\n    PyObject *co_code;          /* instruction opcodes */\n    PyObject *co_consts;        /* list (constants used) */\n    PyObject *co_names;         /* list of strings (names used) */\n    PyObject *co_varnames;      /* tuple of strings (local variable names) */\n    PyObject *co_freevars;      /* tuple of strings (free variable names) */\n    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */\n    /* The rest aren't used in either hash or comparisons, except for co_name,\n       used in both. This is done to preserve the name and line number\n       for tracebacks and debuggers; otherwise, constant de-duplication\n       would collapse identical functions/lambdas defined on different lines.\n    */\n    Py_ssize_t *co_cell2arg;    /* Maps cell vars which are arguments. */\n    PyObject *co_filename;      /* unicode (where it was loaded from) */\n    PyObject *co_name;          /* unicode (name, for reference) */\n    PyObject *co_lnotab;        /* string (encoding addr<->lineno mapping) See\n                                   Objects/lnotab_notes.txt for details. */\n    void *co_zombieframe;       /* for optimization only (see frameobject.c) */\n    PyObject *co_weakreflist;   /* to support weakrefs to code objects */\n    /* Scratch space for extra data relating to the code object.\n       Type is a void* to keep the format private in codeobject.c to force\n       people to go through the proper APIs. */\n    void *co_extra;\n\n    /* Per opcodes just-in-time cache\n     *\n     * To reduce cache size, we use indirect mapping from opcode index to\n     * cache object:\n     *   cache = co_opcache[co_opcache_map[next_instr - first_instr] - 1]\n     */\n\n    // co_opcache_map is indexed by (next_instr - first_instr).\n    //  * 0 means there is no cache for this opcode.\n    //  * n > 0 means there is cache in co_opcache[n-1].\n    unsigned char *co_opcache_map;\n    _PyOpcache *co_opcache;\n    int co_opcache_flag;  // used to determine when create a cache.\n    unsigned char co_opcache_size;  // length of co_opcache.\n} PyCodeObject;\n\n/* Masks for co_flags above */\n#define CO_OPTIMIZED    0x0001\n#define CO_NEWLOCALS    0x0002\n#define CO_VARARGS      0x0004\n#define CO_VARKEYWORDS  0x0008\n#define CO_NESTED       0x0010\n#define CO_GENERATOR    0x0020\n/* The CO_NOFREE flag is set if there are no free or cell variables.\n   This information is redundant, but it allows a single flag test\n   to determine whether there is any extra work to be done when the\n   call frame it setup.\n*/\n#define CO_NOFREE       0x0040\n\n/* The CO_COROUTINE flag is set for coroutine functions (defined with\n   ``async def`` keywords) */\n#define CO_COROUTINE            0x0080\n#define CO_ITERABLE_COROUTINE   0x0100\n#define CO_ASYNC_GENERATOR      0x0200\n\n/* bpo-39562: These constant values are changed in Python 3.9\n   to prevent collision with compiler flags. CO_FUTURE_ and PyCF_\n   constants must be kept unique. PyCF_ constants can use bits from\n   0x0100 to 0x10000. CO_FUTURE_ constants use bits starting at 0x20000. */\n#define CO_FUTURE_DIVISION      0x20000\n#define CO_FUTURE_ABSOLUTE_IMPORT 0x40000 /* do absolute imports by default */\n#define CO_FUTURE_WITH_STATEMENT  0x80000\n#define CO_FUTURE_PRINT_FUNCTION  0x100000\n#define CO_FUTURE_UNICODE_LITERALS 0x200000\n\n#define CO_FUTURE_BARRY_AS_BDFL  0x400000\n#define CO_FUTURE_GENERATOR_STOP  0x800000\n#define CO_FUTURE_ANNOTATIONS    0x1000000\n\n/* This value is found in the co_cell2arg array when the associated cell\n   variable does not correspond to an argument. */\n#define CO_CELL_NOT_AN_ARG (-1)\n\n/* This should be defined if a future statement modifies the syntax.\n   For example, when a keyword is added.\n*/\n#define PY_PARSER_REQUIRES_FUTURE_KEYWORD\n\n#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */\n\nPyAPI_DATA(PyTypeObject) PyCode_Type;\n\n#define PyCode_Check(op) (Py_TYPE(op) == &PyCode_Type)\n#define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)->co_freevars))\n\n/* Public interface */\nPyAPI_FUNC(PyCodeObject *) PyCode_New(\n        int, int, int, int, int, PyObject *, PyObject *,\n        PyObject *, PyObject *, PyObject *, PyObject *,\n        PyObject *, PyObject *, int, PyObject *);\n\nPyAPI_FUNC(PyCodeObject *) PyCode_NewWithPosOnlyArgs(\n        int, int, int, int, int, int, PyObject *, PyObject *,\n        PyObject *, PyObject *, PyObject *, PyObject *,\n        PyObject *, PyObject *, int, PyObject *);\n        /* same as struct above */\n\n/* Creates a new empty code object with the specified source location. */\nPyAPI_FUNC(PyCodeObject *)\nPyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno);\n\n/* Return the line number associated with the specified bytecode index\n   in this code object.  If you just need the line number of a frame,\n   use PyFrame_GetLineNumber() instead. */\nPyAPI_FUNC(int) PyCode_Addr2Line(PyCodeObject *, int);\n\n/* for internal use only */\ntypedef struct _addr_pair {\n        int ap_lower;\n        int ap_upper;\n} PyAddrPair;\n\n#ifndef Py_LIMITED_API\n/* Update *bounds to describe the first and one-past-the-last instructions in the\n   same line as lasti.  Return the number of that line.\n*/\nPyAPI_FUNC(int) _PyCode_CheckLineNumber(PyCodeObject* co,\n                                        int lasti, PyAddrPair *bounds);\n\n/* Create a comparable key used to compare constants taking in account the\n * object type. It is used to make sure types are not coerced (e.g., float and\n * complex) _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms\n *\n * Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)\n * depending on the type and the value. The type is the first item to not\n * compare bytes and str which can raise a BytesWarning exception. */\nPyAPI_FUNC(PyObject*) _PyCode_ConstantKey(PyObject *obj);\n#endif\n\nPyAPI_FUNC(PyObject*) PyCode_Optimize(PyObject *code, PyObject* consts,\n                                      PyObject *names, PyObject *lnotab);\n\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyCode_GetExtra(PyObject *code, Py_ssize_t index,\n                                 void **extra);\nPyAPI_FUNC(int) _PyCode_SetExtra(PyObject *code, Py_ssize_t index,\n                                 void *extra);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_CODE_H */\n#endif /* Py_LIMITED_API */\n"}, "62": {"id": 62, "path": "/usr/include/python3.8/codecs.h", "content": "#ifndef Py_CODECREGISTRY_H\n#define Py_CODECREGISTRY_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* ------------------------------------------------------------------------\n\n   Python Codec Registry and support functions\n\n\nWritten by Marc-Andre Lemburg (mal@lemburg.com).\n\nCopyright (c) Corporation for National Research Initiatives.\n\n   ------------------------------------------------------------------------ */\n\n/* Register a new codec search function.\n\n   As side effect, this tries to load the encodings package, if not\n   yet done, to make sure that it is always first in the list of\n   search functions.\n\n   The search_function's refcount is incremented by this function. */\n\nPyAPI_FUNC(int) PyCodec_Register(\n       PyObject *search_function\n       );\n\n/* Codec registry lookup API.\n\n   Looks up the given encoding and returns a CodecInfo object with\n   function attributes which implement the different aspects of\n   processing the encoding.\n\n   The encoding string is looked up converted to all lower-case\n   characters. This makes encodings looked up through this mechanism\n   effectively case-insensitive.\n\n   If no codec is found, a KeyError is set and NULL returned.\n\n   As side effect, this tries to load the encodings package, if not\n   yet done. This is part of the lazy load strategy for the encodings\n   package.\n\n */\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyCodec_Lookup(\n       const char *encoding\n       );\n\nPyAPI_FUNC(int) _PyCodec_Forget(\n       const char *encoding\n       );\n#endif\n\n/* Codec registry encoding check API.\n\n   Returns 1/0 depending on whether there is a registered codec for\n   the given encoding.\n\n*/\n\nPyAPI_FUNC(int) PyCodec_KnownEncoding(\n       const char *encoding\n       );\n\n/* Generic codec based encoding API.\n\n   object is passed through the encoder function found for the given\n   encoding using the error handling method defined by errors. errors\n   may be NULL to use the default method defined for the codec.\n\n   Raises a LookupError in case no encoder can be found.\n\n */\n\nPyAPI_FUNC(PyObject *) PyCodec_Encode(\n       PyObject *object,\n       const char *encoding,\n       const char *errors\n       );\n\n/* Generic codec based decoding API.\n\n   object is passed through the decoder function found for the given\n   encoding using the error handling method defined by errors. errors\n   may be NULL to use the default method defined for the codec.\n\n   Raises a LookupError in case no encoder can be found.\n\n */\n\nPyAPI_FUNC(PyObject *) PyCodec_Decode(\n       PyObject *object,\n       const char *encoding,\n       const char *errors\n       );\n\n#ifndef Py_LIMITED_API\n/* Text codec specific encoding and decoding API.\n\n   Checks the encoding against a list of codecs which do not\n   implement a str<->bytes encoding before attempting the\n   operation.\n\n   Please note that these APIs are internal and should not\n   be used in Python C extensions.\n\n   XXX (ncoghlan): should we make these, or something like them, public\n   in Python 3.5+?\n\n */\nPyAPI_FUNC(PyObject *) _PyCodec_LookupTextEncoding(\n       const char *encoding,\n       const char *alternate_command\n       );\n\nPyAPI_FUNC(PyObject *) _PyCodec_EncodeText(\n       PyObject *object,\n       const char *encoding,\n       const char *errors\n       );\n\nPyAPI_FUNC(PyObject *) _PyCodec_DecodeText(\n       PyObject *object,\n       const char *encoding,\n       const char *errors\n       );\n\n/* These two aren't actually text encoding specific, but _io.TextIOWrapper\n * is the only current API consumer.\n */\nPyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalDecoder(\n       PyObject *codec_info,\n       const char *errors\n       );\n\nPyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalEncoder(\n       PyObject *codec_info,\n       const char *errors\n       );\n#endif\n\n\n\n/* --- Codec Lookup APIs --------------------------------------------------\n\n   All APIs return a codec object with incremented refcount and are\n   based on _PyCodec_Lookup().  The same comments w/r to the encoding\n   name also apply to these APIs.\n\n*/\n\n/* Get an encoder function for the given encoding. */\n\nPyAPI_FUNC(PyObject *) PyCodec_Encoder(\n       const char *encoding\n       );\n\n/* Get a decoder function for the given encoding. */\n\nPyAPI_FUNC(PyObject *) PyCodec_Decoder(\n       const char *encoding\n       );\n\n/* Get an IncrementalEncoder object for the given encoding. */\n\nPyAPI_FUNC(PyObject *) PyCodec_IncrementalEncoder(\n       const char *encoding,\n       const char *errors\n       );\n\n/* Get an IncrementalDecoder object function for the given encoding. */\n\nPyAPI_FUNC(PyObject *) PyCodec_IncrementalDecoder(\n       const char *encoding,\n       const char *errors\n       );\n\n/* Get a StreamReader factory function for the given encoding. */\n\nPyAPI_FUNC(PyObject *) PyCodec_StreamReader(\n       const char *encoding,\n       PyObject *stream,\n       const char *errors\n       );\n\n/* Get a StreamWriter factory function for the given encoding. */\n\nPyAPI_FUNC(PyObject *) PyCodec_StreamWriter(\n       const char *encoding,\n       PyObject *stream,\n       const char *errors\n       );\n\n/* Unicode encoding error handling callback registry API */\n\n/* Register the error handling callback function error under the given\n   name. This function will be called by the codec when it encounters\n   unencodable characters/undecodable bytes and doesn't know the\n   callback name, when name is specified as the error parameter\n   in the call to the encode/decode function.\n   Return 0 on success, -1 on error */\nPyAPI_FUNC(int) PyCodec_RegisterError(const char *name, PyObject *error);\n\n/* Lookup the error handling callback function registered under the given\n   name. As a special case NULL can be passed, in which case\n   the error handling callback for \"strict\" will be returned. */\nPyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);\n\n/* raise exc as an exception */\nPyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);\n\n/* ignore the unicode error, skipping the faulty input */\nPyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);\n\n/* replace the unicode encode error with ? or U+FFFD */\nPyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);\n\n/* replace the unicode encode error with XML character references */\nPyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);\n\n/* replace the unicode encode error with backslash escapes (\\x, \\u and \\U) */\nPyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* replace the unicode encode error with backslash escapes (\\N, \\x, \\u and \\U) */\nPyAPI_FUNC(PyObject *) PyCodec_NameReplaceErrors(PyObject *exc);\n#endif\n\n#ifndef Py_LIMITED_API\nPyAPI_DATA(const char *) Py_hexdigits;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_CODECREGISTRY_H */\n"}, "63": {"id": 63, "path": "/usr/include/python3.8/compile.h", "content": "#ifndef Py_COMPILE_H\n#define Py_COMPILE_H\n\n#ifndef Py_LIMITED_API\n#include \"code.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Public interface */\nstruct _node; /* Declare the existence of this type */\nPyAPI_FUNC(PyCodeObject *) PyNode_Compile(struct _node *, const char *);\n/* XXX (ncoghlan): Unprefixed type name in a public API! */\n\n#define PyCF_MASK (CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | \\\n                   CO_FUTURE_WITH_STATEMENT | CO_FUTURE_PRINT_FUNCTION | \\\n                   CO_FUTURE_UNICODE_LITERALS | CO_FUTURE_BARRY_AS_BDFL | \\\n                   CO_FUTURE_GENERATOR_STOP | CO_FUTURE_ANNOTATIONS)\n#define PyCF_MASK_OBSOLETE (CO_NESTED)\n\n/* bpo-39562: CO_FUTURE_ and PyCF_ constants must be kept unique.\n   PyCF_ constants can use bits from 0x0100 to 0x10000.\n   CO_FUTURE_ constants use bits starting at 0x20000. */\n#define PyCF_SOURCE_IS_UTF8  0x0100\n#define PyCF_DONT_IMPLY_DEDENT 0x0200\n#define PyCF_ONLY_AST 0x0400\n#define PyCF_IGNORE_COOKIE 0x0800\n#define PyCF_TYPE_COMMENTS 0x1000\n#define PyCF_ALLOW_TOP_LEVEL_AWAIT 0x2000\n#define PyCF_COMPILE_MASK (PyCF_ONLY_AST | PyCF_ALLOW_TOP_LEVEL_AWAIT | \\\n                           PyCF_TYPE_COMMENTS | PyCF_DONT_IMPLY_DEDENT)\n\n#ifndef Py_LIMITED_API\ntypedef struct {\n    int cf_flags;  /* bitmask of CO_xxx flags relevant to future */\n    int cf_feature_version;  /* minor Python version (PyCF_ONLY_AST) */\n} PyCompilerFlags;\n\n#define _PyCompilerFlags_INIT \\\n    (PyCompilerFlags){.cf_flags = 0, .cf_feature_version = PY_MINOR_VERSION}\n#endif\n\n/* Future feature support */\n\ntypedef struct {\n    int ff_features;      /* flags set by future statements */\n    int ff_lineno;        /* line number of last future statement */\n} PyFutureFeatures;\n\n#define FUTURE_NESTED_SCOPES \"nested_scopes\"\n#define FUTURE_GENERATORS \"generators\"\n#define FUTURE_DIVISION \"division\"\n#define FUTURE_ABSOLUTE_IMPORT \"absolute_import\"\n#define FUTURE_WITH_STATEMENT \"with_statement\"\n#define FUTURE_PRINT_FUNCTION \"print_function\"\n#define FUTURE_UNICODE_LITERALS \"unicode_literals\"\n#define FUTURE_BARRY_AS_BDFL \"barry_as_FLUFL\"\n#define FUTURE_GENERATOR_STOP \"generator_stop\"\n#define FUTURE_ANNOTATIONS \"annotations\"\n\nstruct _mod; /* Declare the existence of this type */\n#define PyAST_Compile(mod, s, f, ar) PyAST_CompileEx(mod, s, f, -1, ar)\nPyAPI_FUNC(PyCodeObject *) PyAST_CompileEx(\n    struct _mod *mod,\n    const char *filename,       /* decoded from the filesystem encoding */\n    PyCompilerFlags *flags,\n    int optimize,\n    PyArena *arena);\nPyAPI_FUNC(PyCodeObject *) PyAST_CompileObject(\n    struct _mod *mod,\n    PyObject *filename,\n    PyCompilerFlags *flags,\n    int optimize,\n    PyArena *arena);\nPyAPI_FUNC(PyFutureFeatures *) PyFuture_FromAST(\n    struct _mod * mod,\n    const char *filename        /* decoded from the filesystem encoding */\n    );\nPyAPI_FUNC(PyFutureFeatures *) PyFuture_FromASTObject(\n    struct _mod * mod,\n    PyObject *filename\n    );\n\n/* _Py_Mangle is defined in compile.c */\nPyAPI_FUNC(PyObject*) _Py_Mangle(PyObject *p, PyObject *name);\n\n#define PY_INVALID_STACK_EFFECT INT_MAX\nPyAPI_FUNC(int) PyCompile_OpcodeStackEffect(int opcode, int oparg);\nPyAPI_FUNC(int) PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump);\n\nPyAPI_FUNC(int) _PyAST_Optimize(struct _mod *, PyArena *arena, int optimize);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_LIMITED_API */\n\n/* These definitions must match corresponding definitions in graminit.h. */\n#define Py_single_input 256\n#define Py_file_input 257\n#define Py_eval_input 258\n#define Py_func_type_input 345\n\n#endif /* !Py_COMPILE_H */\n"}, "64": {"id": 64, "path": "/usr/include/python3.8/complexobject.h", "content": "/* Complex number structure */\n\n#ifndef Py_COMPLEXOBJECT_H\n#define Py_COMPLEXOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\ntypedef struct {\n    double real;\n    double imag;\n} Py_complex;\n\n/* Operations on complex numbers from complexmodule.c */\n\nPyAPI_FUNC(Py_complex) _Py_c_sum(Py_complex, Py_complex);\nPyAPI_FUNC(Py_complex) _Py_c_diff(Py_complex, Py_complex);\nPyAPI_FUNC(Py_complex) _Py_c_neg(Py_complex);\nPyAPI_FUNC(Py_complex) _Py_c_prod(Py_complex, Py_complex);\nPyAPI_FUNC(Py_complex) _Py_c_quot(Py_complex, Py_complex);\nPyAPI_FUNC(Py_complex) _Py_c_pow(Py_complex, Py_complex);\nPyAPI_FUNC(double) _Py_c_abs(Py_complex);\n#endif\n\n/* Complex object interface */\n\n/*\nPyComplexObject represents a complex number with double-precision\nreal and imaginary parts.\n*/\n#ifndef Py_LIMITED_API\ntypedef struct {\n    PyObject_HEAD\n    Py_complex cval;\n} PyComplexObject;\n#endif\n\nPyAPI_DATA(PyTypeObject) PyComplex_Type;\n\n#define PyComplex_Check(op) PyObject_TypeCheck(op, &PyComplex_Type)\n#define PyComplex_CheckExact(op) (Py_TYPE(op) == &PyComplex_Type)\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) PyComplex_FromCComplex(Py_complex);\n#endif\nPyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);\n\nPyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);\nPyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(Py_complex) PyComplex_AsCComplex(PyObject *op);\n#endif\n\n/* Format the object based on the format_spec, as defined in PEP 3101\n   (Advanced String Formatting). */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyComplex_FormatAdvancedWriter(\n    _PyUnicodeWriter *writer,\n    PyObject *obj,\n    PyObject *format_spec,\n    Py_ssize_t start,\n    Py_ssize_t end);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_COMPLEXOBJECT_H */\n"}, "65": {"id": 65, "path": "/usr/include/python3.8/context.h", "content": "#ifndef Py_CONTEXT_H\n#define Py_CONTEXT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\n\n\nPyAPI_DATA(PyTypeObject) PyContext_Type;\ntypedef struct _pycontextobject PyContext;\n\nPyAPI_DATA(PyTypeObject) PyContextVar_Type;\ntypedef struct _pycontextvarobject PyContextVar;\n\nPyAPI_DATA(PyTypeObject) PyContextToken_Type;\ntypedef struct _pycontexttokenobject PyContextToken;\n\n\n#define PyContext_CheckExact(o) (Py_TYPE(o) == &PyContext_Type)\n#define PyContextVar_CheckExact(o) (Py_TYPE(o) == &PyContextVar_Type)\n#define PyContextToken_CheckExact(o) (Py_TYPE(o) == &PyContextToken_Type)\n\n\nPyAPI_FUNC(PyObject *) PyContext_New(void);\nPyAPI_FUNC(PyObject *) PyContext_Copy(PyObject *);\nPyAPI_FUNC(PyObject *) PyContext_CopyCurrent(void);\n\nPyAPI_FUNC(int) PyContext_Enter(PyObject *);\nPyAPI_FUNC(int) PyContext_Exit(PyObject *);\n\n\n/* Create a new context variable.\n\n   default_value can be NULL.\n*/\nPyAPI_FUNC(PyObject *) PyContextVar_New(\n    const char *name, PyObject *default_value);\n\n\n/* Get a value for the variable.\n\n   Returns -1 if an error occurred during lookup.\n\n   Returns 0 if value either was or was not found.\n\n   If value was found, *value will point to it.\n   If not, it will point to:\n\n   - default_value, if not NULL;\n   - the default value of \"var\", if not NULL;\n   - NULL.\n\n   '*value' will be a new ref, if not NULL.\n*/\nPyAPI_FUNC(int) PyContextVar_Get(\n    PyObject *var, PyObject *default_value, PyObject **value);\n\n\n/* Set a new value for the variable.\n   Returns NULL if an error occurs.\n*/\nPyAPI_FUNC(PyObject *) PyContextVar_Set(PyObject *var, PyObject *value);\n\n\n/* Reset a variable to its previous value.\n   Returns 0 on success, -1 on error.\n*/\nPyAPI_FUNC(int) PyContextVar_Reset(PyObject *var, PyObject *token);\n\n\n/* This method is exposed only for CPython tests. Don not use it. */\nPyAPI_FUNC(PyObject *) _PyContext_NewHamtForTests(void);\n\n\nPyAPI_FUNC(int) PyContext_ClearFreeList(void);\n\n\n#endif /* !Py_LIMITED_API */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_CONTEXT_H */\n"}, "66": {"id": 66, "path": "/usr/include/python3.8/cpython/abstract.h", "content": "#ifndef Py_CPYTHON_ABSTRACTOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* === Object Protocol ================================================== */\n\n#ifdef PY_SSIZE_T_CLEAN\n#  define _PyObject_CallMethodId _PyObject_CallMethodId_SizeT\n#endif\n\n/* Convert keyword arguments from the FASTCALL (stack: C array, kwnames: tuple)\n   format to a Python dictionary (\"kwargs\" dict).\n\n   The type of kwnames keys is not checked. The final function getting\n   arguments is responsible to check if all keys are strings, for example using\n   PyArg_ParseTupleAndKeywords() or PyArg_ValidateKeywordArguments().\n\n   Duplicate keys are merged using the last value. If duplicate keys must raise\n   an exception, the caller is responsible to implement an explicit keys on\n   kwnames. */\nPyAPI_FUNC(PyObject *) _PyStack_AsDict(\n    PyObject *const *values,\n    PyObject *kwnames);\n\n/* Convert (args, nargs, kwargs: dict) into a (stack, nargs, kwnames: tuple).\n\n   Return 0 on success, raise an exception and return -1 on error.\n\n   Write the new stack into *p_stack. If *p_stack is differen than args, it\n   must be released by PyMem_Free().\n\n   The stack uses borrowed references.\n\n   The type of keyword keys is not checked, these checks should be done\n   later (ex: _PyArg_ParseStackAndKeywords). */\nPyAPI_FUNC(int) _PyStack_UnpackDict(\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    PyObject *kwargs,\n    PyObject *const **p_stack,\n    PyObject **p_kwnames);\n\n/* Suggested size (number of positional arguments) for arrays of PyObject*\n   allocated on a C stack to avoid allocating memory on the heap memory. Such\n   array is used to pass positional arguments to call functions of the\n   _PyObject_Vectorcall() family.\n\n   The size is chosen to not abuse the C stack and so limit the risk of stack\n   overflow. The size is also chosen to allow using the small stack for most\n   function calls of the Python standard library. On 64-bit CPU, it allocates\n   40 bytes on the stack. */\n#define _PY_FASTCALL_SMALL_STACK 5\n\nPyAPI_FUNC(PyObject *) _Py_CheckFunctionResult(PyObject *callable,\n                                               PyObject *result,\n                                               const char *where);\n\n/* === Vectorcall protocol (PEP 590) ============================= */\n\n/* Call callable using tp_call. Arguments are like _PyObject_Vectorcall()\n   or _PyObject_FastCallDict() (both forms are supported),\n   except that nargs is plainly the number of arguments without flags. */\nPyAPI_FUNC(PyObject *) _PyObject_MakeTpCall(\n    PyObject *callable,\n    PyObject *const *args, Py_ssize_t nargs,\n    PyObject *keywords);\n\n#define PY_VECTORCALL_ARGUMENTS_OFFSET ((size_t)1 << (8 * sizeof(size_t) - 1))\n\nstatic inline Py_ssize_t\nPyVectorcall_NARGS(size_t n)\n{\n    return n & ~PY_VECTORCALL_ARGUMENTS_OFFSET;\n}\n\nstatic inline vectorcallfunc\n_PyVectorcall_Function(PyObject *callable)\n{\n    PyTypeObject *tp = Py_TYPE(callable);\n    Py_ssize_t offset = tp->tp_vectorcall_offset;\n    vectorcallfunc *ptr;\n    if (!PyType_HasFeature(tp, _Py_TPFLAGS_HAVE_VECTORCALL)) {\n        return NULL;\n    }\n    assert(PyCallable_Check(callable));\n    assert(offset > 0);\n    ptr = (vectorcallfunc*)(((char *)callable) + offset);\n    return *ptr;\n}\n\n/* Call the callable object 'callable' with the \"vectorcall\" calling\n   convention.\n\n   args is a C array for positional arguments.\n\n   nargsf is the number of positional arguments plus optionally the flag\n   PY_VECTORCALL_ARGUMENTS_OFFSET which means that the caller is allowed to\n   modify args[-1].\n\n   kwnames is a tuple of keyword names. The values of the keyword arguments\n   are stored in \"args\" after the positional arguments (note that the number\n   of keyword arguments does not change nargsf). kwnames can also be NULL if\n   there are no keyword arguments.\n\n   keywords must only contains str strings (no subclass), and all keys must\n   be unique.\n\n   Return the result on success. Raise an exception and return NULL on\n   error. */\nstatic inline PyObject *\n_PyObject_Vectorcall(PyObject *callable, PyObject *const *args,\n                     size_t nargsf, PyObject *kwnames)\n{\n    PyObject *res;\n    vectorcallfunc func;\n    assert(kwnames == NULL || PyTuple_Check(kwnames));\n    assert(args != NULL || PyVectorcall_NARGS(nargsf) == 0);\n    func = _PyVectorcall_Function(callable);\n    if (func == NULL) {\n        Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);\n        return _PyObject_MakeTpCall(callable, args, nargs, kwnames);\n    }\n    res = func(callable, args, nargsf, kwnames);\n    return _Py_CheckFunctionResult(callable, res, NULL);\n}\n\n/* Same as _PyObject_Vectorcall except that keyword arguments are passed as\n   dict, which may be NULL if there are no keyword arguments. */\nPyAPI_FUNC(PyObject *) _PyObject_FastCallDict(\n    PyObject *callable,\n    PyObject *const *args,\n    size_t nargsf,\n    PyObject *kwargs);\n\n/* Call \"callable\" (which must support vectorcall) with positional arguments\n   \"tuple\" and keyword arguments \"dict\". \"dict\" may also be NULL */\nPyAPI_FUNC(PyObject *) PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict);\n\n/* Same as _PyObject_Vectorcall except without keyword arguments */\nstatic inline PyObject *\n_PyObject_FastCall(PyObject *func, PyObject *const *args, Py_ssize_t nargs)\n{\n    return _PyObject_Vectorcall(func, args, (size_t)nargs, NULL);\n}\n\n/* Call a callable without any arguments */\nstatic inline PyObject *\n_PyObject_CallNoArg(PyObject *func) {\n    return _PyObject_Vectorcall(func, NULL, 0, NULL);\n}\n\nPyAPI_FUNC(PyObject *) _PyObject_Call_Prepend(\n    PyObject *callable,\n    PyObject *obj,\n    PyObject *args,\n    PyObject *kwargs);\n\nPyAPI_FUNC(PyObject *) _PyObject_FastCall_Prepend(\n    PyObject *callable,\n    PyObject *obj,\n    PyObject *const *args,\n    Py_ssize_t nargs);\n\n/* Like PyObject_CallMethod(), but expect a _Py_Identifier*\n   as the method name. */\nPyAPI_FUNC(PyObject *) _PyObject_CallMethodId(PyObject *obj,\n                                              _Py_Identifier *name,\n                                              const char *format, ...);\n\nPyAPI_FUNC(PyObject *) _PyObject_CallMethodId_SizeT(PyObject *obj,\n                                                    _Py_Identifier *name,\n                                                    const char *format,\n                                                    ...);\n\nPyAPI_FUNC(PyObject *) _PyObject_CallMethodIdObjArgs(\n    PyObject *obj,\n    struct _Py_Identifier *name,\n    ...);\n\nPyAPI_FUNC(int) _PyObject_HasLen(PyObject *o);\n\n/* Guess the size of object 'o' using len(o) or o.__length_hint__().\n   If neither of those return a non-negative value, then return the default\n   value.  If one of the calls fails, this function returns -1. */\nPyAPI_FUNC(Py_ssize_t) PyObject_LengthHint(PyObject *o, Py_ssize_t);\n\n/* === New Buffer API ============================================ */\n\n/* Return 1 if the getbuffer function is available, otherwise return 0. */\n#define PyObject_CheckBuffer(obj) \\\n    (((obj)->ob_type->tp_as_buffer != NULL) &&  \\\n     ((obj)->ob_type->tp_as_buffer->bf_getbuffer != NULL))\n\n/* This is a C-API version of the getbuffer function call.  It checks\n   to make sure object has the required function pointer and issues the\n   call.\n\n   Returns -1 and raises an error on failure and returns 0 on success. */\nPyAPI_FUNC(int) PyObject_GetBuffer(PyObject *obj, Py_buffer *view,\n                                   int flags);\n\n/* Get the memory area pointed to by the indices for the buffer given.\n   Note that view->ndim is the assumed size of indices. */\nPyAPI_FUNC(void *) PyBuffer_GetPointer(Py_buffer *view, Py_ssize_t *indices);\n\n/* Return the implied itemsize of the data-format area from a\n   struct-style description. */\nPyAPI_FUNC(int) PyBuffer_SizeFromFormat(const char *);\n\n/* Implementation in memoryobject.c */\nPyAPI_FUNC(int) PyBuffer_ToContiguous(void *buf, Py_buffer *view,\n                                      Py_ssize_t len, char order);\n\nPyAPI_FUNC(int) PyBuffer_FromContiguous(Py_buffer *view, void *buf,\n                                        Py_ssize_t len, char order);\n\n/* Copy len bytes of data from the contiguous chunk of memory\n   pointed to by buf into the buffer exported by obj.  Return\n   0 on success and return -1 and raise a PyBuffer_Error on\n   error (i.e. the object does not have a buffer interface or\n   it is not working).\n\n   If fort is 'F', then if the object is multi-dimensional,\n   then the data will be copied into the array in\n   Fortran-style (first dimension varies the fastest).  If\n   fort is 'C', then the data will be copied into the array\n   in C-style (last dimension varies the fastest).  If fort\n   is 'A', then it does not matter and the copy will be made\n   in whatever way is more efficient. */\nPyAPI_FUNC(int) PyObject_CopyData(PyObject *dest, PyObject *src);\n\n/* Copy the data from the src buffer to the buffer of destination. */\nPyAPI_FUNC(int) PyBuffer_IsContiguous(const Py_buffer *view, char fort);\n\n/*Fill the strides array with byte-strides of a contiguous\n  (Fortran-style if fort is 'F' or C-style otherwise)\n  array of the given shape with the given number of bytes\n  per element. */\nPyAPI_FUNC(void) PyBuffer_FillContiguousStrides(int ndims,\n                                               Py_ssize_t *shape,\n                                               Py_ssize_t *strides,\n                                               int itemsize,\n                                               char fort);\n\n/* Fills in a buffer-info structure correctly for an exporter\n   that can only share a contiguous chunk of memory of\n   \"unsigned bytes\" of the given length.\n\n   Returns 0 on success and -1 (with raising an error) on error. */\nPyAPI_FUNC(int) PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf,\n                                  Py_ssize_t len, int readonly,\n                                  int flags);\n\n/* Releases a Py_buffer obtained from getbuffer ParseTuple's \"s*\". */\nPyAPI_FUNC(void) PyBuffer_Release(Py_buffer *view);\n\n/* ==== Iterators ================================================ */\n\n#define PyIter_Check(obj) \\\n    ((obj)->ob_type->tp_iternext != NULL && \\\n     (obj)->ob_type->tp_iternext != &_PyObject_NextNotImplemented)\n\n/* === Number Protocol ================================================== */\n\n#define PyIndex_Check(obj)                              \\\n    ((obj)->ob_type->tp_as_number != NULL &&            \\\n     (obj)->ob_type->tp_as_number->nb_index != NULL)\n\n/* === Sequence protocol ================================================ */\n\n/* Assume tp_as_sequence and sq_item exist and that 'i' does not\n   need to be corrected for a negative index. */\n#define PySequence_ITEM(o, i)\\\n    ( Py_TYPE(o)->tp_as_sequence->sq_item(o, i) )\n\n#define PY_ITERSEARCH_COUNT    1\n#define PY_ITERSEARCH_INDEX    2\n#define PY_ITERSEARCH_CONTAINS 3\n\n/* Iterate over seq.\n\n   Result depends on the operation:\n\n   PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if\n     error.\n   PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of\n     obj in seq; set ValueError and return -1 if none found;\n     also return -1 on error.\n   PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on\n     error. */\nPyAPI_FUNC(Py_ssize_t) _PySequence_IterSearch(PyObject *seq,\n                                              PyObject *obj, int operation);\n\n/* === Mapping protocol ================================================= */\n\nPyAPI_FUNC(int) _PyObject_RealIsInstance(PyObject *inst, PyObject *cls);\n\nPyAPI_FUNC(int) _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls);\n\nPyAPI_FUNC(char *const *) _PySequence_BytesToCharpArray(PyObject* self);\n\nPyAPI_FUNC(void) _Py_FreeCharPArray(char *const array[]);\n\n/* For internal use by buffer API functions */\nPyAPI_FUNC(void) _Py_add_one_to_index_F(int nd, Py_ssize_t *index,\n                                        const Py_ssize_t *shape);\nPyAPI_FUNC(void) _Py_add_one_to_index_C(int nd, Py_ssize_t *index,\n                                        const Py_ssize_t *shape);\n\n/* Convert Python int to Py_ssize_t. Do nothing if the argument is None. */\nPyAPI_FUNC(int) _Py_convert_optional_to_ssize_t(PyObject *, void *);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "67": {"id": 67, "path": "/usr/include/python3.8/cpython/dictobject.h", "content": "#ifndef Py_CPYTHON_DICTOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct _dictkeysobject PyDictKeysObject;\n\n/* The ma_values pointer is NULL for a combined table\n * or points to an array of PyObject* for a split table\n */\ntypedef struct {\n    PyObject_HEAD\n\n    /* Number of items in the dictionary */\n    Py_ssize_t ma_used;\n\n    /* Dictionary version: globally unique, value change each time\n       the dictionary is modified */\n    uint64_t ma_version_tag;\n\n    PyDictKeysObject *ma_keys;\n\n    /* If ma_values is NULL, the table is \"combined\": keys and values\n       are stored in ma_keys.\n\n       If ma_values is not NULL, the table is splitted:\n       keys are stored in ma_keys and values are stored in ma_values */\n    PyObject **ma_values;\n} PyDictObject;\n\nPyAPI_FUNC(PyObject *) _PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key,\n                                       Py_hash_t hash);\nPyAPI_FUNC(PyObject *) _PyDict_GetItemIdWithError(PyObject *dp,\n                                                  struct _Py_Identifier *key);\nPyAPI_FUNC(PyObject *) _PyDict_GetItemStringWithError(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyDict_SetDefault(\n    PyObject *mp, PyObject *key, PyObject *defaultobj);\nPyAPI_FUNC(int) _PyDict_SetItem_KnownHash(PyObject *mp, PyObject *key,\n                                          PyObject *item, Py_hash_t hash);\nPyAPI_FUNC(int) _PyDict_DelItem_KnownHash(PyObject *mp, PyObject *key,\n                                          Py_hash_t hash);\nPyAPI_FUNC(int) _PyDict_DelItemIf(PyObject *mp, PyObject *key,\n                                  int (*predicate)(PyObject *value));\nPyDictKeysObject *_PyDict_NewKeysForClass(void);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetDict(PyObject *, void *);\nPyAPI_FUNC(int) _PyDict_Next(\n    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash);\n\n/* Get the number of items of a dictionary. */\n#define PyDict_GET_SIZE(mp)  (assert(PyDict_Check(mp)),((PyDictObject *)mp)->ma_used)\nPyAPI_FUNC(int) _PyDict_Contains(PyObject *mp, PyObject *key, Py_hash_t hash);\nPyAPI_FUNC(PyObject *) _PyDict_NewPresized(Py_ssize_t minused);\nPyAPI_FUNC(void) _PyDict_MaybeUntrack(PyObject *mp);\nPyAPI_FUNC(int) _PyDict_HasOnlyStringKeys(PyObject *mp);\nPy_ssize_t _PyDict_KeysSize(PyDictKeysObject *keys);\nPyAPI_FUNC(Py_ssize_t) _PyDict_SizeOf(PyDictObject *);\nPyAPI_FUNC(PyObject *) _PyDict_Pop(PyObject *, PyObject *, PyObject *);\nPyObject *_PyDict_Pop_KnownHash(PyObject *, PyObject *, Py_hash_t, PyObject *);\nPyObject *_PyDict_FromKeys(PyObject *, PyObject *, PyObject *);\n#define _PyDict_HasSplitTable(d) ((d)->ma_values != NULL)\n\nPyAPI_FUNC(int) PyDict_ClearFreeList(void);\n\n/* Like PyDict_Merge, but override can be 0, 1 or 2.  If override is 0,\n   the first occurrence of a key wins, if override is 1, the last occurrence\n   of a key wins, if override is 2, a KeyError with conflicting key as\n   argument is raised.\n*/\nPyAPI_FUNC(int) _PyDict_MergeEx(PyObject *mp, PyObject *other, int override);\nPyAPI_FUNC(PyObject *) _PyDict_GetItemId(PyObject *dp, struct _Py_Identifier *key);\nPyAPI_FUNC(int) _PyDict_SetItemId(PyObject *dp, struct _Py_Identifier *key, PyObject *item);\n\nPyAPI_FUNC(int) _PyDict_DelItemId(PyObject *mp, struct _Py_Identifier *key);\nPyAPI_FUNC(void) _PyDict_DebugMallocStats(FILE *out);\n\nint _PyObjectDict_SetItem(PyTypeObject *tp, PyObject **dictptr, PyObject *name, PyObject *value);\nPyObject *_PyDict_LoadGlobal(PyDictObject *, PyDictObject *, PyObject *);\n\n/* _PyDictView */\n\ntypedef struct {\n    PyObject_HEAD\n    PyDictObject *dv_dict;\n} _PyDictViewObject;\n\nPyAPI_FUNC(PyObject *) _PyDictView_New(PyObject *, PyTypeObject *);\nPyAPI_FUNC(PyObject *) _PyDictView_Intersect(PyObject* self, PyObject *other);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "68": {"id": 68, "path": "/usr/include/python3.8/cpython/fileobject.h", "content": "#ifndef Py_CPYTHON_FILEOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(char *) Py_UniversalNewlineFgets(char *, int, FILE*, PyObject *);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000\nPyAPI_DATA(const char *) Py_FileSystemDefaultEncodeErrors;\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000\nPyAPI_DATA(int) Py_UTF8Mode;\n#endif\n\n/* The std printer acts as a preliminary sys.stderr until the new io\n   infrastructure is in place. */\nPyAPI_FUNC(PyObject *) PyFile_NewStdPrinter(int);\nPyAPI_DATA(PyTypeObject) PyStdPrinter_Type;\n\ntypedef PyObject * (*Py_OpenCodeHookFunction)(PyObject *, void *);\n\nPyAPI_FUNC(PyObject *) PyFile_OpenCode(const char *utf8path);\nPyAPI_FUNC(PyObject *) PyFile_OpenCodeObject(PyObject *path);\nPyAPI_FUNC(int) PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "69": {"id": 69, "path": "/usr/include/python3.8/cpython/initconfig.h", "content": "#ifndef Py_PYCORECONFIG_H\n#define Py_PYCORECONFIG_H\n#ifndef Py_LIMITED_API\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* --- PyStatus ----------------------------------------------- */\n\ntypedef struct {\n    enum {\n        _PyStatus_TYPE_OK=0,\n        _PyStatus_TYPE_ERROR=1,\n        _PyStatus_TYPE_EXIT=2\n    } _type;\n    const char *func;\n    const char *err_msg;\n    int exitcode;\n} PyStatus;\n\nPyAPI_FUNC(PyStatus) PyStatus_Ok(void);\nPyAPI_FUNC(PyStatus) PyStatus_Error(const char *err_msg);\nPyAPI_FUNC(PyStatus) PyStatus_NoMemory(void);\nPyAPI_FUNC(PyStatus) PyStatus_Exit(int exitcode);\nPyAPI_FUNC(int) PyStatus_IsError(PyStatus err);\nPyAPI_FUNC(int) PyStatus_IsExit(PyStatus err);\nPyAPI_FUNC(int) PyStatus_Exception(PyStatus err);\n\n/* --- PyWideStringList ------------------------------------------------ */\n\ntypedef struct {\n    /* If length is greater than zero, items must be non-NULL\n       and all items strings must be non-NULL */\n    Py_ssize_t length;\n    wchar_t **items;\n} PyWideStringList;\n\nPyAPI_FUNC(PyStatus) PyWideStringList_Append(PyWideStringList *list,\n    const wchar_t *item);\nPyAPI_FUNC(PyStatus) PyWideStringList_Insert(PyWideStringList *list,\n    Py_ssize_t index,\n    const wchar_t *item);\n\n\n/* --- PyPreConfig ----------------------------------------------- */\n\ntypedef struct {\n    int _config_init;     /* _PyConfigInitEnum value */\n\n    /* Parse Py_PreInitializeFromBytesArgs() arguments?\n       See PyConfig.parse_argv */\n    int parse_argv;\n\n    /* If greater than 0, enable isolated mode: sys.path contains\n       neither the script's directory nor the user's site-packages directory.\n\n       Set to 1 by the -I command line option. If set to -1 (default), inherit\n       Py_IsolatedFlag value. */\n    int isolated;\n\n    /* If greater than 0: use environment variables.\n       Set to 0 by -E command line option. If set to -1 (default), it is\n       set to !Py_IgnoreEnvironmentFlag. */\n    int use_environment;\n\n    /* Set the LC_CTYPE locale to the user preferred locale? If equals to 0,\n       set coerce_c_locale and coerce_c_locale_warn to 0. */\n    int configure_locale;\n\n    /* Coerce the LC_CTYPE locale if it's equal to \"C\"? (PEP 538)\n\n       Set to 0 by PYTHONCOERCECLOCALE=0. Set to 1 by PYTHONCOERCECLOCALE=1.\n       Set to 2 if the user preferred LC_CTYPE locale is \"C\".\n\n       If it is equal to 1, LC_CTYPE locale is read to decide if it should be\n       coerced or not (ex: PYTHONCOERCECLOCALE=1). Internally, it is set to 2\n       if the LC_CTYPE locale must be coerced.\n\n       Disable by default (set to 0). Set it to -1 to let Python decide if it\n       should be enabled or not. */\n    int coerce_c_locale;\n\n    /* Emit a warning if the LC_CTYPE locale is coerced?\n\n       Set to 1 by PYTHONCOERCECLOCALE=warn.\n\n       Disable by default (set to 0). Set it to -1 to let Python decide if it\n       should be enabled or not. */\n    int coerce_c_locale_warn;\n\n#ifdef MS_WINDOWS\n    /* If greater than 1, use the \"mbcs\" encoding instead of the UTF-8\n       encoding for the filesystem encoding.\n\n       Set to 1 if the PYTHONLEGACYWINDOWSFSENCODING environment variable is\n       set to a non-empty string. If set to -1 (default), inherit\n       Py_LegacyWindowsFSEncodingFlag value.\n\n       See PEP 529 for more details. */\n    int legacy_windows_fs_encoding;\n#endif\n\n    /* Enable UTF-8 mode? (PEP 540)\n\n       Disabled by default (equals to 0).\n\n       Set to 1 by \"-X utf8\" and \"-X utf8=1\" command line options.\n       Set to 1 by PYTHONUTF8=1 environment variable.\n\n       Set to 0 by \"-X utf8=0\" and PYTHONUTF8=0.\n\n       If equals to -1, it is set to 1 if the LC_CTYPE locale is \"C\" or\n       \"POSIX\", otherwise it is set to 0. Inherit Py_UTF8Mode value value. */\n    int utf8_mode;\n\n    int dev_mode;           /* Development mode. PYTHONDEVMODE, -X dev */\n\n    /* Memory allocator: PYTHONMALLOC env var.\n       See PyMemAllocatorName for valid values. */\n    int allocator;\n} PyPreConfig;\n\nPyAPI_FUNC(void) PyPreConfig_InitPythonConfig(PyPreConfig *config);\nPyAPI_FUNC(void) PyPreConfig_InitIsolatedConfig(PyPreConfig *config);\n\n\n/* --- PyConfig ---------------------------------------------- */\n\ntypedef struct {\n    int _config_init;     /* _PyConfigInitEnum value */\n\n    int isolated;         /* Isolated mode? see PyPreConfig.isolated */\n    int use_environment;  /* Use environment variables? see PyPreConfig.use_environment */\n    int dev_mode;         /* Development mode? See PyPreConfig.dev_mode */\n\n    /* Install signal handlers? Yes by default. */\n    int install_signal_handlers;\n\n    int use_hash_seed;      /* PYTHONHASHSEED=x */\n    unsigned long hash_seed;\n\n    /* Enable faulthandler?\n       Set to 1 by -X faulthandler and PYTHONFAULTHANDLER. -1 means unset. */\n    int faulthandler;\n\n    /* Enable tracemalloc?\n       Set by -X tracemalloc=N and PYTHONTRACEMALLOC. -1 means unset */\n    int tracemalloc;\n\n    int import_time;        /* PYTHONPROFILEIMPORTTIME, -X importtime */\n    int show_ref_count;     /* -X showrefcount */\n    int show_alloc_count;   /* -X showalloccount */\n    int dump_refs;          /* PYTHONDUMPREFS */\n    int malloc_stats;       /* PYTHONMALLOCSTATS */\n\n    /* Python filesystem encoding and error handler:\n       sys.getfilesystemencoding() and sys.getfilesystemencodeerrors().\n\n       Default encoding and error handler:\n\n       * if Py_SetStandardStreamEncoding() has been called: they have the\n         highest priority;\n       * PYTHONIOENCODING environment variable;\n       * The UTF-8 Mode uses UTF-8/surrogateescape;\n       * If Python forces the usage of the ASCII encoding (ex: C locale\n         or POSIX locale on FreeBSD or HP-UX), use ASCII/surrogateescape;\n       * locale encoding: ANSI code page on Windows, UTF-8 on Android and\n         VxWorks, LC_CTYPE locale encoding on other platforms;\n       * On Windows, \"surrogateescape\" error handler;\n       * \"surrogateescape\" error handler if the LC_CTYPE locale is \"C\" or \"POSIX\";\n       * \"surrogateescape\" error handler if the LC_CTYPE locale has been coerced\n         (PEP 538);\n       * \"strict\" error handler.\n\n       Supported error handlers: \"strict\", \"surrogateescape\" and\n       \"surrogatepass\". The surrogatepass error handler is only supported\n       if Py_DecodeLocale() and Py_EncodeLocale() use directly the UTF-8 codec;\n       it's only used on Windows.\n\n       initfsencoding() updates the encoding to the Python codec name.\n       For example, \"ANSI_X3.4-1968\" is replaced with \"ascii\".\n\n       On Windows, sys._enablelegacywindowsfsencoding() sets the\n       encoding/errors to mbcs/replace at runtime.\n\n\n       See Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors.\n       */\n    wchar_t *filesystem_encoding;\n    wchar_t *filesystem_errors;\n\n    wchar_t *pycache_prefix;  /* PYTHONPYCACHEPREFIX, -X pycache_prefix=PATH */\n    int parse_argv;           /* Parse argv command line arguments? */\n\n    /* Command line arguments (sys.argv).\n\n       Set parse_argv to 1 to parse argv as Python command line arguments\n       and then strip Python arguments from argv.\n\n       If argv is empty, an empty string is added to ensure that sys.argv\n       always exists and is never empty. */\n    PyWideStringList argv;\n\n    /* Program name:\n\n       - If Py_SetProgramName() was called, use its value.\n       - On macOS, use PYTHONEXECUTABLE environment variable if set.\n       - If WITH_NEXT_FRAMEWORK macro is defined, use __PYVENV_LAUNCHER__\n         environment variable is set.\n       - Use argv[0] if available and non-empty.\n       - Use \"python\" on Windows, or \"python3 on other platforms. */\n    wchar_t *program_name;\n\n    PyWideStringList xoptions;     /* Command line -X options */\n\n    /* Warnings options: lowest to highest priority. warnings.filters\n       is built in the reverse order (highest to lowest priority). */\n    PyWideStringList warnoptions;\n\n    /* If equal to zero, disable the import of the module site and the\n       site-dependent manipulations of sys.path that it entails. Also disable\n       these manipulations if site is explicitly imported later (call\n       site.main() if you want them to be triggered).\n\n       Set to 0 by the -S command line option. If set to -1 (default), it is\n       set to !Py_NoSiteFlag. */\n    int site_import;\n\n    /* Bytes warnings:\n\n       * If equal to 1, issue a warning when comparing bytes or bytearray with\n         str or bytes with int.\n       * If equal or greater to 2, issue an error.\n\n       Incremented by the -b command line option. If set to -1 (default), inherit\n       Py_BytesWarningFlag value. */\n    int bytes_warning;\n\n    /* If greater than 0, enable inspect: when a script is passed as first\n       argument or the -c option is used, enter interactive mode after\n       executing the script or the command, even when sys.stdin does not appear\n       to be a terminal.\n\n       Incremented by the -i command line option. Set to 1 if the PYTHONINSPECT\n       environment variable is non-empty. If set to -1 (default), inherit\n       Py_InspectFlag value. */\n    int inspect;\n\n    /* If greater than 0: enable the interactive mode (REPL).\n\n       Incremented by the -i command line option. If set to -1 (default),\n       inherit Py_InteractiveFlag value. */\n    int interactive;\n\n    /* Optimization level.\n\n       Incremented by the -O command line option. Set by the PYTHONOPTIMIZE\n       environment variable. If set to -1 (default), inherit Py_OptimizeFlag\n       value. */\n    int optimization_level;\n\n    /* If greater than 0, enable the debug mode: turn on parser debugging\n       output (for expert only, depending on compilation options).\n\n       Incremented by the -d command line option. Set by the PYTHONDEBUG\n       environment variable. If set to -1 (default), inherit Py_DebugFlag\n       value. */\n    int parser_debug;\n\n    /* If equal to 0, Python won't try to write ``.pyc`` files on the\n       import of source modules.\n\n       Set to 0 by the -B command line option and the PYTHONDONTWRITEBYTECODE\n       environment variable. If set to -1 (default), it is set to\n       !Py_DontWriteBytecodeFlag. */\n    int write_bytecode;\n\n    /* If greater than 0, enable the verbose mode: print a message each time a\n       module is initialized, showing the place (filename or built-in module)\n       from which it is loaded.\n\n       If greater or equal to 2, print a message for each file that is checked\n       for when searching for a module. Also provides information on module\n       cleanup at exit.\n\n       Incremented by the -v option. Set by the PYTHONVERBOSE environment\n       variable. If set to -1 (default), inherit Py_VerboseFlag value. */\n    int verbose;\n\n    /* If greater than 0, enable the quiet mode: Don't display the copyright\n       and version messages even in interactive mode.\n\n       Incremented by the -q option. If set to -1 (default), inherit\n       Py_QuietFlag value. */\n    int quiet;\n\n   /* If greater than 0, don't add the user site-packages directory to\n      sys.path.\n\n      Set to 0 by the -s and -I command line options , and the PYTHONNOUSERSITE\n      environment variable. If set to -1 (default), it is set to\n      !Py_NoUserSiteDirectory. */\n    int user_site_directory;\n\n    /* If non-zero, configure C standard steams (stdio, stdout,\n       stderr):\n\n       - Set O_BINARY mode on Windows.\n       - If buffered_stdio is equal to zero, make streams unbuffered.\n         Otherwise, enable streams buffering if interactive is non-zero. */\n    int configure_c_stdio;\n\n    /* If equal to 0, enable unbuffered mode: force the stdout and stderr\n       streams to be unbuffered.\n\n       Set to 0 by the -u option. Set by the PYTHONUNBUFFERED environment\n       variable.\n       If set to -1 (default), it is set to !Py_UnbufferedStdioFlag. */\n    int buffered_stdio;\n\n    /* Encoding of sys.stdin, sys.stdout and sys.stderr.\n       Value set from PYTHONIOENCODING environment variable and\n       Py_SetStandardStreamEncoding() function.\n       See also 'stdio_errors' attribute. */\n    wchar_t *stdio_encoding;\n\n    /* Error handler of sys.stdin and sys.stdout.\n       Value set from PYTHONIOENCODING environment variable and\n       Py_SetStandardStreamEncoding() function.\n       See also 'stdio_encoding' attribute. */\n    wchar_t *stdio_errors;\n\n#ifdef MS_WINDOWS\n    /* If greater than zero, use io.FileIO instead of WindowsConsoleIO for sys\n       standard streams.\n\n       Set to 1 if the PYTHONLEGACYWINDOWSSTDIO environment variable is set to\n       a non-empty string. If set to -1 (default), inherit\n       Py_LegacyWindowsStdioFlag value.\n\n       See PEP 528 for more details. */\n    int legacy_windows_stdio;\n#endif\n\n    /* Value of the --check-hash-based-pycs command line option:\n\n       - \"default\" means the 'check_source' flag in hash-based pycs\n         determines invalidation\n       - \"always\" causes the interpreter to hash the source file for\n         invalidation regardless of value of 'check_source' bit\n       - \"never\" causes the interpreter to always assume hash-based pycs are\n         valid\n\n       The default value is \"default\".\n\n       See PEP 552 \"Deterministic pycs\" for more details. */\n    wchar_t *check_hash_pycs_mode;\n\n    /* --- Path configuration inputs ------------ */\n\n    /* If greater than 0, suppress _PyPathConfig_Calculate() warnings on Unix.\n       The parameter has no effect on Windows.\n\n       If set to -1 (default), inherit !Py_FrozenFlag value. */\n    int pathconfig_warnings;\n\n    wchar_t *pythonpath_env; /* PYTHONPATH environment variable */\n    wchar_t *home;          /* PYTHONHOME environment variable,\n                               see also Py_SetPythonHome(). */\n\n    /* --- Path configuration outputs ----------- */\n\n    int module_search_paths_set;  /* If non-zero, use module_search_paths */\n    PyWideStringList module_search_paths;  /* sys.path paths. Computed if\n                                       module_search_paths_set is equal\n                                       to zero. */\n\n    wchar_t *executable;        /* sys.executable */\n    wchar_t *base_executable;   /* sys._base_executable */\n    wchar_t *prefix;            /* sys.prefix */\n    wchar_t *base_prefix;       /* sys.base_prefix */\n    wchar_t *exec_prefix;       /* sys.exec_prefix */\n    wchar_t *base_exec_prefix;  /* sys.base_exec_prefix */\n\n    /* --- Parameter only used by Py_Main() ---------- */\n\n    /* Skip the first line of the source ('run_filename' parameter), allowing use of non-Unix forms of\n       \"#!cmd\".  This is intended for a DOS specific hack only.\n\n       Set by the -x command line option. */\n    int skip_source_first_line;\n\n    wchar_t *run_command;   /* -c command line argument */\n    wchar_t *run_module;    /* -m command line argument */\n    wchar_t *run_filename;  /* Trailing command line argument without -c or -m */\n\n    /* --- Private fields ---------------------------- */\n\n    /* Install importlib? If set to 0, importlib is not initialized at all.\n       Needed by freeze_importlib. */\n    int _install_importlib;\n\n    /* If equal to 0, stop Python initialization before the \"main\" phase */\n    int _init_main;\n} PyConfig;\n\nPyAPI_FUNC(void) PyConfig_InitPythonConfig(PyConfig *config);\nPyAPI_FUNC(void) PyConfig_InitIsolatedConfig(PyConfig *config);\nPyAPI_FUNC(void) PyConfig_Clear(PyConfig *);\nPyAPI_FUNC(PyStatus) PyConfig_SetString(\n    PyConfig *config,\n    wchar_t **config_str,\n    const wchar_t *str);\nPyAPI_FUNC(PyStatus) PyConfig_SetBytesString(\n    PyConfig *config,\n    wchar_t **config_str,\n    const char *str);\nPyAPI_FUNC(PyStatus) PyConfig_Read(PyConfig *config);\nPyAPI_FUNC(PyStatus) PyConfig_SetBytesArgv(\n    PyConfig *config,\n    Py_ssize_t argc,\n    char * const *argv);\nPyAPI_FUNC(PyStatus) PyConfig_SetArgv(PyConfig *config,\n    Py_ssize_t argc,\n    wchar_t * const *argv);\nPyAPI_FUNC(PyStatus) PyConfig_SetWideStringList(PyConfig *config,\n    PyWideStringList *list,\n    Py_ssize_t length, wchar_t **items);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_LIMITED_API */\n#endif /* !Py_PYCORECONFIG_H */\n"}, "70": {"id": 70, "path": "/usr/include/python3.8/cpython/object.h", "content": "#ifndef Py_CPYTHON_OBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/********************* String Literals ****************************************/\n/* This structure helps managing static strings. The basic usage goes like this:\n   Instead of doing\n\n       r = PyObject_CallMethod(o, \"foo\", \"args\", ...);\n\n   do\n\n       _Py_IDENTIFIER(foo);\n       ...\n       r = _PyObject_CallMethodId(o, &PyId_foo, \"args\", ...);\n\n   PyId_foo is a static variable, either on block level or file level. On first\n   usage, the string \"foo\" is interned, and the structures are linked. On interpreter\n   shutdown, all strings are released (through _PyUnicode_ClearStaticStrings).\n\n   Alternatively, _Py_static_string allows choosing the variable name.\n   _PyUnicode_FromId returns a borrowed reference to the interned string.\n   _PyObject_{Get,Set,Has}AttrId are __getattr__ versions using _Py_Identifier*.\n*/\ntypedef struct _Py_Identifier {\n    struct _Py_Identifier *next;\n    const char* string;\n    PyObject *object;\n} _Py_Identifier;\n\n#define _Py_static_string_init(value) { .next = NULL, .string = value, .object = NULL }\n#define _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)\n#define _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)\n\n/* buffer interface */\ntypedef struct bufferinfo {\n    void *buf;\n    PyObject *obj;        /* owned reference */\n    Py_ssize_t len;\n    Py_ssize_t itemsize;  /* This is Py_ssize_t so it can be\n                             pointed to by strides in simple case.*/\n    int readonly;\n    int ndim;\n    char *format;\n    Py_ssize_t *shape;\n    Py_ssize_t *strides;\n    Py_ssize_t *suboffsets;\n    void *internal;\n} Py_buffer;\n\ntypedef int (*getbufferproc)(PyObject *, Py_buffer *, int);\ntypedef void (*releasebufferproc)(PyObject *, Py_buffer *);\n\ntypedef PyObject *(*vectorcallfunc)(PyObject *callable, PyObject *const *args,\n                                    size_t nargsf, PyObject *kwnames);\n\n/* Maximum number of dimensions */\n#define PyBUF_MAX_NDIM 64\n\n/* Flags for getting buffers */\n#define PyBUF_SIMPLE 0\n#define PyBUF_WRITABLE 0x0001\n/*  we used to include an E, backwards compatible alias  */\n#define PyBUF_WRITEABLE PyBUF_WRITABLE\n#define PyBUF_FORMAT 0x0004\n#define PyBUF_ND 0x0008\n#define PyBUF_STRIDES (0x0010 | PyBUF_ND)\n#define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)\n#define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)\n#define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)\n#define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)\n\n#define PyBUF_CONTIG (PyBUF_ND | PyBUF_WRITABLE)\n#define PyBUF_CONTIG_RO (PyBUF_ND)\n\n#define PyBUF_STRIDED (PyBUF_STRIDES | PyBUF_WRITABLE)\n#define PyBUF_STRIDED_RO (PyBUF_STRIDES)\n\n#define PyBUF_RECORDS (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT)\n#define PyBUF_RECORDS_RO (PyBUF_STRIDES | PyBUF_FORMAT)\n\n#define PyBUF_FULL (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT)\n#define PyBUF_FULL_RO (PyBUF_INDIRECT | PyBUF_FORMAT)\n\n\n#define PyBUF_READ  0x100\n#define PyBUF_WRITE 0x200\n/* End buffer interface */\n\n\ntypedef struct {\n    /* Number implementations must check *both*\n       arguments for proper type and implement the necessary conversions\n       in the slot functions themselves. */\n\n    binaryfunc nb_add;\n    binaryfunc nb_subtract;\n    binaryfunc nb_multiply;\n    binaryfunc nb_remainder;\n    binaryfunc nb_divmod;\n    ternaryfunc nb_power;\n    unaryfunc nb_negative;\n    unaryfunc nb_positive;\n    unaryfunc nb_absolute;\n    inquiry nb_bool;\n    unaryfunc nb_invert;\n    binaryfunc nb_lshift;\n    binaryfunc nb_rshift;\n    binaryfunc nb_and;\n    binaryfunc nb_xor;\n    binaryfunc nb_or;\n    unaryfunc nb_int;\n    void *nb_reserved;  /* the slot formerly known as nb_long */\n    unaryfunc nb_float;\n\n    binaryfunc nb_inplace_add;\n    binaryfunc nb_inplace_subtract;\n    binaryfunc nb_inplace_multiply;\n    binaryfunc nb_inplace_remainder;\n    ternaryfunc nb_inplace_power;\n    binaryfunc nb_inplace_lshift;\n    binaryfunc nb_inplace_rshift;\n    binaryfunc nb_inplace_and;\n    binaryfunc nb_inplace_xor;\n    binaryfunc nb_inplace_or;\n\n    binaryfunc nb_floor_divide;\n    binaryfunc nb_true_divide;\n    binaryfunc nb_inplace_floor_divide;\n    binaryfunc nb_inplace_true_divide;\n\n    unaryfunc nb_index;\n\n    binaryfunc nb_matrix_multiply;\n    binaryfunc nb_inplace_matrix_multiply;\n} PyNumberMethods;\n\ntypedef struct {\n    lenfunc sq_length;\n    binaryfunc sq_concat;\n    ssizeargfunc sq_repeat;\n    ssizeargfunc sq_item;\n    void *was_sq_slice;\n    ssizeobjargproc sq_ass_item;\n    void *was_sq_ass_slice;\n    objobjproc sq_contains;\n\n    binaryfunc sq_inplace_concat;\n    ssizeargfunc sq_inplace_repeat;\n} PySequenceMethods;\n\ntypedef struct {\n    lenfunc mp_length;\n    binaryfunc mp_subscript;\n    objobjargproc mp_ass_subscript;\n} PyMappingMethods;\n\ntypedef struct {\n    unaryfunc am_await;\n    unaryfunc am_aiter;\n    unaryfunc am_anext;\n} PyAsyncMethods;\n\ntypedef struct {\n     getbufferproc bf_getbuffer;\n     releasebufferproc bf_releasebuffer;\n} PyBufferProcs;\n\n/* Allow printfunc in the tp_vectorcall_offset slot for\n * backwards-compatibility */\ntypedef Py_ssize_t printfunc;\n\ntypedef struct _typeobject {\n    PyObject_VAR_HEAD\n    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n\n    /* Methods to implement standard operations */\n\n    destructor tp_dealloc;\n    Py_ssize_t tp_vectorcall_offset;\n    getattrfunc tp_getattr;\n    setattrfunc tp_setattr;\n    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n                                    or tp_reserved (Python 3) */\n    reprfunc tp_repr;\n\n    /* Method suites for standard classes */\n\n    PyNumberMethods *tp_as_number;\n    PySequenceMethods *tp_as_sequence;\n    PyMappingMethods *tp_as_mapping;\n\n    /* More standard operations (here for binary compatibility) */\n\n    hashfunc tp_hash;\n    ternaryfunc tp_call;\n    reprfunc tp_str;\n    getattrofunc tp_getattro;\n    setattrofunc tp_setattro;\n\n    /* Functions to access object as input/output buffer */\n    PyBufferProcs *tp_as_buffer;\n\n    /* Flags to define presence of optional/expanded features */\n    unsigned long tp_flags;\n\n    const char *tp_doc; /* Documentation string */\n\n    /* Assigned meaning in release 2.0 */\n    /* call function for all accessible objects */\n    traverseproc tp_traverse;\n\n    /* delete references to contained objects */\n    inquiry tp_clear;\n\n    /* Assigned meaning in release 2.1 */\n    /* rich comparisons */\n    richcmpfunc tp_richcompare;\n\n    /* weak reference enabler */\n    Py_ssize_t tp_weaklistoffset;\n\n    /* Iterators */\n    getiterfunc tp_iter;\n    iternextfunc tp_iternext;\n\n    /* Attribute descriptor and subclassing stuff */\n    struct PyMethodDef *tp_methods;\n    struct PyMemberDef *tp_members;\n    struct PyGetSetDef *tp_getset;\n    struct _typeobject *tp_base;\n    PyObject *tp_dict;\n    descrgetfunc tp_descr_get;\n    descrsetfunc tp_descr_set;\n    Py_ssize_t tp_dictoffset;\n    initproc tp_init;\n    allocfunc tp_alloc;\n    newfunc tp_new;\n    freefunc tp_free; /* Low-level free-memory routine */\n    inquiry tp_is_gc; /* For PyObject_IS_GC */\n    PyObject *tp_bases;\n    PyObject *tp_mro; /* method resolution order */\n    PyObject *tp_cache;\n    PyObject *tp_subclasses;\n    PyObject *tp_weaklist;\n    destructor tp_del;\n\n    /* Type attribute cache version tag. Added in version 2.6 */\n    unsigned int tp_version_tag;\n\n    destructor tp_finalize;\n    vectorcallfunc tp_vectorcall;\n\n    /* bpo-37250: kept for backwards compatibility in CPython 3.8 only */\n    Py_DEPRECATED(3.8) int (*tp_print)(PyObject *, FILE *, int);\n\n#ifdef COUNT_ALLOCS\n    /* these must be last and never explicitly initialized */\n    Py_ssize_t tp_allocs;\n    Py_ssize_t tp_frees;\n    Py_ssize_t tp_maxalloc;\n    struct _typeobject *tp_prev;\n    struct _typeobject *tp_next;\n#endif\n} PyTypeObject;\n\n/* The *real* layout of a type object when allocated on the heap */\ntypedef struct _heaptypeobject {\n    /* Note: there's a dependency on the order of these members\n       in slotptr() in typeobject.c . */\n    PyTypeObject ht_type;\n    PyAsyncMethods as_async;\n    PyNumberMethods as_number;\n    PyMappingMethods as_mapping;\n    PySequenceMethods as_sequence; /* as_sequence comes after as_mapping,\n                                      so that the mapping wins when both\n                                      the mapping and the sequence define\n                                      a given operator (e.g. __getitem__).\n                                      see add_operators() in typeobject.c . */\n    PyBufferProcs as_buffer;\n    PyObject *ht_name, *ht_slots, *ht_qualname;\n    struct _dictkeysobject *ht_cached_keys;\n    /* here are optional user slots, followed by the members. */\n} PyHeapTypeObject;\n\n/* access macro to the members which are floating \"behind\" the object */\n#define PyHeapType_GET_MEMBERS(etype) \\\n    ((PyMemberDef *)(((char *)etype) + Py_TYPE(etype)->tp_basicsize))\n\nPyAPI_FUNC(const char *) _PyType_Name(PyTypeObject *);\nPyAPI_FUNC(PyObject *) _PyType_Lookup(PyTypeObject *, PyObject *);\nPyAPI_FUNC(PyObject *) _PyType_LookupId(PyTypeObject *, _Py_Identifier *);\nPyAPI_FUNC(PyObject *) _PyObject_LookupSpecial(PyObject *, _Py_Identifier *);\nPyAPI_FUNC(PyTypeObject *) _PyType_CalculateMetaclass(PyTypeObject *, PyObject *);\nPyAPI_FUNC(PyObject *) _PyType_GetDocFromInternalDoc(const char *, const char *);\nPyAPI_FUNC(PyObject *) _PyType_GetTextSignatureFromInternalDoc(const char *, const char *);\n\nstruct _Py_Identifier;\nPyAPI_FUNC(int) PyObject_Print(PyObject *, FILE *, int);\nPyAPI_FUNC(void) _Py_BreakPoint(void);\nPyAPI_FUNC(void) _PyObject_Dump(PyObject *);\nPyAPI_FUNC(int) _PyObject_IsFreed(PyObject *);\n\nPyAPI_FUNC(int) _PyObject_IsAbstract(PyObject *);\nPyAPI_FUNC(PyObject *) _PyObject_GetAttrId(PyObject *, struct _Py_Identifier *);\nPyAPI_FUNC(int) _PyObject_SetAttrId(PyObject *, struct _Py_Identifier *, PyObject *);\nPyAPI_FUNC(int) _PyObject_HasAttrId(PyObject *, struct _Py_Identifier *);\n/* Replacements of PyObject_GetAttr() and _PyObject_GetAttrId() which\n   don't raise AttributeError.\n\n   Return 1 and set *result != NULL if an attribute is found.\n   Return 0 and set *result == NULL if an attribute is not found;\n   an AttributeError is silenced.\n   Return -1 and set *result == NULL if an error other than AttributeError\n   is raised.\n*/\nPyAPI_FUNC(int) _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **);\nPyAPI_FUNC(int) _PyObject_LookupAttrId(PyObject *, struct _Py_Identifier *, PyObject **);\nPyAPI_FUNC(PyObject **) _PyObject_GetDictPtr(PyObject *);\nPyAPI_FUNC(PyObject *) _PyObject_NextNotImplemented(PyObject *);\nPyAPI_FUNC(void) PyObject_CallFinalizer(PyObject *);\nPyAPI_FUNC(int) PyObject_CallFinalizerFromDealloc(PyObject *);\n\n/* Same as PyObject_Generic{Get,Set}Attr, but passing the attributes\n   dict as the last parameter. */\nPyAPI_FUNC(PyObject *)\n_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int);\nPyAPI_FUNC(int)\n_PyObject_GenericSetAttrWithDict(PyObject *, PyObject *,\n                                 PyObject *, PyObject *);\n\n#define PyType_HasFeature(t,f)  (((t)->tp_flags & (f)) != 0)\n\nstatic inline void _Py_Dealloc_inline(PyObject *op)\n{\n    destructor dealloc = Py_TYPE(op)->tp_dealloc;\n#ifdef Py_TRACE_REFS\n    _Py_ForgetReference(op);\n#else\n    _Py_INC_TPFREES(op);\n#endif\n    (*dealloc)(op);\n}\n#define _Py_Dealloc(op) _Py_Dealloc_inline(op)\n\n\n/* Safely decref `op` and set `op` to `op2`.\n *\n * As in case of Py_CLEAR \"the obvious\" code can be deadly:\n *\n *     Py_DECREF(op);\n *     op = op2;\n *\n * The safe way is:\n *\n *      Py_SETREF(op, op2);\n *\n * That arranges to set `op` to `op2` _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * Py_XSETREF is a variant of Py_SETREF that uses Py_XDECREF instead of\n * Py_DECREF.\n */\n\n#define Py_SETREF(op, op2)                      \\\n    do {                                        \\\n        PyObject *_py_tmp = _PyObject_CAST(op); \\\n        (op) = (op2);                           \\\n        Py_DECREF(_py_tmp);                     \\\n    } while (0)\n\n#define Py_XSETREF(op, op2)                     \\\n    do {                                        \\\n        PyObject *_py_tmp = _PyObject_CAST(op); \\\n        (op) = (op2);                           \\\n        Py_XDECREF(_py_tmp);                    \\\n    } while (0)\n\n\nPyAPI_DATA(PyTypeObject) _PyNone_Type;\nPyAPI_DATA(PyTypeObject) _PyNotImplemented_Type;\n\n/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.\n * Defined in object.c.\n */\nPyAPI_DATA(int) _Py_SwappedOp[];\n\n/* This is the old private API, invoked by the macros before 3.2.4.\n   Kept for binary compatibility of extensions using the stable ABI. */\nPyAPI_FUNC(void) _PyTrash_deposit_object(PyObject*);\nPyAPI_FUNC(void) _PyTrash_destroy_chain(void);\n\nPyAPI_FUNC(void)\n_PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks,\n                       size_t sizeof_block);\nPyAPI_FUNC(void)\n_PyObject_DebugTypeStats(FILE *out);\n\n/* Define a pair of assertion macros:\n   _PyObject_ASSERT_FROM(), _PyObject_ASSERT_WITH_MSG() and _PyObject_ASSERT().\n\n   These work like the regular C assert(), in that they will abort the\n   process with a message on stderr if the given condition fails to hold,\n   but compile away to nothing if NDEBUG is defined.\n\n   However, before aborting, Python will also try to call _PyObject_Dump() on\n   the given object.  This may be of use when investigating bugs in which a\n   particular object is corrupt (e.g. buggy a tp_visit method in an extension\n   module breaking the garbage collector), to help locate the broken objects.\n\n   The WITH_MSG variant allows you to supply an additional message that Python\n   will attempt to print to stderr, after the object dump. */\n#ifdef NDEBUG\n   /* No debugging: compile away the assertions: */\n#  define _PyObject_ASSERT_FROM(obj, expr, msg, filename, lineno, func) \\\n    ((void)0)\n#else\n   /* With debugging: generate checks: */\n#  define _PyObject_ASSERT_FROM(obj, expr, msg, filename, lineno, func) \\\n    ((expr) \\\n      ? (void)(0) \\\n      : _PyObject_AssertFailed((obj), Py_STRINGIFY(expr), \\\n                               (msg), (filename), (lineno), (func)))\n#endif\n\n#define _PyObject_ASSERT_WITH_MSG(obj, expr, msg) \\\n    _PyObject_ASSERT_FROM(obj, expr, msg, __FILE__, __LINE__, __func__)\n#define _PyObject_ASSERT(obj, expr) \\\n    _PyObject_ASSERT_WITH_MSG(obj, expr, NULL)\n\n#define _PyObject_ASSERT_FAILED_MSG(obj, msg) \\\n    _PyObject_AssertFailed((obj), NULL, (msg), __FILE__, __LINE__, __func__)\n\n/* Declare and define _PyObject_AssertFailed() even when NDEBUG is defined,\n   to avoid causing compiler/linker errors when building extensions without\n   NDEBUG against a Python built with NDEBUG defined.\n\n   msg, expr and function can be NULL. */\nPyAPI_FUNC(void) _PyObject_AssertFailed(\n    PyObject *obj,\n    const char *expr,\n    const char *msg,\n    const char *file,\n    int line,\n    const char *function);\n\n/* Check if an object is consistent. For example, ensure that the reference\n   counter is greater than or equal to 1, and ensure that ob_type is not NULL.\n\n   Call _PyObject_AssertFailed() if the object is inconsistent.\n\n   If check_content is zero, only check header fields: reduce the overhead.\n\n   The function always return 1. The return value is just here to be able to\n   write:\n\n   assert(_PyObject_CheckConsistency(obj, 1)); */\nPyAPI_FUNC(int) _PyObject_CheckConsistency(\n    PyObject *op,\n    int check_content);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "71": {"id": 71, "path": "/usr/include/python3.8/cpython/objimpl.h", "content": "#ifndef Py_CPYTHON_OBJIMPL_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* This function returns the number of allocated memory blocks, regardless of size */\nPyAPI_FUNC(Py_ssize_t) _Py_GetAllocatedBlocks(void);\n\n/* Macros */\n#ifdef WITH_PYMALLOC\nPyAPI_FUNC(int) _PyObject_DebugMallocStats(FILE *out);\n#endif\n\n\ntypedef struct {\n    /* user context passed as the first argument to the 2 functions */\n    void *ctx;\n\n    /* allocate an arena of size bytes */\n    void* (*alloc) (void *ctx, size_t size);\n\n    /* free an arena */\n    void (*free) (void *ctx, void *ptr, size_t size);\n} PyObjectArenaAllocator;\n\n/* Get the arena allocator. */\nPyAPI_FUNC(void) PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator);\n\n/* Set the arena allocator. */\nPyAPI_FUNC(void) PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator);\n\n\nPyAPI_FUNC(Py_ssize_t) _PyGC_CollectNoFail(void);\nPyAPI_FUNC(Py_ssize_t) _PyGC_CollectIfEnabled(void);\n\n\n/* Test if an object has a GC head */\n#define PyObject_IS_GC(o) \\\n    (PyType_IS_GC(Py_TYPE(o)) \\\n     && (Py_TYPE(o)->tp_is_gc == NULL || Py_TYPE(o)->tp_is_gc(o)))\n\n/* GC information is stored BEFORE the object structure. */\ntypedef struct {\n    // Pointer to next object in the list.\n    // 0 means the object is not tracked\n    uintptr_t _gc_next;\n\n    // Pointer to previous object in the list.\n    // Lowest two bits are used for flags documented later.\n    uintptr_t _gc_prev;\n} PyGC_Head;\n\n#define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)\n\n/* True if the object is currently tracked by the GC. */\n#define _PyObject_GC_IS_TRACKED(o) (_Py_AS_GC(o)->_gc_next != 0)\n\n/* True if the object may be tracked by the GC in the future, or already is.\n   This can be useful to implement some optimizations. */\n#define _PyObject_GC_MAY_BE_TRACKED(obj) \\\n    (PyObject_IS_GC(obj) && \\\n        (!PyTuple_CheckExact(obj) || _PyObject_GC_IS_TRACKED(obj)))\n\n\n/* Bit flags for _gc_prev */\n/* Bit 0 is set when tp_finalize is called */\n#define _PyGC_PREV_MASK_FINALIZED  (1)\n/* Bit 1 is set when the object is in generation which is GCed currently. */\n#define _PyGC_PREV_MASK_COLLECTING (2)\n/* The (N-2) most significant bits contain the real address. */\n#define _PyGC_PREV_SHIFT           (2)\n#define _PyGC_PREV_MASK            (((uintptr_t) -1) << _PyGC_PREV_SHIFT)\n\n// Lowest bit of _gc_next is used for flags only in GC.\n// But it is always 0 for normal code.\n#define _PyGCHead_NEXT(g)        ((PyGC_Head*)(g)->_gc_next)\n#define _PyGCHead_SET_NEXT(g, p) ((g)->_gc_next = (uintptr_t)(p))\n\n// Lowest two bits of _gc_prev is used for _PyGC_PREV_MASK_* flags.\n#define _PyGCHead_PREV(g) ((PyGC_Head*)((g)->_gc_prev & _PyGC_PREV_MASK))\n#define _PyGCHead_SET_PREV(g, p) do { \\\n    assert(((uintptr_t)p & ~_PyGC_PREV_MASK) == 0); \\\n    (g)->_gc_prev = ((g)->_gc_prev & ~_PyGC_PREV_MASK) \\\n        | ((uintptr_t)(p)); \\\n    } while (0)\n\n#define _PyGCHead_FINALIZED(g) \\\n    (((g)->_gc_prev & _PyGC_PREV_MASK_FINALIZED) != 0)\n#define _PyGCHead_SET_FINALIZED(g) \\\n    ((g)->_gc_prev |= _PyGC_PREV_MASK_FINALIZED)\n\n#define _PyGC_FINALIZED(o) \\\n    _PyGCHead_FINALIZED(_Py_AS_GC(o))\n#define _PyGC_SET_FINALIZED(o) \\\n    _PyGCHead_SET_FINALIZED(_Py_AS_GC(o))\n\n\nPyAPI_FUNC(PyObject *) _PyObject_GC_Malloc(size_t size);\nPyAPI_FUNC(PyObject *) _PyObject_GC_Calloc(size_t size);\n\n\n/* Test if a type supports weak references */\n#define PyType_SUPPORTS_WEAKREFS(t) ((t)->tp_weaklistoffset > 0)\n\n#define PyObject_GET_WEAKREFS_LISTPTR(o) \\\n    ((PyObject **) (((char *) (o)) + Py_TYPE(o)->tp_weaklistoffset))\n\n#ifdef __cplusplus\n}\n#endif\n"}, "72": {"id": 72, "path": "/usr/include/python3.8/cpython/pyerrors.h", "content": "#ifndef Py_CPYTHON_ERRORS_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Error objects */\n\n/* PyException_HEAD defines the initial segment of every exception class. */\n#define PyException_HEAD PyObject_HEAD PyObject *dict;\\\n             PyObject *args; PyObject *traceback;\\\n             PyObject *context; PyObject *cause;\\\n             char suppress_context;\n\ntypedef struct {\n    PyException_HEAD\n} PyBaseExceptionObject;\n\ntypedef struct {\n    PyException_HEAD\n    PyObject *msg;\n    PyObject *filename;\n    PyObject *lineno;\n    PyObject *offset;\n    PyObject *text;\n    PyObject *print_file_and_line;\n} PySyntaxErrorObject;\n\ntypedef struct {\n    PyException_HEAD\n    PyObject *msg;\n    PyObject *name;\n    PyObject *path;\n} PyImportErrorObject;\n\ntypedef struct {\n    PyException_HEAD\n    PyObject *encoding;\n    PyObject *object;\n    Py_ssize_t start;\n    Py_ssize_t end;\n    PyObject *reason;\n} PyUnicodeErrorObject;\n\ntypedef struct {\n    PyException_HEAD\n    PyObject *code;\n} PySystemExitObject;\n\ntypedef struct {\n    PyException_HEAD\n    PyObject *myerrno;\n    PyObject *strerror;\n    PyObject *filename;\n    PyObject *filename2;\n#ifdef MS_WINDOWS\n    PyObject *winerror;\n#endif\n    Py_ssize_t written;   /* only for BlockingIOError, -1 otherwise */\n} PyOSErrorObject;\n\ntypedef struct {\n    PyException_HEAD\n    PyObject *value;\n} PyStopIterationObject;\n\n/* Compatibility typedefs */\ntypedef PyOSErrorObject PyEnvironmentErrorObject;\n#ifdef MS_WINDOWS\ntypedef PyOSErrorObject PyWindowsErrorObject;\n#endif\n\n/* Error handling definitions */\n\nPyAPI_FUNC(void) _PyErr_SetKeyError(PyObject *);\n_PyErr_StackItem *_PyErr_GetTopmostException(PyThreadState *tstate);\n\n/* Context manipulation (PEP 3134) */\n\nPyAPI_FUNC(void) _PyErr_ChainExceptions(PyObject *, PyObject *, PyObject *);\n\n/* */\n\n#define PyExceptionClass_Name(x)  (((PyTypeObject*)(x))->tp_name)\n\n/* Convenience functions */\n\n#ifdef MS_WINDOWS\nPy_DEPRECATED(3.3)\nPyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithUnicodeFilename(\n    PyObject *, const Py_UNICODE *);\n#endif /* MS_WINDOWS */\n\n/* Like PyErr_Format(), but saves current exception as __context__ and\n   __cause__.\n */\nPyAPI_FUNC(PyObject *) _PyErr_FormatFromCause(\n    PyObject *exception,\n    const char *format,   /* ASCII-encoded string  */\n    ...\n    );\n\n#ifdef MS_WINDOWS\n/* XXX redeclare to use WSTRING */\nPy_DEPRECATED(3.3)\nPyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithUnicodeFilename(\n    int, const Py_UNICODE *);\nPy_DEPRECATED(3.3)\nPyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithUnicodeFilename(\n    PyObject *,int, const Py_UNICODE *);\n#endif\n\n/* In exceptions.c */\n\n/* Helper that attempts to replace the current exception with one of the\n * same type but with a prefix added to the exception text. The resulting\n * exception description looks like:\n *\n *     prefix (exc_type: original_exc_str)\n *\n * Only some exceptions can be safely replaced. If the function determines\n * it isn't safe to perform the replacement, it will leave the original\n * unmodified exception in place.\n *\n * Returns a borrowed reference to the new exception (if any), NULL if the\n * existing exception was left in place.\n */\nPyAPI_FUNC(PyObject *) _PyErr_TrySetFromCause(\n    const char *prefix_format,   /* ASCII-encoded string  */\n    ...\n    );\n\n/* In signalmodule.c */\n\nint PySignal_SetWakeupFd(int fd);\nPyAPI_FUNC(int) _PyErr_CheckSignals(void);\n\n/* Support for adding program text to SyntaxErrors */\n\nPyAPI_FUNC(void) PyErr_SyntaxLocationObject(\n    PyObject *filename,\n    int lineno,\n    int col_offset);\n\nPyAPI_FUNC(PyObject *) PyErr_ProgramTextObject(\n    PyObject *filename,\n    int lineno);\n\n/* Create a UnicodeEncodeError object */\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_Create(\n    const char *encoding,       /* UTF-8 encoded string */\n    const Py_UNICODE *object,\n    Py_ssize_t length,\n    Py_ssize_t start,\n    Py_ssize_t end,\n    const char *reason          /* UTF-8 encoded string */\n    );\n\n/* Create a UnicodeTranslateError object */\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_Create(\n    const Py_UNICODE *object,\n    Py_ssize_t length,\n    Py_ssize_t start,\n    Py_ssize_t end,\n    const char *reason          /* UTF-8 encoded string */\n    );\nPyAPI_FUNC(PyObject *) _PyUnicodeTranslateError_Create(\n    PyObject *object,\n    Py_ssize_t start,\n    Py_ssize_t end,\n    const char *reason          /* UTF-8 encoded string */\n    );\n\nPyAPI_FUNC(void) _PyErr_WriteUnraisableMsg(\n    const char *err_msg,\n    PyObject *obj);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "73": {"id": 73, "path": "/usr/include/python3.8/cpython/pylifecycle.h", "content": "#ifndef Py_CPYTHON_PYLIFECYCLE_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Only used by applications that embed the interpreter and need to\n * override the standard encoding determination mechanism\n */\nPyAPI_FUNC(int) Py_SetStandardStreamEncoding(const char *encoding,\n                                             const char *errors);\n\n/* PEP 432 Multi-phase initialization API (Private while provisional!) */\n\nPyAPI_FUNC(PyStatus) Py_PreInitialize(\n    const PyPreConfig *src_config);\nPyAPI_FUNC(PyStatus) Py_PreInitializeFromBytesArgs(\n    const PyPreConfig *src_config,\n    Py_ssize_t argc,\n    char **argv);\nPyAPI_FUNC(PyStatus) Py_PreInitializeFromArgs(\n    const PyPreConfig *src_config,\n    Py_ssize_t argc,\n    wchar_t **argv);\n\nPyAPI_FUNC(int) _Py_IsCoreInitialized(void);\n\n\n/* Initialization and finalization */\n\nPyAPI_FUNC(PyStatus) Py_InitializeFromConfig(\n    const PyConfig *config);\nPyAPI_FUNC(PyStatus) _Py_InitializeFromArgs(\n    const PyConfig *config,\n    Py_ssize_t argc,\n    char * const *argv);\nPyAPI_FUNC(PyStatus) _Py_InitializeFromWideArgs(\n    const PyConfig *config,\n    Py_ssize_t argc,\n    wchar_t * const *argv);\nPyAPI_FUNC(PyStatus) _Py_InitializeMain(void);\n\nPyAPI_FUNC(int) Py_RunMain(void);\n\n\nPyAPI_FUNC(void) _Py_NO_RETURN Py_ExitStatusException(PyStatus err);\n\n/* Py_PyAtExit is for the atexit module, Py_AtExit is for low-level\n * exit functions.\n */\nPyAPI_FUNC(void) _Py_PyAtExit(void (*func)(PyObject *), PyObject *);\n\n/* Restore signals that the interpreter has called SIG_IGN on to SIG_DFL. */\nPyAPI_FUNC(void) _Py_RestoreSignals(void);\n\nPyAPI_FUNC(int) Py_FdIsInteractive(FILE *, const char *);\n\nPyAPI_FUNC(void) _Py_SetProgramFullPath(const wchar_t *);\n\nPyAPI_FUNC(const char *) _Py_gitidentifier(void);\nPyAPI_FUNC(const char *) _Py_gitversion(void);\n\nPyAPI_FUNC(int) _Py_IsFinalizing(void);\n\n/* Random */\nPyAPI_FUNC(int) _PyOS_URandom(void *buffer, Py_ssize_t size);\nPyAPI_FUNC(int) _PyOS_URandomNonblock(void *buffer, Py_ssize_t size);\n\n/* Legacy locale support */\nPyAPI_FUNC(int) _Py_CoerceLegacyLocale(int warn);\nPyAPI_FUNC(int) _Py_LegacyLocaleDetected(int warn);\nPyAPI_FUNC(char *) _Py_SetLocaleFromEnv(int category);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "74": {"id": 74, "path": "/usr/include/python3.8/cpython/pymem.h", "content": "#ifndef Py_CPYTHON_PYMEM_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(void *) PyMem_RawMalloc(size_t size);\nPyAPI_FUNC(void *) PyMem_RawCalloc(size_t nelem, size_t elsize);\nPyAPI_FUNC(void *) PyMem_RawRealloc(void *ptr, size_t new_size);\nPyAPI_FUNC(void) PyMem_RawFree(void *ptr);\n\n/* Try to get the allocators name set by _PyMem_SetupAllocators(). */\nPyAPI_FUNC(const char*) _PyMem_GetCurrentAllocatorName(void);\n\nPyAPI_FUNC(void *) PyMem_Calloc(size_t nelem, size_t elsize);\n\n/* strdup() using PyMem_RawMalloc() */\nPyAPI_FUNC(char *) _PyMem_RawStrdup(const char *str);\n\n/* strdup() using PyMem_Malloc() */\nPyAPI_FUNC(char *) _PyMem_Strdup(const char *str);\n\n/* wcsdup() using PyMem_RawMalloc() */\nPyAPI_FUNC(wchar_t*) _PyMem_RawWcsdup(const wchar_t *str);\n\n\ntypedef enum {\n    /* PyMem_RawMalloc(), PyMem_RawRealloc() and PyMem_RawFree() */\n    PYMEM_DOMAIN_RAW,\n\n    /* PyMem_Malloc(), PyMem_Realloc() and PyMem_Free() */\n    PYMEM_DOMAIN_MEM,\n\n    /* PyObject_Malloc(), PyObject_Realloc() and PyObject_Free() */\n    PYMEM_DOMAIN_OBJ\n} PyMemAllocatorDomain;\n\ntypedef enum {\n    PYMEM_ALLOCATOR_NOT_SET = 0,\n    PYMEM_ALLOCATOR_DEFAULT = 1,\n    PYMEM_ALLOCATOR_DEBUG = 2,\n    PYMEM_ALLOCATOR_MALLOC = 3,\n    PYMEM_ALLOCATOR_MALLOC_DEBUG = 4,\n#ifdef WITH_PYMALLOC\n    PYMEM_ALLOCATOR_PYMALLOC = 5,\n    PYMEM_ALLOCATOR_PYMALLOC_DEBUG = 6,\n#endif\n} PyMemAllocatorName;\n\n\ntypedef struct {\n    /* user context passed as the first argument to the 4 functions */\n    void *ctx;\n\n    /* allocate a memory block */\n    void* (*malloc) (void *ctx, size_t size);\n\n    /* allocate a memory block initialized by zeros */\n    void* (*calloc) (void *ctx, size_t nelem, size_t elsize);\n\n    /* allocate or resize a memory block */\n    void* (*realloc) (void *ctx, void *ptr, size_t new_size);\n\n    /* release a memory block */\n    void (*free) (void *ctx, void *ptr);\n} PyMemAllocatorEx;\n\n/* Get the memory block allocator of the specified domain. */\nPyAPI_FUNC(void) PyMem_GetAllocator(PyMemAllocatorDomain domain,\n                                    PyMemAllocatorEx *allocator);\n\n/* Set the memory block allocator of the specified domain.\n\n   The new allocator must return a distinct non-NULL pointer when requesting\n   zero bytes.\n\n   For the PYMEM_DOMAIN_RAW domain, the allocator must be thread-safe: the GIL\n   is not held when the allocator is called.\n\n   If the new allocator is not a hook (don't call the previous allocator), the\n   PyMem_SetupDebugHooks() function must be called to reinstall the debug hooks\n   on top on the new allocator. */\nPyAPI_FUNC(void) PyMem_SetAllocator(PyMemAllocatorDomain domain,\n                                    PyMemAllocatorEx *allocator);\n\n/* Setup hooks to detect bugs in the following Python memory allocator\n   functions:\n\n   - PyMem_RawMalloc(), PyMem_RawRealloc(), PyMem_RawFree()\n   - PyMem_Malloc(), PyMem_Realloc(), PyMem_Free()\n   - PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()\n\n   Newly allocated memory is filled with the byte 0xCB, freed memory is filled\n   with the byte 0xDB. Additional checks:\n\n   - detect API violations, ex: PyObject_Free() called on a buffer allocated\n     by PyMem_Malloc()\n   - detect write before the start of the buffer (buffer underflow)\n   - detect write after the end of the buffer (buffer overflow)\n\n   The function does nothing if Python is not compiled is debug mode. */\nPyAPI_FUNC(void) PyMem_SetupDebugHooks(void);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "75": {"id": 75, "path": "/usr/include/python3.8/cpython/pystate.h", "content": "#ifndef Py_CPYTHON_PYSTATE_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"cpython/initconfig.h\"\n\nPyAPI_FUNC(int) _PyInterpreterState_RequiresIDRef(PyInterpreterState *);\nPyAPI_FUNC(void) _PyInterpreterState_RequireIDRef(PyInterpreterState *, int);\n\nPyAPI_FUNC(PyObject *) _PyInterpreterState_GetMainModule(PyInterpreterState *);\n\n/* State unique per thread */\n\n/* Py_tracefunc return -1 when raising an exception, or 0 for success. */\ntypedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);\n\n/* The following values are used for 'what' for tracefunc functions\n *\n * To add a new kind of trace event, also update \"trace_init\" in\n * Python/sysmodule.c to define the Python level event name\n */\n#define PyTrace_CALL 0\n#define PyTrace_EXCEPTION 1\n#define PyTrace_LINE 2\n#define PyTrace_RETURN 3\n#define PyTrace_C_CALL 4\n#define PyTrace_C_EXCEPTION 5\n#define PyTrace_C_RETURN 6\n#define PyTrace_OPCODE 7\n\n\ntypedef struct _err_stackitem {\n    /* This struct represents an entry on the exception stack, which is a\n     * per-coroutine state. (Coroutine in the computer science sense,\n     * including the thread and generators).\n     * This ensures that the exception state is not impacted by \"yields\"\n     * from an except handler.\n     */\n    PyObject *exc_type, *exc_value, *exc_traceback;\n\n    struct _err_stackitem *previous_item;\n\n} _PyErr_StackItem;\n\n\n// The PyThreadState typedef is in Include/pystate.h.\nstruct _ts {\n    /* See Python/ceval.c for comments explaining most fields */\n\n    struct _ts *prev;\n    struct _ts *next;\n    PyInterpreterState *interp;\n\n    /* Borrowed reference to the current frame (it can be NULL) */\n    struct _frame *frame;\n    int recursion_depth;\n    char overflowed; /* The stack has overflowed. Allow 50 more calls\n                        to handle the runtime error. */\n    char recursion_critical; /* The current calls must not cause\n                                a stack overflow. */\n    int stackcheck_counter;\n\n    /* 'tracing' keeps track of the execution depth when tracing/profiling.\n       This is to prevent the actual trace/profile code from being recorded in\n       the trace/profile. */\n    int tracing;\n    int use_tracing;\n\n    Py_tracefunc c_profilefunc;\n    Py_tracefunc c_tracefunc;\n    PyObject *c_profileobj;\n    PyObject *c_traceobj;\n\n    /* The exception currently being raised */\n    PyObject *curexc_type;\n    PyObject *curexc_value;\n    PyObject *curexc_traceback;\n\n    /* The exception currently being handled, if no coroutines/generators\n     * are present. Always last element on the stack referred to be exc_info.\n     */\n    _PyErr_StackItem exc_state;\n\n    /* Pointer to the top of the stack of the exceptions currently\n     * being handled */\n    _PyErr_StackItem *exc_info;\n\n    PyObject *dict;  /* Stores per-thread state */\n\n    int gilstate_counter;\n\n    PyObject *async_exc; /* Asynchronous exception to raise */\n    unsigned long thread_id; /* Thread id where this tstate was created */\n\n    int trash_delete_nesting;\n    PyObject *trash_delete_later;\n\n    /* Called when a thread state is deleted normally, but not when it\n     * is destroyed after fork().\n     * Pain:  to prevent rare but fatal shutdown errors (issue 18808),\n     * Thread.join() must wait for the join'ed thread's tstate to be unlinked\n     * from the tstate chain.  That happens at the end of a thread's life,\n     * in pystate.c.\n     * The obvious way doesn't quite work:  create a lock which the tstate\n     * unlinking code releases, and have Thread.join() wait to acquire that\n     * lock.  The problem is that we _are_ at the end of the thread's life:\n     * if the thread holds the last reference to the lock, decref'ing the\n     * lock will delete the lock, and that may trigger arbitrary Python code\n     * if there's a weakref, with a callback, to the lock.  But by this time\n     * _PyRuntime.gilstate.tstate_current is already NULL, so only the simplest\n     * of C code can be allowed to run (in particular it must not be possible to\n     * release the GIL).\n     * So instead of holding the lock directly, the tstate holds a weakref to\n     * the lock:  that's the value of on_delete_data below.  Decref'ing a\n     * weakref is harmless.\n     * on_delete points to _threadmodule.c's static release_sentinel() function.\n     * After the tstate is unlinked, release_sentinel is called with the\n     * weakref-to-lock (on_delete_data) argument, and release_sentinel releases\n     * the indirectly held lock.\n     */\n    void (*on_delete)(void *);\n    void *on_delete_data;\n\n    int coroutine_origin_tracking_depth;\n\n    PyObject *async_gen_firstiter;\n    PyObject *async_gen_finalizer;\n\n    PyObject *context;\n    uint64_t context_ver;\n\n    /* Unique thread state id. */\n    uint64_t id;\n\n    /* XXX signal handlers should also be here */\n\n};\n\n/* Get the current interpreter state.\n\n   Issue a fatal error if there no current Python thread state or no current\n   interpreter. It cannot return NULL.\n\n   The caller must hold the GIL.*/\nPyAPI_FUNC(PyInterpreterState *) _PyInterpreterState_Get(void);\n\nPyAPI_FUNC(int) _PyState_AddModule(PyObject*, struct PyModuleDef*);\nPyAPI_FUNC(void) _PyState_ClearModules(void);\nPyAPI_FUNC(PyThreadState *) _PyThreadState_Prealloc(PyInterpreterState *);\n\n/* Similar to PyThreadState_Get(), but don't issue a fatal error\n * if it is NULL. */\nPyAPI_FUNC(PyThreadState *) _PyThreadState_UncheckedGet(void);\n\n/* PyGILState */\n\n/* Helper/diagnostic function - return 1 if the current thread\n   currently holds the GIL, 0 otherwise.\n\n   The function returns 1 if _PyGILState_check_enabled is non-zero. */\nPyAPI_FUNC(int) PyGILState_Check(void);\n\n/* Get the single PyInterpreterState used by this process' GILState\n   implementation.\n\n   This function doesn't check for error. Return NULL before _PyGILState_Init()\n   is called and after _PyGILState_Fini() is called.\n\n   See also _PyInterpreterState_Get() and _PyInterpreterState_GET_UNSAFE(). */\nPyAPI_FUNC(PyInterpreterState *) _PyGILState_GetInterpreterStateUnsafe(void);\n\n/* The implementation of sys._current_frames()  Returns a dict mapping\n   thread id to that thread's current frame.\n*/\nPyAPI_FUNC(PyObject *) _PyThread_CurrentFrames(void);\n\n/* Routines for advanced debuggers, requested by David Beazley.\n   Don't use unless you know what you are doing! */\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Main(void);\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Head(void);\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Next(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) PyInterpreterState_ThreadHead(PyInterpreterState *);\nPyAPI_FUNC(PyThreadState *) PyThreadState_Next(PyThreadState *);\n\ntypedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);\n\n/* cross-interpreter data */\n\nstruct _xid;\n\n// _PyCrossInterpreterData is similar to Py_buffer as an effectively\n// opaque struct that holds data outside the object machinery.  This\n// is necessary to pass safely between interpreters in the same process.\ntypedef struct _xid {\n    // data is the cross-interpreter-safe derivation of a Python object\n    // (see _PyObject_GetCrossInterpreterData).  It will be NULL if the\n    // new_object func (below) encodes the data.\n    void *data;\n    // obj is the Python object from which the data was derived.  This\n    // is non-NULL only if the data remains bound to the object in some\n    // way, such that the object must be \"released\" (via a decref) when\n    // the data is released.  In that case the code that sets the field,\n    // likely a registered \"crossinterpdatafunc\", is responsible for\n    // ensuring it owns the reference (i.e. incref).\n    PyObject *obj;\n    // interp is the ID of the owning interpreter of the original\n    // object.  It corresponds to the active interpreter when\n    // _PyObject_GetCrossInterpreterData() was called.  This should only\n    // be set by the cross-interpreter machinery.\n    //\n    // We use the ID rather than the PyInterpreterState to avoid issues\n    // with deleted interpreters.  Note that IDs are never re-used, so\n    // each one will always correspond to a specific interpreter\n    // (whether still alive or not).\n    int64_t interp;\n    // new_object is a function that returns a new object in the current\n    // interpreter given the data.  The resulting object (a new\n    // reference) will be equivalent to the original object.  This field\n    // is required.\n    PyObject *(*new_object)(struct _xid *);\n    // free is called when the data is released.  If it is NULL then\n    // nothing will be done to free the data.  For some types this is\n    // okay (e.g. bytes) and for those types this field should be set\n    // to NULL.  However, for most the data was allocated just for\n    // cross-interpreter use, so it must be freed when\n    // _PyCrossInterpreterData_Release is called or the memory will\n    // leak.  In that case, at the very least this field should be set\n    // to PyMem_RawFree (the default if not explicitly set to NULL).\n    // The call will happen with the original interpreter activated.\n    void (*free)(void *);\n} _PyCrossInterpreterData;\n\nPyAPI_FUNC(int) _PyObject_GetCrossInterpreterData(PyObject *, _PyCrossInterpreterData *);\nPyAPI_FUNC(PyObject *) _PyCrossInterpreterData_NewObject(_PyCrossInterpreterData *);\nPyAPI_FUNC(void) _PyCrossInterpreterData_Release(_PyCrossInterpreterData *);\n\nPyAPI_FUNC(int) _PyObject_CheckCrossInterpreterData(PyObject *);\n\n/* cross-interpreter data registry */\n\ntypedef int (*crossinterpdatafunc)(PyObject *, struct _xid *);\n\nPyAPI_FUNC(int) _PyCrossInterpreterData_RegisterClass(PyTypeObject *, crossinterpdatafunc);\nPyAPI_FUNC(crossinterpdatafunc) _PyCrossInterpreterData_Lookup(PyObject *);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "76": {"id": 76, "path": "/usr/include/python3.8/cpython/sysmodule.h", "content": "#ifndef Py_CPYTHON_SYSMODULE_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(PyObject *) _PySys_GetObjectId(_Py_Identifier *key);\nPyAPI_FUNC(int) _PySys_SetObjectId(_Py_Identifier *key, PyObject *);\n\nPyAPI_FUNC(size_t) _PySys_GetSizeOf(PyObject *);\n\ntypedef int(*Py_AuditHookFunction)(const char *, PyObject *, void *);\n\nPyAPI_FUNC(int) PySys_Audit(const char*, const char *, ...);\nPyAPI_FUNC(int) PySys_AddAuditHook(Py_AuditHookFunction, void*);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "77": {"id": 77, "path": "/usr/include/python3.8/cpython/traceback.h", "content": "#ifndef Py_CPYTHON_TRACEBACK_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct _traceback {\n    PyObject_HEAD\n    struct _traceback *tb_next;\n    struct _frame *tb_frame;\n    int tb_lasti;\n    int tb_lineno;\n} PyTracebackObject;\n\nPyAPI_FUNC(int) _Py_DisplaySourceLine(PyObject *, PyObject *, int, int);\nPyAPI_FUNC(void) _PyTraceback_Add(const char *, const char *, int);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "78": {"id": 78, "path": "/usr/include/python3.8/cpython/tupleobject.h", "content": "#ifndef Py_CPYTHON_TUPLEOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* ob_item contains space for 'ob_size' elements.\n       Items must normally not be NULL, except during construction when\n       the tuple is not yet visible outside the function that builds it. */\n    PyObject *ob_item[1];\n} PyTupleObject;\n\nPyAPI_FUNC(int) _PyTuple_Resize(PyObject **, Py_ssize_t);\nPyAPI_FUNC(void) _PyTuple_MaybeUntrack(PyObject *);\n\n/* Macros trading safety for speed */\n\n/* Cast argument to PyTupleObject* type. */\n#define _PyTuple_CAST(op) (assert(PyTuple_Check(op)), (PyTupleObject *)(op))\n\n#define PyTuple_GET_SIZE(op)    Py_SIZE(_PyTuple_CAST(op))\n\n#define PyTuple_GET_ITEM(op, i) (_PyTuple_CAST(op)->ob_item[i])\n\n/* Macro, *only* to be used to fill in brand new tuples */\n#define PyTuple_SET_ITEM(op, i, v) (_PyTuple_CAST(op)->ob_item[i] = v)\n\nPyAPI_FUNC(void) _PyTuple_DebugMallocStats(FILE *out);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "79": {"id": 79, "path": "/usr/include/python3.8/cpython/unicodeobject.h", "content": "#ifndef Py_CPYTHON_UNICODEOBJECT_H\n#  error \"this header file must not be included directly\"\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Py_UNICODE was the native Unicode storage format (code unit) used by\n   Python and represents a single Unicode element in the Unicode type.\n   With PEP 393, Py_UNICODE is deprecated and replaced with a\n   typedef to wchar_t. */\n#define PY_UNICODE_TYPE wchar_t\n/* Py_DEPRECATED(3.3) */ typedef wchar_t Py_UNICODE;\n\n/* --- Internal Unicode Operations ---------------------------------------- */\n\n/* Since splitting on whitespace is an important use case, and\n   whitespace in most situations is solely ASCII whitespace, we\n   optimize for the common case by using a quick look-up table\n   _Py_ascii_whitespace (see below) with an inlined check.\n\n */\n#define Py_UNICODE_ISSPACE(ch) \\\n    ((ch) < 128U ? _Py_ascii_whitespace[(ch)] : _PyUnicode_IsWhitespace(ch))\n\n#define Py_UNICODE_ISLOWER(ch) _PyUnicode_IsLowercase(ch)\n#define Py_UNICODE_ISUPPER(ch) _PyUnicode_IsUppercase(ch)\n#define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)\n#define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)\n\n#define Py_UNICODE_TOLOWER(ch) _PyUnicode_ToLowercase(ch)\n#define Py_UNICODE_TOUPPER(ch) _PyUnicode_ToUppercase(ch)\n#define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)\n\n#define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)\n#define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)\n#define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)\n#define Py_UNICODE_ISPRINTABLE(ch) _PyUnicode_IsPrintable(ch)\n\n#define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)\n#define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)\n#define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)\n\n#define Py_UNICODE_ISALPHA(ch) _PyUnicode_IsAlpha(ch)\n\n#define Py_UNICODE_ISALNUM(ch) \\\n       (Py_UNICODE_ISALPHA(ch) || \\\n    Py_UNICODE_ISDECIMAL(ch) || \\\n    Py_UNICODE_ISDIGIT(ch) || \\\n    Py_UNICODE_ISNUMERIC(ch))\n\n#define Py_UNICODE_COPY(target, source, length) \\\n    memcpy((target), (source), (length)*sizeof(Py_UNICODE))\n\n#define Py_UNICODE_FILL(target, value, length) \\\n    do {Py_ssize_t i_; Py_UNICODE *t_ = (target); Py_UNICODE v_ = (value);\\\n        for (i_ = 0; i_ < (length); i_++) t_[i_] = v_;\\\n    } while (0)\n\n/* macros to work with surrogates */\n#define Py_UNICODE_IS_SURROGATE(ch) (0xD800 <= (ch) && (ch) <= 0xDFFF)\n#define Py_UNICODE_IS_HIGH_SURROGATE(ch) (0xD800 <= (ch) && (ch) <= 0xDBFF)\n#define Py_UNICODE_IS_LOW_SURROGATE(ch) (0xDC00 <= (ch) && (ch) <= 0xDFFF)\n/* Join two surrogate characters and return a single Py_UCS4 value. */\n#define Py_UNICODE_JOIN_SURROGATES(high, low)  \\\n    (((((Py_UCS4)(high) & 0x03FF) << 10) |      \\\n      ((Py_UCS4)(low) & 0x03FF)) + 0x10000)\n/* high surrogate = top 10 bits added to D800 */\n#define Py_UNICODE_HIGH_SURROGATE(ch) (0xD800 - (0x10000 >> 10) + ((ch) >> 10))\n/* low surrogate = bottom 10 bits added to DC00 */\n#define Py_UNICODE_LOW_SURROGATE(ch) (0xDC00 + ((ch) & 0x3FF))\n\n/* Check if substring matches at given offset.  The offset must be\n   valid, and the substring must not be empty. */\n\n#define Py_UNICODE_MATCH(string, offset, substring) \\\n    ((*((string)->wstr + (offset)) == *((substring)->wstr)) && \\\n     ((*((string)->wstr + (offset) + (substring)->wstr_length-1) == *((substring)->wstr + (substring)->wstr_length-1))) && \\\n     !memcmp((string)->wstr + (offset), (substring)->wstr, (substring)->wstr_length*sizeof(Py_UNICODE)))\n\n/* --- Unicode Type ------------------------------------------------------- */\n\n/* ASCII-only strings created through PyUnicode_New use the PyASCIIObject\n   structure. state.ascii and state.compact are set, and the data\n   immediately follow the structure. utf8_length and wstr_length can be found\n   in the length field; the utf8 pointer is equal to the data pointer. */\ntypedef struct {\n    /* There are 4 forms of Unicode strings:\n\n       - compact ascii:\n\n         * structure = PyASCIIObject\n         * test: PyUnicode_IS_COMPACT_ASCII(op)\n         * kind = PyUnicode_1BYTE_KIND\n         * compact = 1\n         * ascii = 1\n         * ready = 1\n         * (length is the length of the utf8 and wstr strings)\n         * (data starts just after the structure)\n         * (since ASCII is decoded from UTF-8, the utf8 string are the data)\n\n       - compact:\n\n         * structure = PyCompactUnicodeObject\n         * test: PyUnicode_IS_COMPACT(op) && !PyUnicode_IS_ASCII(op)\n         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or\n           PyUnicode_4BYTE_KIND\n         * compact = 1\n         * ready = 1\n         * ascii = 0\n         * utf8 is not shared with data\n         * utf8_length = 0 if utf8 is NULL\n         * wstr is shared with data and wstr_length=length\n           if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2\n           or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_t)=4\n         * wstr_length = 0 if wstr is NULL\n         * (data starts just after the structure)\n\n       - legacy string, not ready:\n\n         * structure = PyUnicodeObject\n         * test: kind == PyUnicode_WCHAR_KIND\n         * length = 0 (use wstr_length)\n         * hash = -1\n         * kind = PyUnicode_WCHAR_KIND\n         * compact = 0\n         * ascii = 0\n         * ready = 0\n         * interned = SSTATE_NOT_INTERNED\n         * wstr is not NULL\n         * data.any is NULL\n         * utf8 is NULL\n         * utf8_length = 0\n\n       - legacy string, ready:\n\n         * structure = PyUnicodeObject structure\n         * test: !PyUnicode_IS_COMPACT(op) && kind != PyUnicode_WCHAR_KIND\n         * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or\n           PyUnicode_4BYTE_KIND\n         * compact = 0\n         * ready = 1\n         * data.any is not NULL\n         * utf8 is shared and utf8_length = length with data.any if ascii = 1\n         * utf8_length = 0 if utf8 is NULL\n         * wstr is shared with data.any and wstr_length = length\n           if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2\n           or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_4)=4\n         * wstr_length = 0 if wstr is NULL\n\n       Compact strings use only one memory block (structure + characters),\n       whereas legacy strings use one block for the structure and one block\n       for characters.\n\n       Legacy strings are created by PyUnicode_FromUnicode() and\n       PyUnicode_FromStringAndSize(NULL, size) functions. They become ready\n       when PyUnicode_READY() is called.\n\n       See also _PyUnicode_CheckConsistency().\n    */\n    PyObject_HEAD\n    Py_ssize_t length;          /* Number of code points in the string */\n    Py_hash_t hash;             /* Hash value; -1 if not set */\n    struct {\n        /*\n           SSTATE_NOT_INTERNED (0)\n           SSTATE_INTERNED_MORTAL (1)\n           SSTATE_INTERNED_IMMORTAL (2)\n\n           If interned != SSTATE_NOT_INTERNED, the two references from the\n           dictionary to this object are *not* counted in ob_refcnt.\n         */\n        unsigned int interned:2;\n        /* Character size:\n\n           - PyUnicode_WCHAR_KIND (0):\n\n             * character type = wchar_t (16 or 32 bits, depending on the\n               platform)\n\n           - PyUnicode_1BYTE_KIND (1):\n\n             * character type = Py_UCS1 (8 bits, unsigned)\n             * all characters are in the range U+0000-U+00FF (latin1)\n             * if ascii is set, all characters are in the range U+0000-U+007F\n               (ASCII), otherwise at least one character is in the range\n               U+0080-U+00FF\n\n           - PyUnicode_2BYTE_KIND (2):\n\n             * character type = Py_UCS2 (16 bits, unsigned)\n             * all characters are in the range U+0000-U+FFFF (BMP)\n             * at least one character is in the range U+0100-U+FFFF\n\n           - PyUnicode_4BYTE_KIND (4):\n\n             * character type = Py_UCS4 (32 bits, unsigned)\n             * all characters are in the range U+0000-U+10FFFF\n             * at least one character is in the range U+10000-U+10FFFF\n         */\n        unsigned int kind:3;\n        /* Compact is with respect to the allocation scheme. Compact unicode\n           objects only require one memory block while non-compact objects use\n           one block for the PyUnicodeObject struct and another for its data\n           buffer. */\n        unsigned int compact:1;\n        /* The string only contains characters in the range U+0000-U+007F (ASCII)\n           and the kind is PyUnicode_1BYTE_KIND. If ascii is set and compact is\n           set, use the PyASCIIObject structure. */\n        unsigned int ascii:1;\n        /* The ready flag indicates whether the object layout is initialized\n           completely. This means that this is either a compact object, or\n           the data pointer is filled out. The bit is redundant, and helps\n           to minimize the test in PyUnicode_IS_READY(). */\n        unsigned int ready:1;\n        /* Padding to ensure that PyUnicode_DATA() is always aligned to\n           4 bytes (see issue #19537 on m68k). */\n        unsigned int :24;\n    } state;\n    wchar_t *wstr;              /* wchar_t representation (null-terminated) */\n} PyASCIIObject;\n\n/* Non-ASCII strings allocated through PyUnicode_New use the\n   PyCompactUnicodeObject structure. state.compact is set, and the data\n   immediately follow the structure. */\ntypedef struct {\n    PyASCIIObject _base;\n    Py_ssize_t utf8_length;     /* Number of bytes in utf8, excluding the\n                                 * terminating \\0. */\n    char *utf8;                 /* UTF-8 representation (null-terminated) */\n    Py_ssize_t wstr_length;     /* Number of code points in wstr, possible\n                                 * surrogates count as two code points. */\n} PyCompactUnicodeObject;\n\n/* Strings allocated through PyUnicode_FromUnicode(NULL, len) use the\n   PyUnicodeObject structure. The actual string data is initially in the wstr\n   block, and copied into the data block using _PyUnicode_Ready. */\ntypedef struct {\n    PyCompactUnicodeObject _base;\n    union {\n        void *any;\n        Py_UCS1 *latin1;\n        Py_UCS2 *ucs2;\n        Py_UCS4 *ucs4;\n    } data;                     /* Canonical, smallest-form Unicode buffer */\n} PyUnicodeObject;\n\nPyAPI_FUNC(int) _PyUnicode_CheckConsistency(\n    PyObject *op,\n    int check_content);\n\n/* Fast access macros */\n#define PyUnicode_WSTR_LENGTH(op) \\\n    (PyUnicode_IS_COMPACT_ASCII(op) ?                  \\\n     ((PyASCIIObject*)op)->length :                    \\\n     ((PyCompactUnicodeObject*)op)->wstr_length)\n\n/* Returns the deprecated Py_UNICODE representation's size in code units\n   (this includes surrogate pairs as 2 units).\n   If the Py_UNICODE representation is not available, it will be computed\n   on request.  Use PyUnicode_GET_LENGTH() for the length in code points. */\n\n/* Py_DEPRECATED(3.3) */\n#define PyUnicode_GET_SIZE(op)                       \\\n    (assert(PyUnicode_Check(op)),                    \\\n     (((PyASCIIObject *)(op))->wstr) ?               \\\n      PyUnicode_WSTR_LENGTH(op) :                    \\\n      ((void)PyUnicode_AsUnicode(_PyObject_CAST(op)),\\\n       assert(((PyASCIIObject *)(op))->wstr),        \\\n       PyUnicode_WSTR_LENGTH(op)))\n\n/* Py_DEPRECATED(3.3) */\n#define PyUnicode_GET_DATA_SIZE(op) \\\n    (PyUnicode_GET_SIZE(op) * Py_UNICODE_SIZE)\n\n/* Alias for PyUnicode_AsUnicode().  This will create a wchar_t/Py_UNICODE\n   representation on demand.  Using this macro is very inefficient now,\n   try to port your code to use the new PyUnicode_*BYTE_DATA() macros or\n   use PyUnicode_WRITE() and PyUnicode_READ(). */\n\n/* Py_DEPRECATED(3.3) */\n#define PyUnicode_AS_UNICODE(op) \\\n    (assert(PyUnicode_Check(op)), \\\n     (((PyASCIIObject *)(op))->wstr) ? (((PyASCIIObject *)(op))->wstr) : \\\n      PyUnicode_AsUnicode(_PyObject_CAST(op)))\n\n/* Py_DEPRECATED(3.3) */\n#define PyUnicode_AS_DATA(op) \\\n    ((const char *)(PyUnicode_AS_UNICODE(op)))\n\n\n/* --- Flexible String Representation Helper Macros (PEP 393) -------------- */\n\n/* Values for PyASCIIObject.state: */\n\n/* Interning state. */\n#define SSTATE_NOT_INTERNED 0\n#define SSTATE_INTERNED_MORTAL 1\n#define SSTATE_INTERNED_IMMORTAL 2\n\n/* Return true if the string contains only ASCII characters, or 0 if not. The\n   string may be compact (PyUnicode_IS_COMPACT_ASCII) or not, but must be\n   ready. */\n#define PyUnicode_IS_ASCII(op)                   \\\n    (assert(PyUnicode_Check(op)),                \\\n     assert(PyUnicode_IS_READY(op)),             \\\n     ((PyASCIIObject*)op)->state.ascii)\n\n/* Return true if the string is compact or 0 if not.\n   No type checks or Ready calls are performed. */\n#define PyUnicode_IS_COMPACT(op) \\\n    (((PyASCIIObject*)(op))->state.compact)\n\n/* Return true if the string is a compact ASCII string (use PyASCIIObject\n   structure), or 0 if not.  No type checks or Ready calls are performed. */\n#define PyUnicode_IS_COMPACT_ASCII(op)                 \\\n    (((PyASCIIObject*)op)->state.ascii && PyUnicode_IS_COMPACT(op))\n\nenum PyUnicode_Kind {\n/* String contains only wstr byte characters.  This is only possible\n   when the string was created with a legacy API and _PyUnicode_Ready()\n   has not been called yet.  */\n    PyUnicode_WCHAR_KIND = 0,\n/* Return values of the PyUnicode_KIND() macro: */\n    PyUnicode_1BYTE_KIND = 1,\n    PyUnicode_2BYTE_KIND = 2,\n    PyUnicode_4BYTE_KIND = 4\n};\n\n/* Return pointers to the canonical representation cast to unsigned char,\n   Py_UCS2, or Py_UCS4 for direct character access.\n   No checks are performed, use PyUnicode_KIND() before to ensure\n   these will work correctly. */\n\n#define PyUnicode_1BYTE_DATA(op) ((Py_UCS1*)PyUnicode_DATA(op))\n#define PyUnicode_2BYTE_DATA(op) ((Py_UCS2*)PyUnicode_DATA(op))\n#define PyUnicode_4BYTE_DATA(op) ((Py_UCS4*)PyUnicode_DATA(op))\n\n/* Return one of the PyUnicode_*_KIND values defined above. */\n#define PyUnicode_KIND(op) \\\n    (assert(PyUnicode_Check(op)), \\\n     assert(PyUnicode_IS_READY(op)),            \\\n     ((PyASCIIObject *)(op))->state.kind)\n\n/* Return a void pointer to the raw unicode buffer. */\n#define _PyUnicode_COMPACT_DATA(op)                     \\\n    (PyUnicode_IS_ASCII(op) ?                   \\\n     ((void*)((PyASCIIObject*)(op) + 1)) :              \\\n     ((void*)((PyCompactUnicodeObject*)(op) + 1)))\n\n#define _PyUnicode_NONCOMPACT_DATA(op)                  \\\n    (assert(((PyUnicodeObject*)(op))->data.any),        \\\n     ((((PyUnicodeObject *)(op))->data.any)))\n\n#define PyUnicode_DATA(op) \\\n    (assert(PyUnicode_Check(op)), \\\n     PyUnicode_IS_COMPACT(op) ? _PyUnicode_COMPACT_DATA(op) :   \\\n     _PyUnicode_NONCOMPACT_DATA(op))\n\n/* In the access macros below, \"kind\" may be evaluated more than once.\n   All other macro parameters are evaluated exactly once, so it is safe\n   to put side effects into them (such as increasing the index). */\n\n/* Write into the canonical representation, this macro does not do any sanity\n   checks and is intended for usage in loops.  The caller should cache the\n   kind and data pointers obtained from other macro calls.\n   index is the index in the string (starts at 0) and value is the new\n   code point value which should be written to that location. */\n#define PyUnicode_WRITE(kind, data, index, value) \\\n    do { \\\n        switch ((kind)) { \\\n        case PyUnicode_1BYTE_KIND: { \\\n            ((Py_UCS1 *)(data))[(index)] = (Py_UCS1)(value); \\\n            break; \\\n        } \\\n        case PyUnicode_2BYTE_KIND: { \\\n            ((Py_UCS2 *)(data))[(index)] = (Py_UCS2)(value); \\\n            break; \\\n        } \\\n        default: { \\\n            assert((kind) == PyUnicode_4BYTE_KIND); \\\n            ((Py_UCS4 *)(data))[(index)] = (Py_UCS4)(value); \\\n        } \\\n        } \\\n    } while (0)\n\n/* Read a code point from the string's canonical representation.  No checks\n   or ready calls are performed. */\n#define PyUnicode_READ(kind, data, index) \\\n    ((Py_UCS4) \\\n    ((kind) == PyUnicode_1BYTE_KIND ? \\\n        ((const Py_UCS1 *)(data))[(index)] : \\\n        ((kind) == PyUnicode_2BYTE_KIND ? \\\n            ((const Py_UCS2 *)(data))[(index)] : \\\n            ((const Py_UCS4 *)(data))[(index)] \\\n        ) \\\n    ))\n\n/* PyUnicode_READ_CHAR() is less efficient than PyUnicode_READ() because it\n   calls PyUnicode_KIND() and might call it twice.  For single reads, use\n   PyUnicode_READ_CHAR, for multiple consecutive reads callers should\n   cache kind and use PyUnicode_READ instead. */\n#define PyUnicode_READ_CHAR(unicode, index) \\\n    (assert(PyUnicode_Check(unicode)),          \\\n     assert(PyUnicode_IS_READY(unicode)),       \\\n     (Py_UCS4)                                  \\\n        (PyUnicode_KIND((unicode)) == PyUnicode_1BYTE_KIND ? \\\n            ((const Py_UCS1 *)(PyUnicode_DATA((unicode))))[(index)] : \\\n            (PyUnicode_KIND((unicode)) == PyUnicode_2BYTE_KIND ? \\\n                ((const Py_UCS2 *)(PyUnicode_DATA((unicode))))[(index)] : \\\n                ((const Py_UCS4 *)(PyUnicode_DATA((unicode))))[(index)] \\\n            ) \\\n        ))\n\n/* Returns the length of the unicode string. The caller has to make sure that\n   the string has it's canonical representation set before calling\n   this macro.  Call PyUnicode_(FAST_)Ready to ensure that. */\n#define PyUnicode_GET_LENGTH(op)                \\\n    (assert(PyUnicode_Check(op)),               \\\n     assert(PyUnicode_IS_READY(op)),            \\\n     ((PyASCIIObject *)(op))->length)\n\n\n/* Fast check to determine whether an object is ready. Equivalent to\n   PyUnicode_IS_COMPACT(op) || ((PyUnicodeObject*)(op))->data.any) */\n\n#define PyUnicode_IS_READY(op) (((PyASCIIObject*)op)->state.ready)\n\n/* PyUnicode_READY() does less work than _PyUnicode_Ready() in the best\n   case.  If the canonical representation is not yet set, it will still call\n   _PyUnicode_Ready().\n   Returns 0 on success and -1 on errors. */\n#define PyUnicode_READY(op)                        \\\n    (assert(PyUnicode_Check(op)),                       \\\n     (PyUnicode_IS_READY(op) ?                          \\\n      0 : _PyUnicode_Ready(_PyObject_CAST(op))))\n\n/* Return a maximum character value which is suitable for creating another\n   string based on op.  This is always an approximation but more efficient\n   than iterating over the string. */\n#define PyUnicode_MAX_CHAR_VALUE(op) \\\n    (assert(PyUnicode_IS_READY(op)),                                    \\\n     (PyUnicode_IS_ASCII(op) ?                                          \\\n      (0x7f) :                                                          \\\n      (PyUnicode_KIND(op) == PyUnicode_1BYTE_KIND ?                     \\\n       (0xffU) :                                                        \\\n       (PyUnicode_KIND(op) == PyUnicode_2BYTE_KIND ?                    \\\n        (0xffffU) :                                                     \\\n        (0x10ffffU)))))\n\n/* === Public API ========================================================= */\n\n/* --- Plain Py_UNICODE --------------------------------------------------- */\n\n/* With PEP 393, this is the recommended way to allocate a new unicode object.\n   This function will allocate the object and its buffer in a single memory\n   block.  Objects created using this function are not resizable. */\nPyAPI_FUNC(PyObject*) PyUnicode_New(\n    Py_ssize_t size,            /* Number of code points in the new string */\n    Py_UCS4 maxchar             /* maximum code point value in the string */\n    );\n\n/* Initializes the canonical string representation from the deprecated\n   wstr/Py_UNICODE representation. This function is used to convert Unicode\n   objects which were created using the old API to the new flexible format\n   introduced with PEP 393.\n\n   Don't call this function directly, use the public PyUnicode_READY() macro\n   instead. */\nPyAPI_FUNC(int) _PyUnicode_Ready(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* Get a copy of a Unicode string. */\nPyAPI_FUNC(PyObject*) _PyUnicode_Copy(\n    PyObject *unicode\n    );\n\n/* Copy character from one unicode object into another, this function performs\n   character conversion when necessary and falls back to memcpy() if possible.\n\n   Fail if to is too small (smaller than *how_many* or smaller than\n   len(from)-from_start), or if kind(from[from_start:from_start+how_many]) >\n   kind(to), or if *to* has more than 1 reference.\n\n   Return the number of written character, or return -1 and raise an exception\n   on error.\n\n   Pseudo-code:\n\n       how_many = min(how_many, len(from) - from_start)\n       to[to_start:to_start+how_many] = from[from_start:from_start+how_many]\n       return how_many\n\n   Note: The function doesn't write a terminating null character.\n   */\nPyAPI_FUNC(Py_ssize_t) PyUnicode_CopyCharacters(\n    PyObject *to,\n    Py_ssize_t to_start,\n    PyObject *from,\n    Py_ssize_t from_start,\n    Py_ssize_t how_many\n    );\n\n/* Unsafe version of PyUnicode_CopyCharacters(): don't check arguments and so\n   may crash if parameters are invalid (e.g. if the output string\n   is too short). */\nPyAPI_FUNC(void) _PyUnicode_FastCopyCharacters(\n    PyObject *to,\n    Py_ssize_t to_start,\n    PyObject *from,\n    Py_ssize_t from_start,\n    Py_ssize_t how_many\n    );\n\n/* Fill a string with a character: write fill_char into\n   unicode[start:start+length].\n\n   Fail if fill_char is bigger than the string maximum character, or if the\n   string has more than 1 reference.\n\n   Return the number of written character, or return -1 and raise an exception\n   on error. */\nPyAPI_FUNC(Py_ssize_t) PyUnicode_Fill(\n    PyObject *unicode,\n    Py_ssize_t start,\n    Py_ssize_t length,\n    Py_UCS4 fill_char\n    );\n\n/* Unsafe version of PyUnicode_Fill(): don't check arguments and so may crash\n   if parameters are invalid (e.g. if length is longer than the string). */\nPyAPI_FUNC(void) _PyUnicode_FastFill(\n    PyObject *unicode,\n    Py_ssize_t start,\n    Py_ssize_t length,\n    Py_UCS4 fill_char\n    );\n\n/* Create a Unicode Object from the Py_UNICODE buffer u of the given\n   size.\n\n   u may be NULL which causes the contents to be undefined. It is the\n   user's responsibility to fill in the needed data afterwards. Note\n   that modifying the Unicode object contents after construction is\n   only allowed if u was set to NULL.\n\n   The buffer is copied into the new object. */\n/* Py_DEPRECATED(3.3) */ PyAPI_FUNC(PyObject*) PyUnicode_FromUnicode(\n    const Py_UNICODE *u,        /* Unicode buffer */\n    Py_ssize_t size             /* size of buffer */\n    );\n\n/* Create a new string from a buffer of Py_UCS1, Py_UCS2 or Py_UCS4 characters.\n   Scan the string to find the maximum character. */\nPyAPI_FUNC(PyObject*) PyUnicode_FromKindAndData(\n    int kind,\n    const void *buffer,\n    Py_ssize_t size);\n\n/* Create a new string from a buffer of ASCII characters.\n   WARNING: Don't check if the string contains any non-ASCII character. */\nPyAPI_FUNC(PyObject*) _PyUnicode_FromASCII(\n    const char *buffer,\n    Py_ssize_t size);\n\n/* Compute the maximum character of the substring unicode[start:end].\n   Return 127 for an empty string. */\nPyAPI_FUNC(Py_UCS4) _PyUnicode_FindMaxChar (\n    PyObject *unicode,\n    Py_ssize_t start,\n    Py_ssize_t end);\n\n/* Return a read-only pointer to the Unicode object's internal\n   Py_UNICODE buffer.\n   If the wchar_t/Py_UNICODE representation is not yet available, this\n   function will calculate it. */\n/* Py_DEPRECATED(3.3) */ PyAPI_FUNC(Py_UNICODE *) PyUnicode_AsUnicode(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* Similar to PyUnicode_AsUnicode(), but raises a ValueError if the string\n   contains null characters. */\nPyAPI_FUNC(const Py_UNICODE *) _PyUnicode_AsUnicode(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* Return a read-only pointer to the Unicode object's internal\n   Py_UNICODE buffer and save the length at size.\n   If the wchar_t/Py_UNICODE representation is not yet available, this\n   function will calculate it. */\n\n/* Py_DEPRECATED(3.3) */ PyAPI_FUNC(Py_UNICODE *) PyUnicode_AsUnicodeAndSize(\n    PyObject *unicode,          /* Unicode object */\n    Py_ssize_t *size            /* location where to save the length */\n    );\n\n/* Get the maximum ordinal for a Unicode character. */\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE) PyUnicode_GetMax(void);\n\n\n/* --- _PyUnicodeWriter API ----------------------------------------------- */\n\ntypedef struct {\n    PyObject *buffer;\n    void *data;\n    enum PyUnicode_Kind kind;\n    Py_UCS4 maxchar;\n    Py_ssize_t size;\n    Py_ssize_t pos;\n\n    /* minimum number of allocated characters (default: 0) */\n    Py_ssize_t min_length;\n\n    /* minimum character (default: 127, ASCII) */\n    Py_UCS4 min_char;\n\n    /* If non-zero, overallocate the buffer (default: 0). */\n    unsigned char overallocate;\n\n    /* If readonly is 1, buffer is a shared string (cannot be modified)\n       and size is set to 0. */\n    unsigned char readonly;\n} _PyUnicodeWriter ;\n\n/* Initialize a Unicode writer.\n *\n * By default, the minimum buffer size is 0 character and overallocation is\n * disabled. Set min_length, min_char and overallocate attributes to control\n * the allocation of the buffer. */\nPyAPI_FUNC(void)\n_PyUnicodeWriter_Init(_PyUnicodeWriter *writer);\n\n/* Prepare the buffer to write 'length' characters\n   with the specified maximum character.\n\n   Return 0 on success, raise an exception and return -1 on error. */\n#define _PyUnicodeWriter_Prepare(WRITER, LENGTH, MAXCHAR)             \\\n    (((MAXCHAR) <= (WRITER)->maxchar                                  \\\n      && (LENGTH) <= (WRITER)->size - (WRITER)->pos)                  \\\n     ? 0                                                              \\\n     : (((LENGTH) == 0)                                               \\\n        ? 0                                                           \\\n        : _PyUnicodeWriter_PrepareInternal((WRITER), (LENGTH), (MAXCHAR))))\n\n/* Don't call this function directly, use the _PyUnicodeWriter_Prepare() macro\n   instead. */\nPyAPI_FUNC(int)\n_PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,\n                                 Py_ssize_t length, Py_UCS4 maxchar);\n\n/* Prepare the buffer to have at least the kind KIND.\n   For example, kind=PyUnicode_2BYTE_KIND ensures that the writer will\n   support characters in range U+000-U+FFFF.\n\n   Return 0 on success, raise an exception and return -1 on error. */\n#define _PyUnicodeWriter_PrepareKind(WRITER, KIND)                    \\\n    (assert((KIND) != PyUnicode_WCHAR_KIND),                          \\\n     (KIND) <= (WRITER)->kind                                         \\\n     ? 0                                                              \\\n     : _PyUnicodeWriter_PrepareKindInternal((WRITER), (KIND)))\n\n/* Don't call this function directly, use the _PyUnicodeWriter_PrepareKind()\n   macro instead. */\nPyAPI_FUNC(int)\n_PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer,\n                                     enum PyUnicode_Kind kind);\n\n/* Append a Unicode character.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int)\n_PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer,\n    Py_UCS4 ch\n    );\n\n/* Append a Unicode string.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int)\n_PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer,\n    PyObject *str               /* Unicode string */\n    );\n\n/* Append a substring of a Unicode string.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int)\n_PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer,\n    PyObject *str,              /* Unicode string */\n    Py_ssize_t start,\n    Py_ssize_t end\n    );\n\n/* Append an ASCII-encoded byte string.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int)\n_PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer,\n    const char *str,           /* ASCII-encoded byte string */\n    Py_ssize_t len             /* number of bytes, or -1 if unknown */\n    );\n\n/* Append a latin1-encoded byte string.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int)\n_PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer,\n    const char *str,           /* latin1-encoded byte string */\n    Py_ssize_t len             /* length in bytes */\n    );\n\n/* Get the value of the writer as a Unicode string. Clear the\n   buffer of the writer. Raise an exception and return NULL\n   on error. */\nPyAPI_FUNC(PyObject *)\n_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer);\n\n/* Deallocate memory of a writer (clear its internal buffer). */\nPyAPI_FUNC(void)\n_PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer);\n\n\n/* Format the object based on the format_spec, as defined in PEP 3101\n   (Advanced String Formatting). */\nPyAPI_FUNC(int) _PyUnicode_FormatAdvancedWriter(\n    _PyUnicodeWriter *writer,\n    PyObject *obj,\n    PyObject *format_spec,\n    Py_ssize_t start,\n    Py_ssize_t end);\n\n/* --- wchar_t support for platforms which support it --------------------- */\n\n#ifdef HAVE_WCHAR_H\nPyAPI_FUNC(void*) _PyUnicode_AsKind(PyObject *s, unsigned int kind);\n#endif\n\n/* --- Manage the default encoding ---------------------------------------- */\n\n/* Returns a pointer to the default encoding (UTF-8) of the\n   Unicode object unicode and the size of the encoded representation\n   in bytes stored in *size.\n\n   In case of an error, no *size is set.\n\n   This function caches the UTF-8 encoded string in the unicodeobject\n   and subsequent calls will return the same string.  The memory is released\n   when the unicodeobject is deallocated.\n\n   _PyUnicode_AsStringAndSize is a #define for PyUnicode_AsUTF8AndSize to\n   support the previous internal function with the same behaviour.\n\n   *** This API is for interpreter INTERNAL USE ONLY and will likely\n   *** be removed or changed in the future.\n\n   *** If you need to access the Unicode object as UTF-8 bytes string,\n   *** please use PyUnicode_AsUTF8String() instead.\n*/\n\nPyAPI_FUNC(const char *) PyUnicode_AsUTF8AndSize(\n    PyObject *unicode,\n    Py_ssize_t *size);\n\n#define _PyUnicode_AsStringAndSize PyUnicode_AsUTF8AndSize\n\n/* Returns a pointer to the default encoding (UTF-8) of the\n   Unicode object unicode.\n\n   Like PyUnicode_AsUTF8AndSize(), this also caches the UTF-8 representation\n   in the unicodeobject.\n\n   _PyUnicode_AsString is a #define for PyUnicode_AsUTF8 to\n   support the previous internal function with the same behaviour.\n\n   Use of this API is DEPRECATED since no size information can be\n   extracted from the returned data.\n\n   *** This API is for interpreter INTERNAL USE ONLY and will likely\n   *** be removed or changed for Python 3.1.\n\n   *** If you need to access the Unicode object as UTF-8 bytes string,\n   *** please use PyUnicode_AsUTF8String() instead.\n\n*/\n\nPyAPI_FUNC(const char *) PyUnicode_AsUTF8(PyObject *unicode);\n\n#define _PyUnicode_AsString PyUnicode_AsUTF8\n\n/* --- Generic Codecs ----------------------------------------------------- */\n\n/* Encodes a Py_UNICODE buffer of the given size and returns a\n   Python string object. */\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_Encode(\n    const Py_UNICODE *s,        /* Unicode char buffer */\n    Py_ssize_t size,            /* number of Py_UNICODE chars to encode */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* --- UTF-7 Codecs ------------------------------------------------------- */\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF7(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */\n    int base64SetO,             /* Encode RFC2152 Set O characters in base64 */\n    int base64WhiteSpace,       /* Encode whitespace (sp, ht, nl, cr) in base64 */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) _PyUnicode_EncodeUTF7(\n    PyObject *unicode,          /* Unicode object */\n    int base64SetO,             /* Encode RFC2152 Set O characters in base64 */\n    int base64WhiteSpace,       /* Encode whitespace (sp, ht, nl, cr) in base64 */\n    const char *errors          /* error handling */\n    );\n\n/* --- UTF-8 Codecs ------------------------------------------------------- */\n\nPyAPI_FUNC(PyObject*) _PyUnicode_AsUTF8String(\n    PyObject *unicode,\n    const char *errors);\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF8(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */\n    const char *errors          /* error handling */\n    );\n\n/* --- UTF-32 Codecs ------------------------------------------------------ */\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF32(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */\n    const char *errors,         /* error handling */\n    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */\n    );\n\nPyAPI_FUNC(PyObject*) _PyUnicode_EncodeUTF32(\n    PyObject *object,           /* Unicode object */\n    const char *errors,         /* error handling */\n    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */\n    );\n\n/* --- UTF-16 Codecs ------------------------------------------------------ */\n\n/* Returns a Python string object holding the UTF-16 encoded value of\n   the Unicode data.\n\n   If byteorder is not 0, output is written according to the following\n   byte order:\n\n   byteorder == -1: little endian\n   byteorder == 0:  native byte order (writes a BOM mark)\n   byteorder == 1:  big endian\n\n   If byteorder is 0, the output string will always start with the\n   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is\n   prepended.\n\n   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to\n   UCS-2. This trick makes it possible to add full UTF-16 capabilities\n   at a later point without compromising the APIs.\n\n*/\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF16(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */\n    const char *errors,         /* error handling */\n    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */\n    );\n\nPyAPI_FUNC(PyObject*) _PyUnicode_EncodeUTF16(\n    PyObject* unicode,          /* Unicode object */\n    const char *errors,         /* error handling */\n    int byteorder               /* byteorder to use 0=BOM+native;-1=LE,1=BE */\n    );\n\n/* --- Unicode-Escape Codecs ---------------------------------------------- */\n\n/* Helper for PyUnicode_DecodeUnicodeEscape that detects invalid escape\n   chars. */\nPyAPI_FUNC(PyObject*) _PyUnicode_DecodeUnicodeEscape(\n        const char *string,     /* Unicode-Escape encoded string */\n        Py_ssize_t length,      /* size of string */\n        const char *errors,     /* error handling */\n        const char **first_invalid_escape  /* on return, points to first\n                                              invalid escaped char in\n                                              string. */\n);\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeUnicodeEscape(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length           /* Number of Py_UNICODE chars to encode */\n    );\n\n/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeRawUnicodeEscape(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length           /* Number of Py_UNICODE chars to encode */\n    );\n\n/* --- Latin-1 Codecs ----------------------------------------------------- */\n\nPyAPI_FUNC(PyObject*) _PyUnicode_AsLatin1String(\n    PyObject* unicode,\n    const char* errors);\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeLatin1(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */\n    const char *errors          /* error handling */\n    );\n\n/* --- ASCII Codecs ------------------------------------------------------- */\n\nPyAPI_FUNC(PyObject*) _PyUnicode_AsASCIIString(\n    PyObject* unicode,\n    const char* errors);\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeASCII(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */\n    const char *errors          /* error handling */\n    );\n\n/* --- Character Map Codecs ----------------------------------------------- */\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeCharmap(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */\n    PyObject *mapping,          /* encoding mapping */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) _PyUnicode_EncodeCharmap(\n    PyObject *unicode,          /* Unicode object */\n    PyObject *mapping,          /* encoding mapping */\n    const char *errors          /* error handling */\n    );\n\n/* Translate a Py_UNICODE buffer of the given length by applying a\n   character mapping table to it and return the resulting Unicode\n   object.\n\n   The mapping table must map Unicode ordinal integers to Unicode strings,\n   Unicode ordinal integers or None (causing deletion of the character).\n\n   Mapping tables may be dictionaries or sequences. Unmapped character\n   ordinals (ones which cause a LookupError) are left untouched and\n   are copied as-is.\n\n*/\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject *) PyUnicode_TranslateCharmap(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */\n    PyObject *table,            /* Translate table */\n    const char *errors          /* error handling */\n    );\n\n/* --- MBCS codecs for Windows -------------------------------------------- */\n\n#ifdef MS_WINDOWS\nPy_DEPRECATED(3.3) PyAPI_FUNC(PyObject*) PyUnicode_EncodeMBCS(\n    const Py_UNICODE *data,     /* Unicode char buffer */\n    Py_ssize_t length,          /* number of Py_UNICODE chars to encode */\n    const char *errors          /* error handling */\n    );\n#endif\n\n/* --- Decimal Encoder ---------------------------------------------------- */\n\n/* Takes a Unicode string holding a decimal value and writes it into\n   an output buffer using standard ASCII digit codes.\n\n   The output buffer has to provide at least length+1 bytes of storage\n   area. The output string is 0-terminated.\n\n   The encoder converts whitespace to ' ', decimal characters to their\n   corresponding ASCII digit and all other Latin-1 characters except\n   \\0 as-is. Characters outside this range (Unicode ordinals 1-256)\n   are treated as errors. This includes embedded NULL bytes.\n\n   Error handling is defined by the errors argument:\n\n      NULL or \"strict\": raise a ValueError\n      \"ignore\": ignore the wrong characters (these are not copied to the\n                output buffer)\n      \"replace\": replaces illegal characters with '?'\n\n   Returns 0 on success, -1 on failure.\n\n*/\n\n/* Py_DEPRECATED(3.3) */ PyAPI_FUNC(int) PyUnicode_EncodeDecimal(\n    Py_UNICODE *s,              /* Unicode buffer */\n    Py_ssize_t length,          /* Number of Py_UNICODE chars to encode */\n    char *output,               /* Output buffer; must have size >= length */\n    const char *errors          /* error handling */\n    );\n\n/* Transforms code points that have decimal digit property to the\n   corresponding ASCII digit code points.\n\n   Returns a new Unicode string on success, NULL on failure.\n*/\n\n/* Py_DEPRECATED(3.3) */\nPyAPI_FUNC(PyObject*) PyUnicode_TransformDecimalToASCII(\n    Py_UNICODE *s,              /* Unicode buffer */\n    Py_ssize_t length           /* Number of Py_UNICODE chars to transform */\n    );\n\n/* Coverts a Unicode object holding a decimal value to an ASCII string\n   for using in int, float and complex parsers.\n   Transforms code points that have decimal digit property to the\n   corresponding ASCII digit code points.  Transforms spaces to ASCII.\n   Transforms code points starting from the first non-ASCII code point that\n   is neither a decimal digit nor a space to the end into '?'. */\n\nPyAPI_FUNC(PyObject*) _PyUnicode_TransformDecimalAndSpaceToASCII(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* --- Methods & Slots ---------------------------------------------------- */\n\nPyAPI_FUNC(PyObject *) _PyUnicode_JoinArray(\n    PyObject *separator,\n    PyObject *const *items,\n    Py_ssize_t seqlen\n    );\n\n/* Test whether a unicode is equal to ASCII identifier.  Return 1 if true,\n   0 otherwise.  The right argument must be ASCII identifier.\n   Any error occurs inside will be cleared before return. */\nPyAPI_FUNC(int) _PyUnicode_EqualToASCIIId(\n    PyObject *left,             /* Left string */\n    _Py_Identifier *right       /* Right identifier */\n    );\n\n/* Test whether a unicode is equal to ASCII string.  Return 1 if true,\n   0 otherwise.  The right argument must be ASCII-encoded string.\n   Any error occurs inside will be cleared before return. */\nPyAPI_FUNC(int) _PyUnicode_EqualToASCIIString(\n    PyObject *left,\n    const char *right           /* ASCII-encoded string */\n    );\n\n/* Externally visible for str.strip(unicode) */\nPyAPI_FUNC(PyObject *) _PyUnicode_XStrip(\n    PyObject *self,\n    int striptype,\n    PyObject *sepobj\n    );\n\n/* Using explicit passed-in values, insert the thousands grouping\n   into the string pointed to by buffer.  For the argument descriptions,\n   see Objects/stringlib/localeutil.h */\nPyAPI_FUNC(Py_ssize_t) _PyUnicode_InsertThousandsGrouping(\n    _PyUnicodeWriter *writer,\n    Py_ssize_t n_buffer,\n    PyObject *digits,\n    Py_ssize_t d_pos,\n    Py_ssize_t n_digits,\n    Py_ssize_t min_width,\n    const char *grouping,\n    PyObject *thousands_sep,\n    Py_UCS4 *maxchar);\n\n/* === Characters Type APIs =============================================== */\n\n/* Helper array used by Py_UNICODE_ISSPACE(). */\n\nPyAPI_DATA(const unsigned char) _Py_ascii_whitespace[];\n\n/* These should not be used directly. Use the Py_UNICODE_IS* and\n   Py_UNICODE_TO* macros instead.\n\n   These APIs are implemented in Objects/unicodectype.c.\n\n*/\n\nPyAPI_FUNC(int) _PyUnicode_IsLowercase(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsUppercase(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsTitlecase(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsXidStart(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsXidContinue(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsWhitespace(\n    const Py_UCS4 ch         /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsLinebreak(\n    const Py_UCS4 ch         /* Unicode character */\n    );\n\n/* Py_DEPRECATED(3.3) */ PyAPI_FUNC(Py_UCS4) _PyUnicode_ToLowercase(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\n/* Py_DEPRECATED(3.3) */ PyAPI_FUNC(Py_UCS4) _PyUnicode_ToUppercase(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UCS4) _PyUnicode_ToTitlecase(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_ToLowerFull(\n    Py_UCS4 ch,       /* Unicode character */\n    Py_UCS4 *res\n    );\n\nPyAPI_FUNC(int) _PyUnicode_ToTitleFull(\n    Py_UCS4 ch,       /* Unicode character */\n    Py_UCS4 *res\n    );\n\nPyAPI_FUNC(int) _PyUnicode_ToUpperFull(\n    Py_UCS4 ch,       /* Unicode character */\n    Py_UCS4 *res\n    );\n\nPyAPI_FUNC(int) _PyUnicode_ToFoldedFull(\n    Py_UCS4 ch,       /* Unicode character */\n    Py_UCS4 *res\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsCaseIgnorable(\n    Py_UCS4 ch         /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsCased(\n    Py_UCS4 ch         /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_ToDecimalDigit(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_ToDigit(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(double) _PyUnicode_ToNumeric(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsDecimalDigit(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsDigit(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsNumeric(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsPrintable(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPyAPI_FUNC(int) _PyUnicode_IsAlpha(\n    Py_UCS4 ch       /* Unicode character */\n    );\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(size_t) Py_UNICODE_strlen(\n    const Py_UNICODE *u\n    );\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE*) Py_UNICODE_strcpy(\n    Py_UNICODE *s1,\n    const Py_UNICODE *s2);\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE*) Py_UNICODE_strcat(\n    Py_UNICODE *s1, const Py_UNICODE *s2);\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE*) Py_UNICODE_strncpy(\n    Py_UNICODE *s1,\n    const Py_UNICODE *s2,\n    size_t n);\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(int) Py_UNICODE_strcmp(\n    const Py_UNICODE *s1,\n    const Py_UNICODE *s2\n    );\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(int) Py_UNICODE_strncmp(\n    const Py_UNICODE *s1,\n    const Py_UNICODE *s2,\n    size_t n\n    );\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE*) Py_UNICODE_strchr(\n    const Py_UNICODE *s,\n    Py_UNICODE c\n    );\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE*) Py_UNICODE_strrchr(\n    const Py_UNICODE *s,\n    Py_UNICODE c\n    );\n\nPyAPI_FUNC(PyObject*) _PyUnicode_FormatLong(PyObject *, int, int, int);\n\n/* Create a copy of a unicode string ending with a nul character. Return NULL\n   and raise a MemoryError exception on memory allocation failure, otherwise\n   return a new allocated buffer (use PyMem_Free() to free the buffer). */\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_UNICODE*) PyUnicode_AsUnicodeCopy(\n    PyObject *unicode\n    );\n\n/* Return an interned Unicode object for an Identifier; may fail if there is no memory.*/\nPyAPI_FUNC(PyObject*) _PyUnicode_FromId(_Py_Identifier*);\n/* Clear all static strings. */\nPyAPI_FUNC(void) _PyUnicode_ClearStaticStrings(void);\n\n/* Fast equality check when the inputs are known to be exact unicode types\n   and where the hash values are equal (i.e. a very probable match) */\nPyAPI_FUNC(int) _PyUnicode_EQ(PyObject *, PyObject *);\n\n#ifdef __cplusplus\n}\n#endif\n"}, "80": {"id": 80, "path": "/usr/include/python3.8/descrobject.h", "content": "/* Descriptors */\n#ifndef Py_DESCROBJECT_H\n#define Py_DESCROBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef PyObject *(*getter)(PyObject *, void *);\ntypedef int (*setter)(PyObject *, PyObject *, void *);\n\ntypedef struct PyGetSetDef {\n    const char *name;\n    getter get;\n    setter set;\n    const char *doc;\n    void *closure;\n} PyGetSetDef;\n\n#ifndef Py_LIMITED_API\ntypedef PyObject *(*wrapperfunc)(PyObject *self, PyObject *args,\n                                 void *wrapped);\n\ntypedef PyObject *(*wrapperfunc_kwds)(PyObject *self, PyObject *args,\n                                      void *wrapped, PyObject *kwds);\n\nstruct wrapperbase {\n    const char *name;\n    int offset;\n    void *function;\n    wrapperfunc wrapper;\n    const char *doc;\n    int flags;\n    PyObject *name_strobj;\n};\n\n/* Flags for above struct */\n#define PyWrapperFlag_KEYWORDS 1 /* wrapper function takes keyword args */\n\n/* Various kinds of descriptor objects */\n\ntypedef struct {\n    PyObject_HEAD\n    PyTypeObject *d_type;\n    PyObject *d_name;\n    PyObject *d_qualname;\n} PyDescrObject;\n\n#define PyDescr_COMMON PyDescrObject d_common\n\n#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)\n#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)\n\ntypedef struct {\n    PyDescr_COMMON;\n    PyMethodDef *d_method;\n    vectorcallfunc vectorcall;\n} PyMethodDescrObject;\n\ntypedef struct {\n    PyDescr_COMMON;\n    struct PyMemberDef *d_member;\n} PyMemberDescrObject;\n\ntypedef struct {\n    PyDescr_COMMON;\n    PyGetSetDef *d_getset;\n} PyGetSetDescrObject;\n\ntypedef struct {\n    PyDescr_COMMON;\n    struct wrapperbase *d_base;\n    void *d_wrapped; /* This can be any function pointer */\n} PyWrapperDescrObject;\n#endif /* Py_LIMITED_API */\n\nPyAPI_DATA(PyTypeObject) PyClassMethodDescr_Type;\nPyAPI_DATA(PyTypeObject) PyGetSetDescr_Type;\nPyAPI_DATA(PyTypeObject) PyMemberDescr_Type;\nPyAPI_DATA(PyTypeObject) PyMethodDescr_Type;\nPyAPI_DATA(PyTypeObject) PyWrapperDescr_Type;\nPyAPI_DATA(PyTypeObject) PyDictProxy_Type;\n#ifndef Py_LIMITED_API\nPyAPI_DATA(PyTypeObject) _PyMethodWrapper_Type;\n#endif /* Py_LIMITED_API */\n\nPyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);\nPyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);\nstruct PyMemberDef; /* forward declaration for following prototype */\nPyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *,\n                                               struct PyMemberDef *);\nPyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *,\n                                               struct PyGetSetDef *);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,\n                                                struct wrapperbase *, void *);\n#define PyDescr_IsData(d) (Py_TYPE(d)->tp_descr_set != NULL)\n#endif\n\nPyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);\nPyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);\n\n\nPyAPI_DATA(PyTypeObject) PyProperty_Type;\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_DESCROBJECT_H */\n\n"}, "81": {"id": 81, "path": "/usr/include/python3.8/dictobject.h", "content": "#ifndef Py_DICTOBJECT_H\n#define Py_DICTOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Dictionary object type -- mapping from hashable object to object */\n\n/* The distribution includes a separate file, Objects/dictnotes.txt,\n   describing explorations into dictionary design and optimization.\n   It covers typical dictionary use patterns, the parameters for\n   tuning dictionaries, and several ideas for possible optimizations.\n*/\n\nPyAPI_DATA(PyTypeObject) PyDict_Type;\n\n#define PyDict_Check(op) \\\n                 PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)\n#define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)\n\nPyAPI_FUNC(PyObject *) PyDict_New(void);\nPyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);\nPyAPI_FUNC(PyObject *) PyDict_GetItemWithError(PyObject *mp, PyObject *key);\nPyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);\nPyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);\nPyAPI_FUNC(void) PyDict_Clear(PyObject *mp);\nPyAPI_FUNC(int) PyDict_Next(\n    PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);\nPyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);\nPyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);\nPyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);\nPyAPI_FUNC(Py_ssize_t) PyDict_Size(PyObject *mp);\nPyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);\nPyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);\n\n/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */\nPyAPI_FUNC(int) PyDict_Update(PyObject *mp, PyObject *other);\n\n/* PyDict_Merge updates/merges from a mapping object (an object that\n   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,\n   the last occurrence of a key wins, else the first.  The Python\n   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).\n*/\nPyAPI_FUNC(int) PyDict_Merge(PyObject *mp,\n                             PyObject *other,\n                             int override);\n\n/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing\n   iterable objects of length 2.  If override is true, the last occurrence\n   of a key wins, else the first.  The Python dict constructor dict(seq2)\n   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).\n*/\nPyAPI_FUNC(int) PyDict_MergeFromSeq2(PyObject *d,\n                                     PyObject *seq2,\n                                     int override);\n\nPyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);\nPyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);\nPyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);\n\n/* Dictionary (keys, values, items) views */\n\nPyAPI_DATA(PyTypeObject) PyDictKeys_Type;\nPyAPI_DATA(PyTypeObject) PyDictValues_Type;\nPyAPI_DATA(PyTypeObject) PyDictItems_Type;\n\n#define PyDictKeys_Check(op) PyObject_TypeCheck(op, &PyDictKeys_Type)\n#define PyDictValues_Check(op) PyObject_TypeCheck(op, &PyDictValues_Type)\n#define PyDictItems_Check(op) PyObject_TypeCheck(op, &PyDictItems_Type)\n/* This excludes Values, since they are not sets. */\n# define PyDictViewSet_Check(op) \\\n    (PyDictKeys_Check(op) || PyDictItems_Check(op))\n\n/* Dictionary (key, value, items) iterators */\n\nPyAPI_DATA(PyTypeObject) PyDictIterKey_Type;\nPyAPI_DATA(PyTypeObject) PyDictIterValue_Type;\nPyAPI_DATA(PyTypeObject) PyDictIterItem_Type;\n\nPyAPI_DATA(PyTypeObject) PyDictRevIterKey_Type;\nPyAPI_DATA(PyTypeObject) PyDictRevIterItem_Type;\nPyAPI_DATA(PyTypeObject) PyDictRevIterValue_Type;\n\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_DICTOBJECT_H\n#  include  \"cpython/dictobject.h\"\n#  undef Py_CPYTHON_DICTOBJECT_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_DICTOBJECT_H */\n"}, "82": {"id": 82, "path": "/usr/include/python3.8/dtoa.h", "content": "#ifndef Py_LIMITED_API\n#ifndef PY_NO_SHORT_FLOAT_REPR\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(double) _Py_dg_strtod(const char *str, char **ptr);\nPyAPI_FUNC(char *) _Py_dg_dtoa(double d, int mode, int ndigits,\n                        int *decpt, int *sign, char **rve);\nPyAPI_FUNC(void) _Py_dg_freedtoa(char *s);\nPyAPI_FUNC(double) _Py_dg_stdnan(int sign);\nPyAPI_FUNC(double) _Py_dg_infinity(int sign);\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n#endif\n"}, "83": {"id": 83, "path": "/usr/include/python3.8/enumobject.h", "content": "#ifndef Py_ENUMOBJECT_H\n#define Py_ENUMOBJECT_H\n\n/* Enumerate Object */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_DATA(PyTypeObject) PyEnum_Type;\nPyAPI_DATA(PyTypeObject) PyReversed_Type;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_ENUMOBJECT_H */\n"}, "84": {"id": 84, "path": "/usr/include/python3.8/eval.h", "content": "\n/* Interface to execute compiled code */\n\n#ifndef Py_EVAL_H\n#define Py_EVAL_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);\n\nPyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co,\n                                         PyObject *globals,\n                                         PyObject *locals,\n                                         PyObject *const *args, int argc,\n                                         PyObject *const *kwds, int kwdc,\n                                         PyObject *const *defs, int defc,\n                                         PyObject *kwdefs, PyObject *closure);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyEval_EvalCodeWithName(\n    PyObject *co,\n    PyObject *globals, PyObject *locals,\n    PyObject *const *args, Py_ssize_t argcount,\n    PyObject *const *kwnames, PyObject *const *kwargs,\n    Py_ssize_t kwcount, int kwstep,\n    PyObject *const *defs, Py_ssize_t defcount,\n    PyObject *kwdefs, PyObject *closure,\n    PyObject *name, PyObject *qualname);\n\nPyAPI_FUNC(PyObject *) _PyEval_CallTracing(PyObject *func, PyObject *args);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_EVAL_H */\n"}, "85": {"id": 85, "path": "/usr/include/python3.8/fileobject.h", "content": "/* File object interface (what's left of it -- see io.py) */\n\n#ifndef Py_FILEOBJECT_H\n#define Py_FILEOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define PY_STDIOTEXTMODE \"b\"\n\nPyAPI_FUNC(PyObject *) PyFile_FromFd(int, const char *, const char *, int,\n                                     const char *, const char *,\n                                     const char *, int);\nPyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);\nPyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);\n\n/* The default encoding used by the platform file system APIs\n   If non-NULL, this is different than the default encoding for strings\n*/\nPyAPI_DATA(const char *) Py_FileSystemDefaultEncoding;\nPyAPI_DATA(int) Py_HasFileSystemDefaultEncoding;\n\n/* A routine to check if a file descriptor can be select()-ed. */\n#ifdef _MSC_VER\n    /* On Windows, any socket fd can be select()-ed, no matter how high */\n    #define _PyIsSelectable_fd(FD) (1)\n#else\n    #define _PyIsSelectable_fd(FD) ((unsigned int)(FD) < (unsigned int)FD_SETSIZE)\n#endif\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_FILEOBJECT_H\n#  include  \"cpython/fileobject.h\"\n#  undef Py_CPYTHON_FILEOBJECT_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_FILEOBJECT_H */\n"}, "86": {"id": 86, "path": "/usr/include/python3.8/fileutils.h", "content": "#ifndef Py_FILEUTILS_H\n#define Py_FILEUTILS_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\nPyAPI_FUNC(wchar_t *) Py_DecodeLocale(\n    const char *arg,\n    size_t *size);\n\nPyAPI_FUNC(char*) Py_EncodeLocale(\n    const wchar_t *text,\n    size_t *error_pos);\n\nPyAPI_FUNC(char*) _Py_EncodeLocaleRaw(\n    const wchar_t *text,\n    size_t *error_pos);\n#endif\n\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000\ntypedef enum {\n    _Py_ERROR_UNKNOWN=0,\n    _Py_ERROR_STRICT,\n    _Py_ERROR_SURROGATEESCAPE,\n    _Py_ERROR_REPLACE,\n    _Py_ERROR_IGNORE,\n    _Py_ERROR_BACKSLASHREPLACE,\n    _Py_ERROR_SURROGATEPASS,\n    _Py_ERROR_XMLCHARREFREPLACE,\n    _Py_ERROR_OTHER\n} _Py_error_handler;\n\nPyAPI_FUNC(_Py_error_handler) _Py_GetErrorHandler(const char *errors);\n\nPyAPI_FUNC(int) _Py_DecodeLocaleEx(\n    const char *arg,\n    wchar_t **wstr,\n    size_t *wlen,\n    const char **reason,\n    int current_locale,\n    _Py_error_handler errors);\n\nPyAPI_FUNC(int) _Py_EncodeLocaleEx(\n    const wchar_t *text,\n    char **str,\n    size_t *error_pos,\n    const char **reason,\n    int current_locale,\n    _Py_error_handler errors);\n#endif\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _Py_device_encoding(int);\n\n#if defined(MS_WINDOWS) || defined(__APPLE__)\n    /* On Windows, the count parameter of read() is an int (bpo-9015, bpo-9611).\n       On macOS 10.13, read() and write() with more than INT_MAX bytes\n       fail with EINVAL (bpo-24658). */\n#   define _PY_READ_MAX  INT_MAX\n#   define _PY_WRITE_MAX INT_MAX\n#else\n    /* write() should truncate the input to PY_SSIZE_T_MAX bytes,\n       but it's safer to do it ourself to have a portable behaviour */\n#   define _PY_READ_MAX  PY_SSIZE_T_MAX\n#   define _PY_WRITE_MAX PY_SSIZE_T_MAX\n#endif\n\n#ifdef MS_WINDOWS\nstruct _Py_stat_struct {\n    unsigned long st_dev;\n    uint64_t st_ino;\n    unsigned short st_mode;\n    int st_nlink;\n    int st_uid;\n    int st_gid;\n    unsigned long st_rdev;\n    __int64 st_size;\n    time_t st_atime;\n    int st_atime_nsec;\n    time_t st_mtime;\n    int st_mtime_nsec;\n    time_t st_ctime;\n    int st_ctime_nsec;\n    unsigned long st_file_attributes;\n    unsigned long st_reparse_tag;\n};\n#else\n#  define _Py_stat_struct stat\n#endif\n\nPyAPI_FUNC(int) _Py_fstat(\n    int fd,\n    struct _Py_stat_struct *status);\n\nPyAPI_FUNC(int) _Py_fstat_noraise(\n    int fd,\n    struct _Py_stat_struct *status);\n\nPyAPI_FUNC(int) _Py_stat(\n    PyObject *path,\n    struct stat *status);\n\nPyAPI_FUNC(int) _Py_open(\n    const char *pathname,\n    int flags);\n\nPyAPI_FUNC(int) _Py_open_noraise(\n    const char *pathname,\n    int flags);\n\nPyAPI_FUNC(FILE *) _Py_wfopen(\n    const wchar_t *path,\n    const wchar_t *mode);\n\nPyAPI_FUNC(FILE*) _Py_fopen(\n    const char *pathname,\n    const char *mode);\n\nPyAPI_FUNC(FILE*) _Py_fopen_obj(\n    PyObject *path,\n    const char *mode);\n\nPyAPI_FUNC(Py_ssize_t) _Py_read(\n    int fd,\n    void *buf,\n    size_t count);\n\nPyAPI_FUNC(Py_ssize_t) _Py_write(\n    int fd,\n    const void *buf,\n    size_t count);\n\nPyAPI_FUNC(Py_ssize_t) _Py_write_noraise(\n    int fd,\n    const void *buf,\n    size_t count);\n\n#ifdef HAVE_READLINK\nPyAPI_FUNC(int) _Py_wreadlink(\n    const wchar_t *path,\n    wchar_t *buf,\n    /* Number of characters of 'buf' buffer\n       including the trailing NUL character */\n    size_t buflen);\n#endif\n\n#ifdef HAVE_REALPATH\nPyAPI_FUNC(wchar_t*) _Py_wrealpath(\n    const wchar_t *path,\n    wchar_t *resolved_path,\n    /* Number of characters of 'resolved_path' buffer\n       including the trailing NUL character */\n    size_t resolved_path_len);\n#endif\n\nPyAPI_FUNC(wchar_t*) _Py_wgetcwd(\n    wchar_t *buf,\n    /* Number of characters of 'buf' buffer\n       including the trailing NUL character */\n    size_t buflen);\n\nPyAPI_FUNC(int) _Py_get_inheritable(int fd);\n\nPyAPI_FUNC(int) _Py_set_inheritable(int fd, int inheritable,\n                                    int *atomic_flag_works);\n\nPyAPI_FUNC(int) _Py_set_inheritable_async_safe(int fd, int inheritable,\n                                               int *atomic_flag_works);\n\nPyAPI_FUNC(int) _Py_dup(int fd);\n\n#ifndef MS_WINDOWS\nPyAPI_FUNC(int) _Py_get_blocking(int fd);\n\nPyAPI_FUNC(int) _Py_set_blocking(int fd, int blocking);\n#endif   /* !MS_WINDOWS */\n\n#endif   /* Py_LIMITED_API */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_FILEUTILS_H */\n"}, "87": {"id": 87, "path": "/usr/include/python3.8/floatobject.h", "content": "\n/* Float object interface */\n\n/*\nPyFloatObject represents a (double precision) floating point number.\n*/\n\n#ifndef Py_FLOATOBJECT_H\n#define Py_FLOATOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\ntypedef struct {\n    PyObject_HEAD\n    double ob_fval;\n} PyFloatObject;\n#endif\n\nPyAPI_DATA(PyTypeObject) PyFloat_Type;\n\n#define PyFloat_Check(op) PyObject_TypeCheck(op, &PyFloat_Type)\n#define PyFloat_CheckExact(op) (Py_TYPE(op) == &PyFloat_Type)\n\n#ifdef Py_NAN\n#define Py_RETURN_NAN return PyFloat_FromDouble(Py_NAN)\n#endif\n\n#define Py_RETURN_INF(sign) do                     \\\n    if (copysign(1., sign) == 1.) {                \\\n        return PyFloat_FromDouble(Py_HUGE_VAL);    \\\n    } else {                        \\\n        return PyFloat_FromDouble(-Py_HUGE_VAL);   \\\n    } while(0)\n\nPyAPI_FUNC(double) PyFloat_GetMax(void);\nPyAPI_FUNC(double) PyFloat_GetMin(void);\nPyAPI_FUNC(PyObject *) PyFloat_GetInfo(void);\n\n/* Return Python float from string PyObject. */\nPyAPI_FUNC(PyObject *) PyFloat_FromString(PyObject*);\n\n/* Return Python float from C double. */\nPyAPI_FUNC(PyObject *) PyFloat_FromDouble(double);\n\n/* Extract C double from Python float.  The macro version trades safety for\n   speed. */\nPyAPI_FUNC(double) PyFloat_AsDouble(PyObject *);\n#ifndef Py_LIMITED_API\n#define PyFloat_AS_DOUBLE(op) (((PyFloatObject *)(op))->ob_fval)\n#endif\n\n#ifndef Py_LIMITED_API\n/* _PyFloat_{Pack,Unpack}{4,8}\n *\n * The struct and pickle (at least) modules need an efficient platform-\n * independent way to store floating-point values as byte strings.\n * The Pack routines produce a string from a C double, and the Unpack\n * routines produce a C double from such a string.  The suffix (4 or 8)\n * specifies the number of bytes in the string.\n *\n * On platforms that appear to use (see _PyFloat_Init()) IEEE-754 formats\n * these functions work by copying bits.  On other platforms, the formats the\n * 4- byte format is identical to the IEEE-754 single precision format, and\n * the 8-byte format to the IEEE-754 double precision format, although the\n * packing of INFs and NaNs (if such things exist on the platform) isn't\n * handled correctly, and attempting to unpack a string containing an IEEE\n * INF or NaN will raise an exception.\n *\n * On non-IEEE platforms with more precision, or larger dynamic range, than\n * 754 supports, not all values can be packed; on non-IEEE platforms with less\n * precision, or smaller dynamic range, not all values can be unpacked.  What\n * happens in such cases is partly accidental (alas).\n */\n\n/* The pack routines write 2, 4 or 8 bytes, starting at p.  le is a bool\n * argument, true if you want the string in little-endian format (exponent\n * last, at p+1, p+3 or p+7), false if you want big-endian format (exponent\n * first, at p).\n * Return value:  0 if all is OK, -1 if error (and an exception is\n * set, most likely OverflowError).\n * There are two problems on non-IEEE platforms:\n * 1):  What this does is undefined if x is a NaN or infinity.\n * 2):  -0.0 and +0.0 produce the same string.\n */\nPyAPI_FUNC(int) _PyFloat_Pack2(double x, unsigned char *p, int le);\nPyAPI_FUNC(int) _PyFloat_Pack4(double x, unsigned char *p, int le);\nPyAPI_FUNC(int) _PyFloat_Pack8(double x, unsigned char *p, int le);\n\n/* Needed for the old way for marshal to store a floating point number.\n   Returns the string length copied into p, -1 on error.\n */\nPyAPI_FUNC(int) _PyFloat_Repr(double x, char *p, size_t len);\n\n/* Used to get the important decimal digits of a double */\nPyAPI_FUNC(int) _PyFloat_Digits(char *buf, double v, int *signum);\nPyAPI_FUNC(void) _PyFloat_DigitsInit(void);\n\n/* The unpack routines read 2, 4 or 8 bytes, starting at p.  le is a bool\n * argument, true if the string is in little-endian format (exponent\n * last, at p+1, p+3 or p+7), false if big-endian (exponent first, at p).\n * Return value:  The unpacked double.  On error, this is -1.0 and\n * PyErr_Occurred() is true (and an exception is set, most likely\n * OverflowError).  Note that on a non-IEEE platform this will refuse\n * to unpack a string that represents a NaN or infinity.\n */\nPyAPI_FUNC(double) _PyFloat_Unpack2(const unsigned char *p, int le);\nPyAPI_FUNC(double) _PyFloat_Unpack4(const unsigned char *p, int le);\nPyAPI_FUNC(double) _PyFloat_Unpack8(const unsigned char *p, int le);\n\n/* free list api */\nPyAPI_FUNC(int) PyFloat_ClearFreeList(void);\n\nPyAPI_FUNC(void) _PyFloat_DebugMallocStats(FILE* out);\n\n/* Format the object based on the format_spec, as defined in PEP 3101\n   (Advanced String Formatting). */\nPyAPI_FUNC(int) _PyFloat_FormatAdvancedWriter(\n    _PyUnicodeWriter *writer,\n    PyObject *obj,\n    PyObject *format_spec,\n    Py_ssize_t start,\n    Py_ssize_t end);\n#endif /* Py_LIMITED_API */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_FLOATOBJECT_H */\n"}, "88": {"id": 88, "path": "/usr/include/python3.8/funcobject.h", "content": "\n/* Function object interface */\n#ifndef Py_LIMITED_API\n#ifndef Py_FUNCOBJECT_H\n#define Py_FUNCOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Function objects and code objects should not be confused with each other:\n *\n * Function objects are created by the execution of the 'def' statement.\n * They reference a code object in their __code__ attribute, which is a\n * purely syntactic object, i.e. nothing more than a compiled version of some\n * source code lines.  There is one code object per source code \"fragment\",\n * but each code object can be referenced by zero or many function objects\n * depending only on how many times the 'def' statement in the source was\n * executed so far.\n */\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *func_code;        /* A code object, the __code__ attribute */\n    PyObject *func_globals;     /* A dictionary (other mappings won't do) */\n    PyObject *func_defaults;    /* NULL or a tuple */\n    PyObject *func_kwdefaults;  /* NULL or a dict */\n    PyObject *func_closure;     /* NULL or a tuple of cell objects */\n    PyObject *func_doc;         /* The __doc__ attribute, can be anything */\n    PyObject *func_name;        /* The __name__ attribute, a string object */\n    PyObject *func_dict;        /* The __dict__ attribute, a dict or NULL */\n    PyObject *func_weakreflist; /* List of weak references */\n    PyObject *func_module;      /* The __module__ attribute, can be anything */\n    PyObject *func_annotations; /* Annotations, a dict or NULL */\n    PyObject *func_qualname;    /* The qualified name */\n    vectorcallfunc vectorcall;\n\n    /* Invariant:\n     *     func_closure contains the bindings for func_code->co_freevars, so\n     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)\n     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).\n     */\n} PyFunctionObject;\n\nPyAPI_DATA(PyTypeObject) PyFunction_Type;\n\n#define PyFunction_Check(op) (Py_TYPE(op) == &PyFunction_Type)\n\nPyAPI_FUNC(PyObject *) PyFunction_New(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_GetCode(PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_GetGlobals(PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);\nPyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_GetKwDefaults(PyObject *);\nPyAPI_FUNC(int) PyFunction_SetKwDefaults(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);\nPyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyFunction_GetAnnotations(PyObject *);\nPyAPI_FUNC(int) PyFunction_SetAnnotations(PyObject *, PyObject *);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyFunction_FastCallDict(\n    PyObject *func,\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    PyObject *kwargs);\n\nPyAPI_FUNC(PyObject *) _PyFunction_Vectorcall(\n    PyObject *func,\n    PyObject *const *stack,\n    size_t nargsf,\n    PyObject *kwnames);\n#endif\n\n/* Macros for direct access to these values. Type checks are *not*\n   done, so use with care. */\n#define PyFunction_GET_CODE(func) \\\n        (((PyFunctionObject *)func) -> func_code)\n#define PyFunction_GET_GLOBALS(func) \\\n        (((PyFunctionObject *)func) -> func_globals)\n#define PyFunction_GET_MODULE(func) \\\n        (((PyFunctionObject *)func) -> func_module)\n#define PyFunction_GET_DEFAULTS(func) \\\n        (((PyFunctionObject *)func) -> func_defaults)\n#define PyFunction_GET_KW_DEFAULTS(func) \\\n        (((PyFunctionObject *)func) -> func_kwdefaults)\n#define PyFunction_GET_CLOSURE(func) \\\n        (((PyFunctionObject *)func) -> func_closure)\n#define PyFunction_GET_ANNOTATIONS(func) \\\n        (((PyFunctionObject *)func) -> func_annotations)\n\n/* The classmethod and staticmethod types lives here, too */\nPyAPI_DATA(PyTypeObject) PyClassMethod_Type;\nPyAPI_DATA(PyTypeObject) PyStaticMethod_Type;\n\nPyAPI_FUNC(PyObject *) PyClassMethod_New(PyObject *);\nPyAPI_FUNC(PyObject *) PyStaticMethod_New(PyObject *);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_FUNCOBJECT_H */\n#endif /* Py_LIMITED_API */\n"}, "89": {"id": 89, "path": "/usr/include/python3.8/genobject.h", "content": "\n/* Generator object interface */\n\n#ifndef Py_LIMITED_API\n#ifndef Py_GENOBJECT_H\n#define Py_GENOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"pystate.h\"   /* _PyErr_StackItem */\n\nstruct _frame; /* Avoid including frameobject.h */\n\n/* _PyGenObject_HEAD defines the initial segment of generator\n   and coroutine objects. */\n#define _PyGenObject_HEAD(prefix)                                           \\\n    PyObject_HEAD                                                           \\\n    /* Note: gi_frame can be NULL if the generator is \"finished\" */         \\\n    struct _frame *prefix##_frame;                                          \\\n    /* True if generator is being executed. */                              \\\n    char prefix##_running;                                                  \\\n    /* The code object backing the generator */                             \\\n    PyObject *prefix##_code;                                                \\\n    /* List of weak reference. */                                           \\\n    PyObject *prefix##_weakreflist;                                         \\\n    /* Name of the generator. */                                            \\\n    PyObject *prefix##_name;                                                \\\n    /* Qualified name of the generator. */                                  \\\n    PyObject *prefix##_qualname;                                            \\\n    _PyErr_StackItem prefix##_exc_state;\n\ntypedef struct {\n    /* The gi_ prefix is intended to remind of generator-iterator. */\n    _PyGenObject_HEAD(gi)\n} PyGenObject;\n\nPyAPI_DATA(PyTypeObject) PyGen_Type;\n\n#define PyGen_Check(op) PyObject_TypeCheck(op, &PyGen_Type)\n#define PyGen_CheckExact(op) (Py_TYPE(op) == &PyGen_Type)\n\nPyAPI_FUNC(PyObject *) PyGen_New(struct _frame *);\nPyAPI_FUNC(PyObject *) PyGen_NewWithQualName(struct _frame *,\n    PyObject *name, PyObject *qualname);\nPyAPI_FUNC(int) PyGen_NeedsFinalizing(PyGenObject *);\nPyAPI_FUNC(int) _PyGen_SetStopIterationValue(PyObject *);\nPyAPI_FUNC(int) _PyGen_FetchStopIterationValue(PyObject **);\nPyAPI_FUNC(PyObject *) _PyGen_Send(PyGenObject *, PyObject *);\nPyObject *_PyGen_yf(PyGenObject *);\nPyAPI_FUNC(void) _PyGen_Finalize(PyObject *self);\n\n#ifndef Py_LIMITED_API\ntypedef struct {\n    _PyGenObject_HEAD(cr)\n    PyObject *cr_origin;\n} PyCoroObject;\n\nPyAPI_DATA(PyTypeObject) PyCoro_Type;\nPyAPI_DATA(PyTypeObject) _PyCoroWrapper_Type;\n\nPyAPI_DATA(PyTypeObject) _PyAIterWrapper_Type;\n\n#define PyCoro_CheckExact(op) (Py_TYPE(op) == &PyCoro_Type)\nPyObject *_PyCoro_GetAwaitableIter(PyObject *o);\nPyAPI_FUNC(PyObject *) PyCoro_New(struct _frame *,\n    PyObject *name, PyObject *qualname);\n\n/* Asynchronous Generators */\n\ntypedef struct {\n    _PyGenObject_HEAD(ag)\n    PyObject *ag_finalizer;\n\n    /* Flag is set to 1 when hooks set up by sys.set_asyncgen_hooks\n       were called on the generator, to avoid calling them more\n       than once. */\n    int ag_hooks_inited;\n\n    /* Flag is set to 1 when aclose() is called for the first time, or\n       when a StopAsyncIteration exception is raised. */\n    int ag_closed;\n\n    int ag_running_async;\n} PyAsyncGenObject;\n\nPyAPI_DATA(PyTypeObject) PyAsyncGen_Type;\nPyAPI_DATA(PyTypeObject) _PyAsyncGenASend_Type;\nPyAPI_DATA(PyTypeObject) _PyAsyncGenWrappedValue_Type;\nPyAPI_DATA(PyTypeObject) _PyAsyncGenAThrow_Type;\n\nPyAPI_FUNC(PyObject *) PyAsyncGen_New(struct _frame *,\n    PyObject *name, PyObject *qualname);\n\n#define PyAsyncGen_CheckExact(op) (Py_TYPE(op) == &PyAsyncGen_Type)\n\nPyObject *_PyAsyncGenValueWrapperNew(PyObject *);\n\nint PyAsyncGen_ClearFreeLists(void);\n\n#endif\n\n#undef _PyGenObject_HEAD\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_GENOBJECT_H */\n#endif /* Py_LIMITED_API */\n"}, "90": {"id": 90, "path": "/usr/include/python3.8/import.h", "content": "\n/* Module definition and import interface */\n\n#ifndef Py_IMPORT_H\n#define Py_IMPORT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\nPyMODINIT_FUNC PyInit__imp(void);\n#endif /* !Py_LIMITED_API */\nPyAPI_FUNC(long) PyImport_GetMagicNumber(void);\nPyAPI_FUNC(const char *) PyImport_GetMagicTag(void);\nPyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(\n    const char *name,           /* UTF-8 encoded string */\n    PyObject *co\n    );\nPyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(\n    const char *name,           /* UTF-8 encoded string */\n    PyObject *co,\n    const char *pathname        /* decoded from the filesystem encoding */\n    );\nPyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleWithPathnames(\n    const char *name,           /* UTF-8 encoded string */\n    PyObject *co,\n    const char *pathname,       /* decoded from the filesystem encoding */\n    const char *cpathname       /* decoded from the filesystem encoding */\n    );\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleObject(\n    PyObject *name,\n    PyObject *co,\n    PyObject *pathname,\n    PyObject *cpathname\n    );\n#endif\nPyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000\nPyAPI_FUNC(PyObject *) PyImport_GetModule(PyObject *name);\n#endif\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyImport_IsInitialized(PyInterpreterState *);\nPyAPI_FUNC(PyObject *) _PyImport_GetModuleId(struct _Py_Identifier *name);\nPyAPI_FUNC(PyObject *) _PyImport_AddModuleObject(PyObject *name,\n                                                 PyObject *modules);\nPyAPI_FUNC(int) _PyImport_SetModule(PyObject *name, PyObject *module);\nPyAPI_FUNC(int) _PyImport_SetModuleString(const char *name, PyObject* module);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject *) PyImport_AddModuleObject(\n    PyObject *name\n    );\n#endif\nPyAPI_FUNC(PyObject *) PyImport_AddModule(\n    const char *name            /* UTF-8 encoded string */\n    );\nPyAPI_FUNC(PyObject *) PyImport_ImportModule(\n    const char *name            /* UTF-8 encoded string */\n    );\nPyAPI_FUNC(PyObject *) PyImport_ImportModuleNoBlock(\n    const char *name            /* UTF-8 encoded string */\n    );\nPyAPI_FUNC(PyObject *) PyImport_ImportModuleLevel(\n    const char *name,           /* UTF-8 encoded string */\n    PyObject *globals,\n    PyObject *locals,\n    PyObject *fromlist,\n    int level\n    );\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\nPyAPI_FUNC(PyObject *) PyImport_ImportModuleLevelObject(\n    PyObject *name,\n    PyObject *globals,\n    PyObject *locals,\n    PyObject *fromlist,\n    int level\n    );\n#endif\n\n#define PyImport_ImportModuleEx(n, g, l, f) \\\n    PyImport_ImportModuleLevel(n, g, l, f, 0)\n\nPyAPI_FUNC(PyObject *) PyImport_GetImporter(PyObject *path);\nPyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);\nPyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);\nPyAPI_FUNC(void) PyImport_Cleanup(void);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyImport_ImportFrozenModuleObject(\n    PyObject *name\n    );\n#endif\nPyAPI_FUNC(int) PyImport_ImportFrozenModule(\n    const char *name            /* UTF-8 encoded string */\n    );\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(void) _PyImport_AcquireLock(void);\nPyAPI_FUNC(int) _PyImport_ReleaseLock(void);\n\nPyAPI_FUNC(void) _PyImport_ReInitLock(void);\n\nPyAPI_FUNC(PyObject *) _PyImport_FindBuiltin(\n    const char *name,            /* UTF-8 encoded string */\n    PyObject *modules\n    );\nPyAPI_FUNC(PyObject *) _PyImport_FindExtensionObject(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) _PyImport_FindExtensionObjectEx(PyObject *, PyObject *,\n                                                       PyObject *);\nPyAPI_FUNC(int) _PyImport_FixupBuiltin(\n    PyObject *mod,\n    const char *name,            /* UTF-8 encoded string */\n    PyObject *modules\n    );\nPyAPI_FUNC(int) _PyImport_FixupExtensionObject(PyObject*, PyObject *,\n                                               PyObject *, PyObject *);\n\nstruct _inittab {\n    const char *name;           /* ASCII encoded string */\n    PyObject* (*initfunc)(void);\n};\nPyAPI_DATA(struct _inittab *) PyImport_Inittab;\nPyAPI_FUNC(int) PyImport_ExtendInittab(struct _inittab *newtab);\n#endif /* Py_LIMITED_API */\n\nPyAPI_DATA(PyTypeObject) PyNullImporter_Type;\n\nPyAPI_FUNC(int) PyImport_AppendInittab(\n    const char *name,           /* ASCII encoded string */\n    PyObject* (*initfunc)(void)\n    );\n\n#ifndef Py_LIMITED_API\nstruct _frozen {\n    const char *name;                 /* ASCII encoded string */\n    const unsigned char *code;\n    int size;\n};\n\n/* Embedding apps may change this pointer to point to their favorite\n   collection of frozen modules: */\n\nPyAPI_DATA(const struct _frozen *) PyImport_FrozenModules;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_IMPORT_H */\n"}, "91": {"id": 91, "path": "/usr/include/python3.8/intrcheck.h", "content": "\n#ifndef Py_INTRCHECK_H\n#define Py_INTRCHECK_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(int) PyOS_InterruptOccurred(void);\nPyAPI_FUNC(void) PyOS_InitInterrupts(void);\n#ifdef HAVE_FORK\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000\nPyAPI_FUNC(void) PyOS_BeforeFork(void);\nPyAPI_FUNC(void) PyOS_AfterFork_Parent(void);\nPyAPI_FUNC(void) PyOS_AfterFork_Child(void);\n#endif\n#endif\n/* Deprecated, please use PyOS_AfterFork_Child() instead */\nPy_DEPRECATED(3.7) PyAPI_FUNC(void) PyOS_AfterFork(void);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyOS_IsMainThread(void);\nPyAPI_FUNC(void) _PySignal_AfterFork(void);\n\n#ifdef MS_WINDOWS\n/* windows.h is not included by Python.h so use void* instead of HANDLE */\nPyAPI_FUNC(void*) _PyOS_SigintEvent(void);\n#endif\n#endif /* !Py_LIMITED_API */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_INTRCHECK_H */\n"}, "92": {"id": 92, "path": "/usr/include/python3.8/iterobject.h", "content": "#ifndef Py_ITEROBJECT_H\n#define Py_ITEROBJECT_H\n/* Iterators (the basic kind, over a sequence) */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_DATA(PyTypeObject) PySeqIter_Type;\nPyAPI_DATA(PyTypeObject) PyCallIter_Type;\nPyAPI_DATA(PyTypeObject) PyCmpWrapper_Type;\n\n#define PySeqIter_Check(op) (Py_TYPE(op) == &PySeqIter_Type)\n\nPyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);\n\n\n#define PyCallIter_Check(op) (Py_TYPE(op) == &PyCallIter_Type)\n\nPyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_ITEROBJECT_H */\n\n"}, "93": {"id": 93, "path": "/usr/include/python3.8/listobject.h", "content": "\n/* List object interface */\n\n/*\nAnother generally useful object type is a list of object pointers.\nThis is a mutable type: the list items can be changed, and items can be\nadded or removed.  Out-of-range indices or non-list objects are ignored.\n\n*** WARNING *** PyList_SetItem does not increment the new item's reference\ncount, but does decrement the reference count of the item it replaces,\nif not nil.  It does *decrement* the reference count if it is *not*\ninserted in the list.  Similarly, PyList_GetItem does not increment the\nreturned item's reference count.\n*/\n\n#ifndef Py_LISTOBJECT_H\n#define Py_LISTOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 <= ob_size <= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\n#endif\n\nPyAPI_DATA(PyTypeObject) PyList_Type;\nPyAPI_DATA(PyTypeObject) PyListIter_Type;\nPyAPI_DATA(PyTypeObject) PyListRevIter_Type;\nPyAPI_DATA(PyTypeObject) PySortWrapper_Type;\n\n#define PyList_Check(op) \\\n    PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)\n#define PyList_CheckExact(op) (Py_TYPE(op) == &PyList_Type)\n\nPyAPI_FUNC(PyObject *) PyList_New(Py_ssize_t size);\nPyAPI_FUNC(Py_ssize_t) PyList_Size(PyObject *);\nPyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, Py_ssize_t);\nPyAPI_FUNC(int) PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);\nPyAPI_FUNC(int) PyList_Insert(PyObject *, Py_ssize_t, PyObject *);\nPyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);\nPyAPI_FUNC(int) PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\nPyAPI_FUNC(int) PyList_Sort(PyObject *);\nPyAPI_FUNC(int) PyList_Reverse(PyObject *);\nPyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);\n\nPyAPI_FUNC(int) PyList_ClearFreeList(void);\nPyAPI_FUNC(void) _PyList_DebugMallocStats(FILE *out);\n#endif\n\n/* Macro, trading safety for speed */\n#ifndef Py_LIMITED_API\n#define PyList_GET_ITEM(op, i) (((PyListObject *)(op))->ob_item[i])\n#define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))->ob_item[i] = (v))\n#define PyList_GET_SIZE(op)    (assert(PyList_Check(op)),Py_SIZE(op))\n#define _PyList_ITEMS(op)      (((PyListObject *)(op))->ob_item)\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_LISTOBJECT_H */\n"}, "94": {"id": 94, "path": "/usr/include/python3.8/longintrepr.h", "content": "#ifndef Py_LIMITED_API\n#ifndef Py_LONGINTREPR_H\n#define Py_LONGINTREPR_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* This is published for the benefit of \"friends\" marshal.c and _decimal.c. */\n\n/* Parameters of the integer representation.  There are two different\n   sets of parameters: one set for 30-bit digits, stored in an unsigned 32-bit\n   integer type, and one set for 15-bit digits with each digit stored in an\n   unsigned short.  The value of PYLONG_BITS_IN_DIGIT, defined either at\n   configure time or in pyport.h, is used to decide which digit size to use.\n\n   Type 'digit' should be able to hold 2*PyLong_BASE-1, and type 'twodigits'\n   should be an unsigned integer type able to hold all integers up to\n   PyLong_BASE*PyLong_BASE-1.  x_sub assumes that 'digit' is an unsigned type,\n   and that overflow is handled by taking the result modulo 2**N for some N >\n   PyLong_SHIFT.  The majority of the code doesn't care about the precise\n   value of PyLong_SHIFT, but there are some notable exceptions:\n\n   - long_pow() requires that PyLong_SHIFT be divisible by 5\n\n   - PyLong_{As,From}ByteArray require that PyLong_SHIFT be at least 8\n\n   - long_hash() requires that PyLong_SHIFT is *strictly* less than the number\n     of bits in an unsigned long, as do the PyLong <-> long (or unsigned long)\n     conversion functions\n\n   - the Python int <-> size_t/Py_ssize_t conversion functions expect that\n     PyLong_SHIFT is strictly less than the number of bits in a size_t\n\n   - the marshal code currently expects that PyLong_SHIFT is a multiple of 15\n\n   - NSMALLNEGINTS and NSMALLPOSINTS should be small enough to fit in a single\n     digit; with the current values this forces PyLong_SHIFT >= 9\n\n  The values 15 and 30 should fit all of the above requirements, on any\n  platform.\n*/\n\n#if PYLONG_BITS_IN_DIGIT == 30\ntypedef uint32_t digit;\ntypedef int32_t sdigit; /* signed variant of digit */\ntypedef uint64_t twodigits;\ntypedef int64_t stwodigits; /* signed variant of twodigits */\n#define PyLong_SHIFT    30\n#define _PyLong_DECIMAL_SHIFT   9 /* max(e such that 10**e fits in a digit) */\n#define _PyLong_DECIMAL_BASE    ((digit)1000000000) /* 10 ** DECIMAL_SHIFT */\n#elif PYLONG_BITS_IN_DIGIT == 15\ntypedef unsigned short digit;\ntypedef short sdigit; /* signed variant of digit */\ntypedef unsigned long twodigits;\ntypedef long stwodigits; /* signed variant of twodigits */\n#define PyLong_SHIFT    15\n#define _PyLong_DECIMAL_SHIFT   4 /* max(e such that 10**e fits in a digit) */\n#define _PyLong_DECIMAL_BASE    ((digit)10000) /* 10 ** DECIMAL_SHIFT */\n#else\n#error \"PYLONG_BITS_IN_DIGIT should be 15 or 30\"\n#endif\n#define PyLong_BASE     ((digit)1 << PyLong_SHIFT)\n#define PyLong_MASK     ((digit)(PyLong_BASE - 1))\n\n#if PyLong_SHIFT % 5 != 0\n#error \"longobject.c requires that PyLong_SHIFT be divisible by 5\"\n#endif\n\n/* Long integer representation.\n   The absolute value of a number is equal to\n        SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)\n   Negative numbers are represented with ob_size < 0;\n   zero is represented by ob_size == 0.\n   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant\n   digit) is never zero.  Also, in all cases, for all valid i,\n        0 <= ob_digit[i] <= MASK.\n   The allocation function takes care of allocating extra memory\n   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.\n\n   CAUTION:  Generic code manipulating subtypes of PyVarObject has to\n   aware that ints abuse  ob_size's sign bit.\n*/\n\nstruct _longobject {\n    PyObject_VAR_HEAD\n    digit ob_digit[1];\n};\n\nPyAPI_FUNC(PyLongObject *) _PyLong_New(Py_ssize_t);\n\n/* Return a copy of src. */\nPyAPI_FUNC(PyObject *) _PyLong_Copy(PyLongObject *src);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_LONGINTREPR_H */\n#endif /* Py_LIMITED_API */\n"}, "95": {"id": 95, "path": "/usr/include/python3.8/longobject.h", "content": "#ifndef Py_LONGOBJECT_H\n#define Py_LONGOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Long (arbitrary precision) integer object interface */\n\ntypedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */\n\nPyAPI_DATA(PyTypeObject) PyLong_Type;\n\n#define PyLong_Check(op) \\\n        PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)\n#define PyLong_CheckExact(op) (Py_TYPE(op) == &PyLong_Type)\n\nPyAPI_FUNC(PyObject *) PyLong_FromLong(long);\nPyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);\nPyAPI_FUNC(PyObject *) PyLong_FromSize_t(size_t);\nPyAPI_FUNC(PyObject *) PyLong_FromSsize_t(Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyLong_FromDouble(double);\nPyAPI_FUNC(long) PyLong_AsLong(PyObject *);\nPyAPI_FUNC(long) PyLong_AsLongAndOverflow(PyObject *, int *);\nPyAPI_FUNC(Py_ssize_t) PyLong_AsSsize_t(PyObject *);\nPyAPI_FUNC(size_t) PyLong_AsSize_t(PyObject *);\nPyAPI_FUNC(unsigned long) PyLong_AsUnsignedLong(PyObject *);\nPyAPI_FUNC(unsigned long) PyLong_AsUnsignedLongMask(PyObject *);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyLong_AsInt(PyObject *);\n#endif\nPyAPI_FUNC(PyObject *) PyLong_GetInfo(void);\n\n/* It may be useful in the future. I've added it in the PyInt -> PyLong\n   cleanup to keep the extra information. [CH] */\n#define PyLong_AS_LONG(op) PyLong_AsLong(op)\n\n/* Issue #1983: pid_t can be longer than a C long on some systems */\n#if !defined(SIZEOF_PID_T) || SIZEOF_PID_T == SIZEOF_INT\n#define _Py_PARSE_PID \"i\"\n#define PyLong_FromPid PyLong_FromLong\n#define PyLong_AsPid PyLong_AsLong\n#elif SIZEOF_PID_T == SIZEOF_LONG\n#define _Py_PARSE_PID \"l\"\n#define PyLong_FromPid PyLong_FromLong\n#define PyLong_AsPid PyLong_AsLong\n#elif defined(SIZEOF_LONG_LONG) && SIZEOF_PID_T == SIZEOF_LONG_LONG\n#define _Py_PARSE_PID \"L\"\n#define PyLong_FromPid PyLong_FromLongLong\n#define PyLong_AsPid PyLong_AsLongLong\n#else\n#error \"sizeof(pid_t) is neither sizeof(int), sizeof(long) or sizeof(long long)\"\n#endif /* SIZEOF_PID_T */\n\n#if SIZEOF_VOID_P == SIZEOF_INT\n#  define _Py_PARSE_INTPTR \"i\"\n#  define _Py_PARSE_UINTPTR \"I\"\n#elif SIZEOF_VOID_P == SIZEOF_LONG\n#  define _Py_PARSE_INTPTR \"l\"\n#  define _Py_PARSE_UINTPTR \"k\"\n#elif defined(SIZEOF_LONG_LONG) && SIZEOF_VOID_P == SIZEOF_LONG_LONG\n#  define _Py_PARSE_INTPTR \"L\"\n#  define _Py_PARSE_UINTPTR \"K\"\n#else\n#  error \"void* different in size from int, long and long long\"\n#endif /* SIZEOF_VOID_P */\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyLong_UnsignedShort_Converter(PyObject *, void *);\nPyAPI_FUNC(int) _PyLong_UnsignedInt_Converter(PyObject *, void *);\nPyAPI_FUNC(int) _PyLong_UnsignedLong_Converter(PyObject *, void *);\nPyAPI_FUNC(int) _PyLong_UnsignedLongLong_Converter(PyObject *, void *);\nPyAPI_FUNC(int) _PyLong_Size_t_Converter(PyObject *, void *);\n#endif\n\n/* Used by Python/mystrtoul.c, _PyBytes_FromHex(),\n   _PyBytes_DecodeEscapeRecode(), etc. */\n#ifndef Py_LIMITED_API\nPyAPI_DATA(unsigned char) _PyLong_DigitValue[256];\n#endif\n\n/* _PyLong_Frexp returns a double x and an exponent e such that the\n   true value is approximately equal to x * 2**e.  e is >= 0.  x is\n   0.0 if and only if the input is 0 (in which case, e and x are both\n   zeroes); otherwise, 0.5 <= abs(x) < 1.0.  On overflow, which is\n   possible if the number of bits doesn't fit into a Py_ssize_t, sets\n   OverflowError and returns -1.0 for x, 0 for e. */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(double) _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e);\n#endif\n\nPyAPI_FUNC(double) PyLong_AsDouble(PyObject *);\nPyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);\nPyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);\n\nPyAPI_FUNC(PyObject *) PyLong_FromLongLong(long long);\nPyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned long long);\nPyAPI_FUNC(long long) PyLong_AsLongLong(PyObject *);\nPyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLong(PyObject *);\nPyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLongMask(PyObject *);\nPyAPI_FUNC(long long) PyLong_AsLongLongAndOverflow(PyObject *, int *);\n\nPyAPI_FUNC(PyObject *) PyLong_FromString(const char *, char **, int);\n#ifndef Py_LIMITED_API\nPy_DEPRECATED(3.3)\nPyAPI_FUNC(PyObject *) PyLong_FromUnicode(Py_UNICODE*, Py_ssize_t, int);\nPyAPI_FUNC(PyObject *) PyLong_FromUnicodeObject(PyObject *u, int base);\nPyAPI_FUNC(PyObject *) _PyLong_FromBytes(const char *, Py_ssize_t, int);\n#endif\n\n#ifndef Py_LIMITED_API\n/* _PyLong_Sign.  Return 0 if v is 0, -1 if v < 0, +1 if v > 0.\n   v must not be NULL, and must be a normalized long.\n   There are no error cases.\n*/\nPyAPI_FUNC(int) _PyLong_Sign(PyObject *v);\n\n\n/* _PyLong_NumBits.  Return the number of bits needed to represent the\n   absolute value of a long.  For example, this returns 1 for 1 and -1, 2\n   for 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.\n   v must not be NULL, and must be a normalized long.\n   (size_t)-1 is returned and OverflowError set if the true result doesn't\n   fit in a size_t.\n*/\nPyAPI_FUNC(size_t) _PyLong_NumBits(PyObject *v);\n\n/* _PyLong_DivmodNear.  Given integers a and b, compute the nearest\n   integer q to the exact quotient a / b, rounding to the nearest even integer\n   in the case of a tie.  Return (q, r), where r = a - q*b.  The remainder r\n   will satisfy abs(r) <= abs(b)/2, with equality possible only if q is\n   even.\n*/\nPyAPI_FUNC(PyObject *) _PyLong_DivmodNear(PyObject *, PyObject *);\n\n/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in\n   base 256, and return a Python int with the same numeric value.\n   If n is 0, the integer is 0.  Else:\n   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;\n   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the\n   LSB.\n   If is_signed is 0/false, view the bytes as a non-negative integer.\n   If is_signed is 1/true, view the bytes as a 2's-complement integer,\n   non-negative if bit 0x80 of the MSB is clear, negative if set.\n   Error returns:\n   + Return NULL with the appropriate exception set if there's not\n     enough memory to create the Python int.\n*/\nPyAPI_FUNC(PyObject *) _PyLong_FromByteArray(\n    const unsigned char* bytes, size_t n,\n    int little_endian, int is_signed);\n\n/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long\n   v to a base-256 integer, stored in array bytes.  Normally return 0,\n   return -1 on error.\n   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at\n   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and\n   the LSB at bytes[n-1].\n   If is_signed is 0/false, it's an error if v < 0; else (v >= 0) n bytes\n   are filled and there's nothing special about bit 0x80 of the MSB.\n   If is_signed is 1/true, bytes is filled with the 2's-complement\n   representation of v's value.  Bit 0x80 of the MSB is the sign bit.\n   Error returns (-1):\n   + is_signed is 0 and v < 0.  TypeError is set in this case, and bytes\n     isn't altered.\n   + n isn't big enough to hold the full mathematical value of v.  For\n     example, if is_signed is 0 and there are more digits in the v than\n     fit in n; or if is_signed is 1, v < 0, and n is just 1 bit shy of\n     being large enough to hold a sign bit.  OverflowError is set in this\n     case, but bytes holds the least-significant n bytes of the true value.\n*/\nPyAPI_FUNC(int) _PyLong_AsByteArray(PyLongObject* v,\n    unsigned char* bytes, size_t n,\n    int little_endian, int is_signed);\n\n/* _PyLong_FromNbInt: Convert the given object to a PyLongObject\n   using the nb_int slot, if available.  Raise TypeError if either the\n   nb_int slot is not available or the result of the call to nb_int\n   returns something not of type int.\n*/\nPyAPI_FUNC(PyObject *) _PyLong_FromNbInt(PyObject *);\n\n/* Convert the given object to a PyLongObject using the nb_index or\n   nb_int slots, if available (the latter is deprecated).\n   Raise TypeError if either nb_index and nb_int slots are not\n   available or the result of the call to nb_index or nb_int\n   returns something not of type int.\n   Should be replaced with PyNumber_Index after the end of the\n   deprecation period.\n*/\nPyAPI_FUNC(PyObject *) _PyLong_FromNbIndexOrNbInt(PyObject *);\n\n/* _PyLong_Format: Convert the long to a string object with given base,\n   appending a base prefix of 0[box] if base is 2, 8 or 16. */\nPyAPI_FUNC(PyObject *) _PyLong_Format(PyObject *obj, int base);\n\nPyAPI_FUNC(int) _PyLong_FormatWriter(\n    _PyUnicodeWriter *writer,\n    PyObject *obj,\n    int base,\n    int alternate);\n\nPyAPI_FUNC(char*) _PyLong_FormatBytesWriter(\n    _PyBytesWriter *writer,\n    char *str,\n    PyObject *obj,\n    int base,\n    int alternate);\n\n/* Format the object based on the format_spec, as defined in PEP 3101\n   (Advanced String Formatting). */\nPyAPI_FUNC(int) _PyLong_FormatAdvancedWriter(\n    _PyUnicodeWriter *writer,\n    PyObject *obj,\n    PyObject *format_spec,\n    Py_ssize_t start,\n    Py_ssize_t end);\n#endif /* Py_LIMITED_API */\n\n/* These aren't really part of the int object, but they're handy. The\n   functions are in Python/mystrtoul.c.\n */\nPyAPI_FUNC(unsigned long) PyOS_strtoul(const char *, char **, int);\nPyAPI_FUNC(long) PyOS_strtol(const char *, char **, int);\n\n#ifndef Py_LIMITED_API\n/* For use by the gcd function in mathmodule.c */\nPyAPI_FUNC(PyObject *) _PyLong_GCD(PyObject *, PyObject *);\n#endif /* !Py_LIMITED_API */\n\n#ifndef Py_LIMITED_API\nPyAPI_DATA(PyObject *) _PyLong_Zero;\nPyAPI_DATA(PyObject *) _PyLong_One;\n\nPyAPI_FUNC(PyObject *) _PyLong_Rshift(PyObject *, size_t);\nPyAPI_FUNC(PyObject *) _PyLong_Lshift(PyObject *, size_t);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_LONGOBJECT_H */\n"}, "96": {"id": 96, "path": "/usr/include/python3.8/memoryobject.h", "content": "/* Memory view object. In Python this is available as \"memoryview\". */\n\n#ifndef Py_MEMORYOBJECT_H\n#define Py_MEMORYOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\nPyAPI_DATA(PyTypeObject) _PyManagedBuffer_Type;\n#endif\nPyAPI_DATA(PyTypeObject) PyMemoryView_Type;\n\n#define PyMemoryView_Check(op) (Py_TYPE(op) == &PyMemoryView_Type)\n\n#ifndef Py_LIMITED_API\n/* Get a pointer to the memoryview's private copy of the exporter's buffer. */\n#define PyMemoryView_GET_BUFFER(op) (&((PyMemoryViewObject *)(op))->view)\n/* Get a pointer to the exporting object (this may be NULL!). */\n#define PyMemoryView_GET_BASE(op) (((PyMemoryViewObject *)(op))->view.obj)\n#endif\n\nPyAPI_FUNC(PyObject *) PyMemoryView_FromObject(PyObject *base);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject *) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,\n                                               int flags);\n#endif\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) PyMemoryView_FromBuffer(Py_buffer *info);\n#endif\nPyAPI_FUNC(PyObject *) PyMemoryView_GetContiguous(PyObject *base,\n                                                  int buffertype,\n                                                  char order);\n\n\n/* The structs are declared here so that macros can work, but they shouldn't\n   be considered public. Don't access their fields directly, use the macros\n   and functions instead! */\n#ifndef Py_LIMITED_API\n#define _Py_MANAGED_BUFFER_RELEASED    0x001  /* access to exporter blocked */\n#define _Py_MANAGED_BUFFER_FREE_FORMAT 0x002  /* free format */\ntypedef struct {\n    PyObject_HEAD\n    int flags;          /* state flags */\n    Py_ssize_t exports; /* number of direct memoryview exports */\n    Py_buffer master; /* snapshot buffer obtained from the original exporter */\n} _PyManagedBufferObject;\n\n\n/* memoryview state flags */\n#define _Py_MEMORYVIEW_RELEASED    0x001  /* access to master buffer blocked */\n#define _Py_MEMORYVIEW_C           0x002  /* C-contiguous layout */\n#define _Py_MEMORYVIEW_FORTRAN     0x004  /* Fortran contiguous layout */\n#define _Py_MEMORYVIEW_SCALAR      0x008  /* scalar: ndim = 0 */\n#define _Py_MEMORYVIEW_PIL         0x010  /* PIL-style layout */\n\ntypedef struct {\n    PyObject_VAR_HEAD\n    _PyManagedBufferObject *mbuf; /* managed buffer */\n    Py_hash_t hash;               /* hash value for read-only views */\n    int flags;                    /* state flags */\n    Py_ssize_t exports;           /* number of buffer re-exports */\n    Py_buffer view;               /* private copy of the exporter's view */\n    PyObject *weakreflist;\n    Py_ssize_t ob_array[1];       /* shape, strides, suboffsets */\n} PyMemoryViewObject;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_MEMORYOBJECT_H */\n"}, "97": {"id": 97, "path": "/usr/include/python3.8/methodobject.h", "content": "\n/* Method object interface */\n\n#ifndef Py_METHODOBJECT_H\n#define Py_METHODOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* This is about the type 'builtin_function_or_method',\n   not Python methods in user-defined classes.  See classobject.h\n   for the latter. */\n\nPyAPI_DATA(PyTypeObject) PyCFunction_Type;\n\n#define PyCFunction_Check(op) (Py_TYPE(op) == &PyCFunction_Type)\n\ntypedef PyObject *(*PyCFunction)(PyObject *, PyObject *);\ntypedef PyObject *(*_PyCFunctionFast) (PyObject *, PyObject *const *, Py_ssize_t);\ntypedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *,\n                                             PyObject *);\ntypedef PyObject *(*_PyCFunctionFastWithKeywords) (PyObject *,\n                                                   PyObject *const *, Py_ssize_t,\n                                                   PyObject *);\ntypedef PyObject *(*PyNoArgsFunction)(PyObject *);\n\nPyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);\nPyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);\nPyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);\n\n/* Macros for direct access to these values. Type checks are *not*\n   done, so use with care. */\n#ifndef Py_LIMITED_API\n#define PyCFunction_GET_FUNCTION(func) \\\n        (((PyCFunctionObject *)func) -> m_ml -> ml_meth)\n#define PyCFunction_GET_SELF(func) \\\n        (((PyCFunctionObject *)func) -> m_ml -> ml_flags & METH_STATIC ? \\\n         NULL : ((PyCFunctionObject *)func) -> m_self)\n#define PyCFunction_GET_FLAGS(func) \\\n        (((PyCFunctionObject *)func) -> m_ml -> ml_flags)\n#endif\nPyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyCFunction_FastCallDict(PyObject *func,\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    PyObject *kwargs);\n#endif\n\nstruct PyMethodDef {\n    const char  *ml_name;   /* The name of the built-in function/method */\n    PyCFunction ml_meth;    /* The C function that implements it */\n    int         ml_flags;   /* Combination of METH_xxx flags, which mostly\n                               describe the args expected by the C func */\n    const char  *ml_doc;    /* The __doc__ attribute, or NULL */\n};\ntypedef struct PyMethodDef PyMethodDef;\n\n#define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)\nPyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *,\n                                         PyObject *);\n\n/* Flag passed to newmethodobject */\n/* #define METH_OLDARGS  0x0000   -- unsupported now */\n#define METH_VARARGS  0x0001\n#define METH_KEYWORDS 0x0002\n/* METH_NOARGS and METH_O must not be combined with the flags above. */\n#define METH_NOARGS   0x0004\n#define METH_O        0x0008\n\n/* METH_CLASS and METH_STATIC are a little different; these control\n   the construction of methods for a class.  These cannot be used for\n   functions in modules. */\n#define METH_CLASS    0x0010\n#define METH_STATIC   0x0020\n\n/* METH_COEXIST allows a method to be entered even though a slot has\n   already filled the entry.  When defined, the flag allows a separate\n   method, \"__contains__\" for example, to coexist with a defined\n   slot like sq_contains. */\n\n#define METH_COEXIST   0x0040\n\n#ifndef Py_LIMITED_API\n#define METH_FASTCALL  0x0080\n#endif\n\n/* This bit is preserved for Stackless Python */\n#ifdef STACKLESS\n#define METH_STACKLESS 0x0100\n#else\n#define METH_STACKLESS 0x0000\n#endif\n\n#ifndef Py_LIMITED_API\ntypedef struct {\n    PyObject_HEAD\n    PyMethodDef *m_ml; /* Description of the C function to call */\n    PyObject    *m_self; /* Passed as 'self' arg to the C func, can be NULL */\n    PyObject    *m_module; /* The __module__ attribute, can be anything */\n    PyObject    *m_weakreflist; /* List of weak references */\n    vectorcallfunc vectorcall;\n} PyCFunctionObject;\n\nPyAPI_FUNC(PyObject *) _PyMethodDef_RawFastCallDict(\n    PyMethodDef *method,\n    PyObject *self,\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    PyObject *kwargs);\n\nPyAPI_FUNC(PyObject *) _PyMethodDef_RawFastCallKeywords(\n    PyMethodDef *method,\n    PyObject *self,\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    PyObject *kwnames);\n#endif\n\nPyAPI_FUNC(int) PyCFunction_ClearFreeList(void);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(void) _PyCFunction_DebugMallocStats(FILE *out);\nPyAPI_FUNC(void) _PyMethod_DebugMallocStats(FILE *out);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_METHODOBJECT_H */\n"}, "98": {"id": 98, "path": "/usr/include/python3.8/modsupport.h", "content": "\n#ifndef Py_MODSUPPORT_H\n#define Py_MODSUPPORT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Module support interface */\n\n#include <stdarg.h>\n\n/* If PY_SSIZE_T_CLEAN is defined, each functions treats #-specifier\n   to mean Py_ssize_t */\n#ifdef PY_SSIZE_T_CLEAN\n#define PyArg_Parse                     _PyArg_Parse_SizeT\n#define PyArg_ParseTuple                _PyArg_ParseTuple_SizeT\n#define PyArg_ParseTupleAndKeywords     _PyArg_ParseTupleAndKeywords_SizeT\n#define PyArg_VaParse                   _PyArg_VaParse_SizeT\n#define PyArg_VaParseTupleAndKeywords   _PyArg_VaParseTupleAndKeywords_SizeT\n#define Py_BuildValue                   _Py_BuildValue_SizeT\n#define Py_VaBuildValue                 _Py_VaBuildValue_SizeT\n#ifndef Py_LIMITED_API\n#define _Py_VaBuildStack                _Py_VaBuildStack_SizeT\n#endif\n#else\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _Py_VaBuildValue_SizeT(const char *, va_list);\nPyAPI_FUNC(PyObject **) _Py_VaBuildStack_SizeT(\n    PyObject **small_stack,\n    Py_ssize_t small_stack_len,\n    const char *format,\n    va_list va,\n    Py_ssize_t *p_nargs);\n#endif /* !Py_LIMITED_API */\n#endif\n\n/* Due to a glitch in 3.2, the _SizeT versions weren't exported from the DLL. */\n#if !defined(PY_SSIZE_T_CLEAN) || !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyArg_Parse(PyObject *, const char *, ...);\nPyAPI_FUNC(int) PyArg_ParseTuple(PyObject *, const char *, ...);\nPyAPI_FUNC(int) PyArg_ParseTupleAndKeywords(PyObject *, PyObject *,\n                                                  const char *, char **, ...);\nPyAPI_FUNC(int) PyArg_VaParse(PyObject *, const char *, va_list);\nPyAPI_FUNC(int) PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *,\n                                                  const char *, char **, va_list);\n#endif\nPyAPI_FUNC(int) PyArg_ValidateKeywordArguments(PyObject *);\nPyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);\nPyAPI_FUNC(PyObject *) Py_BuildValue(const char *, ...);\nPyAPI_FUNC(PyObject *) _Py_BuildValue_SizeT(const char *, ...);\n\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) _PyArg_UnpackStack(\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    const char *name,\n    Py_ssize_t min,\n    Py_ssize_t max,\n    ...);\n\nPyAPI_FUNC(int) _PyArg_NoKeywords(const char *funcname, PyObject *kwargs);\nPyAPI_FUNC(int) _PyArg_NoPositional(const char *funcname, PyObject *args);\n#define _PyArg_NoKeywords(funcname, kwargs) \\\n    ((kwargs) == NULL || _PyArg_NoKeywords((funcname), (kwargs)))\n#define _PyArg_NoPositional(funcname, args) \\\n    ((args) == NULL || _PyArg_NoPositional((funcname), (args)))\n\nPyAPI_FUNC(void) _PyArg_BadArgument(const char *, const char *, const char *, PyObject *);\nPyAPI_FUNC(int) _PyArg_CheckPositional(const char *, Py_ssize_t,\n                                       Py_ssize_t, Py_ssize_t);\n#define _PyArg_CheckPositional(funcname, nargs, min, max) \\\n    (((min) <= (nargs) && (nargs) <= (max)) \\\n     || _PyArg_CheckPositional((funcname), (nargs), (min), (max)))\n\n#endif\n\nPyAPI_FUNC(PyObject *) Py_VaBuildValue(const char *, va_list);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject **) _Py_VaBuildStack(\n    PyObject **small_stack,\n    Py_ssize_t small_stack_len,\n    const char *format,\n    va_list va,\n    Py_ssize_t *p_nargs);\n#endif\n\n#ifndef Py_LIMITED_API\ntypedef struct _PyArg_Parser {\n    const char *format;\n    const char * const *keywords;\n    const char *fname;\n    const char *custom_msg;\n    int pos;            /* number of positional-only arguments */\n    int min;            /* minimal number of arguments */\n    int max;            /* maximal number of positional arguments */\n    PyObject *kwtuple;  /* tuple of keyword parameter names */\n    struct _PyArg_Parser *next;\n} _PyArg_Parser;\n#ifdef PY_SSIZE_T_CLEAN\n#define _PyArg_ParseTupleAndKeywordsFast  _PyArg_ParseTupleAndKeywordsFast_SizeT\n#define _PyArg_ParseStack  _PyArg_ParseStack_SizeT\n#define _PyArg_ParseStackAndKeywords  _PyArg_ParseStackAndKeywords_SizeT\n#define _PyArg_VaParseTupleAndKeywordsFast  _PyArg_VaParseTupleAndKeywordsFast_SizeT\n#endif\nPyAPI_FUNC(int) _PyArg_ParseTupleAndKeywordsFast(PyObject *, PyObject *,\n                                                 struct _PyArg_Parser *, ...);\nPyAPI_FUNC(int) _PyArg_ParseStack(\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    const char *format,\n    ...);\nPyAPI_FUNC(int) _PyArg_ParseStackAndKeywords(\n    PyObject *const *args,\n    Py_ssize_t nargs,\n    PyObject *kwnames,\n    struct _PyArg_Parser *,\n    ...);\nPyAPI_FUNC(int) _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *,\n                                                   struct _PyArg_Parser *, va_list);\nPyAPI_FUNC(PyObject * const *) _PyArg_UnpackKeywords(\n        PyObject *const *args, Py_ssize_t nargs,\n        PyObject *kwargs, PyObject *kwnames,\n        struct _PyArg_Parser *parser,\n        int minpos, int maxpos, int minkw,\n        PyObject **buf);\n#define _PyArg_UnpackKeywords(args, nargs, kwargs, kwnames, parser, minpos, maxpos, minkw, buf) \\\n    (((minkw) == 0 && (kwargs) == NULL && (kwnames) == NULL && \\\n      (minpos) <= (nargs) && (nargs) <= (maxpos) && args != NULL) ? (args) : \\\n     _PyArg_UnpackKeywords((args), (nargs), (kwargs), (kwnames), (parser), \\\n                           (minpos), (maxpos), (minkw), (buf)))\n\nvoid _PyArg_Fini(void);\n#endif   /* Py_LIMITED_API */\n\nPyAPI_FUNC(int) PyModule_AddObject(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyModule_AddIntConstant(PyObject *, const char *, long);\nPyAPI_FUNC(int) PyModule_AddStringConstant(PyObject *, const char *, const char *);\n#define PyModule_AddIntMacro(m, c) PyModule_AddIntConstant(m, #c, c)\n#define PyModule_AddStringMacro(m, c) PyModule_AddStringConstant(m, #c, c)\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* New in 3.5 */\nPyAPI_FUNC(int) PyModule_SetDocString(PyObject *, const char *);\nPyAPI_FUNC(int) PyModule_AddFunctions(PyObject *, PyMethodDef *);\nPyAPI_FUNC(int) PyModule_ExecDef(PyObject *module, PyModuleDef *def);\n#endif\n\n#define Py_CLEANUP_SUPPORTED 0x20000\n\n#define PYTHON_API_VERSION 1013\n#define PYTHON_API_STRING \"1013\"\n/* The API version is maintained (independently from the Python version)\n   so we can detect mismatches between the interpreter and dynamically\n   loaded modules.  These are diagnosed by an error message but\n   the module is still loaded (because the mismatch can only be tested\n   after loading the module).  The error message is intended to\n   explain the core dump a few seconds later.\n\n   The symbol PYTHON_API_STRING defines the same value as a string\n   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***\n\n   Please add a line or two to the top of this log for each API\n   version change:\n\n   22-Feb-2006  MvL     1013    PEP 353 - long indices for sequence lengths\n\n   19-Aug-2002  GvR     1012    Changes to string object struct for\n                                interning changes, saving 3 bytes.\n\n   17-Jul-2001  GvR     1011    Descr-branch, just to be on the safe side\n\n   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and\n                                PyFrame_New(); Python 2.1a2\n\n   14-Mar-2000  GvR     1009    Unicode API added\n\n   3-Jan-1999   GvR     1007    Decided to change back!  (Don't reuse 1008!)\n\n   3-Dec-1998   GvR     1008    Python 1.5.2b1\n\n   18-Jan-1997  GvR     1007    string interning and other speedups\n\n   11-Oct-1996  GvR     renamed Py_Ellipses to Py_Ellipsis :-(\n\n   30-Jul-1996  GvR     Slice and ellipses syntax added\n\n   23-Jul-1996  GvR     For 1.4 -- better safe than sorry this time :-)\n\n   7-Nov-1995   GvR     Keyword arguments (should've been done at 1.3 :-( )\n\n   10-Jan-1995  GvR     Renamed globals to new naming scheme\n\n   9-Jan-1995   GvR     Initial version (incompatible with older API)\n*/\n\n/* The PYTHON_ABI_VERSION is introduced in PEP 384. For the lifetime of\n   Python 3, it will stay at the value of 3; changes to the limited API\n   must be performed in a strictly backwards-compatible manner. */\n#define PYTHON_ABI_VERSION 3\n#define PYTHON_ABI_STRING \"3\"\n\n#ifdef Py_TRACE_REFS\n /* When we are tracing reference counts, rename module creation functions so\n    modules compiled with incompatible settings will generate a\n    link-time error. */\n #define PyModule_Create2 PyModule_Create2TraceRefs\n #define PyModule_FromDefAndSpec2 PyModule_FromDefAndSpec2TraceRefs\n#endif\n\nPyAPI_FUNC(PyObject *) PyModule_Create2(struct PyModuleDef*,\n                                     int apiver);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PyModule_CreateInitialized(struct PyModuleDef*,\n                                                   int apiver);\n#endif\n\n#ifdef Py_LIMITED_API\n#define PyModule_Create(module) \\\n        PyModule_Create2(module, PYTHON_ABI_VERSION)\n#else\n#define PyModule_Create(module) \\\n        PyModule_Create2(module, PYTHON_API_VERSION)\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* New in 3.5 */\nPyAPI_FUNC(PyObject *) PyModule_FromDefAndSpec2(PyModuleDef *def,\n                                                PyObject *spec,\n                                                int module_api_version);\n\n#ifdef Py_LIMITED_API\n#define PyModule_FromDefAndSpec(module, spec) \\\n    PyModule_FromDefAndSpec2(module, spec, PYTHON_ABI_VERSION)\n#else\n#define PyModule_FromDefAndSpec(module, spec) \\\n    PyModule_FromDefAndSpec2(module, spec, PYTHON_API_VERSION)\n#endif /* Py_LIMITED_API */\n#endif /* New in 3.5 */\n\n#ifndef Py_LIMITED_API\nPyAPI_DATA(const char *) _Py_PackageContext;\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_MODSUPPORT_H */\n"}, "99": {"id": 99, "path": "/usr/include/python3.8/moduleobject.h", "content": "\n/* Module object interface */\n\n#ifndef Py_MODULEOBJECT_H\n#define Py_MODULEOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_DATA(PyTypeObject) PyModule_Type;\n\n#define PyModule_Check(op) PyObject_TypeCheck(op, &PyModule_Type)\n#define PyModule_CheckExact(op) (Py_TYPE(op) == &PyModule_Type)\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject *) PyModule_NewObject(\n    PyObject *name\n    );\n#endif\nPyAPI_FUNC(PyObject *) PyModule_New(\n    const char *name            /* UTF-8 encoded string */\n    );\nPyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject *) PyModule_GetNameObject(PyObject *);\n#endif\nPyAPI_FUNC(const char *) PyModule_GetName(PyObject *);\nPy_DEPRECATED(3.2) PyAPI_FUNC(const char *) PyModule_GetFilename(PyObject *);\nPyAPI_FUNC(PyObject *) PyModule_GetFilenameObject(PyObject *);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(void) _PyModule_Clear(PyObject *);\nPyAPI_FUNC(void) _PyModule_ClearDict(PyObject *);\nPyAPI_FUNC(int) _PyModuleSpec_IsInitializing(PyObject *);\n#endif\nPyAPI_FUNC(struct PyModuleDef*) PyModule_GetDef(PyObject*);\nPyAPI_FUNC(void*) PyModule_GetState(PyObject*);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* New in 3.5 */\nPyAPI_FUNC(PyObject *) PyModuleDef_Init(struct PyModuleDef*);\nPyAPI_DATA(PyTypeObject) PyModuleDef_Type;\n#endif\n\ntypedef struct PyModuleDef_Base {\n  PyObject_HEAD\n  PyObject* (*m_init)(void);\n  Py_ssize_t m_index;\n  PyObject* m_copy;\n} PyModuleDef_Base;\n\n#define PyModuleDef_HEAD_INIT { \\\n    PyObject_HEAD_INIT(NULL)    \\\n    NULL, /* m_init */          \\\n    0,    /* m_index */         \\\n    NULL, /* m_copy */          \\\n  }\n\nstruct PyModuleDef_Slot;\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* New in 3.5 */\ntypedef struct PyModuleDef_Slot{\n    int slot;\n    void *value;\n} PyModuleDef_Slot;\n\n#define Py_mod_create 1\n#define Py_mod_exec 2\n\n#ifndef Py_LIMITED_API\n#define _Py_mod_LAST_SLOT 2\n#endif\n\n#endif /* New in 3.5 */\n\ntypedef struct PyModuleDef{\n  PyModuleDef_Base m_base;\n  const char* m_name;\n  const char* m_doc;\n  Py_ssize_t m_size;\n  PyMethodDef *m_methods;\n  struct PyModuleDef_Slot* m_slots;\n  traverseproc m_traverse;\n  inquiry m_clear;\n  freefunc m_free;\n} PyModuleDef;\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_MODULEOBJECT_H */\n"}, "100": {"id": 100, "path": "/usr/include/python3.8/namespaceobject.h", "content": "\n/* simple namespace object interface */\n\n#ifndef NAMESPACEOBJECT_H\n#define NAMESPACEOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\nPyAPI_DATA(PyTypeObject) _PyNamespace_Type;\n\nPyAPI_FUNC(PyObject *) _PyNamespace_New(PyObject *kwds);\n#endif /* !Py_LIMITED_API */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !NAMESPACEOBJECT_H */\n"}, "101": {"id": 101, "path": "/usr/include/python3.8/object.h", "content": "#ifndef Py_OBJECT_H\n#define Py_OBJECT_H\n\n#include \"pymem.h\"   /* _Py_tracemalloc_config */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Object and type object interface */\n\n/*\nObjects are structures allocated on the heap.  Special rules apply to\nthe use of objects to ensure they are properly garbage-collected.\nObjects are never allocated statically or on the stack; they must be\naccessed through special macros and functions only.  (Type objects are\nexceptions to the first rule; the standard types are represented by\nstatically initialized type objects, although work on type/class unification\nfor Python 2.2 made it possible to have heap-allocated type objects too).\n\nAn object has a 'reference count' that is increased or decreased when a\npointer to the object is copied or deleted; when the reference count\nreaches zero there are no references to the object left and it can be\nremoved from the heap.\n\nAn object has a 'type' that determines what it represents and what kind\nof data it contains.  An object's type is fixed when it is created.\nTypes themselves are represented as objects; an object contains a\npointer to the corresponding type object.  The type itself has a type\npointer pointing to the object representing the type 'type', which\ncontains a pointer to itself!.\n\nObjects do not float around in memory; once allocated an object keeps\nthe same size and address.  Objects that must hold variable-size data\ncan contain pointers to variable-size parts of the object.  Not all\nobjects of the same type have the same size; but the size cannot change\nafter allocation.  (These restrictions are made so a reference to an\nobject can be simply a pointer -- moving an object would require\nupdating all the pointers, and changing an object's size would require\nmoving it if there was another object right next to it.)\n\nObjects are always accessed through pointers of the type 'PyObject *'.\nThe type 'PyObject' is a structure that only contains the reference count\nand the type pointer.  The actual memory allocated for an object\ncontains other data that can only be accessed after casting the pointer\nto a pointer to a longer structure type.  This longer type must start\nwith the reference count and type fields; the macro PyObject_HEAD should be\nused for this (to accommodate for future changes).  The implementation\nof a particular object type can cast the object pointer to the proper\ntype and back.\n\nA standard interface exists for objects that contain an array of items\nwhose size is determined when the object is allocated.\n*/\n\n/* Py_DEBUG implies Py_REF_DEBUG. */\n#if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)\n#define Py_REF_DEBUG\n#endif\n\n#if defined(Py_LIMITED_API) && defined(Py_REF_DEBUG)\n#error Py_LIMITED_API is incompatible with Py_DEBUG, Py_TRACE_REFS, and Py_REF_DEBUG\n#endif\n\n\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    struct _object *_ob_next;           \\\n    struct _object *_ob_prev;\n\n#define _PyObject_EXTRA_INIT 0, 0,\n\n#else\n#define _PyObject_HEAD_EXTRA\n#define _PyObject_EXTRA_INIT\n#endif\n\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD                   PyObject ob_base;\n\n#define PyObject_HEAD_INIT(type)        \\\n    { _PyObject_EXTRA_INIT              \\\n    1, type },\n\n#define PyVarObject_HEAD_INIT(type, size)       \\\n    { PyObject_HEAD_INIT(type) size },\n\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size\n * container objects.  These end with a declaration of an array with 1\n * element, but enough space is malloc'ed so that the array actually\n * has room for ob_size elements.  Note that ob_size is an element count,\n * not necessarily a byte count.\n */\n#define PyObject_VAR_HEAD      PyVarObject ob_base;\n#define Py_INVALID_SIZE (Py_ssize_t)-1\n\n/* Nothing is actually declared to be a PyObject, but every pointer to\n * a Python object can be cast to a PyObject*.  This is inheritance built\n * by hand.  Similarly every pointer to a variable-size Python object can,\n * in addition, be cast to PyVarObject*.\n */\ntypedef struct _object {\n    _PyObject_HEAD_EXTRA\n    Py_ssize_t ob_refcnt;\n    struct _typeobject *ob_type;\n} PyObject;\n\n/* Cast argument to PyObject* type. */\n#define _PyObject_CAST(op) ((PyObject*)(op))\n\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n\n/* Cast argument to PyVarObject* type. */\n#define _PyVarObject_CAST(op) ((PyVarObject*)(op))\n\n#define Py_REFCNT(ob)           (_PyObject_CAST(ob)->ob_refcnt)\n#define Py_TYPE(ob)             (_PyObject_CAST(ob)->ob_type)\n#define Py_SIZE(ob)             (_PyVarObject_CAST(ob)->ob_size)\n\n/*\nType objects contain a string containing the type name (to help somewhat\nin debugging), the allocation parameters (see PyObject_New() and\nPyObject_NewVar()),\nand methods for accessing objects of the type.  Methods are optional, a\nnil pointer meaning that particular kind of access is not available for\nthis type.  The Py_DECREF() macro uses the tp_dealloc method without\nchecking for a nil pointer; it should always be implemented except if\nthe implementation can guarantee that the reference count will never\nreach zero (e.g., for statically allocated type objects).\n\nNB: the methods for certain type groups are now contained in separate\nmethod blocks.\n*/\n\ntypedef PyObject * (*unaryfunc)(PyObject *);\ntypedef PyObject * (*binaryfunc)(PyObject *, PyObject *);\ntypedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);\ntypedef int (*inquiry)(PyObject *);\ntypedef Py_ssize_t (*lenfunc)(PyObject *);\ntypedef PyObject *(*ssizeargfunc)(PyObject *, Py_ssize_t);\ntypedef PyObject *(*ssizessizeargfunc)(PyObject *, Py_ssize_t, Py_ssize_t);\ntypedef int(*ssizeobjargproc)(PyObject *, Py_ssize_t, PyObject *);\ntypedef int(*ssizessizeobjargproc)(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);\ntypedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);\n\ntypedef int (*objobjproc)(PyObject *, PyObject *);\ntypedef int (*visitproc)(PyObject *, void *);\ntypedef int (*traverseproc)(PyObject *, visitproc, void *);\n\n\ntypedef void (*freefunc)(void *);\ntypedef void (*destructor)(PyObject *);\ntypedef PyObject *(*getattrfunc)(PyObject *, char *);\ntypedef PyObject *(*getattrofunc)(PyObject *, PyObject *);\ntypedef int (*setattrfunc)(PyObject *, char *, PyObject *);\ntypedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*reprfunc)(PyObject *);\ntypedef Py_hash_t (*hashfunc)(PyObject *);\ntypedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);\ntypedef PyObject *(*getiterfunc) (PyObject *);\ntypedef PyObject *(*iternextfunc) (PyObject *);\ntypedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);\ntypedef int (*initproc)(PyObject *, PyObject *, PyObject *);\ntypedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);\ntypedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);\n\n#ifdef Py_LIMITED_API\n/* In Py_LIMITED_API, PyTypeObject is an opaque structure. */\ntypedef struct _typeobject PyTypeObject;\n#else\n/* PyTypeObject is defined in cpython/object.h */\n#endif\n\ntypedef struct{\n    int slot;    /* slot id, see below */\n    void *pfunc; /* function pointer */\n} PyType_Slot;\n\ntypedef struct{\n    const char* name;\n    int basicsize;\n    int itemsize;\n    unsigned int flags;\n    PyType_Slot *slots; /* terminated by slot==0. */\n} PyType_Spec;\n\nPyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(void*) PyType_GetSlot(struct _typeobject*, int);\n#endif\n\n/* Generic type check */\nPyAPI_FUNC(int) PyType_IsSubtype(struct _typeobject *, struct _typeobject *);\n#define PyObject_TypeCheck(ob, tp) \\\n    (Py_TYPE(ob) == (tp) || PyType_IsSubtype(Py_TYPE(ob), (tp)))\n\nPyAPI_DATA(struct _typeobject) PyType_Type; /* built-in 'type' */\nPyAPI_DATA(struct _typeobject) PyBaseObject_Type; /* built-in 'object' */\nPyAPI_DATA(struct _typeobject) PySuper_Type; /* built-in 'super' */\n\nPyAPI_FUNC(unsigned long) PyType_GetFlags(struct _typeobject*);\n\n#define PyType_Check(op) \\\n    PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)\n#define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)\n\nPyAPI_FUNC(int) PyType_Ready(struct _typeobject *);\nPyAPI_FUNC(PyObject *) PyType_GenericAlloc(struct _typeobject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyType_GenericNew(struct _typeobject *,\n                                               PyObject *, PyObject *);\nPyAPI_FUNC(unsigned int) PyType_ClearCache(void);\nPyAPI_FUNC(void) PyType_Modified(struct _typeobject *);\n\n/* Generic operations on objects */\nPyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);\nPyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);\nPyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);\nPyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);\nPyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);\nPyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,\n                                              PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);\n#endif\nPyAPI_FUNC(Py_hash_t) PyObject_Hash(PyObject *);\nPyAPI_FUNC(Py_hash_t) PyObject_HashNotImplemented(PyObject *);\nPyAPI_FUNC(int) PyObject_IsTrue(PyObject *);\nPyAPI_FUNC(int) PyObject_Not(PyObject *);\nPyAPI_FUNC(int) PyCallable_Check(PyObject *);\nPyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);\n\n/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a\n   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),\n   returning the names of the current locals.  In this case, if there are\n   no current locals, NULL is returned, and PyErr_Occurred() is false.\n*/\nPyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);\n\n\n/* Helpers for printing recursive container types */\nPyAPI_FUNC(int) Py_ReprEnter(PyObject *);\nPyAPI_FUNC(void) Py_ReprLeave(PyObject *);\n\n/* Flag bits for printing: */\n#define Py_PRINT_RAW    1       /* No string quotes etc. */\n\n/*\nType flags (tp_flags)\n\nThese flags are used to change expected features and behavior for a\nparticular type.\n\nArbitration of the flag bit positions will need to be coordinated among\nall extension writers who publicly release their extensions (this will\nbe fewer than you might expect!).\n\nMost flags were removed as of Python 3.0 to make room for new flags.  (Some\nflags are not for backwards compatibility but to indicate the presence of an\noptional feature; these flags remain of course.)\n\nType definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.\n\nCode can use PyType_HasFeature(type_ob, flag_value) to test whether the\ngiven type object has a specified feature.\n*/\n\n/* Set if the type object is dynamically allocated */\n#define Py_TPFLAGS_HEAPTYPE (1UL << 9)\n\n/* Set if the type allows subclassing */\n#define Py_TPFLAGS_BASETYPE (1UL << 10)\n\n/* Set if the type implements the vectorcall protocol (PEP 590) */\n#ifndef Py_LIMITED_API\n#define _Py_TPFLAGS_HAVE_VECTORCALL (1UL << 11)\n#endif\n\n/* Set if the type is 'ready' -- fully initialized */\n#define Py_TPFLAGS_READY (1UL << 12)\n\n/* Set while the type is being 'readied', to prevent recursive ready calls */\n#define Py_TPFLAGS_READYING (1UL << 13)\n\n/* Objects support garbage collection (see objimpl.h) */\n#define Py_TPFLAGS_HAVE_GC (1UL << 14)\n\n/* These two bits are preserved for Stackless Python, next after this is 17 */\n#ifdef STACKLESS\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL << 15)\n#else\n#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0\n#endif\n\n/* Objects behave like an unbound method */\n#define Py_TPFLAGS_METHOD_DESCRIPTOR (1UL << 17)\n\n/* Objects support type attribute cache */\n#define Py_TPFLAGS_HAVE_VERSION_TAG   (1UL << 18)\n#define Py_TPFLAGS_VALID_VERSION_TAG  (1UL << 19)\n\n/* Type is abstract and cannot be instantiated */\n#define Py_TPFLAGS_IS_ABSTRACT (1UL << 20)\n\n/* These flags are used to determine if a type is a subclass. */\n#define Py_TPFLAGS_LONG_SUBCLASS        (1UL << 24)\n#define Py_TPFLAGS_LIST_SUBCLASS        (1UL << 25)\n#define Py_TPFLAGS_TUPLE_SUBCLASS       (1UL << 26)\n#define Py_TPFLAGS_BYTES_SUBCLASS       (1UL << 27)\n#define Py_TPFLAGS_UNICODE_SUBCLASS     (1UL << 28)\n#define Py_TPFLAGS_DICT_SUBCLASS        (1UL << 29)\n#define Py_TPFLAGS_BASE_EXC_SUBCLASS    (1UL << 30)\n#define Py_TPFLAGS_TYPE_SUBCLASS        (1UL << 31)\n\n#define Py_TPFLAGS_DEFAULT  ( \\\n                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \\\n                 Py_TPFLAGS_HAVE_VERSION_TAG | \\\n                0)\n\n/* NOTE: The following flags reuse lower bits (removed as part of the\n * Python 3.0 transition). */\n\n/* The following flag is kept for compatibility.  Starting with 3.8,\n * binary compatibility of C extensions accross feature releases of\n * Python is not supported anymore, except when using the stable ABI.\n */\n\n/* Type structure has tp_finalize member (3.4) */\n#define Py_TPFLAGS_HAVE_FINALIZE (1UL << 0)\n\n#ifdef Py_LIMITED_API\n#  define PyType_HasFeature(t,f)  ((PyType_GetFlags(t) & (f)) != 0)\n#endif\n#define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)\n\n\n/*\nThe macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement\nreference counts.  Py_DECREF calls the object's deallocator function when\nthe refcount falls to 0; for\nobjects that don't contain references to other objects or heap memory\nthis can be the standard function free().  Both macros can be used\nwherever a void expression is allowed.  The argument must not be a\nNULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.\nThe macro _Py_NewReference(op) initialize reference counts to 1, and\nin special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional\nbookkeeping appropriate to the special build.\n\nWe assume that the reference count field can never overflow; this can\nbe proven when the size of the field is the same as the pointer size, so\nwe ignore the possibility.  Provided a C int is at least 32 bits (which\nis implicitly assumed in many parts of this code), that's enough for\nabout 2**31 references to an object.\n\nXXX The following became out of date in Python 2.2, but I'm not sure\nXXX what the full truth is now.  Certainly, heap-allocated type objects\nXXX can and should be deallocated.\nType objects should never be deallocated; the type pointer in an object\nis not considered to be a reference to the type object, to save\ncomplications in the deallocation function.  (This is actually a\ndecision that's up to the implementer of each new type so if you want,\nyou can count such references to the type object.)\n*/\n\n/* First define a pile of simple helper macros, one set per special\n * build symbol.  These either expand to the obvious things, or to\n * nothing at all when the special mode isn't in effect.  The main\n * macros can later be defined just once then, yet expand to different\n * things depending on which special build options are and aren't in effect.\n * Trust me <wink>:  while painful, this is 20x easier to understand than,\n * e.g, defining _Py_NewReference five different times in a maze of nested\n * #ifdefs (we used to do that -- it was impenetrable).\n */\n#ifdef Py_REF_DEBUG\nPyAPI_DATA(Py_ssize_t) _Py_RefTotal;\nPyAPI_FUNC(void) _Py_NegativeRefcount(const char *filename, int lineno,\n                                      PyObject *op);\nPyAPI_FUNC(Py_ssize_t) _Py_GetRefTotal(void);\n#define _Py_INC_REFTOTAL        _Py_RefTotal++\n#define _Py_DEC_REFTOTAL        _Py_RefTotal--\n\n/* Py_REF_DEBUG also controls the display of refcounts and memory block\n * allocations at the interactive prompt and at interpreter shutdown\n */\nPyAPI_FUNC(void) _PyDebug_PrintTotalRefs(void);\n#else\n#define _Py_INC_REFTOTAL\n#define _Py_DEC_REFTOTAL\n#endif /* Py_REF_DEBUG */\n\n#ifdef COUNT_ALLOCS\nPyAPI_FUNC(void) _Py_inc_count(struct _typeobject *);\nPyAPI_FUNC(void) _Py_dec_count(struct _typeobject *);\n#define _Py_INC_TPALLOCS(OP)    _Py_inc_count(Py_TYPE(OP))\n#define _Py_INC_TPFREES(OP)     _Py_dec_count(Py_TYPE(OP))\n#define _Py_DEC_TPFREES(OP)     Py_TYPE(OP)->tp_frees--\n#define _Py_COUNT_ALLOCS_COMMA  ,\n#else\n#define _Py_INC_TPALLOCS(OP)\n#define _Py_INC_TPFREES(OP)\n#define _Py_DEC_TPFREES(OP)\n#define _Py_COUNT_ALLOCS_COMMA\n#endif /* COUNT_ALLOCS */\n\n/* Update the Python traceback of an object. This function must be called\n   when a memory block is reused from a free list. */\nPyAPI_FUNC(int) _PyTraceMalloc_NewReference(PyObject *op);\n\n#ifdef Py_TRACE_REFS\n/* Py_TRACE_REFS is such major surgery that we call external routines. */\nPyAPI_FUNC(void) _Py_NewReference(PyObject *);\nPyAPI_FUNC(void) _Py_ForgetReference(PyObject *);\nPyAPI_FUNC(void) _Py_PrintReferences(FILE *);\nPyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);\nPyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);\n#else\n/* Without Py_TRACE_REFS, there's little enough to do that we expand code\n   inline. */\nstatic inline void _Py_NewReference(PyObject *op)\n{\n    if (_Py_tracemalloc_config.tracing) {\n        _PyTraceMalloc_NewReference(op);\n    }\n    _Py_INC_TPALLOCS(op);\n    _Py_INC_REFTOTAL;\n    Py_REFCNT(op) = 1;\n}\n\nstatic inline void _Py_ForgetReference(PyObject *op)\n{\n    (void)op; /* may be unused, shut up -Wunused-parameter */\n    _Py_INC_TPFREES(op);\n}\n#endif /* !Py_TRACE_REFS */\n\n\nPyAPI_FUNC(void) _Py_Dealloc(PyObject *);\n\nstatic inline void _Py_INCREF(PyObject *op)\n{\n    _Py_INC_REFTOTAL;\n    op->ob_refcnt++;\n}\n\n#define Py_INCREF(op) _Py_INCREF(_PyObject_CAST(op))\n\nstatic inline void _Py_DECREF(const char *filename, int lineno,\n                              PyObject *op)\n{\n    (void)filename; /* may be unused, shut up -Wunused-parameter */\n    (void)lineno; /* may be unused, shut up -Wunused-parameter */\n    _Py_DEC_REFTOTAL;\n    if (--op->ob_refcnt != 0) {\n#ifdef Py_REF_DEBUG\n        if (op->ob_refcnt < 0) {\n            _Py_NegativeRefcount(filename, lineno, op);\n        }\n#endif\n    }\n    else {\n        _Py_Dealloc(op);\n    }\n}\n\n#define Py_DECREF(op) _Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))\n\n\n/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear\n * and tp_dealloc implementations.\n *\n * Note that \"the obvious\" code can be deadly:\n *\n *     Py_XDECREF(op);\n *     op = NULL;\n *\n * Typically, `op` is something like self->containee, and `self` is done\n * using its `containee` member.  In the code sequence above, suppose\n * `containee` is non-NULL with a refcount of 1.  Its refcount falls to\n * 0 on the first line, which can trigger an arbitrary amount of code,\n * possibly including finalizers (like __del__ methods or weakref callbacks)\n * coded in Python, which in turn can release the GIL and allow other threads\n * to run, etc.  Such code may even invoke methods of `self` again, or cause\n * cyclic gc to trigger, but-- oops! --self->containee still points to the\n * object being torn down, and it may be in an insane state while being torn\n * down.  This has in fact been a rich historic source of miserable (rare &\n * hard-to-diagnose) segfaulting (and other) bugs.\n *\n * The safe way is:\n *\n *      Py_CLEAR(op);\n *\n * That arranges to set `op` to NULL _before_ decref'ing, so that any code\n * triggered as a side-effect of `op` getting torn down no longer believes\n * `op` points to a valid object.\n *\n * There are cases where it's safe to use the naive code, but they're brittle.\n * For example, if `op` points to a Python integer, you know that destroying\n * one of those can't cause problems -- but in part that relies on that\n * Python integers aren't currently weakly referencable.  Best practice is\n * to use Py_CLEAR() even if you can't think of a reason for why you need to.\n */\n#define Py_CLEAR(op)                            \\\n    do {                                        \\\n        PyObject *_py_tmp = _PyObject_CAST(op); \\\n        if (_py_tmp != NULL) {                  \\\n            (op) = NULL;                        \\\n            Py_DECREF(_py_tmp);                 \\\n        }                                       \\\n    } while (0)\n\n/* Function to use in case the object pointer can be NULL: */\nstatic inline void _Py_XINCREF(PyObject *op)\n{\n    if (op != NULL) {\n        Py_INCREF(op);\n    }\n}\n\n#define Py_XINCREF(op) _Py_XINCREF(_PyObject_CAST(op))\n\nstatic inline void _Py_XDECREF(PyObject *op)\n{\n    if (op != NULL) {\n        Py_DECREF(op);\n    }\n}\n\n#define Py_XDECREF(op) _Py_XDECREF(_PyObject_CAST(op))\n\n/*\nThese are provided as conveniences to Python runtime embedders, so that\nthey can have object code that is not dependent on Python compilation flags.\n*/\nPyAPI_FUNC(void) Py_IncRef(PyObject *);\nPyAPI_FUNC(void) Py_DecRef(PyObject *);\n\n/*\n_Py_NoneStruct is an object of undefined type which can be used in contexts\nwhere NULL (nil) is not suitable (since NULL often means 'error').\n\nDon't forget to apply Py_INCREF() when returning this value!!!\n*/\nPyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */\n#define Py_None (&_Py_NoneStruct)\n\n/* Macro for returning Py_None from a function */\n#define Py_RETURN_NONE return Py_INCREF(Py_None), Py_None\n\n/*\nPy_NotImplemented is a singleton used to signal that an operation is\nnot implemented for a given type combination.\n*/\nPyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */\n#define Py_NotImplemented (&_Py_NotImplementedStruct)\n\n/* Macro for returning Py_NotImplemented from a function */\n#define Py_RETURN_NOTIMPLEMENTED \\\n    return Py_INCREF(Py_NotImplemented), Py_NotImplemented\n\n/* Rich comparison opcodes */\n#define Py_LT 0\n#define Py_LE 1\n#define Py_EQ 2\n#define Py_NE 3\n#define Py_GT 4\n#define Py_GE 5\n\n/*\n * Macro for implementing rich comparisons\n *\n * Needs to be a macro because any C-comparable type can be used.\n */\n#define Py_RETURN_RICHCOMPARE(val1, val2, op)                               \\\n    do {                                                                    \\\n        switch (op) {                                                       \\\n        case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;   \\\n        case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;  \\\n        default:                                                            \\\n            Py_UNREACHABLE();                                               \\\n        }                                                                   \\\n    } while (0)\n\n\n/*\nMore conventions\n================\n\nArgument Checking\n-----------------\n\nFunctions that take objects as arguments normally don't check for nil\narguments, but they do check the type of the argument, and return an\nerror if the function doesn't apply to the type.\n\nFailure Modes\n-------------\n\nFunctions may fail for a variety of reasons, including running out of\nmemory.  This is communicated to the caller in two ways: an error string\nis set (see errors.h), and the function result differs: functions that\nnormally return a pointer return NULL for failure, functions returning\nan integer return -1 (which could be a legal return value too!), and\nother functions return 0 for success and -1 for failure.\nCallers should always check for errors before using the result.  If\nan error was set, the caller must either explicitly clear it, or pass\nthe error on to its caller.\n\nReference Counts\n----------------\n\nIt takes a while to get used to the proper usage of reference counts.\n\nFunctions that create an object set the reference count to 1; such new\nobjects must be stored somewhere or destroyed again with Py_DECREF().\nSome functions that 'store' objects, such as PyTuple_SetItem() and\nPyList_SetItem(),\ndon't increment the reference count of the object, since the most\nfrequent use is to store a fresh object.  Functions that 'retrieve'\nobjects, such as PyTuple_GetItem() and PyDict_GetItemString(), also\ndon't increment\nthe reference count, since most frequently the object is only looked at\nquickly.  Thus, to retrieve an object and store it again, the caller\nmust call Py_INCREF() explicitly.\n\nNOTE: functions that 'consume' a reference count, like\nPyList_SetItem(), consume the reference even if the object wasn't\nsuccessfully stored, to simplify error handling.\n\nIt seems attractive to make other functions that take an object as\nargument consume a reference count; however, this may quickly get\nconfusing (even the current practice is already confusing).  Consider\nit carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at\ntimes.\n*/\n\n\n/* Trashcan mechanism, thanks to Christian Tismer.\n\nWhen deallocating a container object, it's possible to trigger an unbounded\nchain of deallocations, as each Py_DECREF in turn drops the refcount on \"the\nnext\" object in the chain to 0.  This can easily lead to stack overflows,\nespecially in threads (which typically have less stack space to work with).\n\nA container object can avoid this by bracketing the body of its tp_dealloc\nfunction with a pair of macros:\n\nstatic void\nmytype_dealloc(mytype *p)\n{\n    ... declarations go here ...\n\n    PyObject_GC_UnTrack(p);        // must untrack first\n    Py_TRASHCAN_BEGIN(p, mytype_dealloc)\n    ... The body of the deallocator goes here, including all calls ...\n    ... to Py_DECREF on contained objects.                         ...\n    Py_TRASHCAN_END                // there should be no code after this\n}\n\nCAUTION:  Never return from the middle of the body!  If the body needs to\n\"get out early\", put a label immediately before the Py_TRASHCAN_END\ncall, and goto it.  Else the call-depth counter (see below) will stay\nabove 0 forever, and the trashcan will never get emptied.\n\nHow it works:  The BEGIN macro increments a call-depth counter.  So long\nas this counter is small, the body of the deallocator is run directly without\nfurther ado.  But if the counter gets large, it instead adds p to a list of\nobjects to be deallocated later, skips the body of the deallocator, and\nresumes execution after the END macro.  The tp_dealloc routine then returns\nwithout deallocating anything (and so unbounded call-stack depth is avoided).\n\nWhen the call stack finishes unwinding again, code generated by the END macro\nnotices this, and calls another routine to deallocate all the objects that\nmay have been added to the list of deferred deallocations.  In effect, a\nchain of N deallocations is broken into (N-1)/(PyTrash_UNWIND_LEVEL-1) pieces,\nwith the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.\n\nSince the tp_dealloc of a subclass typically calls the tp_dealloc of the base\nclass, we need to ensure that the trashcan is only triggered on the tp_dealloc\nof the actual class being deallocated. Otherwise we might end up with a\npartially-deallocated object. To check this, the tp_dealloc function must be\npassed as second argument to Py_TRASHCAN_BEGIN().\n*/\n\n/* The new thread-safe private API, invoked by the macros below. */\nPyAPI_FUNC(void) _PyTrash_thread_deposit_object(PyObject*);\nPyAPI_FUNC(void) _PyTrash_thread_destroy_chain(void);\n\n#define PyTrash_UNWIND_LEVEL 50\n\n#define Py_TRASHCAN_BEGIN_CONDITION(op, cond) \\\n    do { \\\n        PyThreadState *_tstate = NULL; \\\n        /* If \"cond\" is false, then _tstate remains NULL and the deallocator \\\n         * is run normally without involving the trashcan */ \\\n        if (cond) { \\\n            _tstate = PyThreadState_GET(); \\\n            if (_tstate->trash_delete_nesting >= PyTrash_UNWIND_LEVEL) { \\\n                /* Store the object (to be deallocated later) and jump past \\\n                 * Py_TRASHCAN_END, skipping the body of the deallocator */ \\\n                _PyTrash_thread_deposit_object(_PyObject_CAST(op)); \\\n                break; \\\n            } \\\n            ++_tstate->trash_delete_nesting; \\\n        }\n        /* The body of the deallocator is here. */\n#define Py_TRASHCAN_END \\\n        if (_tstate) { \\\n            --_tstate->trash_delete_nesting; \\\n            if (_tstate->trash_delete_later && _tstate->trash_delete_nesting <= 0) \\\n                _PyTrash_thread_destroy_chain(); \\\n        } \\\n    } while (0);\n\n#define Py_TRASHCAN_BEGIN(op, dealloc) Py_TRASHCAN_BEGIN_CONDITION(op, \\\n        Py_TYPE(op)->tp_dealloc == (destructor)(dealloc))\n\n/* For backwards compatibility, these macros enable the trashcan\n * unconditionally */\n#define Py_TRASHCAN_SAFE_BEGIN(op) Py_TRASHCAN_BEGIN_CONDITION(op, 1)\n#define Py_TRASHCAN_SAFE_END(op) Py_TRASHCAN_END\n\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJECT_H\n#  include  \"cpython/object.h\"\n#  undef Py_CPYTHON_OBJECT_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_OBJECT_H */\n"}, "102": {"id": 102, "path": "/usr/include/python3.8/objimpl.h", "content": "/* The PyObject_ memory family:  high-level object memory interfaces.\n   See pymem.h for the low-level PyMem_ family.\n*/\n\n#ifndef Py_OBJIMPL_H\n#define Py_OBJIMPL_H\n\n#include \"pymem.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* BEWARE:\n\n   Each interface exports both functions and macros.  Extension modules should\n   use the functions, to ensure binary compatibility across Python versions.\n   Because the Python implementation is free to change internal details, and\n   the macros may (or may not) expose details for speed, if you do use the\n   macros you must recompile your extensions with each Python release.\n\n   Never mix calls to PyObject_ memory functions with calls to the platform\n   malloc/realloc/ calloc/free, or with calls to PyMem_.\n*/\n\n/*\nFunctions and macros for modules that implement new object types.\n\n - PyObject_New(type, typeobj) allocates memory for a new object of the given\n   type, and initializes part of it.  'type' must be the C structure type used\n   to represent the object, and 'typeobj' the address of the corresponding\n   type object.  Reference count and type pointer are filled in; the rest of\n   the bytes of the object are *undefined*!  The resulting expression type is\n   'type *'.  The size of the object is determined by the tp_basicsize field\n   of the type object.\n\n - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size\n   object with room for n items.  In addition to the refcount and type pointer\n   fields, this also fills in the ob_size field.\n\n - PyObject_Del(op) releases the memory allocated for an object.  It does not\n   run a destructor -- it only frees the memory.  PyObject_Free is identical.\n\n - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't\n   allocate memory.  Instead of a 'type' parameter, they take a pointer to a\n   new object (allocated by an arbitrary allocator), and initialize its object\n   header fields.\n\nNote that objects created with PyObject_{New, NewVar} are allocated using the\nspecialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is\nenabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG\nis also #defined.\n\nIn case a specific form of memory management is needed (for example, if you\nmust use the platform malloc heap(s), or shared memory, or C++ local storage or\noperator new), you must first allocate the object with your custom allocator,\nthen pass its pointer to PyObject_{Init, InitVar} for filling in its Python-\nspecific fields:  reference count, type pointer, possibly others.  You should\nbe aware that Python has no control over these objects because they don't\ncooperate with the Python memory manager.  Such objects may not be eligible\nfor automatic garbage collection and you have to make sure that they are\nreleased accordingly whenever their destructor gets called (cf. the specific\nform of memory management you're using).\n\nUnless you have specific memory management requirements, use\nPyObject_{New, NewVar, Del}.\n*/\n\n/*\n * Raw object memory interface\n * ===========================\n */\n\n/* Functions to call the same malloc/realloc/free as used by Python's\n   object allocator.  If WITH_PYMALLOC is enabled, these may differ from\n   the platform malloc/realloc/free.  The Python object allocator is\n   designed for fast, cache-conscious allocation of many \"small\" objects,\n   and with low hidden memory overhead.\n\n   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.\n\n   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).\n   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory\n   at p.\n\n   Returned pointers must be checked for NULL explicitly; no action is\n   performed on failure other than to return NULL (no warning it printed, no\n   exception is set, etc).\n\n   For allocating objects, use PyObject_{New, NewVar} instead whenever\n   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed\n   so that you can exploit Python's small-block allocator for non-object\n   uses.  If you must use these routines to allocate object memory, make sure\n   the object gets initialized via PyObject_{Init, InitVar} after obtaining\n   the raw memory.\n*/\nPyAPI_FUNC(void *) PyObject_Malloc(size_t size);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\nPyAPI_FUNC(void *) PyObject_Calloc(size_t nelem, size_t elsize);\n#endif\nPyAPI_FUNC(void *) PyObject_Realloc(void *ptr, size_t new_size);\nPyAPI_FUNC(void) PyObject_Free(void *ptr);\n\n\n/* Macros */\n#define PyObject_MALLOC         PyObject_Malloc\n#define PyObject_REALLOC        PyObject_Realloc\n#define PyObject_FREE           PyObject_Free\n#define PyObject_Del            PyObject_Free\n#define PyObject_DEL            PyObject_Free\n\n\n/*\n * Generic object allocator interface\n * ==================================\n */\n\n/* Functions */\nPyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);\nPyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,\n                                                 PyTypeObject *, Py_ssize_t);\nPyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);\nPyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);\n\n#define PyObject_New(type, typeobj) \\\n                ( (type *) _PyObject_New(typeobj) )\n#define PyObject_NewVar(type, typeobj, n) \\\n                ( (type *) _PyObject_NewVar((typeobj), (n)) )\n\n/* Inline functions trading binary compatibility for speed:\n   PyObject_INIT() is the fast version of PyObject_Init(), and\n   PyObject_INIT_VAR() is the fast version of PyObject_InitVar.\n   See also pymem.h.\n\n   These inline functions expect non-NULL object pointers. */\nstatic inline PyObject*\n_PyObject_INIT(PyObject *op, PyTypeObject *typeobj)\n{\n    assert(op != NULL);\n    Py_TYPE(op) = typeobj;\n    if (PyType_GetFlags(typeobj) & Py_TPFLAGS_HEAPTYPE) {\n        Py_INCREF(typeobj);\n    }\n    _Py_NewReference(op);\n    return op;\n}\n\n#define PyObject_INIT(op, typeobj) \\\n    _PyObject_INIT(_PyObject_CAST(op), (typeobj))\n\nstatic inline PyVarObject*\n_PyObject_INIT_VAR(PyVarObject *op, PyTypeObject *typeobj, Py_ssize_t size)\n{\n    assert(op != NULL);\n    Py_SIZE(op) = size;\n    PyObject_INIT((PyObject *)op, typeobj);\n    return op;\n}\n\n#define PyObject_INIT_VAR(op, typeobj, size) \\\n    _PyObject_INIT_VAR(_PyVarObject_CAST(op), (typeobj), (size))\n\n#define _PyObject_SIZE(typeobj) ( (typeobj)->tp_basicsize )\n\n/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a\n   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The\n   value is rounded up to the closest multiple of sizeof(void *), in order to\n   ensure that pointer fields at the end of the object are correctly aligned\n   for the platform (this is of special importance for subclasses of, e.g.,\n   str or int, so that pointers can be stored after the embedded data).\n\n   Note that there's no memory wastage in doing this, as malloc has to\n   return (at worst) pointer-aligned memory anyway.\n*/\n#if ((SIZEOF_VOID_P - 1) & SIZEOF_VOID_P) != 0\n#   error \"_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2\"\n#endif\n\n#define _PyObject_VAR_SIZE(typeobj, nitems)     \\\n    _Py_SIZE_ROUND_UP((typeobj)->tp_basicsize + \\\n        (nitems)*(typeobj)->tp_itemsize,        \\\n        SIZEOF_VOID_P)\n\n#define PyObject_NEW(type, typeobj) \\\n( (type *) PyObject_Init( \\\n    (PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )\n\n#define PyObject_NEW_VAR(type, typeobj, n) \\\n( (type *) PyObject_InitVar( \\\n      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\\\n      (typeobj), (n)) )\n\n/* This example code implements an object constructor with a custom\n   allocator, where PyObject_New is inlined, and shows the important\n   distinction between two steps (at least):\n       1) the actual allocation of the object storage;\n       2) the initialization of the Python specific fields\n      in this storage with PyObject_{Init, InitVar}.\n\n   PyObject *\n   YourObject_New(...)\n   {\n       PyObject *op;\n\n       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));\n       if (op == NULL)\n       return PyErr_NoMemory();\n\n       PyObject_Init(op, &YourTypeStruct);\n\n       op->ob_field = value;\n       ...\n       return op;\n   }\n\n   Note that in C++, the use of the new operator usually implies that\n   the 1st step is performed automatically for you, so in a C++ class\n   constructor you would start directly with PyObject_Init/InitVar\n*/\n\n\n\n/*\n * Garbage Collection Support\n * ==========================\n */\n\n/* C equivalent of gc.collect() which ignores the state of gc.enabled. */\nPyAPI_FUNC(Py_ssize_t) PyGC_Collect(void);\n\n/* Test if a type has a GC head */\n#define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)\n\nPyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);\n#define PyObject_GC_Resize(type, op, n) \\\n                ( (type *) _PyObject_GC_Resize(_PyVarObject_CAST(op), (n)) )\n\n\n\nPyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);\nPyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);\n\n/* Tell the GC to track this object.\n *\n * See also private _PyObject_GC_TRACK() macro. */\nPyAPI_FUNC(void) PyObject_GC_Track(void *);\n\n/* Tell the GC to stop tracking this object.\n *\n * See also private _PyObject_GC_UNTRACK() macro. */\nPyAPI_FUNC(void) PyObject_GC_UnTrack(void *);\n\nPyAPI_FUNC(void) PyObject_GC_Del(void *);\n\n#define PyObject_GC_New(type, typeobj) \\\n                ( (type *) _PyObject_GC_New(typeobj) )\n#define PyObject_GC_NewVar(type, typeobj, n) \\\n                ( (type *) _PyObject_GC_NewVar((typeobj), (n)) )\n\n\n/* Utility macro to help write tp_traverse functions.\n * To use this macro, the tp_traverse function must name its arguments\n * \"visit\" and \"arg\".  This is intended to keep tp_traverse functions\n * looking as much alike as possible.\n */\n#define Py_VISIT(op)                                                    \\\n    do {                                                                \\\n        if (op) {                                                       \\\n            int vret = visit(_PyObject_CAST(op), arg);                  \\\n            if (vret)                                                   \\\n                return vret;                                            \\\n        }                                                               \\\n    } while (0)\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_OBJIMPL_H\n#  include  \"cpython/objimpl.h\"\n#  undef Py_CPYTHON_OBJIMPL_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_OBJIMPL_H */\n"}, "103": {"id": 103, "path": "/usr/include/python3.8/odictobject.h", "content": "#ifndef Py_ODICTOBJECT_H\n#define Py_ODICTOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* OrderedDict */\n/* This API is optional and mostly redundant. */\n\n#ifndef Py_LIMITED_API\n\ntypedef struct _odictobject PyODictObject;\n\nPyAPI_DATA(PyTypeObject) PyODict_Type;\nPyAPI_DATA(PyTypeObject) PyODictIter_Type;\nPyAPI_DATA(PyTypeObject) PyODictKeys_Type;\nPyAPI_DATA(PyTypeObject) PyODictItems_Type;\nPyAPI_DATA(PyTypeObject) PyODictValues_Type;\n\n#define PyODict_Check(op) PyObject_TypeCheck(op, &PyODict_Type)\n#define PyODict_CheckExact(op) (Py_TYPE(op) == &PyODict_Type)\n#define PyODict_SIZE(op) PyDict_GET_SIZE((op))\n\nPyAPI_FUNC(PyObject *) PyODict_New(void);\nPyAPI_FUNC(int) PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item);\nPyAPI_FUNC(int) PyODict_DelItem(PyObject *od, PyObject *key);\n\n/* wrappers around PyDict* functions */\n#define PyODict_GetItem(od, key) PyDict_GetItem(_PyObject_CAST(od), key)\n#define PyODict_GetItemWithError(od, key) \\\n    PyDict_GetItemWithError(_PyObject_CAST(od), key)\n#define PyODict_Contains(od, key) PyDict_Contains(_PyObject_CAST(od), key)\n#define PyODict_Size(od) PyDict_Size(_PyObject_CAST(od))\n#define PyODict_GetItemString(od, key) \\\n    PyDict_GetItemString(_PyObject_CAST(od), key)\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_ODICTOBJECT_H */\n"}, "104": {"id": 104, "path": "/usr/include/python3.8/osmodule.h", "content": "\n/* os module interface */\n\n#ifndef Py_OSMODULE_H\n#define Py_OSMODULE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000\nPyAPI_FUNC(PyObject *) PyOS_FSPath(PyObject *path);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_OSMODULE_H */\n"}, "105": {"id": 105, "path": "/usr/include/python3.8/patchlevel.h", "content": "\n/* Python version identification scheme.\n\n   When the major or minor version changes, the VERSION variable in\n   configure.ac must also be changed.\n\n   There is also (independent) API version information in modsupport.h.\n*/\n\n/* Values for PY_RELEASE_LEVEL */\n#define PY_RELEASE_LEVEL_ALPHA  0xA\n#define PY_RELEASE_LEVEL_BETA   0xB\n#define PY_RELEASE_LEVEL_GAMMA  0xC     /* For release candidates */\n#define PY_RELEASE_LEVEL_FINAL  0xF     /* Serial should be 0 here */\n                                        /* Higher for patch releases */\n\n/* Version parsed out into numeric values */\n/*--start constants--*/\n#define PY_MAJOR_VERSION        3\n#define PY_MINOR_VERSION        8\n#define PY_MICRO_VERSION        5\n#define PY_RELEASE_LEVEL        PY_RELEASE_LEVEL_FINAL\n#define PY_RELEASE_SERIAL       0\n\n/* Version as a string */\n#define PY_VERSION              \"3.8.5\"\n/*--end constants--*/\n\n/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.\n   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX >= ... */\n#define PY_VERSION_HEX ((PY_MAJOR_VERSION << 24) | \\\n                        (PY_MINOR_VERSION << 16) | \\\n                        (PY_MICRO_VERSION <<  8) | \\\n                        (PY_RELEASE_LEVEL <<  4) | \\\n                        (PY_RELEASE_SERIAL << 0))\n"}, "106": {"id": 106, "path": "/usr/include/python3.8/picklebufobject.h", "content": "/* PickleBuffer object. This is built-in for ease of use from third-party\n * C extensions.\n */\n\n#ifndef Py_PICKLEBUFOBJECT_H\n#define Py_PICKLEBUFOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\n\nPyAPI_DATA(PyTypeObject) PyPickleBuffer_Type;\n\n#define PyPickleBuffer_Check(op) (Py_TYPE(op) == &PyPickleBuffer_Type)\n\n/* Create a PickleBuffer redirecting to the given buffer-enabled object */\nPyAPI_FUNC(PyObject *) PyPickleBuffer_FromObject(PyObject *);\n/* Get the PickleBuffer's underlying view to the original object\n * (NULL if released)\n */\nPyAPI_FUNC(const Py_buffer *) PyPickleBuffer_GetBuffer(PyObject *);\n/* Release the PickleBuffer.  Returns 0 on success, -1 on error. */\nPyAPI_FUNC(int) PyPickleBuffer_Release(PyObject *);\n\n#endif /* !Py_LIMITED_API */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_PICKLEBUFOBJECT_H */\n"}, "107": {"id": 107, "path": "/usr/include/python3.8/pyarena.h", "content": "/* An arena-like memory interface for the compiler.\n */\n\n#ifndef Py_LIMITED_API\n#ifndef Py_PYARENA_H\n#define Py_PYARENA_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n  typedef struct _arena PyArena;\n\n  /* PyArena_New() and PyArena_Free() create a new arena and free it,\n     respectively.  Once an arena has been created, it can be used\n     to allocate memory via PyArena_Malloc().  Pointers to PyObject can\n     also be registered with the arena via PyArena_AddPyObject(), and the\n     arena will ensure that the PyObjects stay alive at least until\n     PyArena_Free() is called.  When an arena is freed, all the memory it\n     allocated is freed, the arena releases internal references to registered\n     PyObject*, and none of its pointers are valid.\n     XXX (tim) What does \"none of its pointers are valid\" mean?  Does it\n     XXX mean that pointers previously obtained via PyArena_Malloc() are\n     XXX no longer valid?  (That's clearly true, but not sure that's what\n     XXX the text is trying to say.)\n\n     PyArena_New() returns an arena pointer.  On error, it\n     returns a negative number and sets an exception.\n     XXX (tim):  Not true.  On error, PyArena_New() actually returns NULL,\n     XXX and looks like it may or may not set an exception (e.g., if the\n     XXX internal PyList_New(0) returns NULL, PyArena_New() passes that on\n     XXX and an exception is set; OTOH, if the internal\n     XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but\n     XXX an exception is not set in that case).\n  */\n  PyAPI_FUNC(PyArena *) PyArena_New(void);\n  PyAPI_FUNC(void) PyArena_Free(PyArena *);\n\n  /* Mostly like malloc(), return the address of a block of memory spanning\n   * `size` bytes, or return NULL (without setting an exception) if enough\n   * new memory can't be obtained.  Unlike malloc(0), PyArena_Malloc() with\n   * size=0 does not guarantee to return a unique pointer (the pointer\n   * returned may equal one or more other pointers obtained from\n   * PyArena_Malloc()).\n   * Note that pointers obtained via PyArena_Malloc() must never be passed to\n   * the system free() or realloc(), or to any of Python's similar memory-\n   * management functions.  PyArena_Malloc()-obtained pointers remain valid\n   * until PyArena_Free(ar) is called, at which point all pointers obtained\n   * from the arena `ar` become invalid simultaneously.\n   */\n  PyAPI_FUNC(void *) PyArena_Malloc(PyArena *, size_t size);\n\n  /* This routine isn't a proper arena allocation routine.  It takes\n   * a PyObject* and records it so that it can be DECREFed when the\n   * arena is freed.\n   */\n  PyAPI_FUNC(int) PyArena_AddPyObject(PyArena *, PyObject *);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_PYARENA_H */\n#endif /* Py_LIMITED_API */\n"}, "108": {"id": 108, "path": "/usr/include/python3.8/pycapsule.h", "content": "\n/* Capsule objects let you wrap a C \"void *\" pointer in a Python\n   object.  They're a way of passing data through the Python interpreter\n   without creating your own custom type.\n\n   Capsules are used for communication between extension modules.\n   They provide a way for an extension module to export a C interface\n   to other extension modules, so that extension modules can use the\n   Python import mechanism to link to one another.\n\n   For more information, please see \"c-api/capsule.html\" in the\n   documentation.\n*/\n\n#ifndef Py_CAPSULE_H\n#define Py_CAPSULE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_DATA(PyTypeObject) PyCapsule_Type;\n\ntypedef void (*PyCapsule_Destructor)(PyObject *);\n\n#define PyCapsule_CheckExact(op) (Py_TYPE(op) == &PyCapsule_Type)\n\n\nPyAPI_FUNC(PyObject *) PyCapsule_New(\n    void *pointer,\n    const char *name,\n    PyCapsule_Destructor destructor);\n\nPyAPI_FUNC(void *) PyCapsule_GetPointer(PyObject *capsule, const char *name);\n\nPyAPI_FUNC(PyCapsule_Destructor) PyCapsule_GetDestructor(PyObject *capsule);\n\nPyAPI_FUNC(const char *) PyCapsule_GetName(PyObject *capsule);\n\nPyAPI_FUNC(void *) PyCapsule_GetContext(PyObject *capsule);\n\nPyAPI_FUNC(int) PyCapsule_IsValid(PyObject *capsule, const char *name);\n\nPyAPI_FUNC(int) PyCapsule_SetPointer(PyObject *capsule, void *pointer);\n\nPyAPI_FUNC(int) PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor);\n\nPyAPI_FUNC(int) PyCapsule_SetName(PyObject *capsule, const char *name);\n\nPyAPI_FUNC(int) PyCapsule_SetContext(PyObject *capsule, void *context);\n\nPyAPI_FUNC(void *) PyCapsule_Import(\n    const char *name,           /* UTF-8 encoded string */\n    int no_block);\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_CAPSULE_H */\n"}, "109": {"id": 109, "path": "/usr/include/python3.8/pyconfig.h", "content": "#if defined(__linux__)\n# if defined(__x86_64__) && defined(__LP64__)\n#  include <x86_64-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__x86_64__) && defined(__ILP32__)\n#  include <x86_64-linux-gnux32/python3.8/pyconfig.h>\n# elif defined(__i386__)\n#  include <i386-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__aarch64__) && defined(__AARCH64EL__)\n#  include <aarch64-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__alpha__)\n#  include <alpha-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__ARM_EABI__) && defined(__ARM_PCS_VFP)\n#  include <arm-linux-gnueabihf/python3.8/pyconfig.h>\n# elif defined(__ARM_EABI__) && !defined(__ARM_PCS_VFP)\n#  include <arm-linux-gnueabi/python3.8/pyconfig.h>\n# elif defined(__hppa__)\n#  include <hppa-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__ia64__)\n#  include <ia64-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__m68k__) && !defined(__mcoldfire__)\n#  include <m68k-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__mips_hard_float) && defined(__mips_isa_rev) && (__mips_isa_rev >=6) && defined(_MIPSEL)\n#  if _MIPS_SIM == _ABIO32\n#   include <mipsisa32r6el-linux-gnu/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABIN32\n#   include <mipsisa64r6el-linux-gnuabin32/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABI64\n#   include <mipsisa64r6el-linux-gnuabi64/python3.8/pyconfig.h>\n#  else\n#   error unknown multiarch location for pyconfig.h\n#  endif\n# elif defined(__mips_hard_float) && defined(__mips_isa_rev) && (__mips_isa_rev >=6)\n#  if _MIPS_SIM == _ABIO32\n#   include <mipsisa32r6-linux-gnu/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABIN32\n#   include <mipsisa64r6-linux-gnuabin32/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABI64\n#   include <mipsisa64r6-linux-gnuabi64/python3.8/pyconfig.h>\n#  else\n#   error unknown multiarch location for pyconfig.h\n#  endif\n# elif defined(__mips_hard_float) && defined(_MIPSEL)\n#  if _MIPS_SIM == _ABIO32\n#   include <mipsel-linux-gnu/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABIN32\n#   include <mips64el-linux-gnuabin32/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABI64\n#   include <mips64el-linux-gnuabi64/python3.8/pyconfig.h>\n#  else\n#   error unknown multiarch location for pyconfig.h\n#  endif\n# elif defined(__mips_hard_float)\n#  if _MIPS_SIM == _ABIO32\n#   include <mips-linux-gnu/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABIN32\n#   include <mips64-linux-gnuabin32/python3.8/pyconfig.h>\n#  elif _MIPS_SIM == _ABI64\n#   include <mips64-linux-gnuabi64/python3.8/pyconfig.h>\n#  else\n#   error unknown multiarch location for pyconfig.h\n#  endif\n# elif defined(__or1k__)\n#  include <or1k-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__powerpc__) && defined(__SPE__)\n#  include <powerpc-linux-gnuspe/python3.8/pyconfig.h>\n# elif defined(__powerpc64__)\n#  if defined(__LITTLE_ENDIAN__)\n#    include <powerpc64le-linux-gnu/python3.8/pyconfig.h>\n#  else\n#    include <powerpc64-linux-gnu/python3.8/pyconfig.h>\n#  endif\n# elif defined(__powerpc__)\n#  include <powerpc-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__s390x__)\n#  include <s390x-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__s390__)\n#  include <s390-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__sh__) && defined(__LITTLE_ENDIAN__)\n#  include <sh4-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__sparc__) && defined(__arch64__)\n#  include <sparc64-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__sparc__)\n#  include <sparc-linux-gnu/python3.8/pyconfig.h>\n# elif defined(__riscv)\n#  if __riscv_xlen == 64\n#    include <riscv64-linux-gnu/python3.8/pyconfig.h>\n#  else\n#    include <riscv32-linux-gnu/python3.8/pyconfig.h>\n#  endif\n# else\n#   error unknown multiarch location for pyconfig.h\n# endif\n#elif defined(__FreeBSD_kernel__)\n# if defined(__LP64__)\n#  include <x86_64-kfreebsd-gnu/python3.8/pyconfig.h>\n# elif defined(__i386__)\n#  include <i386-kfreebsd-gnu/python3.8/pyconfig.h>\n# else\n#   error unknown multiarch location for pyconfig.h\n# endif\n#elif defined(__gnu_hurd__)\n# include <i386-gnu/python3.8/pyconfig.h>\n#else\n# error unknown multiarch location for pyconfig.h\n#endif\n"}, "110": {"id": 110, "path": "/usr/include/python3.8/pyctype.h", "content": "#ifndef Py_LIMITED_API\n#ifndef PYCTYPE_H\n#define PYCTYPE_H\n\n#define PY_CTF_LOWER  0x01\n#define PY_CTF_UPPER  0x02\n#define PY_CTF_ALPHA  (PY_CTF_LOWER|PY_CTF_UPPER)\n#define PY_CTF_DIGIT  0x04\n#define PY_CTF_ALNUM  (PY_CTF_ALPHA|PY_CTF_DIGIT)\n#define PY_CTF_SPACE  0x08\n#define PY_CTF_XDIGIT 0x10\n\nPyAPI_DATA(const unsigned int) _Py_ctype_table[256];\n\n/* Unlike their C counterparts, the following macros are not meant to\n * handle an int with any of the values [EOF, 0-UCHAR_MAX]. The argument\n * must be a signed/unsigned char. */\n#define Py_ISLOWER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_LOWER)\n#define Py_ISUPPER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_UPPER)\n#define Py_ISALPHA(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALPHA)\n#define Py_ISDIGIT(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_DIGIT)\n#define Py_ISXDIGIT(c) (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_XDIGIT)\n#define Py_ISALNUM(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALNUM)\n#define Py_ISSPACE(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_SPACE)\n\nPyAPI_DATA(const unsigned char) _Py_ctype_tolower[256];\nPyAPI_DATA(const unsigned char) _Py_ctype_toupper[256];\n\n#define Py_TOLOWER(c) (_Py_ctype_tolower[Py_CHARMASK(c)])\n#define Py_TOUPPER(c) (_Py_ctype_toupper[Py_CHARMASK(c)])\n\n#endif /* !PYCTYPE_H */\n#endif /* !Py_LIMITED_API */\n"}, "111": {"id": 111, "path": "/usr/include/python3.8/pydebug.h", "content": "#ifndef Py_LIMITED_API\n#ifndef Py_PYDEBUG_H\n#define Py_PYDEBUG_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* These global variable are defined in pylifecycle.c */\n/* XXX (ncoghlan): move these declarations to pylifecycle.h? */\nPyAPI_DATA(int) Py_DebugFlag;\nPyAPI_DATA(int) Py_VerboseFlag;\nPyAPI_DATA(int) Py_QuietFlag;\nPyAPI_DATA(int) Py_InteractiveFlag;\nPyAPI_DATA(int) Py_InspectFlag;\nPyAPI_DATA(int) Py_OptimizeFlag;\nPyAPI_DATA(int) Py_NoSiteFlag;\nPyAPI_DATA(int) Py_BytesWarningFlag;\nPyAPI_DATA(int) Py_FrozenFlag;\nPyAPI_DATA(int) Py_IgnoreEnvironmentFlag;\nPyAPI_DATA(int) Py_DontWriteBytecodeFlag;\nPyAPI_DATA(int) Py_NoUserSiteDirectory;\nPyAPI_DATA(int) Py_UnbufferedStdioFlag;\nPyAPI_DATA(int) Py_HashRandomizationFlag;\nPyAPI_DATA(int) Py_IsolatedFlag;\n\n#ifdef MS_WINDOWS\nPyAPI_DATA(int) Py_LegacyWindowsFSEncodingFlag;\nPyAPI_DATA(int) Py_LegacyWindowsStdioFlag;\n#endif\n\n/* this is a wrapper around getenv() that pays attention to\n   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like\n   PYTHONPATH and PYTHONHOME from the environment */\n#define Py_GETENV(s) (Py_IgnoreEnvironmentFlag ? NULL : getenv(s))\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_PYDEBUG_H */\n#endif /* Py_LIMITED_API */\n"}, "112": {"id": 112, "path": "/usr/include/python3.8/pyerrors.h", "content": "#ifndef Py_ERRORS_H\n#define Py_ERRORS_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Error handling definitions */\n\nPyAPI_FUNC(void) PyErr_SetNone(PyObject *);\nPyAPI_FUNC(void) PyErr_SetObject(PyObject *, PyObject *);\nPyAPI_FUNC(void) PyErr_SetString(\n    PyObject *exception,\n    const char *string   /* decoded from utf-8 */\n    );\nPyAPI_FUNC(PyObject *) PyErr_Occurred(void);\nPyAPI_FUNC(void) PyErr_Clear(void);\nPyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);\nPyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(void) PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **);\nPyAPI_FUNC(void) PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *);\n#endif\n\n/* Defined in Python/pylifecycle.c */\nPyAPI_FUNC(void) _Py_NO_RETURN Py_FatalError(const char *message);\n\n#if defined(Py_DEBUG) || defined(Py_LIMITED_API)\n#define _PyErr_OCCURRED() PyErr_Occurred()\n#else\n#define _PyErr_OCCURRED() (PyThreadState_GET()->curexc_type)\n#endif\n\n/* Error testing and normalization */\nPyAPI_FUNC(int) PyErr_GivenExceptionMatches(PyObject *, PyObject *);\nPyAPI_FUNC(int) PyErr_ExceptionMatches(PyObject *);\nPyAPI_FUNC(void) PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);\n\n/* Traceback manipulation (PEP 3134) */\nPyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);\nPyAPI_FUNC(PyObject *) PyException_GetTraceback(PyObject *);\n\n/* Cause manipulation (PEP 3134) */\nPyAPI_FUNC(PyObject *) PyException_GetCause(PyObject *);\nPyAPI_FUNC(void) PyException_SetCause(PyObject *, PyObject *);\n\n/* Context manipulation (PEP 3134) */\nPyAPI_FUNC(PyObject *) PyException_GetContext(PyObject *);\nPyAPI_FUNC(void) PyException_SetContext(PyObject *, PyObject *);\n\n/* */\n\n#define PyExceptionClass_Check(x)                                       \\\n    (PyType_Check((x)) &&                                               \\\n     PyType_FastSubclass((PyTypeObject*)(x), Py_TPFLAGS_BASE_EXC_SUBCLASS))\n\n#define PyExceptionInstance_Check(x)                    \\\n    PyType_FastSubclass((x)->ob_type, Py_TPFLAGS_BASE_EXC_SUBCLASS)\n\nPyAPI_FUNC(const char *) PyExceptionClass_Name(PyObject *);\n\n#define PyExceptionInstance_Class(x) ((PyObject*)((x)->ob_type))\n\n\n/* Predefined exceptions */\n\nPyAPI_DATA(PyObject *) PyExc_BaseException;\nPyAPI_DATA(PyObject *) PyExc_Exception;\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\nPyAPI_DATA(PyObject *) PyExc_StopAsyncIteration;\n#endif\nPyAPI_DATA(PyObject *) PyExc_StopIteration;\nPyAPI_DATA(PyObject *) PyExc_GeneratorExit;\nPyAPI_DATA(PyObject *) PyExc_ArithmeticError;\nPyAPI_DATA(PyObject *) PyExc_LookupError;\n\nPyAPI_DATA(PyObject *) PyExc_AssertionError;\nPyAPI_DATA(PyObject *) PyExc_AttributeError;\nPyAPI_DATA(PyObject *) PyExc_BufferError;\nPyAPI_DATA(PyObject *) PyExc_EOFError;\nPyAPI_DATA(PyObject *) PyExc_FloatingPointError;\nPyAPI_DATA(PyObject *) PyExc_OSError;\nPyAPI_DATA(PyObject *) PyExc_ImportError;\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000\nPyAPI_DATA(PyObject *) PyExc_ModuleNotFoundError;\n#endif\nPyAPI_DATA(PyObject *) PyExc_IndexError;\nPyAPI_DATA(PyObject *) PyExc_KeyError;\nPyAPI_DATA(PyObject *) PyExc_KeyboardInterrupt;\nPyAPI_DATA(PyObject *) PyExc_MemoryError;\nPyAPI_DATA(PyObject *) PyExc_NameError;\nPyAPI_DATA(PyObject *) PyExc_OverflowError;\nPyAPI_DATA(PyObject *) PyExc_RuntimeError;\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\nPyAPI_DATA(PyObject *) PyExc_RecursionError;\n#endif\nPyAPI_DATA(PyObject *) PyExc_NotImplementedError;\nPyAPI_DATA(PyObject *) PyExc_SyntaxError;\nPyAPI_DATA(PyObject *) PyExc_IndentationError;\nPyAPI_DATA(PyObject *) PyExc_TabError;\nPyAPI_DATA(PyObject *) PyExc_ReferenceError;\nPyAPI_DATA(PyObject *) PyExc_SystemError;\nPyAPI_DATA(PyObject *) PyExc_SystemExit;\nPyAPI_DATA(PyObject *) PyExc_TypeError;\nPyAPI_DATA(PyObject *) PyExc_UnboundLocalError;\nPyAPI_DATA(PyObject *) PyExc_UnicodeError;\nPyAPI_DATA(PyObject *) PyExc_UnicodeEncodeError;\nPyAPI_DATA(PyObject *) PyExc_UnicodeDecodeError;\nPyAPI_DATA(PyObject *) PyExc_UnicodeTranslateError;\nPyAPI_DATA(PyObject *) PyExc_ValueError;\nPyAPI_DATA(PyObject *) PyExc_ZeroDivisionError;\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_DATA(PyObject *) PyExc_BlockingIOError;\nPyAPI_DATA(PyObject *) PyExc_BrokenPipeError;\nPyAPI_DATA(PyObject *) PyExc_ChildProcessError;\nPyAPI_DATA(PyObject *) PyExc_ConnectionError;\nPyAPI_DATA(PyObject *) PyExc_ConnectionAbortedError;\nPyAPI_DATA(PyObject *) PyExc_ConnectionRefusedError;\nPyAPI_DATA(PyObject *) PyExc_ConnectionResetError;\nPyAPI_DATA(PyObject *) PyExc_FileExistsError;\nPyAPI_DATA(PyObject *) PyExc_FileNotFoundError;\nPyAPI_DATA(PyObject *) PyExc_InterruptedError;\nPyAPI_DATA(PyObject *) PyExc_IsADirectoryError;\nPyAPI_DATA(PyObject *) PyExc_NotADirectoryError;\nPyAPI_DATA(PyObject *) PyExc_PermissionError;\nPyAPI_DATA(PyObject *) PyExc_ProcessLookupError;\nPyAPI_DATA(PyObject *) PyExc_TimeoutError;\n#endif\n\n\n/* Compatibility aliases */\nPyAPI_DATA(PyObject *) PyExc_EnvironmentError;\nPyAPI_DATA(PyObject *) PyExc_IOError;\n#ifdef MS_WINDOWS\nPyAPI_DATA(PyObject *) PyExc_WindowsError;\n#endif\n\n/* Predefined warning categories */\nPyAPI_DATA(PyObject *) PyExc_Warning;\nPyAPI_DATA(PyObject *) PyExc_UserWarning;\nPyAPI_DATA(PyObject *) PyExc_DeprecationWarning;\nPyAPI_DATA(PyObject *) PyExc_PendingDeprecationWarning;\nPyAPI_DATA(PyObject *) PyExc_SyntaxWarning;\nPyAPI_DATA(PyObject *) PyExc_RuntimeWarning;\nPyAPI_DATA(PyObject *) PyExc_FutureWarning;\nPyAPI_DATA(PyObject *) PyExc_ImportWarning;\nPyAPI_DATA(PyObject *) PyExc_UnicodeWarning;\nPyAPI_DATA(PyObject *) PyExc_BytesWarning;\nPyAPI_DATA(PyObject *) PyExc_ResourceWarning;\n\n\n/* Convenience functions */\n\nPyAPI_FUNC(int) PyErr_BadArgument(void);\nPyAPI_FUNC(PyObject *) PyErr_NoMemory(void);\nPyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);\nPyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(\n    PyObject *, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObjects(\n    PyObject *, PyObject *, PyObject *);\n#endif\nPyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(\n    PyObject *exc,\n    const char *filename   /* decoded from the filesystem encoding */\n    );\n\nPyAPI_FUNC(PyObject *) PyErr_Format(\n    PyObject *exception,\n    const char *format,   /* ASCII-encoded string  */\n    ...\n    );\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\nPyAPI_FUNC(PyObject *) PyErr_FormatV(\n    PyObject *exception,\n    const char *format,\n    va_list vargs);\n#endif\n\n#ifdef MS_WINDOWS\nPyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(\n    int ierr,\n    const char *filename        /* decoded from the filesystem encoding */\n    );\nPyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);\nPyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(\n    PyObject *,int, PyObject *);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000\nPyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObjects(\n    PyObject *,int, PyObject *, PyObject *);\n#endif\nPyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(\n    PyObject *exc,\n    int ierr,\n    const char *filename        /* decoded from the filesystem encoding */\n    );\nPyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);\n#endif /* MS_WINDOWS */\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000\nPyAPI_FUNC(PyObject *) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,\n    PyObject *, PyObject *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject *) PyErr_SetImportError(PyObject *, PyObject *,\n    PyObject *);\n#endif\n\n/* Export the old function so that the existing API remains available: */\nPyAPI_FUNC(void) PyErr_BadInternalCall(void);\nPyAPI_FUNC(void) _PyErr_BadInternalCall(const char *filename, int lineno);\n/* Mask the old API with a call to the new API for code compiled under\n   Python 2.0: */\n#define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)\n\n/* Function to create a new exception */\nPyAPI_FUNC(PyObject *) PyErr_NewException(\n    const char *name, PyObject *base, PyObject *dict);\nPyAPI_FUNC(PyObject *) PyErr_NewExceptionWithDoc(\n    const char *name, const char *doc, PyObject *base, PyObject *dict);\nPyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);\n\n\n/* In signalmodule.c */\nPyAPI_FUNC(int) PyErr_CheckSignals(void);\nPyAPI_FUNC(void) PyErr_SetInterrupt(void);\n\n/* Support for adding program text to SyntaxErrors */\nPyAPI_FUNC(void) PyErr_SyntaxLocation(\n    const char *filename,       /* decoded from the filesystem encoding */\n    int lineno);\nPyAPI_FUNC(void) PyErr_SyntaxLocationEx(\n    const char *filename,       /* decoded from the filesystem encoding */\n    int lineno,\n    int col_offset);\nPyAPI_FUNC(PyObject *) PyErr_ProgramText(\n    const char *filename,       /* decoded from the filesystem encoding */\n    int lineno);\n\n/* The following functions are used to create and modify unicode\n   exceptions from C */\n\n/* create a UnicodeDecodeError object */\nPyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(\n    const char *encoding,       /* UTF-8 encoded string */\n    const char *object,\n    Py_ssize_t length,\n    Py_ssize_t start,\n    Py_ssize_t end,\n    const char *reason          /* UTF-8 encoded string */\n    );\n\n/* get the encoding attribute */\nPyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);\nPyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);\n\n/* get the object attribute */\nPyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);\nPyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);\nPyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);\n\n/* get the value of the start attribute (the int * may not be NULL)\n   return 0 on success, -1 on failure */\nPyAPI_FUNC(int) PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *);\nPyAPI_FUNC(int) PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *);\nPyAPI_FUNC(int) PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *);\n\n/* assign a new value to the start attribute\n   return 0 on success, -1 on failure */\nPyAPI_FUNC(int) PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t);\nPyAPI_FUNC(int) PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t);\nPyAPI_FUNC(int) PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t);\n\n/* get the value of the end attribute (the int *may not be NULL)\n return 0 on success, -1 on failure */\nPyAPI_FUNC(int) PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *);\nPyAPI_FUNC(int) PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *);\nPyAPI_FUNC(int) PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *);\n\n/* assign a new value to the end attribute\n   return 0 on success, -1 on failure */\nPyAPI_FUNC(int) PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t);\nPyAPI_FUNC(int) PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t);\nPyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);\n\n/* get the value of the reason attribute */\nPyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);\nPyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);\nPyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);\n\n/* assign a new value to the reason attribute\n   return 0 on success, -1 on failure */\nPyAPI_FUNC(int) PyUnicodeEncodeError_SetReason(\n    PyObject *exc,\n    const char *reason          /* UTF-8 encoded string */\n    );\nPyAPI_FUNC(int) PyUnicodeDecodeError_SetReason(\n    PyObject *exc,\n    const char *reason          /* UTF-8 encoded string */\n    );\nPyAPI_FUNC(int) PyUnicodeTranslateError_SetReason(\n    PyObject *exc,\n    const char *reason          /* UTF-8 encoded string */\n    );\n\n/* These APIs aren't really part of the error implementation, but\n   often needed to format error messages; the native C lib APIs are\n   not available on all platforms, which is why we provide emulations\n   for those platforms in Python/mysnprintf.c,\n   WARNING:  The return value of snprintf varies across platforms; do\n   not rely on any particular behavior; eventually the C99 defn may\n   be reliable.\n*/\n#if defined(MS_WIN32) && !defined(HAVE_SNPRINTF)\n# define HAVE_SNPRINTF\n# define snprintf _snprintf\n# define vsnprintf _vsnprintf\n#endif\n\n#include <stdarg.h>\nPyAPI_FUNC(int) PyOS_snprintf(char *str, size_t size, const char  *format, ...)\n                        Py_GCC_ATTRIBUTE((format(printf, 3, 4)));\nPyAPI_FUNC(int) PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)\n                        Py_GCC_ATTRIBUTE((format(printf, 3, 0)));\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_ERRORS_H\n#  include  \"cpython/pyerrors.h\"\n#  undef Py_CPYTHON_ERRORS_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_ERRORS_H */\n"}, "113": {"id": 113, "path": "/usr/include/python3.8/pyfpe.h", "content": "#ifndef Py_PYFPE_H\n#define Py_PYFPE_H\n\n/* These macros used to do something when Python was built with --with-fpectl,\n * but support for that was dropped in 3.7. We continue to define them though,\n * to avoid breaking API users.\n */\n\n#define PyFPE_START_PROTECT(err_string, leave_stmt)\n#define PyFPE_END_PROTECT(v)\n\n#endif /* !Py_PYFPE_H */\n"}, "114": {"id": 114, "path": "/usr/include/python3.8/pyhash.h", "content": "#ifndef Py_HASH_H\n\n#define Py_HASH_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Helpers for hash functions */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(Py_hash_t) _Py_HashDouble(double);\nPyAPI_FUNC(Py_hash_t) _Py_HashPointer(void*);\nPyAPI_FUNC(Py_hash_t) _Py_HashBytes(const void*, Py_ssize_t);\n#endif\n\n/* Prime multiplier used in string and various other hashes. */\n#define _PyHASH_MULTIPLIER 1000003UL  /* 0xf4243 */\n\n/* Parameters used for the numeric hash implementation.  See notes for\n   _Py_HashDouble in Python/pyhash.c.  Numeric hashes are based on\n   reduction modulo the prime 2**_PyHASH_BITS - 1. */\n\n#if SIZEOF_VOID_P >= 8\n#  define _PyHASH_BITS 61\n#else\n#  define _PyHASH_BITS 31\n#endif\n\n#define _PyHASH_MODULUS (((size_t)1 << _PyHASH_BITS) - 1)\n#define _PyHASH_INF 314159\n#define _PyHASH_NAN 0\n#define _PyHASH_IMAG _PyHASH_MULTIPLIER\n\n\n/* hash secret\n *\n * memory layout on 64 bit systems\n *   cccccccc cccccccc cccccccc  uc -- unsigned char[24]\n *   pppppppp ssssssss ........  fnv -- two Py_hash_t\n *   k0k0k0k0 k1k1k1k1 ........  siphash -- two uint64_t\n *   ........ ........ ssssssss  djbx33a -- 16 bytes padding + one Py_hash_t\n *   ........ ........ eeeeeeee  pyexpat XML hash salt\n *\n * memory layout on 32 bit systems\n *   cccccccc cccccccc cccccccc  uc\n *   ppppssss ........ ........  fnv -- two Py_hash_t\n *   k0k0k0k0 k1k1k1k1 ........  siphash -- two uint64_t (*)\n *   ........ ........ ssss....  djbx33a -- 16 bytes padding + one Py_hash_t\n *   ........ ........ eeee....  pyexpat XML hash salt\n *\n * (*) The siphash member may not be available on 32 bit platforms without\n *     an unsigned int64 data type.\n */\n#ifndef Py_LIMITED_API\ntypedef union {\n    /* ensure 24 bytes */\n    unsigned char uc[24];\n    /* two Py_hash_t for FNV */\n    struct {\n        Py_hash_t prefix;\n        Py_hash_t suffix;\n    } fnv;\n    /* two uint64 for SipHash24 */\n    struct {\n        uint64_t k0;\n        uint64_t k1;\n    } siphash;\n    /* a different (!) Py_hash_t for small string optimization */\n    struct {\n        unsigned char padding[16];\n        Py_hash_t suffix;\n    } djbx33a;\n    struct {\n        unsigned char padding[16];\n        Py_hash_t hashsalt;\n    } expat;\n} _Py_HashSecret_t;\nPyAPI_DATA(_Py_HashSecret_t) _Py_HashSecret;\n#endif\n\n#ifdef Py_DEBUG\nPyAPI_DATA(int) _Py_HashSecret_Initialized;\n#endif\n\n\n/* hash function definition */\n#ifndef Py_LIMITED_API\ntypedef struct {\n    Py_hash_t (*const hash)(const void *, Py_ssize_t);\n    const char *name;\n    const int hash_bits;\n    const int seed_bits;\n} PyHash_FuncDef;\n\nPyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);\n#endif\n\n\n/* cutoff for small string DJBX33A optimization in range [1, cutoff).\n *\n * About 50% of the strings in a typical Python application are smaller than\n * 6 to 7 chars. However DJBX33A is vulnerable to hash collision attacks.\n * NEVER use DJBX33A for long strings!\n *\n * A Py_HASH_CUTOFF of 0 disables small string optimization. 32 bit platforms\n * should use a smaller cutoff because it is easier to create colliding\n * strings. A cutoff of 7 on 64bit platforms and 5 on 32bit platforms should\n * provide a decent safety margin.\n */\n#ifndef Py_HASH_CUTOFF\n#  define Py_HASH_CUTOFF 0\n#elif (Py_HASH_CUTOFF > 7 || Py_HASH_CUTOFF < 0)\n#  error Py_HASH_CUTOFF must in range 0...7.\n#endif /* Py_HASH_CUTOFF */\n\n\n/* hash algorithm selection\n *\n * The values for Py_HASH_SIPHASH24 and Py_HASH_FNV are hard-coded in the\n * configure script.\n *\n * - FNV is available on all platforms and architectures.\n * - SIPHASH24 only works on platforms that don't require aligned memory for integers.\n * - With EXTERNAL embedders can provide an alternative implementation with::\n *\n *     PyHash_FuncDef PyHash_Func = {...};\n *\n * XXX: Figure out __declspec() for extern PyHash_FuncDef.\n */\n#define Py_HASH_EXTERNAL 0\n#define Py_HASH_SIPHASH24 1\n#define Py_HASH_FNV 2\n\n#ifndef Py_HASH_ALGORITHM\n#  ifndef HAVE_ALIGNED_REQUIRED\n#    define Py_HASH_ALGORITHM Py_HASH_SIPHASH24\n#  else\n#    define Py_HASH_ALGORITHM Py_HASH_FNV\n#  endif /* uint64_t && uint32_t && aligned */\n#endif /* Py_HASH_ALGORITHM */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_HASH_H */\n"}, "115": {"id": 115, "path": "/usr/include/python3.8/pylifecycle.h", "content": "\n/* Interfaces to configure, query, create & destroy the Python runtime */\n\n#ifndef Py_PYLIFECYCLE_H\n#define Py_PYLIFECYCLE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Initialization and finalization */\nPyAPI_FUNC(void) Py_Initialize(void);\nPyAPI_FUNC(void) Py_InitializeEx(int);\nPyAPI_FUNC(void) Py_Finalize(void);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000\nPyAPI_FUNC(int) Py_FinalizeEx(void);\n#endif\nPyAPI_FUNC(int) Py_IsInitialized(void);\n\n/* Subinterpreter support */\nPyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);\nPyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);\n\n\n/* Py_PyAtExit is for the atexit module, Py_AtExit is for low-level\n * exit functions.\n */\nPyAPI_FUNC(int) Py_AtExit(void (*func)(void));\n\nPyAPI_FUNC(void) _Py_NO_RETURN Py_Exit(int);\n\n/* Bootstrap __main__ (defined in Modules/main.c) */\nPyAPI_FUNC(int) Py_Main(int argc, wchar_t **argv);\n\nPyAPI_FUNC(int) Py_BytesMain(int argc, char **argv);\n\n/* In pathconfig.c */\nPyAPI_FUNC(void) Py_SetProgramName(const wchar_t *);\nPyAPI_FUNC(wchar_t *) Py_GetProgramName(void);\n\nPyAPI_FUNC(void) Py_SetPythonHome(const wchar_t *);\nPyAPI_FUNC(wchar_t *) Py_GetPythonHome(void);\n\nPyAPI_FUNC(wchar_t *) Py_GetProgramFullPath(void);\n\nPyAPI_FUNC(wchar_t *) Py_GetPrefix(void);\nPyAPI_FUNC(wchar_t *) Py_GetExecPrefix(void);\nPyAPI_FUNC(wchar_t *) Py_GetPath(void);\nPyAPI_FUNC(void)      Py_SetPath(const wchar_t *);\n#ifdef MS_WINDOWS\nint _Py_CheckPython3(void);\n#endif\n\n/* In their own files */\nPyAPI_FUNC(const char *) Py_GetVersion(void);\nPyAPI_FUNC(const char *) Py_GetPlatform(void);\nPyAPI_FUNC(const char *) Py_GetCopyright(void);\nPyAPI_FUNC(const char *) Py_GetCompiler(void);\nPyAPI_FUNC(const char *) Py_GetBuildInfo(void);\n\n/* Signals */\ntypedef void (*PyOS_sighandler_t)(int);\nPyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);\nPyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_PYLIFECYCLE_H\n#  include  \"cpython/pylifecycle.h\"\n#  undef Py_CPYTHON_PYLIFECYCLE_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_PYLIFECYCLE_H */\n"}, "116": {"id": 116, "path": "/usr/include/python3.8/pymacconfig.h", "content": "#ifndef PYMACCONFIG_H\n#define PYMACCONFIG_H\n     /*\n      * This file moves some of the autoconf magic to compile-time\n      * when building on MacOSX. This is needed for building 4-way\n      * universal binaries and for 64-bit universal binaries because\n      * the values redefined below aren't configure-time constant but\n      * only compile-time constant in these scenarios.\n      */\n\n#if defined(__APPLE__)\n\n# undef SIZEOF_LONG\n# undef SIZEOF_PTHREAD_T\n# undef SIZEOF_SIZE_T\n# undef SIZEOF_TIME_T\n# undef SIZEOF_VOID_P\n# undef SIZEOF__BOOL\n# undef SIZEOF_UINTPTR_T\n# undef SIZEOF_PTHREAD_T\n# undef WORDS_BIGENDIAN\n# undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754\n# undef DOUBLE_IS_BIG_ENDIAN_IEEE754\n# undef DOUBLE_IS_LITTLE_ENDIAN_IEEE754\n# undef HAVE_GCC_ASM_FOR_X87\n\n#    undef VA_LIST_IS_ARRAY\n#    if defined(__LP64__) && defined(__x86_64__)\n#        define VA_LIST_IS_ARRAY 1\n#    endif\n\n#    undef HAVE_LARGEFILE_SUPPORT\n#    ifndef __LP64__\n#         define HAVE_LARGEFILE_SUPPORT 1\n#    endif\n\n#    undef SIZEOF_LONG\n#    ifdef __LP64__\n#        define SIZEOF__BOOL            1\n#        define SIZEOF__BOOL            1\n#        define SIZEOF_LONG             8\n#        define SIZEOF_PTHREAD_T        8\n#        define SIZEOF_SIZE_T           8\n#        define SIZEOF_TIME_T           8\n#        define SIZEOF_VOID_P           8\n#        define SIZEOF_UINTPTR_T        8\n#        define SIZEOF_PTHREAD_T        8\n#    else\n#        ifdef __ppc__\n#           define SIZEOF__BOOL         4\n#        else\n#           define SIZEOF__BOOL         1\n#        endif\n#        define SIZEOF_LONG             4\n#        define SIZEOF_PTHREAD_T        4\n#        define SIZEOF_SIZE_T           4\n#        define SIZEOF_TIME_T           4\n#        define SIZEOF_VOID_P           4\n#        define SIZEOF_UINTPTR_T        4\n#        define SIZEOF_PTHREAD_T        4\n#    endif\n\n#    if defined(__LP64__)\n     /* MacOSX 10.4 (the first release to support 64-bit code\n      * at all) only supports 64-bit in the UNIX layer.\n      * Therefore suppress the toolbox-glue in 64-bit mode.\n      */\n\n    /* In 64-bit mode setpgrp always has no arguments, in 32-bit\n     * mode that depends on the compilation environment\n     */\n#       undef SETPGRP_HAVE_ARG\n\n#    endif\n\n#ifdef __BIG_ENDIAN__\n#define WORDS_BIGENDIAN 1\n#define DOUBLE_IS_BIG_ENDIAN_IEEE754\n#else\n#define DOUBLE_IS_LITTLE_ENDIAN_IEEE754\n#endif /* __BIG_ENDIAN */\n\n#ifdef __i386__\n# define HAVE_GCC_ASM_FOR_X87\n#endif\n\n    /*\n     * The definition in pyconfig.h is only valid on the OS release\n     * where configure ran on and not necessarily for all systems where\n     * the executable can be used on.\n     *\n     * Specifically: OSX 10.4 has limited supported for '%zd', while\n     * 10.5 has full support for '%zd'. A binary built on 10.5 won't\n     * work properly on 10.4 unless we suppress the definition\n     * of PY_FORMAT_SIZE_T\n     */\n#undef  PY_FORMAT_SIZE_T\n\n\n#endif /* defined(_APPLE__) */\n\n#endif /* PYMACCONFIG_H */\n"}, "117": {"id": 117, "path": "/usr/include/python3.8/pymacro.h", "content": "#ifndef Py_PYMACRO_H\n#define Py_PYMACRO_H\n\n/* Minimum value between x and y */\n#define Py_MIN(x, y) (((x) > (y)) ? (y) : (x))\n\n/* Maximum value between x and y */\n#define Py_MAX(x, y) (((x) > (y)) ? (x) : (y))\n\n/* Absolute value of the number x */\n#define Py_ABS(x) ((x) < 0 ? -(x) : (x))\n\n#define _Py_XSTRINGIFY(x) #x\n\n/* Convert the argument to a string. For example, Py_STRINGIFY(123) is replaced\n   with \"123\" by the preprocessor. Defines are also replaced by their value.\n   For example Py_STRINGIFY(__LINE__) is replaced by the line number, not\n   by \"__LINE__\". */\n#define Py_STRINGIFY(x) _Py_XSTRINGIFY(x)\n\n/* Get the size of a structure member in bytes */\n#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)\n\n/* Argument must be a char or an int in [-128, 127] or [0, 255]. */\n#define Py_CHARMASK(c) ((unsigned char)((c) & 0xff))\n\n/* Assert a build-time dependency, as an expression.\n\n   Your compile will fail if the condition isn't true, or can't be evaluated\n   by the compiler. This can be used in an expression: its value is 0.\n\n   Example:\n\n   #define foo_to_char(foo)  \\\n       ((char *)(foo)        \\\n        + Py_BUILD_ASSERT_EXPR(offsetof(struct foo, string) == 0))\n\n   Written by Rusty Russell, public domain, http://ccodearchive.net/ */\n#define Py_BUILD_ASSERT_EXPR(cond) \\\n    (sizeof(char [1 - 2*!(cond)]) - 1)\n\n#define Py_BUILD_ASSERT(cond)  do {         \\\n        (void)Py_BUILD_ASSERT_EXPR(cond);   \\\n    } while(0)\n\n/* Get the number of elements in a visible array\n\n   This does not work on pointers, or arrays declared as [], or function\n   parameters. With correct compiler support, such usage will cause a build\n   error (see Py_BUILD_ASSERT_EXPR).\n\n   Written by Rusty Russell, public domain, http://ccodearchive.net/\n\n   Requires at GCC 3.1+ */\n#if (defined(__GNUC__) && !defined(__STRICT_ANSI__) && \\\n    (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ >= 4)))\n/* Two gcc extensions.\n   &a[0] degrades to a pointer: a different type from an array */\n#define Py_ARRAY_LENGTH(array) \\\n    (sizeof(array) / sizeof((array)[0]) \\\n     + Py_BUILD_ASSERT_EXPR(!__builtin_types_compatible_p(typeof(array), \\\n                                                          typeof(&(array)[0]))))\n#else\n#define Py_ARRAY_LENGTH(array) \\\n    (sizeof(array) / sizeof((array)[0]))\n#endif\n\n\n/* Define macros for inline documentation. */\n#define PyDoc_VAR(name) static const char name[]\n#define PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)\n#ifdef WITH_DOC_STRINGS\n#define PyDoc_STR(str) str\n#else\n#define PyDoc_STR(str) \"\"\n#endif\n\n/* Below \"a\" is a power of 2. */\n/* Round down size \"n\" to be a multiple of \"a\". */\n#define _Py_SIZE_ROUND_DOWN(n, a) ((size_t)(n) & ~(size_t)((a) - 1))\n/* Round up size \"n\" to be a multiple of \"a\". */\n#define _Py_SIZE_ROUND_UP(n, a) (((size_t)(n) + \\\n        (size_t)((a) - 1)) & ~(size_t)((a) - 1))\n/* Round pointer \"p\" down to the closest \"a\"-aligned address <= \"p\". */\n#define _Py_ALIGN_DOWN(p, a) ((void *)((uintptr_t)(p) & ~(uintptr_t)((a) - 1)))\n/* Round pointer \"p\" up to the closest \"a\"-aligned address >= \"p\". */\n#define _Py_ALIGN_UP(p, a) ((void *)(((uintptr_t)(p) + \\\n        (uintptr_t)((a) - 1)) & ~(uintptr_t)((a) - 1)))\n/* Check if pointer \"p\" is aligned to \"a\"-bytes boundary. */\n#define _Py_IS_ALIGNED(p, a) (!((uintptr_t)(p) & (uintptr_t)((a) - 1)))\n\n/* Use this for unused arguments in a function definition to silence compiler\n * warnings. Example:\n *\n * int func(int a, int Py_UNUSED(b)) { return a; }\n */\n#if defined(__GNUC__) || defined(__clang__)\n#  define Py_UNUSED(name) _unused_ ## name __attribute__((unused))\n#else\n#  define Py_UNUSED(name) _unused_ ## name\n#endif\n\n#define Py_UNREACHABLE() \\\n    Py_FatalError(\"Unreachable C code path reached\")\n\n#endif /* Py_PYMACRO_H */\n"}, "118": {"id": 118, "path": "/usr/include/python3.8/pymath.h", "content": "#ifndef Py_PYMATH_H\n#define Py_PYMATH_H\n\n#include \"pyconfig.h\" /* include for defines */\n\n/**************************************************************************\nSymbols and macros to supply platform-independent interfaces to mathematical\nfunctions and constants\n**************************************************************************/\n\n/* Python provides implementations for copysign, round and hypot in\n * Python/pymath.c just in case your math library doesn't provide the\n * functions.\n *\n *Note: PC/pyconfig.h defines copysign as _copysign\n */\n#ifndef HAVE_COPYSIGN\nextern double copysign(double, double);\n#endif\n\n#ifndef HAVE_ROUND\nextern double round(double);\n#endif\n\n#ifndef HAVE_HYPOT\nextern double hypot(double, double);\n#endif\n\n/* extra declarations */\n#ifndef _MSC_VER\n#ifndef __STDC__\nextern double fmod (double, double);\nextern double frexp (double, int *);\nextern double ldexp (double, int);\nextern double modf (double, double *);\nextern double pow(double, double);\n#endif /* __STDC__ */\n#endif /* _MSC_VER */\n\n/* High precision definition of pi and e (Euler)\n * The values are taken from libc6's math.h.\n */\n#ifndef Py_MATH_PIl\n#define Py_MATH_PIl 3.1415926535897932384626433832795029L\n#endif\n#ifndef Py_MATH_PI\n#define Py_MATH_PI 3.14159265358979323846\n#endif\n\n#ifndef Py_MATH_El\n#define Py_MATH_El 2.7182818284590452353602874713526625L\n#endif\n\n#ifndef Py_MATH_E\n#define Py_MATH_E 2.7182818284590452354\n#endif\n\n/* Tau (2pi) to 40 digits, taken from tauday.com/tau-digits. */\n#ifndef Py_MATH_TAU\n#define Py_MATH_TAU 6.2831853071795864769252867665590057683943L\n#endif\n\n\n/* On x86, Py_FORCE_DOUBLE forces a floating-point number out of an x87 FPU\n   register and into a 64-bit memory location, rounding from extended\n   precision to double precision in the process.  On other platforms it does\n   nothing. */\n\n/* we take double rounding as evidence of x87 usage */\n#ifndef Py_LIMITED_API\n#ifndef Py_FORCE_DOUBLE\n#  ifdef X87_DOUBLE_ROUNDING\nPyAPI_FUNC(double) _Py_force_double(double);\n#    define Py_FORCE_DOUBLE(X) (_Py_force_double(X))\n#  else\n#    define Py_FORCE_DOUBLE(X) (X)\n#  endif\n#endif\n#endif\n\n#ifndef Py_LIMITED_API\n#ifdef HAVE_GCC_ASM_FOR_X87\nPyAPI_FUNC(unsigned short) _Py_get_387controlword(void);\nPyAPI_FUNC(void) _Py_set_387controlword(unsigned short);\n#endif\n#endif\n\n/* Py_IS_NAN(X)\n * Return 1 if float or double arg is a NaN, else 0.\n * Caution:\n *     X is evaluated more than once.\n *     This may not work on all platforms.  Each platform has *some*\n *     way to spell this, though -- override in pyconfig.h if you have\n *     a platform where it doesn't work.\n * Note: PC/pyconfig.h defines Py_IS_NAN as _isnan\n */\n#ifndef Py_IS_NAN\n#if defined HAVE_DECL_ISNAN && HAVE_DECL_ISNAN == 1\n#define Py_IS_NAN(X) isnan(X)\n#else\n#define Py_IS_NAN(X) ((X) != (X))\n#endif\n#endif\n\n/* Py_IS_INFINITY(X)\n * Return 1 if float or double arg is an infinity, else 0.\n * Caution:\n *    X is evaluated more than once.\n *    This implementation may set the underflow flag if |X| is very small;\n *    it really can't be implemented correctly (& easily) before C99.\n *    Override in pyconfig.h if you have a better spelling on your platform.\n *  Py_FORCE_DOUBLE is used to avoid getting false negatives from a\n *    non-infinite value v sitting in an 80-bit x87 register such that\n *    v becomes infinite when spilled from the register to 64-bit memory.\n * Note: PC/pyconfig.h defines Py_IS_INFINITY as _isinf\n */\n#ifndef Py_IS_INFINITY\n#  if defined HAVE_DECL_ISINF && HAVE_DECL_ISINF == 1\n#    define Py_IS_INFINITY(X) isinf(X)\n#  else\n#    define Py_IS_INFINITY(X) ((X) &&                                   \\\n                               (Py_FORCE_DOUBLE(X)*0.5 == Py_FORCE_DOUBLE(X)))\n#  endif\n#endif\n\n/* Py_IS_FINITE(X)\n * Return 1 if float or double arg is neither infinite nor NAN, else 0.\n * Some compilers (e.g. VisualStudio) have intrisics for this, so a special\n * macro for this particular test is useful\n * Note: PC/pyconfig.h defines Py_IS_FINITE as _finite\n */\n#ifndef Py_IS_FINITE\n#if defined HAVE_DECL_ISFINITE && HAVE_DECL_ISFINITE == 1\n#define Py_IS_FINITE(X) isfinite(X)\n#elif defined HAVE_FINITE\n#define Py_IS_FINITE(X) finite(X)\n#else\n#define Py_IS_FINITE(X) (!Py_IS_INFINITY(X) && !Py_IS_NAN(X))\n#endif\n#endif\n\n/* HUGE_VAL is supposed to expand to a positive double infinity.  Python\n * uses Py_HUGE_VAL instead because some platforms are broken in this\n * respect.  We used to embed code in pyport.h to try to worm around that,\n * but different platforms are broken in conflicting ways.  If you're on\n * a platform where HUGE_VAL is defined incorrectly, fiddle your Python\n * config to #define Py_HUGE_VAL to something that works on your platform.\n */\n#ifndef Py_HUGE_VAL\n#define Py_HUGE_VAL HUGE_VAL\n#endif\n\n/* Py_NAN\n * A value that evaluates to a NaN. On IEEE 754 platforms INF*0 or\n * INF/INF works. Define Py_NO_NAN in pyconfig.h if your platform\n * doesn't support NaNs.\n */\n#if !defined(Py_NAN) && !defined(Py_NO_NAN)\n#if !defined(__INTEL_COMPILER)\n    #define Py_NAN (Py_HUGE_VAL * 0.)\n#else /* __INTEL_COMPILER */\n    #if defined(ICC_NAN_STRICT)\n        #pragma float_control(push)\n        #pragma float_control(precise, on)\n        #pragma float_control(except,  on)\n        #if defined(_MSC_VER)\n            __declspec(noinline)\n        #else /* Linux */\n            __attribute__((noinline))\n        #endif /* _MSC_VER */\n        static double __icc_nan()\n        {\n            return sqrt(-1.0);\n        }\n        #pragma float_control (pop)\n        #define Py_NAN __icc_nan()\n    #else /* ICC_NAN_RELAXED as default for Intel Compiler */\n        static const union { unsigned char buf[8]; double __icc_nan; } __nan_store = {0,0,0,0,0,0,0xf8,0x7f};\n        #define Py_NAN (__nan_store.__icc_nan)\n    #endif /* ICC_NAN_STRICT */\n#endif /* __INTEL_COMPILER */\n#endif\n\n/* Py_OVERFLOWED(X)\n * Return 1 iff a libm function overflowed.  Set errno to 0 before calling\n * a libm function, and invoke this macro after, passing the function\n * result.\n * Caution:\n *    This isn't reliable.  C99 no longer requires libm to set errno under\n *        any exceptional condition, but does require +- HUGE_VAL return\n *        values on overflow.  A 754 box *probably* maps HUGE_VAL to a\n *        double infinity, and we're cool if that's so, unless the input\n *        was an infinity and an infinity is the expected result.  A C89\n *        system sets errno to ERANGE, so we check for that too.  We're\n *        out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or\n *        if the returned result is a NaN, or if a C89 box returns HUGE_VAL\n *        in non-overflow cases.\n *    X is evaluated more than once.\n * Some platforms have better way to spell this, so expect some #ifdef'ery.\n *\n * OpenBSD uses 'isinf()' because a compiler bug on that platform causes\n * the longer macro version to be mis-compiled. This isn't optimal, and\n * should be removed once a newer compiler is available on that platform.\n * The system that had the failure was running OpenBSD 3.2 on Intel, with\n * gcc 2.95.3.\n *\n * According to Tim's checkin, the FreeBSD systems use isinf() to work\n * around a FPE bug on that platform.\n */\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n#define Py_OVERFLOWED(X) isinf(X)\n#else\n#define Py_OVERFLOWED(X) ((X) != 0.0 && (errno == ERANGE ||    \\\n                                         (X) == Py_HUGE_VAL || \\\n                                         (X) == -Py_HUGE_VAL))\n#endif\n\n/* Return whether integral type *type* is signed or not. */\n#define _Py_IntegralTypeSigned(type) ((type)(-1) < 0)\n/* Return the maximum value of integral type *type*. */\n#define _Py_IntegralTypeMax(type) ((_Py_IntegralTypeSigned(type)) ? (((((type)1 << (sizeof(type)*CHAR_BIT - 2)) - 1) << 1) + 1) : ~(type)0)\n/* Return the minimum value of integral type *type*. */\n#define _Py_IntegralTypeMin(type) ((_Py_IntegralTypeSigned(type)) ? -_Py_IntegralTypeMax(type) - 1 : 0)\n/* Check whether *v* is in the range of integral type *type*. This is most\n * useful if *v* is floating-point, since demoting a floating-point *v* to an\n * integral type that cannot represent *v*'s integral part is undefined\n * behavior. */\n#define _Py_InIntegralTypeRange(type, v) (_Py_IntegralTypeMin(type) <= v && v <= _Py_IntegralTypeMax(type))\n\n#endif /* Py_PYMATH_H */\n"}, "119": {"id": 119, "path": "/usr/include/python3.8/pymem.h", "content": "/* The PyMem_ family:  low-level memory allocation interfaces.\n   See objimpl.h for the PyObject_ memory family.\n*/\n\n#ifndef Py_PYMEM_H\n#define Py_PYMEM_H\n\n#include \"pyport.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* BEWARE:\n\n   Each interface exports both functions and macros.  Extension modules should\n   use the functions, to ensure binary compatibility across Python versions.\n   Because the Python implementation is free to change internal details, and\n   the macros may (or may not) expose details for speed, if you do use the\n   macros you must recompile your extensions with each Python release.\n\n   Never mix calls to PyMem_ with calls to the platform malloc/realloc/\n   calloc/free.  For example, on Windows different DLLs may end up using\n   different heaps, and if you use PyMem_Malloc you'll get the memory from the\n   heap used by the Python DLL; it could be a disaster if you free()'ed that\n   directly in your own extension.  Using PyMem_Free instead ensures Python\n   can return the memory to the proper heap.  As another example, in\n   PYMALLOC_DEBUG mode, Python wraps all calls to all PyMem_ and PyObject_\n   memory functions in special debugging wrappers that add additional\n   debugging info to dynamic memory blocks.  The system routines have no idea\n   what to do with that stuff, and the Python wrappers have no idea what to do\n   with raw blocks obtained directly by the system routines then.\n\n   The GIL must be held when using these APIs.\n*/\n\n/*\n * Raw memory interface\n * ====================\n */\n\n/* Functions\n\n   Functions supplying platform-independent semantics for malloc/realloc/\n   free.  These functions make sure that allocating 0 bytes returns a distinct\n   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL\n   may be returned), even if the platform malloc and realloc don't.\n   Returned pointers must be checked for NULL explicitly.  No action is\n   performed on failure (no exception is set, no warning is printed, etc).\n*/\n\nPyAPI_FUNC(void *) PyMem_Malloc(size_t size);\nPyAPI_FUNC(void *) PyMem_Realloc(void *ptr, size_t new_size);\nPyAPI_FUNC(void) PyMem_Free(void *ptr);\n\n/* Macros. */\n\n/* PyMem_MALLOC(0) means malloc(1). Some systems would return NULL\n   for malloc(0), which would be treated as an error. Some platforms\n   would return a pointer with no memory behind it, which would break\n   pymalloc. To solve these problems, allocate an extra byte. */\n/* Returns NULL to indicate error if a negative size or size larger than\n   Py_ssize_t can represent is supplied.  Helps prevents security holes. */\n#define PyMem_MALLOC(n)         PyMem_Malloc(n)\n#define PyMem_REALLOC(p, n)     PyMem_Realloc(p, n)\n#define PyMem_FREE(p)           PyMem_Free(p)\n\n/*\n * Type-oriented memory interface\n * ==============================\n *\n * Allocate memory for n objects of the given type.  Returns a new pointer\n * or NULL if the request was too large or memory allocation failed.  Use\n * these macros rather than doing the multiplication yourself so that proper\n * overflow checking is always done.\n */\n\n#define PyMem_New(type, n) \\\n  ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :      \\\n        ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )\n#define PyMem_NEW(type, n) \\\n  ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :      \\\n        ( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )\n\n/*\n * The value of (p) is always clobbered by this macro regardless of success.\n * The caller MUST check if (p) is NULL afterwards and deal with the memory\n * error if so.  This means the original value of (p) MUST be saved for the\n * caller's memory error handler to not lose track of it.\n */\n#define PyMem_Resize(p, type, n) \\\n  ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :        \\\n        (type *) PyMem_Realloc((p), (n) * sizeof(type)) )\n#define PyMem_RESIZE(p, type, n) \\\n  ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :        \\\n        (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )\n\n/* PyMem{Del,DEL} are left over from ancient days, and shouldn't be used\n * anymore.  They're just confusing aliases for PyMem_{Free,FREE} now.\n */\n#define PyMem_Del               PyMem_Free\n#define PyMem_DEL               PyMem_FREE\n\n/* bpo-35053: expose _Py_tracemalloc_config for performance:\n   _Py_NewReference() needs an efficient check to test if tracemalloc is\n   tracing.\n\n   It has to be defined in pymem.h, before object.h is included. */\nstruct _PyTraceMalloc_Config {\n    /* Module initialized?\n       Variable protected by the GIL */\n    enum {\n        TRACEMALLOC_NOT_INITIALIZED,\n        TRACEMALLOC_INITIALIZED,\n        TRACEMALLOC_FINALIZED\n    } initialized;\n\n    /* Is tracemalloc tracing memory allocations?\n       Variable protected by the GIL */\n    int tracing;\n\n    /* limit of the number of frames in a traceback, 1 by default.\n       Variable protected by the GIL. */\n    int max_nframe;\n\n    /* use domain in trace key?\n       Variable protected by the GIL. */\n    int use_domain;\n};\n\nPyAPI_DATA(struct _PyTraceMalloc_Config) _Py_tracemalloc_config;\n\n#define _PyTraceMalloc_Config_INIT \\\n    {.initialized = TRACEMALLOC_NOT_INITIALIZED, \\\n     .tracing = 0, \\\n     .max_nframe = 1, \\\n     .use_domain = 0}\n\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_PYMEM_H\n#  include  \"cpython/pymem.h\"\n#  undef Py_CPYTHON_PYMEM_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_PYMEM_H */\n"}, "120": {"id": 120, "path": "/usr/include/python3.8/pyport.h", "content": "#ifndef Py_PYPORT_H\n#define Py_PYPORT_H\n\n#include \"pyconfig.h\" /* include for defines */\n\n#include <inttypes.h>\n\n\n/* Defines to build Python and its standard library:\n *\n * - Py_BUILD_CORE: Build Python core. Give access to Python internals, but\n *   should not be used by third-party modules.\n * - Py_BUILD_CORE_BUILTIN: Build a Python stdlib module as a built-in module.\n * - Py_BUILD_CORE_MODULE: Build a Python stdlib module as a dynamic library.\n *\n * Py_BUILD_CORE_BUILTIN and Py_BUILD_CORE_MODULE imply Py_BUILD_CORE.\n *\n * On Windows, Py_BUILD_CORE_MODULE exports \"PyInit_xxx\" symbol, whereas\n * Py_BUILD_CORE_BUILTIN does not.\n */\n#if defined(Py_BUILD_CORE_BUILTIN) && !defined(Py_BUILD_CORE)\n#  define Py_BUILD_CORE\n#endif\n#if defined(Py_BUILD_CORE_MODULE) && !defined(Py_BUILD_CORE)\n#  define Py_BUILD_CORE\n#endif\n\n\n/**************************************************************************\nSymbols and macros to supply platform-independent interfaces to basic\nC language & library operations whose spellings vary across platforms.\n\nPlease try to make documentation here as clear as possible:  by definition,\nthe stuff here is trying to illuminate C's darkest corners.\n\nConfig #defines referenced here:\n\nSIGNED_RIGHT_SHIFT_ZERO_FILLS\nMeaning:  To be defined iff i>>j does not extend the sign bit when i is a\n          signed integral type and i < 0.\nUsed in:  Py_ARITHMETIC_RIGHT_SHIFT\n\nPy_DEBUG\nMeaning:  Extra checks compiled in for debug mode.\nUsed in:  Py_SAFE_DOWNCAST\n\n**************************************************************************/\n\n/* typedefs for some C9X-defined synonyms for integral types.\n *\n * The names in Python are exactly the same as the C9X names, except with a\n * Py_ prefix.  Until C9X is universally implemented, this is the only way\n * to ensure that Python gets reliable names that don't conflict with names\n * in non-Python code that are playing their own tricks to define the C9X\n * names.\n *\n * NOTE: don't go nuts here!  Python has no use for *most* of the C9X\n * integral synonyms.  Only define the ones we actually need.\n */\n\n/* long long is required. Ensure HAVE_LONG_LONG is defined for compatibility. */\n#ifndef HAVE_LONG_LONG\n#define HAVE_LONG_LONG 1\n#endif\n#ifndef PY_LONG_LONG\n#define PY_LONG_LONG long long\n/* If LLONG_MAX is defined in limits.h, use that. */\n#define PY_LLONG_MIN LLONG_MIN\n#define PY_LLONG_MAX LLONG_MAX\n#define PY_ULLONG_MAX ULLONG_MAX\n#endif\n\n#define PY_UINT32_T uint32_t\n#define PY_UINT64_T uint64_t\n\n/* Signed variants of the above */\n#define PY_INT32_T int32_t\n#define PY_INT64_T int64_t\n\n/* If PYLONG_BITS_IN_DIGIT is not defined then we'll use 30-bit digits if all\n   the necessary integer types are available, and we're on a 64-bit platform\n   (as determined by SIZEOF_VOID_P); otherwise we use 15-bit digits. */\n\n#ifndef PYLONG_BITS_IN_DIGIT\n#if SIZEOF_VOID_P >= 8\n#define PYLONG_BITS_IN_DIGIT 30\n#else\n#define PYLONG_BITS_IN_DIGIT 15\n#endif\n#endif\n\n/* uintptr_t is the C9X name for an unsigned integral type such that a\n * legitimate void* can be cast to uintptr_t and then back to void* again\n * without loss of information.  Similarly for intptr_t, wrt a signed\n * integral type.\n */\ntypedef uintptr_t       Py_uintptr_t;\ntypedef intptr_t        Py_intptr_t;\n\n/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==\n * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an\n * unsigned integral type).  See PEP 353 for details.\n */\n#ifdef HAVE_SSIZE_T\ntypedef ssize_t         Py_ssize_t;\n#elif SIZEOF_VOID_P == SIZEOF_SIZE_T\ntypedef Py_intptr_t     Py_ssize_t;\n#else\n#   error \"Python needs a typedef for Py_ssize_t in pyport.h.\"\n#endif\n\n/* Py_hash_t is the same size as a pointer. */\n#define SIZEOF_PY_HASH_T SIZEOF_SIZE_T\ntypedef Py_ssize_t Py_hash_t;\n/* Py_uhash_t is the unsigned equivalent needed to calculate numeric hash. */\n#define SIZEOF_PY_UHASH_T SIZEOF_SIZE_T\ntypedef size_t Py_uhash_t;\n\n/* Only used for compatibility with code that may not be PY_SSIZE_T_CLEAN. */\n#ifdef PY_SSIZE_T_CLEAN\ntypedef Py_ssize_t Py_ssize_clean_t;\n#else\ntypedef int Py_ssize_clean_t;\n#endif\n\n/* Largest possible value of size_t. */\n#define PY_SIZE_MAX SIZE_MAX\n\n/* Largest positive value of type Py_ssize_t. */\n#define PY_SSIZE_T_MAX ((Py_ssize_t)(((size_t)-1)>>1))\n/* Smallest negative value of type Py_ssize_t. */\n#define PY_SSIZE_T_MIN (-PY_SSIZE_T_MAX-1)\n\n/* PY_FORMAT_SIZE_T is a platform-specific modifier for use in a printf\n * format to convert an argument with the width of a size_t or Py_ssize_t.\n * C99 introduced \"z\" for this purpose, but not all platforms support that;\n * e.g., MS compilers use \"I\" instead.\n *\n * These \"high level\" Python format functions interpret \"z\" correctly on\n * all platforms (Python interprets the format string itself, and does whatever\n * the platform C requires to convert a size_t/Py_ssize_t argument):\n *\n *     PyBytes_FromFormat\n *     PyErr_Format\n *     PyBytes_FromFormatV\n *     PyUnicode_FromFormatV\n *\n * Lower-level uses require that you interpolate the correct format modifier\n * yourself (e.g., calling printf, fprintf, sprintf, PyOS_snprintf); for\n * example,\n *\n *     Py_ssize_t index;\n *     fprintf(stderr, \"index %\" PY_FORMAT_SIZE_T \"d sucks\\n\", index);\n *\n * That will expand to %ld, or %Id, or to something else correct for a\n * Py_ssize_t on the platform.\n */\n#ifndef PY_FORMAT_SIZE_T\n#   if SIZEOF_SIZE_T == SIZEOF_INT && !defined(__APPLE__)\n#       define PY_FORMAT_SIZE_T \"\"\n#   elif SIZEOF_SIZE_T == SIZEOF_LONG\n#       define PY_FORMAT_SIZE_T \"l\"\n#   elif defined(MS_WINDOWS)\n#       define PY_FORMAT_SIZE_T \"I\"\n#   else\n#       error \"This platform's pyconfig.h needs to define PY_FORMAT_SIZE_T\"\n#   endif\n#endif\n\n/* Py_LOCAL can be used instead of static to get the fastest possible calling\n * convention for functions that are local to a given module.\n *\n * Py_LOCAL_INLINE does the same thing, and also explicitly requests inlining,\n * for platforms that support that.\n *\n * If PY_LOCAL_AGGRESSIVE is defined before python.h is included, more\n * \"aggressive\" inlining/optimization is enabled for the entire module.  This\n * may lead to code bloat, and may slow things down for those reasons.  It may\n * also lead to errors, if the code relies on pointer aliasing.  Use with\n * care.\n *\n * NOTE: You can only use this for functions that are entirely local to a\n * module; functions that are exported via method tables, callbacks, etc,\n * should keep using static.\n */\n\n#if defined(_MSC_VER)\n#  if defined(PY_LOCAL_AGGRESSIVE)\n   /* enable more aggressive optimization for visual studio */\n#  pragma optimize(\"agtw\", on)\n#endif\n   /* ignore warnings if the compiler decides not to inline a function */\n#  pragma warning(disable: 4710)\n   /* fastest possible local call under MSVC */\n#  define Py_LOCAL(type) static type __fastcall\n#  define Py_LOCAL_INLINE(type) static __inline type __fastcall\n#else\n#  define Py_LOCAL(type) static type\n#  define Py_LOCAL_INLINE(type) static inline type\n#endif\n\n/* Py_MEMCPY is kept for backwards compatibility,\n * see https://bugs.python.org/issue28126 */\n#define Py_MEMCPY memcpy\n\n#include <stdlib.h>\n\n#ifdef HAVE_IEEEFP_H\n#include <ieeefp.h>  /* needed for 'finite' declaration on some platforms */\n#endif\n\n#include <math.h> /* Moved here from the math section, before extern \"C\" */\n\n/********************************************\n * WRAPPER FOR <time.h> and/or <sys/time.h> *\n ********************************************/\n\n#ifdef TIME_WITH_SYS_TIME\n#include <sys/time.h>\n#include <time.h>\n#else /* !TIME_WITH_SYS_TIME */\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#else /* !HAVE_SYS_TIME_H */\n#include <time.h>\n#endif /* !HAVE_SYS_TIME_H */\n#endif /* !TIME_WITH_SYS_TIME */\n\n\n/******************************\n * WRAPPER FOR <sys/select.h> *\n ******************************/\n\n/* NB caller must include <sys/types.h> */\n\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif /* !HAVE_SYS_SELECT_H */\n\n/*******************************\n * stat() and fstat() fiddling *\n *******************************/\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#elif defined(HAVE_STAT_H)\n#include <stat.h>\n#endif\n\n#ifndef S_IFMT\n/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */\n#define S_IFMT 0170000\n#endif\n\n#ifndef S_IFLNK\n/* Windows doesn't define S_IFLNK but posixmodule.c maps\n * IO_REPARSE_TAG_SYMLINK to S_IFLNK */\n#  define S_IFLNK 0120000\n#endif\n\n#ifndef S_ISREG\n#define S_ISREG(x) (((x) & S_IFMT) == S_IFREG)\n#endif\n\n#ifndef S_ISDIR\n#define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)\n#endif\n\n#ifndef S_ISCHR\n#define S_ISCHR(x) (((x) & S_IFMT) == S_IFCHR)\n#endif\n\n#ifdef __cplusplus\n/* Move this down here since some C++ #include's don't like to be included\n   inside an extern \"C\" */\nextern \"C\" {\n#endif\n\n\n/* Py_ARITHMETIC_RIGHT_SHIFT\n * C doesn't define whether a right-shift of a signed integer sign-extends\n * or zero-fills.  Here a macro to force sign extension:\n * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)\n *    Return I >> J, forcing sign extension.  Arithmetically, return the\n *    floor of I/2**J.\n * Requirements:\n *    I should have signed integer type.  In the terminology of C99, this can\n *    be either one of the five standard signed integer types (signed char,\n *    short, int, long, long long) or an extended signed integer type.\n *    J is an integer >= 0 and strictly less than the number of bits in the\n *    type of I (because C doesn't define what happens for J outside that\n *    range either).\n *    TYPE used to specify the type of I, but is now ignored.  It's been left\n *    in for backwards compatibility with versions <= 2.6 or 3.0.\n * Caution:\n *    I may be evaluated more than once.\n */\n#ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS\n#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) \\\n    ((I) < 0 ? -1-((-1-(I)) >> (J)) : (I) >> (J))\n#else\n#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) >> (J))\n#endif\n\n/* Py_FORCE_EXPANSION(X)\n * \"Simply\" returns its argument.  However, macro expansions within the\n * argument are evaluated.  This unfortunate trickery is needed to get\n * token-pasting to work as desired in some cases.\n */\n#define Py_FORCE_EXPANSION(X) X\n\n/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)\n * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this\n * assert-fails if any information is lost.\n * Caution:\n *    VALUE may be evaluated more than once.\n */\n#ifdef Py_DEBUG\n#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) \\\n    (assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))\n#else\n#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)\n#endif\n\n/* Py_SET_ERRNO_ON_MATH_ERROR(x)\n * If a libm function did not set errno, but it looks like the result\n * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno\n * to 0 before calling a libm function, and invoke this macro after,\n * passing the function result.\n * Caution:\n *    This isn't reliable.  See Py_OVERFLOWED comments.\n *    X is evaluated more than once.\n */\n#if defined(__FreeBSD__) || defined(__OpenBSD__) || (defined(__hpux) && defined(__ia64))\n#define _Py_SET_EDOM_FOR_NAN(X) if (isnan(X)) errno = EDOM;\n#else\n#define _Py_SET_EDOM_FOR_NAN(X) ;\n#endif\n#define Py_SET_ERRNO_ON_MATH_ERROR(X) \\\n    do { \\\n        if (errno == 0) { \\\n            if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL) \\\n                errno = ERANGE; \\\n            else _Py_SET_EDOM_FOR_NAN(X) \\\n        } \\\n    } while(0)\n\n/* Py_SET_ERANGE_IF_OVERFLOW(x)\n * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.\n */\n#define Py_SET_ERANGE_IF_OVERFLOW(X) Py_SET_ERRNO_ON_MATH_ERROR(X)\n\n/* Py_ADJUST_ERANGE1(x)\n * Py_ADJUST_ERANGE2(x, y)\n * Set errno to 0 before calling a libm function, and invoke one of these\n * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful\n * for functions returning complex results).  This makes two kinds of\n * adjustments to errno:  (A) If it looks like the platform libm set\n * errno=ERANGE due to underflow, clear errno. (B) If it looks like the\n * platform libm overflowed but didn't set errno, force errno to ERANGE.  In\n * effect, we're trying to force a useful implementation of C89 errno\n * behavior.\n * Caution:\n *    This isn't reliable.  See Py_OVERFLOWED comments.\n *    X and Y may be evaluated more than once.\n */\n#define Py_ADJUST_ERANGE1(X)                                            \\\n    do {                                                                \\\n        if (errno == 0) {                                               \\\n            if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)              \\\n                errno = ERANGE;                                         \\\n        }                                                               \\\n        else if (errno == ERANGE && (X) == 0.0)                         \\\n            errno = 0;                                                  \\\n    } while(0)\n\n#define Py_ADJUST_ERANGE2(X, Y)                                         \\\n    do {                                                                \\\n        if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||                \\\n            (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {                \\\n                        if (errno == 0)                                 \\\n                                errno = ERANGE;                         \\\n        }                                                               \\\n        else if (errno == ERANGE)                                       \\\n            errno = 0;                                                  \\\n    } while(0)\n\n/*  The functions _Py_dg_strtod and _Py_dg_dtoa in Python/dtoa.c (which are\n *  required to support the short float repr introduced in Python 3.1) require\n *  that the floating-point unit that's being used for arithmetic operations\n *  on C doubles is set to use 53-bit precision.  It also requires that the\n *  FPU rounding mode is round-half-to-even, but that's less often an issue.\n *\n *  If your FPU isn't already set to 53-bit precision/round-half-to-even, and\n *  you want to make use of _Py_dg_strtod and _Py_dg_dtoa, then you should\n *\n *     #define HAVE_PY_SET_53BIT_PRECISION 1\n *\n *  and also give appropriate definitions for the following three macros:\n *\n *    _PY_SET_53BIT_PRECISION_START : store original FPU settings, and\n *        set FPU to 53-bit precision/round-half-to-even\n *    _PY_SET_53BIT_PRECISION_END : restore original FPU settings\n *    _PY_SET_53BIT_PRECISION_HEADER : any variable declarations needed to\n *        use the two macros above.\n *\n * The macros are designed to be used within a single C function: see\n * Python/pystrtod.c for an example of their use.\n */\n\n/* get and set x87 control word for gcc/x86 */\n#ifdef HAVE_GCC_ASM_FOR_X87\n#define HAVE_PY_SET_53BIT_PRECISION 1\n/* _Py_get/set_387controlword functions are defined in Python/pymath.c */\n#define _Py_SET_53BIT_PRECISION_HEADER                          \\\n    unsigned short old_387controlword, new_387controlword\n#define _Py_SET_53BIT_PRECISION_START                                   \\\n    do {                                                                \\\n        old_387controlword = _Py_get_387controlword();                  \\\n        new_387controlword = (old_387controlword & ~0x0f00) | 0x0200; \\\n        if (new_387controlword != old_387controlword)                   \\\n            _Py_set_387controlword(new_387controlword);                 \\\n    } while (0)\n#define _Py_SET_53BIT_PRECISION_END                             \\\n    if (new_387controlword != old_387controlword)               \\\n        _Py_set_387controlword(old_387controlword)\n#endif\n\n/* get and set x87 control word for VisualStudio/x86 */\n#if defined(_MSC_VER) && !defined(_WIN64) && !defined(_M_ARM) /* x87 not supported in 64-bit or ARM */\n#define HAVE_PY_SET_53BIT_PRECISION 1\n#define _Py_SET_53BIT_PRECISION_HEADER \\\n    unsigned int old_387controlword, new_387controlword, out_387controlword\n/* We use the __control87_2 function to set only the x87 control word.\n   The SSE control word is unaffected. */\n#define _Py_SET_53BIT_PRECISION_START                                   \\\n    do {                                                                \\\n        __control87_2(0, 0, &old_387controlword, NULL);                 \\\n        new_387controlword =                                            \\\n          (old_387controlword & ~(_MCW_PC | _MCW_RC)) | (_PC_53 | _RC_NEAR); \\\n        if (new_387controlword != old_387controlword)                   \\\n            __control87_2(new_387controlword, _MCW_PC | _MCW_RC,        \\\n                          &out_387controlword, NULL);                   \\\n    } while (0)\n#define _Py_SET_53BIT_PRECISION_END                                     \\\n    do {                                                                \\\n        if (new_387controlword != old_387controlword)                   \\\n            __control87_2(old_387controlword, _MCW_PC | _MCW_RC,        \\\n                          &out_387controlword, NULL);                   \\\n    } while (0)\n#endif\n\n#ifdef HAVE_GCC_ASM_FOR_MC68881\n#define HAVE_PY_SET_53BIT_PRECISION 1\n#define _Py_SET_53BIT_PRECISION_HEADER \\\n  unsigned int old_fpcr, new_fpcr\n#define _Py_SET_53BIT_PRECISION_START                                   \\\n  do {                                                                  \\\n    __asm__ (\"fmove.l %%fpcr,%0\" : \"=g\" (old_fpcr));                    \\\n    /* Set double precision / round to nearest.  */                     \\\n    new_fpcr = (old_fpcr & ~0xf0) | 0x80;                               \\\n    if (new_fpcr != old_fpcr)                                           \\\n      __asm__ volatile (\"fmove.l %0,%%fpcr\" : : \"g\" (new_fpcr));        \\\n  } while (0)\n#define _Py_SET_53BIT_PRECISION_END                                     \\\n  do {                                                                  \\\n    if (new_fpcr != old_fpcr)                                           \\\n      __asm__ volatile (\"fmove.l %0,%%fpcr\" : : \"g\" (old_fpcr));        \\\n  } while (0)\n#endif\n\n/* default definitions are empty */\n#ifndef HAVE_PY_SET_53BIT_PRECISION\n#define _Py_SET_53BIT_PRECISION_HEADER\n#define _Py_SET_53BIT_PRECISION_START\n#define _Py_SET_53BIT_PRECISION_END\n#endif\n\n/* If we can't guarantee 53-bit precision, don't use the code\n   in Python/dtoa.c, but fall back to standard code.  This\n   means that repr of a float will be long (17 sig digits).\n\n   Realistically, there are two things that could go wrong:\n\n   (1) doubles aren't IEEE 754 doubles, or\n   (2) we're on x86 with the rounding precision set to 64-bits\n       (extended precision), and we don't know how to change\n       the rounding precision.\n */\n\n#if !defined(DOUBLE_IS_LITTLE_ENDIAN_IEEE754) && \\\n    !defined(DOUBLE_IS_BIG_ENDIAN_IEEE754) && \\\n    !defined(DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754)\n#define PY_NO_SHORT_FLOAT_REPR\n#endif\n\n/* double rounding is symptomatic of use of extended precision on x86.  If\n   we're seeing double rounding, and we don't have any mechanism available for\n   changing the FPU rounding precision, then don't use Python/dtoa.c. */\n#if defined(X87_DOUBLE_ROUNDING) && !defined(HAVE_PY_SET_53BIT_PRECISION)\n#define PY_NO_SHORT_FLOAT_REPR\n#endif\n\n\n/* Py_DEPRECATED(version)\n * Declare a variable, type, or function deprecated.\n * The macro must be placed before the declaration.\n * Usage:\n *    Py_DEPRECATED(3.3) extern int old_var;\n *    Py_DEPRECATED(3.4) typedef int T1;\n *    Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);\n */\n#if defined(__GNUC__) \\\n    && ((__GNUC__ >= 4) || (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))\n#define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))\n#elif defined(_MSC_VER)\n#define Py_DEPRECATED(VERSION) __declspec(deprecated( \\\n                                          \"deprecated in \" #VERSION))\n#else\n#define Py_DEPRECATED(VERSION_UNUSED)\n#endif\n\n\n/* _Py_HOT_FUNCTION\n * The hot attribute on a function is used to inform the compiler that the\n * function is a hot spot of the compiled program. The function is optimized\n * more aggressively and on many target it is placed into special subsection of\n * the text section so all hot functions appears close together improving\n * locality.\n *\n * Usage:\n *    int _Py_HOT_FUNCTION x(void) { return 3; }\n *\n * Issue #28618: This attribute must not be abused, otherwise it can have a\n * negative effect on performance. Only the functions were Python spend most of\n * its time must use it. Use a profiler when running performance benchmark\n * suite to find these functions.\n */\n#if defined(__GNUC__) \\\n    && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 3))\n#define _Py_HOT_FUNCTION __attribute__((hot))\n#else\n#define _Py_HOT_FUNCTION\n#endif\n\n/* _Py_NO_INLINE\n * Disable inlining on a function. For example, it helps to reduce the C stack\n * consumption.\n *\n * Usage:\n *    int _Py_NO_INLINE x(void) { return 3; }\n */\n#if defined(_MSC_VER)\n#  define _Py_NO_INLINE __declspec(noinline)\n#elif defined(__GNUC__) || defined(__clang__)\n#  define _Py_NO_INLINE __attribute__ ((noinline))\n#else\n#  define _Py_NO_INLINE\n#endif\n\n/**************************************************************************\nPrototypes that are missing from the standard include files on some systems\n(and possibly only some versions of such systems.)\n\nPlease be conservative with adding new ones, document them and enclose them\nin platform-specific #ifdefs.\n**************************************************************************/\n\n#ifdef SOLARIS\n/* Unchecked */\nextern int gethostname(char *, int);\n#endif\n\n#ifdef HAVE__GETPTY\n#include <sys/types.h>          /* we need to import mode_t */\nextern char * _getpty(int *, int, mode_t, int);\n#endif\n\n/* On QNX 6, struct termio must be declared by including sys/termio.h\n   if TCGETA, TCSETA, TCSETAW, or TCSETAF are used.  sys/termio.h must\n   be included before termios.h or it will generate an error. */\n#if defined(HAVE_SYS_TERMIO_H) && !defined(__hpux)\n#include <sys/termio.h>\n#endif\n\n\n/* On 4.4BSD-descendants, ctype functions serves the whole range of\n * wchar_t character set rather than single byte code points only.\n * This characteristic can break some operations of string object\n * including str.upper() and str.split() on UTF-8 locales.  This\n * workaround was provided by Tim Robbins of FreeBSD project.\n */\n\n#if defined(__APPLE__)\n#  define _PY_PORT_CTYPE_UTF8_ISSUE\n#endif\n\n#ifdef _PY_PORT_CTYPE_UTF8_ISSUE\n#ifndef __cplusplus\n   /* The workaround below is unsafe in C++ because\n    * the <locale> defines these symbols as real functions,\n    * with a slightly different signature.\n    * See issue #10910\n    */\n#include <ctype.h>\n#include <wctype.h>\n#undef isalnum\n#define isalnum(c) iswalnum(btowc(c))\n#undef isalpha\n#define isalpha(c) iswalpha(btowc(c))\n#undef islower\n#define islower(c) iswlower(btowc(c))\n#undef isspace\n#define isspace(c) iswspace(btowc(c))\n#undef isupper\n#define isupper(c) iswupper(btowc(c))\n#undef tolower\n#define tolower(c) towlower(btowc(c))\n#undef toupper\n#define toupper(c) towupper(btowc(c))\n#endif\n#endif\n\n\n/* Declarations for symbol visibility.\n\n  PyAPI_FUNC(type): Declares a public Python API function and return type\n  PyAPI_DATA(type): Declares public Python data and its type\n  PyMODINIT_FUNC:   A Python module init function.  If these functions are\n                    inside the Python core, they are private to the core.\n                    If in an extension module, it may be declared with\n                    external linkage depending on the platform.\n\n  As a number of platforms support/require \"__declspec(dllimport/dllexport)\",\n  we support a HAVE_DECLSPEC_DLL macro to save duplication.\n*/\n\n/*\n  All windows ports, except cygwin, are handled in PC/pyconfig.h.\n\n  Cygwin is the only other autoconf platform requiring special\n  linkage handling and it uses __declspec().\n*/\n#if defined(__CYGWIN__)\n#       define HAVE_DECLSPEC_DLL\n#endif\n\n/* only get special linkage if built as shared or platform is Cygwin */\n#if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)\n#       if defined(HAVE_DECLSPEC_DLL)\n#               if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)\n#                       define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE\n#                       define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE\n        /* module init functions inside the core need no external linkage */\n        /* except for Cygwin to handle embedding */\n#                       if defined(__CYGWIN__)\n#                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*\n#                       else /* __CYGWIN__ */\n#                               define PyMODINIT_FUNC PyObject*\n#                       endif /* __CYGWIN__ */\n#               else /* Py_BUILD_CORE */\n        /* Building an extension module, or an embedded situation */\n        /* public Python functions and data are imported */\n        /* Under Cygwin, auto-import functions to prevent compilation */\n        /* failures similar to those described at the bottom of 4.1: */\n        /* http://docs.python.org/extending/windows.html#a-cookbook-approach */\n#                       if !defined(__CYGWIN__)\n#                               define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE\n#                       endif /* !__CYGWIN__ */\n#                       define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE\n        /* module init functions outside the core must be exported */\n#                       if defined(__cplusplus)\n#                               define PyMODINIT_FUNC extern \"C\" __declspec(dllexport) PyObject*\n#                       else /* __cplusplus */\n#                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*\n#                       endif /* __cplusplus */\n#               endif /* Py_BUILD_CORE */\n#       endif /* HAVE_DECLSPEC_DLL */\n#endif /* Py_ENABLE_SHARED */\n\n/* If no external linkage macros defined by now, create defaults */\n#ifndef PyAPI_FUNC\n#       define PyAPI_FUNC(RTYPE) RTYPE\n#endif\n#ifndef PyAPI_DATA\n#       define PyAPI_DATA(RTYPE) extern RTYPE\n#endif\n#ifndef PyMODINIT_FUNC\n#       if defined(__cplusplus)\n#               define PyMODINIT_FUNC extern \"C\" PyObject*\n#       else /* __cplusplus */\n#               define PyMODINIT_FUNC PyObject*\n#       endif /* __cplusplus */\n#endif\n\n/* limits.h constants that may be missing */\n\n#ifndef INT_MAX\n#define INT_MAX 2147483647\n#endif\n\n#ifndef LONG_MAX\n#if SIZEOF_LONG == 4\n#define LONG_MAX 0X7FFFFFFFL\n#elif SIZEOF_LONG == 8\n#define LONG_MAX 0X7FFFFFFFFFFFFFFFL\n#else\n#error \"could not set LONG_MAX in pyport.h\"\n#endif\n#endif\n\n#ifndef LONG_MIN\n#define LONG_MIN (-LONG_MAX-1)\n#endif\n\n#ifndef LONG_BIT\n#define LONG_BIT (8 * SIZEOF_LONG)\n#endif\n\n#if LONG_BIT != 8 * SIZEOF_LONG\n/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent\n * 32-bit platforms using gcc.  We try to catch that here at compile-time\n * rather than waiting for integer multiplication to trigger bogus\n * overflows.\n */\n#error \"LONG_BIT definition appears wrong for platform (bad gcc/glibc config?).\"\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n/*\n * Hide GCC attributes from compilers that don't support them.\n */\n#if (!defined(__GNUC__) || __GNUC__ < 2 || \\\n     (__GNUC__ == 2 && __GNUC_MINOR__ < 7) )\n#define Py_GCC_ATTRIBUTE(x)\n#else\n#define Py_GCC_ATTRIBUTE(x) __attribute__(x)\n#endif\n\n/*\n * Specify alignment on compilers that support it.\n */\n#if defined(__GNUC__) && __GNUC__ >= 3\n#define Py_ALIGNED(x) __attribute__((aligned(x)))\n#else\n#define Py_ALIGNED(x)\n#endif\n\n/* Eliminate end-of-loop code not reached warnings from SunPro C\n * when using do{...}while(0) macros\n */\n#ifdef __SUNPRO_C\n#pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)\n#endif\n\n#ifndef Py_LL\n#define Py_LL(x) x##LL\n#endif\n\n#ifndef Py_ULL\n#define Py_ULL(x) Py_LL(x##U)\n#endif\n\n#define Py_VA_COPY va_copy\n\n/*\n * Convenient macros to deal with endianness of the platform. WORDS_BIGENDIAN is\n * detected by configure and defined in pyconfig.h. The code in pyconfig.h\n * also takes care of Apple's universal builds.\n */\n\n#ifdef WORDS_BIGENDIAN\n#define PY_BIG_ENDIAN 1\n#define PY_LITTLE_ENDIAN 0\n#else\n#define PY_BIG_ENDIAN 0\n#define PY_LITTLE_ENDIAN 1\n#endif\n\n#ifdef Py_BUILD_CORE\n/*\n * Macros to protect CRT calls against instant termination when passed an\n * invalid parameter (issue23524).\n */\n#if defined _MSC_VER && _MSC_VER >= 1900\n\nextern _invalid_parameter_handler _Py_silent_invalid_parameter_handler;\n#define _Py_BEGIN_SUPPRESS_IPH { _invalid_parameter_handler _Py_old_handler = \\\n    _set_thread_local_invalid_parameter_handler(_Py_silent_invalid_parameter_handler);\n#define _Py_END_SUPPRESS_IPH _set_thread_local_invalid_parameter_handler(_Py_old_handler); }\n\n#else\n\n#define _Py_BEGIN_SUPPRESS_IPH\n#define _Py_END_SUPPRESS_IPH\n\n#endif /* _MSC_VER >= 1900 */\n#endif /* Py_BUILD_CORE */\n\n#ifdef __ANDROID__\n   /* The Android langinfo.h header is not used. */\n#  undef HAVE_LANGINFO_H\n#  undef CODESET\n#endif\n\n/* Maximum value of the Windows DWORD type */\n#define PY_DWORD_MAX 4294967295U\n\n/* This macro used to tell whether Python was built with multithreading\n * enabled.  Now multithreading is always enabled, but keep the macro\n * for compatibility.\n */\n#ifndef WITH_THREAD\n#  define WITH_THREAD\n#endif\n\n/* Check that ALT_SOABI is consistent with Py_TRACE_REFS:\n   ./configure --with-trace-refs should must be used to define Py_TRACE_REFS */\n#if defined(ALT_SOABI) && defined(Py_TRACE_REFS)\n#  error \"Py_TRACE_REFS ABI is not compatible with release and debug ABI\"\n#endif\n\n#if defined(__ANDROID__) || defined(__VXWORKS__)\n   /* Ignore the locale encoding: force UTF-8 */\n#  define _Py_FORCE_UTF8_LOCALE\n#endif\n\n#if defined(_Py_FORCE_UTF8_LOCALE) || defined(__APPLE__)\n   /* Use UTF-8 as filesystem encoding */\n#  define _Py_FORCE_UTF8_FS_ENCODING\n#endif\n\n/* Mark a function which cannot return. Example:\n\n   PyAPI_FUNC(void) _Py_NO_RETURN PyThread_exit_thread(void); */\n#if defined(__clang__) || \\\n    (defined(__GNUC__) && \\\n     ((__GNUC__ >= 3) || \\\n      (__GNUC__ == 2) && (__GNUC_MINOR__ >= 5)))\n#  define _Py_NO_RETURN __attribute__((__noreturn__))\n#elif defined(_MSC_VER)\n#  define _Py_NO_RETURN __declspec(noreturn)\n#else\n#  define _Py_NO_RETURN\n#endif\n\n#endif /* Py_PYPORT_H */\n"}, "121": {"id": 121, "path": "/usr/include/python3.8/pystate.h", "content": "/* Thread and interpreter state structures and their interfaces */\n\n\n#ifndef Py_PYSTATE_H\n#define Py_PYSTATE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"pythread.h\"\n\n/* This limitation is for performance and simplicity. If needed it can be\nremoved (with effort). */\n#define MAX_CO_EXTRA_USERS 255\n\n/* Forward declarations for PyFrameObject, PyThreadState\n   and PyInterpreterState */\nstruct _frame;\nstruct _ts;\nstruct _is;\n\n/* struct _ts is defined in cpython/pystate.h */\ntypedef struct _ts PyThreadState;\n/* struct _is is defined in internal/pycore_pystate.h */\ntypedef struct _is PyInterpreterState;\n\nPyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);\nPyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);\nPyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000\n/* New in 3.8 */\nPyAPI_FUNC(PyObject *) PyInterpreterState_GetDict(PyInterpreterState *);\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000\n/* New in 3.7 */\nPyAPI_FUNC(int64_t) PyInterpreterState_GetID(PyInterpreterState *);\n#endif\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\n\n/* State unique per thread */\n\n/* New in 3.3 */\nPyAPI_FUNC(int) PyState_AddModule(PyObject*, struct PyModuleDef*);\nPyAPI_FUNC(int) PyState_RemoveModule(struct PyModuleDef*);\n#endif\nPyAPI_FUNC(PyObject*) PyState_FindModule(struct PyModuleDef*);\n\nPyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);\nPyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);\nPyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);\nPyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);\n\n/* Get the current thread state.\n\n   When the current thread state is NULL, this issues a fatal error (so that\n   the caller needn't check for NULL).\n\n   The caller must hold the GIL.\n\n   See also PyThreadState_GET() and _PyThreadState_GET(). */\nPyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);\n\n/* Get the current Python thread state.\n\n   Macro using PyThreadState_Get() or _PyThreadState_GET() depending if\n   pycore_pystate.h is included or not (this header redefines the macro).\n\n   If PyThreadState_Get() is used, issue a fatal error if the current thread\n   state is NULL.\n\n   See also PyThreadState_Get() and _PyThreadState_GET(). */\n#define PyThreadState_GET() PyThreadState_Get()\n\nPyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);\nPyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);\nPyAPI_FUNC(int) PyThreadState_SetAsyncExc(unsigned long, PyObject *);\n\ntypedef\n    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}\n        PyGILState_STATE;\n\n\n/* Ensure that the current thread is ready to call the Python\n   C API, regardless of the current state of Python, or of its\n   thread lock.  This may be called as many times as desired\n   by a thread so long as each call is matched with a call to\n   PyGILState_Release().  In general, other thread-state APIs may\n   be used between _Ensure() and _Release() calls, so long as the\n   thread-state is restored to its previous state before the Release().\n   For example, normal use of the Py_BEGIN_ALLOW_THREADS/\n   Py_END_ALLOW_THREADS macros are acceptable.\n\n   The return value is an opaque \"handle\" to the thread state when\n   PyGILState_Ensure() was called, and must be passed to\n   PyGILState_Release() to ensure Python is left in the same state. Even\n   though recursive calls are allowed, these handles can *not* be shared -\n   each unique call to PyGILState_Ensure must save the handle for its\n   call to PyGILState_Release.\n\n   When the function returns, the current thread will hold the GIL.\n\n   Failure is a fatal error.\n*/\nPyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);\n\n/* Release any resources previously acquired.  After this call, Python's\n   state will be the same as it was prior to the corresponding\n   PyGILState_Ensure() call (but generally this state will be unknown to\n   the caller, hence the use of the GILState API.)\n\n   Every call to PyGILState_Ensure must be matched by a call to\n   PyGILState_Release on the same thread.\n*/\nPyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);\n\n/* Helper/diagnostic function - get the current thread state for\n   this thread.  May return NULL if no GILState API has been used\n   on the current thread.  Note that the main thread always has such a\n   thread-state, even if no auto-thread-state call has been made\n   on the main thread.\n*/\nPyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);\n\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_PYSTATE_H\n#  include  \"cpython/pystate.h\"\n#  undef Py_CPYTHON_PYSTATE_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_PYSTATE_H */\n"}, "122": {"id": 122, "path": "/usr/include/python3.8/pystrcmp.h", "content": "#ifndef Py_STRCMP_H\n#define Py_STRCMP_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(int) PyOS_mystrnicmp(const char *, const char *, Py_ssize_t);\nPyAPI_FUNC(int) PyOS_mystricmp(const char *, const char *);\n\n#ifdef MS_WINDOWS\n#define PyOS_strnicmp strnicmp\n#define PyOS_stricmp stricmp\n#else\n#define PyOS_strnicmp PyOS_mystrnicmp\n#define PyOS_stricmp PyOS_mystricmp\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_STRCMP_H */\n"}, "123": {"id": 123, "path": "/usr/include/python3.8/pystrtod.h", "content": "#ifndef Py_STRTOD_H\n#define Py_STRTOD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nPyAPI_FUNC(double) PyOS_string_to_double(const char *str,\n                                         char **endptr,\n                                         PyObject *overflow_exception);\n\n/* The caller is responsible for calling PyMem_Free to free the buffer\n   that's is returned. */\nPyAPI_FUNC(char *) PyOS_double_to_string(double val,\n                                         char format_code,\n                                         int precision,\n                                         int flags,\n                                         int *type);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _Py_string_to_number_with_underscores(\n    const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg,\n    PyObject *(*innerfunc)(const char *, Py_ssize_t, void *));\n\nPyAPI_FUNC(double) _Py_parse_inf_or_nan(const char *p, char **endptr);\n#endif\n\n\n/* PyOS_double_to_string's \"flags\" parameter can be set to 0 or more of: */\n#define Py_DTSF_SIGN      0x01 /* always add the sign */\n#define Py_DTSF_ADD_DOT_0 0x02 /* if the result is an integer add \".0\" */\n#define Py_DTSF_ALT       0x04 /* \"alternate\" formatting. it's format_code\n                                  specific */\n\n/* PyOS_double_to_string's \"type\", if non-NULL, will be set to one of: */\n#define Py_DTST_FINITE 0\n#define Py_DTST_INFINITE 1\n#define Py_DTST_NAN 2\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_STRTOD_H */\n"}, "124": {"id": 124, "path": "/usr/include/python3.8/pythonrun.h", "content": "\n/* Interfaces to parse and execute pieces of python code */\n\n#ifndef Py_PYTHONRUN_H\n#define Py_PYTHONRUN_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);\nPyAPI_FUNC(int) PyRun_AnyFileExFlags(\n    FILE *fp,\n    const char *filename,       /* decoded from the filesystem encoding */\n    int closeit,\n    PyCompilerFlags *flags);\nPyAPI_FUNC(int) PyRun_SimpleFileExFlags(\n    FILE *fp,\n    const char *filename,       /* decoded from the filesystem encoding */\n    int closeit,\n    PyCompilerFlags *flags);\nPyAPI_FUNC(int) PyRun_InteractiveOneFlags(\n    FILE *fp,\n    const char *filename,       /* decoded from the filesystem encoding */\n    PyCompilerFlags *flags);\nPyAPI_FUNC(int) PyRun_InteractiveOneObject(\n    FILE *fp,\n    PyObject *filename,\n    PyCompilerFlags *flags);\nPyAPI_FUNC(int) PyRun_InteractiveLoopFlags(\n    FILE *fp,\n    const char *filename,       /* decoded from the filesystem encoding */\n    PyCompilerFlags *flags);\n\nPyAPI_FUNC(struct _mod *) PyParser_ASTFromString(\n    const char *s,\n    const char *filename,       /* decoded from the filesystem encoding */\n    int start,\n    PyCompilerFlags *flags,\n    PyArena *arena);\nPyAPI_FUNC(struct _mod *) PyParser_ASTFromStringObject(\n    const char *s,\n    PyObject *filename,\n    int start,\n    PyCompilerFlags *flags,\n    PyArena *arena);\nPyAPI_FUNC(struct _mod *) PyParser_ASTFromFile(\n    FILE *fp,\n    const char *filename,       /* decoded from the filesystem encoding */\n    const char* enc,\n    int start,\n    const char *ps1,\n    const char *ps2,\n    PyCompilerFlags *flags,\n    int *errcode,\n    PyArena *arena);\nPyAPI_FUNC(struct _mod *) PyParser_ASTFromFileObject(\n    FILE *fp,\n    PyObject *filename,\n    const char* enc,\n    int start,\n    const char *ps1,\n    const char *ps2,\n    PyCompilerFlags *flags,\n    int *errcode,\n    PyArena *arena);\n#endif\n\n#ifndef PyParser_SimpleParseString\n#define PyParser_SimpleParseString(S, B) \\\n    PyParser_SimpleParseStringFlags(S, B, 0)\n#define PyParser_SimpleParseFile(FP, S, B) \\\n    PyParser_SimpleParseFileFlags(FP, S, B, 0)\n#endif\nPyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlags(const char *, int,\n                                                           int);\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlagsFilename(const char *,\n                                                                   const char *,\n                                                                   int, int);\n#endif\nPyAPI_FUNC(struct _node *) PyParser_SimpleParseFileFlags(FILE *, const char *,\n                                                         int, int);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) PyRun_StringFlags(const char *, int, PyObject *,\n                                         PyObject *, PyCompilerFlags *);\n\nPyAPI_FUNC(PyObject *) PyRun_FileExFlags(\n    FILE *fp,\n    const char *filename,       /* decoded from the filesystem encoding */\n    int start,\n    PyObject *globals,\n    PyObject *locals,\n    int closeit,\n    PyCompilerFlags *flags);\n#endif\n\n#ifdef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);\n#else\n#define Py_CompileString(str, p, s) Py_CompileStringExFlags(str, p, s, NULL, -1)\n#define Py_CompileStringFlags(str, p, s, f) Py_CompileStringExFlags(str, p, s, f, -1)\nPyAPI_FUNC(PyObject *) Py_CompileStringExFlags(\n    const char *str,\n    const char *filename,       /* decoded from the filesystem encoding */\n    int start,\n    PyCompilerFlags *flags,\n    int optimize);\nPyAPI_FUNC(PyObject *) Py_CompileStringObject(\n    const char *str,\n    PyObject *filename, int start,\n    PyCompilerFlags *flags,\n    int optimize);\n#endif\nPyAPI_FUNC(struct symtable *) Py_SymtableString(\n    const char *str,\n    const char *filename,       /* decoded from the filesystem encoding */\n    int start);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(const char *) _Py_SourceAsString(\n    PyObject *cmd,\n    const char *funcname,\n    const char *what,\n    PyCompilerFlags *cf,\n    PyObject **cmd_copy);\n\nPyAPI_FUNC(struct symtable *) Py_SymtableStringObject(\n    const char *str,\n    PyObject *filename,\n    int start);\n\nPyAPI_FUNC(struct symtable *) _Py_SymtableStringObjectFlags(\n    const char *str,\n    PyObject *filename,\n    int start,\n    PyCompilerFlags *flags);\n#endif\n\nPyAPI_FUNC(void) PyErr_Print(void);\nPyAPI_FUNC(void) PyErr_PrintEx(int);\nPyAPI_FUNC(void) PyErr_Display(PyObject *, PyObject *, PyObject *);\n\n#ifndef Py_LIMITED_API\n/* A function flavor is also exported by libpython. It is required when\n    libpython is accessed directly rather than using header files which defines\n    macros below. On Windows, for example, PyAPI_FUNC() uses dllexport to\n    export functions in pythonXX.dll. */\nPyAPI_FUNC(PyObject *) PyRun_String(const char *str, int s, PyObject *g, PyObject *l);\nPyAPI_FUNC(int) PyRun_AnyFile(FILE *fp, const char *name);\nPyAPI_FUNC(int) PyRun_AnyFileEx(FILE *fp, const char *name, int closeit);\nPyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);\nPyAPI_FUNC(int) PyRun_SimpleString(const char *s);\nPyAPI_FUNC(int) PyRun_SimpleFile(FILE *f, const char *p);\nPyAPI_FUNC(int) PyRun_SimpleFileEx(FILE *f, const char *p, int c);\nPyAPI_FUNC(int) PyRun_InteractiveOne(FILE *f, const char *p);\nPyAPI_FUNC(int) PyRun_InteractiveLoop(FILE *f, const char *p);\nPyAPI_FUNC(PyObject *) PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l);\nPyAPI_FUNC(PyObject *) PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c);\nPyAPI_FUNC(PyObject *) PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags);\n\n/* Use macros for a bunch of old variants */\n#define PyRun_String(str, s, g, l) PyRun_StringFlags(str, s, g, l, NULL)\n#define PyRun_AnyFile(fp, name) PyRun_AnyFileExFlags(fp, name, 0, NULL)\n#define PyRun_AnyFileEx(fp, name, closeit) \\\n    PyRun_AnyFileExFlags(fp, name, closeit, NULL)\n#define PyRun_AnyFileFlags(fp, name, flags) \\\n    PyRun_AnyFileExFlags(fp, name, 0, flags)\n#define PyRun_SimpleString(s) PyRun_SimpleStringFlags(s, NULL)\n#define PyRun_SimpleFile(f, p) PyRun_SimpleFileExFlags(f, p, 0, NULL)\n#define PyRun_SimpleFileEx(f, p, c) PyRun_SimpleFileExFlags(f, p, c, NULL)\n#define PyRun_InteractiveOne(f, p) PyRun_InteractiveOneFlags(f, p, NULL)\n#define PyRun_InteractiveLoop(f, p) PyRun_InteractiveLoopFlags(f, p, NULL)\n#define PyRun_File(fp, p, s, g, l) \\\n    PyRun_FileExFlags(fp, p, s, g, l, 0, NULL)\n#define PyRun_FileEx(fp, p, s, g, l, c) \\\n    PyRun_FileExFlags(fp, p, s, g, l, c, NULL)\n#define PyRun_FileFlags(fp, p, s, g, l, flags) \\\n    PyRun_FileExFlags(fp, p, s, g, l, 0, flags)\n#endif\n\n/* Stuff with no proper home (yet) */\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, const char *);\n#endif\nPyAPI_DATA(int) (*PyOS_InputHook)(void);\nPyAPI_DATA(char) *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *);\n#ifndef Py_LIMITED_API\nPyAPI_DATA(PyThreadState*) _PyOS_ReadlineTState;\n#endif\n\n/* Stack size, in \"pointers\" (so we get extra safety margins\n   on 64-bit platforms).  On a 32-bit platform, this translates\n   to an 8k margin. */\n#define PYOS_STACK_MARGIN 2048\n\n#if defined(WIN32) && !defined(MS_WIN64) && !defined(_M_ARM) && defined(_MSC_VER) && _MSC_VER >= 1300\n/* Enable stack checking under Microsoft C */\n#define USE_STACKCHECK\n#endif\n\n#ifdef USE_STACKCHECK\n/* Check that we aren't overflowing our stack */\nPyAPI_FUNC(int) PyOS_CheckStack(void);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_PYTHONRUN_H */\n"}, "125": {"id": 125, "path": "/usr/include/python3.8/pythread.h", "content": "\n#ifndef Py_PYTHREAD_H\n#define Py_PYTHREAD_H\n\ntypedef void *PyThread_type_lock;\ntypedef void *PyThread_type_sema;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Return status codes for Python lock acquisition.  Chosen for maximum\n * backwards compatibility, ie failure -> 0, success -> 1.  */\ntypedef enum PyLockStatus {\n    PY_LOCK_FAILURE = 0,\n    PY_LOCK_ACQUIRED = 1,\n    PY_LOCK_INTR\n} PyLockStatus;\n\n#ifndef Py_LIMITED_API\n#define PYTHREAD_INVALID_THREAD_ID ((unsigned long)-1)\n#endif\n\nPyAPI_FUNC(void) PyThread_init_thread(void);\nPyAPI_FUNC(unsigned long) PyThread_start_new_thread(void (*)(void *), void *);\nPyAPI_FUNC(void) _Py_NO_RETURN PyThread_exit_thread(void);\nPyAPI_FUNC(unsigned long) PyThread_get_thread_ident(void);\n\n#if defined(__APPLE__) || defined(__linux__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(_WIN32) || defined(_AIX) || defined(__GNU__)\n#define PY_HAVE_THREAD_NATIVE_ID\nPyAPI_FUNC(unsigned long) PyThread_get_thread_native_id(void);\n#endif\n\nPyAPI_FUNC(PyThread_type_lock) PyThread_allocate_lock(void);\nPyAPI_FUNC(void) PyThread_free_lock(PyThread_type_lock);\nPyAPI_FUNC(int) PyThread_acquire_lock(PyThread_type_lock, int);\n#define WAIT_LOCK       1\n#define NOWAIT_LOCK     0\n\n/* PY_TIMEOUT_T is the integral type used to specify timeouts when waiting\n   on a lock (see PyThread_acquire_lock_timed() below).\n   PY_TIMEOUT_MAX is the highest usable value (in microseconds) of that\n   type, and depends on the system threading API.\n\n   NOTE: this isn't the same value as `_thread.TIMEOUT_MAX`.  The _thread\n   module exposes a higher-level API, with timeouts expressed in seconds\n   and floating-point numbers allowed.\n*/\n#define PY_TIMEOUT_T long long\n\n#if defined(_POSIX_THREADS)\n   /* PyThread_acquire_lock_timed() uses _PyTime_FromNanoseconds(us * 1000),\n      convert microseconds to nanoseconds. */\n#  define PY_TIMEOUT_MAX (PY_LLONG_MAX / 1000)\n#elif defined (NT_THREADS)\n   /* In the NT API, the timeout is a DWORD and is expressed in milliseconds */\n#  if 0xFFFFFFFFLL * 1000 < PY_LLONG_MAX\n#    define PY_TIMEOUT_MAX (0xFFFFFFFFLL * 1000)\n#  else\n#    define PY_TIMEOUT_MAX PY_LLONG_MAX\n#  endif\n#else\n#  define PY_TIMEOUT_MAX PY_LLONG_MAX\n#endif\n\n\n/* If microseconds == 0, the call is non-blocking: it returns immediately\n   even when the lock can't be acquired.\n   If microseconds > 0, the call waits up to the specified duration.\n   If microseconds < 0, the call waits until success (or abnormal failure)\n\n   microseconds must be less than PY_TIMEOUT_MAX. Behaviour otherwise is\n   undefined.\n\n   If intr_flag is true and the acquire is interrupted by a signal, then the\n   call will return PY_LOCK_INTR.  The caller may reattempt to acquire the\n   lock.\n*/\nPyAPI_FUNC(PyLockStatus) PyThread_acquire_lock_timed(PyThread_type_lock,\n                                                     PY_TIMEOUT_T microseconds,\n                                                     int intr_flag);\n\nPyAPI_FUNC(void) PyThread_release_lock(PyThread_type_lock);\n\nPyAPI_FUNC(size_t) PyThread_get_stacksize(void);\nPyAPI_FUNC(int) PyThread_set_stacksize(size_t);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyThread_GetInfo(void);\n#endif\n\n\n/* Thread Local Storage (TLS) API\n   TLS API is DEPRECATED.  Use Thread Specific Storage (TSS) API.\n\n   The existing TLS API has used int to represent TLS keys across all\n   platforms, but it is not POSIX-compliant.  Therefore, the new TSS API uses\n   opaque data type to represent TSS keys to be compatible (see PEP 539).\n*/\nPy_DEPRECATED(3.7) PyAPI_FUNC(int) PyThread_create_key(void);\nPy_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key(int key);\nPy_DEPRECATED(3.7) PyAPI_FUNC(int) PyThread_set_key_value(int key,\n                                                          void *value);\nPy_DEPRECATED(3.7) PyAPI_FUNC(void *) PyThread_get_key_value(int key);\nPy_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key_value(int key);\n\n/* Cleanup after a fork */\nPy_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_ReInitTLS(void);\n\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000\n/* New in 3.7 */\n/* Thread Specific Storage (TSS) API */\n\ntypedef struct _Py_tss_t Py_tss_t;  /* opaque */\n\n#ifndef Py_LIMITED_API\n#if defined(_POSIX_THREADS)\n    /* Darwin needs pthread.h to know type name the pthread_key_t. */\n#   include <pthread.h>\n#   define NATIVE_TSS_KEY_T     pthread_key_t\n#elif defined(NT_THREADS)\n    /* In Windows, native TSS key type is DWORD,\n       but hardcode the unsigned long to avoid errors for include directive.\n    */\n#   define NATIVE_TSS_KEY_T     unsigned long\n#else\n#   error \"Require native threads. See https://bugs.python.org/issue31370\"\n#endif\n\n/* When Py_LIMITED_API is not defined, the type layout of Py_tss_t is\n   exposed to allow static allocation in the API clients.  Even in this case,\n   you must handle TSS keys through API functions due to compatibility.\n*/\nstruct _Py_tss_t {\n    int _is_initialized;\n    NATIVE_TSS_KEY_T _key;\n};\n\n#undef NATIVE_TSS_KEY_T\n\n/* When static allocation, you must initialize with Py_tss_NEEDS_INIT. */\n#define Py_tss_NEEDS_INIT   {0}\n#endif  /* !Py_LIMITED_API */\n\nPyAPI_FUNC(Py_tss_t *) PyThread_tss_alloc(void);\nPyAPI_FUNC(void) PyThread_tss_free(Py_tss_t *key);\n\n/* The parameter key must not be NULL. */\nPyAPI_FUNC(int) PyThread_tss_is_created(Py_tss_t *key);\nPyAPI_FUNC(int) PyThread_tss_create(Py_tss_t *key);\nPyAPI_FUNC(void) PyThread_tss_delete(Py_tss_t *key);\nPyAPI_FUNC(int) PyThread_tss_set(Py_tss_t *key, void *value);\nPyAPI_FUNC(void *) PyThread_tss_get(Py_tss_t *key);\n#endif  /* New in 3.7 */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !Py_PYTHREAD_H */\n"}, "126": {"id": 126, "path": "/usr/include/python3.8/pytime.h", "content": "#ifndef Py_LIMITED_API\n#ifndef Py_PYTIME_H\n#define Py_PYTIME_H\n\n#include \"pyconfig.h\" /* include for defines */\n#include \"object.h\"\n\n/**************************************************************************\nSymbols and macros to supply platform-independent interfaces to time related\nfunctions and constants\n**************************************************************************/\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* _PyTime_t: Python timestamp with subsecond precision. It can be used to\n   store a duration, and so indirectly a date (related to another date, like\n   UNIX epoch). */\ntypedef int64_t _PyTime_t;\n#define _PyTime_MIN INT64_MIN\n#define _PyTime_MAX INT64_MAX\n\ntypedef enum {\n    /* Round towards minus infinity (-inf).\n       For example, used to read a clock. */\n    _PyTime_ROUND_FLOOR=0,\n    /* Round towards infinity (+inf).\n       For example, used for timeout to wait \"at least\" N seconds. */\n    _PyTime_ROUND_CEILING=1,\n    /* Round to nearest with ties going to nearest even integer.\n       For example, used to round from a Python float. */\n    _PyTime_ROUND_HALF_EVEN=2,\n    /* Round away from zero\n       For example, used for timeout. _PyTime_ROUND_CEILING rounds\n       -1e-9 to 0 milliseconds which causes bpo-31786 issue.\n       _PyTime_ROUND_UP rounds -1e-9 to -1 millisecond which keeps\n       the timeout sign as expected. select.poll(timeout) must block\n       for negative values.\" */\n    _PyTime_ROUND_UP=3,\n    /* _PyTime_ROUND_TIMEOUT (an alias for _PyTime_ROUND_UP) should be\n       used for timeouts. */\n    _PyTime_ROUND_TIMEOUT = _PyTime_ROUND_UP\n} _PyTime_round_t;\n\n\n/* Convert a time_t to a PyLong. */\nPyAPI_FUNC(PyObject *) _PyLong_FromTime_t(\n    time_t sec);\n\n/* Convert a PyLong to a time_t. */\nPyAPI_FUNC(time_t) _PyLong_AsTime_t(\n    PyObject *obj);\n\n/* Convert a number of seconds, int or float, to time_t. */\nPyAPI_FUNC(int) _PyTime_ObjectToTime_t(\n    PyObject *obj,\n    time_t *sec,\n    _PyTime_round_t);\n\n/* Convert a number of seconds, int or float, to a timeval structure.\n   usec is in the range [0; 999999] and rounded towards zero.\n   For example, -1.2 is converted to (-2, 800000). */\nPyAPI_FUNC(int) _PyTime_ObjectToTimeval(\n    PyObject *obj,\n    time_t *sec,\n    long *usec,\n    _PyTime_round_t);\n\n/* Convert a number of seconds, int or float, to a timespec structure.\n   nsec is in the range [0; 999999999] and rounded towards zero.\n   For example, -1.2 is converted to (-2, 800000000). */\nPyAPI_FUNC(int) _PyTime_ObjectToTimespec(\n    PyObject *obj,\n    time_t *sec,\n    long *nsec,\n    _PyTime_round_t);\n\n\n/* Create a timestamp from a number of seconds. */\nPyAPI_FUNC(_PyTime_t) _PyTime_FromSeconds(int seconds);\n\n/* Macro to create a timestamp from a number of seconds, no integer overflow.\n   Only use the macro for small values, prefer _PyTime_FromSeconds(). */\n#define _PYTIME_FROMSECONDS(seconds) \\\n            ((_PyTime_t)(seconds) * (1000 * 1000 * 1000))\n\n/* Create a timestamp from a number of nanoseconds. */\nPyAPI_FUNC(_PyTime_t) _PyTime_FromNanoseconds(_PyTime_t ns);\n\n/* Create a timestamp from nanoseconds (Python int). */\nPyAPI_FUNC(int) _PyTime_FromNanosecondsObject(_PyTime_t *t,\n    PyObject *obj);\n\n/* Convert a number of seconds (Python float or int) to a timetamp.\n   Raise an exception and return -1 on error, return 0 on success. */\nPyAPI_FUNC(int) _PyTime_FromSecondsObject(_PyTime_t *t,\n    PyObject *obj,\n    _PyTime_round_t round);\n\n/* Convert a number of milliseconds (Python float or int, 10^-3) to a timetamp.\n   Raise an exception and return -1 on error, return 0 on success. */\nPyAPI_FUNC(int) _PyTime_FromMillisecondsObject(_PyTime_t *t,\n    PyObject *obj,\n    _PyTime_round_t round);\n\n/* Convert a timestamp to a number of seconds as a C double. */\nPyAPI_FUNC(double) _PyTime_AsSecondsDouble(_PyTime_t t);\n\n/* Convert timestamp to a number of milliseconds (10^-3 seconds). */\nPyAPI_FUNC(_PyTime_t) _PyTime_AsMilliseconds(_PyTime_t t,\n    _PyTime_round_t round);\n\n/* Convert timestamp to a number of microseconds (10^-6 seconds). */\nPyAPI_FUNC(_PyTime_t) _PyTime_AsMicroseconds(_PyTime_t t,\n    _PyTime_round_t round);\n\n/* Convert timestamp to a number of nanoseconds (10^-9 seconds) as a Python int\n   object. */\nPyAPI_FUNC(PyObject *) _PyTime_AsNanosecondsObject(_PyTime_t t);\n\n/* Create a timestamp from a timeval structure.\n   Raise an exception and return -1 on overflow, return 0 on success. */\nPyAPI_FUNC(int) _PyTime_FromTimeval(_PyTime_t *tp, struct timeval *tv);\n\n/* Convert a timestamp to a timeval structure (microsecond resolution).\n   tv_usec is always positive.\n   Raise an exception and return -1 if the conversion overflowed,\n   return 0 on success. */\nPyAPI_FUNC(int) _PyTime_AsTimeval(_PyTime_t t,\n    struct timeval *tv,\n    _PyTime_round_t round);\n\n/* Similar to _PyTime_AsTimeval(), but don't raise an exception on error. */\nPyAPI_FUNC(int) _PyTime_AsTimeval_noraise(_PyTime_t t,\n    struct timeval *tv,\n    _PyTime_round_t round);\n\n/* Convert a timestamp to a number of seconds (secs) and microseconds (us).\n   us is always positive. This function is similar to _PyTime_AsTimeval()\n   except that secs is always a time_t type, whereas the timeval structure\n   uses a C long for tv_sec on Windows.\n   Raise an exception and return -1 if the conversion overflowed,\n   return 0 on success. */\nPyAPI_FUNC(int) _PyTime_AsTimevalTime_t(\n    _PyTime_t t,\n    time_t *secs,\n    int *us,\n    _PyTime_round_t round);\n\n#if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_KQUEUE)\n/* Create a timestamp from a timespec structure.\n   Raise an exception and return -1 on overflow, return 0 on success. */\nPyAPI_FUNC(int) _PyTime_FromTimespec(_PyTime_t *tp, struct timespec *ts);\n\n/* Convert a timestamp to a timespec structure (nanosecond resolution).\n   tv_nsec is always positive.\n   Raise an exception and return -1 on error, return 0 on success. */\nPyAPI_FUNC(int) _PyTime_AsTimespec(_PyTime_t t, struct timespec *ts);\n#endif\n\n/* Compute ticks * mul / div.\n   The caller must ensure that ((div - 1) * mul) cannot overflow. */\nPyAPI_FUNC(_PyTime_t) _PyTime_MulDiv(_PyTime_t ticks,\n    _PyTime_t mul,\n    _PyTime_t div);\n\n/* Get the current time from the system clock.\n\n   The function cannot fail. _PyTime_Init() ensures that the system clock\n   works. */\nPyAPI_FUNC(_PyTime_t) _PyTime_GetSystemClock(void);\n\n/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.\n   The clock is not affected by system clock updates. The reference point of\n   the returned value is undefined, so that only the difference between the\n   results of consecutive calls is valid.\n\n   The function cannot fail. _PyTime_Init() ensures that a monotonic clock\n   is available and works. */\nPyAPI_FUNC(_PyTime_t) _PyTime_GetMonotonicClock(void);\n\n\n/* Structure used by time.get_clock_info() */\ntypedef struct {\n    const char *implementation;\n    int monotonic;\n    int adjustable;\n    double resolution;\n} _Py_clock_info_t;\n\n/* Get the current time from the system clock.\n * Fill clock information if info is not NULL.\n * Raise an exception and return -1 on error, return 0 on success.\n */\nPyAPI_FUNC(int) _PyTime_GetSystemClockWithInfo(\n    _PyTime_t *t,\n    _Py_clock_info_t *info);\n\n/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.\n   The clock is not affected by system clock updates. The reference point of\n   the returned value is undefined, so that only the difference between the\n   results of consecutive calls is valid.\n\n   Fill info (if set) with information of the function used to get the time.\n\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int) _PyTime_GetMonotonicClockWithInfo(\n    _PyTime_t *t,\n    _Py_clock_info_t *info);\n\n\n/* Initialize time.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int) _PyTime_Init(void);\n\n/* Converts a timestamp to the Gregorian time, using the local time zone.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int) _PyTime_localtime(time_t t, struct tm *tm);\n\n/* Converts a timestamp to the Gregorian time, assuming UTC.\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int) _PyTime_gmtime(time_t t, struct tm *tm);\n\n/* Get the performance counter: clock with the highest available resolution to\n   measure a short duration.\n\n   The function cannot fail. _PyTime_Init() ensures that the system clock\n   works. */\nPyAPI_FUNC(_PyTime_t) _PyTime_GetPerfCounter(void);\n\n/* Get the performance counter: clock with the highest available resolution to\n   measure a short duration.\n\n   Fill info (if set) with information of the function used to get the time.\n\n   Return 0 on success, raise an exception and return -1 on error. */\nPyAPI_FUNC(int) _PyTime_GetPerfCounterWithInfo(\n    _PyTime_t *t,\n    _Py_clock_info_t *info);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* Py_PYTIME_H */\n#endif /* Py_LIMITED_API */\n"}, "127": {"id": 127, "path": "/usr/include/python3.8/rangeobject.h", "content": "\n/* Range object interface */\n\n#ifndef Py_RANGEOBJECT_H\n#define Py_RANGEOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\nA range object represents an integer range.  This is an immutable object;\na range cannot change its value after creation.\n\nRange objects behave like the corresponding tuple objects except that\nthey are represented by a start, stop, and step datamembers.\n*/\n\nPyAPI_DATA(PyTypeObject) PyRange_Type;\nPyAPI_DATA(PyTypeObject) PyRangeIter_Type;\nPyAPI_DATA(PyTypeObject) PyLongRangeIter_Type;\n\n#define PyRange_Check(op) (Py_TYPE(op) == &PyRange_Type)\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_RANGEOBJECT_H */\n"}, "128": {"id": 128, "path": "/usr/include/python3.8/setobject.h", "content": "/* Set object interface */\n\n#ifndef Py_SETOBJECT_H\n#define Py_SETOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\n\n/* There are three kinds of entries in the table:\n\n1. Unused:  key == NULL and hash == 0\n2. Dummy:   key == dummy and hash == -1\n3. Active:  key != NULL and key != dummy and hash != -1\n\nThe hash field of Unused slots is always zero.\n\nThe hash field of Dummy slots are set to -1\nmeaning that dummy entries can be detected by\neither entry->key==dummy or by entry->hash==-1.\n*/\n\n#define PySet_MINSIZE 8\n\ntypedef struct {\n    PyObject *key;\n    Py_hash_t hash;             /* Cached hash code of the key */\n} setentry;\n\n/* The SetObject data structure is shared by set and frozenset objects.\n\nInvariant for sets:\n - hash is -1\n\nInvariants for frozensets:\n - data is immutable.\n - hash is the hash of the frozenset or -1 if not computed yet.\n\n*/\n\ntypedef struct {\n    PyObject_HEAD\n\n    Py_ssize_t fill;            /* Number active and dummy entries*/\n    Py_ssize_t used;            /* Number active entries */\n\n    /* The table contains mask + 1 slots, and that's a power of 2.\n     * We store the mask instead of the size because the mask is more\n     * frequently needed.\n     */\n    Py_ssize_t mask;\n\n    /* The table points to a fixed-size smalltable for small tables\n     * or to additional malloc'ed memory for bigger tables.\n     * The table pointer is never NULL which saves us from repeated\n     * runtime null-tests.\n     */\n    setentry *table;\n    Py_hash_t hash;             /* Only used by frozenset objects */\n    Py_ssize_t finger;          /* Search finger for pop() */\n\n    setentry smalltable[PySet_MINSIZE];\n    PyObject *weakreflist;      /* List of weak references */\n} PySetObject;\n\n#define PySet_GET_SIZE(so) (assert(PyAnySet_Check(so)),(((PySetObject *)(so))->used))\n\nPyAPI_DATA(PyObject *) _PySet_Dummy;\n\nPyAPI_FUNC(int) _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash);\nPyAPI_FUNC(int) _PySet_Update(PyObject *set, PyObject *iterable);\nPyAPI_FUNC(int) PySet_ClearFreeList(void);\n\n#endif /* Section excluded by Py_LIMITED_API */\n\nPyAPI_DATA(PyTypeObject) PySet_Type;\nPyAPI_DATA(PyTypeObject) PyFrozenSet_Type;\nPyAPI_DATA(PyTypeObject) PySetIter_Type;\n\nPyAPI_FUNC(PyObject *) PySet_New(PyObject *);\nPyAPI_FUNC(PyObject *) PyFrozenSet_New(PyObject *);\n\nPyAPI_FUNC(int) PySet_Add(PyObject *set, PyObject *key);\nPyAPI_FUNC(int) PySet_Clear(PyObject *set);\nPyAPI_FUNC(int) PySet_Contains(PyObject *anyset, PyObject *key);\nPyAPI_FUNC(int) PySet_Discard(PyObject *set, PyObject *key);\nPyAPI_FUNC(PyObject *) PySet_Pop(PyObject *set);\nPyAPI_FUNC(Py_ssize_t) PySet_Size(PyObject *anyset);\n\n#define PyFrozenSet_CheckExact(ob) (Py_TYPE(ob) == &PyFrozenSet_Type)\n#define PyAnySet_CheckExact(ob) \\\n    (Py_TYPE(ob) == &PySet_Type || Py_TYPE(ob) == &PyFrozenSet_Type)\n#define PyAnySet_Check(ob) \\\n    (Py_TYPE(ob) == &PySet_Type || Py_TYPE(ob) == &PyFrozenSet_Type || \\\n      PyType_IsSubtype(Py_TYPE(ob), &PySet_Type) || \\\n      PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))\n#define PySet_Check(ob) \\\n    (Py_TYPE(ob) == &PySet_Type || \\\n    PyType_IsSubtype(Py_TYPE(ob), &PySet_Type))\n#define   PyFrozenSet_Check(ob) \\\n    (Py_TYPE(ob) == &PyFrozenSet_Type || \\\n      PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_SETOBJECT_H */\n"}, "129": {"id": 129, "path": "/usr/include/python3.8/sliceobject.h", "content": "#ifndef Py_SLICEOBJECT_H\n#define Py_SLICEOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* The unique ellipsis object \"...\" */\n\nPyAPI_DATA(PyObject) _Py_EllipsisObject; /* Don't use this directly */\n\n#define Py_Ellipsis (&_Py_EllipsisObject)\n\n/* Slice object interface */\n\n/*\n\nA slice object containing start, stop, and step data members (the\nnames are from range).  After much talk with Guido, it was decided to\nlet these be any arbitrary python type.  Py_None stands for omitted values.\n*/\n#ifndef Py_LIMITED_API\ntypedef struct {\n    PyObject_HEAD\n    PyObject *start, *stop, *step;      /* not NULL */\n} PySliceObject;\n#endif\n\nPyAPI_DATA(PyTypeObject) PySlice_Type;\nPyAPI_DATA(PyTypeObject) PyEllipsis_Type;\n\n#define PySlice_Check(op) (Py_TYPE(op) == &PySlice_Type)\n\nPyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,\n                                  PyObject* step);\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject *) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);\nPyAPI_FUNC(int) _PySlice_GetLongIndices(PySliceObject *self, PyObject *length,\n                                 PyObject **start_ptr, PyObject **stop_ptr,\n                                 PyObject **step_ptr);\n#endif\nPyAPI_FUNC(int) PySlice_GetIndices(PyObject *r, Py_ssize_t length,\n                                  Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step);\nPy_DEPRECATED(3.7)\nPyAPI_FUNC(int) PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length,\n                                     Py_ssize_t *start, Py_ssize_t *stop,\n                                     Py_ssize_t *step,\n                                     Py_ssize_t *slicelength);\n\n#if !defined(Py_LIMITED_API) || (Py_LIMITED_API+0 >= 0x03050400 && Py_LIMITED_API+0 < 0x03060000) || Py_LIMITED_API+0 >= 0x03060100\n#define PySlice_GetIndicesEx(slice, length, start, stop, step, slicelen) (  \\\n    PySlice_Unpack((slice), (start), (stop), (step)) < 0 ?                  \\\n    ((*(slicelen) = 0), -1) :                                               \\\n    ((*(slicelen) = PySlice_AdjustIndices((length), (start), (stop), *(step))), \\\n     0))\nPyAPI_FUNC(int) PySlice_Unpack(PyObject *slice,\n                               Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step);\nPyAPI_FUNC(Py_ssize_t) PySlice_AdjustIndices(Py_ssize_t length,\n                                             Py_ssize_t *start, Py_ssize_t *stop,\n                                             Py_ssize_t step);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_SLICEOBJECT_H */\n"}, "130": {"id": 130, "path": "/usr/include/python3.8/structseq.h", "content": "\n/* Named tuple object interface */\n\n#ifndef Py_STRUCTSEQ_H\n#define Py_STRUCTSEQ_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct PyStructSequence_Field {\n    const char *name;\n    const char *doc;\n} PyStructSequence_Field;\n\ntypedef struct PyStructSequence_Desc {\n    const char *name;\n    const char *doc;\n    struct PyStructSequence_Field *fields;\n    int n_in_sequence;\n} PyStructSequence_Desc;\n\nextern char* PyStructSequence_UnnamedField;\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(void) PyStructSequence_InitType(PyTypeObject *type,\n                                           PyStructSequence_Desc *desc);\nPyAPI_FUNC(int) PyStructSequence_InitType2(PyTypeObject *type,\n                                           PyStructSequence_Desc *desc);\n#endif\nPyAPI_FUNC(PyTypeObject*) PyStructSequence_NewType(PyStructSequence_Desc *desc);\n\nPyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);\n\n#ifndef Py_LIMITED_API\ntypedef PyTupleObject PyStructSequence;\n\n/* Macro, *only* to be used to fill in brand new objects */\n#define PyStructSequence_SET_ITEM(op, i, v) PyTuple_SET_ITEM(op, i, v)\n\n#define PyStructSequence_GET_ITEM(op, i) PyTuple_GET_ITEM(op, i)\n#endif\n\nPyAPI_FUNC(void) PyStructSequence_SetItem(PyObject*, Py_ssize_t, PyObject*);\nPyAPI_FUNC(PyObject*) PyStructSequence_GetItem(PyObject*, Py_ssize_t);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_STRUCTSEQ_H */\n"}, "131": {"id": 131, "path": "/usr/include/python3.8/sysmodule.h", "content": "\n/* System module interface */\n\n#ifndef Py_SYSMODULE_H\n#define Py_SYSMODULE_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nPyAPI_FUNC(PyObject *) PySys_GetObject(const char *);\nPyAPI_FUNC(int) PySys_SetObject(const char *, PyObject *);\n\nPyAPI_FUNC(void) PySys_SetArgv(int, wchar_t **);\nPyAPI_FUNC(void) PySys_SetArgvEx(int, wchar_t **, int);\nPyAPI_FUNC(void) PySys_SetPath(const wchar_t *);\n\nPyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)\n                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));\nPyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)\n                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));\nPyAPI_FUNC(void) PySys_FormatStdout(const char *format, ...);\nPyAPI_FUNC(void) PySys_FormatStderr(const char *format, ...);\n\nPyAPI_FUNC(void) PySys_ResetWarnOptions(void);\nPyAPI_FUNC(void) PySys_AddWarnOption(const wchar_t *);\nPyAPI_FUNC(void) PySys_AddWarnOptionUnicode(PyObject *);\nPyAPI_FUNC(int) PySys_HasWarnOptions(void);\n\nPyAPI_FUNC(void) PySys_AddXOption(const wchar_t *);\nPyAPI_FUNC(PyObject *) PySys_GetXOptions(void);\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_SYSMODULE_H\n#  include  \"cpython/sysmodule.h\"\n#  undef Py_CPYTHON_SYSMODULE_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_SYSMODULE_H */\n"}, "132": {"id": 132, "path": "/usr/include/python3.8/traceback.h", "content": "#ifndef Py_TRACEBACK_H\n#define Py_TRACEBACK_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct _frame;\n\n/* Traceback interface */\n\nPyAPI_FUNC(int) PyTraceBack_Here(struct _frame *);\nPyAPI_FUNC(int) PyTraceBack_Print(PyObject *, PyObject *);\n\n/* Reveal traceback type so we can typecheck traceback objects */\nPyAPI_DATA(PyTypeObject) PyTraceBack_Type;\n#define PyTraceBack_Check(v) (Py_TYPE(v) == &PyTraceBack_Type)\n\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_TRACEBACK_H\n#  include  \"cpython/traceback.h\"\n#  undef Py_CPYTHON_TRACEBACK_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_TRACEBACK_H */\n"}, "133": {"id": 133, "path": "/usr/include/python3.8/tracemalloc.h", "content": "#ifndef Py_TRACEMALLOC_H\n#define Py_TRACEMALLOC_H\n\n#ifndef Py_LIMITED_API\n/* Track an allocated memory block in the tracemalloc module.\n   Return 0 on success, return -1 on error (failed to allocate memory to store\n   the trace).\n\n   Return -2 if tracemalloc is disabled.\n\n   If memory block is already tracked, update the existing trace. */\nPyAPI_FUNC(int) PyTraceMalloc_Track(\n    unsigned int domain,\n    uintptr_t ptr,\n    size_t size);\n\n/* Untrack an allocated memory block in the tracemalloc module.\n   Do nothing if the block was not tracked.\n\n   Return -2 if tracemalloc is disabled, otherwise return 0. */\nPyAPI_FUNC(int) PyTraceMalloc_Untrack(\n    unsigned int domain,\n    uintptr_t ptr);\n\n/* Get the traceback where a memory block was allocated.\n\n   Return a tuple of (filename: str, lineno: int) tuples.\n\n   Return None if the tracemalloc module is disabled or if the memory block\n   is not tracked by tracemalloc.\n\n   Raise an exception and return NULL on error. */\nPyAPI_FUNC(PyObject*) _PyTraceMalloc_GetTraceback(\n    unsigned int domain,\n    uintptr_t ptr);\n#endif\n\n#endif /* !Py_TRACEMALLOC_H */\n"}, "134": {"id": 134, "path": "/usr/include/python3.8/tupleobject.h", "content": "/* Tuple object interface */\n\n#ifndef Py_TUPLEOBJECT_H\n#define Py_TUPLEOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\nAnother generally useful object type is a tuple of object pointers.\nFor Python, this is an immutable type.  C code can change the tuple items\n(but not their number), and even use tuples as general-purpose arrays of\nobject references, but in general only brand new tuples should be mutated,\nnot ones that might already have been exposed to Python code.\n\n*** WARNING *** PyTuple_SetItem does not increment the new item's reference\ncount, but does decrement the reference count of the item it replaces,\nif not nil.  It does *decrement* the reference count if it is *not*\ninserted in the tuple.  Similarly, PyTuple_GetItem does not increment the\nreturned item's reference count.\n*/\n\nPyAPI_DATA(PyTypeObject) PyTuple_Type;\nPyAPI_DATA(PyTypeObject) PyTupleIter_Type;\n\n#define PyTuple_Check(op) \\\n                 PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)\n#define PyTuple_CheckExact(op) (Py_TYPE(op) == &PyTuple_Type)\n\nPyAPI_FUNC(PyObject *) PyTuple_New(Py_ssize_t size);\nPyAPI_FUNC(Py_ssize_t) PyTuple_Size(PyObject *);\nPyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, Py_ssize_t);\nPyAPI_FUNC(int) PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);\nPyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);\nPyAPI_FUNC(PyObject *) PyTuple_Pack(Py_ssize_t, ...);\n\nPyAPI_FUNC(int) PyTuple_ClearFreeList(void);\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_TUPLEOBJECT_H\n#  include  \"cpython/tupleobject.h\"\n#  undef Py_CPYTHON_TUPLEOBJECT_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_TUPLEOBJECT_H */\n"}, "135": {"id": 135, "path": "/usr/include/python3.8/typeslots.h", "content": "/* Do not renumber the file; these numbers are part of the stable ABI. */\n/* Disabled, see #10181 */\n#undef Py_bf_getbuffer\n#undef Py_bf_releasebuffer\n#define Py_mp_ass_subscript 3\n#define Py_mp_length 4\n#define Py_mp_subscript 5\n#define Py_nb_absolute 6\n#define Py_nb_add 7\n#define Py_nb_and 8\n#define Py_nb_bool 9\n#define Py_nb_divmod 10\n#define Py_nb_float 11\n#define Py_nb_floor_divide 12\n#define Py_nb_index 13\n#define Py_nb_inplace_add 14\n#define Py_nb_inplace_and 15\n#define Py_nb_inplace_floor_divide 16\n#define Py_nb_inplace_lshift 17\n#define Py_nb_inplace_multiply 18\n#define Py_nb_inplace_or 19\n#define Py_nb_inplace_power 20\n#define Py_nb_inplace_remainder 21\n#define Py_nb_inplace_rshift 22\n#define Py_nb_inplace_subtract 23\n#define Py_nb_inplace_true_divide 24\n#define Py_nb_inplace_xor 25\n#define Py_nb_int 26\n#define Py_nb_invert 27\n#define Py_nb_lshift 28\n#define Py_nb_multiply 29\n#define Py_nb_negative 30\n#define Py_nb_or 31\n#define Py_nb_positive 32\n#define Py_nb_power 33\n#define Py_nb_remainder 34\n#define Py_nb_rshift 35\n#define Py_nb_subtract 36\n#define Py_nb_true_divide 37\n#define Py_nb_xor 38\n#define Py_sq_ass_item 39\n#define Py_sq_concat 40\n#define Py_sq_contains 41\n#define Py_sq_inplace_concat 42\n#define Py_sq_inplace_repeat 43\n#define Py_sq_item 44\n#define Py_sq_length 45\n#define Py_sq_repeat 46\n#define Py_tp_alloc 47\n#define Py_tp_base 48\n#define Py_tp_bases 49\n#define Py_tp_call 50\n#define Py_tp_clear 51\n#define Py_tp_dealloc 52\n#define Py_tp_del 53\n#define Py_tp_descr_get 54\n#define Py_tp_descr_set 55\n#define Py_tp_doc 56\n#define Py_tp_getattr 57\n#define Py_tp_getattro 58\n#define Py_tp_hash 59\n#define Py_tp_init 60\n#define Py_tp_is_gc 61\n#define Py_tp_iter 62\n#define Py_tp_iternext 63\n#define Py_tp_methods 64\n#define Py_tp_new 65\n#define Py_tp_repr 66\n#define Py_tp_richcompare 67\n#define Py_tp_setattr 68\n#define Py_tp_setattro 69\n#define Py_tp_str 70\n#define Py_tp_traverse 71\n#define Py_tp_members 72\n#define Py_tp_getset 73\n#define Py_tp_free 74\n#define Py_nb_matrix_multiply 75\n#define Py_nb_inplace_matrix_multiply 76\n#define Py_am_await 77\n#define Py_am_aiter 78\n#define Py_am_anext 79\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000\n/* New in 3.5 */\n#define Py_tp_finalize 80\n#endif\n"}, "136": {"id": 136, "path": "/usr/include/python3.8/unicodeobject.h", "content": "#ifndef Py_UNICODEOBJECT_H\n#define Py_UNICODEOBJECT_H\n\n#include <stdarg.h>\n\n/*\n\nUnicode implementation based on original code by Fredrik Lundh,\nmodified by Marc-Andre Lemburg (mal@lemburg.com) according to the\nUnicode Integration Proposal. (See\nhttp://www.egenix.com/files/python/unicode-proposal.txt).\n\nCopyright (c) Corporation for National Research Initiatives.\n\n\n Original header:\n --------------------------------------------------------------------\n\n * Yet another Unicode string type for Python.  This type supports the\n * 16-bit Basic Multilingual Plane (BMP) only.\n *\n * Written by Fredrik Lundh, January 1999.\n *\n * Copyright (c) 1999 by Secret Labs AB.\n * Copyright (c) 1999 by Fredrik Lundh.\n *\n * fredrik@pythonware.com\n * http://www.pythonware.com\n *\n * --------------------------------------------------------------------\n * This Unicode String Type is\n *\n * Copyright (c) 1999 by Secret Labs AB\n * Copyright (c) 1999 by Fredrik Lundh\n *\n * By obtaining, using, and/or copying this software and/or its\n * associated documentation, you agree that you have read, understood,\n * and will comply with the following terms and conditions:\n *\n * Permission to use, copy, modify, and distribute this software and its\n * associated documentation for any purpose and without fee is hereby\n * granted, provided that the above copyright notice appears in all\n * copies, and that both that copyright notice and this permission notice\n * appear in supporting documentation, and that the name of Secret Labs\n * AB or the author not be used in advertising or publicity pertaining to\n * distribution of the software without specific, written prior\n * permission.\n *\n * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n * -------------------------------------------------------------------- */\n\n#include <ctype.h>\n\n/* === Internal API ======================================================= */\n\n/* --- Internal Unicode Format -------------------------------------------- */\n\n/* Python 3.x requires unicode */\n#define Py_USING_UNICODE\n\n#ifndef SIZEOF_WCHAR_T\n#error Must define SIZEOF_WCHAR_T\n#endif\n\n#define Py_UNICODE_SIZE SIZEOF_WCHAR_T\n\n/* If wchar_t can be used for UCS-4 storage, set Py_UNICODE_WIDE.\n   Otherwise, Unicode strings are stored as UCS-2 (with limited support\n   for UTF-16) */\n\n#if Py_UNICODE_SIZE >= 4\n#define Py_UNICODE_WIDE\n#endif\n\n/* Set these flags if the platform has \"wchar.h\" and the\n   wchar_t type is a 16-bit unsigned type */\n/* #define HAVE_WCHAR_H */\n/* #define HAVE_USABLE_WCHAR_T */\n\n/* If the compiler provides a wchar_t type we try to support it\n   through the interface functions PyUnicode_FromWideChar(),\n   PyUnicode_AsWideChar() and PyUnicode_AsWideCharString(). */\n\n#ifdef HAVE_USABLE_WCHAR_T\n# ifndef HAVE_WCHAR_H\n#  define HAVE_WCHAR_H\n# endif\n#endif\n\n#ifdef HAVE_WCHAR_H\n#  include <wchar.h>\n#endif\n\n/* Py_UCS4 and Py_UCS2 are typedefs for the respective\n   unicode representations. */\ntypedef uint32_t Py_UCS4;\ntypedef uint16_t Py_UCS2;\ntypedef uint8_t Py_UCS1;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nPyAPI_DATA(PyTypeObject) PyUnicode_Type;\nPyAPI_DATA(PyTypeObject) PyUnicodeIter_Type;\n\n#define PyUnicode_Check(op) \\\n                 PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)\n#define PyUnicode_CheckExact(op) (Py_TYPE(op) == &PyUnicode_Type)\n\n/* --- Constants ---------------------------------------------------------- */\n\n/* This Unicode character will be used as replacement character during\n   decoding if the errors argument is set to \"replace\". Note: the\n   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in\n   Unicode 3.0. */\n\n#define Py_UNICODE_REPLACEMENT_CHARACTER ((Py_UCS4) 0xFFFD)\n\n/* === Public API ========================================================= */\n\n/* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */\nPyAPI_FUNC(PyObject*) PyUnicode_FromStringAndSize(\n    const char *u,             /* UTF-8 encoded string */\n    Py_ssize_t size            /* size of buffer */\n    );\n\n/* Similar to PyUnicode_FromUnicode(), but u points to null-terminated\n   UTF-8 encoded bytes.  The size is determined with strlen(). */\nPyAPI_FUNC(PyObject*) PyUnicode_FromString(\n    const char *u              /* UTF-8 encoded string */\n    );\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyUnicode_Substring(\n    PyObject *str,\n    Py_ssize_t start,\n    Py_ssize_t end);\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\n/* Copy the string into a UCS4 buffer including the null character if copy_null\n   is set. Return NULL and raise an exception on error. Raise a SystemError if\n   the buffer is smaller than the string. Return buffer on success.\n\n   buflen is the length of the buffer in (Py_UCS4) characters. */\nPyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4(\n    PyObject *unicode,\n    Py_UCS4* buffer,\n    Py_ssize_t buflen,\n    int copy_null);\n\n/* Copy the string into a UCS4 buffer. A new buffer is allocated using\n * PyMem_Malloc; if this fails, NULL is returned with a memory error\n   exception set. */\nPyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4Copy(PyObject *unicode);\n#endif\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\n/* Get the length of the Unicode object. */\n\nPyAPI_FUNC(Py_ssize_t) PyUnicode_GetLength(\n    PyObject *unicode\n);\n#endif\n\n/* Get the number of Py_UNICODE units in the\n   string representation. */\n\nPy_DEPRECATED(3.3) PyAPI_FUNC(Py_ssize_t) PyUnicode_GetSize(\n    PyObject *unicode           /* Unicode object */\n    );\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\n/* Read a character from the string. */\n\nPyAPI_FUNC(Py_UCS4) PyUnicode_ReadChar(\n    PyObject *unicode,\n    Py_ssize_t index\n    );\n\n/* Write a character to the string. The string must have been created through\n   PyUnicode_New, must not be shared, and must not have been hashed yet.\n\n   Return 0 on success, -1 on error. */\n\nPyAPI_FUNC(int) PyUnicode_WriteChar(\n    PyObject *unicode,\n    Py_ssize_t index,\n    Py_UCS4 character\n    );\n#endif\n\n/* Resize a Unicode object. The length is the number of characters, except\n   if the kind of the string is PyUnicode_WCHAR_KIND: in this case, the length\n   is the number of Py_UNICODE characters.\n\n   *unicode is modified to point to the new (resized) object and 0\n   returned on success.\n\n   Try to resize the string in place (which is usually faster than allocating\n   a new string and copy characters), or create a new string.\n\n   Error handling is implemented as follows: an exception is set, -1\n   is returned and *unicode left untouched.\n\n   WARNING: The function doesn't check string content, the result may not be a\n            string in canonical representation. */\n\nPyAPI_FUNC(int) PyUnicode_Resize(\n    PyObject **unicode,         /* Pointer to the Unicode object */\n    Py_ssize_t length           /* New length */\n    );\n\n/* Decode obj to a Unicode object.\n\n   bytes, bytearray and other bytes-like objects are decoded according to the\n   given encoding and error handler. The encoding and error handler can be\n   NULL to have the interface use UTF-8 and \"strict\".\n\n   All other objects (including Unicode objects) raise an exception.\n\n   The API returns NULL in case of an error. The caller is responsible\n   for decref'ing the returned objects.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(\n    PyObject *obj,              /* Object */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* Copy an instance of a Unicode subtype to a new true Unicode object if\n   necessary. If obj is already a true Unicode object (not a subtype), return\n   the reference with *incremented* refcount.\n\n   The API returns NULL in case of an error. The caller is responsible\n   for decref'ing the returned objects.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_FromObject(\n    PyObject *obj      /* Object */\n    );\n\nPyAPI_FUNC(PyObject *) PyUnicode_FromFormatV(\n    const char *format,   /* ASCII-encoded string  */\n    va_list vargs\n    );\nPyAPI_FUNC(PyObject *) PyUnicode_FromFormat(\n    const char *format,   /* ASCII-encoded string  */\n    ...\n    );\n\nPyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);\nPyAPI_FUNC(void) PyUnicode_InternImmortal(PyObject **);\nPyAPI_FUNC(PyObject *) PyUnicode_InternFromString(\n    const char *u              /* UTF-8 encoded string */\n    );\n\n/* Use only if you know it's a string */\n#define PyUnicode_CHECK_INTERNED(op) \\\n    (((PyASCIIObject *)(op))->state.interned)\n\n/* --- wchar_t support for platforms which support it --------------------- */\n\n#ifdef HAVE_WCHAR_H\n\n/* Create a Unicode Object from the wchar_t buffer w of the given\n   size.\n\n   The buffer is copied into the new object. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(\n    const wchar_t *w,           /* wchar_t buffer */\n    Py_ssize_t size             /* size of buffer */\n    );\n\n/* Copies the Unicode Object contents into the wchar_t buffer w.  At\n   most size wchar_t characters are copied.\n\n   Note that the resulting wchar_t string may or may not be\n   0-terminated.  It is the responsibility of the caller to make sure\n   that the wchar_t string is 0-terminated in case this is required by\n   the application.\n\n   Returns the number of wchar_t characters copied (excluding a\n   possibly trailing 0-termination character) or -1 in case of an\n   error. */\n\nPyAPI_FUNC(Py_ssize_t) PyUnicode_AsWideChar(\n    PyObject *unicode,          /* Unicode object */\n    wchar_t *w,                 /* wchar_t buffer */\n    Py_ssize_t size             /* size of buffer */\n    );\n\n/* Convert the Unicode object to a wide character string. The output string\n   always ends with a nul character. If size is not NULL, write the number of\n   wide characters (excluding the null character) into *size.\n\n   Returns a buffer allocated by PyMem_Malloc() (use PyMem_Free() to free it)\n   on success. On error, returns NULL, *size is undefined and raises a\n   MemoryError. */\n\nPyAPI_FUNC(wchar_t*) PyUnicode_AsWideCharString(\n    PyObject *unicode,          /* Unicode object */\n    Py_ssize_t *size            /* number of characters of the result */\n    );\n\n#endif\n\n/* --- Unicode ordinals --------------------------------------------------- */\n\n/* Create a Unicode Object from the given Unicode code point ordinal.\n\n   The ordinal must be in range(0x110000). A ValueError is\n   raised in case it is not.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);\n\n/* --- Free-list management ----------------------------------------------- */\n\n/* Clear the free list used by the Unicode implementation.\n\n   This can be used to release memory used for objects on the free\n   list back to the Python memory allocator.\n\n*/\n\nPyAPI_FUNC(int) PyUnicode_ClearFreeList(void);\n\n/* === Builtin Codecs =====================================================\n\n   Many of these APIs take two arguments encoding and errors. These\n   parameters encoding and errors have the same semantics as the ones\n   of the builtin str() API.\n\n   Setting encoding to NULL causes the default encoding (UTF-8) to be used.\n\n   Error handling is set by errors which may also be set to NULL\n   meaning to use the default handling defined for the codec. Default\n   error handling for all builtin codecs is \"strict\" (ValueErrors are\n   raised).\n\n   The codecs all use a similar interface. Only deviation from the\n   generic ones are documented.\n\n*/\n\n/* --- Manage the default encoding ---------------------------------------- */\n\n/* Returns \"utf-8\".  */\nPyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);\n\n/* --- Generic Codecs ----------------------------------------------------- */\n\n/* Create a Unicode object by decoding the encoded string s of the\n   given size. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_Decode(\n    const char *s,              /* encoded string */\n    Py_ssize_t size,            /* size of buffer */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* Decode a Unicode object unicode and return the result as Python\n   object.\n\n   This API is DEPRECATED. The only supported standard encoding is rot13.\n   Use PyCodec_Decode() to decode with rot13 and non-standard codecs\n   that decode from str. */\n\nPy_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedObject(\n    PyObject *unicode,          /* Unicode object */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* Decode a Unicode object unicode and return the result as Unicode\n   object.\n\n   This API is DEPRECATED. The only supported standard encoding is rot13.\n   Use PyCodec_Decode() to decode with rot13 and non-standard codecs\n   that decode from str to str. */\n\nPy_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedUnicode(\n    PyObject *unicode,          /* Unicode object */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* Encodes a Unicode object and returns the result as Python\n   object.\n\n   This API is DEPRECATED.  It is superseded by PyUnicode_AsEncodedString()\n   since all standard encodings (except rot13) encode str to bytes.\n   Use PyCodec_Encode() for encoding with rot13 and non-standard codecs\n   that encode form str to non-bytes. */\n\nPy_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(\n    PyObject *unicode,          /* Unicode object */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* Encodes a Unicode object and returns the result as Python string\n   object. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(\n    PyObject *unicode,          /* Unicode object */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* Encodes a Unicode object and returns the result as Unicode\n   object.\n\n   This API is DEPRECATED.  The only supported standard encodings is rot13.\n   Use PyCodec_Encode() to encode with rot13 and non-standard codecs\n   that encode from str to str. */\n\nPy_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedUnicode(\n    PyObject *unicode,          /* Unicode object */\n    const char *encoding,       /* encoding */\n    const char *errors          /* error handling */\n    );\n\n/* Build an encoding map. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_BuildEncodingMap(\n    PyObject* string            /* 256 character map */\n   );\n\n/* --- UTF-7 Codecs ------------------------------------------------------- */\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(\n    const char *string,         /* UTF-7 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7Stateful(\n    const char *string,         /* UTF-7 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    Py_ssize_t *consumed        /* bytes consumed */\n    );\n\n/* --- UTF-8 Codecs ------------------------------------------------------- */\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(\n    const char *string,         /* UTF-8 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(\n    const char *string,         /* UTF-8 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    Py_ssize_t *consumed        /* bytes consumed */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* --- UTF-32 Codecs ------------------------------------------------------ */\n\n/* Decodes length bytes from a UTF-32 encoded buffer string and returns\n   the corresponding Unicode object.\n\n   errors (if non-NULL) defines the error handling. It defaults\n   to \"strict\".\n\n   If byteorder is non-NULL, the decoder starts decoding using the\n   given byte order:\n\n    *byteorder == -1: little endian\n    *byteorder == 0:  native order\n    *byteorder == 1:  big endian\n\n   In native mode, the first four bytes of the stream are checked for a\n   BOM mark. If found, the BOM mark is analysed, the byte order\n   adjusted and the BOM skipped.  In the other modes, no BOM mark\n   interpretation is done. After completion, *byteorder is set to the\n   current byte order at the end of input data.\n\n   If byteorder is NULL, the codec starts in native order mode.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32(\n    const char *string,         /* UTF-32 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    int *byteorder              /* pointer to byteorder to use\n                                   0=native;-1=LE,1=BE; updated on\n                                   exit */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32Stateful(\n    const char *string,         /* UTF-32 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    int *byteorder,             /* pointer to byteorder to use\n                                   0=native;-1=LE,1=BE; updated on\n                                   exit */\n    Py_ssize_t *consumed        /* bytes consumed */\n    );\n\n/* Returns a Python string using the UTF-32 encoding in native byte\n   order. The string always starts with a BOM mark.  */\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsUTF32String(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* Returns a Python string object holding the UTF-32 encoded value of\n   the Unicode data.\n\n   If byteorder is not 0, output is written according to the following\n   byte order:\n\n   byteorder == -1: little endian\n   byteorder == 0:  native byte order (writes a BOM mark)\n   byteorder == 1:  big endian\n\n   If byteorder is 0, the output string will always start with the\n   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is\n   prepended.\n\n*/\n\n/* --- UTF-16 Codecs ------------------------------------------------------ */\n\n/* Decodes length bytes from a UTF-16 encoded buffer string and returns\n   the corresponding Unicode object.\n\n   errors (if non-NULL) defines the error handling. It defaults\n   to \"strict\".\n\n   If byteorder is non-NULL, the decoder starts decoding using the\n   given byte order:\n\n    *byteorder == -1: little endian\n    *byteorder == 0:  native order\n    *byteorder == 1:  big endian\n\n   In native mode, the first two bytes of the stream are checked for a\n   BOM mark. If found, the BOM mark is analysed, the byte order\n   adjusted and the BOM skipped.  In the other modes, no BOM mark\n   interpretation is done. After completion, *byteorder is set to the\n   current byte order at the end of input data.\n\n   If byteorder is NULL, the codec starts in native order mode.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(\n    const char *string,         /* UTF-16 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    int *byteorder              /* pointer to byteorder to use\n                                   0=native;-1=LE,1=BE; updated on\n                                   exit */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(\n    const char *string,         /* UTF-16 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    int *byteorder,             /* pointer to byteorder to use\n                                   0=native;-1=LE,1=BE; updated on\n                                   exit */\n    Py_ssize_t *consumed        /* bytes consumed */\n    );\n\n/* Returns a Python string using the UTF-16 encoding in native byte\n   order. The string always starts with a BOM mark.  */\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* --- Unicode-Escape Codecs ---------------------------------------------- */\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(\n    const char *string,         /* Unicode-Escape encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(\n    const char *string,         /* Raw-Unicode-Escape encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* --- Latin-1 Codecs -----------------------------------------------------\n\n   Note: Latin-1 corresponds to the first 256 Unicode ordinals. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(\n    const char *string,         /* Latin-1 encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* --- ASCII Codecs -------------------------------------------------------\n\n   Only 7-bit ASCII data is excepted. All other codes generate errors.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(\n    const char *string,         /* ASCII encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(\n    PyObject *unicode           /* Unicode object */\n    );\n\n/* --- Character Map Codecs -----------------------------------------------\n\n   This codec uses mappings to encode and decode characters.\n\n   Decoding mappings must map byte ordinals (integers in the range from 0 to\n   255) to Unicode strings, integers (which are then interpreted as Unicode\n   ordinals) or None.  Unmapped data bytes (ones which cause a LookupError)\n   as well as mapped to None, 0xFFFE or '\\ufffe' are treated as \"undefined\n   mapping\" and cause an error.\n\n   Encoding mappings must map Unicode ordinal integers to bytes objects,\n   integers in the range from 0 to 255 or None.  Unmapped character\n   ordinals (ones which cause a LookupError) as well as mapped to\n   None are treated as \"undefined mapping\" and cause an error.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(\n    const char *string,         /* Encoded string */\n    Py_ssize_t length,          /* size of string */\n    PyObject *mapping,          /* decoding mapping */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(\n    PyObject *unicode,          /* Unicode object */\n    PyObject *mapping           /* encoding mapping */\n    );\n\n/* --- MBCS codecs for Windows -------------------------------------------- */\n\n#ifdef MS_WINDOWS\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(\n    const char *string,         /* MBCS encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors          /* error handling */\n    );\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCSStateful(\n    const char *string,         /* MBCS encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    Py_ssize_t *consumed        /* bytes consumed */\n    );\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeCodePageStateful(\n    int code_page,              /* code page number */\n    const char *string,         /* encoded string */\n    Py_ssize_t length,          /* size of string */\n    const char *errors,         /* error handling */\n    Py_ssize_t *consumed        /* bytes consumed */\n    );\n#endif\n\nPyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(\n    PyObject *unicode           /* Unicode object */\n    );\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\nPyAPI_FUNC(PyObject*) PyUnicode_EncodeCodePage(\n    int code_page,              /* code page number */\n    PyObject *unicode,          /* Unicode object */\n    const char *errors          /* error handling */\n    );\n#endif\n\n#endif /* MS_WINDOWS */\n\n/* --- Locale encoding --------------------------------------------------- */\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\n/* Decode a string from the current locale encoding. The decoder is strict if\n   *surrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'\n   error handler (PEP 383) to escape undecodable bytes. If a byte sequence can\n   be decoded as a surrogate character and *surrogateescape* is not equal to\n   zero, the byte sequence is escaped using the 'surrogateescape' error handler\n   instead of being decoded. *str* must end with a null character but cannot\n   contain embedded null characters. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeLocaleAndSize(\n    const char *str,\n    Py_ssize_t len,\n    const char *errors);\n\n/* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string\n   length using strlen(). */\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeLocale(\n    const char *str,\n    const char *errors);\n\n/* Encode a Unicode object to the current locale encoding. The encoder is\n   strict is *surrogateescape* is equal to zero, otherwise the\n   \"surrogateescape\" error handler is used. Return a bytes object. The string\n   cannot contain embedded null characters. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_EncodeLocale(\n    PyObject *unicode,\n    const char *errors\n    );\n#endif\n\n/* --- File system encoding ---------------------------------------------- */\n\n/* ParseTuple converter: encode str objects to bytes using\n   PyUnicode_EncodeFSDefault(); bytes objects are output as-is. */\n\nPyAPI_FUNC(int) PyUnicode_FSConverter(PyObject*, void*);\n\n/* ParseTuple converter: decode bytes objects to unicode using\n   PyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is. */\n\nPyAPI_FUNC(int) PyUnicode_FSDecoder(PyObject*, void*);\n\n/* Decode a null-terminated string using Py_FileSystemDefaultEncoding\n   and the \"surrogateescape\" error handler.\n\n   If Py_FileSystemDefaultEncoding is not set, fall back to the locale\n   encoding.\n\n   Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefault(\n    const char *s               /* encoded string */\n    );\n\n/* Decode a string using Py_FileSystemDefaultEncoding\n   and the \"surrogateescape\" error handler.\n\n   If Py_FileSystemDefaultEncoding is not set, fall back to the locale\n   encoding.\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefaultAndSize(\n    const char *s,               /* encoded string */\n    Py_ssize_t size              /* size */\n    );\n\n/* Encode a Unicode object to Py_FileSystemDefaultEncoding with the\n   \"surrogateescape\" error handler, and return bytes.\n\n   If Py_FileSystemDefaultEncoding is not set, fall back to the locale\n   encoding.\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_EncodeFSDefault(\n    PyObject *unicode\n    );\n\n/* --- Methods & Slots ----------------------------------------------------\n\n   These are capable of handling Unicode objects and strings on input\n   (we refer to them as strings in the descriptions) and return\n   Unicode objects or integers as appropriate. */\n\n/* Concat two strings giving a new Unicode string. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_Concat(\n    PyObject *left,             /* Left string */\n    PyObject *right             /* Right string */\n    );\n\n/* Concat two strings and put the result in *pleft\n   (sets *pleft to NULL on error) */\n\nPyAPI_FUNC(void) PyUnicode_Append(\n    PyObject **pleft,           /* Pointer to left string */\n    PyObject *right             /* Right string */\n    );\n\n/* Concat two strings, put the result in *pleft and drop the right object\n   (sets *pleft to NULL on error) */\n\nPyAPI_FUNC(void) PyUnicode_AppendAndDel(\n    PyObject **pleft,           /* Pointer to left string */\n    PyObject *right             /* Right string */\n    );\n\n/* Split a string giving a list of Unicode strings.\n\n   If sep is NULL, splitting will be done at all whitespace\n   substrings. Otherwise, splits occur at the given separator.\n\n   At most maxsplit splits will be done. If negative, no limit is set.\n\n   Separators are not included in the resulting list.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_Split(\n    PyObject *s,                /* String to split */\n    PyObject *sep,              /* String separator */\n    Py_ssize_t maxsplit         /* Maxsplit count */\n    );\n\n/* Dito, but split at line breaks.\n\n   CRLF is considered to be one line break. Line breaks are not\n   included in the resulting list. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_Splitlines(\n    PyObject *s,                /* String to split */\n    int keepends                /* If true, line end markers are included */\n    );\n\n/* Partition a string using a given separator. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_Partition(\n    PyObject *s,                /* String to partition */\n    PyObject *sep               /* String separator */\n    );\n\n/* Partition a string using a given separator, searching from the end of the\n   string. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_RPartition(\n    PyObject *s,                /* String to partition */\n    PyObject *sep               /* String separator */\n    );\n\n/* Split a string giving a list of Unicode strings.\n\n   If sep is NULL, splitting will be done at all whitespace\n   substrings. Otherwise, splits occur at the given separator.\n\n   At most maxsplit splits will be done. But unlike PyUnicode_Split\n   PyUnicode_RSplit splits from the end of the string. If negative,\n   no limit is set.\n\n   Separators are not included in the resulting list.\n\n*/\n\nPyAPI_FUNC(PyObject*) PyUnicode_RSplit(\n    PyObject *s,                /* String to split */\n    PyObject *sep,              /* String separator */\n    Py_ssize_t maxsplit         /* Maxsplit count */\n    );\n\n/* Translate a string by applying a character mapping table to it and\n   return the resulting Unicode object.\n\n   The mapping table must map Unicode ordinal integers to Unicode strings,\n   Unicode ordinal integers or None (causing deletion of the character).\n\n   Mapping tables may be dictionaries or sequences. Unmapped character\n   ordinals (ones which cause a LookupError) are left untouched and\n   are copied as-is.\n\n*/\n\nPyAPI_FUNC(PyObject *) PyUnicode_Translate(\n    PyObject *str,              /* String */\n    PyObject *table,            /* Translate table */\n    const char *errors          /* error handling */\n    );\n\n/* Join a sequence of strings using the given separator and return\n   the resulting Unicode string. */\n\nPyAPI_FUNC(PyObject*) PyUnicode_Join(\n    PyObject *separator,        /* Separator string */\n    PyObject *seq               /* Sequence object */\n    );\n\n/* Return 1 if substr matches str[start:end] at the given tail end, 0\n   otherwise. */\n\nPyAPI_FUNC(Py_ssize_t) PyUnicode_Tailmatch(\n    PyObject *str,              /* String */\n    PyObject *substr,           /* Prefix or Suffix string */\n    Py_ssize_t start,           /* Start index */\n    Py_ssize_t end,             /* Stop index */\n    int direction               /* Tail end: -1 prefix, +1 suffix */\n    );\n\n/* Return the first position of substr in str[start:end] using the\n   given search direction or -1 if not found. -2 is returned in case\n   an error occurred and an exception is set. */\n\nPyAPI_FUNC(Py_ssize_t) PyUnicode_Find(\n    PyObject *str,              /* String */\n    PyObject *substr,           /* Substring to find */\n    Py_ssize_t start,           /* Start index */\n    Py_ssize_t end,             /* Stop index */\n    int direction               /* Find direction: +1 forward, -1 backward */\n    );\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000\n/* Like PyUnicode_Find, but search for single character only. */\nPyAPI_FUNC(Py_ssize_t) PyUnicode_FindChar(\n    PyObject *str,\n    Py_UCS4 ch,\n    Py_ssize_t start,\n    Py_ssize_t end,\n    int direction\n    );\n#endif\n\n/* Count the number of occurrences of substr in str[start:end]. */\n\nPyAPI_FUNC(Py_ssize_t) PyUnicode_Count(\n    PyObject *str,              /* String */\n    PyObject *substr,           /* Substring to count */\n    Py_ssize_t start,           /* Start index */\n    Py_ssize_t end              /* Stop index */\n    );\n\n/* Replace at most maxcount occurrences of substr in str with replstr\n   and return the resulting Unicode object. */\n\nPyAPI_FUNC(PyObject *) PyUnicode_Replace(\n    PyObject *str,              /* String */\n    PyObject *substr,           /* Substring to find */\n    PyObject *replstr,          /* Substring to replace */\n    Py_ssize_t maxcount         /* Max. number of replacements to apply;\n                                   -1 = all */\n    );\n\n/* Compare two strings and return -1, 0, 1 for less than, equal,\n   greater than resp.\n   Raise an exception and return -1 on error. */\n\nPyAPI_FUNC(int) PyUnicode_Compare(\n    PyObject *left,             /* Left string */\n    PyObject *right             /* Right string */\n    );\n\n/* Compare a Unicode object with C string and return -1, 0, 1 for less than,\n   equal, and greater than, respectively.  It is best to pass only\n   ASCII-encoded strings, but the function interprets the input string as\n   ISO-8859-1 if it contains non-ASCII characters.\n   This function does not raise exceptions. */\n\nPyAPI_FUNC(int) PyUnicode_CompareWithASCIIString(\n    PyObject *left,\n    const char *right           /* ASCII-encoded string */\n    );\n\n/* Rich compare two strings and return one of the following:\n\n   - NULL in case an exception was raised\n   - Py_True or Py_False for successful comparisons\n   - Py_NotImplemented in case the type combination is unknown\n\n   Possible values for op:\n\n     Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE\n\n*/\n\nPyAPI_FUNC(PyObject *) PyUnicode_RichCompare(\n    PyObject *left,             /* Left string */\n    PyObject *right,            /* Right string */\n    int op                      /* Operation: Py_EQ, Py_NE, Py_GT, etc. */\n    );\n\n/* Apply an argument tuple or dictionary to a format string and return\n   the resulting Unicode string. */\n\nPyAPI_FUNC(PyObject *) PyUnicode_Format(\n    PyObject *format,           /* Format string */\n    PyObject *args              /* Argument tuple or dictionary */\n    );\n\n/* Checks whether element is contained in container and return 1/0\n   accordingly.\n\n   element has to coerce to a one element Unicode string. -1 is\n   returned in case of an error. */\n\nPyAPI_FUNC(int) PyUnicode_Contains(\n    PyObject *container,        /* Container string */\n    PyObject *element           /* Element string */\n    );\n\n/* Checks whether argument is a valid identifier. */\n\nPyAPI_FUNC(int) PyUnicode_IsIdentifier(PyObject *s);\n\n/* === Characters Type APIs =============================================== */\n\n#ifndef Py_LIMITED_API\n#  define Py_CPYTHON_UNICODEOBJECT_H\n#  include  \"cpython/unicodeobject.h\"\n#  undef Py_CPYTHON_UNICODEOBJECT_H\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_UNICODEOBJECT_H */\n"}, "137": {"id": 137, "path": "/usr/include/python3.8/warnings.h", "content": "#ifndef Py_WARNINGS_H\n#define Py_WARNINGS_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(PyObject*) _PyWarnings_Init(void);\n#endif\n\nPyAPI_FUNC(int) PyErr_WarnEx(\n    PyObject *category,\n    const char *message,        /* UTF-8 encoded string */\n    Py_ssize_t stack_level);\nPyAPI_FUNC(int) PyErr_WarnFormat(\n    PyObject *category,\n    Py_ssize_t stack_level,\n    const char *format,         /* ASCII-encoded string  */\n    ...);\n\n#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000\n/* Emit a ResourceWarning warning */\nPyAPI_FUNC(int) PyErr_ResourceWarning(\n    PyObject *source,\n    Py_ssize_t stack_level,\n    const char *format,         /* ASCII-encoded string  */\n    ...);\n#endif\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int) PyErr_WarnExplicitObject(\n    PyObject *category,\n    PyObject *message,\n    PyObject *filename,\n    int lineno,\n    PyObject *module,\n    PyObject *registry);\n#endif\nPyAPI_FUNC(int) PyErr_WarnExplicit(\n    PyObject *category,\n    const char *message,        /* UTF-8 encoded string */\n    const char *filename,       /* decoded from the filesystem encoding */\n    int lineno,\n    const char *module,         /* UTF-8 encoded string */\n    PyObject *registry);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(int)\nPyErr_WarnExplicitFormat(PyObject *category,\n                         const char *filename, int lineno,\n                         const char *module, PyObject *registry,\n                         const char *format, ...);\n#endif\n\n/* DEPRECATED: Use PyErr_WarnEx() instead. */\n#ifndef Py_LIMITED_API\n#define PyErr_Warn(category, msg) PyErr_WarnEx(category, msg, 1)\n#endif\n\n#ifndef Py_LIMITED_API\nvoid _PyErr_WarnUnawaitedCoroutine(PyObject *coro);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_WARNINGS_H */\n\n"}, "138": {"id": 138, "path": "/usr/include/python3.8/weakrefobject.h", "content": "/* Weak references objects for Python. */\n\n#ifndef Py_WEAKREFOBJECT_H\n#define Py_WEAKREFOBJECT_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\ntypedef struct _PyWeakReference PyWeakReference;\n\n/* PyWeakReference is the base struct for the Python ReferenceType, ProxyType,\n * and CallableProxyType.\n */\n#ifndef Py_LIMITED_API\nstruct _PyWeakReference {\n    PyObject_HEAD\n\n    /* The object to which this is a weak reference, or Py_None if none.\n     * Note that this is a stealth reference:  wr_object's refcount is\n     * not incremented to reflect this pointer.\n     */\n    PyObject *wr_object;\n\n    /* A callable to invoke when wr_object dies, or NULL if none. */\n    PyObject *wr_callback;\n\n    /* A cache for wr_object's hash code.  As usual for hashes, this is -1\n     * if the hash code isn't known yet.\n     */\n    Py_hash_t hash;\n\n    /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL-\n     * terminated list of weak references to it.  These are the list pointers.\n     * If wr_object goes away, wr_object is set to Py_None, and these pointers\n     * have no meaning then.\n     */\n    PyWeakReference *wr_prev;\n    PyWeakReference *wr_next;\n};\n#endif\n\nPyAPI_DATA(PyTypeObject) _PyWeakref_RefType;\nPyAPI_DATA(PyTypeObject) _PyWeakref_ProxyType;\nPyAPI_DATA(PyTypeObject) _PyWeakref_CallableProxyType;\n\n#define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &_PyWeakref_RefType)\n#define PyWeakref_CheckRefExact(op) \\\n        (Py_TYPE(op) == &_PyWeakref_RefType)\n#define PyWeakref_CheckProxy(op) \\\n        ((Py_TYPE(op) == &_PyWeakref_ProxyType) || \\\n         (Py_TYPE(op) == &_PyWeakref_CallableProxyType))\n\n#define PyWeakref_Check(op) \\\n        (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))\n\n\nPyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,\n                                              PyObject *callback);\nPyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,\n                                                PyObject *callback);\nPyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);\n\n#ifndef Py_LIMITED_API\nPyAPI_FUNC(Py_ssize_t) _PyWeakref_GetWeakrefCount(PyWeakReference *head);\n\nPyAPI_FUNC(void) _PyWeakref_ClearRef(PyWeakReference *self);\n#endif\n\n/* Explanation for the Py_REFCNT() check: when a weakref's target is part\n   of a long chain of deallocations which triggers the trashcan mechanism,\n   clearing the weakrefs can be delayed long after the target's refcount\n   has dropped to zero.  In the meantime, code accessing the weakref will\n   be able to \"see\" the target object even though it is supposed to be\n   unreachable.  See issue #16602. */\n\n#define PyWeakref_GET_OBJECT(ref)                           \\\n    (Py_REFCNT(((PyWeakReference *)(ref))->wr_object) > 0   \\\n     ? ((PyWeakReference *)(ref))->wr_object                \\\n     : Py_None)\n\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* !Py_WEAKREFOBJECT_H */\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 5, "line": 48}, "message": "LLVM_LLDB_SOURCE_PLUGINS_SCRIPTINTERPRETER_PYTHON_PYTHONDATAOBJECTS_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 48}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h", "reportHash": "b92550287c6ded45f38cb81377758938", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 9}, "message": "LLVM_LLDB_SOURCE_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTINTERPRETERPYTHON_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/ScriptInterpreterPython.h", "reportHash": "7f0e055699cc9022d2c8285a5be35932", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 7, "line": 9}, "message": "LLVM_LLDB_SOURCE_PLUGINS_SCRIPTINTERPRETER_PYTHON_SCRIPTEDPROCESSPYTHONINTERFACE_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/ScriptedProcessPythonInterface.h", "reportHash": "92f7c7fe7d61d74c3d618ae2513ecd57", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 9}, "message": "LLVM_LLDB_SOURCE_PLUGINS_SCRIPTINTERPRETER_PYTHON_LLDB_PYTHON_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ScriptInterpreter/Python/lldb-python.h", "reportHash": "9f2b53126cf5e1a2a750b23d45ba98b6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 9, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/unittests/ScriptInterpreter/Python/PythonTestSuite.h", "reportHash": "a30d5611074702e730b82a957199ee43", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 44, "file": 20, "line": 812}, "message": "in implicit copy constructor for 'testing::PolymorphicMatcher<testing::internal::PropertyMatcher<lldb_private::python::PythonException, std::basic_string<char>>>' first required here"}, {"location": {"col": 3, "file": 19, "line": 475}, "message": "definition of implicit copy constructor for 'PolymorphicMatcher<testing::internal::PropertyMatcher<lldb_private::python::PythonException, std::basic_string<char>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "da8cebc5e3bcd048b028ebe036150335", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 7, "file": 19, "line": 929}, "message": "in implicit copy constructor for 'testing::internal::ComparisonBase<testing::internal::EqMatcher<long long>, long long, testing::internal::AnyEq>' first required here"}, {"location": {"col": 48, "file": 19, "line": 3766}, "message": "in implicit move constructor for 'testing::internal::EqMatcher<long long>' first required here"}, {"location": {"col": 40, "file": 19, "line": 3771}, "message": "in instantiation of function template specialization 'testing::Eq<long long>' requested here"}, {"location": {"col": 12, "file": 19, "line": 557}, "message": "in instantiation of member function 'testing::Matcher<long long>::Matcher' requested here"}, {"location": {"col": 12, "file": 19, "line": 533}, "message": "in instantiation of member function 'testing::internal::MatcherCastImpl<long long, int>::CastImpl' requested here"}, {"location": {"col": 45, "file": 19, "line": 630}, "message": "(skipping 4 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)"}, {"location": {"col": 12, "file": 19, "line": 533}, "message": "in instantiation of member function 'testing::internal::MatcherCastImpl<const llvm::detail::ExpectedHolder<long long> &, llvm::detail::ValueMatchesPoly<int>>::CastImpl' requested here"}, {"location": {"col": 45, "file": 19, "line": 630}, "message": "in instantiation of member function 'testing::internal::MatcherCastImpl<const llvm::detail::ExpectedHolder<long long> &, llvm::detail::ValueMatchesPoly<int>>::Cast' requested here"}, {"location": {"col": 34, "file": 19, "line": 668}, "message": "in instantiation of function template specialization 'testing::SafeMatcherCastImpl<const llvm::detail::ExpectedHolder<long long> &>::Cast<llvm::detail::ValueMatchesPoly<int>>' requested here"}, {"location": {"col": 39, "file": 19, "line": 1856}, "message": "in instantiation of function template specialization 'testing::SafeMatcherCast<const llvm::detail::ExpectedHolder<long long> &, llvm::detail::ValueMatchesPoly<int>>' requested here"}, {"location": {"col": 3, "file": 20, "line": 129}, "message": "in instantiation of function template specialization 'testing::internal::PredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<int>>::operator()<llvm::detail::ExpectedHolder<long long>>' requested here"}, {"location": {"col": 3, "file": 11, "line": 169}, "message": "expanded from macro 'EXPECT_THAT_EXPECTED'"}, {"location": {"col": 37, "file": 19, "line": 4414}, "message": "expanded from macro 'EXPECT_THAT'"}, {"location": {"col": 3, "file": 21, "line": 114}, "message": "expanded from macro 'EXPECT_PRED_FORMAT1'"}, {"location": {"col": 28, "file": 21, "line": 101}, "message": "expanded from macro 'GTEST_PRED_FORMAT1_'"}, {"location": {"col": 3, "file": 19, "line": 925}, "message": "definition of implicit copy constructor for 'ComparisonBase<testing::internal::EqMatcher<long long>, long long, testing::internal::AnyEq>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "46b6086b04973ce7775feb370e3b3f43", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 7, "file": 12, "line": 1022}, "message": "in implicit copy constructor for 'testing::internal::BothOfMatcher<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>' first required here"}, {"location": {"col": 27, "file": 20, "line": 814}, "message": "in instantiation of function template specialization 'testing::AllOf<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>' requested here"}, {"location": {"col": 3, "file": 19, "line": 1658}, "message": "definition of implicit copy constructor for 'BothOfMatcher<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "291056a390b3a99ceabb8d357dd1caf1", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 12, "line": 1021}, "message": "in implicit copy constructor for 'testing::internal::BothOfMatcher<testing::internal::BothOfMatcher<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>, testing::internal::BothOfMatcher<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>>' first required here"}, {"location": {"col": 27, "file": 20, "line": 814}, "message": "in instantiation of function template specialization 'testing::AllOf<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>' requested here"}, {"location": {"col": 3, "file": 19, "line": 1658}, "message": "definition of implicit copy constructor for 'BothOfMatcher<testing::internal::BothOfMatcher<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>, testing::internal::BothOfMatcher<testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>, testing::PolymorphicMatcher<testing::internal::MatchesRegexMatcher>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "9bf482417be3a0736006bde9e971fa73", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 19, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<llvm::SucceededMatcher>' first required here"}, {"location": {"col": 3, "file": 20, "line": 587}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<llvm::SucceededMatcher>' requested here"}, {"location": {"col": 3, "file": 11, "line": 171}, "message": "expanded from macro 'ASSERT_THAT_EXPECTED'"}, {"location": {"col": 26, "file": 19, "line": 4413}, "message": "expanded from macro 'ASSERT_THAT'"}, {"location": {"col": 3, "file": 19, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<llvm::SucceededMatcher>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "261d9ba0bbc352d32c266c33560ded2e", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 19, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<const char *>>' first required here"}, {"location": {"col": 3, "file": 20, "line": 860}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<const char *>>' requested here"}, {"location": {"col": 3, "file": 11, "line": 171}, "message": "expanded from macro 'ASSERT_THAT_EXPECTED'"}, {"location": {"col": 26, "file": 19, "line": 4413}, "message": "expanded from macro 'ASSERT_THAT'"}, {"location": {"col": 3, "file": 19, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<const char *>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "d97548d3159935ad8f0e3f9cae43a086", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 19, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<int>>' first required here"}, {"location": {"col": 3, "file": 20, "line": 129}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<int>>' requested here"}, {"location": {"col": 3, "file": 11, "line": 169}, "message": "expanded from macro 'EXPECT_THAT_EXPECTED'"}, {"location": {"col": 26, "file": 19, "line": 4415}, "message": "expanded from macro 'EXPECT_THAT'"}, {"location": {"col": 3, "file": 19, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<int>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "d9a6d22d1d9cdd91a1d4db4c2d31a41e", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 19, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<long>>' first required here"}, {"location": {"col": 3, "file": 20, "line": 342}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<long>>' requested here"}, {"location": {"col": 3, "file": 11, "line": 171}, "message": "expanded from macro 'ASSERT_THAT_EXPECTED'"}, {"location": {"col": 26, "file": 19, "line": 4413}, "message": "expanded from macro 'ASSERT_THAT'"}, {"location": {"col": 3, "file": 19, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<llvm::detail::ValueMatchesPoly<long>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "3310de1ae36e47edfd231211b7b3140b", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 19, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<testing::Matcher<const llvm::detail::ErrorHolder &>>' first required here"}, {"location": {"col": 3, "file": 20, "line": 811}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<testing::Matcher<const llvm::detail::ErrorHolder &>>' requested here"}, {"location": {"col": 3, "file": 11, "line": 169}, "message": "expanded from macro 'EXPECT_THAT_EXPECTED'"}, {"location": {"col": 26, "file": 19, "line": 4415}, "message": "expanded from macro 'EXPECT_THAT'"}, {"location": {"col": 3, "file": 19, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<testing::Matcher<const llvm::detail::ErrorHolder &>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "12cc758ffe8433b3c747b9803e87c2cd", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 13, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 7, "file": 19, "line": 432}, "message": "in implicit copy constructor for 'testing::internal::PropertyMatcher<lldb_private::python::PythonException, std::basic_string<char>>' first required here"}, {"location": {"col": 44, "file": 20, "line": 812}, "message": "in implicit copy constructor for 'testing::PolymorphicMatcher<testing::internal::PropertyMatcher<lldb_private::python::PythonException, std::basic_string<char>>>' first required here"}, {"location": {"col": 3, "file": 19, "line": 2303}, "message": "definition of implicit copy constructor for 'PropertyMatcher<lldb_private::python::PythonException, std::basic_string<char>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "324a2d3dc99830610a1fb8b9e70193e9", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 52, "line": 1}, "message": "PYTHON3_8_PYTHON_H (fixit)"}, {"location": {"col": 9, "file": 52, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/Python.h", "reportHash": "9bc3476af18ef2f458c0f5654338c66f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 53, "line": 3}, "message": "PYTHON3_8_ABSTRACT_H (fixit)"}, {"location": {"col": 9, "file": 53, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/abstract.h", "reportHash": "540cad4319c9bb15874fbca8fd45a3f0", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 54, "line": 1}, "message": "PYTHON3_8_BLTINMODULE_H (fixit)"}, {"location": {"col": 9, "file": 54, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/bltinmodule.h", "reportHash": "18215430bb4abc1b6b0df03d83506f41", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 55, "line": 3}, "message": "PYTHON3_8_BOOLOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 55, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/boolobject.h", "reportHash": "4d537c5abc1858a9b149f41844862fa4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 56, "line": 3}, "message": "PYTHON3_8_BYTEARRAYOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 56, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/bytearrayobject.h", "reportHash": "0907dc6409a576e55a74d22237d66afb", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 57, "line": 4}, "message": "PYTHON3_8_BYTESOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 57, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/bytesobject.h", "reportHash": "2672768f812a17bfbf3946a786e4b828", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 58, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cellobject.h", "reportHash": "982892989ab022d02094d85b12fb7d0b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 59, "line": 1}, "message": "PYTHON3_8_CEVAL_H (fixit)"}, {"location": {"col": 9, "file": 59, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/ceval.h", "reportHash": "fc570fec7d70a347f8e5d656fbdd907e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 60, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/classobject.h", "reportHash": "8fb4c0f3037134bcf7304587bd91b72f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 61, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/code.h", "reportHash": "aa5d2de0613355908e305f547ab40f66", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 62, "line": 1}, "message": "PYTHON3_8_CODECS_H (fixit)"}, {"location": {"col": 9, "file": 62, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/codecs.h", "reportHash": "6a86ed01a6e16d2a6e10760922d96fc5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 63, "line": 1}, "message": "PYTHON3_8_COMPILE_H (fixit)"}, {"location": {"col": 9, "file": 63, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/compile.h", "reportHash": "b617ddc12e8450ee51b499a711d1a99d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 64, "line": 3}, "message": "PYTHON3_8_COMPLEXOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 64, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/complexobject.h", "reportHash": "f4838868ccf647ecab16be1b1844c288", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 65, "line": 1}, "message": "PYTHON3_8_CONTEXT_H (fixit)"}, {"location": {"col": 9, "file": 65, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/context.h", "reportHash": "24a194b4433bd1cae91dee5f1d4cad47", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 66, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/abstract.h", "reportHash": "504e9c7f8aef058d6f03d93fe9eeb885", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 67, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/dictobject.h", "reportHash": "cacabb1356aeb02129acfbca6c47b94d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 68, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/fileobject.h", "reportHash": "67e8d0b9e4a429e6a2706a4b85e8b72b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 69, "line": 1}, "message": "PYTHON3_8_CPYTHON_INITCONFIG_H (fixit)"}, {"location": {"col": 9, "file": 69, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/initconfig.h", "reportHash": "ebf803e739d4b515621041d107205bdd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 70, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/object.h", "reportHash": "1aa200986a3a736bd89db23644f6f362", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 71, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/objimpl.h", "reportHash": "1ef7107f41834de8074efce414ac9483", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 72, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/pyerrors.h", "reportHash": "9b57f27fc8e2311a5556d733dafadc53", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 73, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/pylifecycle.h", "reportHash": "db88ea7c0fba7a985e075b90edc0e4ed", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 74, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/pymem.h", "reportHash": "36d62152e67349a0c8506833b9f33f18", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 75, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/pystate.h", "reportHash": "36906929717fc72c83d7130d4bcba86a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 76, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/sysmodule.h", "reportHash": "79917152b81b84f434ab68b7ffc214ce", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 77, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/traceback.h", "reportHash": "e794dd9b5b28f092bfc6bedfccaf3fce", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 78, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/tupleobject.h", "reportHash": "edc0c989d9c5e38fa5cfe9738a1f9bb9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 79, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/cpython/unicodeobject.h", "reportHash": "3aa58cffb38bf428317c083c26393661", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 80, "line": 2}, "message": "PYTHON3_8_DESCROBJECT_H (fixit)"}, {"location": {"col": 9, "file": 80, "line": 2}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/descrobject.h", "reportHash": "ea2ae50d10b5be97a962bb03d51cb5a4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 81, "line": 1}, "message": "PYTHON3_8_DICTOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 81, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/dictobject.h", "reportHash": "41820a7d9fa0a2c37ae764007cf239e5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 82, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/dtoa.h", "reportHash": "0cecea4232e1d6039914f11374d24ad9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 83, "line": 1}, "message": "PYTHON3_8_ENUMOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 83, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/enumobject.h", "reportHash": "af249d57d705be2354286a2d1b2437df", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 84, "line": 4}, "message": "PYTHON3_8_EVAL_H (fixit)"}, {"location": {"col": 9, "file": 84, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/eval.h", "reportHash": "357edad4e6f515263b07268fa3687339", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 85, "line": 3}, "message": "PYTHON3_8_FILEOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 85, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/fileobject.h", "reportHash": "6b959056b579e56caf3cdbaab7613ff7", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 86, "line": 1}, "message": "PYTHON3_8_FILEUTILS_H (fixit)"}, {"location": {"col": 9, "file": 86, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/fileutils.h", "reportHash": "77082276af51391f3080497082f9b199", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 87, "line": 8}, "message": "PYTHON3_8_FLOATOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 87, "line": 8}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/floatobject.h", "reportHash": "d0829c98a1423cd8da5d541b54b94dc4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 88, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/funcobject.h", "reportHash": "777fbbcdae47b321b277b5300bd521b8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 89, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/genobject.h", "reportHash": "92c58e8766f1f8697e0ad6f352c251b3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 90, "line": 4}, "message": "PYTHON3_8_IMPORT_H (fixit)"}, {"location": {"col": 9, "file": 90, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/import.h", "reportHash": "5b098122ebcb976037dcc5ed64904a71", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 91, "line": 2}, "message": "PYTHON3_8_INTRCHECK_H (fixit)"}, {"location": {"col": 9, "file": 91, "line": 2}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/intrcheck.h", "reportHash": "fbeba56ad15f1b8e7e88656c0833b7c9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 92, "line": 1}, "message": "PYTHON3_8_ITEROBJECT_H (fixit)"}, {"location": {"col": 9, "file": 92, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/iterobject.h", "reportHash": "170f411c8c8f096d60a8e1afd6116e30", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 93, "line": 16}, "message": "PYTHON3_8_LISTOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 93, "line": 16}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/listobject.h", "reportHash": "ee952c05de469fb3ca639cd8c3f14b95", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 94, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/longintrepr.h", "reportHash": "24850c22a7354dcfb2f2b3cdb13ada14", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 95, "line": 1}, "message": "PYTHON3_8_LONGOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 95, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/longobject.h", "reportHash": "674c61bb8178969795263aa47482cc65", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 96, "line": 3}, "message": "PYTHON3_8_MEMORYOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 96, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/memoryobject.h", "reportHash": "c8983be55efd08e98cd60b9932eaad0a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 97, "line": 4}, "message": "PYTHON3_8_METHODOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 97, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/methodobject.h", "reportHash": "19defcfc4e54f6bf93da4e7132af04cd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 98, "line": 2}, "message": "PYTHON3_8_MODSUPPORT_H (fixit)"}, {"location": {"col": 9, "file": 98, "line": 2}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/modsupport.h", "reportHash": "e8c6531f916fb236bce9366d3f7b5575", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 99, "line": 4}, "message": "PYTHON3_8_MODULEOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 99, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/moduleobject.h", "reportHash": "592344afbca03ab8beb97804c1a7e411", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 100, "line": 4}, "message": "PYTHON3_8_NAMESPACEOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 100, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/namespaceobject.h", "reportHash": "da661a9c5bb5d58e9b061c1f4227ec85", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 101, "line": 1}, "message": "PYTHON3_8_OBJECT_H (fixit)"}, {"location": {"col": 9, "file": 101, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/object.h", "reportHash": "ad76e3124239ab50fc3aa8bd8bb7653d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 102, "line": 5}, "message": "PYTHON3_8_OBJIMPL_H (fixit)"}, {"location": {"col": 9, "file": 102, "line": 5}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/objimpl.h", "reportHash": "6b2ded4544bcf03fa58a4516ec9f703d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 103, "line": 1}, "message": "PYTHON3_8_ODICTOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 103, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/odictobject.h", "reportHash": "6536090edfc63bf15cc52315d8103c60", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 104, "line": 4}, "message": "PYTHON3_8_OSMODULE_H (fixit)"}, {"location": {"col": 9, "file": 104, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/osmodule.h", "reportHash": "cb20e03e7b2dada960990e25c1f664e1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 105, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/patchlevel.h", "reportHash": "1f1a5c0b12d8c99402191dfe35c488c5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 106, "line": 5}, "message": "PYTHON3_8_PICKLEBUFOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 106, "line": 5}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/picklebufobject.h", "reportHash": "a60875fb30e7f4a4d4b52b0f6d2709d5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 107, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pyarena.h", "reportHash": "3fe9fbca8b0544400cf752f257fc58a1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 108, "line": 15}, "message": "PYTHON3_8_PYCAPSULE_H (fixit)"}, {"location": {"col": 9, "file": 108, "line": 15}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pycapsule.h", "reportHash": "db63fbe2a6e86bed61ecbe5a3e67b4f0", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 109, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pyconfig.h", "reportHash": "b38bf1d4e93ab970697dc5fc67c10bbd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 110, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pyctype.h", "reportHash": "c84d2dc1097c063ddfdb3d179bc7a780", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 111, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pydebug.h", "reportHash": "cc6c77a4dea936e5d235c51364d88a43", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 112, "line": 1}, "message": "PYTHON3_8_PYERRORS_H (fixit)"}, {"location": {"col": 9, "file": 112, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pyerrors.h", "reportHash": "ee6c310ab4d3dcd625e84c450b2c121b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 113, "line": 1}, "message": "PYTHON3_8_PYFPE_H (fixit)"}, {"location": {"col": 9, "file": 113, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pyfpe.h", "reportHash": "ad5648d1502b090dffbb9935b203836a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 114, "line": 1}, "message": "PYTHON3_8_PYHASH_H (fixit)"}, {"location": {"col": 9, "file": 114, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pyhash.h", "reportHash": "5c2500815ef2c7195df008d7f7efcd17", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 115, "line": 4}, "message": "PYTHON3_8_PYLIFECYCLE_H (fixit)"}, {"location": {"col": 9, "file": 115, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pylifecycle.h", "reportHash": "2c2d21cf5886e867c313702ef08d5a26", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 116, "line": 1}, "message": "PYTHON3_8_PYMACCONFIG_H (fixit)"}, {"location": {"col": 9, "file": 116, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pymacconfig.h", "reportHash": "cf2fcd58b1668e31a807a7983251f1cf", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 117, "line": 1}, "message": "PYTHON3_8_PYMACRO_H (fixit)"}, {"location": {"col": 9, "file": 117, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pymacro.h", "reportHash": "22421274ff8f239f7006959edcedc93a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 118, "line": 1}, "message": "PYTHON3_8_PYMATH_H (fixit)"}, {"location": {"col": 9, "file": 118, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pymath.h", "reportHash": "0eee23cef18ee65328ff5e3d93ce0b4d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 119, "line": 5}, "message": "PYTHON3_8_PYMEM_H (fixit)"}, {"location": {"col": 9, "file": 119, "line": 5}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pymem.h", "reportHash": "149d20ac0e98e2fa634b8f4446a4db33", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 120, "line": 1}, "message": "PYTHON3_8_PYPORT_H (fixit)"}, {"location": {"col": 9, "file": 120, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pyport.h", "reportHash": "9a31ec7165e8dc01417f10648c977182", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 121, "line": 4}, "message": "PYTHON3_8_PYSTATE_H (fixit)"}, {"location": {"col": 9, "file": 121, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pystate.h", "reportHash": "d22e30aa7e9ebf36d15e7e769ca480ab", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 122, "line": 1}, "message": "PYTHON3_8_PYSTRCMP_H (fixit)"}, {"location": {"col": 9, "file": 122, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pystrcmp.h", "reportHash": "b13a4282ffaa0f98418f9b4e343ef70a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 123, "line": 1}, "message": "PYTHON3_8_PYSTRTOD_H (fixit)"}, {"location": {"col": 9, "file": 123, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pystrtod.h", "reportHash": "f033bc2142e1d92722b012b3b790e11e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 124, "line": 4}, "message": "PYTHON3_8_PYTHONRUN_H (fixit)"}, {"location": {"col": 9, "file": 124, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pythonrun.h", "reportHash": "5f12ede72f854048985ba8991c15df6d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 125, "line": 2}, "message": "PYTHON3_8_PYTHREAD_H (fixit)"}, {"location": {"col": 9, "file": 125, "line": 2}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pythread.h", "reportHash": "cbdc77fa490fc402fb1f9860a5872e60", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 126, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/pytime.h", "reportHash": "271e051e3e8516626566edf756e0a6a7", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 127, "line": 4}, "message": "PYTHON3_8_RANGEOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 127, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/rangeobject.h", "reportHash": "29278ccd1464d712a711feb4d4ae9c69", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 128, "line": 3}, "message": "PYTHON3_8_SETOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 128, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/setobject.h", "reportHash": "30d1c4eaca1c3b2eacfe1b723e3a4536", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 129, "line": 1}, "message": "PYTHON3_8_SLICEOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 129, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/sliceobject.h", "reportHash": "75343962b51c809da3de148e565a0e67", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 130, "line": 4}, "message": "PYTHON3_8_STRUCTSEQ_H (fixit)"}, {"location": {"col": 9, "file": 130, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/structseq.h", "reportHash": "fcb67a3b16087e81e3b88aae8e4741b9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 131, "line": 4}, "message": "PYTHON3_8_SYSMODULE_H (fixit)"}, {"location": {"col": 9, "file": 131, "line": 4}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/sysmodule.h", "reportHash": "c8bf56960a4f93992a31462d982a1af4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 132, "line": 1}, "message": "PYTHON3_8_TRACEBACK_H (fixit)"}, {"location": {"col": 9, "file": 132, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/traceback.h", "reportHash": "da236c1d669199426386fc6a2354d49b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 133, "line": 1}, "message": "PYTHON3_8_TRACEMALLOC_H (fixit)"}, {"location": {"col": 9, "file": 133, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/tracemalloc.h", "reportHash": "7d58cf8c56143fada029a95f3ac14d90", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 134, "line": 3}, "message": "PYTHON3_8_TUPLEOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 134, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/tupleobject.h", "reportHash": "e2e499610225802dae94e7eab629a535", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 135, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/typeslots.h", "reportHash": "ab9682adc97594e408e8f67d7b0382c3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 136, "line": 1}, "message": "PYTHON3_8_UNICODEOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 136, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/unicodeobject.h", "reportHash": "6ba88fc28c3db145e3addb038c981970", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 137, "line": 1}, "message": "PYTHON3_8_WARNINGS_H (fixit)"}, {"location": {"col": 9, "file": 137, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/warnings.h", "reportHash": "696d4798ec26f5c3421c39c5540419ac", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 138, "line": 3}, "message": "PYTHON3_8_WEAKREFOBJECT_H (fixit)"}, {"location": {"col": 9, "file": 138, "line": 3}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/usr/include/python3.8/weakrefobject.h", "reportHash": "34984ca9f2abffbe2b5310d5ae9aac57", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
