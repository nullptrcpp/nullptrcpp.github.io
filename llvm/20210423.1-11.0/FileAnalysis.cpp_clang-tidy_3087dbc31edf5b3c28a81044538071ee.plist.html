<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan)\n//\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don't\n// end with _ are part of Google Test's public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don't need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it's necessary for a user to define some of the following\n// macros in the build script to override Google Test's decisions.\n//\n// If the user doesn't define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don't use #ifdef or \"#if\n//     defined(...)\", which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn't available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_GLOBAL_STRING  - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::string, which is different to std::string).\n//   GTEST_HAS_GLOBAL_WSTRING - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::wstring, which is different to std::wstring).\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren't available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that <pthread.h>\n//                              is/isn't available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn't\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn't work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_TR1_TUPLE      - Define it to 1/0 to indicate tr1::tuple\n//                              is/isn't available.\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft's \"Structured\n//                              Exception Handling\".\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_USE_OWN_TR1_TUPLE  - Define it to 1/0 to indicate whether Google\n//                              Test's own tr1 tuple implementation should be\n//                              used.  Unused when the user sets\n//                              GTEST_HAS_TR1_TUPLE to 0.\n//   GTEST_LANG_CXX11         - Define it to 1/0 to indicate that Google Test\n//                              is building in C++11/C++98 mode.\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_MINIX    - Minix\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_SYMBIAN  - Symbian\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Max OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don't have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #if\n// which controls that code.  For example:\n//\n// #if GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_COMBINE      - the Combine() function (for value-parameterized\n//                            tests)\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_PARAM_TEST   - value-parameterized tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above two are mutually exclusive.\n//   GTEST_CAN_COMPARE_NULL - accepts untyped NULL in EXPECT_EQ().\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test's INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_ATTRIBUTE_UNUSED_  - declares that a class' instances or a\n//                              variable don't have to be used.\n//   GTEST_DISALLOW_ASSIGN_   - disables operator=.\n//   GTEST_DISALLOW_COPY_AND_ASSIGN_ - disables copy ctor and operator=.\n//   GTEST_MUST_USE_RESULT_   - declares that a function's result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//\n// C++11 feature wrappers:\n//\n//   testing::internal::move  - portability wrapper for std::move.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Template meta programming:\n//   is_pointer     - as in TR1; needed on Symbian and IBM XL C/C++ only.\n//   IteratorTraits - partial implementation of std::iterator_traits, which\n//                    is not available in libCstd when compiled with Sun C++.\n//\n// Smart pointers:\n//   scoped_ptr     - as in TR2.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using the POSIX\n//                    Extended Regular Expression syntax on UNIX-like\n//                    platforms, or a reduced regular exception syntax on\n//                    other platforms, including Windows.\n//\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   Int32, UInt32, Int64, UInt64, TimeInMillis\n//                  - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GTEST_DECLARE_*()  - declares a flag.\n//   GTEST_DEFINE_*()   - defines a flag.\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an Int32 environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n\n#include <ctype.h>   // for isspace, etc\n#include <stddef.h>  // for ptrdiff_t\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#ifndef _WIN32_WCE\n# include <sys/types.h>\n# include <sys/stat.h>\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n# include <AvailabilityMacros.h>\n# include <TargetConditionals.h>\n#endif\n\n#include <algorithm>  // NOLINT\n#include <iostream>  // NOLINT\n#include <sstream>  // NOLINT\n#include <string>  // NOLINT\n#include <utility>\n#include <vector>  // NOLINT\n\n#include \"gtest/internal/gtest-port-arch.h\"\n#include \"gtest/internal/custom/gtest-port.h\"\n\n#if !defined(GTEST_DEV_EMAIL_)\n# define GTEST_DEV_EMAIL_ \"googletestframework@@googlegroups.com\"\n# define GTEST_FLAG_PREFIX_ \"gtest_\"\n# define GTEST_FLAG_PREFIX_DASH_ \"gtest-\"\n# define GTEST_FLAG_PREFIX_UPPER_ \"GTEST_\"\n# define GTEST_NAME_ \"Google Test\"\n# define GTEST_PROJECT_URL_ \"https://github.com/google/googletest/\"\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n# define GTEST_INIT_GOOGLE_TEST_NAME_ \"testing::InitGoogleTest\"\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n# define GTEST_GCC_VER_ \\\n    (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if _MSC_VER >= 1500\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n    __pragma(warning(push))                        \\\n    __pragma(warning(disable: warnings))\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()          \\\n    __pragma(warning(pop))\n#else\n// Older versions of MSVC don't have __pragma.\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n#ifndef GTEST_LANG_CXX11\n// gcc and clang define __GXX_EXPERIMENTAL_CXX0X__ when\n// -std={c,gnu}++{0x,11} is passed.  The C++11 standard specifies a\n// value for __cplusplus, and recent versions of clang, gcc, and\n// probably other compilers set that too in C++11 mode.\n# if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L\n// Compiling in at least C++11 mode.\n#  define GTEST_LANG_CXX11 1\n# else\n#  define GTEST_LANG_CXX11 0\n# endif\n#endif\n\n// Distinct from C++11 language support, some environments don't provide\n// proper C++11 library support. Notably, it's possible to build in\n// C++11 mode when targeting Mac OS X 10.6, which has an old libstdc++\n// with no C++11 support.\n//\n// libstdc++ has sufficient C++11 support as of GCC 4.6.0, __GLIBCXX__\n// 20110325, but maintenance releases in the 4.4 and 4.5 series followed\n// this date, so check for those versions by their date stamps.\n// https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html#abi.versioning\n#if GTEST_LANG_CXX11 && \\\n    (!defined(__GLIBCXX__) || ( \\\n        __GLIBCXX__ >= 20110325ul &&  /* GCC >= 4.6.0 */ \\\n        /* Exclude patch releases of older branches: */ \\\n        __GLIBCXX__ != 20110416ul &&  /* GCC 4.4.6 */ \\\n        __GLIBCXX__ != 20120313ul &&  /* GCC 4.4.7 */ \\\n        __GLIBCXX__ != 20110428ul &&  /* GCC 4.5.3 */ \\\n        __GLIBCXX__ != 20120702ul))   /* GCC 4.5.4 */\n# define GTEST_STDLIB_CXX11 1\n#endif\n\n// Only use C++11 library features if the library provides them.\n#if GTEST_STDLIB_CXX11\n# define GTEST_HAS_STD_BEGIN_AND_END_ 1\n# define GTEST_HAS_STD_FORWARD_LIST_ 1\n# define GTEST_HAS_STD_FUNCTION_ 1\n# define GTEST_HAS_STD_INITIALIZER_LIST_ 1\n# define GTEST_HAS_STD_MOVE_ 1\n# define GTEST_HAS_STD_SHARED_PTR_ 1\n# define GTEST_HAS_STD_TYPE_TRAITS_ 1\n# define GTEST_HAS_STD_UNIQUE_PTR_ 1\n#endif\n\n// C++11 specifies that <tuple> provides std::tuple.\n// Some platforms still might not have it, however.\n#if GTEST_LANG_CXX11\n# define GTEST_HAS_STD_TUPLE_ 1\n# if defined(__clang__)\n// Inspired by http://clang.llvm.org/docs/LanguageExtensions.html#__has_include\n#  if defined(__has_include) && !__has_include(<tuple>)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(_MSC_VER)\n// Inspired by boost/config/stdlib/dinkumware.hpp\n#  if defined(_CPPLIB_VER) && _CPPLIB_VER < 520\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(__GLIBCXX__)\n// Inspired by boost/config/stdlib/libstdcpp3.hpp,\n// http://gcc.gnu.org/gcc-4.2/changes.html and\n// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01.html#manual.intro.status.standard.200x\n#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# endif\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#if GTEST_OS_WINDOWS\n# if !GTEST_OS_WINDOWS_MOBILE\n#  include <direct.h>\n#  include <io.h>\n# endif\n// In order to avoid having to include <windows.h>, use forward declaration\n// assuming CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\nstruct _RTL_CRITICAL_SECTION;\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n# include <unistd.h>\n# include <strings.h>\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#  include <android/api-level.h>  // NOLINT\n#endif\n\n// Defines this to true iff Google Test can use POSIX regular expressions.\n#ifndef GTEST_HAS_POSIX_RE\n# if GTEST_OS_LINUX_ANDROID\n// On Android, <regex.h> is only available starting with Gingerbread.\n#  define GTEST_HAS_POSIX_RE (__ANDROID_API__ >= 9)\n# else\n#  define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS)\n# endif\n#endif\n\n#if GTEST_USES_PCRE\n// The appropriate headers have already been included.\n\n#elif GTEST_HAS_POSIX_RE\n\n// On some platforms, <regex.h> needs someone to define size_t, and\n// won't compile otherwise.  We can #include it here as we already\n// included <stdlib.h>, which is guaranteed to define size_t through\n// <stddef.h>.\n# include <regex.h>  // NOLINT\n\n# define GTEST_USES_POSIX_RE 1\n\n#elif GTEST_OS_WINDOWS\n\n// <regex.h> is not available on Windows.  Use our own simple regex\n// implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#else\n\n// <regex.h> may not be available on this platform.  Use our own\n// simple regex implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#endif  // GTEST_USES_PCRE\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn't tell us whether exceptions are enabled, so we need\n// to figure it out.\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// MSVC's and C++Builder's implementations of the STL use the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we'll do the same.\n// Assumes that exceptions are enabled by default.\n#  ifndef _HAS_EXCEPTIONS\n#   define _HAS_EXCEPTIONS 1\n#  endif  // _HAS_EXCEPTIONS\n#  define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n# elif defined(__clang__)\n// clang defines __EXCEPTIONS iff exceptions are enabled before clang 220714,\n// but iff cleanups are enabled after that. In Obj-C++ files, there can be\n// cleanups for ObjC exceptions which also need cleanups, even if C++ exceptions\n// are disabled. clang has __has_feature(cxx_exceptions) which checks for C++\n// exceptions starting at clang r206352, but which checked for cleanups prior to\n// that. To reliably check for C++ exception availability with clang, check for\n// __EXCEPTIONS && __has_feature(cxx_exceptions).\n#  define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS && __has_feature(cxx_exceptions))\n# elif defined(__GNUC__) && __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__IBMCPP__) && __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#  define GTEST_HAS_EXCEPTIONS 1\n# else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#  define GTEST_HAS_EXCEPTIONS 0\n# endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#if !defined(GTEST_HAS_STD_STRING)\n// Even though we don't use this macro any longer, we keep it in case\n// some clients still depend on it.\n# define GTEST_HAS_STD_STRING 1\n#elif !GTEST_HAS_STD_STRING\n// The user told us that ::std::string isn't available.\n# error \"Google Test cannot be used where ::std::string isn't available.\"\n#endif  // !defined(GTEST_HAS_STD_STRING)\n\n#ifndef GTEST_HAS_GLOBAL_STRING\n// The user didn't tell us whether ::string is available, so we need\n// to figure it out.\n\n# define GTEST_HAS_GLOBAL_STRING 0\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn't tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// TODO(wan@google.com): uses autoconf to detect whether ::std::wstring\n//   is available.\n\n// Cygwin 1.7 and below doesn't support ::std::wstring.\n// Solaris' libc++ doesn't support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n// Minix currently doesn't support it either.\n# define GTEST_HAS_STD_WSTRING \\\n    (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || GTEST_OS_HAIKU || GTEST_OS_MINIX))\n\n#endif  // GTEST_HAS_STD_WSTRING\n\n#ifndef GTEST_HAS_GLOBAL_WSTRING\n// The user didn't tell us whether ::wstring is available, so we need\n// to figure it out.\n# define GTEST_HAS_GLOBAL_WSTRING \\\n    (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn't tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n# ifdef _MSC_VER\n\n#  ifdef _CPPRTTI  // MSVC defines this macro iff RTTI is enabled.\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI iff RTTI is enabled.\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)\n\n#  ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#   if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && \\\n       !defined(__EXCEPTIONS)\n#    define GTEST_HAS_RTTI 0\n#   else\n#    define GTEST_HAS_RTTI 1\n#   endif  // GTEST_OS_LINUX_ANDROID && __STLPORT_MAJOR && !__EXCEPTIONS\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n# elif defined(__clang__)\n\n#  define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n# elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)\n\n#  ifdef __RTTI_ALL__\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n# else\n\n// For all other compilers, we assume RTTI is enabled.\n#  define GTEST_HAS_RTTI 1\n\n# endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It's this header's responsibility to #include <typeinfo> when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n# include <typeinfo>\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn't tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n# define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \\\n    || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL)\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is\n// true.\n# include <pthread.h>  // NOLINT\n\n// For timespec and nanosleep, used below.\n# include <time.h>  // NOLINT\n#endif\n\n// Determines if hash_map/hash_set are available.\n// Only used for testing against those containers.\n#if !defined(GTEST_HAS_HASH_MAP_)\n# if _MSC_VER\n#  define GTEST_HAS_HASH_MAP_ 1  // Indicates that hash_map is available.\n#  define GTEST_HAS_HASH_SET_ 1  // Indicates that hash_set is available.\n# endif  // _MSC_VER\n#endif  // !defined(GTEST_HAS_HASH_MAP_)\n\n// Determines whether Google Test can use tr1/tuple.  You can define\n// this macro to 0 to prevent Google Test from using tuple (any\n// feature depending on tuple with be disabled in this mode).\n#ifndef GTEST_HAS_TR1_TUPLE\n# if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)\n// STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.\n#  define GTEST_HAS_TR1_TUPLE 0\n# else\n// The user didn't tell us not to do it, so we assume it's OK.\n#  define GTEST_HAS_TR1_TUPLE 1\n# endif\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether Google Test's own tr1 tuple implementation\n// should be used.\n#ifndef GTEST_USE_OWN_TR1_TUPLE\n// The user didn't tell us, so we need to figure it out.\n\n// We use our own TR1 tuple if we aren't sure the user has an\n// implementation of it already.  At this time, libstdc++ 4.0.0+ and\n// MSVC 2010 are the only mainstream standard libraries that come\n// with a TR1 tuple implementation.  NVIDIA's CUDA NVCC compiler\n// pretends to be GCC by defining __GNUC__ and friends, but cannot\n// compile GCC's tuple implementation.  MSVC 2008 (9.0) provides TR1\n// tuple in a 323 MB Feature Pack download, which we cannot assume the\n// user has.  QNX's QCC compiler is a modified GCC but it doesn't\n// support TR1 tuple.  libc++ only provides std::tuple, in C++11 mode,\n// and it can be used with some compilers that define __GNUC__.\n# if (defined(__GNUC__) && !defined(__CUDACC__) && (GTEST_GCC_VER_ >= 40000) \\\n      && !GTEST_OS_QNX && !defined(_LIBCPP_VERSION)) || _MSC_VER >= 1600\n#  define GTEST_ENV_HAS_TR1_TUPLE_ 1\n# endif\n\n// C++11 specifies that <tuple> provides std::tuple. Use that if gtest is used\n// in C++11 mode and libstdc++ isn't very old (binaries targeting OS X 10.6\n// can build with clang but need to use gcc4.2's libstdc++).\n# if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)\n#  define GTEST_ENV_HAS_STD_TUPLE_ 1\n# endif\n\n# if GTEST_ENV_HAS_TR1_TUPLE_ || GTEST_ENV_HAS_STD_TUPLE_\n#  define GTEST_USE_OWN_TR1_TUPLE 0\n# else\n#  define GTEST_USE_OWN_TR1_TUPLE 1\n# endif\n\n#endif  // GTEST_USE_OWN_TR1_TUPLE\n\n// To avoid conditional compilation everywhere, we make it\n// gtest-port.h's responsibility to #include the header implementing\n// tuple.\n#if GTEST_HAS_STD_TUPLE_\n# include <tuple>  // IWYU pragma: export\n# define GTEST_TUPLE_NAMESPACE_ ::std\n#endif  // GTEST_HAS_STD_TUPLE_\n\n// We include tr1::tuple even if std::tuple is available to define printers for\n// them.\n#if GTEST_HAS_TR1_TUPLE\n# ifndef GTEST_TUPLE_NAMESPACE_\n#  define GTEST_TUPLE_NAMESPACE_ ::std::tr1\n# endif  // GTEST_TUPLE_NAMESPACE_\n\n# if GTEST_USE_OWN_TR1_TUPLE\n#  include \"gtest/internal/gtest-tuple.h\"  // IWYU pragma: export  // NOLINT\n# elif GTEST_ENV_HAS_STD_TUPLE_\n#  include <tuple>\n// C++11 puts its tuple into the ::std namespace rather than\n// ::std::tr1.  gtest expects tuple to live in ::std::tr1, so put it there.\n// This causes undefined behavior, but supported compilers react in\n// the way we intend.\nnamespace std {\nnamespace tr1 {\nusing ::std::get;\nusing ::std::make_tuple;\nusing ::std::tuple;\nusing ::std::tuple_element;\nusing ::std::tuple_size;\n}\n}\n\n# elif GTEST_OS_SYMBIAN\n\n// On Symbian, BOOST_HAS_TR1_TUPLE causes Boost's TR1 tuple library to\n// use STLport's tuple implementation, which unfortunately doesn't\n// work as the copy of STLport distributed with Symbian is incomplete.\n// By making sure BOOST_HAS_TR1_TUPLE is undefined, we force Boost to\n// use its own tuple implementation.\n#  ifdef BOOST_HAS_TR1_TUPLE\n#   undef BOOST_HAS_TR1_TUPLE\n#  endif  // BOOST_HAS_TR1_TUPLE\n\n// This prevents <boost/tr1/detail/config.hpp>, which defines\n// BOOST_HAS_TR1_TUPLE, from being #included by Boost's <tuple>.\n#  define BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)\n// GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header.  This does\n// not conform to the TR1 spec, which requires the header to be <tuple>.\n\n#  if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n// Until version 4.3.2, gcc has a bug that causes <tr1/functional>,\n// which is #included by <tr1/tuple>, to not compile when RTTI is\n// disabled.  _TR1_FUNCTIONAL is the header guard for\n// <tr1/functional>.  Hence the following #define is a hack to prevent\n// <tr1/functional> from being included.\n#   define _TR1_FUNCTIONAL 1\n#   include <tr1/tuple>\n#   undef _TR1_FUNCTIONAL  // Allows the user to #include\n                        // <tr1/functional> if he chooses to.\n#  else\n#   include <tr1/tuple>  // NOLINT\n#  endif  // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n\n# else\n// If the compiler is not GCC 4.0+, we assume the user is using a\n// spec-conforming TR1 implementation.\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n# endif  // GTEST_USE_OWN_TR1_TUPLE\n\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see http://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn't tell us, so we need to figure it out.\n\n# if GTEST_OS_LINUX && !defined(__ia64__)\n#  if GTEST_OS_LINUX_ANDROID\n// On Android, clone() is only available on ARM starting with Gingerbread.\n#    if defined(__arm__) && __ANDROID_API__ >= 9\n#     define GTEST_HAS_CLONE 1\n#    else\n#     define GTEST_HAS_CLONE 0\n#    endif\n#  else\n#   define GTEST_HAS_CLONE 1\n#  endif\n# else\n#  define GTEST_HAS_CLONE 0\n# endif  // GTEST_OS_LINUX && !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile ones.\n# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || \\\n    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT\n#  define GTEST_HAS_STREAM_REDIRECTION 0\n# else\n#  define GTEST_HAS_STREAM_REDIRECTION 1\n# endif  // !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_SYMBIAN\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// Google Test does not support death tests for VC 7.1 and earlier as\n// abort() in a VC 7.1 application compiled as GUI in debug config\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\\n     (GTEST_OS_MAC && !GTEST_OS_IOS) || \\\n     (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \\\n     GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \\\n     GTEST_OS_OPENBSD || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NETBSD)\n# define GTEST_HAS_DEATH_TEST 1\n#endif\n\n// We don't support MSVC 7.1 with exceptions disabled now.  Therefore\n// all the compilers we care about are adequate for supporting\n// value-parameterized tests.\n#define GTEST_HAS_PARAM_TEST 1\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need <typeinfo> and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n# define GTEST_HAS_TYPED_TEST 1\n# define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether to support Combine(). This only makes sense when\n// value-parameterized tests are enabled.  The implementation doesn't\n// work on Sun Studio since it doesn't understand templated conversion\n// operators.\n#if GTEST_HAS_PARAM_TEST && GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)\n# define GTEST_HAS_COMBINE 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#define GTEST_WIDE_STRING_USES_UTF16_ \\\n    (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)\n\n// Determines whether test results can be streamed to a socket.\n#if GTEST_OS_LINUX\n# define GTEST_CAN_STREAM_RESULTS_ 1\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested \"if\" statements are followed by\n// an \"else\" statement and braces are not used to explicitly disambiguate the\n// \"else\" binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) << \"Some message\";\n//\n// The \"switch (0) case 0:\" idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_ switch (0) case 0: default:  // NOLINT\n#endif\n\n// Use this annotation at the end of a struct/class definition to\n// prevent the compiler from optimizing away instances that are never\n// used.  This is useful when all interesting logic happens inside the\n// c'tor and / or d'tor.  Example:\n//\n//   struct Foo {\n//     Foo() { ... }\n//   } GTEST_ATTRIBUTE_UNUSED_;\n//\n// Also use it after a variable or parameter declaration to tell the\n// compiler the variable/parameter does not have to be used.\n#if defined(__GNUC__) && !defined(COMPILER_ICC)\n# define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n#elif defined(__clang__)\n# if __has_attribute(unused)\n#  define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n# endif\n#endif\n#ifndef GTEST_ATTRIBUTE_UNUSED_\n# define GTEST_ATTRIBUTE_UNUSED_\n#endif\n\n// A macro to disallow operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_ASSIGN_(type)\\\n  void operator=(type const &) = delete\n\n// A macro to disallow copy constructor and operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)\\\n  type(type const &) = delete;\\\n  GTEST_DISALLOW_ASSIGN_(type)\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if defined(__GNUC__) && (GTEST_GCC_VER_ >= 30400) && !defined(COMPILER_ICC)\n# define GTEST_MUST_USE_RESULT_ __attribute__ ((warn_unused_result))\n#else\n# define GTEST_MUST_USE_RESULT_\n#endif  // __GNUC__ && (GTEST_GCC_VER_ >= 30400) && !COMPILER_ICC\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n# define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n    GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n# define GTEST_INTENTIONAL_CONST_COND_POP_() \\\n    GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft's Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn't tell us, so we need to figure it out.\n\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#  define GTEST_HAS_SEH 1\n# else\n// Assume no SEH.\n#  define GTEST_HAS_SEH 0\n# endif\n\n#endif  // GTEST_HAS_SEH\n\n#define GTEST_IS_THREADSAFE \\\n    (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \\\n     || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \\\n     || GTEST_HAS_PTHREAD)\n\n#ifdef _MSC_VER\n# if GTEST_LINKED_AS_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllimport)\n# elif GTEST_CREATE_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllexport)\n# endif\n#elif __GNUC__ >= 4 || defined(__clang__)\n# define GTEST_API_ __attribute__((visibility (\"default\")))\n#endif // _MSC_VER\n\n#ifndef GTEST_API_\n# define GTEST_API_\n#endif\n\n#ifdef __GNUC__\n// Ask the compiler to never inline a given function.\n# define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n# define GTEST_NO_INLINE_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if defined(__has_include)\n# if __has_include(<cxxabi.h>)\n#  define GTEST_HAS_CXXABI_H_ 1\n# else\n#  define GTEST_HAS_CXXABI_H_ 0\n# endif\n#elif defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)\n# define GTEST_HAS_CXXABI_H_ 1\n#else\n# define GTEST_HAS_CXXABI_H_ 0\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if defined(__clang__)\n# if __has_feature(memory_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ \\\n       __attribute__((no_sanitize_memory))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n# endif  // __has_feature(memory_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif  // __clang__\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(address_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n       __attribute__((no_sanitize_address))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n# endif  // __has_feature(address_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif  // __clang__\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(thread_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ \\\n       __attribute__((no_sanitize_thread))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n# endif  // __has_feature(thread_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif  // __clang__\n\nnamespace testing {\n\nclass Message;\n\n#if defined(GTEST_TUPLE_NAMESPACE_)\n// Import tuple and friends into the ::testing namespace.\n// It is part of our interface, having them in ::testing allows us to change\n// their types as needed.\nusing GTEST_TUPLE_NAMESPACE_::get;\nusing GTEST_TUPLE_NAMESPACE_::make_tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple_size;\nusing GTEST_TUPLE_NAMESPACE_::tuple_element;\n#endif  // defined(GTEST_TUPLE_NAMESPACE_)\n\nnamespace internal {\n\n// A secret type that Google Test users don't know about.  It has no\n// definition on purpose.  Therefore it's impossible to create a\n// Secret object, which is what we want.\nclass Secret;\n\n// The GTEST_COMPILE_ASSERT_ macro can be used to verify that a compile time\n// expression is true. For example, you could use it to verify the\n// size of a static array:\n//\n//   GTEST_COMPILE_ASSERT_(GTEST_ARRAY_SIZE_(names) == NUM_NAMES,\n//                         names_incorrect_size);\n//\n// or to make sure a struct is smaller than a certain size:\n//\n//   GTEST_COMPILE_ASSERT_(sizeof(foo) < 128, foo_too_large);\n//\n// The second argument to the macro is the name of the variable. If\n// the expression is false, most compilers will issue a warning/error\n// containing the name of the variable.\n\n#if GTEST_LANG_CXX11\n# define GTEST_COMPILE_ASSERT_(expr, msg) static_assert(expr, #msg)\n#else  // !GTEST_LANG_CXX11\ntemplate <bool>\n  struct CompileAssert {\n};\n\n# define GTEST_COMPILE_ASSERT_(expr, msg) \\\n  typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \\\n      msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_\n#endif  // !GTEST_LANG_CXX11\n\n// Implementation details of GTEST_COMPILE_ASSERT_:\n//\n// (In C++11, we simply use static_assert instead of the following)\n//\n// - GTEST_COMPILE_ASSERT_ works by defining an array type that has -1\n//   elements (and thus is invalid) when the expression is false.\n//\n// - The simpler definition\n//\n//    #define GTEST_COMPILE_ASSERT_(expr, msg) typedef char msg[(expr) ? 1 : -1]\n//\n//   does not work, as gcc supports variable-length arrays whose sizes\n//   are determined at run-time (this is gcc's extension and not part\n//   of the C++ standard).  As a result, gcc fails to reject the\n//   following code with the simple definition:\n//\n//     int foo;\n//     GTEST_COMPILE_ASSERT_(foo, msg); // not supposed to compile as foo is\n//                                      // not a compile-time constant.\n//\n// - By using the type CompileAssert<(bool(expr))>, we ensures that\n//   expr is a compile-time constant.  (Template arguments must be\n//   determined at compile-time.)\n//\n// - The outter parentheses in CompileAssert<(bool(expr))> are necessary\n//   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written\n//\n//     CompileAssert<bool(expr)>\n//\n//   instead, these compilers will refuse to compile\n//\n//     GTEST_COMPILE_ASSERT_(5 > 0, some_message);\n//\n//   (They seem to think the \">\" in \"5 > 0\" marks the end of the\n//   template argument list.)\n//\n// - The array size is (bool(expr) ? 1 : -1), instead of simply\n//\n//     ((expr) ? 1 : -1).\n//\n//   This is to avoid running into a bug in MS VC 7.1, which\n//   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.\n\n// StaticAssertTypeEqHelper is used by StaticAssertTypeEq defined in gtest.h.\n//\n// This template is declared, but intentionally undefined.\ntemplate <typename T1, typename T2>\nstruct StaticAssertTypeEqHelper;\n\ntemplate <typename T>\nstruct StaticAssertTypeEqHelper<T, T> {\n  enum { value = true };\n};\n\n// Evaluates to the number of elements in 'array'.\n#define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))\n\n#if GTEST_HAS_GLOBAL_STRING\ntypedef ::string string;\n#else\ntypedef ::std::string string;\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#if GTEST_HAS_GLOBAL_WSTRING\ntypedef ::wstring wstring;\n#elif GTEST_HAS_STD_WSTRING\ntypedef ::std::wstring wstring;\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns 'condition'.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines scoped_ptr.\n\n// This implementation of scoped_ptr is PARTIAL - it only contains\n// enough stuff to satisfy Google Test's need.\ntemplate <typename T>\nclass scoped_ptr {\n public:\n  typedef T element_type;\n\n  explicit scoped_ptr(T* p = NULL) : ptr_(p) {}\n  ~scoped_ptr() { reset(); }\n\n  T& operator*() const { return *ptr_; }\n  T* operator->() const { return ptr_; }\n  T* get() const { return ptr_; }\n\n  T* release() {\n    T* const ptr = ptr_;\n    ptr_ = NULL;\n    return ptr;\n  }\n\n  void reset(T* p = NULL) {\n    if (p != ptr_) {\n      if (IsTrue(sizeof(T) > 0)) {  // Makes sure T is a complete type.\n        delete ptr_;\n      }\n      ptr_ = p;\n    }\n  }\n\n  friend void swap(scoped_ptr& a, scoped_ptr& b) {\n    using std::swap;\n    swap(a.ptr_, b.ptr_);\n  }\n\n private:\n  T* ptr_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr);\n};\n\n// Defines RE.\n\n// A simple C++ wrapper for <regex.h>.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE& other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  RE(const ::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_; }\n\n  // FullMatch(str, re) returns true iff regular expression re matches\n  // the entire str.\n  // PartialMatch(str, re) returns true iff regular expression re\n  // matches a substring of str (including str itself).\n  //\n  // TODO(wan@google.com): make FullMatch() and PartialMatch() work\n  // when str contains NUL characters.\n  static bool FullMatch(const ::std::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const ::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const char* str, const RE& re);\n  static bool PartialMatch(const char* str, const RE& re);\n\n private:\n  void Init(const char* regex);\n\n  // We use a const char* instead of an std::string, as Google Test used to be\n  // used where std::string is not available.  TODO(wan@google.com): change to\n  // std::string.\n  const char* pattern_;\n  bool is_valid_;\n\n#if GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  const char* full_pattern_;  // For FullMatch();\n\n#endif\n\n  GTEST_DISALLOW_ASSIGN_(RE);\n};\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity {\n  GTEST_INFO,\n  GTEST_WARNING,\n  GTEST_ERROR,\n  GTEST_FATAL\n};\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream& GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);\n};\n\n#if !defined(GTEST_LOG_)\n\n# define GTEST_LOG_(severity) \\\n    ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                  __FILE__, __LINE__).GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(NULL); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsys:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) << \"Additional message\";\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n# define GTEST_CHECK_(condition) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::IsTrue(condition)) \\\n      ; \\\n    else \\\n      GTEST_LOG_(FATAL) << \"Condition \" #condition \" failed. \"\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn't expand to a balanced 'if' statement, so enclose the macro\n// in {} if you need to use it as the only statement in an 'if'\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call)) \\\n    GTEST_LOG_(FATAL) << #posix_call << \"failed with error \" \\\n                      << gtest_error\n\n#if GTEST_HAS_STD_MOVE_\nusing std::move;\n#else  // GTEST_HAS_STD_MOVE_\ntemplate <typename T>\nconst T& move(const T& t) {\n  return t;\n}\n#endif  // GTEST_HAS_STD_MOVE_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertable to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_<ToType>(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To>\ninline To ImplicitCast_(To x) { return x; }\n\n// When you upcast (that is, cast a pointer from type Foo to type\n// SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts\n// always succeed.  When you downcast (that is, cast a pointer from\n// type Foo to type SubclassOfFoo), static_cast<> isn't safe, because\n// how do you know the pointer is really of type SubclassOfFoo?  It\n// could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,\n// when you downcast, you should use this macro.  In debug mode, we\n// use dynamic_cast<> to double-check the downcast is legal (we die\n// if it's not).  In normal mode, we do the efficient static_cast<>\n// instead.  Thus, it's important to test in debug mode to make sure\n// the cast is legal!\n//    This is the only place in the code we should use dynamic_cast<>.\n// In particular, you SHOULDN'T be using dynamic_cast<> in order to\n// do RTTI (eg code like this:\n//    if (dynamic_cast<Subclass1>(foo)) HandleASubclass1Object(foo);\n//    if (dynamic_cast<Subclass2>(foo)) HandleASubclass2Object(foo);\n// You should design the code some other way not to need this.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., down_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To, typename From>  // use like this: DownCast_<T*>(foo);\ninline To DownCast_(From* f) {  // so we only accept pointers\n  // Ensures that To is a sub-type of From *.  This test is here only\n  // for compile-time type checking, and has no overhead in an\n  // optimized build at run-time, as it will be optimized away\n  // completely.\n  GTEST_INTENTIONAL_CONST_COND_PUSH_()\n  if (false) {\n  GTEST_INTENTIONAL_CONST_COND_POP_()\n    const To to = NULL;\n    ::testing::internal::ImplicitCast_<From*>(to);\n  }\n\n#if GTEST_HAS_RTTI\n  // RTTI: debug mode only!\n  GTEST_CHECK_(f == NULL || dynamic_cast<To>(f) != NULL);\n#endif\n  return static_cast<To>(f);\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate <class Derived, class Base>\nDerived* CheckedDowncastToActualType(Base* base) {\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(typeid(*base) == typeid(Derived));\n#endif\n\n#if GTEST_HAS_DOWNCAST_\n  return ::down_cast<Derived*>(base);\n#elif GTEST_HAS_RTTI\n  return dynamic_cast<Derived*>(base);  // NOLINT\n#else\n  return static_cast<Derived*>(base);  // Poor man's downcast.\n#endif\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Returns a path to temporary directory.\nGTEST_API_ std::string TempDir();\n\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ const ::std::vector<testing::internal::string>& GetArgvs();\n\n#if GTEST_HAS_DEATH_TEST\n\nconst ::std::vector<testing::internal::string>& GetInjectableArgvs();\nvoid SetInjectableArgvs(const ::std::vector<testing::internal::string>*\n                             new_argvs);\n\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#if GTEST_IS_THREADSAFE\n# if GTEST_HAS_PTHREAD\n// Sleeps for (roughly) n milliseconds.  This function is only for testing\n// Google Test's own constructs.  Don't use it in user tests, either\n// directly or indirectly.\ninline void SleepMilliseconds(int n) {\n  const timespec time = {\n    0,                  // 0 seconds.\n    n * 1000L * 1000L,  // And n ms.\n  };\n  nanosleep(&time, NULL);\n}\n# endif  // GTEST_HAS_PTHREAD\n\n# if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_HAS_PTHREAD\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass Notification {\n public:\n  Notification() : notified_(false) {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n  }\n  ~Notification() {\n    pthread_mutex_destroy(&mutex_);\n  }\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    pthread_mutex_lock(&mutex_);\n    notified_ = true;\n    pthread_mutex_unlock(&mutex_);\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    for (;;) {\n      pthread_mutex_lock(&mutex_);\n      const bool notified = notified_;\n      pthread_mutex_unlock(&mutex_);\n      if (notified)\n        break;\n      SleepMilliseconds(10);\n    }\n  }\n\n private:\n  pthread_mutex_t mutex_;\n  bool notified_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\nGTEST_API_ void SleepMilliseconds(int n);\n\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including <windows.h> in this header file. Including <windows.h> is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true iff the handle is a valid handle object that can be closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);\n};\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass GTEST_API_ Notification {\n public:\n  Notification();\n  void Notify();\n  void WaitForNotification();\n\n private:\n  AutoHandle event_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n# endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don't want to use MinGW's pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n# if GTEST_HAS_PTHREAD && !GTEST_OS_WINDOWS_MINGW\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() {}\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern \"C\" inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast<ThreadWithParamBase*>(thread)->Run();\n  return NULL;\n}\n\n// Helper class for testing Google Test's multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam<int> thread(&ThreadFunc, 5, &thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test's own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&thread_, 0, &ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, 0));\n      finished_ = true;\n    }\n  }\n\n  virtual void Run() {\n    if (thread_can_start_ != NULL)\n      thread_can_start_->WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true iff we know that the thread function has finished.\n  pthread_t thread_;  // The native thread object.\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n# endif  // !GTEST_OS_WINDOWS && GTEST_HAS_PTHREAD ||\n         // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n# if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  _RTL_CRITICAL_SECTION* critical_section_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n    extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n    ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder<T>.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder<T> object holding a default value passed to\n  // this ThreadLocal<T>'s constructor and returns it.  It is the caller's\n  // responsibility not to call this when the ThreadLocal<T> instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocalBase);\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test's multi-threading constructs.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {\n  }\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param)\n        : func_(func),\n          param_(param) {\n    }\n    virtual ~RunnableImpl() {}\n    virtual void Run() {\n      func_(param_);\n    }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(RunnableImpl);\n  };\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal<int> tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate <typename T>\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n\n  T* GetOrCreateValue() const {\n    return static_cast<ValueHolder*>(\n        ThreadLocalRegistry::GetValueOnCurrentThread(this))->pointer();\n  }\n\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const {\n    return default_factory_->MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don't protect writing to has_owner_ here, as it's\n    // the caller's responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))\n        << \"The current thread is not holding the mutex @\" << this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there's no\n  // guarantee that a zero'd pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#  define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n     extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n#  define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n     ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, pthread_t() }\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n    has_owner_ = false;\n  }\n  ~Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal<T>.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern \"C\" inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast<ThreadLocalValueHolderBase*>(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&key, &DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast<ThreadLocalValueHolderBase*>(pthread_getspecific(key_));\n    if (holder != NULL) {\n      return CheckedDowncastToActualType<ValueHolder>(holder)->pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_->MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder->pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T& value) : value_(value) {}\n  T* pointer() { return &value_; }\n  const T* pointer() const { return &value_; }\n  const T& get() const { return value_; }\n  void set(const T& value) { value_ = value; }\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n// Passing non-POD classes through ellipsis (...) crashes the ARM\n// compiler and generates a warning in Sun Studio.  The Nokia Symbian\n// and the IBM XL C/C++ compiler try to instantiate a copy constructor\n// for objects passed through ellipsis (...), failing for uncopyable\n// objects.  We define this to ensure that only POD is passed through\n// ellipsis on these systems.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_ELLIPSIS_NEEDS_POD_ 1\n#else\n# define GTEST_CAN_COMPARE_NULL 1\n#endif\n\n// The Nokia Symbian and IBM XL C/C++ compilers cannot decide between\n// const T& and const T* in a function template.  These compilers\n// _can_ decide between class template specializations for T and T*,\n// so a tr1::type_traits-like is_pointer works.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__)\n# define GTEST_NEEDS_IS_POINTER_ 1\n#endif\n\ntemplate <bool bool_value>\nstruct bool_constant {\n  typedef bool_constant<bool_value> type;\n  static const bool value = bool_value;\n};\ntemplate <bool bool_value> const bool bool_constant<bool_value>::value;\n\ntypedef bool_constant<false> false_type;\ntypedef bool_constant<true> true_type;\n\ntemplate <typename T>\nstruct is_pointer : public false_type {};\n\ntemplate <typename T>\nstruct is_pointer<T*> : public true_type {};\n\ntemplate <typename Iterator>\nstruct IteratorTraits {\n  typedef typename Iterator::value_type value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<T*> {\n  typedef T value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<const T*> {\n  typedef T value_type;\n};\n\n#if GTEST_OS_WINDOWS\n# define GTEST_PATH_SEP_ \"\\\\\"\n# define GTEST_HAS_ALT_PATH_SEP_ 1\n// The biggest signed integer type the compiler supports.\ntypedef __int64 BiggestInt;\n#else\n# define GTEST_PATH_SEP_ \"/\"\n# define GTEST_HAS_ALT_PATH_SEP_ 0\ntypedef long long BiggestInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast<unsigned char>(ch);\n  return ch == low_byte && isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() && IsSpace(*--it))\n    it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// Functions with a different name on Windows.\n\n#if GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n# ifdef __BORLANDC__\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\n# else  // !__BORLANDC__\n#  if GTEST_OS_WINDOWS_MOBILE\ninline int IsATTY(int /* fd */) { return 0; }\n#  else\ninline int IsATTY(int fd) { return _isatty(fd); }\n#  endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return _strdup(src); }\n# endif  // __BORLANDC__\n\n# if GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast<int>(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n# else\ninline int FileNo(FILE* file) { return _fileno(file); }\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct& st) {\n  return (_S_IFDIR & st.st_mode) != 0;\n}\n# endif  // GTEST_OS_WINDOWS_MOBILE\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }\n\n#endif  // GTEST_OS_WINDOWS\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4996 /* deprecated function */)\n\ninline const char* StrNCpy(char* dest, const char* src, size_t n) {\n  return strncpy(dest, src, n);\n}\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren't needed on Windows CE at this time and thus not\n// defined there.\n\n#if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n  return fopen(path, mode);\n}\n#if !GTEST_OS_WINDOWS_MOBILE\ninline FILE *FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !GTEST_OS_WINDOWS_MOBILE\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast<int>(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast<int>(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif\ninline const char* GetEnv(const char* name) {\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT\n  // We are on Windows CE, which has no environment variables.\n  static_cast<void>(name);  // To prevent 'unused argument' warning.\n  return NULL;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != NULL && env[0] != '\\0') ? env : NULL;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n#if GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\nvoid Abort();\n#else\ninline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC \"deprecates\" snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE\n// MSVC 2005 and above support variadic macros.\n# define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n     _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s and MSVC prior to 2005 doesn't\n// complain about _snprintf.\n# define GTEST_SNPRINTF_ _snprintf\n#else\n# define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The maximum number a BiggestInt can represent.  This definition\n// works no matter BiggestInt is represented in one's complement or\n// two's complement.\n//\n// We cannot rely on numeric_limits in STL, as __int64 and long long\n// are not part of standard C++ and numeric_limits doesn't need to be\n// defined for them.\nconst BiggestInt kMaxBiggestInt =\n    ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize<4>::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that's all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate <size_t size>\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize<N> with incorrect\n  // values of N.\n  typedef void UInt;\n};\n\n// The specialization for size 4.\ntemplate <>\nclass TypeWithSize<4> {\n public:\n  // unsigned int has size 4 in both gcc and MSVC.\n  //\n  // As base/basictypes.h doesn't compile on Windows, we cannot use\n  // uint32, uint64, and etc here.\n  typedef int Int;\n  typedef unsigned int UInt;\n};\n\n// The specialization for size 8.\ntemplate <>\nclass TypeWithSize<8> {\n public:\n#if GTEST_OS_WINDOWS\n  typedef __int64 Int;\n  typedef unsigned __int64 UInt;\n#else\n  typedef long long Int;  // NOLINT\n  typedef unsigned long long UInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n};\n\n// Integer types of known sizes.\ntypedef TypeWithSize<4>::Int Int32;\ntypedef TypeWithSize<4>::UInt UInt32;\ntypedef TypeWithSize<8>::Int Int64;\ntypedef TypeWithSize<8>::UInt UInt64;\ntypedef TypeWithSize<8>::Int TimeInMillis;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n# define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n#if !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n# define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n#endif  // !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n\n#if !defined(GTEST_DECLARE_bool_)\n# define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n// Macros for declaring flags.\n# define GTEST_DECLARE_bool_(name) GTEST_API_ extern bool GTEST_FLAG(name)\n# define GTEST_DECLARE_int32_(name) \\\n    GTEST_API_ extern ::testing::internal::Int32 GTEST_FLAG(name)\n#define GTEST_DECLARE_string_(name) \\\n    GTEST_API_ extern ::std::string GTEST_FLAG(name)\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n    GTEST_API_ bool GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n    GTEST_API_ ::testing::internal::Int32 GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n    GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val)\n\n#endif  // !defined(GTEST_DECLARE_bool_)\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n# define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n# define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses 'str' for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\n// TODO(chandlerc): Find a better way to refactor flag and environment parsing\n// out of both gtest-port.cc and gtest.cc to avoid exporting this utility\n// function.\nbool ParseInt32(const Message& src_text, const char* str, Int32* value);\n\n// Parses a bool/Int32/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);\nstd::string StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}, "12": {"id": 12, "path": "/usr/include/c++/9/tuple", "content": "// <tuple> -*- C++ -*-\n\n// Copyright (C) 2007-2019 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/tuple\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _GLIBCXX_TUPLE\n#define _GLIBCXX_TUPLE 1\n\n#pragma GCC system_header\n\n#if __cplusplus < 201103L\n# include <bits/c++0x_warning.h>\n#else\n\n#include <utility>\n#include <array>\n#include <bits/uses_allocator.h>\n#include <bits/invoke.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @addtogroup utilities\n   *  @{\n   */\n\n  template<typename... _Elements>\n    class tuple;\n\n  template<typename _Tp>\n    struct __is_empty_non_tuple : is_empty<_Tp> { };\n\n  // Using EBO for elements that are tuples causes ambiguous base errors.\n  template<typename _El0, typename... _El>\n    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };\n\n  // Use the Empty Base-class Optimization for empty, non-final types.\n  template<typename _Tp>\n    using __empty_not_final\n    = typename conditional<__is_final(_Tp), false_type,\n\t\t\t   __is_empty_non_tuple<_Tp>>::type;\n\n  template<std::size_t _Idx, typename _Head,\n\t   bool = __empty_not_final<_Head>::value>\n    struct _Head_base;\n\n  template<std::size_t _Idx, typename _Head>\n    struct _Head_base<_Idx, _Head, true>\n    : public _Head\n    {\n      constexpr _Head_base()\n      : _Head() { }\n\n      constexpr _Head_base(const _Head& __h)\n      : _Head(__h) { }\n\n      constexpr _Head_base(const _Head_base&) = default;\n      constexpr _Head_base(_Head_base&&) = default;\n\n      template<typename _UHead>\n        constexpr _Head_base(_UHead&& __h)\n\t: _Head(std::forward<_UHead>(__h)) { }\n\n      _Head_base(allocator_arg_t, __uses_alloc0)\n      : _Head() { }\n\n      template<typename _Alloc>\n\t_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)\n\t: _Head(allocator_arg, *__a._M_a) { }\n\n      template<typename _Alloc>\n\t_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)\n\t: _Head(*__a._M_a) { }\n\n      template<typename _UHead>\n\t_Head_base(__uses_alloc0, _UHead&& __uhead)\n\t: _Head(std::forward<_UHead>(__uhead)) { }\n\n      template<typename _Alloc, typename _UHead>\n\t_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)\n\t: _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }\n\n      template<typename _Alloc, typename _UHead>\n\t_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)\n\t: _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }\n\n      static constexpr _Head&\n      _M_head(_Head_base& __b) noexcept { return __b; }\n\n      static constexpr const _Head&\n      _M_head(const _Head_base& __b) noexcept { return __b; }\n    };\n\n  template<std::size_t _Idx, typename _Head>\n    struct _Head_base<_Idx, _Head, false>\n    {\n      constexpr _Head_base()\n      : _M_head_impl() { }\n\n      constexpr _Head_base(const _Head& __h)\n      : _M_head_impl(__h) { }\n\n      constexpr _Head_base(const _Head_base&) = default;\n      constexpr _Head_base(_Head_base&&) = default;\n\n      template<typename _UHead>\n        constexpr _Head_base(_UHead&& __h)\n\t: _M_head_impl(std::forward<_UHead>(__h)) { }\n\n      _Head_base(allocator_arg_t, __uses_alloc0)\n      : _M_head_impl() { }\n\n      template<typename _Alloc>\n\t_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)\n\t: _M_head_impl(allocator_arg, *__a._M_a) { }\n\n      template<typename _Alloc>\n\t_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)\n\t: _M_head_impl(*__a._M_a) { }\n\n      template<typename _UHead>\n\t_Head_base(__uses_alloc0, _UHead&& __uhead)\n\t: _M_head_impl(std::forward<_UHead>(__uhead)) { }\n\n      template<typename _Alloc, typename _UHead>\n\t_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)\n\t: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))\n\t{ }\n\n      template<typename _Alloc, typename _UHead>\n\t_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)\n\t: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }\n\n      static constexpr _Head&\n      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }\n\n      static constexpr const _Head&\n      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }\n\n      _Head _M_head_impl;\n    };\n\n  /**\n   * Contains the actual implementation of the @c tuple template, stored\n   * as a recursive inheritance hierarchy from the first element (most\n   * derived class) to the last (least derived class). The @c Idx\n   * parameter gives the 0-based index of the element stored at this\n   * point in the hierarchy; we use it to implement a constant-time\n   * get() operation.\n   */\n  template<std::size_t _Idx, typename... _Elements>\n    struct _Tuple_impl;\n\n  /**\n   * Recursive tuple implementation. Here we store the @c Head element\n   * and derive from a @c Tuple_impl containing the remaining elements\n   * (which contains the @c Tail).\n   */\n  template<std::size_t _Idx, typename _Head, typename... _Tail>\n    struct _Tuple_impl<_Idx, _Head, _Tail...>\n    : public _Tuple_impl<_Idx + 1, _Tail...>,\n      private _Head_base<_Idx, _Head>\n    {\n      template<std::size_t, typename...> friend class _Tuple_impl;\n\n      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;\n      typedef _Head_base<_Idx, _Head> _Base;\n\n      static constexpr _Head&\n      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      static constexpr const _Head&\n      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      static constexpr _Inherited&\n      _M_tail(_Tuple_impl& __t) noexcept { return __t; }\n\n      static constexpr const _Inherited&\n      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }\n\n      constexpr _Tuple_impl()\n      : _Inherited(), _Base() { }\n\n      explicit\n      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)\n      : _Inherited(__tail...), _Base(__head) { }\n\n      template<typename _UHead, typename... _UTail, typename = typename\n               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>\n        explicit\n        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)\n\t: _Inherited(std::forward<_UTail>(__tail)...),\n\t  _Base(std::forward<_UHead>(__head)) { }\n\n      constexpr _Tuple_impl(const _Tuple_impl&) = default;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2729. Missing SFINAE on std::pair::operator=\n      _Tuple_impl& operator=(const _Tuple_impl&) = delete;\n\n      constexpr\n      _Tuple_impl(_Tuple_impl&& __in)\n      noexcept(__and_<is_nothrow_move_constructible<_Head>,\n\t              is_nothrow_move_constructible<_Inherited>>::value)\n      : _Inherited(std::move(_M_tail(__in))),\n\t_Base(std::forward<_Head>(_M_head(__in))) { }\n\n      template<typename... _UElements>\n        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n\t: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),\n\t  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }\n\n      template<typename _UHead, typename... _UTails>\n        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n\t: _Inherited(std::move\n\t\t     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),\n\t  _Base(std::forward<_UHead>\n\t\t(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }\n\n      template<typename _Alloc>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)\n\t: _Inherited(__tag, __a),\n          _Base(__tag, __use_alloc<_Head>(__a)) { }\n\n      template<typename _Alloc>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t\t    const _Head& __head, const _Tail&... __tail)\n\t: _Inherited(__tag, __a, __tail...),\n          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }\n\n      template<typename _Alloc, typename _UHead, typename... _UTail,\n               typename = typename enable_if<sizeof...(_Tail)\n\t\t\t\t\t     == sizeof...(_UTail)>::type>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            _UHead&& __head, _UTail&&... __tail)\n\t: _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),\n          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n\t        std::forward<_UHead>(__head)) { }\n\n      template<typename _Alloc>\n        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            const _Tuple_impl& __in)\n\t: _Inherited(__tag, __a, _M_tail(__in)),\n          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }\n\n      template<typename _Alloc>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            _Tuple_impl&& __in)\n\t: _Inherited(__tag, __a, std::move(_M_tail(__in))),\n\t  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n\t        std::forward<_Head>(_M_head(__in))) { }\n\n      template<typename _Alloc, typename... _UElements>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            const _Tuple_impl<_Idx, _UElements...>& __in)\n\t: _Inherited(__tag, __a,\n\t\t     _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),\n\t  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n\t\t_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }\n\n      template<typename _Alloc, typename _UHead, typename... _UTails>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n\t: _Inherited(__tag, __a, std::move\n\t\t     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),\n\t  _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n                std::forward<_UHead>\n\t\t(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }\n\n      template<typename... _UElements>\n        void\n        _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)\n        {\n\t  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);\n\t  _M_tail(*this)._M_assign(\n\t      _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));\n\t}\n\n      template<typename _UHead, typename... _UTails>\n        void\n        _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n        {\n\t  _M_head(*this) = std::forward<_UHead>\n\t    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));\n\t  _M_tail(*this)._M_assign(\n\t      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));\n\t}\n\n    protected:\n      void\n      _M_swap(_Tuple_impl& __in)\n      {\n\tusing std::swap;\n\tswap(_M_head(*this), _M_head(__in));\n\t_Inherited::_M_swap(_M_tail(__in));\n      }\n    };\n\n  // Basis case of inheritance recursion.\n  template<std::size_t _Idx, typename _Head>\n    struct _Tuple_impl<_Idx, _Head>\n    : private _Head_base<_Idx, _Head>\n    {\n      template<std::size_t, typename...> friend class _Tuple_impl;\n\n      typedef _Head_base<_Idx, _Head> _Base;\n\n      static constexpr _Head&\n      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      static constexpr const _Head&\n      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }\n\n      constexpr _Tuple_impl()\n      : _Base() { }\n\n      explicit\n      constexpr _Tuple_impl(const _Head& __head)\n      : _Base(__head) { }\n\n      template<typename _UHead>\n        explicit\n        constexpr _Tuple_impl(_UHead&& __head)\n\t: _Base(std::forward<_UHead>(__head)) { }\n\n      constexpr _Tuple_impl(const _Tuple_impl&) = default;\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2729. Missing SFINAE on std::pair::operator=\n      _Tuple_impl& operator=(const _Tuple_impl&) = delete;\n\n      constexpr\n      _Tuple_impl(_Tuple_impl&& __in)\n      noexcept(is_nothrow_move_constructible<_Head>::value)\n      : _Base(std::forward<_Head>(_M_head(__in))) { }\n\n      template<typename _UHead>\n        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)\n\t: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }\n\n      template<typename _UHead>\n        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)\n\t: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n\t{ }\n\n      template<typename _Alloc>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)\n\t: _Base(__tag, __use_alloc<_Head>(__a)) { }\n\n      template<typename _Alloc>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t\t    const _Head& __head)\n\t: _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }\n\n      template<typename _Alloc, typename _UHead>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            _UHead&& __head)\n\t: _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n\t        std::forward<_UHead>(__head)) { }\n\n      template<typename _Alloc>\n        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            const _Tuple_impl& __in)\n\t: _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }\n\n      template<typename _Alloc>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            _Tuple_impl&& __in)\n\t: _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n\t        std::forward<_Head>(_M_head(__in))) { }\n\n      template<typename _Alloc, typename _UHead>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            const _Tuple_impl<_Idx, _UHead>& __in)\n\t: _Base(__use_alloc<_Head, _Alloc, _Head>(__a),\n\t\t_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }\n\n      template<typename _Alloc, typename _UHead>\n\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n\t            _Tuple_impl<_Idx, _UHead>&& __in)\n\t: _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),\n                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n\t{ }\n\n      template<typename _UHead>\n        void\n        _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)\n        {\n\t  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);\n\t}\n\n      template<typename _UHead>\n        void\n        _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)\n        {\n\t  _M_head(*this)\n\t    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));\n\t}\n\n    protected:\n      void\n      _M_swap(_Tuple_impl& __in)\n      {\n\tusing std::swap;\n\tswap(_M_head(*this), _M_head(__in));\n      }\n    };\n\n  // Concept utility functions, reused in conditionally-explicit\n  // constructors.\n  template<bool, typename... _Elements>\n  struct _TC\n  {\n    template<typename... _UElements>\n    static constexpr bool _ConstructibleTuple()\n    {\n      return __and_<is_constructible<_Elements, const _UElements&>...>::value;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyConvertibleTuple()\n    {\n      return __and_<is_convertible<const _UElements&, _Elements>...>::value;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _MoveConstructibleTuple()\n    {\n      return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyMoveConvertibleTuple()\n    {\n      return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n    }\n\n    template<typename _SrcTuple>\n    static constexpr bool _NonNestedTuple()\n    {\n      return  __and_<__not_<is_same<tuple<_Elements...>,\n\t\t\t\t    __remove_cvref_t<_SrcTuple>>>,\n                     __not_<is_convertible<_SrcTuple, _Elements...>>,\n                     __not_<is_constructible<_Elements..., _SrcTuple>>\n              >::value;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _NotSameTuple()\n    {\n      return  __not_<is_same<tuple<_Elements...>,\n\t\t\t     __remove_cvref_t<_UElements>...>>::value;\n    }\n  };\n\n  template<typename... _Elements>\n  struct _TC<false, _Elements...>\n  {\n    template<typename... _UElements>\n    static constexpr bool _ConstructibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyConvertibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _MoveConstructibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _ImplicitlyMoveConvertibleTuple()\n    {\n      return false;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _NonNestedTuple()\n    {\n      return true;\n    }\n\n    template<typename... _UElements>\n    static constexpr bool _NotSameTuple()\n    {\n      return true;\n    }\n  };\n\n  /// Primary class template, tuple\n  template<typename... _Elements>\n    class tuple : public _Tuple_impl<0, _Elements...>\n    {\n      typedef _Tuple_impl<0, _Elements...> _Inherited;\n\n      // Used for constraining the default constructor so\n      // that it becomes dependent on the constraints.\n      template<typename _Dummy>\n      struct _TC2\n      {\n        static constexpr bool _DefaultConstructibleTuple()\n        {\n          return __and_<is_default_constructible<_Elements>...>::value;\n        }\n        static constexpr bool _ImplicitlyDefaultConstructibleTuple()\n        {\n          return __and_<__is_implicitly_default_constructible<_Elements>...>\n            ::value;\n        }\n      };\n\n      template<typename... _UElements>\n\tstatic constexpr\n\t__enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>\n\t__assignable()\n\t{ return __and_<is_assignable<_Elements&, _UElements>...>::value; }\n\n      template<typename... _UElements>\n\tstatic constexpr bool __nothrow_assignable()\n\t{\n\t  return\n\t    __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;\n\t}\n\n    public:\n      template<typename _Dummy = void,\n               typename enable_if<_TC2<_Dummy>::\n                                    _ImplicitlyDefaultConstructibleTuple(),\n                                  bool>::type = true>\n      constexpr tuple()\n      : _Inherited() { }\n\n      template<typename _Dummy = void,\n               typename enable_if<_TC2<_Dummy>::\n                                    _DefaultConstructibleTuple()\n                                  &&\n                                  !_TC2<_Dummy>::\n                                    _ImplicitlyDefaultConstructibleTuple(),\n                                  bool>::type = false>\n      explicit constexpr tuple()\n      : _Inherited() { }\n\n      // Shortcut for the cases where constructors taking _Elements...\n      // need to be constrained.\n      template<typename _Dummy> using _TCC =\n        _TC<is_same<_Dummy, void>::value,\n            _Elements...>;\n\n      template<typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>::template\n                   _ConstructibleTuple<_Elements...>()\n                 && _TCC<_Dummy>::template\n                   _ImplicitlyConvertibleTuple<_Elements...>()\n                 && (sizeof...(_Elements) >= 1),\n               bool>::type=true>\n        constexpr tuple(const _Elements&... __elements)\n      : _Inherited(__elements...) { }\n\n      template<typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>::template\n                   _ConstructibleTuple<_Elements...>()\n                 && !_TCC<_Dummy>::template\n                   _ImplicitlyConvertibleTuple<_Elements...>()\n                 && (sizeof...(_Elements) >= 1),\n               bool>::type=false>\n      explicit constexpr tuple(const _Elements&... __elements)\n      : _Inherited(__elements...) { }\n\n      // Shortcut for the cases where constructors taking _UElements...\n      // need to be constrained.\n      template<typename... _UElements> using _TMC =\n                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))\n\t\t      && (_TC<(sizeof...(_UElements)==1), _Elements...>::\n\t\t\t  template _NotSameTuple<_UElements...>()),\n                      _Elements...>;\n\n      // Shortcut for the cases where constructors taking tuple<_UElements...>\n      // need to be constrained.\n      template<typename... _UElements> using _TMCT =\n                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))\n\t\t      && !is_same<tuple<_Elements...>,\n\t\t\t\t  tuple<_UElements...>>::value,\n                      _Elements...>;\n\n      template<typename... _UElements, typename\n\t       enable_if<\n\t\t  _TMC<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && _TMC<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n                  && (sizeof...(_Elements) >= 1),\n        bool>::type=true>\n        constexpr tuple(_UElements&&... __elements)\n        : _Inherited(std::forward<_UElements>(__elements)...) { }\n\n      template<typename... _UElements, typename\n        enable_if<\n\t\t  _TMC<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && !_TMC<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n                  && (sizeof...(_Elements) >= 1),\n        bool>::type=false>\n        explicit constexpr tuple(_UElements&&... __elements)\n\t: _Inherited(std::forward<_UElements>(__elements)...) {\t}\n\n      constexpr tuple(const tuple&) = default;\n\n      constexpr tuple(tuple&&) = default;\n\n      // Shortcut for the cases where constructors taking tuples\n      // must avoid creating temporaries.\n      template<typename _Dummy> using _TNTC =\n        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,\n            _Elements...>;\n\n      template<typename... _UElements, typename _Dummy = void, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _ConstructibleTuple<_UElements...>()\n                  && _TMCT<_UElements...>::template\n                    _ImplicitlyConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<const tuple<_UElements...>&>(),\n        bool>::type=true>\n        constexpr tuple(const tuple<_UElements...>& __in)\n        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n        { }\n\n      template<typename... _UElements, typename _Dummy = void, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _ConstructibleTuple<_UElements...>()\n                  && !_TMCT<_UElements...>::template\n                    _ImplicitlyConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<const tuple<_UElements...>&>(),\n        bool>::type=false>\n        explicit constexpr tuple(const tuple<_UElements...>& __in)\n        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n        { }\n\n      template<typename... _UElements, typename _Dummy = void, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && _TMCT<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<tuple<_UElements...>&&>(),\n        bool>::type=true>\n        constexpr tuple(tuple<_UElements...>&& __in)\n        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n\n      template<typename... _UElements, typename _Dummy = void, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && !_TMCT<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<tuple<_UElements...>&&>(),\n        bool>::type=false>\n        explicit constexpr tuple(tuple<_UElements...>&& __in)\n        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n\n      // Allocator-extended constructors.\n\n      template<typename _Alloc>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a)\n\t: _Inherited(__tag, __a) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>::template\n                   _ConstructibleTuple<_Elements...>()\n                 && _TCC<_Dummy>::template\n                   _ImplicitlyConvertibleTuple<_Elements...>(),\n               bool>::type=true>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const _Elements&... __elements)\n\t: _Inherited(__tag, __a, __elements...) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>::template\n                   _ConstructibleTuple<_Elements...>()\n                 && !_TCC<_Dummy>::template\n                   _ImplicitlyConvertibleTuple<_Elements...>(),\n               bool>::type=false>\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       const _Elements&... __elements)\n\t: _Inherited(__tag, __a, __elements...) { }\n\n      template<typename _Alloc, typename... _UElements, typename\n        enable_if<_TMC<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && _TMC<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n        bool>::type=true>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      _UElements&&... __elements)\n\t: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n       \t{ }\n\n      template<typename _Alloc, typename... _UElements, typename\n        enable_if<_TMC<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && !_TMC<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),\n        bool>::type=false>\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      _UElements&&... __elements)\n\t: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)\n        { }\n\n      template<typename _Alloc>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n\t: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n\n      template<typename _Alloc>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n\t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n\t       typename... _UElements, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _ConstructibleTuple<_UElements...>()\n                  && _TMCT<_UElements...>::template\n                    _ImplicitlyConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<const tuple<_UElements...>&>(),\n        bool>::type=true>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const tuple<_UElements...>& __in)\n\t: _Inherited(__tag, __a,\n\t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n\t{ }\n\n      template<typename _Alloc, typename _Dummy = void,\n\t       typename... _UElements, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _ConstructibleTuple<_UElements...>()\n                  && !_TMCT<_UElements...>::template\n                    _ImplicitlyConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<const tuple<_UElements...>&>(),\n        bool>::type=false>\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const tuple<_UElements...>& __in)\n\t: _Inherited(__tag, __a,\n\t             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n\t{ }\n\n      template<typename _Alloc, typename _Dummy = void,\n\t       typename... _UElements, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && _TMCT<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<tuple<_UElements...>&&>(),\n        bool>::type=true>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      tuple<_UElements...>&& __in)\n\t: _Inherited(__tag, __a,\n\t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n\t{ }\n\n      template<typename _Alloc, typename _Dummy = void,\n\t       typename... _UElements, typename\n        enable_if<_TMCT<_UElements...>::template\n                    _MoveConstructibleTuple<_UElements...>()\n                  && !_TMCT<_UElements...>::template\n                    _ImplicitlyMoveConvertibleTuple<_UElements...>()\n                  && _TNTC<_Dummy>::template\n                    _NonNestedTuple<tuple<_UElements...>&&>(),\n        bool>::type=false>\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      tuple<_UElements...>&& __in)\n\t: _Inherited(__tag, __a,\n\t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n\t{ }\n\n      // tuple assignment\n\n      tuple&\n      operator=(typename conditional<__assignable<const _Elements&...>(),\n\t\t\t\t     const tuple&,\n\t\t\t\t     const __nonesuch_no_braces&>::type __in)\n      noexcept(__nothrow_assignable<const _Elements&...>())\n      {\n\tthis->_M_assign(__in);\n\treturn *this;\n      }\n\n      tuple&\n      operator=(typename conditional<__assignable<_Elements...>(),\n\t\t\t\t     tuple&&,\n\t\t\t\t     __nonesuch_no_braces&&>::type __in)\n      noexcept(__nothrow_assignable<_Elements...>())\n      {\n\tthis->_M_assign(std::move(__in));\n\treturn *this;\n      }\n\n      template<typename... _UElements>\n\t__enable_if_t<__assignable<const _UElements&...>(), tuple&>\n\toperator=(const tuple<_UElements...>& __in)\n\tnoexcept(__nothrow_assignable<const _UElements&...>())\n\t{\n\t  this->_M_assign(__in);\n\t  return *this;\n\t}\n\n      template<typename... _UElements>\n\t__enable_if_t<__assignable<_UElements...>(), tuple&>\n\toperator=(tuple<_UElements...>&& __in)\n\tnoexcept(__nothrow_assignable<_UElements...>())\n\t{\n\t  this->_M_assign(std::move(__in));\n\t  return *this;\n\t}\n\n      // tuple swap\n      void\n      swap(tuple& __in)\n      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)\n      { _Inherited::_M_swap(__in); }\n    };\n\n#if __cpp_deduction_guides >= 201606\n  template<typename... _UTypes>\n    tuple(_UTypes...) -> tuple<_UTypes...>;\n  template<typename _T1, typename _T2>\n    tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;\n  template<typename _Alloc, typename... _UTypes>\n    tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;\n  template<typename _Alloc, typename _T1, typename _T2>\n    tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;\n  template<typename _Alloc, typename... _UTypes>\n    tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;\n#endif\n\n  // Explicit specialization, zero-element tuple.\n  template<>\n    class tuple<>\n    {\n    public:\n      void swap(tuple&) noexcept { /* no-op */ }\n      // We need the default since we're going to define no-op\n      // allocator constructors.\n      tuple() = default;\n      // No-op allocator constructors.\n      template<typename _Alloc>\n\ttuple(allocator_arg_t, const _Alloc&) { }\n      template<typename _Alloc>\n\ttuple(allocator_arg_t, const _Alloc&, const tuple&) { }\n    };\n\n  /// Partial specialization, 2-element tuple.\n  /// Includes construction and assignment from a pair.\n  template<typename _T1, typename _T2>\n    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n    {\n      typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n\n      template<typename _U1, typename _U2>\n\tstatic constexpr bool __assignable()\n\t{\n\t  return __and_<is_assignable<_T1&, _U1>,\n\t\t\tis_assignable<_T2&, _U2>>::value;\n\t}\n\n      template<typename _U1, typename _U2>\n\tstatic constexpr bool __nothrow_assignable()\n\t{\n\t  return __and_<is_nothrow_assignable<_T1&, _U1>,\n\t\t\tis_nothrow_assignable<_T2&, _U2>>::value;\n\t}\n\n    public:\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<__and_<\n                                     __is_implicitly_default_constructible<_U1>,\n                                     __is_implicitly_default_constructible<_U2>>\n                                   ::value, bool>::type = true>\n\tconstexpr tuple()\n\t: _Inherited() { }\n\n      template <typename _U1 = _T1,\n                typename _U2 = _T2,\n                typename enable_if<\n                  __and_<\n                    is_default_constructible<_U1>,\n                    is_default_constructible<_U2>,\n                    __not_<\n                      __and_<__is_implicitly_default_constructible<_U1>,\n                             __is_implicitly_default_constructible<_U2>>>>\n                  ::value, bool>::type = false>\n\texplicit constexpr tuple()\n\t: _Inherited() { }\n\n      // Shortcut for the cases where constructors taking _T1, _T2\n      // need to be constrained.\n      template<typename _Dummy> using _TCC =\n        _TC<is_same<_Dummy, void>::value, _T1, _T2>;\n\n      template<typename _Dummy = void, typename\n               enable_if<_TCC<_Dummy>::template\n                           _ConstructibleTuple<_T1, _T2>()\n                         && _TCC<_Dummy>::template\n                           _ImplicitlyConvertibleTuple<_T1, _T2>(),\n\tbool>::type = true>\n        constexpr tuple(const _T1& __a1, const _T2& __a2)\n        : _Inherited(__a1, __a2) { }\n\n      template<typename _Dummy = void, typename\n               enable_if<_TCC<_Dummy>::template\n                           _ConstructibleTuple<_T1, _T2>()\n                         && !_TCC<_Dummy>::template\n                           _ImplicitlyConvertibleTuple<_T1, _T2>(),\n\tbool>::type = false>\n        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)\n        : _Inherited(__a1, __a2) { }\n\n      // Shortcut for the cases where constructors taking _U1, _U2\n      // need to be constrained.\n      using _TMC = _TC<true, _T1, _T2>;\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()\n\t          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,\n\tbool>::type = true>\n        constexpr tuple(_U1&& __a1, _U2&& __a2)\n\t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()\n\t          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,\n\tbool>::type = false>\n        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)\n\t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n\n      constexpr tuple(const tuple&) = default;\n\n      constexpr tuple(tuple&&) = default;\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n        constexpr tuple(const tuple<_U1, _U2>& __in)\n\t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n        explicit constexpr tuple(const tuple<_U1, _U2>& __in)\n\t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n        constexpr tuple(tuple<_U1, _U2>&& __in)\n\t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n        explicit constexpr tuple(tuple<_U1, _U2>&& __in)\n\t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n        constexpr tuple(const pair<_U1, _U2>& __in)\n\t: _Inherited(__in.first, __in.second) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n        explicit constexpr tuple(const pair<_U1, _U2>& __in)\n\t: _Inherited(__in.first, __in.second) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n        constexpr tuple(pair<_U1, _U2>&& __in)\n\t: _Inherited(std::forward<_U1>(__in.first),\n\t\t     std::forward<_U2>(__in.second)) { }\n\n      template<typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n        explicit constexpr tuple(pair<_U1, _U2>&& __in)\n\t: _Inherited(std::forward<_U1>(__in.first),\n\t\t     std::forward<_U2>(__in.second)) { }\n\n      // Allocator-extended constructors.\n\n      template<typename _Alloc>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a)\n\t: _Inherited(__tag, __a) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>::template\n                   _ConstructibleTuple<_T1, _T2>()\n                 && _TCC<_Dummy>::template\n                   _ImplicitlyConvertibleTuple<_T1, _T2>(),\n               bool>::type=true>\n\n\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const _T1& __a1, const _T2& __a2)\n\t: _Inherited(__tag, __a, __a1, __a2) { }\n\n      template<typename _Alloc, typename _Dummy = void,\n               typename enable_if<\n                 _TCC<_Dummy>::template\n                   _ConstructibleTuple<_T1, _T2>()\n                 && !_TCC<_Dummy>::template\n                   _ImplicitlyConvertibleTuple<_T1, _T2>(),\n               bool>::type=false>\n\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const _T1& __a1, const _T2& __a2)\n\t: _Inherited(__tag, __a, __a1, __a2) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)\n\t: _Inherited(__tag, __a, std::forward<_U1>(__a1),\n\t             std::forward<_U2>(__a2)) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       _U1&& __a1, _U2&& __a2)\n\t: _Inherited(__tag, __a, std::forward<_U1>(__a1),\n\t             std::forward<_U2>(__a2)) { }\n\n      template<typename _Alloc>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)\n\t: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }\n\n      template<typename _Alloc>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)\n\t: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const tuple<_U1, _U2>& __in)\n\t: _Inherited(__tag, __a,\n\t             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n\t{ }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const tuple<_U1, _U2>& __in)\n\t: _Inherited(__tag, __a,\n\t             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))\n\t{ }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n\ttuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)\n\t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n\t{ }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n\texplicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       tuple<_U1, _U2>&& __in)\n\t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n\t{ }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n        tuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const pair<_U1, _U2>& __in)\n\t: _Inherited(__tag, __a, __in.first, __in.second) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _ConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n\t      const pair<_U1, _U2>& __in)\n\t: _Inherited(__tag, __a, __in.first, __in.second) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && _TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = true>\n        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)\n\t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n\t\t     std::forward<_U2>(__in.second)) { }\n\n      template<typename _Alloc, typename _U1, typename _U2, typename\n        enable_if<_TMC::template\n                    _MoveConstructibleTuple<_U1, _U2>()\n                  && !_TMC::template\n                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n\tbool>::type = false>\n        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,\n                       pair<_U1, _U2>&& __in)\n\t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n\t\t     std::forward<_U2>(__in.second)) { }\n\n      tuple&\n      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),\n\t\t\t\t     const tuple&,\n\t\t\t\t     const __nonesuch_no_braces&>::type __in)\n      noexcept(__nothrow_assignable<const _T1&, const _T2&>())\n      {\n\tthis->_M_assign(__in);\n\treturn *this;\n      }\n\n      tuple&\n      operator=(typename conditional<__assignable<_T1, _T2>(),\n\t\t\t\t     tuple&&,\n\t\t\t\t     __nonesuch_no_braces&&>::type __in)\n      noexcept(__nothrow_assignable<_T1, _T2>())\n      {\n\tthis->_M_assign(std::move(__in));\n\treturn *this;\n      }\n\n      template<typename _U1, typename _U2>\n\t__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>\n\toperator=(const tuple<_U1, _U2>& __in)\n\tnoexcept(__nothrow_assignable<const _U1&, const _U2&>())\n\t{\n\t  this->_M_assign(__in);\n\t  return *this;\n\t}\n\n      template<typename _U1, typename _U2>\n\t__enable_if_t<__assignable<_U1, _U2>(), tuple&>\n\toperator=(tuple<_U1, _U2>&& __in)\n\tnoexcept(__nothrow_assignable<_U1, _U2>())\n\t{\n\t  this->_M_assign(std::move(__in));\n\t  return *this;\n\t}\n\n      template<typename _U1, typename _U2>\n\t__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>\n\toperator=(const pair<_U1, _U2>& __in)\n\tnoexcept(__nothrow_assignable<const _U1&, const _U2&>())\n\t{\n\t  this->_M_head(*this) = __in.first;\n\t  this->_M_tail(*this)._M_head(*this) = __in.second;\n\t  return *this;\n\t}\n\n      template<typename _U1, typename _U2>\n\t__enable_if_t<__assignable<_U1, _U2>(), tuple&>\n\toperator=(pair<_U1, _U2>&& __in)\n\tnoexcept(__nothrow_assignable<_U1, _U2>())\n\t{\n\t  this->_M_head(*this) = std::forward<_U1>(__in.first);\n\t  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);\n\t  return *this;\n\t}\n\n      void\n      swap(tuple& __in)\n      noexcept(__and_<__is_nothrow_swappable<_T1>,\n\t\t      __is_nothrow_swappable<_T2>>::value)\n      { _Inherited::_M_swap(__in); }\n    };\n\n\n  /// class tuple_size\n  template<typename... _Elements>\n    struct tuple_size<tuple<_Elements...>>\n    : public integral_constant<std::size_t, sizeof...(_Elements)> { };\n\n#if __cplusplus > 201402L\n  template <typename _Tp>\n    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;\n#endif\n\n  /**\n   * Recursive case for tuple_element: strip off the first element in\n   * the tuple and retrieve the (i-1)th element of the remaining tuple.\n   */\n  template<std::size_t __i, typename _Head, typename... _Tail>\n    struct tuple_element<__i, tuple<_Head, _Tail...> >\n    : tuple_element<__i - 1, tuple<_Tail...> > { };\n\n  /**\n   * Basis case for tuple_element: The first element is the one we're seeking.\n   */\n  template<typename _Head, typename... _Tail>\n    struct tuple_element<0, tuple<_Head, _Tail...> >\n    {\n      typedef _Head type;\n    };\n\n  /**\n   * Error case for tuple_element: invalid index.\n   */\n  template<size_t __i>\n    struct tuple_element<__i, tuple<>>\n    {\n      static_assert(__i < tuple_size<tuple<>>::value,\n\t  \"tuple index is in range\");\n    };\n\n  template<std::size_t __i, typename _Head, typename... _Tail>\n    constexpr _Head&\n    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n  template<std::size_t __i, typename _Head, typename... _Tail>\n    constexpr const _Head&\n    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n  /// Return a reference to the ith element of a tuple.\n  template<std::size_t __i, typename... _Elements>\n    constexpr __tuple_element_t<__i, tuple<_Elements...>>&\n    get(tuple<_Elements...>& __t) noexcept\n    { return std::__get_helper<__i>(__t); }\n\n  /// Return a const reference to the ith element of a const tuple.\n  template<std::size_t __i, typename... _Elements>\n    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&\n    get(const tuple<_Elements...>& __t) noexcept\n    { return std::__get_helper<__i>(__t); }\n\n  /// Return an rvalue reference to the ith element of a tuple rvalue.\n  template<std::size_t __i, typename... _Elements>\n    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&\n    get(tuple<_Elements...>&& __t) noexcept\n    {\n      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;\n      return std::forward<__element_type&&>(std::get<__i>(__t));\n    }\n\n  /// Return a const rvalue reference to the ith element of a const tuple rvalue.\n  template<std::size_t __i, typename... _Elements>\n    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&\n    get(const tuple<_Elements...>&& __t) noexcept\n    {\n      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;\n      return std::forward<const __element_type&&>(std::get<__i>(__t));\n    }\n\n#if __cplusplus >= 201402L\n\n#define __cpp_lib_tuples_by_type 201304\n\n  template<typename _Head, size_t __i, typename... _Tail>\n    constexpr _Head&\n    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n  template<typename _Head, size_t __i, typename... _Tail>\n    constexpr const _Head&\n    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n\n  /// Return a reference to the unique element of type _Tp of a tuple.\n  template <typename _Tp, typename... _Types>\n    constexpr _Tp&\n    get(tuple<_Types...>& __t) noexcept\n    { return std::__get_helper2<_Tp>(__t); }\n\n  /// Return a reference to the unique element of type _Tp of a tuple rvalue.\n  template <typename _Tp, typename... _Types>\n    constexpr _Tp&&\n    get(tuple<_Types...>&& __t) noexcept\n    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }\n\n  /// Return a const reference to the unique element of type _Tp of a tuple.\n  template <typename _Tp, typename... _Types>\n    constexpr const _Tp&\n    get(const tuple<_Types...>& __t) noexcept\n    { return std::__get_helper2<_Tp>(__t); }\n\n  /// Return a const reference to the unique element of type _Tp of\n  /// a const tuple rvalue.\n  template <typename _Tp, typename... _Types>\n    constexpr const _Tp&&\n    get(const tuple<_Types...>&& __t) noexcept\n    { return std::forward<const _Tp&&>(std::__get_helper2<_Tp>(__t)); }\n#endif\n\n  // This class performs the comparison operations on tuples\n  template<typename _Tp, typename _Up, size_t __i, size_t __size>\n    struct __tuple_compare\n    {\n      static constexpr bool\n      __eq(const _Tp& __t, const _Up& __u)\n      {\n\treturn bool(std::get<__i>(__t) == std::get<__i>(__u))\n\t  && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);\n      }\n\n      static constexpr bool\n      __less(const _Tp& __t, const _Up& __u)\n      {\n\treturn bool(std::get<__i>(__t) < std::get<__i>(__u))\n\t  || (!bool(std::get<__i>(__u) < std::get<__i>(__t))\n\t      && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));\n      }\n    };\n\n  template<typename _Tp, typename _Up, size_t __size>\n    struct __tuple_compare<_Tp, _Up, __size, __size>\n    {\n      static constexpr bool\n      __eq(const _Tp&, const _Up&) { return true; }\n\n      static constexpr bool\n      __less(const _Tp&, const _Up&) { return false; }\n    };\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n    operator==(const tuple<_TElements...>& __t,\n\t       const tuple<_UElements...>& __u)\n    {\n      static_assert(sizeof...(_TElements) == sizeof...(_UElements),\n\t  \"tuple objects can only be compared if they have equal sizes.\");\n      using __compare = __tuple_compare<tuple<_TElements...>,\n\t\t\t\t\ttuple<_UElements...>,\n\t\t\t\t\t0, sizeof...(_TElements)>;\n      return __compare::__eq(__t, __u);\n    }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n    operator<(const tuple<_TElements...>& __t,\n\t      const tuple<_UElements...>& __u)\n    {\n      static_assert(sizeof...(_TElements) == sizeof...(_UElements),\n\t  \"tuple objects can only be compared if they have equal sizes.\");\n      using __compare = __tuple_compare<tuple<_TElements...>,\n\t\t\t\t\ttuple<_UElements...>,\n\t\t\t\t\t0, sizeof...(_TElements)>;\n      return __compare::__less(__t, __u);\n    }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n    operator!=(const tuple<_TElements...>& __t,\n\t       const tuple<_UElements...>& __u)\n    { return !(__t == __u); }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n    operator>(const tuple<_TElements...>& __t,\n\t      const tuple<_UElements...>& __u)\n    { return __u < __t; }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n    operator<=(const tuple<_TElements...>& __t,\n\t       const tuple<_UElements...>& __u)\n    { return !(__u < __t); }\n\n  template<typename... _TElements, typename... _UElements>\n    constexpr bool\n    operator>=(const tuple<_TElements...>& __t,\n\t       const tuple<_UElements...>& __u)\n    { return !(__t < __u); }\n\n  // NB: DR 705.\n  template<typename... _Elements>\n    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>\n    make_tuple(_Elements&&... __args)\n    {\n      typedef tuple<typename __decay_and_strip<_Elements>::__type...>\n\t__result_type;\n      return __result_type(std::forward<_Elements>(__args)...);\n    }\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2275. Why is forward_as_tuple not constexpr?\n  /// std::forward_as_tuple\n  template<typename... _Elements>\n    constexpr tuple<_Elements&&...>\n    forward_as_tuple(_Elements&&... __args) noexcept\n    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }\n\n  template<size_t, typename, typename, size_t>\n    struct __make_tuple_impl;\n\n  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>\n    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>\n    : __make_tuple_impl<_Idx + 1,\n\t\t\ttuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,\n\t\t\t_Tuple, _Nm>\n    { };\n\n  template<std::size_t _Nm, typename _Tuple, typename... _Tp>\n    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>\n    {\n      typedef tuple<_Tp...> __type;\n    };\n\n  template<typename _Tuple>\n    struct __do_make_tuple\n    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>\n    { };\n\n  // Returns the std::tuple equivalent of a tuple-like type.\n  template<typename _Tuple>\n    struct __make_tuple\n    : public __do_make_tuple<__remove_cvref_t<_Tuple>>\n    { };\n\n  // Combines several std::tuple's into a single one.\n  template<typename...>\n    struct __combine_tuples;\n\n  template<>\n    struct __combine_tuples<>\n    {\n      typedef tuple<> __type;\n    };\n\n  template<typename... _Ts>\n    struct __combine_tuples<tuple<_Ts...>>\n    {\n      typedef tuple<_Ts...> __type;\n    };\n\n  template<typename... _T1s, typename... _T2s, typename... _Rem>\n    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>\n    {\n      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,\n\t\t\t\t\t_Rem...>::__type __type;\n    };\n\n  // Computes the result type of tuple_cat given a set of tuple-like types.\n  template<typename... _Tpls>\n    struct __tuple_cat_result\n    {\n      typedef typename __combine_tuples\n        <typename __make_tuple<_Tpls>::__type...>::__type __type;\n    };\n\n  // Helper to determine the index set for the first tuple-like\n  // type of a given set.\n  template<typename...>\n    struct __make_1st_indices;\n\n  template<>\n    struct __make_1st_indices<>\n    {\n      typedef std::_Index_tuple<> __type;\n    };\n\n  template<typename _Tp, typename... _Tpls>\n    struct __make_1st_indices<_Tp, _Tpls...>\n    {\n      typedef typename std::_Build_index_tuple<std::tuple_size<\n\ttypename std::remove_reference<_Tp>::type>::value>::__type __type;\n    };\n\n  // Performs the actual concatenation by step-wise expanding tuple-like\n  // objects into the elements,  which are finally forwarded into the\n  // result tuple.\n  template<typename _Ret, typename _Indices, typename... _Tpls>\n    struct __tuple_concater;\n\n  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>\n    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>\n    {\n      template<typename... _Us>\n        static constexpr _Ret\n        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)\n        {\n\t  typedef typename __make_1st_indices<_Tpls...>::__type __idx;\n\t  typedef __tuple_concater<_Ret, __idx, _Tpls...>      __next;\n\t  return __next::_S_do(std::forward<_Tpls>(__tps)...,\n\t\t\t       std::forward<_Us>(__us)...,\n\t\t\t       std::get<_Is>(std::forward<_Tp>(__tp))...);\n\t}\n    };\n\n  template<typename _Ret>\n    struct __tuple_concater<_Ret, std::_Index_tuple<>>\n    {\n      template<typename... _Us>\n\tstatic constexpr _Ret\n\t_S_do(_Us&&... __us)\n        {\n\t  return _Ret(std::forward<_Us>(__us)...);\n\t}\n    };\n\n  /// tuple_cat\n  template<typename... _Tpls, typename = typename\n           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>\n    constexpr auto\n    tuple_cat(_Tpls&&... __tpls)\n    -> typename __tuple_cat_result<_Tpls...>::__type\n    {\n      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;\n      typedef typename __make_1st_indices<_Tpls...>::__type __idx;\n      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;\n      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);\n    }\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2301. Why is tie not constexpr?\n  /// tie\n  template<typename... _Elements>\n    constexpr tuple<_Elements&...>\n    tie(_Elements&... __args) noexcept\n    { return tuple<_Elements&...>(__args...); }\n\n  /// swap\n  template<typename... _Elements>\n    inline\n#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n    // Constrained free swap overload, see p0185r1\n    typename enable_if<__and_<__is_swappable<_Elements>...>::value\n      >::type\n#else\n    void\n#endif\n    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)\n    noexcept(noexcept(__x.swap(__y)))\n    { __x.swap(__y); }\n\n#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n  template<typename... _Elements>\n    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type\n    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;\n#endif\n\n  // A class (and instance) which can be used in 'tie' when an element\n  // of a tuple is not required.\n  // _GLIBCXX14_CONSTEXPR\n  // 2933. PR for LWG 2773 could be clearer\n  struct _Swallow_assign\n  {\n    template<class _Tp>\n      _GLIBCXX14_CONSTEXPR const _Swallow_assign&\n      operator=(const _Tp&) const\n      { return *this; }\n  };\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2773. Making std::ignore constexpr\n  _GLIBCXX17_INLINE constexpr _Swallow_assign ignore{};\n\n  /// Partial specialization for tuples\n  template<typename... _Types, typename _Alloc>\n    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };\n\n  // See stl_pair.h...\n  template<class _T1, class _T2>\n    template<typename... _Args1, typename... _Args2>\n      inline\n      pair<_T1, _T2>::\n      pair(piecewise_construct_t,\n\t   tuple<_Args1...> __first, tuple<_Args2...> __second)\n      : pair(__first, __second,\n\t     typename _Build_index_tuple<sizeof...(_Args1)>::__type(),\n\t     typename _Build_index_tuple<sizeof...(_Args2)>::__type())\n      { }\n\n  template<class _T1, class _T2>\n    template<typename... _Args1, std::size_t... _Indexes1,\n             typename... _Args2, std::size_t... _Indexes2>\n      inline\n      pair<_T1, _T2>::\n      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,\n\t   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)\n      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),\n        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)\n      { }\n\n#if __cplusplus >= 201703L\n# define __cpp_lib_apply 201603\n\n  template <typename _Fn, typename _Tuple, size_t... _Idx>\n    constexpr decltype(auto)\n    __apply_impl(_Fn&& __f, _Tuple&& __t, index_sequence<_Idx...>)\n    {\n      return std::__invoke(std::forward<_Fn>(__f),\n\t\t\t   std::get<_Idx>(std::forward<_Tuple>(__t))...);\n    }\n\n  template <typename _Fn, typename _Tuple>\n    constexpr decltype(auto)\n    apply(_Fn&& __f, _Tuple&& __t)\n    {\n      using _Indices\n\t= make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;\n      return std::__apply_impl(std::forward<_Fn>(__f),\n\t\t\t       std::forward<_Tuple>(__t),\n\t\t\t       _Indices{});\n    }\n\n#define __cpp_lib_make_from_tuple  201606\n\n  template <typename _Tp, typename _Tuple, size_t... _Idx>\n    constexpr _Tp\n    __make_from_tuple_impl(_Tuple&& __t, index_sequence<_Idx...>)\n    { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }\n\n  template <typename _Tp, typename _Tuple>\n    constexpr _Tp\n    make_from_tuple(_Tuple&& __t)\n    {\n      return __make_from_tuple_impl<_Tp>(\n        std::forward<_Tuple>(__t),\n\tmake_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});\n    }\n#endif // C++17\n\n  /// @}\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif // C++11\n\n#endif // _GLIBCXX_TUPLE\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used argument matchers.  More\n// matchers can be defined by the user implementing the\n// MatcherInterface<T> interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n\n#include <math.h>\n#include <algorithm>\n#include <iterator>\n#include <limits>\n#include <ostream>  // NOLINT\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n# include <initializer_list>  // NOLINT -- must be after gtest.h\n#endif\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherImpl that implements the\n//      MatcherInterface<T> interface, and\n//   2. a factory function that creates a Matcher<T> object from a\n//      FooMatcherImpl*.\n//\n// The two-level delegation design makes it possible to allow a user\n// to write \"v\" instead of \"Eq(v)\" where a Matcher is expected, which\n// is impossible if we pass matchers by pointers.  It also eases\n// ownership management as Matcher objects can now be copied like\n// plain values.\n\n// MatchResultListener is an abstract class.  Its << operator can be\n// used by a matcher to explain why a value matches or doesn't match.\n//\n// TODO(wan@google.com): add method\n//   bool InterestedInWhy(bool result) const;\n// to indicate whether the listener is interested in why the match\n// result is 'result'.\nclass MatchResultListener {\n public:\n  // Creates a listener object with the given underlying ostream.  The\n  // listener does not own the ostream, and does not dereference it\n  // in the constructor or destructor.\n  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}\n  virtual ~MatchResultListener() = 0;  // Makes this class abstract.\n\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template <typename T>\n  MatchResultListener& operator<<(const T& x) {\n    if (stream_ != NULL)\n      *stream_ << x;\n    return *this;\n  }\n\n  // Returns the underlying ostream.\n  ::std::ostream* stream() { return stream_; }\n\n  // Returns true iff the listener is interested in an explanation of\n  // the match result.  A matcher's MatchAndExplain() method can use\n  // this information to avoid generating the explanation when no one\n  // intends to hear it.\n  bool IsInterested() const { return stream_ != NULL; }\n\n private:\n  ::std::ostream* const stream_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);\n};\n\ninline MatchResultListener::~MatchResultListener() {\n}\n\n// An instance of a subclass of this knows how to describe itself as a\n// matcher.\nclass MatcherDescriberInterface {\n public:\n  virtual ~MatcherDescriberInterface() {}\n\n  // Describes this matcher to an ostream.  The function should print\n  // a verb phrase that describes the property a value matching this\n  // matcher should have.  The subject of the verb phrase is the value\n  // being matched.  For example, the DescribeTo() method of the Gt(7)\n  // matcher prints \"is greater than 7\".\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.  For\n  // example, if the description of this matcher is \"is greater than\n  // 7\", the negated description could be \"is not greater than 7\".\n  // You are not required to override this when implementing\n  // MatcherInterface, but it is highly advised so that your matcher\n  // can produce good error messages.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"not (\";\n    DescribeTo(os);\n    *os << \")\";\n  }\n};\n\n// The implementation of a matcher.\ntemplate <typename T>\nclass MatcherInterface : public MatcherDescriberInterface {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener' if necessary (see the next paragraph), in\n  // the form of a non-restrictive relative clause (\"which ...\",\n  // \"whose ...\", etc) that describes x.  For example, the\n  // MatchAndExplain() method of the Pointee(...) matcher should\n  // generate an explanation like \"which points to ...\".\n  //\n  // Implementations of MatchAndExplain() should add an explanation of\n  // the match result *if and only if* they can provide additional\n  // information that's not already present (or not obvious) in the\n  // print-out of x and the matcher's description.  Whether the match\n  // succeeds is not a factor in deciding whether an explanation is\n  // needed, as sometimes the caller needs to print a failure message\n  // when the match succeeds (e.g. when the matcher is used inside\n  // Not()).\n  //\n  // For example, a \"has at least 10 elements\" matcher should explain\n  // what the actual element count is, regardless of the match result,\n  // as it is useful information to the reader; on the other hand, an\n  // \"is empty\" matcher probably only needs to explain what the actual\n  // size is when the match fails, as it's redundant to say that the\n  // size is 0 when the value is already known to be empty.\n  //\n  // You should override this method when defining a new matcher.\n  //\n  // It's the responsibility of the caller (Google Mock) to guarantee\n  // that 'listener' is not NULL.  This helps to simplify a matcher's\n  // implementation when it doesn't care about the performance, as it\n  // can talk to 'listener' without checking its validity first.\n  // However, in order to implement dummy listeners efficiently,\n  // listener->stream() may be NULL.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Inherits these methods from MatcherDescriberInterface:\n  //   virtual void DescribeTo(::std::ostream* os) const = 0;\n  //   virtual void DescribeNegationTo(::std::ostream* os) const;\n};\n\n// A match result listener that stores the explanation in a string.\nclass StringMatchResultListener : public MatchResultListener {\n public:\n  StringMatchResultListener() : MatchResultListener(&ss_) {}\n\n  // Returns the explanation accumulated so far.\n  internal::string str() const { return ss_.str(); }\n\n  // Clears the explanation accumulated so far.\n  void Clear() { ss_.str(\"\"); }\n\n private:\n  ::std::stringstream ss_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);\n};\n\nnamespace internal {\n\nstruct AnyEq {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a == b; }\n};\nstruct AnyNe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a != b; }\n};\nstruct AnyLt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a < b; }\n};\nstruct AnyGt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a > b; }\n};\nstruct AnyLe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a <= b; }\n};\nstruct AnyGe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a >= b; }\n};\n\n// A match result listener that ignores the explanation.\nclass DummyMatchResultListener : public MatchResultListener {\n public:\n  DummyMatchResultListener() : MatchResultListener(NULL) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);\n};\n\n// A match result listener that forwards the explanation to a given\n// ostream.  The difference between this and MatchResultListener is\n// that the former is concrete.\nclass StreamMatchResultListener : public MatchResultListener {\n public:\n  explicit StreamMatchResultListener(::std::ostream* os)\n      : MatchResultListener(os) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);\n};\n\n// An internal class for implementing Matcher<T>, which will derive\n// from it.  We put functionalities common to all Matcher<T>\n// specializations here to avoid code duplication.\ntemplate <typename T>\nclass MatcherBase {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener'.\n  bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return impl_->MatchAndExplain(x, listener);\n  }\n\n  // Returns true iff this matcher matches x.\n  bool Matches(T x) const {\n    DummyMatchResultListener dummy;\n    return MatchAndExplain(x, &dummy);\n  }\n\n  // Describes this matcher to an ostream.\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the negation of this matcher to an ostream.\n  void DescribeNegationTo(::std::ostream* os) const {\n    impl_->DescribeNegationTo(os);\n  }\n\n  // Explains why x matches, or doesn't match, the matcher.\n  void ExplainMatchResultTo(T x, ::std::ostream* os) const {\n    StreamMatchResultListener listener(os);\n    MatchAndExplain(x, &listener);\n  }\n\n  // Returns the describer for this matcher object; retains ownership\n  // of the describer, which is only guaranteed to be alive when\n  // this matcher object is alive.\n  const MatcherDescriberInterface* GetDescriber() const {\n    return impl_.get();\n  }\n\n protected:\n  MatcherBase() {}\n\n  // Constructs a matcher from its implementation.\n  explicit MatcherBase(const MatcherInterface<T>* impl)\n      : impl_(impl) {}\n\n  virtual ~MatcherBase() {}\n\n private:\n  // shared_ptr (util/gtl/shared_ptr.h) and linked_ptr have similar\n  // interfaces.  The former dynamically allocates a chunk of memory\n  // to hold the reference count, while the latter tracks all\n  // references using a circular linked list without allocating\n  // memory.  It has been observed that linked_ptr performs better in\n  // typical scenarios.  However, shared_ptr can out-perform\n  // linked_ptr when there are many more uses of the copy constructor\n  // than the default constructor.\n  //\n  // If performance becomes a problem, we should see if using\n  // shared_ptr helps.\n  ::testing::internal::linked_ptr<const MatcherInterface<T> > impl_;\n};\n\n}  // namespace internal\n\n// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)\n// object that can check whether a value of type T matches.  The\n// implementation of Matcher<T> is just a linked_ptr to const\n// MatcherInterface<T>, so copying is fairly cheap.  Don't inherit\n// from Matcher!\ntemplate <typename T>\nclass Matcher : public internal::MatcherBase<T> {\n public:\n  // Constructs a null matcher.  Needed for storing Matcher objects in STL\n  // containers.  A default-constructed matcher is not yet initialized.  You\n  // cannot use it until a valid value has been assigned to it.\n  explicit Matcher() {}  // NOLINT\n\n  // Constructs a matcher from its implementation.\n  explicit Matcher(const MatcherInterface<T>* impl)\n      : internal::MatcherBase<T>(impl) {}\n\n  // Implicit constructor here allows people to write\n  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes\n  Matcher(T value);  // NOLINT\n};\n\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a string\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const internal::string&>\n    : public internal::MatcherBase<const internal::string&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const internal::string&>* impl)\n      : internal::MatcherBase<const internal::string&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<internal::string>\n    : public internal::MatcherBase<internal::string> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<internal::string>* impl)\n      : internal::MatcherBase<internal::string>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\n#if GTEST_HAS_STRING_PIECE_\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a StringPiece\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const StringPiece&>\n    : public internal::MatcherBase<const StringPiece&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const StringPiece&>* impl)\n      : internal::MatcherBase<const StringPiece&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<StringPiece>\n    : public internal::MatcherBase<StringPiece> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<StringPiece>* impl)\n      : internal::MatcherBase<StringPiece>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n#endif  // GTEST_HAS_STRING_PIECE_\n\n// The PolymorphicMatcher class template makes it easy to implement a\n// polymorphic matcher (i.e. a matcher that can match values of more\n// than one type, e.g. Eq(n) and NotNull()).\n//\n// To define a polymorphic matcher, a user should provide an Impl\n// class that has a DescribeTo() method and a DescribeNegationTo()\n// method, and define a member function (or member function template)\n//\n//   bool MatchAndExplain(const Value& value,\n//                        MatchResultListener* listener) const;\n//\n// See the definition of NotNull() for a complete example.\ntemplate <class Impl>\nclass PolymorphicMatcher {\n public:\n  explicit PolymorphicMatcher(const Impl& an_impl) : impl_(an_impl) {}\n\n  // Returns a mutable reference to the underlying matcher\n  // implementation object.\n  Impl& mutable_impl() { return impl_; }\n\n  // Returns an immutable reference to the underlying matcher\n  // implementation object.\n  const Impl& impl() const { return impl_; }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new MonomorphicImpl<T>(impl_));\n  }\n\n private:\n  template <typename T>\n  class MonomorphicImpl : public MatcherInterface<T> {\n   public:\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      impl_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      impl_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return impl_.MatchAndExplain(x, listener);\n    }\n\n   private:\n    const Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);\n};\n\n// Creates a matcher from its implementation.  This is easier to use\n// than the Matcher<T> constructor as it doesn't require you to\n// explicitly write the template argument, e.g.\n//\n//   MakeMatcher(foo);\n// vs\n//   Matcher<const string&>(foo);\ntemplate <typename T>\ninline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {\n  return Matcher<T>(impl);\n}\n\n// Creates a polymorphic matcher from its implementation.  This is\n// easier to use than the PolymorphicMatcher<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicMatcher(foo);\n// vs\n//   PolymorphicMatcher<TypeOfFoo>(foo);\ntemplate <class Impl>\ninline PolymorphicMatcher<Impl> MakePolymorphicMatcher(const Impl& impl) {\n  return PolymorphicMatcher<Impl>(impl);\n}\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// The MatcherCastImpl class template is a helper for implementing\n// MatcherCast().  We need this helper in order to partially\n// specialize the implementation of MatcherCast() (C++ allows\n// class/struct templates to be partially specialized, but not\n// function templates.).\n\n// This general version is used when MatcherCast()'s argument is a\n// polymorphic matcher (i.e. something that can be converted to a\n// Matcher but is not one yet; for example, Eq(value)) or a value (for\n// example, \"hello\").\ntemplate <typename T, typename M>\nclass MatcherCastImpl {\n public:\n  static Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    // M can be a polymorhic matcher, in which case we want to use\n    // its conversion operator to create Matcher<T>.  Or it can be a value\n    // that should be passed to the Matcher<T>'s constructor.\n    //\n    // We can't call Matcher<T>(polymorphic_matcher_or_value) when M is a\n    // polymorphic matcher because it'll be ambiguous if T has an implicit\n    // constructor from M (this usually happens when T has an implicit\n    // constructor from any type).\n    //\n    // It won't work to unconditionally implict_cast\n    // polymorphic_matcher_or_value to Matcher<T> because it won't trigger\n    // a user-defined conversion from M to T if one exists (assuming M is\n    // a value).\n    return CastImpl(\n        polymorphic_matcher_or_value,\n        BooleanConstant<\n            internal::ImplicitlyConvertible<M, Matcher<T> >::value>());\n  }\n\n private:\n  static Matcher<T> CastImpl(const M& value, BooleanConstant<false>) {\n    // M can't be implicitly converted to Matcher<T>, so M isn't a polymorphic\n    // matcher.  It must be a value then.  Use direct initialization to create\n    // a matcher.\n    return Matcher<T>(ImplicitCast_<T>(value));\n  }\n\n  static Matcher<T> CastImpl(const M& polymorphic_matcher_or_value,\n                             BooleanConstant<true>) {\n    // M is implicitly convertible to Matcher<T>, which means that either\n    // M is a polymorhpic matcher or Matcher<T> has an implicit constructor\n    // from M.  In both cases using the implicit conversion will produce a\n    // matcher.\n    //\n    // Even if T has an implicit constructor from M, it won't be called because\n    // creating Matcher<T> would require a chain of two user-defined conversions\n    // (first to create T from M and then to create Matcher<T> from T).\n    return polymorphic_matcher_or_value;\n  }\n};\n\n// This more specialized version is used when MatcherCast()'s argument\n// is already a Matcher.  This only compiles when type T can be\n// statically converted to type U.\ntemplate <typename T, typename U>\nclass MatcherCastImpl<T, Matcher<U> > {\n public:\n  static Matcher<T> Cast(const Matcher<U>& source_matcher) {\n    return Matcher<T>(new Impl(source_matcher));\n  }\n\n private:\n  class Impl : public MatcherInterface<T> {\n   public:\n    explicit Impl(const Matcher<U>& source_matcher)\n        : source_matcher_(source_matcher) {}\n\n    // We delegate the matching logic to the source matcher.\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return source_matcher_.MatchAndExplain(static_cast<U>(x), listener);\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      source_matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      source_matcher_.DescribeNegationTo(os);\n    }\n\n   private:\n    const Matcher<U> source_matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n};\n\n// This even more specialized version is used for efficiently casting\n// a matcher to its own type.\ntemplate <typename T>\nclass MatcherCastImpl<T, Matcher<T> > {\n public:\n  static Matcher<T> Cast(const Matcher<T>& matcher) { return matcher; }\n};\n\n}  // namespace internal\n\n// In order to be safe and clear, casting between different matcher\n// types is done explicitly via MatcherCast<T>(m), which takes a\n// matcher m and returns a Matcher<T>.  It compiles only when T can be\n// statically converted to the argument type of m.\ntemplate <typename T, typename M>\ninline Matcher<T> MatcherCast(const M& matcher) {\n  return internal::MatcherCastImpl<T, M>::Cast(matcher);\n}\n\n// Implements SafeMatcherCast().\n//\n// We use an intermediate class to do the actual safe casting as Nokia's\n// Symbian compiler cannot decide between\n// template <T, M> ... (M) and\n// template <T, U> ... (const Matcher<U>&)\n// for function templates but can for member function templates.\ntemplate <typename T>\nclass SafeMatcherCastImpl {\n public:\n  // This overload handles polymorphic matchers and values only since\n  // monomorphic matchers are handled by the next one.\n  template <typename M>\n  static inline Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    return internal::MatcherCastImpl<T, M>::Cast(polymorphic_matcher_or_value);\n  }\n\n  // This overload handles monomorphic matchers.\n  //\n  // In general, if type T can be implicitly converted to type U, we can\n  // safely convert a Matcher<U> to a Matcher<T> (i.e. Matcher is\n  // contravariant): just keep a copy of the original Matcher<U>, convert the\n  // argument from type T to U, and then pass it to the underlying Matcher<U>.\n  // The only exception is when U is a reference and T is not, as the\n  // underlying Matcher<U> may be interested in the argument's address, which\n  // is not preserved in the conversion from T to U.\n  template <typename U>\n  static inline Matcher<T> Cast(const Matcher<U>& matcher) {\n    // Enforce that T can be implicitly converted to U.\n    GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible<T, U>::value),\n                          T_must_be_implicitly_convertible_to_U);\n    // Enforce that we are not converting a non-reference type T to a reference\n    // type U.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<T>::value || !internal::is_reference<U>::value,\n        cannot_convert_non_referentce_arg_to_reference);\n    // In case both T and U are arithmetic types, enforce that the\n    // conversion is not lossy.\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;\n    const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;\n    const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;\n    GTEST_COMPILE_ASSERT_(\n        kTIsOther || kUIsOther ||\n        (internal::LosslessArithmeticConvertible<RawT, RawU>::value),\n        conversion_of_arithmetic_types_must_be_lossless);\n    return MatcherCast<T>(matcher);\n  }\n};\n\ntemplate <typename T, typename M>\ninline Matcher<T> SafeMatcherCast(const M& polymorphic_matcher) {\n  return SafeMatcherCastImpl<T>::Cast(polymorphic_matcher);\n}\n\n// A<T>() returns a matcher that matches any value of type T.\ntemplate <typename T>\nMatcher<T> A();\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// If the explanation is not empty, prints it to the ostream.\ninline void PrintIfNotEmpty(const internal::string& explanation,\n                            ::std::ostream* os) {\n  if (explanation != \"\" && os != NULL) {\n    *os << \", \" << explanation;\n  }\n}\n\n// Returns true if the given type name is easy to read by a human.\n// This is used to decide whether printing the type of a value might\n// be helpful.\ninline bool IsReadableTypeName(const string& type_name) {\n  // We consider a type name readable if it's short or doesn't contain\n  // a template or function type.\n  return (type_name.length() <= 20 ||\n          type_name.find_first_of(\"<(\") == string::npos);\n}\n\n// Matches the value against the given matcher, prints the value and explains\n// the match result to the listener. Returns the match result.\n// 'listener' must not be NULL.\n// Value cannot be passed by const reference, because some matchers take a\n// non-const argument.\ntemplate <typename Value, typename T>\nbool MatchPrintAndExplain(Value& value, const Matcher<T>& matcher,\n                          MatchResultListener* listener) {\n  if (!listener->IsInterested()) {\n    // If the listener is not interested, we do not need to construct the\n    // inner explanation.\n    return matcher.Matches(value);\n  }\n\n  StringMatchResultListener inner_listener;\n  const bool match = matcher.MatchAndExplain(value, &inner_listener);\n\n  UniversalPrint(value, listener->stream());\n#if GTEST_HAS_RTTI\n  const string& type_name = GetTypeName<Value>();\n  if (IsReadableTypeName(type_name))\n    *listener->stream() << \" (of type \" << type_name << \")\";\n#endif\n  PrintIfNotEmpty(inner_listener.str(), listener->stream());\n\n  return match;\n}\n\n// An internal helper class for doing compile-time loop on a tuple's\n// fields.\ntemplate <size_t N>\nclass TuplePrefix {\n public:\n  // TuplePrefix<N>::Matches(matcher_tuple, value_tuple) returns true\n  // iff the first N fields of matcher_tuple matches the first N\n  // fields of value_tuple, respectively.\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& matcher_tuple,\n                      const ValueTuple& value_tuple) {\n    return TuplePrefix<N - 1>::Matches(matcher_tuple, value_tuple)\n        && get<N - 1>(matcher_tuple).Matches(get<N - 1>(value_tuple));\n  }\n\n  // TuplePrefix<N>::ExplainMatchFailuresTo(matchers, values, os)\n  // describes failures in matching the first N fields of matchers\n  // against the first N fields of values.  If there is no failure,\n  // nothing will be streamed to os.\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& matchers,\n                                     const ValueTuple& values,\n                                     ::std::ostream* os) {\n    // First, describes failures in the first N - 1 fields.\n    TuplePrefix<N - 1>::ExplainMatchFailuresTo(matchers, values, os);\n\n    // Then describes the failure (if any) in the (N - 1)-th (0-based)\n    // field.\n    typename tuple_element<N - 1, MatcherTuple>::type matcher =\n        get<N - 1>(matchers);\n    typedef typename tuple_element<N - 1, ValueTuple>::type Value;\n    Value value = get<N - 1>(values);\n    StringMatchResultListener listener;\n    if (!matcher.MatchAndExplain(value, &listener)) {\n      // TODO(wan): include in the message the name of the parameter\n      // as used in MOCK_METHOD*() when possible.\n      *os << \"  Expected arg #\" << N - 1 << \": \";\n      get<N - 1>(matchers).DescribeTo(os);\n      *os << \"\\n           Actual: \";\n      // We remove the reference in type Value to prevent the\n      // universal printer from printing the address of value, which\n      // isn't interesting to the user most of the time.  The\n      // matcher's MatchAndExplain() method handles the case when\n      // the address is interesting.\n      internal::UniversalPrint(value, os);\n      PrintIfNotEmpty(listener.str(), os);\n      *os << \"\\n\";\n    }\n  }\n};\n\n// The base case.\ntemplate <>\nclass TuplePrefix<0> {\n public:\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& /* matcher_tuple */,\n                      const ValueTuple& /* value_tuple */) {\n    return true;\n  }\n\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& /* matchers */,\n                                     const ValueTuple& /* values */,\n                                     ::std::ostream* /* os */) {}\n};\n\n// TupleMatches(matcher_tuple, value_tuple) returns true iff all\n// matchers in matcher_tuple match the corresponding fields in\n// value_tuple.  It is a compiler error if matcher_tuple and\n// value_tuple have different number of fields or incompatible field\n// types.\ntemplate <typename MatcherTuple, typename ValueTuple>\nbool TupleMatches(const MatcherTuple& matcher_tuple,\n                  const ValueTuple& value_tuple) {\n  // Makes sure that matcher_tuple and value_tuple have the same\n  // number of fields.\n  GTEST_COMPILE_ASSERT_(tuple_size<MatcherTuple>::value ==\n                        tuple_size<ValueTuple>::value,\n                        matcher_and_value_have_different_numbers_of_fields);\n  return TuplePrefix<tuple_size<ValueTuple>::value>::\n      Matches(matcher_tuple, value_tuple);\n}\n\n// Describes failures in matching matchers against values.  If there\n// is no failure, nothing will be streamed to os.\ntemplate <typename MatcherTuple, typename ValueTuple>\nvoid ExplainMatchFailureTupleTo(const MatcherTuple& matchers,\n                                const ValueTuple& values,\n                                ::std::ostream* os) {\n  TuplePrefix<tuple_size<MatcherTuple>::value>::ExplainMatchFailuresTo(\n      matchers, values, os);\n}\n\n// TransformTupleValues and its helper.\n//\n// TransformTupleValuesHelper hides the internal machinery that\n// TransformTupleValues uses to implement a tuple traversal.\ntemplate <typename Tuple, typename Func, typename OutIter>\nclass TransformTupleValuesHelper {\n private:\n  typedef ::testing::tuple_size<Tuple> TupleSize;\n\n public:\n  // For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.\n  // Returns the final value of 'out' in case the caller needs it.\n  static OutIter Run(Func f, const Tuple& t, OutIter out) {\n    return IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);\n  }\n\n private:\n  template <typename Tup, size_t kRemainingSize>\n  struct IterateOverTuple {\n    OutIter operator() (Func f, const Tup& t, OutIter out) const {\n      *out++ = f(::testing::get<TupleSize::value - kRemainingSize>(t));\n      return IterateOverTuple<Tup, kRemainingSize - 1>()(f, t, out);\n    }\n  };\n  template <typename Tup>\n  struct IterateOverTuple<Tup, 0> {\n    OutIter operator() (Func /* f */, const Tup& /* t */, OutIter out) const {\n      return out;\n    }\n  };\n};\n\n// Successively invokes 'f(element)' on each element of the tuple 't',\n// appending each result to the 'out' iterator. Returns the final value\n// of 'out'.\ntemplate <typename Tuple, typename Func, typename OutIter>\nOutIter TransformTupleValues(Func f, const Tuple& t, OutIter out) {\n  return TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(f, t, out);\n}\n\n// Implements A<T>().\ntemplate <typename T>\nclass AnyMatcherImpl : public MatcherInterface<T> {\n public:\n  virtual bool MatchAndExplain(\n      T /* x */, MatchResultListener* /* listener */) const { return true; }\n  virtual void DescribeTo(::std::ostream* os) const { *os << \"is anything\"; }\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    // This is mostly for completeness' safe, as it's not very useful\n    // to write Not(A<bool>()).  However we cannot completely rule out\n    // such a possibility, and it doesn't hurt to be prepared.\n    *os << \"never matches\";\n  }\n};\n\n// Implements _, a matcher that matches any value of any\n// type.  This is a polymorphic matcher, so we need a template type\n// conversion operator to make it appearing as a Matcher<T> for any\n// type T.\nclass AnythingMatcher {\n public:\n  template <typename T>\n  operator Matcher<T>() const { return A<T>(); }\n};\n\n// Implements a matcher that compares a given value with a\n// pre-supplied value using one of the ==, <=, <, etc, operators.  The\n// two values being compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq(5) can be\n// used to match an int, a short, a double, etc).  Therefore we use\n// a template type conversion operator in the implementation.\n//\n// The following template definition assumes that the Rhs parameter is\n// a \"bare\" type (i.e. neither 'const T' nor 'T&').\ntemplate <typename D, typename Rhs, typename Op>\nclass ComparisonBase {\n public:\n  explicit ComparisonBase(const Rhs& rhs) : rhs_(rhs) {}\n  template <typename Lhs>\n  operator Matcher<Lhs>() const {\n    return MakeMatcher(new Impl<Lhs>(rhs_));\n  }\n\n private:\n  template <typename Lhs>\n  class Impl : public MatcherInterface<Lhs> {\n   public:\n    explicit Impl(const Rhs& rhs) : rhs_(rhs) {}\n    virtual bool MatchAndExplain(\n        Lhs lhs, MatchResultListener* /* listener */) const {\n      return Op()(lhs, rhs_);\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << D::Desc() << \" \";\n      UniversalPrint(rhs_, os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << D::NegatedDesc() <<  \" \";\n      UniversalPrint(rhs_, os);\n    }\n   private:\n    Rhs rhs_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n  Rhs rhs_;\n  GTEST_DISALLOW_ASSIGN_(ComparisonBase);\n};\n\ntemplate <typename Rhs>\nclass EqMatcher : public ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq> {\n public:\n  explicit EqMatcher(const Rhs& rhs)\n      : ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq>(rhs) { }\n  static const char* Desc() { return \"is equal to\"; }\n  static const char* NegatedDesc() { return \"isn't equal to\"; }\n};\ntemplate <typename Rhs>\nclass NeMatcher : public ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe> {\n public:\n  explicit NeMatcher(const Rhs& rhs)\n      : ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe>(rhs) { }\n  static const char* Desc() { return \"isn't equal to\"; }\n  static const char* NegatedDesc() { return \"is equal to\"; }\n};\ntemplate <typename Rhs>\nclass LtMatcher : public ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt> {\n public:\n  explicit LtMatcher(const Rhs& rhs)\n      : ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt>(rhs) { }\n  static const char* Desc() { return \"is <\"; }\n  static const char* NegatedDesc() { return \"isn't <\"; }\n};\ntemplate <typename Rhs>\nclass GtMatcher : public ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt> {\n public:\n  explicit GtMatcher(const Rhs& rhs)\n      : ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt>(rhs) { }\n  static const char* Desc() { return \"is >\"; }\n  static const char* NegatedDesc() { return \"isn't >\"; }\n};\ntemplate <typename Rhs>\nclass LeMatcher : public ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe> {\n public:\n  explicit LeMatcher(const Rhs& rhs)\n      : ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe>(rhs) { }\n  static const char* Desc() { return \"is <=\"; }\n  static const char* NegatedDesc() { return \"isn't <=\"; }\n};\ntemplate <typename Rhs>\nclass GeMatcher : public ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe> {\n public:\n  explicit GeMatcher(const Rhs& rhs)\n      : ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe>(rhs) { }\n  static const char* Desc() { return \"is >=\"; }\n  static const char* NegatedDesc() { return \"isn't >=\"; }\n};\n\n// Implements the polymorphic IsNull() matcher, which matches any raw or smart\n// pointer that is NULL.\nclass IsNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p == nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) == NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"is NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"isn't NULL\";\n  }\n};\n\n// Implements the polymorphic NotNull() matcher, which matches any raw or smart\n// pointer that is not NULL.\nclass NotNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p != nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) != NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"isn't NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is NULL\";\n  }\n};\n\n// Ref(variable) matches any argument that is a reference to\n// 'variable'.  This matcher is polymorphic as it can match any\n// super type of the type of 'variable'.\n//\n// The RefMatcher template class implements Ref(variable).  It can\n// only be instantiated with a reference type.  This prevents a user\n// from mistakenly using Ref(x) to match a non-reference function\n// argument.  For example, the following will righteously cause a\n// compiler error:\n//\n//   int n;\n//   Matcher<int> m1 = Ref(n);   // This won't compile.\n//   Matcher<int&> m2 = Ref(n);  // This will compile.\ntemplate <typename T>\nclass RefMatcher;\n\ntemplate <typename T>\nclass RefMatcher<T&> {\n  // Google Mock is a generic framework and thus needs to support\n  // mocking any function types, including those that take non-const\n  // reference arguments.  Therefore the template parameter T (and\n  // Super below) can be instantiated to either a const type or a\n  // non-const type.\n public:\n  // RefMatcher() takes a T& instead of const T&, as we want the\n  // compiler to catch using Ref(const_value) as a matcher for a\n  // non-const reference.\n  explicit RefMatcher(T& x) : object_(x) {}  // NOLINT\n\n  template <typename Super>\n  operator Matcher<Super&>() const {\n    // By passing object_ (type T&) to Impl(), which expects a Super&,\n    // we make sure that Super is a super type of T.  In particular,\n    // this catches using Ref(const_value) as a matcher for a\n    // non-const reference, as you cannot implicitly convert a const\n    // reference to a non-const reference.\n    return MakeMatcher(new Impl<Super>(object_));\n  }\n\n private:\n  template <typename Super>\n  class Impl : public MatcherInterface<Super&> {\n   public:\n    explicit Impl(Super& x) : object_(x) {}  // NOLINT\n\n    // MatchAndExplain() takes a Super& (as opposed to const Super&)\n    // in order to match the interface MatcherInterface<Super&>.\n    virtual bool MatchAndExplain(\n        Super& x, MatchResultListener* listener) const {\n      *listener << \"which is located @\" << static_cast<const void*>(&x);\n      return &x == &object_;\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"references the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not reference the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n   private:\n    const Super& object_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& object_;\n\n  GTEST_DISALLOW_ASSIGN_(RefMatcher);\n};\n\n// Polymorphic helper functions for narrow and wide string matchers.\ninline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  return String::CaseInsensitiveCStringEquals(lhs, rhs);\n}\n\ninline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,\n                                         const wchar_t* rhs) {\n  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);\n}\n\n// String comparison for narrow or wide strings that can have embedded NUL\n// characters.\ntemplate <typename StringType>\nbool CaseInsensitiveStringEquals(const StringType& s1,\n                                 const StringType& s2) {\n  // Are the heads equal?\n  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {\n    return false;\n  }\n\n  // Skip the equal heads.\n  const typename StringType::value_type nul = 0;\n  const size_t i1 = s1.find(nul), i2 = s2.find(nul);\n\n  // Are we at the end of either s1 or s2?\n  if (i1 == StringType::npos || i2 == StringType::npos) {\n    return i1 == i2;\n  }\n\n  // Are the tails equal?\n  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));\n}\n\n// String matchers.\n\n// Implements equality-based string matchers like StrEq, StrCaseNe, and etc.\ntemplate <typename StringType>\nclass StrEqualityMatcher {\n public:\n  StrEqualityMatcher(const StringType& str, bool expect_eq,\n                     bool case_sensitive)\n      : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    if (s == NULL) {\n      return !expect_eq_;\n    }\n    return MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    const bool eq = case_sensitive_ ? s2 == string_ :\n        CaseInsensitiveStringEquals(s2, string_);\n    return expect_eq_ == eq;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    DescribeToHelper(expect_eq_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    DescribeToHelper(!expect_eq_, os);\n  }\n\n private:\n  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {\n    *os << (expect_eq ? \"is \" : \"isn't \");\n    *os << \"equal to \";\n    if (!case_sensitive_) {\n      *os << \"(ignoring case) \";\n    }\n    UniversalPrint(string_, os);\n  }\n\n  const StringType string_;\n  const bool expect_eq_;\n  const bool case_sensitive_;\n\n  GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);\n};\n\n// Implements the polymorphic HasSubstr(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass HasSubstrMatcher {\n public:\n  explicit HasSubstrMatcher(const StringType& substring)\n      : substring_(substring) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.find(substring_) != StringType::npos;\n  }\n\n  // Describes what this matcher matches.\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"has substring \";\n    UniversalPrint(substring_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has no substring \";\n    UniversalPrint(substring_, os);\n  }\n\n private:\n  const StringType substring_;\n\n  GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);\n};\n\n// Implements the polymorphic StartsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass StartsWithMatcher {\n public:\n  explicit StartsWithMatcher(const StringType& prefix) : prefix_(prefix) {\n  }\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= prefix_.length() &&\n        s2.substr(0, prefix_.length()) == prefix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"starts with \";\n    UniversalPrint(prefix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't start with \";\n    UniversalPrint(prefix_, os);\n  }\n\n private:\n  const StringType prefix_;\n\n  GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);\n};\n\n// Implements the polymorphic EndsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass EndsWithMatcher {\n public:\n  explicit EndsWithMatcher(const StringType& suffix) : suffix_(suffix) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= suffix_.length() &&\n        s2.substr(s2.length() - suffix_.length()) == suffix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"ends with \";\n    UniversalPrint(suffix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't end with \";\n    UniversalPrint(suffix_, os);\n  }\n\n private:\n  const StringType suffix_;\n\n  GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);\n};\n\n// Implements polymorphic matchers MatchesRegex(regex) and\n// ContainsRegex(regex), which can be used as a Matcher<T> as long as\n// T can be converted to a string.\nclass MatchesRegexMatcher {\n public:\n  MatchesRegexMatcher(const RE* regex, bool full_match)\n      : regex_(regex), full_match_(full_match) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(internal::string(s), listener);\n  }\n\n  // Matches anything that can convert to internal::string.\n  //\n  // This is a template, not just a plain function with const internal::string&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <class MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const internal::string& s2(s);\n    return full_match_ ? RE::FullMatch(s2, *regex_) :\n        RE::PartialMatch(s2, *regex_);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << (full_match_ ? \"matches\" : \"contains\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't \" << (full_match_ ? \"match\" : \"contain\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n private:\n  const internal::linked_ptr<const RE> regex_;\n  const bool full_match_;\n\n  GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);\n};\n\n// Implements a matcher that compares the two fields of a 2-tuple\n// using one of the ==, <=, <, etc, operators.  The two fields being\n// compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq() can be\n// used to match a tuple<int, short>, a tuple<const long&, double>,\n// etc).  Therefore we use a template type conversion operator in the\n// implementation.\ntemplate <typename D, typename Op>\nclass PairMatchBase {\n public:\n  template <typename T1, typename T2>\n  operator Matcher< ::testing::tuple<T1, T2> >() const {\n    return MakeMatcher(new Impl< ::testing::tuple<T1, T2> >);\n  }\n  template <typename T1, typename T2>\n  operator Matcher<const ::testing::tuple<T1, T2>&>() const {\n    return MakeMatcher(new Impl<const ::testing::tuple<T1, T2>&>);\n  }\n\n private:\n  static ::std::ostream& GetDesc(::std::ostream& os) {  // NOLINT\n    return os << D::Desc();\n  }\n\n  template <typename Tuple>\n  class Impl : public MatcherInterface<Tuple> {\n   public:\n    virtual bool MatchAndExplain(\n        Tuple args,\n        MatchResultListener* /* listener */) const {\n      return Op()(::testing::get<0>(args), ::testing::get<1>(args));\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"are \" << GetDesc;\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"aren't \" << GetDesc;\n    }\n  };\n};\n\nclass Eq2Matcher : public PairMatchBase<Eq2Matcher, AnyEq> {\n public:\n  static const char* Desc() { return \"an equal pair\"; }\n};\nclass Ne2Matcher : public PairMatchBase<Ne2Matcher, AnyNe> {\n public:\n  static const char* Desc() { return \"an unequal pair\"; }\n};\nclass Lt2Matcher : public PairMatchBase<Lt2Matcher, AnyLt> {\n public:\n  static const char* Desc() { return \"a pair where the first < the second\"; }\n};\nclass Gt2Matcher : public PairMatchBase<Gt2Matcher, AnyGt> {\n public:\n  static const char* Desc() { return \"a pair where the first > the second\"; }\n};\nclass Le2Matcher : public PairMatchBase<Le2Matcher, AnyLe> {\n public:\n  static const char* Desc() { return \"a pair where the first <= the second\"; }\n};\nclass Ge2Matcher : public PairMatchBase<Ge2Matcher, AnyGe> {\n public:\n  static const char* Desc() { return \"a pair where the first >= the second\"; }\n};\n\n// Implements the Not(...) matcher for a particular argument type T.\n// We do not nest it inside the NotMatcher class template, as that\n// will prevent different instantiations of NotMatcher from sharing\n// the same NotMatcherImpl<T> class.\ntemplate <typename T>\nclass NotMatcherImpl : public MatcherInterface<T> {\n public:\n  explicit NotMatcherImpl(const Matcher<T>& matcher)\n      : matcher_(matcher) {}\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return !matcher_.MatchAndExplain(x, listener);\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    matcher_.DescribeNegationTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<T> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);\n};\n\n// Implements the Not(m) matcher, which matches a value that doesn't\n// match matcher m.\ntemplate <typename InnerMatcher>\nclass NotMatcher {\n public:\n  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}\n\n  // This template type conversion operator allows Not(m) to be used\n  // to match any type m can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new NotMatcherImpl<T>(SafeMatcherCast<T>(matcher_)));\n  }\n\n private:\n  InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcher);\n};\n\n// Implements the AllOf(m1, m2) matcher for a particular argument type\n// T. We do not nest it inside the BothOfMatcher class template, as\n// that will prevent different instantiations of BothOfMatcher from\n// sharing the same BothOfMatcherImpl<T> class.\ntemplate <typename T>\nclass BothOfMatcherImpl : public MatcherInterface<T> {\n public:\n  BothOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ doesn't match x, we only need\n    // to explain why one of them fails.\n    StringMatchResultListener listener1;\n    if (!matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return false;\n    }\n\n    StringMatchResultListener listener2;\n    if (!matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return false;\n    }\n\n    // Otherwise we need to explain why *both* of them match.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return true;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// MatcherList provides mechanisms for storing a variable number of matchers in\n// a list structure (ListType) and creating a combining matcher from such a\n// list.\n// The template is defined recursively using the following template paramters:\n//   * kSize is the length of the MatcherList.\n//   * Head is the type of the first matcher of the list.\n//   * Tail denotes the types of the remaining matchers of the list.\ntemplate <int kSize, typename Head, typename... Tail>\nstruct MatcherList {\n  typedef MatcherList<kSize - 1, Tail...> MatcherListTail;\n  typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;\n\n  // BuildList stores variadic type values in a nested pair structure.\n  // Example:\n  // MatcherList<3, int, string, float>::BuildList(5, \"foo\", 2.0) will return\n  // the corresponding result of type pair<int, pair<string, float>>.\n  static ListType BuildList(const Head& matcher, const Tail&... tail) {\n    return ListType(matcher, MatcherListTail::BuildList(tail...));\n  }\n\n  // CreateMatcher<T> creates a Matcher<T> from a given list of matchers (built\n  // by BuildList()). CombiningMatcher<T> is used to combine the matchers of the\n  // list. CombiningMatcher<T> must implement MatcherInterface<T> and have a\n  // constructor taking two Matcher<T>s as input.\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        MatcherListTail::template CreateMatcher<T, CombiningMatcher>(\n            matchers.second)));\n  }\n};\n\n// The following defines the base case for the recursive definition of\n// MatcherList.\ntemplate <typename Matcher1, typename Matcher2>\nstruct MatcherList<2, Matcher1, Matcher2> {\n  typedef ::std::pair<Matcher1, Matcher2> ListType;\n\n  static ListType BuildList(const Matcher1& matcher1,\n                            const Matcher2& matcher2) {\n    return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);\n  }\n\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        SafeMatcherCast<T>(matchers.second)));\n  }\n};\n\n// VariadicMatcher is used for the variadic implementation of\n// AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).\n// CombiningMatcher<T> is used to recursively combine the provided matchers\n// (of type Args...).\ntemplate <template <typename T> class CombiningMatcher, typename... Args>\nclass VariadicMatcher {\n public:\n  VariadicMatcher(const Args&... matchers)  // NOLINT\n      : matchers_(MatcherListType::BuildList(matchers...)) {}\n\n  // This template type conversion operator allows an\n  // VariadicMatcher<Matcher1, Matcher2...> object to match any type that\n  // all of the provided matchers (Matcher1, Matcher2, ...) can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return MatcherListType::template CreateMatcher<T, CombiningMatcher>(\n        matchers_);\n  }\n\n private:\n  typedef MatcherList<sizeof...(Args), Args...> MatcherListType;\n\n  const typename MatcherListType::ListType matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(VariadicMatcher);\n};\n\ntemplate <typename... Args>\nusing AllOfMatcher = VariadicMatcher<BothOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AllOf(m_1, ..., m_n) matcher, which\n// matches a value that matches all of the matchers m_1, ..., and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass BothOfMatcher {\n public:\n  BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // BothOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new BothOfMatcherImpl<T>(SafeMatcherCast<T>(matcher1_),\n                                               SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcher);\n};\n\n// Implements the AnyOf(m1, m2) matcher for a particular argument type\n// T.  We do not nest it inside the AnyOfMatcher class template, as\n// that will prevent different instantiations of AnyOfMatcher from\n// sharing the same EitherOfMatcherImpl<T> class.\ntemplate <typename T>\nclass EitherOfMatcherImpl : public MatcherInterface<T> {\n public:\n  EitherOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ matches x, we just need to\n    // explain why *one* of them matches.\n    StringMatchResultListener listener1;\n    if (matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return true;\n    }\n\n    StringMatchResultListener listener2;\n    if (matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return true;\n    }\n\n    // Otherwise we need to explain why *both* of them fail.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return false;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).\ntemplate <typename... Args>\nusing AnyOfMatcher = VariadicMatcher<EitherOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AnyOf(m_1, ..., m_n) matcher, which\n// matches a value that matches at least one of the matchers m_1, ...,\n// and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass EitherOfMatcher {\n public:\n  EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // EitherOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new EitherOfMatcherImpl<T>(\n        SafeMatcherCast<T>(matcher1_), SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcher);\n};\n\n// Used for implementing Truly(pred), which turns a predicate into a\n// matcher.\ntemplate <typename Predicate>\nclass TrulyMatcher {\n public:\n  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}\n\n  // This method template allows Truly(pred) to be used as a matcher\n  // for type T where T is the argument type of predicate 'pred'.  The\n  // argument is passed by reference as the predicate may be\n  // interested in the address of the argument.\n  template <typename T>\n  bool MatchAndExplain(T& x,  // NOLINT\n                       MatchResultListener* /* listener */) const {\n    // Without the if-statement, MSVC sometimes warns about converting\n    // a value to bool (warning 4800).\n    //\n    // We cannot write 'return !!predicate_(x);' as that doesn't work\n    // when predicate_(x) returns a class convertible to bool but\n    // having no operator!().\n    if (predicate_(x))\n      return true;\n    return false;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"satisfies the given predicate\";\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't satisfy the given predicate\";\n  }\n\n private:\n  Predicate predicate_;\n\n  GTEST_DISALLOW_ASSIGN_(TrulyMatcher);\n};\n\n// Used for implementing Matches(matcher), which turns a matcher into\n// a predicate.\ntemplate <typename M>\nclass MatcherAsPredicate {\n public:\n  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}\n\n  // This template operator() allows Matches(m) to be used as a\n  // predicate on type T where m is a matcher on type T.\n  //\n  // The argument x is passed by reference instead of by value, as\n  // some matcher may be interested in its address (e.g. as in\n  // Matches(Ref(n))(x)).\n  template <typename T>\n  bool operator()(const T& x) const {\n    // We let matcher_ commit to a particular type here instead of\n    // when the MatcherAsPredicate object was constructed.  This\n    // allows us to write Matches(m) where m is a polymorphic matcher\n    // (e.g. Eq(5)).\n    //\n    // If we write Matcher<T>(matcher_).Matches(x) here, it won't\n    // compile when matcher_ has type Matcher<const T&>; if we write\n    // Matcher<const T&>(matcher_).Matches(x) here, it won't compile\n    // when matcher_ has type Matcher<T>; if we just write\n    // matcher_.Matches(x), it won't compile when matcher_ is\n    // polymorphic, e.g. Eq(5).\n    //\n    // MatcherCast<const T&>() is necessary for making the code work\n    // in all of the above situations.\n    return MatcherCast<const T&>(matcher_).Matches(x);\n  }\n\n private:\n  M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);\n};\n\n// For implementing ASSERT_THAT() and EXPECT_THAT().  The template\n// argument M must be a type that can be converted to a matcher.\ntemplate <typename M>\nclass PredicateFormatterFromMatcher {\n public:\n  explicit PredicateFormatterFromMatcher(M m) : matcher_(internal::move(m)) {}\n\n  // This template () operator allows a PredicateFormatterFromMatcher\n  // object to act as a predicate-formatter suitable for using with\n  // Google Test's EXPECT_PRED_FORMAT1() macro.\n  template <typename T>\n  AssertionResult operator()(const char* value_text, const T& x) const {\n    // We convert matcher_ to a Matcher<const T&> *now* instead of\n    // when the PredicateFormatterFromMatcher object was constructed,\n    // as matcher_ may be polymorphic (e.g. NotNull()) and we won't\n    // know which type to instantiate it to until we actually see the\n    // type of x here.\n    //\n    // We write SafeMatcherCast<const T&>(matcher_) instead of\n    // Matcher<const T&>(matcher_), as the latter won't compile when\n    // matcher_ has type Matcher<T> (e.g. An<int>()).\n    // We don't write MatcherCast<const T&> either, as that allows\n    // potentially unsafe downcasting of the matcher argument.\n    const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);\n    StringMatchResultListener listener;\n    if (MatchPrintAndExplain(x, matcher, &listener))\n      return AssertionSuccess();\n\n    ::std::stringstream ss;\n    ss << \"Value of: \" << value_text << \"\\n\"\n       << \"Expected: \";\n    matcher.DescribeTo(&ss);\n    ss << \"\\n  Actual: \" << listener.str();\n    return AssertionFailure() << ss.str();\n  }\n\n private:\n  const M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);\n};\n\n// A helper function for converting a matcher to a predicate-formatter\n// without the user needing to explicitly write the type.  This is\n// used for implementing ASSERT_THAT() and EXPECT_THAT().\n// Implementation detail: 'matcher' is received by-value to force decaying.\ntemplate <typename M>\ninline PredicateFormatterFromMatcher<M>\nMakePredicateFormatterFromMatcher(M matcher) {\n  return PredicateFormatterFromMatcher<M>(internal::move(matcher));\n}\n\n// Implements the polymorphic floating point equality matcher, which matches\n// two float values using ULP-based approximation or, optionally, a\n// user-specified epsilon.  The template is meant to be instantiated with\n// FloatType being either float or double.\ntemplate <typename FloatType>\nclass FloatingEqMatcher {\n public:\n  // Constructor for FloatingEqMatcher.\n  // The matcher's input will be compared with expected.  The matcher treats two\n  // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,\n  // equality comparisons between NANs will always return false.  We specify a\n  // negative max_abs_error_ term to indicate that ULP-based approximation will\n  // be used for comparison.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :\n    expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {\n  }\n\n  // Constructor that supports a user-specified max_abs_error that will be used\n  // for comparison instead of ULP-based approximation.  The max absolute\n  // should be non-negative.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,\n                    FloatType max_abs_error)\n      : expected_(expected),\n        nan_eq_nan_(nan_eq_nan),\n        max_abs_error_(max_abs_error) {\n    GTEST_CHECK_(max_abs_error >= 0)\n        << \", where max_abs_error is\" << max_abs_error;\n  }\n\n  // Implements floating point equality matcher as a Matcher<T>.\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)\n        : expected_(expected),\n          nan_eq_nan_(nan_eq_nan),\n          max_abs_error_(max_abs_error) {}\n\n    virtual bool MatchAndExplain(T value,\n                                 MatchResultListener* listener) const {\n      const FloatingPoint<FloatType> actual(value), expected(expected_);\n\n      // Compares NaNs first, if nan_eq_nan_ is true.\n      if (actual.is_nan() || expected.is_nan()) {\n        if (actual.is_nan() && expected.is_nan()) {\n          return nan_eq_nan_;\n        }\n        // One is nan; the other is not nan.\n        return false;\n      }\n      if (HasMaxAbsError()) {\n        // We perform an equality check so that inf will match inf, regardless\n        // of error bounds.  If the result of value - expected_ would result in\n        // overflow or if either value is inf, the default result is infinity,\n        // which should only match if max_abs_error_ is also infinity.\n        if (value == expected_) {\n          return true;\n        }\n\n        const FloatType diff = value - expected_;\n        if (fabs(diff) <= max_abs_error_) {\n          return true;\n        }\n\n        if (listener->IsInterested()) {\n          *listener << \"which is \" << diff << \" from \" << expected_;\n        }\n        return false;\n      } else {\n        return actual.AlmostEquals(expected);\n      }\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      // os->precision() returns the previously set precision, which we\n      // store to restore the ostream to its original configuration\n      // after outputting.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"is NaN\";\n        } else {\n          *os << \"never matches\";\n        }\n      } else {\n        *os << \"is approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error <= \" << max_abs_error_ << \")\";\n        }\n      }\n      os->precision(old_precision);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      // As before, get original precision.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"isn't NaN\";\n        } else {\n          *os << \"is anything\";\n        }\n      } else {\n        *os << \"isn't approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error > \" << max_abs_error_ << \")\";\n        }\n      }\n      // Restore original precision.\n      os->precision(old_precision);\n    }\n\n   private:\n    bool HasMaxAbsError() const {\n      return max_abs_error_ >= 0;\n    }\n\n    const FloatType expected_;\n    const bool nan_eq_nan_;\n    // max_abs_error will be used for value comparison when >= 0.\n    const FloatType max_abs_error_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  // The following 3 type conversion operators allow FloatEq(expected) and\n  // NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a\n  // Matcher<const float&>, or a Matcher<float&>, but nothing else.\n  // (While Google's C++ coding style doesn't allow arguments passed\n  // by non-const reference, we may see them in code not conforming to\n  // the style.  Therefore Google Mock needs to support them.)\n  operator Matcher<FloatType>() const {\n    return MakeMatcher(\n        new Impl<FloatType>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<const FloatType&>() const {\n    return MakeMatcher(\n        new Impl<const FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<FloatType&>() const {\n    return MakeMatcher(\n        new Impl<FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n private:\n  const FloatType expected_;\n  const bool nan_eq_nan_;\n  // max_abs_error will be used for value comparison when >= 0.\n  const FloatType max_abs_error_;\n\n  GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);\n};\n\n// Implements the Pointee(m) matcher for matching a pointer whose\n// pointee matches matcher m.  The pointer can be either raw or smart.\ntemplate <typename InnerMatcher>\nclass PointeeMatcher {\n public:\n  explicit PointeeMatcher(const InnerMatcher& matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Pointee(m) to be\n  // used as a matcher for any pointer type whose pointee type is\n  // compatible with the inner matcher, where type Pointer can be\n  // either a raw pointer or a smart pointer.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Pointee().\n  template <typename Pointer>\n  operator Matcher<Pointer>() const {\n    return MakeMatcher(new Impl<Pointer>(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular pointer type.\n  template <typename Pointer>\n  class Impl : public MatcherInterface<Pointer> {\n   public:\n    typedef typename PointeeOf<GTEST_REMOVE_CONST_(  // NOLINT\n        GTEST_REMOVE_REFERENCE_(Pointer))>::type Pointee;\n\n    explicit Impl(const InnerMatcher& matcher)\n        : matcher_(MatcherCast<const Pointee&>(matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"points to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not point to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(Pointer pointer,\n                                 MatchResultListener* listener) const {\n      if (GetRawPointer(pointer) == NULL)\n        return false;\n\n      *listener << \"which points to \";\n      return MatchPrintAndExplain(*pointer, matcher_, listener);\n    }\n\n   private:\n    const Matcher<const Pointee&> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PointeeMatcher);\n};\n\n// Implements the WhenDynamicCastTo<T>(m) matcher that matches a pointer or\n// reference that matches inner_matcher when dynamic_cast<T> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\nclass WhenDynamicCastToMatcherBase {\n public:\n  explicit WhenDynamicCastToMatcherBase(const Matcher<To>& matcher)\n      : matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeNegationTo(os);\n  }\n\n protected:\n  const Matcher<To> matcher_;\n\n  static string GetToName() {\n#if GTEST_HAS_RTTI\n    return GetTypeName<To>();\n#else  // GTEST_HAS_RTTI\n    return \"the target type\";\n#endif  // GTEST_HAS_RTTI\n  }\n\n private:\n  static void GetCastTypeDescription(::std::ostream* os) {\n    *os << \"when dynamic_cast to \" << GetToName() << \", \";\n  }\n\n  GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);\n};\n\n// Primary template.\n// To is a pointer. Cast and forward the result.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase<To> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To>& matcher)\n      : WhenDynamicCastToMatcherBase<To>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From from, MatchResultListener* listener) const {\n    // TODO(sbenza): Add more detail on failures. ie did the dyn_cast fail?\n    To to = dynamic_cast<To>(from);\n    return MatchPrintAndExplain(to, this->matcher_, listener);\n  }\n};\n\n// Specialize for references.\n// In this case we return false if the dynamic_cast fails.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher<To&> : public WhenDynamicCastToMatcherBase<To&> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To&>& matcher)\n      : WhenDynamicCastToMatcherBase<To&>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From& from, MatchResultListener* listener) const {\n    // We don't want an std::bad_cast here, so do the cast with pointers.\n    To* to = dynamic_cast<To*>(&from);\n    if (to == NULL) {\n      *listener << \"which cannot be dynamic_cast to \" << this->GetToName();\n      return false;\n    }\n    return MatchPrintAndExplain(*to, this->matcher_, listener);\n  }\n};\n\n// Implements the Field() matcher for matching a field (i.e. member\n// variable) of an object.\ntemplate <typename Class, typename FieldType>\nclass FieldMatcher {\n public:\n  FieldMatcher(FieldType Class::*field,\n               const Matcher<const FieldType&>& matcher)\n      : field_(field), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T& value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Field() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given field is \";\n    return MatchPrintAndExplain(obj.*field_, matcher_, listener);\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a field, it must be a class/struct/union type and\n    // thus cannot be a pointer.  Therefore we pass false_type() as\n    // the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  const FieldType Class::*field_;\n  const Matcher<const FieldType&> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(FieldMatcher);\n};\n\n// Implements the Property() matcher for matching a property\n// (i.e. return value of a getter method) of an object.\ntemplate <typename Class, typename PropertyType>\nclass PropertyMatcher {\n public:\n  // The property may have a reference type, so 'const PropertyType&'\n  // may cause double references and fail to compile.  That's why we\n  // need GTEST_REFERENCE_TO_CONST, which works regardless of\n  // PropertyType being a reference or not.\n  typedef GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty;\n\n  PropertyMatcher(PropertyType (Class::*property)() const,\n                  const Matcher<RefToConstProperty>& matcher)\n      : property_(property), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T&value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Property() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given property is \";\n    // Cannot pass the return value (for example, int) to MatchPrintAndExplain,\n    // which takes a non-const reference as argument.\n#if defined(_PREFAST_ ) && _MSC_VER == 1800\n    // Workaround bug in VC++ 2013's /analyze parser.\n    // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move\n    posix::Abort();  // To make sure it is never run.\n    return false;\n#else\n    RefToConstProperty result = (obj.*property_)();\n    return MatchPrintAndExplain(result, matcher_, listener);\n#endif\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a property method, it must be a class/struct/union\n    // type and thus cannot be a pointer.  Therefore we pass\n    // false_type() as the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  PropertyType (Class::*property_)() const;\n  const Matcher<RefToConstProperty> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PropertyMatcher);\n};\n\n// Type traits specifying various features of different functors for ResultOf.\n// The default template specifies features for functor objects.\n// Functor classes have to typedef argument_type and result_type\n// to be compatible with ResultOf.\ntemplate <typename Functor>\nstruct CallableTraits {\n  typedef typename Functor::result_type ResultType;\n  typedef Functor StorageType;\n\n  static void CheckIsValid(Functor /* functor */) {}\n  template <typename T>\n  static ResultType Invoke(Functor f, T arg) { return f(arg); }\n};\n\n// Specialization for function pointers.\ntemplate <typename ArgType, typename ResType>\nstruct CallableTraits<ResType(*)(ArgType)> {\n  typedef ResType ResultType;\n  typedef ResType(*StorageType)(ArgType);\n\n  static void CheckIsValid(ResType(*f)(ArgType)) {\n    GTEST_CHECK_(f != NULL)\n        << \"NULL function pointer is passed into ResultOf().\";\n  }\n  template <typename T>\n  static ResType Invoke(ResType(*f)(ArgType), T arg) {\n    return (*f)(arg);\n  }\n};\n\n// Implements the ResultOf() matcher for matching a return value of a\n// unary function of an object.\ntemplate <typename Callable>\nclass ResultOfMatcher {\n public:\n  typedef typename CallableTraits<Callable>::ResultType ResultType;\n\n  ResultOfMatcher(Callable callable, const Matcher<ResultType>& matcher)\n      : callable_(callable), matcher_(matcher) {\n    CallableTraits<Callable>::CheckIsValid(callable_);\n  }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new Impl<T>(callable_, matcher_));\n  }\n\n private:\n  typedef typename CallableTraits<Callable>::StorageType CallableStorageType;\n\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(CallableStorageType callable, const Matcher<ResultType>& matcher)\n        : callable_(callable), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T obj, MatchResultListener* listener) const {\n      *listener << \"which is mapped by the given callable to \";\n      // Cannot pass the return value (for example, int) to\n      // MatchPrintAndExplain, which takes a non-const reference as argument.\n      ResultType result =\n          CallableTraits<Callable>::template Invoke<T>(callable_, obj);\n      return MatchPrintAndExplain(result, matcher_, listener);\n    }\n\n   private:\n    // Functors often define operator() as non-const method even though\n    // they are actualy stateless. But we need to use them even when\n    // 'this' is a const pointer. It's the user's responsibility not to\n    // use stateful callables with ResultOf(), which does't guarantee\n    // how many times the callable will be invoked.\n    mutable CallableStorageType callable_;\n    const Matcher<ResultType> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };  // class Impl\n\n  const CallableStorageType callable_;\n  const Matcher<ResultType> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);\n};\n\n// Implements a matcher that checks the size of an STL-style container.\ntemplate <typename SizeMatcher>\nclass SizeIsMatcher {\n public:\n  explicit SizeIsMatcher(const SizeMatcher& size_matcher)\n       : size_matcher_(size_matcher) {\n  }\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(size_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)> ContainerView;\n    typedef typename ContainerView::type::size_type SizeType;\n    explicit Impl(const SizeMatcher& size_matcher)\n        : size_matcher_(MatcherCast<SizeType>(size_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n      SizeType size = container.size();\n      StringMatchResultListener size_listener;\n      const bool result = size_matcher_.MatchAndExplain(size, &size_listener);\n      *listener\n          << \"whose size \" << size << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(size_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<SizeType> size_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const SizeMatcher size_matcher_;\n  GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);\n};\n\n// Implements a matcher that checks the begin()..end() distance of an STL-style\n// container.\ntemplate <typename DistanceMatcher>\nclass BeginEndDistanceIsMatcher {\n public:\n  explicit BeginEndDistanceIsMatcher(const DistanceMatcher& distance_matcher)\n      : distance_matcher_(distance_matcher) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(distance_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::type StlContainer;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef typename std::iterator_traits<\n        StlContainerConstIterator>::difference_type DistanceType;\n    explicit Impl(const DistanceMatcher& distance_matcher)\n        : distance_matcher_(MatcherCast<DistanceType>(distance_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n#if GTEST_HAS_STD_BEGIN_AND_END_\n      using std::begin;\n      using std::end;\n      DistanceType distance = std::distance(begin(container), end(container));\n#else\n      DistanceType distance = std::distance(container.begin(), container.end());\n#endif\n      StringMatchResultListener distance_listener;\n      const bool result =\n          distance_matcher_.MatchAndExplain(distance, &distance_listener);\n      *listener << \"whose distance between begin() and end() \" << distance\n                << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(distance_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<DistanceType> distance_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const DistanceMatcher distance_matcher_;\n  GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);\n};\n\n// Implements an equality matcher for any STL-style container whose elements\n// support ==. This matcher is like Eq(), but its failure explanations provide\n// more detailed information that is useful when the container is used as a set.\n// The failure message reports elements that are in one of the operands but not\n// the other. The failure messages do not report duplicate or out-of-order\n// elements in the containers (which don't properly matter to sets, but can\n// occur if the containers are vectors or lists, for example).\n//\n// Uses the container's const_iterator, value_type, operator ==,\n// begin(), and end().\ntemplate <typename Container>\nclass ContainerEqMatcher {\n public:\n  typedef internal::StlContainerView<Container> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n\n  // We make a copy of expected in case the elements in it are modified\n  // after this matcher is created.\n  explicit ContainerEqMatcher(const Container& expected)\n      : expected_(View::Copy(expected)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<Container,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(Container)>();\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"equals \";\n    UniversalPrint(expected_, os);\n  }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"does not equal \";\n    UniversalPrint(expected_, os);\n  }\n\n  template <typename LhsContainer>\n  bool MatchAndExplain(const LhsContainer& lhs,\n                       MatchResultListener* listener) const {\n    // GTEST_REMOVE_CONST_() is needed to work around an MSVC 8.0 bug\n    // that causes LhsContainer to be a const type sometimes.\n    typedef internal::StlContainerView<GTEST_REMOVE_CONST_(LhsContainer)>\n        LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n    if (lhs_stl_container == expected_)\n      return true;\n\n    ::std::ostream* const os = listener->stream();\n    if (os != NULL) {\n      // Something is different. Check for extra values first.\n      bool printed_header = false;\n      for (typename LhsStlContainer::const_iterator it =\n               lhs_stl_container.begin();\n           it != lhs_stl_container.end(); ++it) {\n        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==\n            expected_.end()) {\n          if (printed_header) {\n            *os << \", \";\n          } else {\n            *os << \"which has these unexpected elements: \";\n            printed_header = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n\n      // Now check for missing values.\n      bool printed_header2 = false;\n      for (typename StlContainer::const_iterator it = expected_.begin();\n           it != expected_.end(); ++it) {\n        if (internal::ArrayAwareFind(\n                lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==\n            lhs_stl_container.end()) {\n          if (printed_header2) {\n            *os << \", \";\n          } else {\n            *os << (printed_header ? \",\\nand\" : \"which\")\n                << \" doesn't have these expected elements: \";\n            printed_header2 = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n    }\n\n    return false;\n  }\n\n private:\n  const StlContainer expected_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);\n};\n\n// A comparator functor that uses the < operator to compare two values.\nstruct LessComparator {\n  template <typename T, typename U>\n  bool operator()(const T& lhs, const U& rhs) const { return lhs < rhs; }\n};\n\n// Implements WhenSortedBy(comparator, container_matcher).\ntemplate <typename Comparator, typename ContainerMatcher>\nclass WhenSortedByMatcher {\n public:\n  WhenSortedByMatcher(const Comparator& comparator,\n                      const ContainerMatcher& matcher)\n      : comparator_(comparator), matcher_(matcher) {}\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(comparator_, matcher_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    // Transforms std::pair<const Key, Value> into std::pair<Key, Value>\n    // so that we can match associative containers.\n    typedef typename RemoveConstFromKey<\n        typename LhsStlContainer::value_type>::type LhsValue;\n\n    Impl(const Comparator& comparator, const ContainerMatcher& matcher)\n        : comparator_(comparator), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      ::std::vector<LhsValue> sorted_container(lhs_stl_container.begin(),\n                                               lhs_stl_container.end());\n      ::std::sort(\n           sorted_container.begin(), sorted_container.end(), comparator_);\n\n      if (!listener->IsInterested()) {\n        // If the listener is not interested, we do not need to\n        // construct the inner explanation.\n        return matcher_.Matches(sorted_container);\n      }\n\n      *listener << \"which is \";\n      UniversalPrint(sorted_container, listener->stream());\n      *listener << \" when sorted\";\n\n      StringMatchResultListener inner_listener;\n      const bool match = matcher_.MatchAndExplain(sorted_container,\n                                                  &inner_listener);\n      PrintIfNotEmpty(inner_listener.str(), listener->stream());\n      return match;\n    }\n\n   private:\n    const Comparator comparator_;\n    const Matcher<const ::std::vector<LhsValue>&> matcher_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n private:\n  const Comparator comparator_;\n  const ContainerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);\n};\n\n// Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher\n// must be able to be safely cast to Matcher<tuple<const T1&, const\n// T2&> >, where T1 and T2 are the types of elements in the LHS\n// container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename RhsContainer>\nclass PointwiseMatcher {\n public:\n  typedef internal::StlContainerView<RhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type RhsValue;\n\n  // Like ContainerEq, we make a copy of rhs in case the elements in\n  // it are modified after this matcher is created.\n  PointwiseMatcher(const TupleMatcher& tuple_matcher, const RhsContainer& rhs)\n      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<RhsContainer,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)>();\n  }\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(tuple_matcher_, rhs_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    typedef typename LhsStlContainer::value_type LhsValue;\n    // We pass the LHS value and the RHS value to the inner matcher by\n    // reference, as they may be expensive to copy.  We must use tuple\n    // instead of pair here, as a pair cannot hold references (C++ 98,\n    // 20.2.2 [lib.pairs]).\n    typedef ::testing::tuple<const LhsValue&, const RhsValue&> InnerMatcherArg;\n\n    Impl(const TupleMatcher& tuple_matcher, const RhsStlContainer& rhs)\n        // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.\n        : mono_tuple_matcher_(SafeMatcherCast<InnerMatcherArg>(tuple_matcher)),\n          rhs_(rhs) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"contains \" << rhs_.size()\n          << \" values, where each value and its corresponding value in \";\n      UniversalPrinter<RhsStlContainer>::Print(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"doesn't contain exactly \" << rhs_.size()\n          << \" values, or contains a value x at some index i\"\n          << \" where x and the i-th value of \";\n      UniversalPrint(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      const size_t actual_size = lhs_stl_container.size();\n      if (actual_size != rhs_.size()) {\n        *listener << \"which contains \" << actual_size << \" values\";\n        return false;\n      }\n\n      typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();\n      typename RhsStlContainer::const_iterator right = rhs_.begin();\n      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {\n        const InnerMatcherArg value_pair(*left, *right);\n\n        if (listener->IsInterested()) {\n          StringMatchResultListener inner_listener;\n          if (!mono_tuple_matcher_.MatchAndExplain(\n                  value_pair, &inner_listener)) {\n            *listener << \"where the value pair (\";\n            UniversalPrint(*left, listener->stream());\n            *listener << \", \";\n            UniversalPrint(*right, listener->stream());\n            *listener << \") at index #\" << i << \" don't match\";\n            PrintIfNotEmpty(inner_listener.str(), listener->stream());\n            return false;\n          }\n        } else {\n          if (!mono_tuple_matcher_.Matches(value_pair))\n            return false;\n        }\n      }\n\n      return true;\n    }\n\n   private:\n    const Matcher<InnerMatcherArg> mono_tuple_matcher_;\n    const RhsStlContainer rhs_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const TupleMatcher tuple_matcher_;\n  const RhsStlContainer rhs_;\n\n  GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);\n};\n\n// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.\ntemplate <typename Container>\nclass QuantifierMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  template <typename InnerMatcher>\n  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n           testing::SafeMatcherCast<const Element&>(inner_matcher)) {}\n\n  // Checks whether:\n  // * All elements in the container match, if all_elements_should_match.\n  // * Any element in the container matches, if !all_elements_should_match.\n  bool MatchAndExplainImpl(bool all_elements_should_match,\n                           Container container,\n                           MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    size_t i = 0;\n    for (typename StlContainer::const_iterator it = stl_container.begin();\n         it != stl_container.end(); ++it, ++i) {\n      StringMatchResultListener inner_listener;\n      const bool matches = inner_matcher_.MatchAndExplain(*it, &inner_listener);\n\n      if (matches != all_elements_should_match) {\n        *listener << \"whose element #\" << i\n                  << (matches ? \" matches\" : \" doesn't match\");\n        PrintIfNotEmpty(inner_listener.str(), listener->stream());\n        return !all_elements_should_match;\n      }\n    }\n    return all_elements_should_match;\n  }\n\n protected:\n  const Matcher<const Element&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);\n};\n\n// Implements Contains(element_matcher) for the given argument type Container.\n// Symmetric to EachMatcherImpl.\ntemplate <typename Container>\nclass ContainsMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"contains at least one element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't contain any element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(false, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);\n};\n\n// Implements Each(element_matcher) for the given argument type Container.\n// Symmetric to ContainsMatcherImpl.\ntemplate <typename Container>\nclass EachMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit EachMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"only contains elements that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"contains some element that \";\n    this->inner_matcher_.DescribeNegationTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(true, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);\n};\n\n// Implements polymorphic Contains(element_matcher).\ntemplate <typename M>\nclass ContainsMatcher {\n public:\n  explicit ContainsMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ContainsMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcher);\n};\n\n// Implements polymorphic Each(element_matcher).\ntemplate <typename M>\nclass EachMatcher {\n public:\n  explicit EachMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new EachMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(EachMatcher);\n};\n\n// Implements Key(inner_matcher) for the given argument pair type.\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename PairType>\nclass KeyMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type KeyType;\n\n  template <typename InnerMatcher>\n  explicit KeyMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n          testing::SafeMatcherCast<const KeyType&>(inner_matcher)) {\n  }\n\n  // Returns true iff 'key_value.first' (the key) matches the inner matcher.\n  virtual bool MatchAndExplain(PairType key_value,\n                               MatchResultListener* listener) const {\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(key_value.first,\n                                                      &inner_listener);\n    const internal::string explanation = inner_listener.str();\n    if (explanation != \"\") {\n      *listener << \"whose first field is a value \" << explanation;\n    }\n    return match;\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't have a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<const KeyType&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);\n};\n\n// Implements polymorphic Key(matcher_for_key).\ntemplate <typename M>\nclass KeyMatcher {\n public:\n  explicit KeyMatcher(M m) : matcher_for_key_(m) {}\n\n  template <typename PairType>\n  operator Matcher<PairType>() const {\n    return MakeMatcher(new KeyMatcherImpl<PairType>(matcher_for_key_));\n  }\n\n private:\n  const M matcher_for_key_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcher);\n};\n\n// Implements Pair(first_matcher, second_matcher) for the given argument pair\n// type with its two matchers. See Pair() function below.\ntemplate <typename PairType>\nclass PairMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type FirstType;\n  typedef typename RawPairType::second_type SecondType;\n\n  template <typename FirstMatcher, typename SecondMatcher>\n  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(\n            testing::SafeMatcherCast<const FirstType&>(first_matcher)),\n        second_matcher_(\n            testing::SafeMatcherCast<const SecondType&>(second_matcher)) {\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeTo(os);\n    *os << \", and has a second field that \";\n    second_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeNegationTo(os);\n    *os << \", or has a second field that \";\n    second_matcher_.DescribeNegationTo(os);\n  }\n\n  // Returns true iff 'a_pair.first' matches first_matcher and 'a_pair.second'\n  // matches second_matcher.\n  virtual bool MatchAndExplain(PairType a_pair,\n                               MatchResultListener* listener) const {\n    if (!listener->IsInterested()) {\n      // If the listener is not interested, we don't need to construct the\n      // explanation.\n      return first_matcher_.Matches(a_pair.first) &&\n             second_matcher_.Matches(a_pair.second);\n    }\n    StringMatchResultListener first_inner_listener;\n    if (!first_matcher_.MatchAndExplain(a_pair.first,\n                                        &first_inner_listener)) {\n      *listener << \"whose first field does not match\";\n      PrintIfNotEmpty(first_inner_listener.str(), listener->stream());\n      return false;\n    }\n    StringMatchResultListener second_inner_listener;\n    if (!second_matcher_.MatchAndExplain(a_pair.second,\n                                         &second_inner_listener)) {\n      *listener << \"whose second field does not match\";\n      PrintIfNotEmpty(second_inner_listener.str(), listener->stream());\n      return false;\n    }\n    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),\n                   listener);\n    return true;\n  }\n\n private:\n  void ExplainSuccess(const internal::string& first_explanation,\n                      const internal::string& second_explanation,\n                      MatchResultListener* listener) const {\n    *listener << \"whose both fields match\";\n    if (first_explanation != \"\") {\n      *listener << \", where the first field is a value \" << first_explanation;\n    }\n    if (second_explanation != \"\") {\n      *listener << \", \";\n      if (first_explanation != \"\") {\n        *listener << \"and \";\n      } else {\n        *listener << \"where \";\n      }\n      *listener << \"the second field is a value \" << second_explanation;\n    }\n  }\n\n  const Matcher<const FirstType&> first_matcher_;\n  const Matcher<const SecondType&> second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);\n};\n\n// Implements polymorphic Pair(first_matcher, second_matcher).\ntemplate <typename FirstMatcher, typename SecondMatcher>\nclass PairMatcher {\n public:\n  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}\n\n  template <typename PairType>\n  operator Matcher<PairType> () const {\n    return MakeMatcher(\n        new PairMatcherImpl<PairType>(\n            first_matcher_, second_matcher_));\n  }\n\n private:\n  const FirstMatcher first_matcher_;\n  const SecondMatcher second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcher);\n};\n\n// Implements ElementsAre() and ElementsAreArray().\ntemplate <typename Container>\nclass ElementsAreMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  ElementsAreMatcherImpl(InputIter first, InputIter last) {\n    while (first != last) {\n      matchers_.push_back(MatcherCast<const Element&>(*first++));\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"is empty\";\n    } else if (count() == 1) {\n      *os << \"has 1 element that \";\n      matchers_[0].DescribeTo(os);\n    } else {\n      *os << \"has \" << Elements(count()) << \" where\\n\";\n      for (size_t i = 0; i != count(); ++i) {\n        *os << \"element #\" << i << \" \";\n        matchers_[i].DescribeTo(os);\n        if (i + 1 < count()) {\n          *os << \",\\n\";\n        }\n      }\n    }\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"isn't empty\";\n      return;\n    }\n\n    *os << \"doesn't have \" << Elements(count()) << \", or\\n\";\n    for (size_t i = 0; i != count(); ++i) {\n      *os << \"element #\" << i << \" \";\n      matchers_[i].DescribeNegationTo(os);\n      if (i + 1 < count()) {\n        *os << \", or\\n\";\n      }\n    }\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    // To work with stream-like \"containers\", we must only walk\n    // through the elements in one pass.\n\n    const bool listener_interested = listener->IsInterested();\n\n    // explanations[i] is the explanation of the element at index i.\n    ::std::vector<internal::string> explanations(count());\n    StlContainerReference stl_container = View::ConstReference(container);\n    StlContainerConstIterator it = stl_container.begin();\n    size_t exam_pos = 0;\n    bool mismatch_found = false;  // Have we found a mismatched element yet?\n\n    // Go through the elements and matchers in pairs, until we reach\n    // the end of either the elements or the matchers, or until we find a\n    // mismatch.\n    for (; it != stl_container.end() && exam_pos != count(); ++it, ++exam_pos) {\n      bool match;  // Does the current element match the current matcher?\n      if (listener_interested) {\n        StringMatchResultListener s;\n        match = matchers_[exam_pos].MatchAndExplain(*it, &s);\n        explanations[exam_pos] = s.str();\n      } else {\n        match = matchers_[exam_pos].Matches(*it);\n      }\n\n      if (!match) {\n        mismatch_found = true;\n        break;\n      }\n    }\n    // If mismatch_found is true, 'exam_pos' is the index of the mismatch.\n\n    // Find how many elements the actual container has.  We avoid\n    // calling size() s.t. this code works for stream-like \"containers\"\n    // that don't define size().\n    size_t actual_count = exam_pos;\n    for (; it != stl_container.end(); ++it) {\n      ++actual_count;\n    }\n\n    if (actual_count != count()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container.  Otherwise we just need to show\n      // how many elements there actually are.\n      if (listener_interested && (actual_count != 0)) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    if (mismatch_found) {\n      // The element count matches, but the exam_pos-th element doesn't match.\n      if (listener_interested) {\n        *listener << \"whose element #\" << exam_pos << \" doesn't match\";\n        PrintIfNotEmpty(explanations[exam_pos], listener->stream());\n      }\n      return false;\n    }\n\n    // Every element matches its expectation.  We need to explain why\n    // (the obvious ones can be skipped).\n    if (listener_interested) {\n      bool reason_printed = false;\n      for (size_t i = 0; i != count(); ++i) {\n        const internal::string& s = explanations[i];\n        if (!s.empty()) {\n          if (reason_printed) {\n            *listener << \",\\nand \";\n          }\n          *listener << \"whose element #\" << i << \" matches, \" << s;\n          reason_printed = true;\n        }\n      }\n    }\n    return true;\n  }\n\n private:\n  static Message Elements(size_t count) {\n    return Message() << count << (count == 1 ? \" element\" : \" elements\");\n  }\n\n  size_t count() const { return matchers_.size(); }\n\n  ::std::vector<Matcher<const Element&> > matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);\n};\n\n// Connectivity matrix of (elements X matchers), in element-major order.\n// Initially, there are no edges.\n// Use NextGraph() to iterate over all possible edge configurations.\n// Use Randomize() to generate a random edge configuration.\nclass GTEST_API_ MatchMatrix {\n public:\n  MatchMatrix(size_t num_elements, size_t num_matchers)\n      : num_elements_(num_elements),\n        num_matchers_(num_matchers),\n        matched_(num_elements_* num_matchers_, 0) {\n  }\n\n  size_t LhsSize() const { return num_elements_; }\n  size_t RhsSize() const { return num_matchers_; }\n  bool HasEdge(size_t ilhs, size_t irhs) const {\n    return matched_[SpaceIndex(ilhs, irhs)] == 1;\n  }\n  void SetEdge(size_t ilhs, size_t irhs, bool b) {\n    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;\n  }\n\n  // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,\n  // adds 1 to that number; returns false if incrementing the graph left it\n  // empty.\n  bool NextGraph();\n\n  void Randomize();\n\n  string DebugString() const;\n\n private:\n  size_t SpaceIndex(size_t ilhs, size_t irhs) const {\n    return ilhs * num_matchers_ + irhs;\n  }\n\n  size_t num_elements_;\n  size_t num_matchers_;\n\n  // Each element is a char interpreted as bool. They are stored as a\n  // flattened array in lhs-major order, use 'SpaceIndex()' to translate\n  // a (ilhs, irhs) matrix coordinate into an offset.\n  ::std::vector<char> matched_;\n};\n\ntypedef ::std::pair<size_t, size_t> ElementMatcherPair;\ntypedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;\n\n// Returns a maximum bipartite matching for the specified graph 'g'.\n// The matching is represented as a vector of {element, matcher} pairs.\nGTEST_API_ ElementMatcherPairs\nFindMaxBipartiteMatching(const MatchMatrix& g);\n\nGTEST_API_ bool FindPairing(const MatchMatrix& matrix,\n                            MatchResultListener* listener);\n\n// Untyped base class for implementing UnorderedElementsAre.  By\n// putting logic that's not specific to the element type here, we\n// reduce binary bloat and increase compilation speed.\nclass GTEST_API_ UnorderedElementsAreMatcherImplBase {\n protected:\n  // A vector of matcher describers, one for each element matcher.\n  // Does not own the describers (and thus can be used only when the\n  // element matchers are alive).\n  typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;\n\n  // Describes this UnorderedElementsAre matcher.\n  void DescribeToImpl(::std::ostream* os) const;\n\n  // Describes the negation of this UnorderedElementsAre matcher.\n  void DescribeNegationToImpl(::std::ostream* os) const;\n\n  bool VerifyAllElementsAndMatchersAreMatched(\n      const ::std::vector<string>& element_printouts,\n      const MatchMatrix& matrix,\n      MatchResultListener* listener) const;\n\n  MatcherDescriberVec& matcher_describers() {\n    return matcher_describers_;\n  }\n\n  static Message Elements(size_t n) {\n    return Message() << n << \" element\" << (n == 1 ? \"\" : \"s\");\n  }\n\n private:\n  MatcherDescriberVec matcher_describers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);\n};\n\n// Implements unordered ElementsAre and unordered ElementsAreArray.\ntemplate <typename Container>\nclass UnorderedElementsAreMatcherImpl\n    : public MatcherInterface<Container>,\n      public UnorderedElementsAreMatcherImplBase {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  UnorderedElementsAreMatcherImpl(InputIter first, InputIter last) {\n    for (; first != last; ++first) {\n      matchers_.push_back(MatcherCast<const Element&>(*first));\n      matcher_describers().push_back(matchers_.back().GetDescriber());\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    ::std::vector<string> element_printouts;\n    MatchMatrix matrix = AnalyzeElements(stl_container.begin(),\n                                         stl_container.end(),\n                                         &element_printouts,\n                                         listener);\n\n    const size_t actual_count = matrix.LhsSize();\n    if (actual_count == 0 && matchers_.empty()) {\n      return true;\n    }\n    if (actual_count != matchers_.size()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container. Otherwise we just need to show\n      // how many elements there actually are.\n      if (actual_count != 0 && listener->IsInterested()) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    return VerifyAllElementsAndMatchersAreMatched(element_printouts,\n                                                  matrix, listener) &&\n           FindPairing(matrix, listener);\n  }\n\n private:\n  typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n\n  template <typename ElementIter>\n  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,\n                              ::std::vector<string>* element_printouts,\n                              MatchResultListener* listener) const {\n    element_printouts->clear();\n    ::std::vector<char> did_match;\n    size_t num_elements = 0;\n    for (; elem_first != elem_last; ++num_elements, ++elem_first) {\n      if (listener->IsInterested()) {\n        element_printouts->push_back(PrintToString(*elem_first));\n      }\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        did_match.push_back(Matches(matchers_[irhs])(*elem_first));\n      }\n    }\n\n    MatchMatrix matrix(num_elements, matchers_.size());\n    ::std::vector<char>::const_iterator did_match_iter = did_match.begin();\n    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);\n      }\n    }\n    return matrix;\n  }\n\n  MatcherVec matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);\n};\n\n// Functor for use in TransformTuple.\n// Performs MatcherCast<Target> on an input argument of any type.\ntemplate <typename Target>\nstruct CastAndAppendTransform {\n  template <typename Arg>\n  Matcher<Target> operator()(const Arg& a) const {\n    return MatcherCast<Target>(a);\n  }\n};\n\n// Implements UnorderedElementsAre.\ntemplate <typename MatcherTuple>\nclass UnorderedElementsAreMatcher {\n public:\n  explicit UnorderedElementsAreMatcher(const MatcherTuple& args)\n      : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new UnorderedElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);\n};\n\n// Implements ElementsAre.\ntemplate <typename MatcherTuple>\nclass ElementsAreMatcher {\n public:\n  explicit ElementsAreMatcher(const MatcherTuple& args) : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);\n};\n\n// Implements UnorderedElementsAreArray().\ntemplate <typename T>\nclass UnorderedElementsAreArrayMatcher {\n public:\n  UnorderedElementsAreArrayMatcher() {}\n\n  template <typename Iter>\n  UnorderedElementsAreArrayMatcher(Iter first, Iter last)\n      : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(\n        new UnorderedElementsAreMatcherImpl<Container>(matchers_.begin(),\n                                                       matchers_.end()));\n  }\n\n private:\n  ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);\n};\n\n// Implements ElementsAreArray().\ntemplate <typename T>\nclass ElementsAreArrayMatcher {\n public:\n  template <typename Iter>\n  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n        matchers_.begin(), matchers_.end()));\n  }\n\n private:\n  const ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);\n};\n\n// Given a 2-tuple matcher tm of type Tuple2Matcher and a value second\n// of type Second, BoundSecondMatcher<Tuple2Matcher, Second>(tm,\n// second) is a polymorphic matcher that matches a value x iff tm\n// matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\n//\n// BoundSecondMatcher is copyable and assignable, as we need to put\n// instances of this class in a vector when implementing\n// UnorderedPointwise().\ntemplate <typename Tuple2Matcher, typename Second>\nclass BoundSecondMatcher {\n public:\n  BoundSecondMatcher(const Tuple2Matcher& tm, const Second& second)\n      : tuple2_matcher_(tm), second_value_(second) {}\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return MakeMatcher(new Impl<T>(tuple2_matcher_, second_value_));\n  }\n\n  // We have to define this for UnorderedPointwise() to compile in\n  // C++98 mode, as it puts BoundSecondMatcher instances in a vector,\n  // which requires the elements to be assignable in C++98.  The\n  // compiler cannot generate the operator= for us, as Tuple2Matcher\n  // and Second may not be assignable.\n  //\n  // However, this should never be called, so the implementation just\n  // need to assert.\n  void operator=(const BoundSecondMatcher& /*rhs*/) {\n    GTEST_LOG_(FATAL) << \"BoundSecondMatcher should never be assigned.\";\n  }\n\n  BoundSecondMatcher(const BoundSecondMatcher &) = default;\n\n private:\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    typedef ::testing::tuple<T, Second> ArgTuple;\n\n    Impl(const Tuple2Matcher& tm, const Second& second)\n        : mono_tuple2_matcher_(SafeMatcherCast<const ArgTuple&>(tm)),\n          second_value_(second) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"and \";\n      UniversalPrint(second_value_, os);\n      *os << \" \";\n      mono_tuple2_matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),\n                                                  listener);\n    }\n\n   private:\n    const Matcher<const ArgTuple&> mono_tuple2_matcher_;\n    const Second second_value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const Tuple2Matcher tuple2_matcher_;\n  const Second second_value_;\n};\n\n// Given a 2-tuple matcher tm and a value second,\n// MatcherBindSecond(tm, second) returns a matcher that matches a\n// value x iff tm matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\ntemplate <typename Tuple2Matcher, typename Second>\nBoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(\n    const Tuple2Matcher& tm, const Second& second) {\n  return BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);\n}\n\n// Returns the description for a matcher defined using the MATCHER*()\n// macro where the user-supplied description string is \"\", if\n// 'negation' is false; otherwise returns the description of the\n// negation of the matcher.  'param_values' contains a list of strings\n// that are the print-out of the matcher's parameters.\nGTEST_API_ string FormatMatcherDescription(bool negation,\n                                           const char* matcher_name,\n                                           const Strings& param_values);\n\n}  // namespace internal\n\n// ElementsAreArray(first, last)\n// ElementsAreArray(pointer, count)\n// ElementsAreArray(array)\n// ElementsAreArray(container)\n// ElementsAreArray({ e1, e2, ..., en })\n//\n// The ElementsAreArray() functions are like ElementsAre(...), except\n// that they are given a homogeneous sequence rather than taking each\n// element as a function argument. The sequence can be specified as an\n// array, a pointer and count, a vector, an initializer list, or an\n// STL iterator range. In each of these cases, the underlying sequence\n// can be either a sequence of values or a sequence of matchers.\n//\n// All forms of ElementsAreArray() make a copy of the input matcher sequence.\n\ntemplate <typename Iter>\ninline internal::ElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::ElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T* pointer, size_t count) {\n  return ElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T (&array)[N]) {\n  return ElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::ElementsAreArrayMatcher<typename Container::value_type>\nElementsAreArray(const Container& container) {\n  return ElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T>\nElementsAreArray(::std::initializer_list<T> xs) {\n  return ElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// UnorderedElementsAreArray(first, last)\n// UnorderedElementsAreArray(pointer, count)\n// UnorderedElementsAreArray(array)\n// UnorderedElementsAreArray(container)\n// UnorderedElementsAreArray({ e1, e2, ..., en })\n//\n// The UnorderedElementsAreArray() functions are like\n// ElementsAreArray(...), but allow matching the elements in any order.\ntemplate <typename Iter>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nUnorderedElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T* pointer, size_t count) {\n  return UnorderedElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T (&array)[N]) {\n  return UnorderedElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename Container::value_type>\nUnorderedElementsAreArray(const Container& container) {\n  return UnorderedElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(::std::initializer_list<T> xs) {\n  return UnorderedElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// _ is a matcher that matches anything of any type.\n//\n// This definition is fine as:\n//\n//   1. The C++ standard permits using the name _ in a namespace that\n//      is not the global namespace or ::std.\n//   2. The AnythingMatcher class has no data member or constructor,\n//      so it's OK to create global variables of this type.\n//   3. c-style has approved of using _ in this case.\nconst internal::AnythingMatcher _ = {};\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> A() { return MakeMatcher(new internal::AnyMatcherImpl<T>()); }\n\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> An() { return A<T>(); }\n\n// Creates a polymorphic matcher that matches anything equal to x.\n// Note: if the parameter of Eq() were declared as const T&, Eq(\"foo\")\n// wouldn't compile.\ntemplate <typename T>\ninline internal::EqMatcher<T> Eq(T x) { return internal::EqMatcher<T>(x); }\n\n// Constructs a Matcher<T> from a 'value' of type T.  The constructed\n// matcher matches any value that's equal to 'value'.\ntemplate <typename T>\nMatcher<T>::Matcher(T value) { *this = Eq(value); }\n\n// Creates a monomorphic matcher that matches anything with type Lhs\n// and equal to rhs.  A user may need to use this instead of Eq(...)\n// in order to resolve an overloading ambiguity.\n//\n// TypedEq<T>(x) is just a convenient short-hand for Matcher<T>(Eq(x))\n// or Matcher<T>(x), but more readable than the latter.\n//\n// We could define similar monomorphic matchers for other comparison\n// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do\n// it yet as those are used much less than Eq() in practice.  A user\n// can always write Matcher<T>(Lt(5)) to be explicit about the type,\n// for example.\ntemplate <typename Lhs, typename Rhs>\ninline Matcher<Lhs> TypedEq(const Rhs& rhs) { return Eq(rhs); }\n\n// Creates a polymorphic matcher that matches anything >= x.\ntemplate <typename Rhs>\ninline internal::GeMatcher<Rhs> Ge(Rhs x) {\n  return internal::GeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything > x.\ntemplate <typename Rhs>\ninline internal::GtMatcher<Rhs> Gt(Rhs x) {\n  return internal::GtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything <= x.\ntemplate <typename Rhs>\ninline internal::LeMatcher<Rhs> Le(Rhs x) {\n  return internal::LeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything < x.\ntemplate <typename Rhs>\ninline internal::LtMatcher<Rhs> Lt(Rhs x) {\n  return internal::LtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything != x.\ntemplate <typename Rhs>\ninline internal::NeMatcher<Rhs> Ne(Rhs x) {\n  return internal::NeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches any NULL pointer.\ninline PolymorphicMatcher<internal::IsNullMatcher > IsNull() {\n  return MakePolymorphicMatcher(internal::IsNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any non-NULL pointer.\n// This is convenient as Not(NULL) doesn't compile (the compiler\n// thinks that that expression is comparing a pointer with an integer).\ninline PolymorphicMatcher<internal::NotNullMatcher > NotNull() {\n  return MakePolymorphicMatcher(internal::NotNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any argument that\n// references variable x.\ntemplate <typename T>\ninline internal::RefMatcher<T&> Ref(T& x) {  // NOLINT\n  return internal::RefMatcher<T&>(x);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<double> DoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, false);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, true);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> DoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<float> FloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, false);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, true);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> FloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches a pointer (raw or smart) that points\n// to a value that matches inner_matcher.\ntemplate <typename InnerMatcher>\ninline internal::PointeeMatcher<InnerMatcher> Pointee(\n    const InnerMatcher& inner_matcher) {\n  return internal::PointeeMatcher<InnerMatcher>(inner_matcher);\n}\n\n// Creates a matcher that matches a pointer or reference that matches\n// inner_matcher when dynamic_cast<To> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\ninline PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To> >\nWhenDynamicCastTo(const Matcher<To>& inner_matcher) {\n  return MakePolymorphicMatcher(\n      internal::WhenDynamicCastToMatcher<To>(inner_matcher));\n}\n\n// Creates a matcher that matches an object whose given field matches\n// 'matcher'.  For example,\n//   Field(&Foo::number, Ge(5))\n// matches a Foo object x iff x.number >= 5.\ntemplate <typename Class, typename FieldType, typename FieldMatcher>\ninline PolymorphicMatcher<\n  internal::FieldMatcher<Class, FieldType> > Field(\n    FieldType Class::*field, const FieldMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::FieldMatcher<Class, FieldType>(\n          field, MatcherCast<const FieldType&>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Field(&Foo::bar, m)\n  // to compile where bar is an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object whose given property\n// matches 'matcher'.  For example,\n//   Property(&Foo::str, StartsWith(\"hi\"))\n// matches a Foo object x iff x.str() starts with \"hi\".\ntemplate <typename Class, typename PropertyType, typename PropertyMatcher>\ninline PolymorphicMatcher<\n  internal::PropertyMatcher<Class, PropertyType> > Property(\n    PropertyType (Class::*property)() const, const PropertyMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher<Class, PropertyType>(\n          property,\n          MatcherCast<GTEST_REFERENCE_TO_CONST_(PropertyType)>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Property(&Foo::bar, m)\n  // to compile where bar() returns an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object iff the result of applying\n// a callable to x matches 'matcher'.\n// For example,\n//   ResultOf(f, StartsWith(\"hi\"))\n// matches a Foo object x iff f(x) starts with \"hi\".\n// callable parameter can be a function, function pointer, or a functor.\n// Callable has to satisfy the following conditions:\n//   * It is required to keep no state affecting the results of\n//     the calls on it and make no assumptions about how many calls\n//     will be made. Any state it keeps must be protected from the\n//     concurrent access.\n//   * If it is a function object, it has to define type result_type.\n//     We recommend deriving your functor classes from std::unary_function.\ntemplate <typename Callable, typename ResultOfMatcher>\ninternal::ResultOfMatcher<Callable> ResultOf(\n    Callable callable, const ResultOfMatcher& matcher) {\n  return internal::ResultOfMatcher<Callable>(\n          callable,\n          MatcherCast<typename internal::CallableTraits<Callable>::ResultType>(\n              matcher));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   ResultOf(Function, m)\n  // to compile where Function() returns an int32 and m is a matcher for int64.\n}\n\n// String matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any string, std::string, or C string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::string> >\n    HasSubstr(const internal::string& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::string>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::string> >\n    StartsWith(const internal::string& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::string>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::string> >\n    EndsWith(const internal::string& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::string>(\n      suffix));\n}\n\n// Matches a string that fully matches regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::string& regex) {\n  return MatchesRegex(new internal::RE(regex));\n}\n\n// Matches a string that contains regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::string& regex) {\n  return ContainsRegex(new internal::RE(regex));\n}\n\n#if GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n// Wide string matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any wstring, std::wstring, or C wide string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::wstring> >\n    HasSubstr(const internal::wstring& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::wstring>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::wstring> >\n    StartsWith(const internal::wstring& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::wstring>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::wstring> >\n    EndsWith(const internal::wstring& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::wstring>(\n      suffix));\n}\n\n#endif  // GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field == the second field.\ninline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field >= the second field.\ninline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field > the second field.\ninline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field <= the second field.\ninline internal::Le2Matcher Le() { return internal::Le2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field < the second field.\ninline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field != the second field.\ninline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }\n\n// Creates a matcher that matches any value of type T that m doesn't\n// match.\ntemplate <typename InnerMatcher>\ninline internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) {\n  return internal::NotMatcher<InnerMatcher>(m);\n}\n\n// Returns a matcher that matches anything that satisfies the given\n// predicate.  The predicate can be any unary function or functor\n// whose return type can be implicitly converted to bool.\ntemplate <typename Predicate>\ninline PolymorphicMatcher<internal::TrulyMatcher<Predicate> >\nTruly(Predicate pred) {\n  return MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));\n}\n\n// Returns a matcher that matches the container size. The container must\n// support both size() and size_type which all STL-like containers provide.\n// Note that the parameter 'size' can be a value of type size_type as well as\n// matcher. For instance:\n//   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.\n//   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.\ntemplate <typename SizeMatcher>\ninline internal::SizeIsMatcher<SizeMatcher>\nSizeIs(const SizeMatcher& size_matcher) {\n  return internal::SizeIsMatcher<SizeMatcher>(size_matcher);\n}\n\n// Returns a matcher that matches the distance between the container's begin()\n// iterator and its end() iterator, i.e. the size of the container. This matcher\n// can be used instead of SizeIs with containers such as std::forward_list which\n// do not implement size(). The container must provide const_iterator (with\n// valid iterator_traits), begin() and end().\ntemplate <typename DistanceMatcher>\ninline internal::BeginEndDistanceIsMatcher<DistanceMatcher>\nBeginEndDistanceIs(const DistanceMatcher& distance_matcher) {\n  return internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance_matcher);\n}\n\n// Returns a matcher that matches an equal container.\n// This matcher behaves like Eq(), but in the event of mismatch lists the\n// values that are included in one container but not the other. (Duplicate\n// values and order differences are not explained.)\ntemplate <typename Container>\ninline PolymorphicMatcher<internal::ContainerEqMatcher<  // NOLINT\n                            GTEST_REMOVE_CONST_(Container)> >\n    ContainerEq(const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes.\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return MakePolymorphicMatcher(\n      internal::ContainerEqMatcher<RawContainer>(rhs));\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the given comparator, matches container_matcher.\ntemplate <typename Comparator, typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<Comparator, ContainerMatcher>\nWhenSortedBy(const Comparator& comparator,\n             const ContainerMatcher& container_matcher) {\n  return internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(\n      comparator, container_matcher);\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the < operator, matches container_matcher.\ntemplate <typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>\nWhenSorted(const ContainerMatcher& container_matcher) {\n  return\n      internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>(\n          internal::LessComparator(), container_matcher);\n}\n\n// Matches an STL-style container or a native array that contains the\n// same number of elements as in rhs, where its i-th element and rhs's\n// i-th element (as a pair) satisfy the given pair matcher, for all i.\n// TupleMatcher must be able to be safely cast to Matcher<tuple<const\n// T1&, const T2&> >, where T1 and T2 are the types of elements in the\n// LHS container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename Container>\ninline internal::PointwiseMatcher<TupleMatcher,\n                                  GTEST_REMOVE_CONST_(Container)>\nPointwise(const TupleMatcher& tuple_matcher, const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes (e.g. when\n  // rhs is a const int[])..\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return internal::PointwiseMatcher<TupleMatcher, RawContainer>(\n      tuple_matcher, rhs);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the Pointwise(m, {a, b, c}) syntax.\ntemplate <typename TupleMatcher, typename T>\ninline internal::PointwiseMatcher<TupleMatcher, std::vector<T> > Pointwise(\n    const TupleMatcher& tuple_matcher, std::initializer_list<T> rhs) {\n  return Pointwise(tuple_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// UnorderedPointwise(pair_matcher, rhs) matches an STL-style\n// container or a native array that contains the same number of\n// elements as in rhs, where in some permutation of the container, its\n// i-th element and rhs's i-th element (as a pair) satisfy the given\n// pair matcher, for all i.  Tuple2Matcher must be able to be safely\n// cast to Matcher<tuple<const T1&, const T2&> >, where T1 and T2 are\n// the types of elements in the LHS container and the RHS container\n// respectively.\n//\n// This is like Pointwise(pair_matcher, rhs), except that the element\n// order doesn't matter.\ntemplate <typename Tuple2Matcher, typename RhsContainer>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<\n        Tuple2Matcher, typename internal::StlContainerView<GTEST_REMOVE_CONST_(\n                           RhsContainer)>::type::value_type> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   const RhsContainer& rhs_container) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes RhsContainer to be a const type sometimes (e.g. when\n  // rhs_container is a const int[]).\n  typedef GTEST_REMOVE_CONST_(RhsContainer) RawRhsContainer;\n\n  // RhsView allows the same code to handle RhsContainer being a\n  // STL-style container and it being a native C-style array.\n  typedef typename internal::StlContainerView<RawRhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type Second;\n  const RhsStlContainer& rhs_stl_container =\n      RhsView::ConstReference(rhs_container);\n\n  // Create a matcher for each element in rhs_container.\n  ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher, Second> > matchers;\n  for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();\n       it != rhs_stl_container.end(); ++it) {\n    matchers.push_back(\n        internal::MatcherBindSecond(tuple2_matcher, *it));\n  }\n\n  // Delegate the work to UnorderedElementsAreArray().\n  return UnorderedElementsAreArray(matchers);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the UnorderedPointwise(m, {a, b, c}) syntax.\ntemplate <typename Tuple2Matcher, typename T>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<Tuple2Matcher, T> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   std::initializer_list<T> rhs) {\n  return UnorderedPointwise(tuple2_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Matches an STL-style container or a native array that contains at\n// least one element matching the given value or matcher.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   page_ids.insert(3);\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Contains(1));\n//   EXPECT_THAT(page_ids, Contains(Gt(2)));\n//   EXPECT_THAT(page_ids, Not(Contains(4)));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   EXPECT_THAT(page_lengths,\n//               Contains(::std::pair<const int, size_t>(1, 100)));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Contains(Eq(::std::string(\"tom\"))));\ntemplate <typename M>\ninline internal::ContainsMatcher<M> Contains(M matcher) {\n  return internal::ContainsMatcher<M>(matcher);\n}\n\n// Matches an STL-style container or a native array that contains only\n// elements matching the given value or matcher.\n//\n// Each(m) is semantically equivalent to Not(Contains(Not(m))). Only\n// the messages are different.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   // Each(m) matches an empty container, regardless of what m is.\n//   EXPECT_THAT(page_ids, Each(Eq(1)));\n//   EXPECT_THAT(page_ids, Each(Eq(77)));\n//\n//   page_ids.insert(3);\n//   EXPECT_THAT(page_ids, Each(Gt(0)));\n//   EXPECT_THAT(page_ids, Not(Each(Gt(4))));\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Not(Each(Lt(2))));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   page_lengths[2] = 200;\n//   page_lengths[3] = 300;\n//   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));\n//   EXPECT_THAT(page_lengths, Each(Key(Le(3))));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string(\"tom\")))));\ntemplate <typename M>\ninline internal::EachMatcher<M> Each(M matcher) {\n  return internal::EachMatcher<M>(matcher);\n}\n\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename M>\ninline internal::KeyMatcher<M> Key(M inner_matcher) {\n  return internal::KeyMatcher<M>(inner_matcher);\n}\n\n// Pair(first_matcher, second_matcher) matches a std::pair whose 'first' field\n// matches first_matcher and whose 'second' field matches second_matcher.  For\n// example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), \"foo\"))) can be used\n// to match a std::map<int, string> that contains exactly one element whose key\n// is >= 5 and whose value equals \"foo\".\ntemplate <typename FirstMatcher, typename SecondMatcher>\ninline internal::PairMatcher<FirstMatcher, SecondMatcher>\nPair(FirstMatcher first_matcher, SecondMatcher second_matcher) {\n  return internal::PairMatcher<FirstMatcher, SecondMatcher>(\n      first_matcher, second_matcher);\n}\n\n// Returns a predicate that is satisfied by anything that matches the\n// given matcher.\ntemplate <typename M>\ninline internal::MatcherAsPredicate<M> Matches(M matcher) {\n  return internal::MatcherAsPredicate<M>(matcher);\n}\n\n// Returns true iff the value matches the matcher.\ntemplate <typename T, typename M>\ninline bool Value(const T& value, M matcher) {\n  return testing::Matches(matcher)(value);\n}\n\n// Matches the value against the given matcher and explains the match\n// result to listener.\ntemplate <typename T, typename M>\ninline bool ExplainMatchResult(\n    M matcher, const T& value, MatchResultListener* listener) {\n  return SafeMatcherCast<const T&>(matcher).MatchAndExplain(value, listener);\n}\n\n#if GTEST_LANG_CXX11\n// Define variadic matcher versions. They are overloaded in\n// gmock-generated-matchers.h for the cases supported by pre C++11 compilers.\ntemplate <typename... Args>\ninline internal::AllOfMatcher<Args...> AllOf(const Args&... matchers) {\n  return internal::AllOfMatcher<Args...>(matchers...);\n}\n\ntemplate <typename... Args>\ninline internal::AnyOfMatcher<Args...> AnyOf(const Args&... matchers) {\n  return internal::AnyOfMatcher<Args...>(matchers...);\n}\n\n#endif  // GTEST_LANG_CXX11\n\n// AllArgs(m) is a synonym of m.  This is useful in\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));\n//\n// which is easier to read than\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(Eq());\ntemplate <typename InnerMatcher>\ninline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }\n\n// These macros allow using matchers to check values in Google Test\n// tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)\n// succeed iff the value matches the matcher.  If the assertion fails,\n// the value and the description of the matcher will be printed.\n#define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n#define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n\n}  // namespace testing\n\n// Include any custom callback matchers added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-matchers.h\"\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/llvm/unittests/tools/llvm-cfi-verify/FileAnalysis.cpp", "content": "//===- llvm/unittests/tools/llvm-cfi-verify/FileAnalysis.cpp --------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"../tools/llvm-cfi-verify/lib/FileAnalysis.h\"\n#include \"../tools/llvm-cfi-verify/lib/GraphBuilder.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/MC/MCAsmInfo.h\"\n#include \"llvm/MC/MCContext.h\"\n#include \"llvm/MC/MCDisassembler/MCDisassembler.h\"\n#include \"llvm/MC/MCInst.h\"\n#include \"llvm/MC/MCInstPrinter.h\"\n#include \"llvm/MC/MCInstrAnalysis.h\"\n#include \"llvm/MC/MCInstrDesc.h\"\n#include \"llvm/MC/MCInstrInfo.h\"\n#include \"llvm/MC/MCObjectFileInfo.h\"\n#include \"llvm/MC/MCRegisterInfo.h\"\n#include \"llvm/MC/MCSubtargetInfo.h\"\n#include \"llvm/Object/Binary.h\"\n#include \"llvm/Object/COFF.h\"\n#include \"llvm/Object/ELFObjectFile.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/TargetRegistry.h\"\n#include \"llvm/Support/TargetSelect.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <cstdlib>\n\nusing Instr = ::llvm::cfi_verify::FileAnalysis::Instr;\nusing ::testing::Eq;\nusing ::testing::Field;\n\nnamespace llvm {\nnamespace cfi_verify {\nnamespace {\nclass ELFTestFileAnalysis : public FileAnalysis {\npublic:\n  ELFTestFileAnalysis(StringRef Trip)\n      : FileAnalysis(Triple(Trip), SubtargetFeatures()) {}\n\n  // Expose this method publicly for testing.\n  void parseSectionContents(ArrayRef<uint8_t> SectionBytes,\n                            object::SectionedAddress Address) {\n    FileAnalysis::parseSectionContents(SectionBytes, Address);\n  }\n\n  Error initialiseDisassemblyMembers() {\n    return FileAnalysis::initialiseDisassemblyMembers();\n  }\n};\n\nclass BasicFileAnalysisTest : public ::testing::Test {\npublic:\n  BasicFileAnalysisTest(StringRef Trip)\n      : SuccessfullyInitialised(false), Analysis(Trip) {}\nprotected:\n  void SetUp() override {\n    IgnoreDWARFFlag = true;\n    SuccessfullyInitialised = true;\n    if (auto Err = Analysis.initialiseDisassemblyMembers()) {\n      handleAllErrors(std::move(Err), [&](const UnsupportedDisassembly &E) {\n        SuccessfullyInitialised = false;\n        outs()\n            << \"Note: CFIVerifyTests are disabled due to lack of support \"\n               \"on this build.\\n\";\n      });\n    }\n  }\n\n  bool SuccessfullyInitialised;\n  ELFTestFileAnalysis Analysis;\n};\n\nclass BasicX86FileAnalysisTest : public BasicFileAnalysisTest {\npublic:\n  BasicX86FileAnalysisTest() : BasicFileAnalysisTest(\"x86_64--\") {}\n};\n\nclass BasicAArch64FileAnalysisTest : public BasicFileAnalysisTest {\npublic:\n  BasicAArch64FileAnalysisTest() : BasicFileAnalysisTest(\"aarch64--\") {}\n};\n\nTEST_F(BasicX86FileAnalysisTest, BasicDisassemblyTraversalTest) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x90,                   // 0: nop\n          0xb0, 0x00,             // 1: mov $0x0, %al\n          0x48, 0x89, 0xe5,       // 3: mov %rsp, %rbp\n          0x48, 0x83, 0xec, 0x18, // 6: sub $0x18, %rsp\n          0x48, 0xbe, 0xc4, 0x07, 0x40,\n          0x00, 0x00, 0x00, 0x00, 0x00, // 10: movabs $0x4007c4, %rsi\n          0x2f,                         // 20: (bad)\n          0x41, 0x0e,                   // 21: rex.B (bad)\n          0x62, 0x72, 0x65, 0x61, 0x6b, // 23: (bad) {%k1}\n      },\n      {0xDEADBEEF, 0x0});\n\n  EXPECT_EQ(nullptr, Analysis.getInstruction(0x0));\n  EXPECT_EQ(nullptr, Analysis.getInstruction(0x1000));\n\n  // 0xDEADBEEF: nop\n  const auto *InstrMeta = Analysis.getInstruction(0xDEADBEEF);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF, InstrMeta->VMAddress);\n  EXPECT_EQ(1u, InstrMeta->InstructionSize);\n  EXPECT_TRUE(InstrMeta->Valid);\n\n  const auto *NextInstrMeta = Analysis.getNextInstructionSequential(*InstrMeta);\n  EXPECT_EQ(nullptr, Analysis.getPrevInstructionSequential(*InstrMeta));\n  const auto *PrevInstrMeta = InstrMeta;\n\n  // 0xDEADBEEF + 1: mov $0x0, %al\n  InstrMeta = Analysis.getInstruction(0xDEADBEEF + 1);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(NextInstrMeta, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 1, InstrMeta->VMAddress);\n  EXPECT_EQ(2u, InstrMeta->InstructionSize);\n  EXPECT_TRUE(InstrMeta->Valid);\n\n  NextInstrMeta = Analysis.getNextInstructionSequential(*InstrMeta);\n  EXPECT_EQ(PrevInstrMeta, Analysis.getPrevInstructionSequential(*InstrMeta));\n  PrevInstrMeta = InstrMeta;\n\n  // 0xDEADBEEF + 3: mov %rsp, %rbp\n  InstrMeta = Analysis.getInstruction(0xDEADBEEF + 3);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(NextInstrMeta, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 3, InstrMeta->VMAddress);\n  EXPECT_EQ(3u, InstrMeta->InstructionSize);\n  EXPECT_TRUE(InstrMeta->Valid);\n\n  NextInstrMeta = Analysis.getNextInstructionSequential(*InstrMeta);\n  EXPECT_EQ(PrevInstrMeta, Analysis.getPrevInstructionSequential(*InstrMeta));\n  PrevInstrMeta = InstrMeta;\n\n  // 0xDEADBEEF + 6: sub $0x18, %rsp\n  InstrMeta = Analysis.getInstruction(0xDEADBEEF + 6);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(NextInstrMeta, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 6, InstrMeta->VMAddress);\n  EXPECT_EQ(4u, InstrMeta->InstructionSize);\n  EXPECT_TRUE(InstrMeta->Valid);\n\n  NextInstrMeta = Analysis.getNextInstructionSequential(*InstrMeta);\n  EXPECT_EQ(PrevInstrMeta, Analysis.getPrevInstructionSequential(*InstrMeta));\n  PrevInstrMeta = InstrMeta;\n\n  // 0xDEADBEEF + 10: movabs $0x4007c4, %rsi\n  InstrMeta = Analysis.getInstruction(0xDEADBEEF + 10);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(NextInstrMeta, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 10, InstrMeta->VMAddress);\n  EXPECT_EQ(10u, InstrMeta->InstructionSize);\n  EXPECT_TRUE(InstrMeta->Valid);\n\n  EXPECT_EQ(nullptr, Analysis.getNextInstructionSequential(*InstrMeta));\n  EXPECT_EQ(PrevInstrMeta, Analysis.getPrevInstructionSequential(*InstrMeta));\n  PrevInstrMeta = InstrMeta;\n\n  // 0xDEADBEEF + 20: (bad)\n  InstrMeta = Analysis.getInstruction(0xDEADBEEF + 20);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 20, InstrMeta->VMAddress);\n  EXPECT_EQ(1u, InstrMeta->InstructionSize);\n  EXPECT_FALSE(InstrMeta->Valid);\n\n  EXPECT_EQ(nullptr, Analysis.getNextInstructionSequential(*InstrMeta));\n  EXPECT_EQ(PrevInstrMeta, Analysis.getPrevInstructionSequential(*InstrMeta));\n\n  // 0xDEADBEEF + 21: rex.B (bad)\n  InstrMeta = Analysis.getInstruction(0xDEADBEEF + 21);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 21, InstrMeta->VMAddress);\n  EXPECT_EQ(2u, InstrMeta->InstructionSize);\n  EXPECT_FALSE(InstrMeta->Valid);\n\n  EXPECT_EQ(nullptr, Analysis.getNextInstructionSequential(*InstrMeta));\n  EXPECT_EQ(nullptr, Analysis.getPrevInstructionSequential(*InstrMeta));\n\n  // 0xDEADBEEF + 6: (bad) {%k1}\n  InstrMeta = Analysis.getInstruction(0xDEADBEEF + 23);\n  EXPECT_NE(nullptr, InstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 23, InstrMeta->VMAddress);\n  EXPECT_EQ(5u, InstrMeta->InstructionSize);\n  EXPECT_FALSE(InstrMeta->Valid);\n\n  EXPECT_EQ(nullptr, Analysis.getNextInstructionSequential(*InstrMeta));\n  EXPECT_EQ(nullptr, Analysis.getPrevInstructionSequential(*InstrMeta));\n}\n\nTEST_F(BasicX86FileAnalysisTest, PrevAndNextFromBadInst) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x90, // 0: nop\n          0x2f, // 1: (bad)\n          0x90  // 2: nop\n      },\n      {0xDEADBEEF, 0x0});\n  const auto &BadInstrMeta = Analysis.getInstructionOrDie(0xDEADBEEF + 1);\n  const auto *GoodInstrMeta =\n      Analysis.getPrevInstructionSequential(BadInstrMeta);\n  EXPECT_NE(nullptr, GoodInstrMeta);\n  EXPECT_EQ(0xDEADBEEF, GoodInstrMeta->VMAddress);\n  EXPECT_EQ(1u, GoodInstrMeta->InstructionSize);\n\n  GoodInstrMeta = Analysis.getNextInstructionSequential(BadInstrMeta);\n  EXPECT_NE(nullptr, GoodInstrMeta);\n  EXPECT_EQ(0xDEADBEEF + 2, GoodInstrMeta->VMAddress);\n  EXPECT_EQ(1u, GoodInstrMeta->InstructionSize);\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFITrapTest) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x90,                   // 0: nop\n          0xb0, 0x00,             // 1: mov $0x0, %al\n          0x48, 0x89, 0xe5,       // 3: mov %rsp, %rbp\n          0x48, 0x83, 0xec, 0x18, // 6: sub $0x18, %rsp\n          0x48, 0xbe, 0xc4, 0x07, 0x40,\n          0x00, 0x00, 0x00, 0x00, 0x00, // 10: movabs $0x4007c4, %rsi\n          0x2f,                         // 20: (bad)\n          0x41, 0x0e,                   // 21: rex.B (bad)\n          0x62, 0x72, 0x65, 0x61, 0x6b, // 23: (bad) {%k1}\n          0x0f, 0x0b                    // 28: ud2\n      },\n      {0xDEADBEEF, 0x0});\n\n  EXPECT_FALSE(Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF)));\n  EXPECT_FALSE(\n      Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF + 3)));\n  EXPECT_FALSE(\n      Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF + 6)));\n  EXPECT_FALSE(\n      Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF + 10)));\n  EXPECT_FALSE(\n      Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF + 20)));\n  EXPECT_FALSE(\n      Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF + 21)));\n  EXPECT_FALSE(\n      Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF + 23)));\n  EXPECT_TRUE(\n      Analysis.isCFITrap(Analysis.getInstructionOrDie(0xDEADBEEF + 28)));\n}\n\nTEST_F(BasicX86FileAnalysisTest, FallThroughTest) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x90,                         // 0: nop\n          0xb0, 0x00,                   // 1: mov $0x0, %al\n          0x2f,                         // 3: (bad)\n          0x0f, 0x0b,                   // 4: ud2\n          0xff, 0x20,                   // 6: jmpq *(%rax)\n          0xeb, 0x00,                   // 8: jmp +0\n          0xe8, 0x45, 0xfe, 0xff, 0xff, // 10: callq [some loc]\n          0xff, 0x10,                   // 15: callq *(rax)\n          0x75, 0x00,                   // 17: jne +0\n          0xc3,                         // 19: retq\n      },\n      {0xDEADBEEF, 0x0});\n\n  EXPECT_TRUE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF)));\n  EXPECT_TRUE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 1)));\n  EXPECT_FALSE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 3)));\n  EXPECT_FALSE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 4)));\n  EXPECT_FALSE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 6)));\n  EXPECT_FALSE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 8)));\n  EXPECT_FALSE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 10)));\n  EXPECT_FALSE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 15)));\n  EXPECT_TRUE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 17)));\n  EXPECT_FALSE(\n      Analysis.canFallThrough(Analysis.getInstructionOrDie(0xDEADBEEF + 19)));\n}\n\nTEST_F(BasicX86FileAnalysisTest, DefiniteNextInstructionTest) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x90,                         // 0: nop\n          0xb0, 0x00,                   // 1: mov $0x0, %al\n          0x2f,                         // 3: (bad)\n          0x0f, 0x0b,                   // 4: ud2\n          0xff, 0x20,                   // 6: jmpq *(%rax)\n          0xeb, 0x00,                   // 8: jmp 10 [+0]\n          0xeb, 0x05,                   // 10: jmp 17 [+5]\n          0xe8, 0x00, 0x00, 0x00, 0x00, // 12: callq 17 [+0]\n          0xe8, 0x78, 0x56, 0x34, 0x12, // 17: callq 0x1234569f [+0x12345678]\n          0xe8, 0x04, 0x00, 0x00, 0x00, // 22: callq 31 [+4]\n          0xff, 0x10,                   // 27: callq *(rax)\n          0x75, 0x00,                   // 29: jne 31 [+0]\n          0x75, 0xe0,                   // 31: jne 1 [-32]\n          0xc3,                         // 33: retq\n          0xeb, 0xdd,                   // 34: jmp 1 [-35]\n          0xeb, 0xdd,                   // 36: jmp 3 [-35]\n          0xeb, 0xdc,                   // 38: jmp 4 [-36]\n      },\n      {0xDEADBEEF, 0x0});\n\n  const auto *Current = Analysis.getInstruction(0xDEADBEEF);\n  const auto *Next = Analysis.getDefiniteNextInstruction(*Current);\n  EXPECT_NE(nullptr, Next);\n  EXPECT_EQ(0xDEADBEEF + 1, Next->VMAddress);\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 1);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 3);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 4);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 6);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 8);\n  Next = Analysis.getDefiniteNextInstruction(*Current);\n  EXPECT_NE(nullptr, Next);\n  EXPECT_EQ(0xDEADBEEF + 10, Next->VMAddress);\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 10);\n  Next = Analysis.getDefiniteNextInstruction(*Current);\n  EXPECT_NE(nullptr, Next);\n  EXPECT_EQ(0xDEADBEEF + 17, Next->VMAddress);\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 12);\n  Next = Analysis.getDefiniteNextInstruction(*Current);\n  EXPECT_NE(nullptr, Next);\n  EXPECT_EQ(0xDEADBEEF + 17, Next->VMAddress);\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 17);\n  // Note, definite next instruction address is out of range and should fail.\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n  Next = Analysis.getDefiniteNextInstruction(*Current);\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 22);\n  Next = Analysis.getDefiniteNextInstruction(*Current);\n  EXPECT_NE(nullptr, Next);\n  EXPECT_EQ(0xDEADBEEF + 31, Next->VMAddress);\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 27);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n  Current = Analysis.getInstruction(0xDEADBEEF + 29);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n  Current = Analysis.getInstruction(0xDEADBEEF + 31);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n  Current = Analysis.getInstruction(0xDEADBEEF + 33);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 34);\n  Next = Analysis.getDefiniteNextInstruction(*Current);\n  EXPECT_NE(nullptr, Next);\n  EXPECT_EQ(0xDEADBEEF + 1, Next->VMAddress);\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 36);\n  EXPECT_EQ(nullptr, Analysis.getDefiniteNextInstruction(*Current));\n\n  Current = Analysis.getInstruction(0xDEADBEEF + 38);\n  Next = Analysis.getDefiniteNextInstruction(*Current);\n  EXPECT_NE(nullptr, Next);\n  EXPECT_EQ(0xDEADBEEF + 4, Next->VMAddress);\n}\n\nTEST_F(BasicX86FileAnalysisTest, ControlFlowXRefsTest) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x90,                         // 0: nop\n          0xb0, 0x00,                   // 1: mov $0x0, %al\n          0x2f,                         // 3: (bad)\n          0x0f, 0x0b,                   // 4: ud2\n          0xff, 0x20,                   // 6: jmpq *(%rax)\n          0xeb, 0x00,                   // 8: jmp 10 [+0]\n          0xeb, 0x05,                   // 10: jmp 17 [+5]\n          0xe8, 0x00, 0x00, 0x00, 0x00, // 12: callq 17 [+0]\n          0xe8, 0x78, 0x56, 0x34, 0x12, // 17: callq 0x1234569f [+0x12345678]\n          0xe8, 0x04, 0x00, 0x00, 0x00, // 22: callq 31 [+4]\n          0xff, 0x10,                   // 27: callq *(rax)\n          0x75, 0x00,                   // 29: jne 31 [+0]\n          0x75, 0xe0,                   // 31: jne 1 [-32]\n          0xc3,                         // 33: retq\n          0xeb, 0xdd,                   // 34: jmp 1 [-35]\n          0xeb, 0xdd,                   // 36: jmp 3 [-35]\n          0xeb, 0xdc,                   // 38: jmp 4 [-36]\n      },\n      {0xDEADBEEF, 0x0});\n  const auto *InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF);\n  std::set<const Instr *> XRefs =\n      Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(XRefs.empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 1);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_THAT(XRefs, UnorderedElementsAre(\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF)),\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 31)),\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 34))));\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 3);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_THAT(XRefs, UnorderedElementsAre(\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 1)),\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 36))));\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 4);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_THAT(XRefs, UnorderedElementsAre(\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 38))));\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 6);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 8);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 10);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_THAT(XRefs, UnorderedElementsAre(\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 8))));\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 12);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 17);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_THAT(XRefs, UnorderedElementsAre(\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 10)),\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 12))));\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 22);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 27);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 29);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 31);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_THAT(XRefs, UnorderedElementsAre(\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 22)),\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 29))));\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 33);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_THAT(XRefs, UnorderedElementsAre(\n                         Field(&Instr::VMAddress, Eq(0xDEADBEEF + 31))));\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 34);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 36);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n\n  InstrMetaPtr = &Analysis.getInstructionOrDie(0xDEADBEEF + 38);\n  XRefs = Analysis.getDirectControlFlowXRefs(*InstrMetaPtr);\n  EXPECT_TRUE(Analysis.getDirectControlFlowXRefs(*InstrMetaPtr).empty());\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionInvalidTargets) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x90,       // 0: nop\n          0x0f, 0x0b, // 1: ud2\n          0x75, 0x00, // 3: jne 5 [+0]\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_NOT_INDIRECT_CF,\n            Analysis.validateCFIProtection(Result));\n  Result = GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 1, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_NOT_INDIRECT_CF,\n            Analysis.validateCFIProtection(Result));\n  Result = GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 3, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_NOT_INDIRECT_CF,\n            Analysis.validateCFIProtection(Result));\n  Result = GraphBuilder::buildFlowGraph(Analysis, {0x12345678, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_INVALID_INSTRUCTION,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionBasicFallthroughToUd2) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x02, // 0: jne 4 [+2]\n          0x0f, 0x0b, // 2: ud2\n          0xff, 0x10, // 4: callq *(%rax)\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 4, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionBasicJumpToUd2) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x02, // 0: jne 4 [+2]\n          0xff, 0x10, // 2: callq *(%rax)\n          0x0f, 0x0b, // 4: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 2, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionDualPathUd2) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x03, // 0: jne 5 [+3]\n          0x90,       // 2: nop\n          0xff, 0x10, // 3: callq *(%rax)\n          0x0f, 0x0b, // 5: ud2\n          0x75, 0xf9, // 7: jne 2 [-7]\n          0x0f, 0x0b, // 9: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 3, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionDualPathSingleUd2) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x05, // 0: jne 7 [+5]\n          0x90,       // 2: nop\n          0xff, 0x10, // 3: callq *(%rax)\n          0x75, 0xfb, // 5: jne 2 [-5]\n          0x0f, 0x0b, // 7: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 3, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionDualFailLimitUpwards) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x06, // 0: jne 8 [+6]\n          0x90,       // 2: nop\n          0x90,       // 3: nop\n          0x90,       // 4: nop\n          0x90,       // 5: nop\n          0xff, 0x10, // 6: callq *(%rax)\n          0x0f, 0x0b, // 8: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  uint64_t PrevSearchLengthForConditionalBranch =\n      SearchLengthForConditionalBranch;\n  SearchLengthForConditionalBranch = 2;\n\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 6, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_ORPHANS,\n            Analysis.validateCFIProtection(Result));\n\n  SearchLengthForConditionalBranch = PrevSearchLengthForConditionalBranch;\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionDualFailLimitDownwards) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x02, // 0: jne 4 [+2]\n          0xff, 0x10, // 2: callq *(%rax)\n          0x90,       // 4: nop\n          0x90,       // 5: nop\n          0x90,       // 6: nop\n          0x90,       // 7: nop\n          0x0f, 0x0b, // 8: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  uint64_t PrevSearchLengthForUndef = SearchLengthForUndef;\n  SearchLengthForUndef = 2;\n\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 2, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_BAD_CONDITIONAL_BRANCH,\n            Analysis.validateCFIProtection(Result));\n\n  SearchLengthForUndef = PrevSearchLengthForUndef;\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionGoodAndBadPaths) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0xeb, 0x02, // 0: jmp 4 [+2]\n          0x75, 0x02, // 2: jne 6 [+2]\n          0xff, 0x10, // 4: callq *(%rax)\n          0x0f, 0x0b, // 6: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 4, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_ORPHANS,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionWithUnconditionalJumpInFallthrough) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x04, // 0: jne 6 [+4]\n          0xeb, 0x00, // 2: jmp 4 [+0]\n          0xff, 0x10, // 4: callq *(%rax)\n          0x0f, 0x0b, // 6: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 4, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionComplexExample) {\n  if (!SuccessfullyInitialised)\n    return;\n  // See unittests/GraphBuilder.cpp::BuildFlowGraphComplexExample for this\n  // graph.\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x12,                   // 0: jne 20 [+18]\n          0xeb, 0x03,                   // 2: jmp 7 [+3]\n          0x75, 0x10,                   // 4: jne 22 [+16]\n          0x90,                         // 6: nop\n          0x90,                         // 7: nop\n          0x90,                         // 8: nop\n          0xff, 0x10,                   // 9: callq *(%rax)\n          0xeb, 0xfc,                   // 11: jmp 9 [-4]\n          0x75, 0xfa,                   // 13: jne 9 [-6]\n          0xe8, 0x78, 0x56, 0x34, 0x12, // 15: callq OUTOFBOUNDS [+0x12345678]\n          0x90,                         // 20: nop\n          0x90,                         // 21: nop\n          0x0f, 0x0b,                   // 22: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  uint64_t PrevSearchLengthForUndef = SearchLengthForUndef;\n  SearchLengthForUndef = 5;\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 9, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_ORPHANS,\n            Analysis.validateCFIProtection(Result));\n  SearchLengthForUndef = PrevSearchLengthForUndef;\n}\n\nTEST_F(BasicX86FileAnalysisTest, UndefSearchLengthOneTest) {\n  Analysis.parseSectionContents(\n      {\n          0x77, 0x0d,                   // 0x688118: ja 0x688127 [+12]\n          0x48, 0x89, 0xdf,             // 0x68811a: mov %rbx, %rdi\n          0xff, 0xd0,                   // 0x68811d: callq *%rax\n          0x48, 0x89, 0xdf,             // 0x68811f: mov %rbx, %rdi\n          0xe8, 0x09, 0x00, 0x00, 0x00, // 0x688122: callq 0x688130\n          0x0f, 0x0b,                   // 0x688127: ud2\n      },\n      {0x688118, 0x0});\n  uint64_t PrevSearchLengthForUndef = SearchLengthForUndef;\n  SearchLengthForUndef = 1;\n  GraphResult Result = GraphBuilder::buildFlowGraph(Analysis, {0x68811d, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n  SearchLengthForUndef = PrevSearchLengthForUndef;\n}\n\nTEST_F(BasicX86FileAnalysisTest, UndefSearchLengthOneTestFarAway) {\n  Analysis.parseSectionContents(\n      {\n          0x74, 0x73,                         // 0x7759eb: je 0x775a60\n          0xe9, 0x1c, 0x04, 0x00, 0x00, 0x00, // 0x7759ed: jmpq 0x775e0e\n      },\n      {0x7759eb, 0x0});\n\n  Analysis.parseSectionContents(\n      {\n          0x0f, 0x85, 0xb2, 0x03, 0x00, 0x00, // 0x775a56: jne    0x775e0e\n          0x48, 0x83, 0xc3, 0xf4, // 0x775a5c: add    $0xfffffffffffffff4,%rbx\n          0x48, 0x8b, 0x7c, 0x24, 0x10, // 0x775a60: mov    0x10(%rsp),%rdi\n          0x48, 0x89, 0xde,             // 0x775a65: mov    %rbx,%rsi\n          0xff, 0xd1,                   // 0x775a68: callq  *%rcx\n      },\n      {0x775a56, 0x0});\n\n  Analysis.parseSectionContents(\n      {\n          0x0f, 0x0b, // 0x775e0e: ud2\n      },\n      {0x775e0e, 0x0});\n  uint64_t PrevSearchLengthForUndef = SearchLengthForUndef;\n  SearchLengthForUndef = 1;\n  GraphResult Result = GraphBuilder::buildFlowGraph(Analysis, {0x775a68, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_BAD_CONDITIONAL_BRANCH,\n            Analysis.validateCFIProtection(Result));\n  SearchLengthForUndef = 2;\n  Result = GraphBuilder::buildFlowGraph(Analysis, {0x775a68, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n  SearchLengthForUndef = 3;\n  Result = GraphBuilder::buildFlowGraph(Analysis, {0x775a68, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n  SearchLengthForUndef = PrevSearchLengthForUndef;\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionClobberSinglePathExplicit) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x02,                         // 0: jne 4 [+2]\n          0x0f, 0x0b,                         // 2: ud2\n          0x48, 0x05, 0x00, 0x00, 0x00, 0x00, // 4: add $0x0, %rax\n          0xff, 0x10,                         // 10: callq *(%rax)\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 10, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionClobberSinglePathExplicit2) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x02,             // 0: jne 4 [+2]\n          0x0f, 0x0b,             // 2: ud2\n          0x48, 0x83, 0xc0, 0x00, // 4: add $0x0, %rax\n          0xff, 0x10,             // 8: callq *(%rax)\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 8, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionClobberSinglePathImplicit) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x02,                   // 0: jne 4 [+2]\n          0x0f, 0x0b,                   // 2: ud2\n          0x05, 0x00, 0x00, 0x00, 0x00, // 4: add $0x0, %eax\n          0xff, 0x10,                   // 9: callq *(%rax)\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 9, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicX86FileAnalysisTest, CFIProtectionClobberDualPathImplicit) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x75, 0x04, // 0: jne 6 [+4]\n          0x0f, 0x31, // 2: rdtsc (note: affects eax)\n          0xff, 0x10, // 4: callq *(%rax)\n          0x0f, 0x0b, // 6: ud2\n          0x75, 0xf9, // 8: jne 2 [-7]\n          0x0f, 0x0b, // 10: ud2\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 4, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64BasicUnprotected) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x00, 0x01, 0x3f, 0xd6, // 0: blr x8\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_ORPHANS,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64BasicProtected) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x00, 0x01, 0x3f, 0xd6, // 8: blr x8\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 8, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberBasic) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x08, 0x05, 0x00, 0x91, // 8: add x8, x8, #1\n          0x00, 0x01, 0x3f, 0xd6, // 12: blr x8\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 12, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberOneLoad) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x21, 0x09, 0x40, 0xf9, // 8: ldr x1, [x9,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 12: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 12, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberLoadAddGood) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x21, 0x04, 0x00, 0x91, // 8: add x1, x1, #1\n          0x21, 0x09, 0x40, 0xf9, // 12: ldr x1, [x9,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 16: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 16, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberLoadAddBad) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x21, 0x09, 0x40, 0xf9, // 8: ldr x1, [x9,#16]\n          0x21, 0x04, 0x00, 0x91, // 12: add x1, x1, #1\n          0x20, 0x00, 0x1f, 0xd6, // 16: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 16, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberLoadAddBad2) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x29, 0x04, 0x00, 0x91, // 16: add x9, x1, #1\n          0x21, 0x09, 0x40, 0xf9, // 12: ldr x1, [x9,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 16: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 16, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberTwoLoads) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x21, 0x09, 0x40, 0xf9, // 8: ldr x1, [x9,#16]\n          0x21, 0x08, 0x40, 0xf9, // 12: ldr x1, [x1,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 16: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 16, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberUnrelatedSecondLoad) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x21, 0x09, 0x40, 0xf9, // 8: ldr x1, [x9,#16]\n          0x21, 0x09, 0x40, 0xf9, // 12: ldr x1, [x9,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 16: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 16, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64ClobberUnrelatedLoads) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x49, 0x00, 0x00, 0x54, // 0: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 4: brk #0x1\n          0x22, 0x09, 0x40, 0xf9, // 8: ldr x2, [x9,#16]\n          0x22, 0x08, 0x40, 0xf9, // 12: ldr x2, [x1,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 16: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 16, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64GoodAndBadPaths) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0x03, 0x00, 0x00, 0x14, // 0: b 12\n          0x49, 0x00, 0x00, 0x54, // 4: b.ls 8\n          0x20, 0x00, 0x20, 0xd4, // 8: brk #0x1\n          0x20, 0x00, 0x1f, 0xd6, // 12: br x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 12, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_ORPHANS,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64TwoPaths) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0xc9, 0x00, 0x00, 0x54, // 0: b.ls 24\n          0x21, 0x08, 0x40, 0xf9, // 4: ldr x1, [x1,#16]\n          0x03, 0x00, 0x00, 0x14, // 8: b 12\n          0x69, 0x00, 0x00, 0x54, // 12: b.ls 12\n          0x21, 0x08, 0x40, 0xf9, // 16: ldr x1, [x1,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 20: br x1\n          0x20, 0x00, 0x20, 0xd4, // 24: brk #0x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 20, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::PROTECTED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64TwoPathsBadLoad1) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0xe9, 0x00, 0x00, 0x54, // 0: b.ls 28\n          0x21, 0x08, 0x40, 0xf9, // 4: ldr x1, [x1,#16]\n          0x21, 0x08, 0x40, 0xf9, // 8: ldr x1, [x1,#16]\n          0x03, 0x00, 0x00, 0x14, // 12: b 12\n          0x69, 0x00, 0x00, 0x54, // 16: b.ls 12\n          0x21, 0x08, 0x40, 0xf9, // 20: ldr x1, [x1,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 24: br x1\n          0x20, 0x00, 0x20, 0xd4, // 28: brk #0x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 24, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\nTEST_F(BasicAArch64FileAnalysisTest, AArch64TwoPathsBadLoad2) {\n  if (!SuccessfullyInitialised)\n    return;\n  Analysis.parseSectionContents(\n      {\n          0xe9, 0x00, 0x00, 0x54, // 0: b.ls 28\n          0x21, 0x08, 0x40, 0xf9, // 4: ldr x1, [x1,#16]\n          0x03, 0x00, 0x00, 0x14, // 8: b 12\n          0x89, 0x00, 0x00, 0x54, // 12: b.ls 16\n          0x21, 0x08, 0x40, 0xf9, // 16: ldr x1, [x1,#16]\n          0x21, 0x08, 0x40, 0xf9, // 20: ldr x1, [x1,#16]\n          0x20, 0x00, 0x1f, 0xd6, // 24: br x1\n          0x20, 0x00, 0x20, 0xd4, // 28: brk #0x1\n      },\n      {0xDEADBEEF, 0x0});\n  GraphResult Result =\n      GraphBuilder::buildFlowGraph(Analysis, {0xDEADBEEF + 24, 0x0});\n  EXPECT_EQ(CFIProtectionStatus::FAIL_REGISTER_CLOBBERED,\n            Analysis.validateCFIProtection(Result));\n}\n\n} // anonymous namespace\n} // end namespace cfi_verify\n} // end namespace llvm\n\nint main(int argc, char **argv) {\n  ::testing::InitGoogleTest(&argc, argv);\n  llvm::cl::ParseCommandLineOptions(argc, argv);\n\n  llvm::InitializeAllTargetInfos();\n  llvm::InitializeAllTargetMCs();\n  llvm::InitializeAllAsmParsers();\n  llvm::InitializeAllDisassemblers();\n\n  return RUN_ALL_TESTS();\n}\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_pred_impl.h", "content": "// Copyright 2006, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// This file is AUTOMATICALLY GENERATED on 10/31/2011 by command\n// 'gen_gtest_pred_impl.py 5'.  DO NOT EDIT BY HAND!\n//\n// Implements a family of generic predicate assertion macros.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n\n// Makes sure this header is not included before gtest.h.\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n# error Do not include gtest_pred_impl.h directly.  Include gtest.h instead.\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n\n// This header implements a family of generic predicate assertion\n// macros:\n//\n//   ASSERT_PRED_FORMAT1(pred_format, v1)\n//   ASSERT_PRED_FORMAT2(pred_format, v1, v2)\n//   ...\n//\n// where pred_format is a function or functor that takes n (in the\n// case of ASSERT_PRED_FORMATn) values and their source expression\n// text, and returns a testing::AssertionResult.  See the definition\n// of ASSERT_EQ in gtest.h for an example.\n//\n// If you don't care about formatting, you can use the more\n// restrictive version:\n//\n//   ASSERT_PRED1(pred, v1)\n//   ASSERT_PRED2(pred, v1, v2)\n//   ...\n//\n// where pred is an n-ary function or functor that returns bool,\n// and the values v1, v2, ..., must support the << operator for\n// streaming to std::ostream.\n//\n// We also define the EXPECT_* variations.\n//\n// For now we only support predicates whose arity is at most 5.\n// Please email googletestframework@googlegroups.com if you need\n// support for higher arities.\n\n// GTEST_ASSERT_ is the basic statement to which all of the assertions\n// in this file reduce.  Don't use this in your code.\n\n#define GTEST_ASSERT_(expression, on_failure) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar = (expression)) \\\n    ; \\\n  else \\\n    on_failure(gtest_ar.failure_message())\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1>\nAssertionResult AssertPred1Helper(const char* pred_text,\n                                  const char* e1,\n                                  Pred pred,\n                                  const T1& v1) {\n  if (pred(v1)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT1.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT1_(pred_format, v1, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, v1), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\n#define GTEST_PRED1_(pred, v1, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred1Helper(#pred, \\\n                                             #v1, \\\n                                             pred, \\\n                                             v1), on_failure)\n\n// Unary predicate assertion macros.\n#define EXPECT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2>\nAssertionResult AssertPred2Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2) {\n  if (pred(v1, v2)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT2.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT2_(pred_format, v1, v2, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\n#define GTEST_PRED2_(pred, v1, v2, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred2Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2), on_failure)\n\n// Binary predicate assertion macros.\n#define EXPECT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3>\nAssertionResult AssertPred3Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3) {\n  if (pred(v1, v2, v3)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT3.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\n#define GTEST_PRED3_(pred, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred3Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3), on_failure)\n\n// Ternary predicate assertion macros.\n#define EXPECT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4>\nAssertionResult AssertPred4Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4) {\n  if (pred(v1, v2, v3, v4)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT4.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, v1, v2, v3, v4), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\n#define GTEST_PRED4_(pred, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred4Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4), on_failure)\n\n// 4-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4,\n          typename T5>\nAssertionResult AssertPred5Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  const char* e5,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4,\n                                  const T5& v5) {\n  if (pred(v1, v2, v3, v4, v5)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \", \"\n                            << e5 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4\n                            << \"\\n\" << e5 << \" evaluates to \" << v5;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT5.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, #v5, v1, v2, v3, v4, v5), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\n#define GTEST_PRED5_(pred, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred5Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             #v5, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4, \\\n                                             v5), on_failure)\n\n// 5-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n\n\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 17, "file": 12, "line": 128}, "message": "in implicit copy constructor for 'testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>' first required here"}, {"location": {"col": 17, "file": 12, "line": 351}, "message": "in defaulted copy constructor for 'std::_Head_base<2, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, false>' first required here"}, {"location": {"col": 17, "file": 12, "line": 220}, "message": "in defaulted copy constructor for 'std::_Tuple_impl<2, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 17, "file": 12, "line": 220}, "message": "in defaulted copy constructor for 'std::_Tuple_impl<1, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 17, "file": 12, "line": 640}, "message": "in defaulted copy constructor for 'std::_Tuple_impl<0, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 7, "file": 11, "line": 3463}, "message": "in defaulted copy constructor for 'std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 22, "file": 13, "line": 424}, "message": "in implicit copy constructor for 'testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' first required here"}, {"location": {"col": 3, "file": 11, "line": 475}, "message": "definition of implicit copy constructor for 'PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "6ba172f057cf664d0eb7b839bbb8d313", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 7, "file": 11, "line": 929}, "message": "in implicit copy constructor for 'testing::internal::ComparisonBase<testing::internal::EqMatcher<unsigned int>, unsigned int, testing::internal::AnyEq>' first required here"}, {"location": {"col": 48, "file": 11, "line": 3766}, "message": "in implicit move constructor for 'testing::internal::EqMatcher<unsigned int>' first required here"}, {"location": {"col": 51, "file": 13, "line": 425}, "message": "in instantiation of function template specialization 'testing::Eq<unsigned int>' requested here"}, {"location": {"col": 3, "file": 11, "line": 925}, "message": "definition of implicit copy constructor for 'ComparisonBase<testing::internal::EqMatcher<unsigned int>, unsigned int, testing::internal::AnyEq>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "b2168a2f36f7bd0d4acc93e55491f661", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 11, "line": 4366}, "message": "in implicit copy constructor for 'testing::internal::MatcherAsPredicate<testing::Matcher<const llvm::cfi_verify::FileAnalysis::Instr *const &>>' first required here"}, {"location": {"col": 29, "file": 11, "line": 3432}, "message": "in instantiation of function template specialization 'testing::Matches<testing::Matcher<const llvm::cfi_verify::FileAnalysis::Instr *const &>>' requested here"}, {"location": {"col": 26, "file": 11, "line": 3392}, "message": "in instantiation of function template specialization 'testing::internal::UnorderedElementsAreMatcherImpl<const std::set<const llvm::cfi_verify::FileAnalysis::Instr *> &>::AnalyzeElements<std::_Rb_tree_const_iterator<const llvm::cfi_verify::FileAnalysis::Instr *>>' requested here"}, {"location": {"col": 3, "file": 11, "line": 3371}, "message": "in instantiation of member function 'testing::internal::UnorderedElementsAreMatcherImpl<const std::set<const llvm::cfi_verify::FileAnalysis::Instr *> &>::MatchAndExplain' requested here"}, {"location": {"col": 28, "file": 11, "line": 3483}, "message": "in instantiation of function template specialization 'testing::internal::UnorderedElementsAreMatcherImpl<const std::set<const llvm::cfi_verify::FileAnalysis::Instr *> &>::UnorderedElementsAreMatcherImpl<__gnu_cxx::__normal_iterator<testing::Matcher<const llvm::cfi_verify::FileAnalysis::Instr *const &> *, std::vector<testing::Matcher<const llvm::cfi_verify::FileAnalysis::Instr *const &>>>>' requested here"}, {"location": {"col": 12, "file": 11, "line": 557}, "message": "(skipping 1 context in backtrace; use -ftemplate-backtrace-limit=0 to see all)"}, {"location": {"col": 12, "file": 11, "line": 533}, "message": "in instantiation of member function 'testing::internal::MatcherCastImpl<const std::set<const llvm::cfi_verify::FileAnalysis::Instr *> &, testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>::CastImpl' requested here"}, {"location": {"col": 45, "file": 11, "line": 630}, "message": "in instantiation of member function 'testing::internal::MatcherCastImpl<const std::set<const llvm::cfi_verify::FileAnalysis::Instr *> &, testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>::Cast' requested here"}, {"location": {"col": 34, "file": 11, "line": 668}, "message": "in instantiation of function template specialization 'testing::SafeMatcherCastImpl<const std::set<const llvm::cfi_verify::FileAnalysis::Instr *> &>::Cast<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' requested here"}, {"location": {"col": 39, "file": 11, "line": 1856}, "message": "in instantiation of function template specialization 'testing::SafeMatcherCast<const std::set<const llvm::cfi_verify::FileAnalysis::Instr *> &, testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' requested here"}, {"location": {"col": 3, "file": 13, "line": 424}, "message": "in instantiation of function template specialization 'testing::internal::PredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>::operator()<std::set<const llvm::cfi_verify::FileAnalysis::Instr *>>' requested here"}, {"location": {"col": 37, "file": 11, "line": 4414}, "message": "expanded from macro 'EXPECT_THAT'"}, {"location": {"col": 3, "file": 14, "line": 114}, "message": "expanded from macro 'EXPECT_PRED_FORMAT1'"}, {"location": {"col": 28, "file": 14, "line": 101}, "message": "expanded from macro 'GTEST_PRED_FORMAT1_'"}, {"location": {"col": 3, "file": 11, "line": 1830}, "message": "definition of implicit copy constructor for 'MatcherAsPredicate<testing::Matcher<const llvm::cfi_verify::FileAnalysis::Instr *const &>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "b7c7cb5f8182e0fb3a9ef17a96cd518b", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 11, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' first required here"}, {"location": {"col": 3, "file": 13, "line": 424}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' requested here"}, {"location": {"col": 26, "file": 11, "line": 4415}, "message": "expanded from macro 'EXPECT_THAT'"}, {"location": {"col": 3, "file": 11, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "65188c4bb67d13a501a9a974721c64a3", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 11, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' first required here"}, {"location": {"col": 3, "file": 13, "line": 431}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' requested here"}, {"location": {"col": 26, "file": 11, "line": 4415}, "message": "expanded from macro 'EXPECT_THAT'"}, {"location": {"col": 3, "file": 11, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "ae0e799bc1bcf1ade4fc5b9a6556e173", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 10, "file": 11, "line": 1882}, "message": "in implicit copy constructor for 'testing::internal::PredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' first required here"}, {"location": {"col": 3, "file": 13, "line": 437}, "message": "in instantiation of function template specialization 'testing::internal::MakePredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' requested here"}, {"location": {"col": 26, "file": 11, "line": 4415}, "message": "expanded from macro 'EXPECT_THAT'"}, {"location": {"col": 3, "file": 11, "line": 1872}, "message": "definition of implicit copy constructor for 'PredicateFormatterFromMatcher<testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "e6371ca3f0e056a2d2f5c9e97aa5b5c7", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 7, "file": 11, "line": 432}, "message": "in implicit copy constructor for 'testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>' first required here"}, {"location": {"col": 17, "file": 12, "line": 128}, "message": "in implicit copy constructor for 'testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>' first required here"}, {"location": {"col": 17, "file": 12, "line": 351}, "message": "in defaulted copy constructor for 'std::_Head_base<2, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, false>' first required here"}, {"location": {"col": 17, "file": 12, "line": 220}, "message": "in defaulted copy constructor for 'std::_Tuple_impl<2, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 17, "file": 12, "line": 220}, "message": "in defaulted copy constructor for 'std::_Tuple_impl<1, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 17, "file": 12, "line": 640}, "message": "in defaulted copy constructor for 'std::_Tuple_impl<0, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 7, "file": 11, "line": 3463}, "message": "in defaulted copy constructor for 'std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>' first required here"}, {"location": {"col": 22, "file": 13, "line": 424}, "message": "in implicit copy constructor for 'testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' first required here"}, {"location": {"col": 3, "file": 11, "line": 2232}, "message": "definition of implicit copy constructor for 'FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "c544c9cad63288e102f41a0dc9d5baff", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 22, "file": 13, "line": 424}, "message": "in implicit copy constructor for 'testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' first required here"}, {"location": {"col": 3, "file": 11, "line": 3489}, "message": "definition of implicit copy constructor for 'UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "2b620cd85a1d8835908d5f38285f2fa1", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 22, "file": 13, "line": 431}, "message": "in implicit copy constructor for 'testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' first required here"}, {"location": {"col": 3, "file": 11, "line": 3489}, "message": "definition of implicit copy constructor for 'UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>, testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "4fe6d85598578eff88d32652ec651430", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 5, "line": 873}, "message": "expanded from macro 'GTEST_DISALLOW_ASSIGN_'"}, {"location": {"col": 22, "file": 13, "line": 437}, "message": "in implicit copy constructor for 'testing::internal::UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' first required here"}, {"location": {"col": 3, "file": 11, "line": 3489}, "message": "definition of implicit copy constructor for 'UnorderedElementsAreMatcher<std::tuple<testing::PolymorphicMatcher<testing::internal::FieldMatcher<llvm::cfi_verify::FileAnalysis::Instr, unsigned long>>>>' is deprecated because it has a user-declared copy assignment operator"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "5b8471c990539400d477156493107d04", "checkerName": "clang-diagnostic-deprecated-copy", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
