<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp", "content": "//===- RegisterCoalescer.cpp - Generic Register Coalescing Interface ------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the generic RegisterCoalescer interface which\n// is used as the common interface used by all clients and\n// implementations of register coalescing.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"RegisterCoalescer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/CodeGen/LiveInterval.h\"\n#include \"llvm/CodeGen/LiveIntervals.h\"\n#include \"llvm/CodeGen/LiveRangeEdit.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineFunctionPass.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBuilder.h\"\n#include \"llvm/CodeGen/MachineLoopInfo.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/Passes.h\"\n#include \"llvm/CodeGen/RegisterClassInfo.h\"\n#include \"llvm/CodeGen/SlotIndexes.h\"\n#include \"llvm/CodeGen/TargetInstrInfo.h\"\n#include \"llvm/CodeGen/TargetOpcodes.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/MC/MCInstrDesc.h\"\n#include \"llvm/MC/MCRegisterInfo.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <limits>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\n#define DEBUG_TYPE \"regalloc\"\n\nSTATISTIC(numJoins    , \"Number of interval joins performed\");\nSTATISTIC(numCrossRCs , \"Number of cross class joins performed\");\nSTATISTIC(numCommutes , \"Number of instruction commuting performed\");\nSTATISTIC(numExtends  , \"Number of copies extended\");\nSTATISTIC(NumReMats   , \"Number of instructions re-materialized\");\nSTATISTIC(NumInflated , \"Number of register classes inflated\");\nSTATISTIC(NumLaneConflicts, \"Number of dead lane conflicts tested\");\nSTATISTIC(NumLaneResolves,  \"Number of dead lane conflicts resolved\");\nSTATISTIC(NumShrinkToUses,  \"Number of shrinkToUses called\");\n\nstatic cl::opt<bool> EnableJoining(\"join-liveintervals\",\n                                   cl::desc(\"Coalesce copies (default=true)\"),\n                                   cl::init(true), cl::Hidden);\n\nstatic cl::opt<bool> UseTerminalRule(\"terminal-rule\",\n                                     cl::desc(\"Apply the terminal rule\"),\n                                     cl::init(false), cl::Hidden);\n\n/// Temporary flag to test critical edge unsplitting.\nstatic cl::opt<bool>\nEnableJoinSplits(\"join-splitedges\",\n  cl::desc(\"Coalesce copies on split edges (default=subtarget)\"), cl::Hidden);\n\n/// Temporary flag to test global copy optimization.\nstatic cl::opt<cl::boolOrDefault>\nEnableGlobalCopies(\"join-globalcopies\",\n  cl::desc(\"Coalesce copies that span blocks (default=subtarget)\"),\n  cl::init(cl::BOU_UNSET), cl::Hidden);\n\nstatic cl::opt<bool>\nVerifyCoalescing(\"verify-coalescing\",\n         cl::desc(\"Verify machine instrs before and after register coalescing\"),\n         cl::Hidden);\n\nstatic cl::opt<unsigned> LateRematUpdateThreshold(\n    \"late-remat-update-threshold\", cl::Hidden,\n    cl::desc(\"During rematerialization for a copy, if the def instruction has \"\n             \"many other copy uses to be rematerialized, delay the multiple \"\n             \"separate live interval update work and do them all at once after \"\n             \"all those rematerialization are done. It will save a lot of \"\n             \"repeated work. \"),\n    cl::init(100));\n\nstatic cl::opt<unsigned> LargeIntervalSizeThreshold(\n    \"large-interval-size-threshold\", cl::Hidden,\n    cl::desc(\"If the valnos size of an interval is larger than the threshold, \"\n             \"it is regarded as a large interval. \"),\n    cl::init(100));\n\nstatic cl::opt<unsigned> LargeIntervalFreqThreshold(\n    \"large-interval-freq-threshold\", cl::Hidden,\n    cl::desc(\"For a large interval, if it is coalesed with other live \"\n             \"intervals many times more than the threshold, stop its \"\n             \"coalescing to control the compile time. \"),\n    cl::init(100));\n\nnamespace {\n\n  class JoinVals;\n\n  class RegisterCoalescer : public MachineFunctionPass,\n                            private LiveRangeEdit::Delegate {\n    MachineFunction* MF = nullptr;\n    MachineRegisterInfo* MRI = nullptr;\n    const TargetRegisterInfo* TRI = nullptr;\n    const TargetInstrInfo* TII = nullptr;\n    LiveIntervals *LIS = nullptr;\n    const MachineLoopInfo* Loops = nullptr;\n    AliasAnalysis *AA = nullptr;\n    RegisterClassInfo RegClassInfo;\n\n    /// Debug variable location tracking -- for each VReg, maintain an\n    /// ordered-by-slot-index set of DBG_VALUEs, to help quick\n    /// identification of whether coalescing may change location validity.\n    using DbgValueLoc = std::pair<SlotIndex, MachineInstr*>;\n    DenseMap<Register, std::vector<DbgValueLoc>> DbgVRegToValues;\n\n    /// VRegs may be repeatedly coalesced, and have many DBG_VALUEs attached.\n    /// To avoid repeatedly merging sets of DbgValueLocs, instead record\n    /// which vregs have been coalesced, and where to. This map is from\n    /// vreg => {set of vregs merged in}.\n    DenseMap<Register, SmallVector<Register, 4>> DbgMergedVRegNums;\n\n    /// A LaneMask to remember on which subregister live ranges we need to call\n    /// shrinkToUses() later.\n    LaneBitmask ShrinkMask;\n\n    /// True if the main range of the currently coalesced intervals should be\n    /// checked for smaller live intervals.\n    bool ShrinkMainRange = false;\n\n    /// True if the coalescer should aggressively coalesce global copies\n    /// in favor of keeping local copies.\n    bool JoinGlobalCopies = false;\n\n    /// True if the coalescer should aggressively coalesce fall-thru\n    /// blocks exclusively containing copies.\n    bool JoinSplitEdges = false;\n\n    /// Copy instructions yet to be coalesced.\n    SmallVector<MachineInstr*, 8> WorkList;\n    SmallVector<MachineInstr*, 8> LocalWorkList;\n\n    /// Set of instruction pointers that have been erased, and\n    /// that may be present in WorkList.\n    SmallPtrSet<MachineInstr*, 8> ErasedInstrs;\n\n    /// Dead instructions that are about to be deleted.\n    SmallVector<MachineInstr*, 8> DeadDefs;\n\n    /// Virtual registers to be considered for register class inflation.\n    SmallVector<Register, 8> InflateRegs;\n\n    /// The collection of live intervals which should have been updated\n    /// immediately after rematerialiation but delayed until\n    /// lateLiveIntervalUpdate is called.\n    DenseSet<Register> ToBeUpdated;\n\n    /// Record how many times the large live interval with many valnos\n    /// has been tried to join with other live interval.\n    DenseMap<Register, unsigned long> LargeLIVisitCounter;\n\n    /// Recursively eliminate dead defs in DeadDefs.\n    void eliminateDeadDefs();\n\n    /// LiveRangeEdit callback for eliminateDeadDefs().\n    void LRE_WillEraseInstruction(MachineInstr *MI) override;\n\n    /// Coalesce the LocalWorkList.\n    void coalesceLocals();\n\n    /// Join compatible live intervals\n    void joinAllIntervals();\n\n    /// Coalesce copies in the specified MBB, putting\n    /// copies that cannot yet be coalesced into WorkList.\n    void copyCoalesceInMBB(MachineBasicBlock *MBB);\n\n    /// Tries to coalesce all copies in CurrList. Returns true if any progress\n    /// was made.\n    bool copyCoalesceWorkList(MutableArrayRef<MachineInstr*> CurrList);\n\n    /// If one def has many copy like uses, and those copy uses are all\n    /// rematerialized, the live interval update needed for those\n    /// rematerializations will be delayed and done all at once instead\n    /// of being done multiple times. This is to save compile cost because\n    /// live interval update is costly.\n    void lateLiveIntervalUpdate();\n\n    /// Check if the incoming value defined by a COPY at \\p SLRQ in the subrange\n    /// has no value defined in the predecessors. If the incoming value is the\n    /// same as defined by the copy itself, the value is considered undefined.\n    bool copyValueUndefInPredecessors(LiveRange &S,\n                                      const MachineBasicBlock *MBB,\n                                      LiveQueryResult SLRQ);\n\n    /// Set necessary undef flags on subregister uses after pruning out undef\n    /// lane segments from the subrange.\n    void setUndefOnPrunedSubRegUses(LiveInterval &LI, Register Reg,\n                                    LaneBitmask PrunedLanes);\n\n    /// Attempt to join intervals corresponding to SrcReg/DstReg, which are the\n    /// src/dst of the copy instruction CopyMI.  This returns true if the copy\n    /// was successfully coalesced away. If it is not currently possible to\n    /// coalesce this interval, but it may be possible if other things get\n    /// coalesced, then it returns true by reference in 'Again'.\n    bool joinCopy(MachineInstr *CopyMI, bool &Again);\n\n    /// Attempt to join these two intervals.  On failure, this\n    /// returns false.  The output \"SrcInt\" will not have been modified, so we\n    /// can use this information below to update aliases.\n    bool joinIntervals(CoalescerPair &CP);\n\n    /// Attempt joining two virtual registers. Return true on success.\n    bool joinVirtRegs(CoalescerPair &CP);\n\n    /// If a live interval has many valnos and is coalesced with other\n    /// live intervals many times, we regard such live interval as having\n    /// high compile time cost.\n    bool isHighCostLiveInterval(LiveInterval &LI);\n\n    /// Attempt joining with a reserved physreg.\n    bool joinReservedPhysReg(CoalescerPair &CP);\n\n    /// Add the LiveRange @p ToMerge as a subregister liverange of @p LI.\n    /// Subranges in @p LI which only partially interfere with the desired\n    /// LaneMask are split as necessary. @p LaneMask are the lanes that\n    /// @p ToMerge will occupy in the coalescer register. @p LI has its subrange\n    /// lanemasks already adjusted to the coalesced register.\n    void mergeSubRangeInto(LiveInterval &LI, const LiveRange &ToMerge,\n                           LaneBitmask LaneMask, CoalescerPair &CP,\n                           unsigned DstIdx);\n\n    /// Join the liveranges of two subregisters. Joins @p RRange into\n    /// @p LRange, @p RRange may be invalid afterwards.\n    void joinSubRegRanges(LiveRange &LRange, LiveRange &RRange,\n                          LaneBitmask LaneMask, const CoalescerPair &CP);\n\n    /// We found a non-trivially-coalescable copy. If the source value number is\n    /// defined by a copy from the destination reg see if we can merge these two\n    /// destination reg valno# into a single value number, eliminating a copy.\n    /// This returns true if an interval was modified.\n    bool adjustCopiesBackFrom(const CoalescerPair &CP, MachineInstr *CopyMI);\n\n    /// Return true if there are definitions of IntB\n    /// other than BValNo val# that can reach uses of AValno val# of IntA.\n    bool hasOtherReachingDefs(LiveInterval &IntA, LiveInterval &IntB,\n                              VNInfo *AValNo, VNInfo *BValNo);\n\n    /// We found a non-trivially-coalescable copy.\n    /// If the source value number is defined by a commutable instruction and\n    /// its other operand is coalesced to the copy dest register, see if we\n    /// can transform the copy into a noop by commuting the definition.\n    /// This returns a pair of two flags:\n    /// - the first element is true if an interval was modified,\n    /// - the second element is true if the destination interval needs\n    ///   to be shrunk after deleting the copy.\n    std::pair<bool,bool> removeCopyByCommutingDef(const CoalescerPair &CP,\n                                                  MachineInstr *CopyMI);\n\n    /// We found a copy which can be moved to its less frequent predecessor.\n    bool removePartialRedundancy(const CoalescerPair &CP, MachineInstr &CopyMI);\n\n    /// If the source of a copy is defined by a\n    /// trivial computation, replace the copy by rematerialize the definition.\n    bool reMaterializeTrivialDef(const CoalescerPair &CP, MachineInstr *CopyMI,\n                                 bool &IsDefCopy);\n\n    /// Return true if a copy involving a physreg should be joined.\n    bool canJoinPhys(const CoalescerPair &CP);\n\n    /// Replace all defs and uses of SrcReg to DstReg and update the subregister\n    /// number if it is not zero. If DstReg is a physical register and the\n    /// existing subregister number of the def / use being updated is not zero,\n    /// make sure to set it to the correct physical subregister.\n    void updateRegDefsUses(Register SrcReg, Register DstReg, unsigned SubIdx);\n\n    /// If the given machine operand reads only undefined lanes add an undef\n    /// flag.\n    /// This can happen when undef uses were previously concealed by a copy\n    /// which we coalesced. Example:\n    ///    %0:sub0<def,read-undef> = ...\n    ///    %1 = COPY %0           <-- Coalescing COPY reveals undef\n    ///       = use %1:sub1       <-- hidden undef use\n    void addUndefFlag(const LiveInterval &Int, SlotIndex UseIdx,\n                      MachineOperand &MO, unsigned SubRegIdx);\n\n    /// Handle copies of undef values. If the undef value is an incoming\n    /// PHI value, it will convert @p CopyMI to an IMPLICIT_DEF.\n    /// Returns nullptr if @p CopyMI was not in any way eliminable. Otherwise,\n    /// it returns @p CopyMI (which could be an IMPLICIT_DEF at this point).\n    MachineInstr *eliminateUndefCopy(MachineInstr *CopyMI);\n\n    /// Check whether or not we should apply the terminal rule on the\n    /// destination (Dst) of \\p Copy.\n    /// When the terminal rule applies, Copy is not profitable to\n    /// coalesce.\n    /// Dst is terminal if it has exactly one affinity (Dst, Src) and\n    /// at least one interference (Dst, Dst2). If Dst is terminal, the\n    /// terminal rule consists in checking that at least one of\n    /// interfering node, say Dst2, has an affinity of equal or greater\n    /// weight with Src.\n    /// In that case, Dst2 and Dst will not be able to be both coalesced\n    /// with Src. Since Dst2 exposes more coalescing opportunities than\n    /// Dst, we can drop \\p Copy.\n    bool applyTerminalRule(const MachineInstr &Copy) const;\n\n    /// Wrapper method for \\see LiveIntervals::shrinkToUses.\n    /// This method does the proper fixing of the live-ranges when the afore\n    /// mentioned method returns true.\n    void shrinkToUses(LiveInterval *LI,\n                      SmallVectorImpl<MachineInstr * > *Dead = nullptr) {\n      NumShrinkToUses++;\n      if (LIS->shrinkToUses(LI, Dead)) {\n        /// Check whether or not \\p LI is composed by multiple connected\n        /// components and if that is the case, fix that.\n        SmallVector<LiveInterval*, 8> SplitLIs;\n        LIS->splitSeparateComponents(*LI, SplitLIs);\n      }\n    }\n\n    /// Wrapper Method to do all the necessary work when an Instruction is\n    /// deleted.\n    /// Optimizations should use this to make sure that deleted instructions\n    /// are always accounted for.\n    void deleteInstr(MachineInstr* MI) {\n      ErasedInstrs.insert(MI);\n      LIS->RemoveMachineInstrFromMaps(*MI);\n      MI->eraseFromParent();\n    }\n\n    /// Walk over function and initialize the DbgVRegToValues map.\n    void buildVRegToDbgValueMap(MachineFunction &MF);\n\n    /// Test whether, after merging, any DBG_VALUEs would refer to a\n    /// different value number than before merging, and whether this can\n    /// be resolved. If not, mark the DBG_VALUE as being undef.\n    void checkMergingChangesDbgValues(CoalescerPair &CP, LiveRange &LHS,\n                                      JoinVals &LHSVals, LiveRange &RHS,\n                                      JoinVals &RHSVals);\n\n    void checkMergingChangesDbgValuesImpl(Register Reg, LiveRange &OtherRange,\n                                          LiveRange &RegRange, JoinVals &Vals2);\n\n  public:\n    static char ID; ///< Class identification, replacement for typeinfo\n\n    RegisterCoalescer() : MachineFunctionPass(ID) {\n      initializeRegisterCoalescerPass(*PassRegistry::getPassRegistry());\n    }\n\n    void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n    void releaseMemory() override;\n\n    /// This is the pass entry point.\n    bool runOnMachineFunction(MachineFunction&) override;\n\n    /// Implement the dump method.\n    void print(raw_ostream &O, const Module* = nullptr) const override;\n  };\n\n} // end anonymous namespace\n\nchar RegisterCoalescer::ID = 0;\n\nchar &llvm::RegisterCoalescerID = RegisterCoalescer::ID;\n\nINITIALIZE_PASS_BEGIN(RegisterCoalescer, \"simple-register-coalescing\",\n                      \"Simple Register Coalescing\", false, false)\nINITIALIZE_PASS_DEPENDENCY(LiveIntervals)\nINITIALIZE_PASS_DEPENDENCY(SlotIndexes)\nINITIALIZE_PASS_DEPENDENCY(MachineLoopInfo)\nINITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)\nINITIALIZE_PASS_END(RegisterCoalescer, \"simple-register-coalescing\",\n                    \"Simple Register Coalescing\", false, false)\n\nLLVM_NODISCARD static bool isMoveInstr(const TargetRegisterInfo &tri,\n                                       const MachineInstr *MI, Register &Src,\n                                       Register &Dst, unsigned &SrcSub,\n                                       unsigned &DstSub) {\n  if (MI->isCopy()) {\n    Dst = MI->getOperand(0).getReg();\n    DstSub = MI->getOperand(0).getSubReg();\n    Src = MI->getOperand(1).getReg();\n    SrcSub = MI->getOperand(1).getSubReg();\n  } else if (MI->isSubregToReg()) {\n    Dst = MI->getOperand(0).getReg();\n    DstSub = tri.composeSubRegIndices(MI->getOperand(0).getSubReg(),\n                                      MI->getOperand(3).getImm());\n    Src = MI->getOperand(2).getReg();\n    SrcSub = MI->getOperand(2).getSubReg();\n  } else\n    return false;\n  return true;\n}\n\n/// Return true if this block should be vacated by the coalescer to eliminate\n/// branches. The important cases to handle in the coalescer are critical edges\n/// split during phi elimination which contain only copies. Simple blocks that\n/// contain non-branches should also be vacated, but this can be handled by an\n/// earlier pass similar to early if-conversion.\nstatic bool isSplitEdge(const MachineBasicBlock *MBB) {\n  if (MBB->pred_size() != 1 || MBB->succ_size() != 1)\n    return false;\n\n  for (const auto &MI : *MBB) {\n    if (!MI.isCopyLike() && !MI.isUnconditionalBranch())\n      return false;\n  }\n  return true;\n}\n\nbool CoalescerPair::setRegisters(const MachineInstr *MI) {\n  SrcReg = DstReg = Register();\n  SrcIdx = DstIdx = 0;\n  NewRC = nullptr;\n  Flipped = CrossClass = false;\n\n  Register Src, Dst;\n  unsigned SrcSub = 0, DstSub = 0;\n  if (!isMoveInstr(TRI, MI, Src, Dst, SrcSub, DstSub))\n    return false;\n  Partial = SrcSub || DstSub;\n\n  // If one register is a physreg, it must be Dst.\n  if (Register::isPhysicalRegister(Src)) {\n    if (Register::isPhysicalRegister(Dst))\n      return false;\n    std::swap(Src, Dst);\n    std::swap(SrcSub, DstSub);\n    Flipped = true;\n  }\n\n  const MachineRegisterInfo &MRI = MI->getMF()->getRegInfo();\n\n  if (Register::isPhysicalRegister(Dst)) {\n    // Eliminate DstSub on a physreg.\n    if (DstSub) {\n      Dst = TRI.getSubReg(Dst, DstSub);\n      if (!Dst) return false;\n      DstSub = 0;\n    }\n\n    // Eliminate SrcSub by picking a corresponding Dst superregister.\n    if (SrcSub) {\n      Dst = TRI.getMatchingSuperReg(Dst, SrcSub, MRI.getRegClass(Src));\n      if (!Dst) return false;\n    } else if (!MRI.getRegClass(Src)->contains(Dst)) {\n      return false;\n    }\n  } else {\n    // Both registers are virtual.\n    const TargetRegisterClass *SrcRC = MRI.getRegClass(Src);\n    const TargetRegisterClass *DstRC = MRI.getRegClass(Dst);\n\n    // Both registers have subreg indices.\n    if (SrcSub && DstSub) {\n      // Copies between different sub-registers are never coalescable.\n      if (Src == Dst && SrcSub != DstSub)\n        return false;\n\n      NewRC = TRI.getCommonSuperRegClass(SrcRC, SrcSub, DstRC, DstSub,\n                                         SrcIdx, DstIdx);\n      if (!NewRC)\n        return false;\n    } else if (DstSub) {\n      // SrcReg will be merged with a sub-register of DstReg.\n      SrcIdx = DstSub;\n      NewRC = TRI.getMatchingSuperRegClass(DstRC, SrcRC, DstSub);\n    } else if (SrcSub) {\n      // DstReg will be merged with a sub-register of SrcReg.\n      DstIdx = SrcSub;\n      NewRC = TRI.getMatchingSuperRegClass(SrcRC, DstRC, SrcSub);\n    } else {\n      // This is a straight copy without sub-registers.\n      NewRC = TRI.getCommonSubClass(DstRC, SrcRC);\n    }\n\n    // The combined constraint may be impossible to satisfy.\n    if (!NewRC)\n      return false;\n\n    // Prefer SrcReg to be a sub-register of DstReg.\n    // FIXME: Coalescer should support subregs symmetrically.\n    if (DstIdx && !SrcIdx) {\n      std::swap(Src, Dst);\n      std::swap(SrcIdx, DstIdx);\n      Flipped = !Flipped;\n    }\n\n    CrossClass = NewRC != DstRC || NewRC != SrcRC;\n  }\n  // Check our invariants\n  assert(Register::isVirtualRegister(Src) && \"Src must be virtual\");\n  assert(!(Register::isPhysicalRegister(Dst) && DstSub) &&\n         \"Cannot have a physical SubIdx\");\n  SrcReg = Src;\n  DstReg = Dst;\n  return true;\n}\n\nbool CoalescerPair::flip() {\n  if (Register::isPhysicalRegister(DstReg))\n    return false;\n  std::swap(SrcReg, DstReg);\n  std::swap(SrcIdx, DstIdx);\n  Flipped = !Flipped;\n  return true;\n}\n\nbool CoalescerPair::isCoalescable(const MachineInstr *MI) const {\n  if (!MI)\n    return false;\n  Register Src, Dst;\n  unsigned SrcSub = 0, DstSub = 0;\n  if (!isMoveInstr(TRI, MI, Src, Dst, SrcSub, DstSub))\n    return false;\n\n  // Find the virtual register that is SrcReg.\n  if (Dst == SrcReg) {\n    std::swap(Src, Dst);\n    std::swap(SrcSub, DstSub);\n  } else if (Src != SrcReg) {\n    return false;\n  }\n\n  // Now check that Dst matches DstReg.\n  if (DstReg.isPhysical()) {\n    if (!Dst.isPhysical())\n      return false;\n    assert(!DstIdx && !SrcIdx && \"Inconsistent CoalescerPair state.\");\n    // DstSub could be set for a physreg from INSERT_SUBREG.\n    if (DstSub)\n      Dst = TRI.getSubReg(Dst, DstSub);\n    // Full copy of Src.\n    if (!SrcSub)\n      return DstReg == Dst;\n    // This is a partial register copy. Check that the parts match.\n    return Register(TRI.getSubReg(DstReg, SrcSub)) == Dst;\n  } else {\n    // DstReg is virtual.\n    if (DstReg != Dst)\n      return false;\n    // Registers match, do the subregisters line up?\n    return TRI.composeSubRegIndices(SrcIdx, SrcSub) ==\n           TRI.composeSubRegIndices(DstIdx, DstSub);\n  }\n}\n\nvoid RegisterCoalescer::getAnalysisUsage(AnalysisUsage &AU) const {\n  AU.setPreservesCFG();\n  AU.addRequired<AAResultsWrapperPass>();\n  AU.addRequired<LiveIntervals>();\n  AU.addPreserved<LiveIntervals>();\n  AU.addPreserved<SlotIndexes>();\n  AU.addRequired<MachineLoopInfo>();\n  AU.addPreserved<MachineLoopInfo>();\n  AU.addPreservedID(MachineDominatorsID);\n  MachineFunctionPass::getAnalysisUsage(AU);\n}\n\nvoid RegisterCoalescer::eliminateDeadDefs() {\n  SmallVector<Register, 8> NewRegs;\n  LiveRangeEdit(nullptr, NewRegs, *MF, *LIS,\n                nullptr, this).eliminateDeadDefs(DeadDefs);\n}\n\nvoid RegisterCoalescer::LRE_WillEraseInstruction(MachineInstr *MI) {\n  // MI may be in WorkList. Make sure we don't visit it.\n  ErasedInstrs.insert(MI);\n}\n\nbool RegisterCoalescer::adjustCopiesBackFrom(const CoalescerPair &CP,\n                                             MachineInstr *CopyMI) {\n  assert(!CP.isPartial() && \"This doesn't work for partial copies.\");\n  assert(!CP.isPhys() && \"This doesn't work for physreg copies.\");\n\n  LiveInterval &IntA =\n    LIS->getInterval(CP.isFlipped() ? CP.getDstReg() : CP.getSrcReg());\n  LiveInterval &IntB =\n    LIS->getInterval(CP.isFlipped() ? CP.getSrcReg() : CP.getDstReg());\n  SlotIndex CopyIdx = LIS->getInstructionIndex(*CopyMI).getRegSlot();\n\n  // We have a non-trivially-coalescable copy with IntA being the source and\n  // IntB being the dest, thus this defines a value number in IntB.  If the\n  // source value number (in IntA) is defined by a copy from B, see if we can\n  // merge these two pieces of B into a single value number, eliminating a copy.\n  // For example:\n  //\n  //  A3 = B0\n  //    ...\n  //  B1 = A3      <- this copy\n  //\n  // In this case, B0 can be extended to where the B1 copy lives, allowing the\n  // B1 value number to be replaced with B0 (which simplifies the B\n  // liveinterval).\n\n  // BValNo is a value number in B that is defined by a copy from A.  'B1' in\n  // the example above.\n  LiveInterval::iterator BS = IntB.FindSegmentContaining(CopyIdx);\n  if (BS == IntB.end()) return false;\n  VNInfo *BValNo = BS->valno;\n\n  // Get the location that B is defined at.  Two options: either this value has\n  // an unknown definition point or it is defined at CopyIdx.  If unknown, we\n  // can't process it.\n  if (BValNo->def != CopyIdx) return false;\n\n  // AValNo is the value number in A that defines the copy, A3 in the example.\n  SlotIndex CopyUseIdx = CopyIdx.getRegSlot(true);\n  LiveInterval::iterator AS = IntA.FindSegmentContaining(CopyUseIdx);\n  // The live segment might not exist after fun with physreg coalescing.\n  if (AS == IntA.end()) return false;\n  VNInfo *AValNo = AS->valno;\n\n  // If AValNo is defined as a copy from IntB, we can potentially process this.\n  // Get the instruction that defines this value number.\n  MachineInstr *ACopyMI = LIS->getInstructionFromIndex(AValNo->def);\n  // Don't allow any partial copies, even if isCoalescable() allows them.\n  if (!CP.isCoalescable(ACopyMI) || !ACopyMI->isFullCopy())\n    return false;\n\n  // Get the Segment in IntB that this value number starts with.\n  LiveInterval::iterator ValS =\n    IntB.FindSegmentContaining(AValNo->def.getPrevSlot());\n  if (ValS == IntB.end())\n    return false;\n\n  // Make sure that the end of the live segment is inside the same block as\n  // CopyMI.\n  MachineInstr *ValSEndInst =\n    LIS->getInstructionFromIndex(ValS->end.getPrevSlot());\n  if (!ValSEndInst || ValSEndInst->getParent() != CopyMI->getParent())\n    return false;\n\n  // Okay, we now know that ValS ends in the same block that the CopyMI\n  // live-range starts.  If there are no intervening live segments between them\n  // in IntB, we can merge them.\n  if (ValS+1 != BS) return false;\n\n  LLVM_DEBUG(dbgs() << \"Extending: \" << printReg(IntB.reg(), TRI));\n\n  SlotIndex FillerStart = ValS->end, FillerEnd = BS->start;\n  // We are about to delete CopyMI, so need to remove it as the 'instruction\n  // that defines this value #'. Update the valnum with the new defining\n  // instruction #.\n  BValNo->def = FillerStart;\n\n  // Okay, we can merge them.  We need to insert a new liverange:\n  // [ValS.end, BS.begin) of either value number, then we merge the\n  // two value numbers.\n  IntB.addSegment(LiveInterval::Segment(FillerStart, FillerEnd, BValNo));\n\n  // Okay, merge \"B1\" into the same value number as \"B0\".\n  if (BValNo != ValS->valno)\n    IntB.MergeValueNumberInto(BValNo, ValS->valno);\n\n  // Do the same for the subregister segments.\n  for (LiveInterval::SubRange &S : IntB.subranges()) {\n    // Check for SubRange Segments of the form [1234r,1234d:0) which can be\n    // removed to prevent creating bogus SubRange Segments.\n    LiveInterval::iterator SS = S.FindSegmentContaining(CopyIdx);\n    if (SS != S.end() && SlotIndex::isSameInstr(SS->start, SS->end)) {\n      S.removeSegment(*SS, true);\n      continue;\n    }\n    // The subrange may have ended before FillerStart. If so, extend it.\n    if (!S.getVNInfoAt(FillerStart)) {\n      SlotIndex BBStart =\n          LIS->getMBBStartIdx(LIS->getMBBFromIndex(FillerStart));\n      S.extendInBlock(BBStart, FillerStart);\n    }\n    VNInfo *SubBValNo = S.getVNInfoAt(CopyIdx);\n    S.addSegment(LiveInterval::Segment(FillerStart, FillerEnd, SubBValNo));\n    VNInfo *SubValSNo = S.getVNInfoAt(AValNo->def.getPrevSlot());\n    if (SubBValNo != SubValSNo)\n      S.MergeValueNumberInto(SubBValNo, SubValSNo);\n  }\n\n  LLVM_DEBUG(dbgs() << \"   result = \" << IntB << '\\n');\n\n  // If the source instruction was killing the source register before the\n  // merge, unset the isKill marker given the live range has been extended.\n  int UIdx = ValSEndInst->findRegisterUseOperandIdx(IntB.reg(), true);\n  if (UIdx != -1) {\n    ValSEndInst->getOperand(UIdx).setIsKill(false);\n  }\n\n  // Rewrite the copy.\n  CopyMI->substituteRegister(IntA.reg(), IntB.reg(), 0, *TRI);\n  // If the copy instruction was killing the destination register or any\n  // subrange before the merge trim the live range.\n  bool RecomputeLiveRange = AS->end == CopyIdx;\n  if (!RecomputeLiveRange) {\n    for (LiveInterval::SubRange &S : IntA.subranges()) {\n      LiveInterval::iterator SS = S.FindSegmentContaining(CopyUseIdx);\n      if (SS != S.end() && SS->end == CopyIdx) {\n        RecomputeLiveRange = true;\n        break;\n      }\n    }\n  }\n  if (RecomputeLiveRange)\n    shrinkToUses(&IntA);\n\n  ++numExtends;\n  return true;\n}\n\nbool RegisterCoalescer::hasOtherReachingDefs(LiveInterval &IntA,\n                                             LiveInterval &IntB,\n                                             VNInfo *AValNo,\n                                             VNInfo *BValNo) {\n  // If AValNo has PHI kills, conservatively assume that IntB defs can reach\n  // the PHI values.\n  if (LIS->hasPHIKill(IntA, AValNo))\n    return true;\n\n  for (LiveRange::Segment &ASeg : IntA.segments) {\n    if (ASeg.valno != AValNo) continue;\n    LiveInterval::iterator BI = llvm::upper_bound(IntB, ASeg.start);\n    if (BI != IntB.begin())\n      --BI;\n    for (; BI != IntB.end() && ASeg.end >= BI->start; ++BI) {\n      if (BI->valno == BValNo)\n        continue;\n      if (BI->start <= ASeg.start && BI->end > ASeg.start)\n        return true;\n      if (BI->start > ASeg.start && BI->start < ASeg.end)\n        return true;\n    }\n  }\n  return false;\n}\n\n/// Copy segments with value number @p SrcValNo from liverange @p Src to live\n/// range @Dst and use value number @p DstValNo there.\nstatic std::pair<bool,bool>\naddSegmentsWithValNo(LiveRange &Dst, VNInfo *DstValNo, const LiveRange &Src,\n                     const VNInfo *SrcValNo) {\n  bool Changed = false;\n  bool MergedWithDead = false;\n  for (const LiveRange::Segment &S : Src.segments) {\n    if (S.valno != SrcValNo)\n      continue;\n    // This is adding a segment from Src that ends in a copy that is about\n    // to be removed. This segment is going to be merged with a pre-existing\n    // segment in Dst. This works, except in cases when the corresponding\n    // segment in Dst is dead. For example: adding [192r,208r:1) from Src\n    // to [208r,208d:1) in Dst would create [192r,208d:1) in Dst.\n    // Recognized such cases, so that the segments can be shrunk.\n    LiveRange::Segment Added = LiveRange::Segment(S.start, S.end, DstValNo);\n    LiveRange::Segment &Merged = *Dst.addSegment(Added);\n    if (Merged.end.isDead())\n      MergedWithDead = true;\n    Changed = true;\n  }\n  return std::make_pair(Changed, MergedWithDead);\n}\n\nstd::pair<bool,bool>\nRegisterCoalescer::removeCopyByCommutingDef(const CoalescerPair &CP,\n                                            MachineInstr *CopyMI) {\n  assert(!CP.isPhys());\n\n  LiveInterval &IntA =\n      LIS->getInterval(CP.isFlipped() ? CP.getDstReg() : CP.getSrcReg());\n  LiveInterval &IntB =\n      LIS->getInterval(CP.isFlipped() ? CP.getSrcReg() : CP.getDstReg());\n\n  // We found a non-trivially-coalescable copy with IntA being the source and\n  // IntB being the dest, thus this defines a value number in IntB.  If the\n  // source value number (in IntA) is defined by a commutable instruction and\n  // its other operand is coalesced to the copy dest register, see if we can\n  // transform the copy into a noop by commuting the definition. For example,\n  //\n  //  A3 = op A2 killed B0\n  //    ...\n  //  B1 = A3      <- this copy\n  //    ...\n  //     = op A3   <- more uses\n  //\n  // ==>\n  //\n  //  B2 = op B0 killed A2\n  //    ...\n  //  B1 = B2      <- now an identity copy\n  //    ...\n  //     = op B2   <- more uses\n\n  // BValNo is a value number in B that is defined by a copy from A. 'B1' in\n  // the example above.\n  SlotIndex CopyIdx = LIS->getInstructionIndex(*CopyMI).getRegSlot();\n  VNInfo *BValNo = IntB.getVNInfoAt(CopyIdx);\n  assert(BValNo != nullptr && BValNo->def == CopyIdx);\n\n  // AValNo is the value number in A that defines the copy, A3 in the example.\n  VNInfo *AValNo = IntA.getVNInfoAt(CopyIdx.getRegSlot(true));\n  assert(AValNo && !AValNo->isUnused() && \"COPY source not live\");\n  if (AValNo->isPHIDef())\n    return { false, false };\n  MachineInstr *DefMI = LIS->getInstructionFromIndex(AValNo->def);\n  if (!DefMI)\n    return { false, false };\n  if (!DefMI->isCommutable())\n    return { false, false };\n  // If DefMI is a two-address instruction then commuting it will change the\n  // destination register.\n  int DefIdx = DefMI->findRegisterDefOperandIdx(IntA.reg());\n  assert(DefIdx != -1);\n  unsigned UseOpIdx;\n  if (!DefMI->isRegTiedToUseOperand(DefIdx, &UseOpIdx))\n    return { false, false };\n\n  // FIXME: The code below tries to commute 'UseOpIdx' operand with some other\n  // commutable operand which is expressed by 'CommuteAnyOperandIndex'value\n  // passed to the method. That _other_ operand is chosen by\n  // the findCommutedOpIndices() method.\n  //\n  // That is obviously an area for improvement in case of instructions having\n  // more than 2 operands. For example, if some instruction has 3 commutable\n  // operands then all possible variants (i.e. op#1<->op#2, op#1<->op#3,\n  // op#2<->op#3) of commute transformation should be considered/tried here.\n  unsigned NewDstIdx = TargetInstrInfo::CommuteAnyOperandIndex;\n  if (!TII->findCommutedOpIndices(*DefMI, UseOpIdx, NewDstIdx))\n    return { false, false };\n\n  MachineOperand &NewDstMO = DefMI->getOperand(NewDstIdx);\n  Register NewReg = NewDstMO.getReg();\n  if (NewReg != IntB.reg() || !IntB.Query(AValNo->def).isKill())\n    return { false, false };\n\n  // Make sure there are no other definitions of IntB that would reach the\n  // uses which the new definition can reach.\n  if (hasOtherReachingDefs(IntA, IntB, AValNo, BValNo))\n    return { false, false };\n\n  // If some of the uses of IntA.reg is already coalesced away, return false.\n  // It's not possible to determine whether it's safe to perform the coalescing.\n  for (MachineOperand &MO : MRI->use_nodbg_operands(IntA.reg())) {\n    MachineInstr *UseMI = MO.getParent();\n    unsigned OpNo = &MO - &UseMI->getOperand(0);\n    SlotIndex UseIdx = LIS->getInstructionIndex(*UseMI);\n    LiveInterval::iterator US = IntA.FindSegmentContaining(UseIdx);\n    if (US == IntA.end() || US->valno != AValNo)\n      continue;\n    // If this use is tied to a def, we can't rewrite the register.\n    if (UseMI->isRegTiedToDefOperand(OpNo))\n      return { false, false };\n  }\n\n  LLVM_DEBUG(dbgs() << \"\\tremoveCopyByCommutingDef: \" << AValNo->def << '\\t'\n                    << *DefMI);\n\n  // At this point we have decided that it is legal to do this\n  // transformation.  Start by commuting the instruction.\n  MachineBasicBlock *MBB = DefMI->getParent();\n  MachineInstr *NewMI =\n      TII->commuteInstruction(*DefMI, false, UseOpIdx, NewDstIdx);\n  if (!NewMI)\n    return { false, false };\n  if (Register::isVirtualRegister(IntA.reg()) &&\n      Register::isVirtualRegister(IntB.reg()) &&\n      !MRI->constrainRegClass(IntB.reg(), MRI->getRegClass(IntA.reg())))\n    return { false, false };\n  if (NewMI != DefMI) {\n    LIS->ReplaceMachineInstrInMaps(*DefMI, *NewMI);\n    MachineBasicBlock::iterator Pos = DefMI;\n    MBB->insert(Pos, NewMI);\n    MBB->erase(DefMI);\n  }\n\n  // If ALR and BLR overlaps and end of BLR extends beyond end of ALR, e.g.\n  // A = or A, B\n  // ...\n  // B = A\n  // ...\n  // C = killed A\n  // ...\n  //   = B\n\n  // Update uses of IntA of the specific Val# with IntB.\n  for (MachineRegisterInfo::use_iterator UI = MRI->use_begin(IntA.reg()),\n                                         UE = MRI->use_end();\n       UI != UE;\n       /* ++UI is below because of possible MI removal */) {\n    MachineOperand &UseMO = *UI;\n    ++UI;\n    if (UseMO.isUndef())\n      continue;\n    MachineInstr *UseMI = UseMO.getParent();\n    if (UseMI->isDebugValue()) {\n      // FIXME These don't have an instruction index.  Not clear we have enough\n      // info to decide whether to do this replacement or not.  For now do it.\n      UseMO.setReg(NewReg);\n      continue;\n    }\n    SlotIndex UseIdx = LIS->getInstructionIndex(*UseMI).getRegSlot(true);\n    LiveInterval::iterator US = IntA.FindSegmentContaining(UseIdx);\n    assert(US != IntA.end() && \"Use must be live\");\n    if (US->valno != AValNo)\n      continue;\n    // Kill flags are no longer accurate. They are recomputed after RA.\n    UseMO.setIsKill(false);\n    if (Register::isPhysicalRegister(NewReg))\n      UseMO.substPhysReg(NewReg, *TRI);\n    else\n      UseMO.setReg(NewReg);\n    if (UseMI == CopyMI)\n      continue;\n    if (!UseMI->isCopy())\n      continue;\n    if (UseMI->getOperand(0).getReg() != IntB.reg() ||\n        UseMI->getOperand(0).getSubReg())\n      continue;\n\n    // This copy will become a noop. If it's defining a new val#, merge it into\n    // BValNo.\n    SlotIndex DefIdx = UseIdx.getRegSlot();\n    VNInfo *DVNI = IntB.getVNInfoAt(DefIdx);\n    if (!DVNI)\n      continue;\n    LLVM_DEBUG(dbgs() << \"\\t\\tnoop: \" << DefIdx << '\\t' << *UseMI);\n    assert(DVNI->def == DefIdx);\n    BValNo = IntB.MergeValueNumberInto(DVNI, BValNo);\n    for (LiveInterval::SubRange &S : IntB.subranges()) {\n      VNInfo *SubDVNI = S.getVNInfoAt(DefIdx);\n      if (!SubDVNI)\n        continue;\n      VNInfo *SubBValNo = S.getVNInfoAt(CopyIdx);\n      assert(SubBValNo->def == CopyIdx);\n      S.MergeValueNumberInto(SubDVNI, SubBValNo);\n    }\n\n    deleteInstr(UseMI);\n  }\n\n  // Extend BValNo by merging in IntA live segments of AValNo. Val# definition\n  // is updated.\n  bool ShrinkB = false;\n  BumpPtrAllocator &Allocator = LIS->getVNInfoAllocator();\n  if (IntA.hasSubRanges() || IntB.hasSubRanges()) {\n    if (!IntA.hasSubRanges()) {\n      LaneBitmask Mask = MRI->getMaxLaneMaskForVReg(IntA.reg());\n      IntA.createSubRangeFrom(Allocator, Mask, IntA);\n    } else if (!IntB.hasSubRanges()) {\n      LaneBitmask Mask = MRI->getMaxLaneMaskForVReg(IntB.reg());\n      IntB.createSubRangeFrom(Allocator, Mask, IntB);\n    }\n    SlotIndex AIdx = CopyIdx.getRegSlot(true);\n    LaneBitmask MaskA;\n    const SlotIndexes &Indexes = *LIS->getSlotIndexes();\n    for (LiveInterval::SubRange &SA : IntA.subranges()) {\n      VNInfo *ASubValNo = SA.getVNInfoAt(AIdx);\n      // Even if we are dealing with a full copy, some lanes can\n      // still be undefined.\n      // E.g.,\n      // undef A.subLow = ...\n      // B = COPY A <== A.subHigh is undefined here and does\n      //                not have a value number.\n      if (!ASubValNo)\n        continue;\n      MaskA |= SA.LaneMask;\n\n      IntB.refineSubRanges(\n          Allocator, SA.LaneMask,\n          [&Allocator, &SA, CopyIdx, ASubValNo,\n           &ShrinkB](LiveInterval::SubRange &SR) {\n            VNInfo *BSubValNo = SR.empty() ? SR.getNextValue(CopyIdx, Allocator)\n                                           : SR.getVNInfoAt(CopyIdx);\n            assert(BSubValNo != nullptr);\n            auto P = addSegmentsWithValNo(SR, BSubValNo, SA, ASubValNo);\n            ShrinkB |= P.second;\n            if (P.first)\n              BSubValNo->def = ASubValNo->def;\n          },\n          Indexes, *TRI);\n    }\n    // Go over all subranges of IntB that have not been covered by IntA,\n    // and delete the segments starting at CopyIdx. This can happen if\n    // IntA has undef lanes that are defined in IntB.\n    for (LiveInterval::SubRange &SB : IntB.subranges()) {\n      if ((SB.LaneMask & MaskA).any())\n        continue;\n      if (LiveRange::Segment *S = SB.getSegmentContaining(CopyIdx))\n        if (S->start.getBaseIndex() == CopyIdx.getBaseIndex())\n          SB.removeSegment(*S, true);\n    }\n  }\n\n  BValNo->def = AValNo->def;\n  auto P = addSegmentsWithValNo(IntB, BValNo, IntA, AValNo);\n  ShrinkB |= P.second;\n  LLVM_DEBUG(dbgs() << \"\\t\\textended: \" << IntB << '\\n');\n\n  LIS->removeVRegDefAt(IntA, AValNo->def);\n\n  LLVM_DEBUG(dbgs() << \"\\t\\ttrimmed:  \" << IntA << '\\n');\n  ++numCommutes;\n  return { true, ShrinkB };\n}\n\n/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a\n/// predecessor of BB2, and if B is not redefined on the way from A = B\n/// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the\n/// execution goes through the path from BB0 to BB2. We may move B = A\n/// to the predecessor without such reversed copy.\n/// So we will transform the program from:\n///   BB0:\n///      A = B;    BB1:\n///       ...         ...\n///     /     \\      /\n///             BB2:\n///               ...\n///               B = A;\n///\n/// to:\n///\n///   BB0:         BB1:\n///      A = B;        ...\n///       ...          B = A;\n///     /     \\       /\n///             BB2:\n///               ...\n///\n/// A special case is when BB0 and BB2 are the same BB which is the only\n/// BB in a loop:\n///   BB1:\n///        ...\n///   BB0/BB2:  ----\n///        B = A;   |\n///        ...      |\n///        A = B;   |\n///          |-------\n///          |\n/// We may hoist B = A from BB0/BB2 to BB1.\n///\n/// The major preconditions for correctness to remove such partial\n/// redundancy include:\n/// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of\n///    the PHI is defined by the reversed copy A = B in BB0.\n/// 2. No B is referenced from the start of BB2 to B = A.\n/// 3. No B is defined from A = B to the end of BB0.\n/// 4. BB1 has only one successor.\n///\n/// 2 and 4 implicitly ensure B is not live at the end of BB1.\n/// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a\n/// colder place, which not only prevent endless loop, but also make sure\n/// the movement of copy is beneficial.\nbool RegisterCoalescer::removePartialRedundancy(const CoalescerPair &CP,\n                                                MachineInstr &CopyMI) {\n  assert(!CP.isPhys());\n  if (!CopyMI.isFullCopy())\n    return false;\n\n  MachineBasicBlock &MBB = *CopyMI.getParent();\n  // If this block is the target of an invoke/inlineasm_br, moving the copy into\n  // the predecessor is tricker, and we don't handle it.\n  if (MBB.isEHPad() || MBB.isInlineAsmBrIndirectTarget())\n    return false;\n\n  if (MBB.pred_size() != 2)\n    return false;\n\n  LiveInterval &IntA =\n      LIS->getInterval(CP.isFlipped() ? CP.getDstReg() : CP.getSrcReg());\n  LiveInterval &IntB =\n      LIS->getInterval(CP.isFlipped() ? CP.getSrcReg() : CP.getDstReg());\n\n  // A is defined by PHI at the entry of MBB.\n  SlotIndex CopyIdx = LIS->getInstructionIndex(CopyMI).getRegSlot(true);\n  VNInfo *AValNo = IntA.getVNInfoAt(CopyIdx);\n  assert(AValNo && !AValNo->isUnused() && \"COPY source not live\");\n  if (!AValNo->isPHIDef())\n    return false;\n\n  // No B is referenced before CopyMI in MBB.\n  if (IntB.overlaps(LIS->getMBBStartIdx(&MBB), CopyIdx))\n    return false;\n\n  // MBB has two predecessors: one contains A = B so no copy will be inserted\n  // for it. The other one will have a copy moved from MBB.\n  bool FoundReverseCopy = false;\n  MachineBasicBlock *CopyLeftBB = nullptr;\n  for (MachineBasicBlock *Pred : MBB.predecessors()) {\n    VNInfo *PVal = IntA.getVNInfoBefore(LIS->getMBBEndIdx(Pred));\n    MachineInstr *DefMI = LIS->getInstructionFromIndex(PVal->def);\n    if (!DefMI || !DefMI->isFullCopy()) {\n      CopyLeftBB = Pred;\n      continue;\n    }\n    // Check DefMI is a reverse copy and it is in BB Pred.\n    if (DefMI->getOperand(0).getReg() != IntA.reg() ||\n        DefMI->getOperand(1).getReg() != IntB.reg() ||\n        DefMI->getParent() != Pred) {\n      CopyLeftBB = Pred;\n      continue;\n    }\n    // If there is any other def of B after DefMI and before the end of Pred,\n    // we need to keep the copy of B = A at the end of Pred if we remove\n    // B = A from MBB.\n    bool ValB_Changed = false;\n    for (auto VNI : IntB.valnos) {\n      if (VNI->isUnused())\n        continue;\n      if (PVal->def < VNI->def && VNI->def < LIS->getMBBEndIdx(Pred)) {\n        ValB_Changed = true;\n        break;\n      }\n    }\n    if (ValB_Changed) {\n      CopyLeftBB = Pred;\n      continue;\n    }\n    FoundReverseCopy = true;\n  }\n\n  // If no reverse copy is found in predecessors, nothing to do.\n  if (!FoundReverseCopy)\n    return false;\n\n  // If CopyLeftBB is nullptr, it means every predecessor of MBB contains\n  // reverse copy, CopyMI can be removed trivially if only IntA/IntB is updated.\n  // If CopyLeftBB is not nullptr, move CopyMI from MBB to CopyLeftBB and\n  // update IntA/IntB.\n  //\n  // If CopyLeftBB is not nullptr, ensure CopyLeftBB has a single succ so\n  // MBB is hotter than CopyLeftBB.\n  if (CopyLeftBB && CopyLeftBB->succ_size() > 1)\n    return false;\n\n  // Now (almost sure it's) ok to move copy.\n  if (CopyLeftBB) {\n    // Position in CopyLeftBB where we should insert new copy.\n    auto InsPos = CopyLeftBB->getFirstTerminator();\n\n    // Make sure that B isn't referenced in the terminators (if any) at the end\n    // of the predecessor since we're about to insert a new definition of B\n    // before them.\n    if (InsPos != CopyLeftBB->end()) {\n      SlotIndex InsPosIdx = LIS->getInstructionIndex(*InsPos).getRegSlot(true);\n      if (IntB.overlaps(InsPosIdx, LIS->getMBBEndIdx(CopyLeftBB)))\n        return false;\n    }\n\n    LLVM_DEBUG(dbgs() << \"\\tremovePartialRedundancy: Move the copy to \"\n                      << printMBBReference(*CopyLeftBB) << '\\t' << CopyMI);\n\n    // Insert new copy to CopyLeftBB.\n    MachineInstr *NewCopyMI = BuildMI(*CopyLeftBB, InsPos, CopyMI.getDebugLoc(),\n                                      TII->get(TargetOpcode::COPY), IntB.reg())\n                                  .addReg(IntA.reg());\n    SlotIndex NewCopyIdx =\n        LIS->InsertMachineInstrInMaps(*NewCopyMI).getRegSlot();\n    IntB.createDeadDef(NewCopyIdx, LIS->getVNInfoAllocator());\n    for (LiveInterval::SubRange &SR : IntB.subranges())\n      SR.createDeadDef(NewCopyIdx, LIS->getVNInfoAllocator());\n\n    // If the newly created Instruction has an address of an instruction that was\n    // deleted before (object recycled by the allocator) it needs to be removed from\n    // the deleted list.\n    ErasedInstrs.erase(NewCopyMI);\n  } else {\n    LLVM_DEBUG(dbgs() << \"\\tremovePartialRedundancy: Remove the copy from \"\n                      << printMBBReference(MBB) << '\\t' << CopyMI);\n  }\n\n  // Remove CopyMI.\n  // Note: This is fine to remove the copy before updating the live-ranges.\n  // While updating the live-ranges, we only look at slot indices and\n  // never go back to the instruction.\n  // Mark instructions as deleted.\n  deleteInstr(&CopyMI);\n\n  // Update the liveness.\n  SmallVector<SlotIndex, 8> EndPoints;\n  VNInfo *BValNo = IntB.Query(CopyIdx).valueOutOrDead();\n  LIS->pruneValue(*static_cast<LiveRange *>(&IntB), CopyIdx.getRegSlot(),\n                  &EndPoints);\n  BValNo->markUnused();\n  // Extend IntB to the EndPoints of its original live interval.\n  LIS->extendToIndices(IntB, EndPoints);\n\n  // Now, do the same for its subranges.\n  for (LiveInterval::SubRange &SR : IntB.subranges()) {\n    EndPoints.clear();\n    VNInfo *BValNo = SR.Query(CopyIdx).valueOutOrDead();\n    assert(BValNo && \"All sublanes should be live\");\n    LIS->pruneValue(SR, CopyIdx.getRegSlot(), &EndPoints);\n    BValNo->markUnused();\n    // We can have a situation where the result of the original copy is live,\n    // but is immediately dead in this subrange, e.g. [336r,336d:0). That makes\n    // the copy appear as an endpoint from pruneValue(), but we don't want it\n    // to because the copy has been removed.  We can go ahead and remove that\n    // endpoint; there is no other situation here that there could be a use at\n    // the same place as we know that the copy is a full copy.\n    for (unsigned I = 0; I != EndPoints.size(); ) {\n      if (SlotIndex::isSameInstr(EndPoints[I], CopyIdx)) {\n        EndPoints[I] = EndPoints.back();\n        EndPoints.pop_back();\n        continue;\n      }\n      ++I;\n    }\n    SmallVector<SlotIndex, 8> Undefs;\n    IntB.computeSubRangeUndefs(Undefs, SR.LaneMask, *MRI,\n                               *LIS->getSlotIndexes());\n    LIS->extendToIndices(SR, EndPoints, Undefs);\n  }\n  // If any dead defs were extended, truncate them.\n  shrinkToUses(&IntB);\n\n  // Finally, update the live-range of IntA.\n  shrinkToUses(&IntA);\n  return true;\n}\n\n/// Returns true if @p MI defines the full vreg @p Reg, as opposed to just\n/// defining a subregister.\nstatic bool definesFullReg(const MachineInstr &MI, Register Reg) {\n  assert(!Reg.isPhysical() && \"This code cannot handle physreg aliasing\");\n\n  for (const MachineOperand &Op : MI.operands()) {\n    if (!Op.isReg() || !Op.isDef() || Op.getReg() != Reg)\n      continue;\n    // Return true if we define the full register or don't care about the value\n    // inside other subregisters.\n    if (Op.getSubReg() == 0 || Op.isUndef())\n      return true;\n  }\n  return false;\n}\n\nbool RegisterCoalescer::reMaterializeTrivialDef(const CoalescerPair &CP,\n                                                MachineInstr *CopyMI,\n                                                bool &IsDefCopy) {\n  IsDefCopy = false;\n  Register SrcReg = CP.isFlipped() ? CP.getDstReg() : CP.getSrcReg();\n  unsigned SrcIdx = CP.isFlipped() ? CP.getDstIdx() : CP.getSrcIdx();\n  Register DstReg = CP.isFlipped() ? CP.getSrcReg() : CP.getDstReg();\n  unsigned DstIdx = CP.isFlipped() ? CP.getSrcIdx() : CP.getDstIdx();\n  if (Register::isPhysicalRegister(SrcReg))\n    return false;\n\n  LiveInterval &SrcInt = LIS->getInterval(SrcReg);\n  SlotIndex CopyIdx = LIS->getInstructionIndex(*CopyMI);\n  VNInfo *ValNo = SrcInt.Query(CopyIdx).valueIn();\n  if (!ValNo)\n    return false;\n  if (ValNo->isPHIDef() || ValNo->isUnused())\n    return false;\n  MachineInstr *DefMI = LIS->getInstructionFromIndex(ValNo->def);\n  if (!DefMI)\n    return false;\n  if (DefMI->isCopyLike()) {\n    IsDefCopy = true;\n    return false;\n  }\n  if (!TII->isAsCheapAsAMove(*DefMI))\n    return false;\n  if (!TII->isTriviallyReMaterializable(*DefMI, AA))\n    return false;\n  if (!definesFullReg(*DefMI, SrcReg))\n    return false;\n  bool SawStore = false;\n  if (!DefMI->isSafeToMove(AA, SawStore))\n    return false;\n  const MCInstrDesc &MCID = DefMI->getDesc();\n  if (MCID.getNumDefs() != 1)\n    return false;\n  // Only support subregister destinations when the def is read-undef.\n  MachineOperand &DstOperand = CopyMI->getOperand(0);\n  Register CopyDstReg = DstOperand.getReg();\n  if (DstOperand.getSubReg() && !DstOperand.isUndef())\n    return false;\n\n  // If both SrcIdx and DstIdx are set, correct rematerialization would widen\n  // the register substantially (beyond both source and dest size). This is bad\n  // for performance since it can cascade through a function, introducing many\n  // extra spills and fills (e.g. ARM can easily end up copying QQQQPR registers\n  // around after a few subreg copies).\n  if (SrcIdx && DstIdx)\n    return false;\n\n  const TargetRegisterClass *DefRC = TII->getRegClass(MCID, 0, TRI, *MF);\n  if (!DefMI->isImplicitDef()) {\n    if (DstReg.isPhysical()) {\n      Register NewDstReg = DstReg;\n\n      unsigned NewDstIdx = TRI->composeSubRegIndices(CP.getSrcIdx(),\n                                              DefMI->getOperand(0).getSubReg());\n      if (NewDstIdx)\n        NewDstReg = TRI->getSubReg(DstReg, NewDstIdx);\n\n      // Finally, make sure that the physical subregister that will be\n      // constructed later is permitted for the instruction.\n      if (!DefRC->contains(NewDstReg))\n        return false;\n    } else {\n      // Theoretically, some stack frame reference could exist. Just make sure\n      // it hasn't actually happened.\n      assert(Register::isVirtualRegister(DstReg) &&\n             \"Only expect to deal with virtual or physical registers\");\n    }\n  }\n\n  DebugLoc DL = CopyMI->getDebugLoc();\n  MachineBasicBlock *MBB = CopyMI->getParent();\n  MachineBasicBlock::iterator MII =\n    std::next(MachineBasicBlock::iterator(CopyMI));\n  TII->reMaterialize(*MBB, MII, DstReg, SrcIdx, *DefMI, *TRI);\n  MachineInstr &NewMI = *std::prev(MII);\n  NewMI.setDebugLoc(DL);\n\n  // In a situation like the following:\n  //     %0:subreg = instr              ; DefMI, subreg = DstIdx\n  //     %1        = copy %0:subreg ; CopyMI, SrcIdx = 0\n  // instead of widening %1 to the register class of %0 simply do:\n  //     %1 = instr\n  const TargetRegisterClass *NewRC = CP.getNewRC();\n  if (DstIdx != 0) {\n    MachineOperand &DefMO = NewMI.getOperand(0);\n    if (DefMO.getSubReg() == DstIdx) {\n      assert(SrcIdx == 0 && CP.isFlipped()\n             && \"Shouldn't have SrcIdx+DstIdx at this point\");\n      const TargetRegisterClass *DstRC = MRI->getRegClass(DstReg);\n      const TargetRegisterClass *CommonRC =\n        TRI->getCommonSubClass(DefRC, DstRC);\n      if (CommonRC != nullptr) {\n        NewRC = CommonRC;\n        DstIdx = 0;\n        DefMO.setSubReg(0);\n        DefMO.setIsUndef(false); // Only subregs can have def+undef.\n      }\n    }\n  }\n\n  // CopyMI may have implicit operands, save them so that we can transfer them\n  // over to the newly materialized instruction after CopyMI is removed.\n  SmallVector<MachineOperand, 4> ImplicitOps;\n  ImplicitOps.reserve(CopyMI->getNumOperands() -\n                      CopyMI->getDesc().getNumOperands());\n  for (unsigned I = CopyMI->getDesc().getNumOperands(),\n                E = CopyMI->getNumOperands();\n       I != E; ++I) {\n    MachineOperand &MO = CopyMI->getOperand(I);\n    if (MO.isReg()) {\n      assert(MO.isImplicit() && \"No explicit operands after implicit operands.\");\n      // Discard VReg implicit defs.\n      if (Register::isPhysicalRegister(MO.getReg()))\n        ImplicitOps.push_back(MO);\n    }\n  }\n\n  LIS->ReplaceMachineInstrInMaps(*CopyMI, NewMI);\n  CopyMI->eraseFromParent();\n  ErasedInstrs.insert(CopyMI);\n\n  // NewMI may have dead implicit defs (E.g. EFLAGS for MOV<bits>r0 on X86).\n  // We need to remember these so we can add intervals once we insert\n  // NewMI into SlotIndexes.\n  SmallVector<MCRegister, 4> NewMIImplDefs;\n  for (unsigned i = NewMI.getDesc().getNumOperands(),\n                e = NewMI.getNumOperands();\n       i != e; ++i) {\n    MachineOperand &MO = NewMI.getOperand(i);\n    if (MO.isReg() && MO.isDef()) {\n      assert(MO.isImplicit() && MO.isDead() &&\n             Register::isPhysicalRegister(MO.getReg()));\n      NewMIImplDefs.push_back(MO.getReg().asMCReg());\n    }\n  }\n\n  if (DstReg.isVirtual()) {\n    unsigned NewIdx = NewMI.getOperand(0).getSubReg();\n\n    if (DefRC != nullptr) {\n      if (NewIdx)\n        NewRC = TRI->getMatchingSuperRegClass(NewRC, DefRC, NewIdx);\n      else\n        NewRC = TRI->getCommonSubClass(NewRC, DefRC);\n      assert(NewRC && \"subreg chosen for remat incompatible with instruction\");\n    }\n    // Remap subranges to new lanemask and change register class.\n    LiveInterval &DstInt = LIS->getInterval(DstReg);\n    for (LiveInterval::SubRange &SR : DstInt.subranges()) {\n      SR.LaneMask = TRI->composeSubRegIndexLaneMask(DstIdx, SR.LaneMask);\n    }\n    MRI->setRegClass(DstReg, NewRC);\n\n    // Update machine operands and add flags.\n    updateRegDefsUses(DstReg, DstReg, DstIdx);\n    NewMI.getOperand(0).setSubReg(NewIdx);\n    // updateRegDefUses can add an \"undef\" flag to the definition, since\n    // it will replace DstReg with DstReg.DstIdx. If NewIdx is 0, make\n    // sure that \"undef\" is not set.\n    if (NewIdx == 0)\n      NewMI.getOperand(0).setIsUndef(false);\n    // Add dead subregister definitions if we are defining the whole register\n    // but only part of it is live.\n    // This could happen if the rematerialization instruction is rematerializing\n    // more than actually is used in the register.\n    // An example would be:\n    // %1 = LOAD CONSTANTS 5, 8 ; Loading both 5 and 8 in different subregs\n    // ; Copying only part of the register here, but the rest is undef.\n    // %2:sub_16bit<def, read-undef> = COPY %1:sub_16bit\n    // ==>\n    // ; Materialize all the constants but only using one\n    // %2 = LOAD_CONSTANTS 5, 8\n    //\n    // at this point for the part that wasn't defined before we could have\n    // subranges missing the definition.\n    if (NewIdx == 0 && DstInt.hasSubRanges()) {\n      SlotIndex CurrIdx = LIS->getInstructionIndex(NewMI);\n      SlotIndex DefIndex =\n          CurrIdx.getRegSlot(NewMI.getOperand(0).isEarlyClobber());\n      LaneBitmask MaxMask = MRI->getMaxLaneMaskForVReg(DstReg);\n      VNInfo::Allocator& Alloc = LIS->getVNInfoAllocator();\n      for (LiveInterval::SubRange &SR : DstInt.subranges()) {\n        if (!SR.liveAt(DefIndex))\n          SR.createDeadDef(DefIndex, Alloc);\n        MaxMask &= ~SR.LaneMask;\n      }\n      if (MaxMask.any()) {\n        LiveInterval::SubRange *SR = DstInt.createSubRange(Alloc, MaxMask);\n        SR->createDeadDef(DefIndex, Alloc);\n      }\n    }\n\n    // Make sure that the subrange for resultant undef is removed\n    // For example:\n    //   %1:sub1<def,read-undef> = LOAD CONSTANT 1\n    //   %2 = COPY %1\n    // ==>\n    //   %2:sub1<def, read-undef> = LOAD CONSTANT 1\n    //     ; Correct but need to remove the subrange for %2:sub0\n    //     ; as it is now undef\n    if (NewIdx != 0 && DstInt.hasSubRanges()) {\n      // The affected subregister segments can be removed.\n      SlotIndex CurrIdx = LIS->getInstructionIndex(NewMI);\n      LaneBitmask DstMask = TRI->getSubRegIndexLaneMask(NewIdx);\n      bool UpdatedSubRanges = false;\n      SlotIndex DefIndex =\n          CurrIdx.getRegSlot(NewMI.getOperand(0).isEarlyClobber());\n      VNInfo::Allocator &Alloc = LIS->getVNInfoAllocator();\n      for (LiveInterval::SubRange &SR : DstInt.subranges()) {\n        if ((SR.LaneMask & DstMask).none()) {\n          LLVM_DEBUG(dbgs()\n                     << \"Removing undefined SubRange \"\n                     << PrintLaneMask(SR.LaneMask) << \" : \" << SR << \"\\n\");\n          // VNI is in ValNo - remove any segments in this SubRange that have this ValNo\n          if (VNInfo *RmValNo = SR.getVNInfoAt(CurrIdx.getRegSlot())) {\n            SR.removeValNo(RmValNo);\n            UpdatedSubRanges = true;\n          }\n        } else {\n          // We know that this lane is defined by this instruction,\n          // but at this point it may be empty because it is not used by\n          // anything. This happens when updateRegDefUses adds the missing\n          // lanes. Assign that lane a dead def so that the interferences\n          // are properly modeled.\n          if (SR.empty())\n            SR.createDeadDef(DefIndex, Alloc);\n        }\n      }\n      if (UpdatedSubRanges)\n        DstInt.removeEmptySubRanges();\n    }\n  } else if (NewMI.getOperand(0).getReg() != CopyDstReg) {\n    // The New instruction may be defining a sub-register of what's actually\n    // been asked for. If so it must implicitly define the whole thing.\n    assert(Register::isPhysicalRegister(DstReg) &&\n           \"Only expect virtual or physical registers in remat\");\n    NewMI.getOperand(0).setIsDead(true);\n    NewMI.addOperand(MachineOperand::CreateReg(\n        CopyDstReg, true /*IsDef*/, true /*IsImp*/, false /*IsKill*/));\n    // Record small dead def live-ranges for all the subregisters\n    // of the destination register.\n    // Otherwise, variables that live through may miss some\n    // interferences, thus creating invalid allocation.\n    // E.g., i386 code:\n    // %1 = somedef ; %1 GR8\n    // %2 = remat ; %2 GR32\n    // CL = COPY %2.sub_8bit\n    // = somedef %1 ; %1 GR8\n    // =>\n    // %1 = somedef ; %1 GR8\n    // dead ECX = remat ; implicit-def CL\n    // = somedef %1 ; %1 GR8\n    // %1 will see the interferences with CL but not with CH since\n    // no live-ranges would have been created for ECX.\n    // Fix that!\n    SlotIndex NewMIIdx = LIS->getInstructionIndex(NewMI);\n    for (MCRegUnitIterator Units(NewMI.getOperand(0).getReg(), TRI);\n         Units.isValid(); ++Units)\n      if (LiveRange *LR = LIS->getCachedRegUnit(*Units))\n        LR->createDeadDef(NewMIIdx.getRegSlot(), LIS->getVNInfoAllocator());\n  }\n\n  if (NewMI.getOperand(0).getSubReg())\n    NewMI.getOperand(0).setIsUndef();\n\n  // Transfer over implicit operands to the rematerialized instruction.\n  for (MachineOperand &MO : ImplicitOps)\n    NewMI.addOperand(MO);\n\n  SlotIndex NewMIIdx = LIS->getInstructionIndex(NewMI);\n  for (unsigned i = 0, e = NewMIImplDefs.size(); i != e; ++i) {\n    MCRegister Reg = NewMIImplDefs[i];\n    for (MCRegUnitIterator Units(Reg, TRI); Units.isValid(); ++Units)\n      if (LiveRange *LR = LIS->getCachedRegUnit(*Units))\n        LR->createDeadDef(NewMIIdx.getRegSlot(), LIS->getVNInfoAllocator());\n  }\n\n  LLVM_DEBUG(dbgs() << \"Remat: \" << NewMI);\n  ++NumReMats;\n\n  // If the virtual SrcReg is completely eliminated, update all DBG_VALUEs\n  // to describe DstReg instead.\n  if (MRI->use_nodbg_empty(SrcReg)) {\n    for (MachineOperand &UseMO : MRI->use_operands(SrcReg)) {\n      MachineInstr *UseMI = UseMO.getParent();\n      if (UseMI->isDebugValue()) {\n        if (Register::isPhysicalRegister(DstReg))\n          UseMO.substPhysReg(DstReg, *TRI);\n        else\n          UseMO.setReg(DstReg);\n        // Move the debug value directly after the def of the rematerialized\n        // value in DstReg.\n        MBB->splice(std::next(NewMI.getIterator()), UseMI->getParent(), UseMI);\n        LLVM_DEBUG(dbgs() << \"\\t\\tupdated: \" << *UseMI);\n      }\n    }\n  }\n\n  if (ToBeUpdated.count(SrcReg))\n    return true;\n\n  unsigned NumCopyUses = 0;\n  for (MachineOperand &UseMO : MRI->use_nodbg_operands(SrcReg)) {\n    if (UseMO.getParent()->isCopyLike())\n      NumCopyUses++;\n  }\n  if (NumCopyUses < LateRematUpdateThreshold) {\n    // The source interval can become smaller because we removed a use.\n    shrinkToUses(&SrcInt, &DeadDefs);\n    if (!DeadDefs.empty())\n      eliminateDeadDefs();\n  } else {\n    ToBeUpdated.insert(SrcReg);\n  }\n  return true;\n}\n\nMachineInstr *RegisterCoalescer::eliminateUndefCopy(MachineInstr *CopyMI) {\n  // ProcessImplicitDefs may leave some copies of <undef> values, it only\n  // removes local variables. When we have a copy like:\n  //\n  //   %1 = COPY undef %2\n  //\n  // We delete the copy and remove the corresponding value number from %1.\n  // Any uses of that value number are marked as <undef>.\n\n  // Note that we do not query CoalescerPair here but redo isMoveInstr as the\n  // CoalescerPair may have a new register class with adjusted subreg indices\n  // at this point.\n  Register SrcReg, DstReg;\n  unsigned SrcSubIdx = 0, DstSubIdx = 0;\n  if(!isMoveInstr(*TRI, CopyMI, SrcReg, DstReg, SrcSubIdx, DstSubIdx))\n    return nullptr;\n\n  SlotIndex Idx = LIS->getInstructionIndex(*CopyMI);\n  const LiveInterval &SrcLI = LIS->getInterval(SrcReg);\n  // CopyMI is undef iff SrcReg is not live before the instruction.\n  if (SrcSubIdx != 0 && SrcLI.hasSubRanges()) {\n    LaneBitmask SrcMask = TRI->getSubRegIndexLaneMask(SrcSubIdx);\n    for (const LiveInterval::SubRange &SR : SrcLI.subranges()) {\n      if ((SR.LaneMask & SrcMask).none())\n        continue;\n      if (SR.liveAt(Idx))\n        return nullptr;\n    }\n  } else if (SrcLI.liveAt(Idx))\n    return nullptr;\n\n  // If the undef copy defines a live-out value (i.e. an input to a PHI def),\n  // then replace it with an IMPLICIT_DEF.\n  LiveInterval &DstLI = LIS->getInterval(DstReg);\n  SlotIndex RegIndex = Idx.getRegSlot();\n  LiveRange::Segment *Seg = DstLI.getSegmentContaining(RegIndex);\n  assert(Seg != nullptr && \"No segment for defining instruction\");\n  if (VNInfo *V = DstLI.getVNInfoAt(Seg->end)) {\n    if (V->isPHIDef()) {\n      CopyMI->setDesc(TII->get(TargetOpcode::IMPLICIT_DEF));\n      for (unsigned i = CopyMI->getNumOperands(); i != 0; --i) {\n        MachineOperand &MO = CopyMI->getOperand(i-1);\n        if (MO.isReg() && MO.isUse())\n          CopyMI->RemoveOperand(i-1);\n      }\n      LLVM_DEBUG(dbgs() << \"\\tReplaced copy of <undef> value with an \"\n                           \"implicit def\\n\");\n      return CopyMI;\n    }\n  }\n\n  // Remove any DstReg segments starting at the instruction.\n  LLVM_DEBUG(dbgs() << \"\\tEliminating copy of <undef> value\\n\");\n\n  // Remove value or merge with previous one in case of a subregister def.\n  if (VNInfo *PrevVNI = DstLI.getVNInfoAt(Idx)) {\n    VNInfo *VNI = DstLI.getVNInfoAt(RegIndex);\n    DstLI.MergeValueNumberInto(VNI, PrevVNI);\n\n    // The affected subregister segments can be removed.\n    LaneBitmask DstMask = TRI->getSubRegIndexLaneMask(DstSubIdx);\n    for (LiveInterval::SubRange &SR : DstLI.subranges()) {\n      if ((SR.LaneMask & DstMask).none())\n        continue;\n\n      VNInfo *SVNI = SR.getVNInfoAt(RegIndex);\n      assert(SVNI != nullptr && SlotIndex::isSameInstr(SVNI->def, RegIndex));\n      SR.removeValNo(SVNI);\n    }\n    DstLI.removeEmptySubRanges();\n  } else\n    LIS->removeVRegDefAt(DstLI, RegIndex);\n\n  // Mark uses as undef.\n  for (MachineOperand &MO : MRI->reg_nodbg_operands(DstReg)) {\n    if (MO.isDef() /*|| MO.isUndef()*/)\n      continue;\n    const MachineInstr &MI = *MO.getParent();\n    SlotIndex UseIdx = LIS->getInstructionIndex(MI);\n    LaneBitmask UseMask = TRI->getSubRegIndexLaneMask(MO.getSubReg());\n    bool isLive;\n    if (!UseMask.all() && DstLI.hasSubRanges()) {\n      isLive = false;\n      for (const LiveInterval::SubRange &SR : DstLI.subranges()) {\n        if ((SR.LaneMask & UseMask).none())\n          continue;\n        if (SR.liveAt(UseIdx)) {\n          isLive = true;\n          break;\n        }\n      }\n    } else\n      isLive = DstLI.liveAt(UseIdx);\n    if (isLive)\n      continue;\n    MO.setIsUndef(true);\n    LLVM_DEBUG(dbgs() << \"\\tnew undef: \" << UseIdx << '\\t' << MI);\n  }\n\n  // A def of a subregister may be a use of the other subregisters, so\n  // deleting a def of a subregister may also remove uses. Since CopyMI\n  // is still part of the function (but about to be erased), mark all\n  // defs of DstReg in it as <undef>, so that shrinkToUses would\n  // ignore them.\n  for (MachineOperand &MO : CopyMI->operands())\n    if (MO.isReg() && MO.isDef() && MO.getReg() == DstReg)\n      MO.setIsUndef(true);\n  LIS->shrinkToUses(&DstLI);\n\n  return CopyMI;\n}\n\nvoid RegisterCoalescer::addUndefFlag(const LiveInterval &Int, SlotIndex UseIdx,\n                                     MachineOperand &MO, unsigned SubRegIdx) {\n  LaneBitmask Mask = TRI->getSubRegIndexLaneMask(SubRegIdx);\n  if (MO.isDef())\n    Mask = ~Mask;\n  bool IsUndef = true;\n  for (const LiveInterval::SubRange &S : Int.subranges()) {\n    if ((S.LaneMask & Mask).none())\n      continue;\n    if (S.liveAt(UseIdx)) {\n      IsUndef = false;\n      break;\n    }\n  }\n  if (IsUndef) {\n    MO.setIsUndef(true);\n    // We found out some subregister use is actually reading an undefined\n    // value. In some cases the whole vreg has become undefined at this\n    // point so we have to potentially shrink the main range if the\n    // use was ending a live segment there.\n    LiveQueryResult Q = Int.Query(UseIdx);\n    if (Q.valueOut() == nullptr)\n      ShrinkMainRange = true;\n  }\n}\n\nvoid RegisterCoalescer::updateRegDefsUses(Register SrcReg, Register DstReg,\n                                          unsigned SubIdx) {\n  bool DstIsPhys = Register::isPhysicalRegister(DstReg);\n  LiveInterval *DstInt = DstIsPhys ? nullptr : &LIS->getInterval(DstReg);\n\n  if (DstInt && DstInt->hasSubRanges() && DstReg != SrcReg) {\n    for (MachineOperand &MO : MRI->reg_operands(DstReg)) {\n      unsigned SubReg = MO.getSubReg();\n      if (SubReg == 0 || MO.isUndef())\n        continue;\n      MachineInstr &MI = *MO.getParent();\n      if (MI.isDebugValue())\n        continue;\n      SlotIndex UseIdx = LIS->getInstructionIndex(MI).getRegSlot(true);\n      addUndefFlag(*DstInt, UseIdx, MO, SubReg);\n    }\n  }\n\n  SmallPtrSet<MachineInstr*, 8> Visited;\n  for (MachineRegisterInfo::reg_instr_iterator\n       I = MRI->reg_instr_begin(SrcReg), E = MRI->reg_instr_end();\n       I != E; ) {\n    MachineInstr *UseMI = &*(I++);\n\n    // Each instruction can only be rewritten once because sub-register\n    // composition is not always idempotent. When SrcReg != DstReg, rewriting\n    // the UseMI operands removes them from the SrcReg use-def chain, but when\n    // SrcReg is DstReg we could encounter UseMI twice if it has multiple\n    // operands mentioning the virtual register.\n    if (SrcReg == DstReg && !Visited.insert(UseMI).second)\n      continue;\n\n    SmallVector<unsigned,8> Ops;\n    bool Reads, Writes;\n    std::tie(Reads, Writes) = UseMI->readsWritesVirtualRegister(SrcReg, &Ops);\n\n    // If SrcReg wasn't read, it may still be the case that DstReg is live-in\n    // because SrcReg is a sub-register.\n    if (DstInt && !Reads && SubIdx && !UseMI->isDebugValue())\n      Reads = DstInt->liveAt(LIS->getInstructionIndex(*UseMI));\n\n    // Replace SrcReg with DstReg in all UseMI operands.\n    for (unsigned i = 0, e = Ops.size(); i != e; ++i) {\n      MachineOperand &MO = UseMI->getOperand(Ops[i]);\n\n      // Adjust <undef> flags in case of sub-register joins. We don't want to\n      // turn a full def into a read-modify-write sub-register def and vice\n      // versa.\n      if (SubIdx && MO.isDef())\n        MO.setIsUndef(!Reads);\n\n      // A subreg use of a partially undef (super) register may be a complete\n      // undef use now and then has to be marked that way.\n      if (SubIdx != 0 && MO.isUse() && MRI->shouldTrackSubRegLiveness(DstReg)) {\n        if (!DstInt->hasSubRanges()) {\n          BumpPtrAllocator &Allocator = LIS->getVNInfoAllocator();\n          LaneBitmask FullMask = MRI->getMaxLaneMaskForVReg(DstInt->reg());\n          LaneBitmask UsedLanes = TRI->getSubRegIndexLaneMask(SubIdx);\n          LaneBitmask UnusedLanes = FullMask & ~UsedLanes;\n          DstInt->createSubRangeFrom(Allocator, UsedLanes, *DstInt);\n          // The unused lanes are just empty live-ranges at this point.\n          // It is the caller responsibility to set the proper\n          // dead segments if there is an actual dead def of the\n          // unused lanes. This may happen with rematerialization.\n          DstInt->createSubRange(Allocator, UnusedLanes);\n        }\n        SlotIndex MIIdx = UseMI->isDebugValue()\n                              ? LIS->getSlotIndexes()->getIndexBefore(*UseMI)\n                              : LIS->getInstructionIndex(*UseMI);\n        SlotIndex UseIdx = MIIdx.getRegSlot(true);\n        addUndefFlag(*DstInt, UseIdx, MO, SubIdx);\n      }\n\n      if (DstIsPhys)\n        MO.substPhysReg(DstReg, *TRI);\n      else\n        MO.substVirtReg(DstReg, SubIdx, *TRI);\n    }\n\n    LLVM_DEBUG({\n      dbgs() << \"\\t\\tupdated: \";\n      if (!UseMI->isDebugValue())\n        dbgs() << LIS->getInstructionIndex(*UseMI) << \"\\t\";\n      dbgs() << *UseMI;\n    });\n  }\n}\n\nbool RegisterCoalescer::canJoinPhys(const CoalescerPair &CP) {\n  // Always join simple intervals that are defined by a single copy from a\n  // reserved register. This doesn't increase register pressure, so it is\n  // always beneficial.\n  if (!MRI->isReserved(CP.getDstReg())) {\n    LLVM_DEBUG(dbgs() << \"\\tCan only merge into reserved registers.\\n\");\n    return false;\n  }\n\n  LiveInterval &JoinVInt = LIS->getInterval(CP.getSrcReg());\n  if (JoinVInt.containsOneValue())\n    return true;\n\n  LLVM_DEBUG(\n      dbgs() << \"\\tCannot join complex intervals into reserved register.\\n\");\n  return false;\n}\n\nbool RegisterCoalescer::copyValueUndefInPredecessors(\n    LiveRange &S, const MachineBasicBlock *MBB, LiveQueryResult SLRQ) {\n  for (const MachineBasicBlock *Pred : MBB->predecessors()) {\n    SlotIndex PredEnd = LIS->getMBBEndIdx(Pred);\n    if (VNInfo *V = S.getVNInfoAt(PredEnd.getPrevSlot())) {\n      // If this is a self loop, we may be reading the same value.\n      if (V->id != SLRQ.valueOutOrDead()->id)\n        return false;\n    }\n  }\n\n  return true;\n}\n\nvoid RegisterCoalescer::setUndefOnPrunedSubRegUses(LiveInterval &LI,\n                                                   Register Reg,\n                                                   LaneBitmask PrunedLanes) {\n  // If we had other instructions in the segment reading the undef sublane\n  // value, we need to mark them with undef.\n  for (MachineOperand &MO : MRI->use_nodbg_operands(Reg)) {\n    unsigned SubRegIdx = MO.getSubReg();\n    if (SubRegIdx == 0 || MO.isUndef())\n      continue;\n\n    LaneBitmask SubRegMask = TRI->getSubRegIndexLaneMask(SubRegIdx);\n    SlotIndex Pos = LIS->getInstructionIndex(*MO.getParent());\n    for (LiveInterval::SubRange &S : LI.subranges()) {\n      if (!S.liveAt(Pos) && (PrunedLanes & SubRegMask).any()) {\n        MO.setIsUndef();\n        break;\n      }\n    }\n  }\n\n  LI.removeEmptySubRanges();\n\n  // A def of a subregister may be a use of other register lanes. Replacing\n  // such a def with a def of a different register will eliminate the use,\n  // and may cause the recorded live range to be larger than the actual\n  // liveness in the program IR.\n  LIS->shrinkToUses(&LI);\n}\n\nbool RegisterCoalescer::joinCopy(MachineInstr *CopyMI, bool &Again) {\n  Again = false;\n  LLVM_DEBUG(dbgs() << LIS->getInstructionIndex(*CopyMI) << '\\t' << *CopyMI);\n\n  CoalescerPair CP(*TRI);\n  if (!CP.setRegisters(CopyMI)) {\n    LLVM_DEBUG(dbgs() << \"\\tNot coalescable.\\n\");\n    return false;\n  }\n\n  if (CP.getNewRC()) {\n    auto SrcRC = MRI->getRegClass(CP.getSrcReg());\n    auto DstRC = MRI->getRegClass(CP.getDstReg());\n    unsigned SrcIdx = CP.getSrcIdx();\n    unsigned DstIdx = CP.getDstIdx();\n    if (CP.isFlipped()) {\n      std::swap(SrcIdx, DstIdx);\n      std::swap(SrcRC, DstRC);\n    }\n    if (!TRI->shouldCoalesce(CopyMI, SrcRC, SrcIdx, DstRC, DstIdx,\n                             CP.getNewRC(), *LIS)) {\n      LLVM_DEBUG(dbgs() << \"\\tSubtarget bailed on coalescing.\\n\");\n      return false;\n    }\n  }\n\n  // Dead code elimination. This really should be handled by MachineDCE, but\n  // sometimes dead copies slip through, and we can't generate invalid live\n  // ranges.\n  if (!CP.isPhys() && CopyMI->allDefsAreDead()) {\n    LLVM_DEBUG(dbgs() << \"\\tCopy is dead.\\n\");\n    DeadDefs.push_back(CopyMI);\n    eliminateDeadDefs();\n    return true;\n  }\n\n  // Eliminate undefs.\n  if (!CP.isPhys()) {\n    // If this is an IMPLICIT_DEF, leave it alone, but don't try to coalesce.\n    if (MachineInstr *UndefMI = eliminateUndefCopy(CopyMI)) {\n      if (UndefMI->isImplicitDef())\n        return false;\n      deleteInstr(CopyMI);\n      return false;  // Not coalescable.\n    }\n  }\n\n  // Coalesced copies are normally removed immediately, but transformations\n  // like removeCopyByCommutingDef() can inadvertently create identity copies.\n  // When that happens, just join the values and remove the copy.\n  if (CP.getSrcReg() == CP.getDstReg()) {\n    LiveInterval &LI = LIS->getInterval(CP.getSrcReg());\n    LLVM_DEBUG(dbgs() << \"\\tCopy already coalesced: \" << LI << '\\n');\n    const SlotIndex CopyIdx = LIS->getInstructionIndex(*CopyMI);\n    LiveQueryResult LRQ = LI.Query(CopyIdx);\n    if (VNInfo *DefVNI = LRQ.valueDefined()) {\n      VNInfo *ReadVNI = LRQ.valueIn();\n      assert(ReadVNI && \"No value before copy and no <undef> flag.\");\n      assert(ReadVNI != DefVNI && \"Cannot read and define the same value.\");\n\n      // Track incoming undef lanes we need to eliminate from the subrange.\n      LaneBitmask PrunedLanes;\n      MachineBasicBlock *MBB = CopyMI->getParent();\n\n      // Process subregister liveranges.\n      for (LiveInterval::SubRange &S : LI.subranges()) {\n        LiveQueryResult SLRQ = S.Query(CopyIdx);\n        if (VNInfo *SDefVNI = SLRQ.valueDefined()) {\n          if (VNInfo *SReadVNI = SLRQ.valueIn())\n            SDefVNI = S.MergeValueNumberInto(SDefVNI, SReadVNI);\n\n          // If this copy introduced an undef subrange from an incoming value,\n          // we need to eliminate the undef live in values from the subrange.\n          if (copyValueUndefInPredecessors(S, MBB, SLRQ)) {\n            LLVM_DEBUG(dbgs() << \"Incoming sublane value is undef at copy\\n\");\n            PrunedLanes |= S.LaneMask;\n            S.removeValNo(SDefVNI);\n          }\n        }\n      }\n\n      LI.MergeValueNumberInto(DefVNI, ReadVNI);\n      if (PrunedLanes.any()) {\n        LLVM_DEBUG(dbgs() << \"Pruning undef incoming lanes: \"\n                          << PrunedLanes << '\\n');\n        setUndefOnPrunedSubRegUses(LI, CP.getSrcReg(), PrunedLanes);\n      }\n\n      LLVM_DEBUG(dbgs() << \"\\tMerged values:          \" << LI << '\\n');\n    }\n    deleteInstr(CopyMI);\n    return true;\n  }\n\n  // Enforce policies.\n  if (CP.isPhys()) {\n    LLVM_DEBUG(dbgs() << \"\\tConsidering merging \"\n                      << printReg(CP.getSrcReg(), TRI) << \" with \"\n                      << printReg(CP.getDstReg(), TRI, CP.getSrcIdx()) << '\\n');\n    if (!canJoinPhys(CP)) {\n      // Before giving up coalescing, if definition of source is defined by\n      // trivial computation, try rematerializing it.\n      bool IsDefCopy = false;\n      if (reMaterializeTrivialDef(CP, CopyMI, IsDefCopy))\n        return true;\n      if (IsDefCopy)\n        Again = true;  // May be possible to coalesce later.\n      return false;\n    }\n  } else {\n    // When possible, let DstReg be the larger interval.\n    if (!CP.isPartial() && LIS->getInterval(CP.getSrcReg()).size() >\n                           LIS->getInterval(CP.getDstReg()).size())\n      CP.flip();\n\n    LLVM_DEBUG({\n      dbgs() << \"\\tConsidering merging to \"\n             << TRI->getRegClassName(CP.getNewRC()) << \" with \";\n      if (CP.getDstIdx() && CP.getSrcIdx())\n        dbgs() << printReg(CP.getDstReg()) << \" in \"\n               << TRI->getSubRegIndexName(CP.getDstIdx()) << \" and \"\n               << printReg(CP.getSrcReg()) << \" in \"\n               << TRI->getSubRegIndexName(CP.getSrcIdx()) << '\\n';\n      else\n        dbgs() << printReg(CP.getSrcReg(), TRI) << \" in \"\n               << printReg(CP.getDstReg(), TRI, CP.getSrcIdx()) << '\\n';\n    });\n  }\n\n  ShrinkMask = LaneBitmask::getNone();\n  ShrinkMainRange = false;\n\n  // Okay, attempt to join these two intervals.  On failure, this returns false.\n  // Otherwise, if one of the intervals being joined is a physreg, this method\n  // always canonicalizes DstInt to be it.  The output \"SrcInt\" will not have\n  // been modified, so we can use this information below to update aliases.\n  if (!joinIntervals(CP)) {\n    // Coalescing failed.\n\n    // If definition of source is defined by trivial computation, try\n    // rematerializing it.\n    bool IsDefCopy = false;\n    if (reMaterializeTrivialDef(CP, CopyMI, IsDefCopy))\n      return true;\n\n    // If we can eliminate the copy without merging the live segments, do so\n    // now.\n    if (!CP.isPartial() && !CP.isPhys()) {\n      bool Changed = adjustCopiesBackFrom(CP, CopyMI);\n      bool Shrink = false;\n      if (!Changed)\n        std::tie(Changed, Shrink) = removeCopyByCommutingDef(CP, CopyMI);\n      if (Changed) {\n        deleteInstr(CopyMI);\n        if (Shrink) {\n          Register DstReg = CP.isFlipped() ? CP.getSrcReg() : CP.getDstReg();\n          LiveInterval &DstLI = LIS->getInterval(DstReg);\n          shrinkToUses(&DstLI);\n          LLVM_DEBUG(dbgs() << \"\\t\\tshrunk:   \" << DstLI << '\\n');\n        }\n        LLVM_DEBUG(dbgs() << \"\\tTrivial!\\n\");\n        return true;\n      }\n    }\n\n    // Try and see if we can partially eliminate the copy by moving the copy to\n    // its predecessor.\n    if (!CP.isPartial() && !CP.isPhys())\n      if (removePartialRedundancy(CP, *CopyMI))\n        return true;\n\n    // Otherwise, we are unable to join the intervals.\n    LLVM_DEBUG(dbgs() << \"\\tInterference!\\n\");\n    Again = true;  // May be possible to coalesce later.\n    return false;\n  }\n\n  // Coalescing to a virtual register that is of a sub-register class of the\n  // other. Make sure the resulting register is set to the right register class.\n  if (CP.isCrossClass()) {\n    ++numCrossRCs;\n    MRI->setRegClass(CP.getDstReg(), CP.getNewRC());\n  }\n\n  // Removing sub-register copies can ease the register class constraints.\n  // Make sure we attempt to inflate the register class of DstReg.\n  if (!CP.isPhys() && RegClassInfo.isProperSubClass(CP.getNewRC()))\n    InflateRegs.push_back(CP.getDstReg());\n\n  // CopyMI has been erased by joinIntervals at this point. Remove it from\n  // ErasedInstrs since copyCoalesceWorkList() won't add a successful join back\n  // to the work list. This keeps ErasedInstrs from growing needlessly.\n  ErasedInstrs.erase(CopyMI);\n\n  // Rewrite all SrcReg operands to DstReg.\n  // Also update DstReg operands to include DstIdx if it is set.\n  if (CP.getDstIdx())\n    updateRegDefsUses(CP.getDstReg(), CP.getDstReg(), CP.getDstIdx());\n  updateRegDefsUses(CP.getSrcReg(), CP.getDstReg(), CP.getSrcIdx());\n\n  // Shrink subregister ranges if necessary.\n  if (ShrinkMask.any()) {\n    LiveInterval &LI = LIS->getInterval(CP.getDstReg());\n    for (LiveInterval::SubRange &S : LI.subranges()) {\n      if ((S.LaneMask & ShrinkMask).none())\n        continue;\n      LLVM_DEBUG(dbgs() << \"Shrink LaneUses (Lane \" << PrintLaneMask(S.LaneMask)\n                        << \")\\n\");\n      LIS->shrinkToUses(S, LI.reg());\n    }\n    LI.removeEmptySubRanges();\n  }\n\n  // CP.getSrcReg()'s live interval has been merged into CP.getDstReg's live\n  // interval. Since CP.getSrcReg() is in ToBeUpdated set and its live interval\n  // is not up-to-date, need to update the merged live interval here.\n  if (ToBeUpdated.count(CP.getSrcReg()))\n    ShrinkMainRange = true;\n\n  if (ShrinkMainRange) {\n    LiveInterval &LI = LIS->getInterval(CP.getDstReg());\n    shrinkToUses(&LI);\n  }\n\n  // SrcReg is guaranteed to be the register whose live interval that is\n  // being merged.\n  LIS->removeInterval(CP.getSrcReg());\n\n  // Update regalloc hint.\n  TRI->updateRegAllocHint(CP.getSrcReg(), CP.getDstReg(), *MF);\n\n  LLVM_DEBUG({\n    dbgs() << \"\\tSuccess: \" << printReg(CP.getSrcReg(), TRI, CP.getSrcIdx())\n           << \" -> \" << printReg(CP.getDstReg(), TRI, CP.getDstIdx()) << '\\n';\n    dbgs() << \"\\tResult = \";\n    if (CP.isPhys())\n      dbgs() << printReg(CP.getDstReg(), TRI);\n    else\n      dbgs() << LIS->getInterval(CP.getDstReg());\n    dbgs() << '\\n';\n  });\n\n  ++numJoins;\n  return true;\n}\n\nbool RegisterCoalescer::joinReservedPhysReg(CoalescerPair &CP) {\n  Register DstReg = CP.getDstReg();\n  Register SrcReg = CP.getSrcReg();\n  assert(CP.isPhys() && \"Must be a physreg copy\");\n  assert(MRI->isReserved(DstReg) && \"Not a reserved register\");\n  LiveInterval &RHS = LIS->getInterval(SrcReg);\n  LLVM_DEBUG(dbgs() << \"\\t\\tRHS = \" << RHS << '\\n');\n\n  assert(RHS.containsOneValue() && \"Invalid join with reserved register\");\n\n  // Optimization for reserved registers like ESP. We can only merge with a\n  // reserved physreg if RHS has a single value that is a copy of DstReg.\n  // The live range of the reserved register will look like a set of dead defs\n  // - we don't properly track the live range of reserved registers.\n\n  // Deny any overlapping intervals.  This depends on all the reserved\n  // register live ranges to look like dead defs.\n  if (!MRI->isConstantPhysReg(DstReg)) {\n    for (MCRegUnitIterator UI(DstReg, TRI); UI.isValid(); ++UI) {\n      // Abort if not all the regunits are reserved.\n      for (MCRegUnitRootIterator RI(*UI, TRI); RI.isValid(); ++RI) {\n        if (!MRI->isReserved(*RI))\n          return false;\n      }\n      if (RHS.overlaps(LIS->getRegUnit(*UI))) {\n        LLVM_DEBUG(dbgs() << \"\\t\\tInterference: \" << printRegUnit(*UI, TRI)\n                          << '\\n');\n        return false;\n      }\n    }\n\n    // We must also check for overlaps with regmask clobbers.\n    BitVector RegMaskUsable;\n    if (LIS->checkRegMaskInterference(RHS, RegMaskUsable) &&\n        !RegMaskUsable.test(DstReg)) {\n      LLVM_DEBUG(dbgs() << \"\\t\\tRegMask interference\\n\");\n      return false;\n    }\n  }\n\n  // Skip any value computations, we are not adding new values to the\n  // reserved register.  Also skip merging the live ranges, the reserved\n  // register live range doesn't need to be accurate as long as all the\n  // defs are there.\n\n  // Delete the identity copy.\n  MachineInstr *CopyMI;\n  if (CP.isFlipped()) {\n    // Physreg is copied into vreg\n    //   %y = COPY %physreg_x\n    //   ...  //< no other def of %physreg_x here\n    //   use %y\n    // =>\n    //   ...\n    //   use %physreg_x\n    CopyMI = MRI->getVRegDef(SrcReg);\n  } else {\n    // VReg is copied into physreg:\n    //   %y = def\n    //   ... //< no other def or use of %physreg_x here\n    //   %physreg_x = COPY %y\n    // =>\n    //   %physreg_x = def\n    //   ...\n    if (!MRI->hasOneNonDBGUse(SrcReg)) {\n      LLVM_DEBUG(dbgs() << \"\\t\\tMultiple vreg uses!\\n\");\n      return false;\n    }\n\n    if (!LIS->intervalIsInOneMBB(RHS)) {\n      LLVM_DEBUG(dbgs() << \"\\t\\tComplex control flow!\\n\");\n      return false;\n    }\n\n    MachineInstr &DestMI = *MRI->getVRegDef(SrcReg);\n    CopyMI = &*MRI->use_instr_nodbg_begin(SrcReg);\n    SlotIndex CopyRegIdx = LIS->getInstructionIndex(*CopyMI).getRegSlot();\n    SlotIndex DestRegIdx = LIS->getInstructionIndex(DestMI).getRegSlot();\n\n    if (!MRI->isConstantPhysReg(DstReg)) {\n      // We checked above that there are no interfering defs of the physical\n      // register. However, for this case, where we intend to move up the def of\n      // the physical register, we also need to check for interfering uses.\n      SlotIndexes *Indexes = LIS->getSlotIndexes();\n      for (SlotIndex SI = Indexes->getNextNonNullIndex(DestRegIdx);\n           SI != CopyRegIdx; SI = Indexes->getNextNonNullIndex(SI)) {\n        MachineInstr *MI = LIS->getInstructionFromIndex(SI);\n        if (MI->readsRegister(DstReg, TRI)) {\n          LLVM_DEBUG(dbgs() << \"\\t\\tInterference (read): \" << *MI);\n          return false;\n        }\n      }\n    }\n\n    // We're going to remove the copy which defines a physical reserved\n    // register, so remove its valno, etc.\n    LLVM_DEBUG(dbgs() << \"\\t\\tRemoving phys reg def of \"\n                      << printReg(DstReg, TRI) << \" at \" << CopyRegIdx << \"\\n\");\n\n    LIS->removePhysRegDefAt(DstReg.asMCReg(), CopyRegIdx);\n    // Create a new dead def at the new def location.\n    for (MCRegUnitIterator UI(DstReg, TRI); UI.isValid(); ++UI) {\n      LiveRange &LR = LIS->getRegUnit(*UI);\n      LR.createDeadDef(DestRegIdx, LIS->getVNInfoAllocator());\n    }\n  }\n\n  deleteInstr(CopyMI);\n\n  // We don't track kills for reserved registers.\n  MRI->clearKillFlags(CP.getSrcReg());\n\n  return true;\n}\n\n//===----------------------------------------------------------------------===//\n//                 Interference checking and interval joining\n//===----------------------------------------------------------------------===//\n//\n// In the easiest case, the two live ranges being joined are disjoint, and\n// there is no interference to consider. It is quite common, though, to have\n// overlapping live ranges, and we need to check if the interference can be\n// resolved.\n//\n// The live range of a single SSA value forms a sub-tree of the dominator tree.\n// This means that two SSA values overlap if and only if the def of one value\n// is contained in the live range of the other value. As a special case, the\n// overlapping values can be defined at the same index.\n//\n// The interference from an overlapping def can be resolved in these cases:\n//\n// 1. Coalescable copies. The value is defined by a copy that would become an\n//    identity copy after joining SrcReg and DstReg. The copy instruction will\n//    be removed, and the value will be merged with the source value.\n//\n//    There can be several copies back and forth, causing many values to be\n//    merged into one. We compute a list of ultimate values in the joined live\n//    range as well as a mappings from the old value numbers.\n//\n// 2. IMPLICIT_DEF. This instruction is only inserted to ensure all PHI\n//    predecessors have a live out value. It doesn't cause real interference,\n//    and can be merged into the value it overlaps. Like a coalescable copy, it\n//    can be erased after joining.\n//\n// 3. Copy of external value. The overlapping def may be a copy of a value that\n//    is already in the other register. This is like a coalescable copy, but\n//    the live range of the source register must be trimmed after erasing the\n//    copy instruction:\n//\n//      %src = COPY %ext\n//      %dst = COPY %ext  <-- Remove this COPY, trim the live range of %ext.\n//\n// 4. Clobbering undefined lanes. Vector registers are sometimes built by\n//    defining one lane at a time:\n//\n//      %dst:ssub0<def,read-undef> = FOO\n//      %src = BAR\n//      %dst:ssub1 = COPY %src\n//\n//    The live range of %src overlaps the %dst value defined by FOO, but\n//    merging %src into %dst:ssub1 is only going to clobber the ssub1 lane\n//    which was undef anyway.\n//\n//    The value mapping is more complicated in this case. The final live range\n//    will have different value numbers for both FOO and BAR, but there is no\n//    simple mapping from old to new values. It may even be necessary to add\n//    new PHI values.\n//\n// 5. Clobbering dead lanes. A def may clobber a lane of a vector register that\n//    is live, but never read. This can happen because we don't compute\n//    individual live ranges per lane.\n//\n//      %dst = FOO\n//      %src = BAR\n//      %dst:ssub1 = COPY %src\n//\n//    This kind of interference is only resolved locally. If the clobbered\n//    lane value escapes the block, the join is aborted.\n\nnamespace {\n\n/// Track information about values in a single virtual register about to be\n/// joined. Objects of this class are always created in pairs - one for each\n/// side of the CoalescerPair (or one for each lane of a side of the coalescer\n/// pair)\nclass JoinVals {\n  /// Live range we work on.\n  LiveRange &LR;\n\n  /// (Main) register we work on.\n  const Register Reg;\n\n  /// Reg (and therefore the values in this liverange) will end up as\n  /// subregister SubIdx in the coalesced register. Either CP.DstIdx or\n  /// CP.SrcIdx.\n  const unsigned SubIdx;\n\n  /// The LaneMask that this liverange will occupy the coalesced register. May\n  /// be smaller than the lanemask produced by SubIdx when merging subranges.\n  const LaneBitmask LaneMask;\n\n  /// This is true when joining sub register ranges, false when joining main\n  /// ranges.\n  const bool SubRangeJoin;\n\n  /// Whether the current LiveInterval tracks subregister liveness.\n  const bool TrackSubRegLiveness;\n\n  /// Values that will be present in the final live range.\n  SmallVectorImpl<VNInfo*> &NewVNInfo;\n\n  const CoalescerPair &CP;\n  LiveIntervals *LIS;\n  SlotIndexes *Indexes;\n  const TargetRegisterInfo *TRI;\n\n  /// Value number assignments. Maps value numbers in LI to entries in\n  /// NewVNInfo. This is suitable for passing to LiveInterval::join().\n  SmallVector<int, 8> Assignments;\n\n  public:\n  /// Conflict resolution for overlapping values.\n  enum ConflictResolution {\n    /// No overlap, simply keep this value.\n    CR_Keep,\n\n    /// Merge this value into OtherVNI and erase the defining instruction.\n    /// Used for IMPLICIT_DEF, coalescable copies, and copies from external\n    /// values.\n    CR_Erase,\n\n    /// Merge this value into OtherVNI but keep the defining instruction.\n    /// This is for the special case where OtherVNI is defined by the same\n    /// instruction.\n    CR_Merge,\n\n    /// Keep this value, and have it replace OtherVNI where possible. This\n    /// complicates value mapping since OtherVNI maps to two different values\n    /// before and after this def.\n    /// Used when clobbering undefined or dead lanes.\n    CR_Replace,\n\n    /// Unresolved conflict. Visit later when all values have been mapped.\n    CR_Unresolved,\n\n    /// Unresolvable conflict. Abort the join.\n    CR_Impossible\n  };\n\n  private:\n  /// Per-value info for LI. The lane bit masks are all relative to the final\n  /// joined register, so they can be compared directly between SrcReg and\n  /// DstReg.\n  struct Val {\n    ConflictResolution Resolution = CR_Keep;\n\n    /// Lanes written by this def, 0 for unanalyzed values.\n    LaneBitmask WriteLanes;\n\n    /// Lanes with defined values in this register. Other lanes are undef and\n    /// safe to clobber.\n    LaneBitmask ValidLanes;\n\n    /// Value in LI being redefined by this def.\n    VNInfo *RedefVNI = nullptr;\n\n    /// Value in the other live range that overlaps this def, if any.\n    VNInfo *OtherVNI = nullptr;\n\n    /// Is this value an IMPLICIT_DEF that can be erased?\n    ///\n    /// IMPLICIT_DEF values should only exist at the end of a basic block that\n    /// is a predecessor to a phi-value. These IMPLICIT_DEF instructions can be\n    /// safely erased if they are overlapping a live value in the other live\n    /// interval.\n    ///\n    /// Weird control flow graphs and incomplete PHI handling in\n    /// ProcessImplicitDefs can very rarely create IMPLICIT_DEF values with\n    /// longer live ranges. Such IMPLICIT_DEF values should be treated like\n    /// normal values.\n    bool ErasableImplicitDef = false;\n\n    /// True when the live range of this value will be pruned because of an\n    /// overlapping CR_Replace value in the other live range.\n    bool Pruned = false;\n\n    /// True once Pruned above has been computed.\n    bool PrunedComputed = false;\n\n    /// True if this value is determined to be identical to OtherVNI\n    /// (in valuesIdentical). This is used with CR_Erase where the erased\n    /// copy is redundant, i.e. the source value is already the same as\n    /// the destination. In such cases the subranges need to be updated\n    /// properly. See comment at pruneSubRegValues for more info.\n    bool Identical = false;\n\n    Val() = default;\n\n    bool isAnalyzed() const { return WriteLanes.any(); }\n  };\n\n  /// One entry per value number in LI.\n  SmallVector<Val, 8> Vals;\n\n  /// Compute the bitmask of lanes actually written by DefMI.\n  /// Set Redef if there are any partial register definitions that depend on the\n  /// previous value of the register.\n  LaneBitmask computeWriteLanes(const MachineInstr *DefMI, bool &Redef) const;\n\n  /// Find the ultimate value that VNI was copied from.\n  std::pair<const VNInfo *, Register> followCopyChain(const VNInfo *VNI) const;\n\n  bool valuesIdentical(VNInfo *Value0, VNInfo *Value1, const JoinVals &Other) const;\n\n  /// Analyze ValNo in this live range, and set all fields of Vals[ValNo].\n  /// Return a conflict resolution when possible, but leave the hard cases as\n  /// CR_Unresolved.\n  /// Recursively calls computeAssignment() on this and Other, guaranteeing that\n  /// both OtherVNI and RedefVNI have been analyzed and mapped before returning.\n  /// The recursion always goes upwards in the dominator tree, making loops\n  /// impossible.\n  ConflictResolution analyzeValue(unsigned ValNo, JoinVals &Other);\n\n  /// Compute the value assignment for ValNo in RI.\n  /// This may be called recursively by analyzeValue(), but never for a ValNo on\n  /// the stack.\n  void computeAssignment(unsigned ValNo, JoinVals &Other);\n\n  /// Assuming ValNo is going to clobber some valid lanes in Other.LR, compute\n  /// the extent of the tainted lanes in the block.\n  ///\n  /// Multiple values in Other.LR can be affected since partial redefinitions\n  /// can preserve previously tainted lanes.\n  ///\n  ///   1 %dst = VLOAD           <-- Define all lanes in %dst\n  ///   2 %src = FOO             <-- ValNo to be joined with %dst:ssub0\n  ///   3 %dst:ssub1 = BAR       <-- Partial redef doesn't clear taint in ssub0\n  ///   4 %dst:ssub0 = COPY %src <-- Conflict resolved, ssub0 wasn't read\n  ///\n  /// For each ValNo in Other that is affected, add an (EndIndex, TaintedLanes)\n  /// entry to TaintedVals.\n  ///\n  /// Returns false if the tainted lanes extend beyond the basic block.\n  bool\n  taintExtent(unsigned ValNo, LaneBitmask TaintedLanes, JoinVals &Other,\n              SmallVectorImpl<std::pair<SlotIndex, LaneBitmask>> &TaintExtent);\n\n  /// Return true if MI uses any of the given Lanes from Reg.\n  /// This does not include partial redefinitions of Reg.\n  bool usesLanes(const MachineInstr &MI, Register, unsigned, LaneBitmask) const;\n\n  /// Determine if ValNo is a copy of a value number in LR or Other.LR that will\n  /// be pruned:\n  ///\n  ///   %dst = COPY %src\n  ///   %src = COPY %dst  <-- This value to be pruned.\n  ///   %dst = COPY %src  <-- This value is a copy of a pruned value.\n  bool isPrunedValue(unsigned ValNo, JoinVals &Other);\n\npublic:\n  JoinVals(LiveRange &LR, Register Reg, unsigned SubIdx, LaneBitmask LaneMask,\n           SmallVectorImpl<VNInfo *> &newVNInfo, const CoalescerPair &cp,\n           LiveIntervals *lis, const TargetRegisterInfo *TRI, bool SubRangeJoin,\n           bool TrackSubRegLiveness)\n      : LR(LR), Reg(Reg), SubIdx(SubIdx), LaneMask(LaneMask),\n        SubRangeJoin(SubRangeJoin), TrackSubRegLiveness(TrackSubRegLiveness),\n        NewVNInfo(newVNInfo), CP(cp), LIS(lis), Indexes(LIS->getSlotIndexes()),\n        TRI(TRI), Assignments(LR.getNumValNums(), -1),\n        Vals(LR.getNumValNums()) {}\n\n  /// Analyze defs in LR and compute a value mapping in NewVNInfo.\n  /// Returns false if any conflicts were impossible to resolve.\n  bool mapValues(JoinVals &Other);\n\n  /// Try to resolve conflicts that require all values to be mapped.\n  /// Returns false if any conflicts were impossible to resolve.\n  bool resolveConflicts(JoinVals &Other);\n\n  /// Prune the live range of values in Other.LR where they would conflict with\n  /// CR_Replace values in LR. Collect end points for restoring the live range\n  /// after joining.\n  void pruneValues(JoinVals &Other, SmallVectorImpl<SlotIndex> &EndPoints,\n                   bool changeInstrs);\n\n  /// Removes subranges starting at copies that get removed. This sometimes\n  /// happens when undefined subranges are copied around. These ranges contain\n  /// no useful information and can be removed.\n  void pruneSubRegValues(LiveInterval &LI, LaneBitmask &ShrinkMask);\n\n  /// Pruning values in subranges can lead to removing segments in these\n  /// subranges started by IMPLICIT_DEFs. The corresponding segments in\n  /// the main range also need to be removed. This function will mark\n  /// the corresponding values in the main range as pruned, so that\n  /// eraseInstrs can do the final cleanup.\n  /// The parameter @p LI must be the interval whose main range is the\n  /// live range LR.\n  void pruneMainSegments(LiveInterval &LI, bool &ShrinkMainRange);\n\n  /// Erase any machine instructions that have been coalesced away.\n  /// Add erased instructions to ErasedInstrs.\n  /// Add foreign virtual registers to ShrinkRegs if their live range ended at\n  /// the erased instrs.\n  void eraseInstrs(SmallPtrSetImpl<MachineInstr*> &ErasedInstrs,\n                   SmallVectorImpl<Register> &ShrinkRegs,\n                   LiveInterval *LI = nullptr);\n\n  /// Remove liverange defs at places where implicit defs will be removed.\n  void removeImplicitDefs();\n\n  /// Get the value assignments suitable for passing to LiveInterval::join.\n  const int *getAssignments() const { return Assignments.data(); }\n\n  /// Get the conflict resolution for a value number.\n  ConflictResolution getResolution(unsigned Num) const {\n    return Vals[Num].Resolution;\n  }\n};\n\n} // end anonymous namespace\n\nLaneBitmask JoinVals::computeWriteLanes(const MachineInstr *DefMI, bool &Redef)\n  const {\n  LaneBitmask L;\n  for (const MachineOperand &MO : DefMI->operands()) {\n    if (!MO.isReg() || MO.getReg() != Reg || !MO.isDef())\n      continue;\n    L |= TRI->getSubRegIndexLaneMask(\n           TRI->composeSubRegIndices(SubIdx, MO.getSubReg()));\n    if (MO.readsReg())\n      Redef = true;\n  }\n  return L;\n}\n\nstd::pair<const VNInfo *, Register>\nJoinVals::followCopyChain(const VNInfo *VNI) const {\n  Register TrackReg = Reg;\n\n  while (!VNI->isPHIDef()) {\n    SlotIndex Def = VNI->def;\n    MachineInstr *MI = Indexes->getInstructionFromIndex(Def);\n    assert(MI && \"No defining instruction\");\n    if (!MI->isFullCopy())\n      return std::make_pair(VNI, TrackReg);\n    Register SrcReg = MI->getOperand(1).getReg();\n    if (!SrcReg.isVirtual())\n      return std::make_pair(VNI, TrackReg);\n\n    const LiveInterval &LI = LIS->getInterval(SrcReg);\n    const VNInfo *ValueIn;\n    // No subrange involved.\n    if (!SubRangeJoin || !LI.hasSubRanges()) {\n      LiveQueryResult LRQ = LI.Query(Def);\n      ValueIn = LRQ.valueIn();\n    } else {\n      // Query subranges. Ensure that all matching ones take us to the same def\n      // (allowing some of them to be undef).\n      ValueIn = nullptr;\n      for (const LiveInterval::SubRange &S : LI.subranges()) {\n        // Transform lanemask to a mask in the joined live interval.\n        LaneBitmask SMask = TRI->composeSubRegIndexLaneMask(SubIdx, S.LaneMask);\n        if ((SMask & LaneMask).none())\n          continue;\n        LiveQueryResult LRQ = S.Query(Def);\n        if (!ValueIn) {\n          ValueIn = LRQ.valueIn();\n          continue;\n        }\n        if (LRQ.valueIn() && ValueIn != LRQ.valueIn())\n          return std::make_pair(VNI, TrackReg);\n      }\n    }\n    if (ValueIn == nullptr) {\n      // Reaching an undefined value is legitimate, for example:\n      //\n      // 1   undef %0.sub1 = ...  ;; %0.sub0 == undef\n      // 2   %1 = COPY %0         ;; %1 is defined here.\n      // 3   %0 = COPY %1         ;; Now %0.sub0 has a definition,\n      //                          ;; but it's equivalent to \"undef\".\n      return std::make_pair(nullptr, SrcReg);\n    }\n    VNI = ValueIn;\n    TrackReg = SrcReg;\n  }\n  return std::make_pair(VNI, TrackReg);\n}\n\nbool JoinVals::valuesIdentical(VNInfo *Value0, VNInfo *Value1,\n                               const JoinVals &Other) const {\n  const VNInfo *Orig0;\n  Register Reg0;\n  std::tie(Orig0, Reg0) = followCopyChain(Value0);\n  if (Orig0 == Value1 && Reg0 == Other.Reg)\n    return true;\n\n  const VNInfo *Orig1;\n  Register Reg1;\n  std::tie(Orig1, Reg1) = Other.followCopyChain(Value1);\n  // If both values are undefined, and the source registers are the same\n  // register, the values are identical. Filter out cases where only one\n  // value is defined.\n  if (Orig0 == nullptr || Orig1 == nullptr)\n    return Orig0 == Orig1 && Reg0 == Reg1;\n\n  // The values are equal if they are defined at the same place and use the\n  // same register. Note that we cannot compare VNInfos directly as some of\n  // them might be from a copy created in mergeSubRangeInto()  while the other\n  // is from the original LiveInterval.\n  return Orig0->def == Orig1->def && Reg0 == Reg1;\n}\n\nJoinVals::ConflictResolution\nJoinVals::analyzeValue(unsigned ValNo, JoinVals &Other) {\n  Val &V = Vals[ValNo];\n  assert(!V.isAnalyzed() && \"Value has already been analyzed!\");\n  VNInfo *VNI = LR.getValNumInfo(ValNo);\n  if (VNI->isUnused()) {\n    V.WriteLanes = LaneBitmask::getAll();\n    return CR_Keep;\n  }\n\n  // Get the instruction defining this value, compute the lanes written.\n  const MachineInstr *DefMI = nullptr;\n  if (VNI->isPHIDef()) {\n    // Conservatively assume that all lanes in a PHI are valid.\n    LaneBitmask Lanes = SubRangeJoin ? LaneBitmask::getLane(0)\n                                     : TRI->getSubRegIndexLaneMask(SubIdx);\n    V.ValidLanes = V.WriteLanes = Lanes;\n  } else {\n    DefMI = Indexes->getInstructionFromIndex(VNI->def);\n    assert(DefMI != nullptr);\n    if (SubRangeJoin) {\n      // We don't care about the lanes when joining subregister ranges.\n      V.WriteLanes = V.ValidLanes = LaneBitmask::getLane(0);\n      if (DefMI->isImplicitDef()) {\n        V.ValidLanes = LaneBitmask::getNone();\n        V.ErasableImplicitDef = true;\n      }\n    } else {\n      bool Redef = false;\n      V.ValidLanes = V.WriteLanes = computeWriteLanes(DefMI, Redef);\n\n      // If this is a read-modify-write instruction, there may be more valid\n      // lanes than the ones written by this instruction.\n      // This only covers partial redef operands. DefMI may have normal use\n      // operands reading the register. They don't contribute valid lanes.\n      //\n      // This adds ssub1 to the set of valid lanes in %src:\n      //\n      //   %src:ssub1 = FOO\n      //\n      // This leaves only ssub1 valid, making any other lanes undef:\n      //\n      //   %src:ssub1<def,read-undef> = FOO %src:ssub2\n      //\n      // The <read-undef> flag on the def operand means that old lane values are\n      // not important.\n      if (Redef) {\n        V.RedefVNI = LR.Query(VNI->def).valueIn();\n        assert((TrackSubRegLiveness || V.RedefVNI) &&\n               \"Instruction is reading nonexistent value\");\n        if (V.RedefVNI != nullptr) {\n          computeAssignment(V.RedefVNI->id, Other);\n          V.ValidLanes |= Vals[V.RedefVNI->id].ValidLanes;\n        }\n      }\n\n      // An IMPLICIT_DEF writes undef values.\n      if (DefMI->isImplicitDef()) {\n        // We normally expect IMPLICIT_DEF values to be live only until the end\n        // of their block. If the value is really live longer and gets pruned in\n        // another block, this flag is cleared again.\n        //\n        // Clearing the valid lanes is deferred until it is sure this can be\n        // erased.\n        V.ErasableImplicitDef = true;\n      }\n    }\n  }\n\n  // Find the value in Other that overlaps VNI->def, if any.\n  LiveQueryResult OtherLRQ = Other.LR.Query(VNI->def);\n\n  // It is possible that both values are defined by the same instruction, or\n  // the values are PHIs defined in the same block. When that happens, the two\n  // values should be merged into one, but not into any preceding value.\n  // The first value defined or visited gets CR_Keep, the other gets CR_Merge.\n  if (VNInfo *OtherVNI = OtherLRQ.valueDefined()) {\n    assert(SlotIndex::isSameInstr(VNI->def, OtherVNI->def) && \"Broken LRQ\");\n\n    // One value stays, the other is merged. Keep the earlier one, or the first\n    // one we see.\n    if (OtherVNI->def < VNI->def)\n      Other.computeAssignment(OtherVNI->id, *this);\n    else if (VNI->def < OtherVNI->def && OtherLRQ.valueIn()) {\n      // This is an early-clobber def overlapping a live-in value in the other\n      // register. Not mergeable.\n      V.OtherVNI = OtherLRQ.valueIn();\n      return CR_Impossible;\n    }\n    V.OtherVNI = OtherVNI;\n    Val &OtherV = Other.Vals[OtherVNI->id];\n    // Keep this value, check for conflicts when analyzing OtherVNI.\n    if (!OtherV.isAnalyzed())\n      return CR_Keep;\n    // Both sides have been analyzed now.\n    // Allow overlapping PHI values. Any real interference would show up in a\n    // predecessor, the PHI itself can't introduce any conflicts.\n    if (VNI->isPHIDef())\n      return CR_Merge;\n    if ((V.ValidLanes & OtherV.ValidLanes).any())\n      // Overlapping lanes can't be resolved.\n      return CR_Impossible;\n    else\n      return CR_Merge;\n  }\n\n  // No simultaneous def. Is Other live at the def?\n  V.OtherVNI = OtherLRQ.valueIn();\n  if (!V.OtherVNI)\n    // No overlap, no conflict.\n    return CR_Keep;\n\n  assert(!SlotIndex::isSameInstr(VNI->def, V.OtherVNI->def) && \"Broken LRQ\");\n\n  // We have overlapping values, or possibly a kill of Other.\n  // Recursively compute assignments up the dominator tree.\n  Other.computeAssignment(V.OtherVNI->id, *this);\n  Val &OtherV = Other.Vals[V.OtherVNI->id];\n\n  if (OtherV.ErasableImplicitDef) {\n    // Check if OtherV is an IMPLICIT_DEF that extends beyond its basic block.\n    // This shouldn't normally happen, but ProcessImplicitDefs can leave such\n    // IMPLICIT_DEF instructions behind, and there is nothing wrong with it\n    // technically.\n    //\n    // When it happens, treat that IMPLICIT_DEF as a normal value, and don't try\n    // to erase the IMPLICIT_DEF instruction.\n    if (DefMI &&\n        DefMI->getParent() != Indexes->getMBBFromIndex(V.OtherVNI->def)) {\n      LLVM_DEBUG(dbgs() << \"IMPLICIT_DEF defined at \" << V.OtherVNI->def\n                 << \" extends into \"\n                 << printMBBReference(*DefMI->getParent())\n                 << \", keeping it.\\n\");\n      OtherV.ErasableImplicitDef = false;\n    } else {\n      // We deferred clearing these lanes in case we needed to save them\n      OtherV.ValidLanes &= ~OtherV.WriteLanes;\n    }\n  }\n\n  // Allow overlapping PHI values. Any real interference would show up in a\n  // predecessor, the PHI itself can't introduce any conflicts.\n  if (VNI->isPHIDef())\n    return CR_Replace;\n\n  // Check for simple erasable conflicts.\n  if (DefMI->isImplicitDef())\n    return CR_Erase;\n\n  // Include the non-conflict where DefMI is a coalescable copy that kills\n  // OtherVNI. We still want the copy erased and value numbers merged.\n  if (CP.isCoalescable(DefMI)) {\n    // Some of the lanes copied from OtherVNI may be undef, making them undef\n    // here too.\n    V.ValidLanes &= ~V.WriteLanes | OtherV.ValidLanes;\n    return CR_Erase;\n  }\n\n  // This may not be a real conflict if DefMI simply kills Other and defines\n  // VNI.\n  if (OtherLRQ.isKill() && OtherLRQ.endPoint() <= VNI->def)\n    return CR_Keep;\n\n  // Handle the case where VNI and OtherVNI can be proven to be identical:\n  //\n  //   %other = COPY %ext\n  //   %this  = COPY %ext <-- Erase this copy\n  //\n  if (DefMI->isFullCopy() && !CP.isPartial() &&\n      valuesIdentical(VNI, V.OtherVNI, Other)) {\n    V.Identical = true;\n    return CR_Erase;\n  }\n\n  // The remaining checks apply to the lanes, which aren't tracked here.  This\n  // was already decided to be OK via the following CR_Replace condition.\n  // CR_Replace.\n  if (SubRangeJoin)\n    return CR_Replace;\n\n  // If the lanes written by this instruction were all undef in OtherVNI, it is\n  // still safe to join the live ranges. This can't be done with a simple value\n  // mapping, though - OtherVNI will map to multiple values:\n  //\n  //   1 %dst:ssub0 = FOO                <-- OtherVNI\n  //   2 %src = BAR                      <-- VNI\n  //   3 %dst:ssub1 = COPY killed %src    <-- Eliminate this copy.\n  //   4 BAZ killed %dst\n  //   5 QUUX killed %src\n  //\n  // Here OtherVNI will map to itself in [1;2), but to VNI in [2;5). CR_Replace\n  // handles this complex value mapping.\n  if ((V.WriteLanes & OtherV.ValidLanes).none())\n    return CR_Replace;\n\n  // If the other live range is killed by DefMI and the live ranges are still\n  // overlapping, it must be because we're looking at an early clobber def:\n  //\n  //   %dst<def,early-clobber> = ASM killed %src\n  //\n  // In this case, it is illegal to merge the two live ranges since the early\n  // clobber def would clobber %src before it was read.\n  if (OtherLRQ.isKill()) {\n    // This case where the def doesn't overlap the kill is handled above.\n    assert(VNI->def.isEarlyClobber() &&\n           \"Only early clobber defs can overlap a kill\");\n    return CR_Impossible;\n  }\n\n  // VNI is clobbering live lanes in OtherVNI, but there is still the\n  // possibility that no instructions actually read the clobbered lanes.\n  // If we're clobbering all the lanes in OtherVNI, at least one must be read.\n  // Otherwise Other.RI wouldn't be live here.\n  if ((TRI->getSubRegIndexLaneMask(Other.SubIdx) & ~V.WriteLanes).none())\n    return CR_Impossible;\n\n  // We need to verify that no instructions are reading the clobbered lanes. To\n  // save compile time, we'll only check that locally. Don't allow the tainted\n  // value to escape the basic block.\n  MachineBasicBlock *MBB = Indexes->getMBBFromIndex(VNI->def);\n  if (OtherLRQ.endPoint() >= Indexes->getMBBEndIdx(MBB))\n    return CR_Impossible;\n\n  // There are still some things that could go wrong besides clobbered lanes\n  // being read, for example OtherVNI may be only partially redefined in MBB,\n  // and some clobbered lanes could escape the block. Save this analysis for\n  // resolveConflicts() when all values have been mapped. We need to know\n  // RedefVNI and WriteLanes for any later defs in MBB, and we can't compute\n  // that now - the recursive analyzeValue() calls must go upwards in the\n  // dominator tree.\n  return CR_Unresolved;\n}\n\nvoid JoinVals::computeAssignment(unsigned ValNo, JoinVals &Other) {\n  Val &V = Vals[ValNo];\n  if (V.isAnalyzed()) {\n    // Recursion should always move up the dominator tree, so ValNo is not\n    // supposed to reappear before it has been assigned.\n    assert(Assignments[ValNo] != -1 && \"Bad recursion?\");\n    return;\n  }\n  switch ((V.Resolution = analyzeValue(ValNo, Other))) {\n  case CR_Erase:\n  case CR_Merge:\n    // Merge this ValNo into OtherVNI.\n    assert(V.OtherVNI && \"OtherVNI not assigned, can't merge.\");\n    assert(Other.Vals[V.OtherVNI->id].isAnalyzed() && \"Missing recursion\");\n    Assignments[ValNo] = Other.Assignments[V.OtherVNI->id];\n    LLVM_DEBUG(dbgs() << \"\\t\\tmerge \" << printReg(Reg) << ':' << ValNo << '@'\n                      << LR.getValNumInfo(ValNo)->def << \" into \"\n                      << printReg(Other.Reg) << ':' << V.OtherVNI->id << '@'\n                      << V.OtherVNI->def << \" --> @\"\n                      << NewVNInfo[Assignments[ValNo]]->def << '\\n');\n    break;\n  case CR_Replace:\n  case CR_Unresolved: {\n    // The other value is going to be pruned if this join is successful.\n    assert(V.OtherVNI && \"OtherVNI not assigned, can't prune\");\n    Val &OtherV = Other.Vals[V.OtherVNI->id];\n    // We cannot erase an IMPLICIT_DEF if we don't have valid values for all\n    // its lanes.\n    if (OtherV.ErasableImplicitDef &&\n        TrackSubRegLiveness &&\n        (OtherV.WriteLanes & ~V.ValidLanes).any()) {\n      LLVM_DEBUG(dbgs() << \"Cannot erase implicit_def with missing values\\n\");\n\n      OtherV.ErasableImplicitDef = false;\n      // The valid lanes written by the implicit_def were speculatively cleared\n      // before, so make this more conservative. It may be better to track this,\n      // I haven't found a testcase where it matters.\n      OtherV.ValidLanes = LaneBitmask::getAll();\n    }\n\n    OtherV.Pruned = true;\n    LLVM_FALLTHROUGH;\n  }\n  default:\n    // This value number needs to go in the final joined live range.\n    Assignments[ValNo] = NewVNInfo.size();\n    NewVNInfo.push_back(LR.getValNumInfo(ValNo));\n    break;\n  }\n}\n\nbool JoinVals::mapValues(JoinVals &Other) {\n  for (unsigned i = 0, e = LR.getNumValNums(); i != e; ++i) {\n    computeAssignment(i, Other);\n    if (Vals[i].Resolution == CR_Impossible) {\n      LLVM_DEBUG(dbgs() << \"\\t\\tinterference at \" << printReg(Reg) << ':' << i\n                        << '@' << LR.getValNumInfo(i)->def << '\\n');\n      return false;\n    }\n  }\n  return true;\n}\n\nbool JoinVals::\ntaintExtent(unsigned ValNo, LaneBitmask TaintedLanes, JoinVals &Other,\n            SmallVectorImpl<std::pair<SlotIndex, LaneBitmask>> &TaintExtent) {\n  VNInfo *VNI = LR.getValNumInfo(ValNo);\n  MachineBasicBlock *MBB = Indexes->getMBBFromIndex(VNI->def);\n  SlotIndex MBBEnd = Indexes->getMBBEndIdx(MBB);\n\n  // Scan Other.LR from VNI.def to MBBEnd.\n  LiveInterval::iterator OtherI = Other.LR.find(VNI->def);\n  assert(OtherI != Other.LR.end() && \"No conflict?\");\n  do {\n    // OtherI is pointing to a tainted value. Abort the join if the tainted\n    // lanes escape the block.\n    SlotIndex End = OtherI->end;\n    if (End >= MBBEnd) {\n      LLVM_DEBUG(dbgs() << \"\\t\\ttaints global \" << printReg(Other.Reg) << ':'\n                        << OtherI->valno->id << '@' << OtherI->start << '\\n');\n      return false;\n    }\n    LLVM_DEBUG(dbgs() << \"\\t\\ttaints local \" << printReg(Other.Reg) << ':'\n                      << OtherI->valno->id << '@' << OtherI->start << \" to \"\n                      << End << '\\n');\n    // A dead def is not a problem.\n    if (End.isDead())\n      break;\n    TaintExtent.push_back(std::make_pair(End, TaintedLanes));\n\n    // Check for another def in the MBB.\n    if (++OtherI == Other.LR.end() || OtherI->start >= MBBEnd)\n      break;\n\n    // Lanes written by the new def are no longer tainted.\n    const Val &OV = Other.Vals[OtherI->valno->id];\n    TaintedLanes &= ~OV.WriteLanes;\n    if (!OV.RedefVNI)\n      break;\n  } while (TaintedLanes.any());\n  return true;\n}\n\nbool JoinVals::usesLanes(const MachineInstr &MI, Register Reg, unsigned SubIdx,\n                         LaneBitmask Lanes) const {\n  if (MI.isDebugInstr())\n    return false;\n  for (const MachineOperand &MO : MI.operands()) {\n    if (!MO.isReg() || MO.isDef() || MO.getReg() != Reg)\n      continue;\n    if (!MO.readsReg())\n      continue;\n    unsigned S = TRI->composeSubRegIndices(SubIdx, MO.getSubReg());\n    if ((Lanes & TRI->getSubRegIndexLaneMask(S)).any())\n      return true;\n  }\n  return false;\n}\n\nbool JoinVals::resolveConflicts(JoinVals &Other) {\n  for (unsigned i = 0, e = LR.getNumValNums(); i != e; ++i) {\n    Val &V = Vals[i];\n    assert(V.Resolution != CR_Impossible && \"Unresolvable conflict\");\n    if (V.Resolution != CR_Unresolved)\n      continue;\n    LLVM_DEBUG(dbgs() << \"\\t\\tconflict at \" << printReg(Reg) << ':' << i << '@'\n                      << LR.getValNumInfo(i)->def\n                      << ' ' << PrintLaneMask(LaneMask) << '\\n');\n    if (SubRangeJoin)\n      return false;\n\n    ++NumLaneConflicts;\n    assert(V.OtherVNI && \"Inconsistent conflict resolution.\");\n    VNInfo *VNI = LR.getValNumInfo(i);\n    const Val &OtherV = Other.Vals[V.OtherVNI->id];\n\n    // VNI is known to clobber some lanes in OtherVNI. If we go ahead with the\n    // join, those lanes will be tainted with a wrong value. Get the extent of\n    // the tainted lanes.\n    LaneBitmask TaintedLanes = V.WriteLanes & OtherV.ValidLanes;\n    SmallVector<std::pair<SlotIndex, LaneBitmask>, 8> TaintExtent;\n    if (!taintExtent(i, TaintedLanes, Other, TaintExtent))\n      // Tainted lanes would extend beyond the basic block.\n      return false;\n\n    assert(!TaintExtent.empty() && \"There should be at least one conflict.\");\n\n    // Now look at the instructions from VNI->def to TaintExtent (inclusive).\n    MachineBasicBlock *MBB = Indexes->getMBBFromIndex(VNI->def);\n    MachineBasicBlock::iterator MI = MBB->begin();\n    if (!VNI->isPHIDef()) {\n      MI = Indexes->getInstructionFromIndex(VNI->def);\n      // No need to check the instruction defining VNI for reads.\n      ++MI;\n    }\n    assert(!SlotIndex::isSameInstr(VNI->def, TaintExtent.front().first) &&\n           \"Interference ends on VNI->def. Should have been handled earlier\");\n    MachineInstr *LastMI =\n      Indexes->getInstructionFromIndex(TaintExtent.front().first);\n    assert(LastMI && \"Range must end at a proper instruction\");\n    unsigned TaintNum = 0;\n    while (true) {\n      assert(MI != MBB->end() && \"Bad LastMI\");\n      if (usesLanes(*MI, Other.Reg, Other.SubIdx, TaintedLanes)) {\n        LLVM_DEBUG(dbgs() << \"\\t\\ttainted lanes used by: \" << *MI);\n        return false;\n      }\n      // LastMI is the last instruction to use the current value.\n      if (&*MI == LastMI) {\n        if (++TaintNum == TaintExtent.size())\n          break;\n        LastMI = Indexes->getInstructionFromIndex(TaintExtent[TaintNum].first);\n        assert(LastMI && \"Range must end at a proper instruction\");\n        TaintedLanes = TaintExtent[TaintNum].second;\n      }\n      ++MI;\n    }\n\n    // The tainted lanes are unused.\n    V.Resolution = CR_Replace;\n    ++NumLaneResolves;\n  }\n  return true;\n}\n\nbool JoinVals::isPrunedValue(unsigned ValNo, JoinVals &Other) {\n  Val &V = Vals[ValNo];\n  if (V.Pruned || V.PrunedComputed)\n    return V.Pruned;\n\n  if (V.Resolution != CR_Erase && V.Resolution != CR_Merge)\n    return V.Pruned;\n\n  // Follow copies up the dominator tree and check if any intermediate value\n  // has been pruned.\n  V.PrunedComputed = true;\n  V.Pruned = Other.isPrunedValue(V.OtherVNI->id, *this);\n  return V.Pruned;\n}\n\nvoid JoinVals::pruneValues(JoinVals &Other,\n                           SmallVectorImpl<SlotIndex> &EndPoints,\n                           bool changeInstrs) {\n  for (unsigned i = 0, e = LR.getNumValNums(); i != e; ++i) {\n    SlotIndex Def = LR.getValNumInfo(i)->def;\n    switch (Vals[i].Resolution) {\n    case CR_Keep:\n      break;\n    case CR_Replace: {\n      // This value takes precedence over the value in Other.LR.\n      LIS->pruneValue(Other.LR, Def, &EndPoints);\n      // Check if we're replacing an IMPLICIT_DEF value. The IMPLICIT_DEF\n      // instructions are only inserted to provide a live-out value for PHI\n      // predecessors, so the instruction should simply go away once its value\n      // has been replaced.\n      Val &OtherV = Other.Vals[Vals[i].OtherVNI->id];\n      bool EraseImpDef = OtherV.ErasableImplicitDef &&\n                         OtherV.Resolution == CR_Keep;\n      if (!Def.isBlock()) {\n        if (changeInstrs) {\n          // Remove <def,read-undef> flags. This def is now a partial redef.\n          // Also remove dead flags since the joined live range will\n          // continue past this instruction.\n          for (MachineOperand &MO :\n               Indexes->getInstructionFromIndex(Def)->operands()) {\n            if (MO.isReg() && MO.isDef() && MO.getReg() == Reg) {\n              if (MO.getSubReg() != 0 && MO.isUndef() && !EraseImpDef)\n                MO.setIsUndef(false);\n              MO.setIsDead(false);\n            }\n          }\n        }\n        // This value will reach instructions below, but we need to make sure\n        // the live range also reaches the instruction at Def.\n        if (!EraseImpDef)\n          EndPoints.push_back(Def);\n      }\n      LLVM_DEBUG(dbgs() << \"\\t\\tpruned \" << printReg(Other.Reg) << \" at \" << Def\n                        << \": \" << Other.LR << '\\n');\n      break;\n    }\n    case CR_Erase:\n    case CR_Merge:\n      if (isPrunedValue(i, Other)) {\n        // This value is ultimately a copy of a pruned value in LR or Other.LR.\n        // We can no longer trust the value mapping computed by\n        // computeAssignment(), the value that was originally copied could have\n        // been replaced.\n        LIS->pruneValue(LR, Def, &EndPoints);\n        LLVM_DEBUG(dbgs() << \"\\t\\tpruned all of \" << printReg(Reg) << \" at \"\n                          << Def << \": \" << LR << '\\n');\n      }\n      break;\n    case CR_Unresolved:\n    case CR_Impossible:\n      llvm_unreachable(\"Unresolved conflicts\");\n    }\n  }\n}\n\n/// Consider the following situation when coalescing the copy between\n/// %31 and %45 at 800. (The vertical lines represent live range segments.)\n///\n///                              Main range         Subrange 0004 (sub2)\n///                              %31    %45           %31    %45\n///  544    %45 = COPY %28               +                    +\n///                                      | v1                 | v1\n///  560B bb.1:                          +                    +\n///  624        = %45.sub2               | v2                 | v2\n///  800    %31 = COPY %45        +      +             +      +\n///                               | v0                 | v0\n///  816    %31.sub1 = ...        +                    |\n///  880    %30 = COPY %31        | v1                 +\n///  928    %45 = COPY %30        |      +                    +\n///                               |      | v0                 | v0  <--+\n///  992B   ; backedge -> bb.1    |      +                    +        |\n/// 1040        = %31.sub0        +                                    |\n///                                                 This value must remain\n///                                                 live-out!\n///\n/// Assuming that %31 is coalesced into %45, the copy at 928 becomes\n/// redundant, since it copies the value from %45 back into it. The\n/// conflict resolution for the main range determines that %45.v0 is\n/// to be erased, which is ok since %31.v1 is identical to it.\n/// The problem happens with the subrange for sub2: it has to be live\n/// on exit from the block, but since 928 was actually a point of\n/// definition of %45.sub2, %45.sub2 was not live immediately prior\n/// to that definition. As a result, when 928 was erased, the value v0\n/// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an\n/// IMPLICIT_DEF was inserted as a \"backedge\" definition for %45.sub2,\n/// providing an incorrect value to the use at 624.\n///\n/// Since the main-range values %31.v1 and %45.v0 were proved to be\n/// identical, the corresponding values in subranges must also be the\n/// same. A redundant copy is removed because it's not needed, and not\n/// because it copied an undefined value, so any liveness that originated\n/// from that copy cannot disappear. When pruning a value that started\n/// at the removed copy, the corresponding identical value must be\n/// extended to replace it.\nvoid JoinVals::pruneSubRegValues(LiveInterval &LI, LaneBitmask &ShrinkMask) {\n  // Look for values being erased.\n  bool DidPrune = false;\n  for (unsigned i = 0, e = LR.getNumValNums(); i != e; ++i) {\n    Val &V = Vals[i];\n    // We should trigger in all cases in which eraseInstrs() does something.\n    // match what eraseInstrs() is doing, print a message so\n    if (V.Resolution != CR_Erase &&\n        (V.Resolution != CR_Keep || !V.ErasableImplicitDef || !V.Pruned))\n      continue;\n\n    // Check subranges at the point where the copy will be removed.\n    SlotIndex Def = LR.getValNumInfo(i)->def;\n    SlotIndex OtherDef;\n    if (V.Identical)\n      OtherDef = V.OtherVNI->def;\n\n    // Print message so mismatches with eraseInstrs() can be diagnosed.\n    LLVM_DEBUG(dbgs() << \"\\t\\tExpecting instruction removal at \" << Def\n                      << '\\n');\n    for (LiveInterval::SubRange &S : LI.subranges()) {\n      LiveQueryResult Q = S.Query(Def);\n\n      // If a subrange starts at the copy then an undefined value has been\n      // copied and we must remove that subrange value as well.\n      VNInfo *ValueOut = Q.valueOutOrDead();\n      if (ValueOut != nullptr && (Q.valueIn() == nullptr ||\n                                  (V.Identical && V.Resolution == CR_Erase &&\n                                   ValueOut->def == Def))) {\n        LLVM_DEBUG(dbgs() << \"\\t\\tPrune sublane \" << PrintLaneMask(S.LaneMask)\n                          << \" at \" << Def << \"\\n\");\n        SmallVector<SlotIndex,8> EndPoints;\n        LIS->pruneValue(S, Def, &EndPoints);\n        DidPrune = true;\n        // Mark value number as unused.\n        ValueOut->markUnused();\n\n        if (V.Identical && S.Query(OtherDef).valueOutOrDead()) {\n          // If V is identical to V.OtherVNI (and S was live at OtherDef),\n          // then we can't simply prune V from S. V needs to be replaced\n          // with V.OtherVNI.\n          LIS->extendToIndices(S, EndPoints);\n        }\n        continue;\n      }\n      // If a subrange ends at the copy, then a value was copied but only\n      // partially used later. Shrink the subregister range appropriately.\n      if (Q.valueIn() != nullptr && Q.valueOut() == nullptr) {\n        LLVM_DEBUG(dbgs() << \"\\t\\tDead uses at sublane \"\n                          << PrintLaneMask(S.LaneMask) << \" at \" << Def\n                          << \"\\n\");\n        ShrinkMask |= S.LaneMask;\n      }\n    }\n  }\n  if (DidPrune)\n    LI.removeEmptySubRanges();\n}\n\n/// Check if any of the subranges of @p LI contain a definition at @p Def.\nstatic bool isDefInSubRange(LiveInterval &LI, SlotIndex Def) {\n  for (LiveInterval::SubRange &SR : LI.subranges()) {\n    if (VNInfo *VNI = SR.Query(Def).valueOutOrDead())\n      if (VNI->def == Def)\n        return true;\n  }\n  return false;\n}\n\nvoid JoinVals::pruneMainSegments(LiveInterval &LI, bool &ShrinkMainRange) {\n  assert(&static_cast<LiveRange&>(LI) == &LR);\n\n  for (unsigned i = 0, e = LR.getNumValNums(); i != e; ++i) {\n    if (Vals[i].Resolution != CR_Keep)\n      continue;\n    VNInfo *VNI = LR.getValNumInfo(i);\n    if (VNI->isUnused() || VNI->isPHIDef() || isDefInSubRange(LI, VNI->def))\n      continue;\n    Vals[i].Pruned = true;\n    ShrinkMainRange = true;\n  }\n}\n\nvoid JoinVals::removeImplicitDefs() {\n  for (unsigned i = 0, e = LR.getNumValNums(); i != e; ++i) {\n    Val &V = Vals[i];\n    if (V.Resolution != CR_Keep || !V.ErasableImplicitDef || !V.Pruned)\n      continue;\n\n    VNInfo *VNI = LR.getValNumInfo(i);\n    VNI->markUnused();\n    LR.removeValNo(VNI);\n  }\n}\n\nvoid JoinVals::eraseInstrs(SmallPtrSetImpl<MachineInstr*> &ErasedInstrs,\n                           SmallVectorImpl<Register> &ShrinkRegs,\n                           LiveInterval *LI) {\n  for (unsigned i = 0, e = LR.getNumValNums(); i != e; ++i) {\n    // Get the def location before markUnused() below invalidates it.\n    VNInfo *VNI = LR.getValNumInfo(i);\n    SlotIndex Def = VNI->def;\n    switch (Vals[i].Resolution) {\n    case CR_Keep: {\n      // If an IMPLICIT_DEF value is pruned, it doesn't serve a purpose any\n      // longer. The IMPLICIT_DEF instructions are only inserted by\n      // PHIElimination to guarantee that all PHI predecessors have a value.\n      if (!Vals[i].ErasableImplicitDef || !Vals[i].Pruned)\n        break;\n      // Remove value number i from LR.\n      // For intervals with subranges, removing a segment from the main range\n      // may require extending the previous segment: for each definition of\n      // a subregister, there will be a corresponding def in the main range.\n      // That def may fall in the middle of a segment from another subrange.\n      // In such cases, removing this def from the main range must be\n      // complemented by extending the main range to account for the liveness\n      // of the other subrange.\n      // The new end point of the main range segment to be extended.\n      SlotIndex NewEnd;\n      if (LI != nullptr) {\n        LiveRange::iterator I = LR.FindSegmentContaining(Def);\n        assert(I != LR.end());\n        // Do not extend beyond the end of the segment being removed.\n        // The segment may have been pruned in preparation for joining\n        // live ranges.\n        NewEnd = I->end;\n      }\n\n      LR.removeValNo(VNI);\n      // Note that this VNInfo is reused and still referenced in NewVNInfo,\n      // make it appear like an unused value number.\n      VNI->markUnused();\n\n      if (LI != nullptr && LI->hasSubRanges()) {\n        assert(static_cast<LiveRange*>(LI) == &LR);\n        // Determine the end point based on the subrange information:\n        // minimum of (earliest def of next segment,\n        //             latest end point of containing segment)\n        SlotIndex ED, LE;\n        for (LiveInterval::SubRange &SR : LI->subranges()) {\n          LiveRange::iterator I = SR.find(Def);\n          if (I == SR.end())\n            continue;\n          if (I->start > Def)\n            ED = ED.isValid() ? std::min(ED, I->start) : I->start;\n          else\n            LE = LE.isValid() ? std::max(LE, I->end) : I->end;\n        }\n        if (LE.isValid())\n          NewEnd = std::min(NewEnd, LE);\n        if (ED.isValid())\n          NewEnd = std::min(NewEnd, ED);\n\n        // We only want to do the extension if there was a subrange that\n        // was live across Def.\n        if (LE.isValid()) {\n          LiveRange::iterator S = LR.find(Def);\n          if (S != LR.begin())\n            std::prev(S)->end = NewEnd;\n        }\n      }\n      LLVM_DEBUG({\n        dbgs() << \"\\t\\tremoved \" << i << '@' << Def << \": \" << LR << '\\n';\n        if (LI != nullptr)\n          dbgs() << \"\\t\\t  LHS = \" << *LI << '\\n';\n      });\n      LLVM_FALLTHROUGH;\n    }\n\n    case CR_Erase: {\n      MachineInstr *MI = Indexes->getInstructionFromIndex(Def);\n      assert(MI && \"No instruction to erase\");\n      if (MI->isCopy()) {\n        Register Reg = MI->getOperand(1).getReg();\n        if (Register::isVirtualRegister(Reg) && Reg != CP.getSrcReg() &&\n            Reg != CP.getDstReg())\n          ShrinkRegs.push_back(Reg);\n      }\n      ErasedInstrs.insert(MI);\n      LLVM_DEBUG(dbgs() << \"\\t\\terased:\\t\" << Def << '\\t' << *MI);\n      LIS->RemoveMachineInstrFromMaps(*MI);\n      MI->eraseFromParent();\n      break;\n    }\n    default:\n      break;\n    }\n  }\n}\n\nvoid RegisterCoalescer::joinSubRegRanges(LiveRange &LRange, LiveRange &RRange,\n                                         LaneBitmask LaneMask,\n                                         const CoalescerPair &CP) {\n  SmallVector<VNInfo*, 16> NewVNInfo;\n  JoinVals RHSVals(RRange, CP.getSrcReg(), CP.getSrcIdx(), LaneMask,\n                   NewVNInfo, CP, LIS, TRI, true, true);\n  JoinVals LHSVals(LRange, CP.getDstReg(), CP.getDstIdx(), LaneMask,\n                   NewVNInfo, CP, LIS, TRI, true, true);\n\n  // Compute NewVNInfo and resolve conflicts (see also joinVirtRegs())\n  // We should be able to resolve all conflicts here as we could successfully do\n  // it on the mainrange already. There is however a problem when multiple\n  // ranges get mapped to the \"overflow\" lane mask bit which creates unexpected\n  // interferences.\n  if (!LHSVals.mapValues(RHSVals) || !RHSVals.mapValues(LHSVals)) {\n    // We already determined that it is legal to merge the intervals, so this\n    // should never fail.\n    llvm_unreachable(\"*** Couldn't join subrange!\\n\");\n  }\n  if (!LHSVals.resolveConflicts(RHSVals) ||\n      !RHSVals.resolveConflicts(LHSVals)) {\n    // We already determined that it is legal to merge the intervals, so this\n    // should never fail.\n    llvm_unreachable(\"*** Couldn't join subrange!\\n\");\n  }\n\n  // The merging algorithm in LiveInterval::join() can't handle conflicting\n  // value mappings, so we need to remove any live ranges that overlap a\n  // CR_Replace resolution. Collect a set of end points that can be used to\n  // restore the live range after joining.\n  SmallVector<SlotIndex, 8> EndPoints;\n  LHSVals.pruneValues(RHSVals, EndPoints, false);\n  RHSVals.pruneValues(LHSVals, EndPoints, false);\n\n  LHSVals.removeImplicitDefs();\n  RHSVals.removeImplicitDefs();\n\n  LRange.verify();\n  RRange.verify();\n\n  // Join RRange into LHS.\n  LRange.join(RRange, LHSVals.getAssignments(), RHSVals.getAssignments(),\n              NewVNInfo);\n\n  LLVM_DEBUG(dbgs() << \"\\t\\tjoined lanes: \" << PrintLaneMask(LaneMask)\n                    << ' ' << LRange << \"\\n\");\n  if (EndPoints.empty())\n    return;\n\n  // Recompute the parts of the live range we had to remove because of\n  // CR_Replace conflicts.\n  LLVM_DEBUG({\n    dbgs() << \"\\t\\trestoring liveness to \" << EndPoints.size() << \" points: \";\n    for (unsigned i = 0, n = EndPoints.size(); i != n; ++i) {\n      dbgs() << EndPoints[i];\n      if (i != n-1)\n        dbgs() << ',';\n    }\n    dbgs() << \":  \" << LRange << '\\n';\n  });\n  LIS->extendToIndices(LRange, EndPoints);\n}\n\nvoid RegisterCoalescer::mergeSubRangeInto(LiveInterval &LI,\n                                          const LiveRange &ToMerge,\n                                          LaneBitmask LaneMask,\n                                          CoalescerPair &CP,\n                                          unsigned ComposeSubRegIdx) {\n  BumpPtrAllocator &Allocator = LIS->getVNInfoAllocator();\n  LI.refineSubRanges(\n      Allocator, LaneMask,\n      [this, &Allocator, &ToMerge, &CP](LiveInterval::SubRange &SR) {\n        if (SR.empty()) {\n          SR.assign(ToMerge, Allocator);\n        } else {\n          // joinSubRegRange() destroys the merged range, so we need a copy.\n          LiveRange RangeCopy(ToMerge, Allocator);\n          joinSubRegRanges(SR, RangeCopy, SR.LaneMask, CP);\n        }\n      },\n      *LIS->getSlotIndexes(), *TRI, ComposeSubRegIdx);\n}\n\nbool RegisterCoalescer::isHighCostLiveInterval(LiveInterval &LI) {\n  if (LI.valnos.size() < LargeIntervalSizeThreshold)\n    return false;\n  auto &Counter = LargeLIVisitCounter[LI.reg()];\n  if (Counter < LargeIntervalFreqThreshold) {\n    Counter++;\n    return false;\n  }\n  return true;\n}\n\nbool RegisterCoalescer::joinVirtRegs(CoalescerPair &CP) {\n  SmallVector<VNInfo*, 16> NewVNInfo;\n  LiveInterval &RHS = LIS->getInterval(CP.getSrcReg());\n  LiveInterval &LHS = LIS->getInterval(CP.getDstReg());\n  bool TrackSubRegLiveness = MRI->shouldTrackSubRegLiveness(*CP.getNewRC());\n  JoinVals RHSVals(RHS, CP.getSrcReg(), CP.getSrcIdx(), LaneBitmask::getNone(),\n                   NewVNInfo, CP, LIS, TRI, false, TrackSubRegLiveness);\n  JoinVals LHSVals(LHS, CP.getDstReg(), CP.getDstIdx(), LaneBitmask::getNone(),\n                   NewVNInfo, CP, LIS, TRI, false, TrackSubRegLiveness);\n\n  LLVM_DEBUG(dbgs() << \"\\t\\tRHS = \" << RHS << \"\\n\\t\\tLHS = \" << LHS << '\\n');\n\n  if (isHighCostLiveInterval(LHS) || isHighCostLiveInterval(RHS))\n    return false;\n\n  // First compute NewVNInfo and the simple value mappings.\n  // Detect impossible conflicts early.\n  if (!LHSVals.mapValues(RHSVals) || !RHSVals.mapValues(LHSVals))\n    return false;\n\n  // Some conflicts can only be resolved after all values have been mapped.\n  if (!LHSVals.resolveConflicts(RHSVals) || !RHSVals.resolveConflicts(LHSVals))\n    return false;\n\n  // All clear, the live ranges can be merged.\n  if (RHS.hasSubRanges() || LHS.hasSubRanges()) {\n    BumpPtrAllocator &Allocator = LIS->getVNInfoAllocator();\n\n    // Transform lanemasks from the LHS to masks in the coalesced register and\n    // create initial subranges if necessary.\n    unsigned DstIdx = CP.getDstIdx();\n    if (!LHS.hasSubRanges()) {\n      LaneBitmask Mask = DstIdx == 0 ? CP.getNewRC()->getLaneMask()\n                                     : TRI->getSubRegIndexLaneMask(DstIdx);\n      // LHS must support subregs or we wouldn't be in this codepath.\n      assert(Mask.any());\n      LHS.createSubRangeFrom(Allocator, Mask, LHS);\n    } else if (DstIdx != 0) {\n      // Transform LHS lanemasks to new register class if necessary.\n      for (LiveInterval::SubRange &R : LHS.subranges()) {\n        LaneBitmask Mask = TRI->composeSubRegIndexLaneMask(DstIdx, R.LaneMask);\n        R.LaneMask = Mask;\n      }\n    }\n    LLVM_DEBUG(dbgs() << \"\\t\\tLHST = \" << printReg(CP.getDstReg()) << ' ' << LHS\n                      << '\\n');\n\n    // Determine lanemasks of RHS in the coalesced register and merge subranges.\n    unsigned SrcIdx = CP.getSrcIdx();\n    if (!RHS.hasSubRanges()) {\n      LaneBitmask Mask = SrcIdx == 0 ? CP.getNewRC()->getLaneMask()\n                                     : TRI->getSubRegIndexLaneMask(SrcIdx);\n      mergeSubRangeInto(LHS, RHS, Mask, CP, DstIdx);\n    } else {\n      // Pair up subranges and merge.\n      for (LiveInterval::SubRange &R : RHS.subranges()) {\n        LaneBitmask Mask = TRI->composeSubRegIndexLaneMask(SrcIdx, R.LaneMask);\n        mergeSubRangeInto(LHS, R, Mask, CP, DstIdx);\n      }\n    }\n    LLVM_DEBUG(dbgs() << \"\\tJoined SubRanges \" << LHS << \"\\n\");\n\n    // Pruning implicit defs from subranges may result in the main range\n    // having stale segments.\n    LHSVals.pruneMainSegments(LHS, ShrinkMainRange);\n\n    LHSVals.pruneSubRegValues(LHS, ShrinkMask);\n    RHSVals.pruneSubRegValues(LHS, ShrinkMask);\n  }\n\n  // The merging algorithm in LiveInterval::join() can't handle conflicting\n  // value mappings, so we need to remove any live ranges that overlap a\n  // CR_Replace resolution. Collect a set of end points that can be used to\n  // restore the live range after joining.\n  SmallVector<SlotIndex, 8> EndPoints;\n  LHSVals.pruneValues(RHSVals, EndPoints, true);\n  RHSVals.pruneValues(LHSVals, EndPoints, true);\n\n  // Erase COPY and IMPLICIT_DEF instructions. This may cause some external\n  // registers to require trimming.\n  SmallVector<Register, 8> ShrinkRegs;\n  LHSVals.eraseInstrs(ErasedInstrs, ShrinkRegs, &LHS);\n  RHSVals.eraseInstrs(ErasedInstrs, ShrinkRegs);\n  while (!ShrinkRegs.empty())\n    shrinkToUses(&LIS->getInterval(ShrinkRegs.pop_back_val()));\n\n  // Scan and mark undef any DBG_VALUEs that would refer to a different value.\n  checkMergingChangesDbgValues(CP, LHS, LHSVals, RHS, RHSVals);\n\n  // Join RHS into LHS.\n  LHS.join(RHS, LHSVals.getAssignments(), RHSVals.getAssignments(), NewVNInfo);\n\n  // Kill flags are going to be wrong if the live ranges were overlapping.\n  // Eventually, we should simply clear all kill flags when computing live\n  // ranges. They are reinserted after register allocation.\n  MRI->clearKillFlags(LHS.reg());\n  MRI->clearKillFlags(RHS.reg());\n\n  if (!EndPoints.empty()) {\n    // Recompute the parts of the live range we had to remove because of\n    // CR_Replace conflicts.\n    LLVM_DEBUG({\n      dbgs() << \"\\t\\trestoring liveness to \" << EndPoints.size() << \" points: \";\n      for (unsigned i = 0, n = EndPoints.size(); i != n; ++i) {\n        dbgs() << EndPoints[i];\n        if (i != n-1)\n          dbgs() << ',';\n      }\n      dbgs() << \":  \" << LHS << '\\n';\n    });\n    LIS->extendToIndices((LiveRange&)LHS, EndPoints);\n  }\n\n  return true;\n}\n\nbool RegisterCoalescer::joinIntervals(CoalescerPair &CP) {\n  return CP.isPhys() ? joinReservedPhysReg(CP) : joinVirtRegs(CP);\n}\n\nvoid RegisterCoalescer::buildVRegToDbgValueMap(MachineFunction &MF)\n{\n  const SlotIndexes &Slots = *LIS->getSlotIndexes();\n  SmallVector<MachineInstr *, 8> ToInsert;\n\n  // After collecting a block of DBG_VALUEs into ToInsert, enter them into the\n  // vreg => DbgValueLoc map.\n  auto CloseNewDVRange = [this, &ToInsert](SlotIndex Slot) {\n    for (auto *X : ToInsert)\n      DbgVRegToValues[X->getDebugOperand(0).getReg()].push_back({Slot, X});\n\n    ToInsert.clear();\n  };\n\n  // Iterate over all instructions, collecting them into the ToInsert vector.\n  // Once a non-debug instruction is found, record the slot index of the\n  // collected DBG_VALUEs.\n  for (auto &MBB : MF) {\n    SlotIndex CurrentSlot = Slots.getMBBStartIdx(&MBB);\n\n    for (auto &MI : MBB) {\n      if (MI.isDebugValue() && MI.getDebugOperand(0).isReg() &&\n          MI.getDebugOperand(0).getReg().isVirtual()) {\n        ToInsert.push_back(&MI);\n      } else if (!MI.isDebugInstr()) {\n        CurrentSlot = Slots.getInstructionIndex(MI);\n        CloseNewDVRange(CurrentSlot);\n      }\n    }\n\n    // Close range of DBG_VALUEs at the end of blocks.\n    CloseNewDVRange(Slots.getMBBEndIdx(&MBB));\n  }\n\n  // Sort all DBG_VALUEs we've seen by slot number.\n  for (auto &Pair : DbgVRegToValues)\n    llvm::sort(Pair.second);\n}\n\nvoid RegisterCoalescer::checkMergingChangesDbgValues(CoalescerPair &CP,\n                                                     LiveRange &LHS,\n                                                     JoinVals &LHSVals,\n                                                     LiveRange &RHS,\n                                                     JoinVals &RHSVals) {\n  auto ScanForDstReg = [&](Register Reg) {\n    checkMergingChangesDbgValuesImpl(Reg, RHS, LHS, LHSVals);\n  };\n\n  auto ScanForSrcReg = [&](Register Reg) {\n    checkMergingChangesDbgValuesImpl(Reg, LHS, RHS, RHSVals);\n  };\n\n  // Scan for potentially unsound DBG_VALUEs: examine first the register number\n  // Reg, and then any other vregs that may have been merged into  it.\n  auto PerformScan = [this](Register Reg, std::function<void(Register)> Func) {\n    Func(Reg);\n    if (DbgMergedVRegNums.count(Reg))\n      for (Register X : DbgMergedVRegNums[Reg])\n        Func(X);\n  };\n\n  // Scan for unsound updates of both the source and destination register.\n  PerformScan(CP.getSrcReg(), ScanForSrcReg);\n  PerformScan(CP.getDstReg(), ScanForDstReg);\n}\n\nvoid RegisterCoalescer::checkMergingChangesDbgValuesImpl(Register Reg,\n                                                         LiveRange &OtherLR,\n                                                         LiveRange &RegLR,\n                                                         JoinVals &RegVals) {\n  // Are there any DBG_VALUEs to examine?\n  auto VRegMapIt = DbgVRegToValues.find(Reg);\n  if (VRegMapIt == DbgVRegToValues.end())\n    return;\n\n  auto &DbgValueSet = VRegMapIt->second;\n  auto DbgValueSetIt = DbgValueSet.begin();\n  auto SegmentIt = OtherLR.begin();\n\n  bool LastUndefResult = false;\n  SlotIndex LastUndefIdx;\n\n  // If the \"Other\" register is live at a slot Idx, test whether Reg can\n  // safely be merged with it, or should be marked undef.\n  auto ShouldUndef = [&RegVals, &RegLR, &LastUndefResult,\n                      &LastUndefIdx](SlotIndex Idx) -> bool {\n    // Our worst-case performance typically happens with asan, causing very\n    // many DBG_VALUEs of the same location. Cache a copy of the most recent\n    // result for this edge-case.\n    if (LastUndefIdx == Idx)\n      return LastUndefResult;\n\n    // If the other range was live, and Reg's was not, the register coalescer\n    // will not have tried to resolve any conflicts. We don't know whether\n    // the DBG_VALUE will refer to the same value number, so it must be made\n    // undef.\n    auto OtherIt = RegLR.find(Idx);\n    if (OtherIt == RegLR.end())\n      return true;\n\n    // Both the registers were live: examine the conflict resolution record for\n    // the value number Reg refers to. CR_Keep meant that this value number\n    // \"won\" and the merged register definitely refers to that value. CR_Erase\n    // means the value number was a redundant copy of the other value, which\n    // was coalesced and Reg deleted. It's safe to refer to the other register\n    // (which will be the source of the copy).\n    auto Resolution = RegVals.getResolution(OtherIt->valno->id);\n    LastUndefResult = Resolution != JoinVals::CR_Keep &&\n                      Resolution != JoinVals::CR_Erase;\n    LastUndefIdx = Idx;\n    return LastUndefResult;\n  };\n\n  // Iterate over both the live-range of the \"Other\" register, and the set of\n  // DBG_VALUEs for Reg at the same time. Advance whichever one has the lowest\n  // slot index. This relies on the DbgValueSet being ordered.\n  while (DbgValueSetIt != DbgValueSet.end() && SegmentIt != OtherLR.end()) {\n    if (DbgValueSetIt->first < SegmentIt->end) {\n      // \"Other\" is live and there is a DBG_VALUE of Reg: test if we should\n      // set it undef.\n      if (DbgValueSetIt->first >= SegmentIt->start &&\n          DbgValueSetIt->second->getDebugOperand(0).getReg() != 0 &&\n          ShouldUndef(DbgValueSetIt->first)) {\n        // Mark undef, erase record of this DBG_VALUE to avoid revisiting.\n        DbgValueSetIt->second->setDebugValueUndef();\n        continue;\n      }\n      ++DbgValueSetIt;\n    } else {\n      ++SegmentIt;\n    }\n  }\n}\n\nnamespace {\n\n/// Information concerning MBB coalescing priority.\nstruct MBBPriorityInfo {\n  MachineBasicBlock *MBB;\n  unsigned Depth;\n  bool IsSplit;\n\n  MBBPriorityInfo(MachineBasicBlock *mbb, unsigned depth, bool issplit)\n    : MBB(mbb), Depth(depth), IsSplit(issplit) {}\n};\n\n} // end anonymous namespace\n\n/// C-style comparator that sorts first based on the loop depth of the basic\n/// block (the unsigned), and then on the MBB number.\n///\n/// EnableGlobalCopies assumes that the primary sort key is loop depth.\nstatic int compareMBBPriority(const MBBPriorityInfo *LHS,\n                              const MBBPriorityInfo *RHS) {\n  // Deeper loops first\n  if (LHS->Depth != RHS->Depth)\n    return LHS->Depth > RHS->Depth ? -1 : 1;\n\n  // Try to unsplit critical edges next.\n  if (LHS->IsSplit != RHS->IsSplit)\n    return LHS->IsSplit ? -1 : 1;\n\n  // Prefer blocks that are more connected in the CFG. This takes care of\n  // the most difficult copies first while intervals are short.\n  unsigned cl = LHS->MBB->pred_size() + LHS->MBB->succ_size();\n  unsigned cr = RHS->MBB->pred_size() + RHS->MBB->succ_size();\n  if (cl != cr)\n    return cl > cr ? -1 : 1;\n\n  // As a last resort, sort by block number.\n  return LHS->MBB->getNumber() < RHS->MBB->getNumber() ? -1 : 1;\n}\n\n/// \\returns true if the given copy uses or defines a local live range.\nstatic bool isLocalCopy(MachineInstr *Copy, const LiveIntervals *LIS) {\n  if (!Copy->isCopy())\n    return false;\n\n  if (Copy->getOperand(1).isUndef())\n    return false;\n\n  Register SrcReg = Copy->getOperand(1).getReg();\n  Register DstReg = Copy->getOperand(0).getReg();\n  if (Register::isPhysicalRegister(SrcReg) ||\n      Register::isPhysicalRegister(DstReg))\n    return false;\n\n  return LIS->intervalIsInOneMBB(LIS->getInterval(SrcReg))\n    || LIS->intervalIsInOneMBB(LIS->getInterval(DstReg));\n}\n\nvoid RegisterCoalescer::lateLiveIntervalUpdate() {\n  for (Register reg : ToBeUpdated) {\n    if (!LIS->hasInterval(reg))\n      continue;\n    LiveInterval &LI = LIS->getInterval(reg);\n    shrinkToUses(&LI, &DeadDefs);\n    if (!DeadDefs.empty())\n      eliminateDeadDefs();\n  }\n  ToBeUpdated.clear();\n}\n\nbool RegisterCoalescer::\ncopyCoalesceWorkList(MutableArrayRef<MachineInstr*> CurrList) {\n  bool Progress = false;\n  for (unsigned i = 0, e = CurrList.size(); i != e; ++i) {\n    if (!CurrList[i])\n      continue;\n    // Skip instruction pointers that have already been erased, for example by\n    // dead code elimination.\n    if (ErasedInstrs.count(CurrList[i])) {\n      CurrList[i] = nullptr;\n      continue;\n    }\n    bool Again = false;\n    bool Success = joinCopy(CurrList[i], Again);\n    Progress |= Success;\n    if (Success || !Again)\n      CurrList[i] = nullptr;\n  }\n  return Progress;\n}\n\n/// Check if DstReg is a terminal node.\n/// I.e., it does not have any affinity other than \\p Copy.\nstatic bool isTerminalReg(Register DstReg, const MachineInstr &Copy,\n                          const MachineRegisterInfo *MRI) {\n  assert(Copy.isCopyLike());\n  // Check if the destination of this copy as any other affinity.\n  for (const MachineInstr &MI : MRI->reg_nodbg_instructions(DstReg))\n    if (&MI != &Copy && MI.isCopyLike())\n      return false;\n  return true;\n}\n\nbool RegisterCoalescer::applyTerminalRule(const MachineInstr &Copy) const {\n  assert(Copy.isCopyLike());\n  if (!UseTerminalRule)\n    return false;\n  Register SrcReg, DstReg;\n  unsigned SrcSubReg = 0, DstSubReg = 0;\n  if (!isMoveInstr(*TRI, &Copy, SrcReg, DstReg, SrcSubReg, DstSubReg))\n    return false;\n  // Check if the destination of this copy has any other affinity.\n  if (DstReg.isPhysical() ||\n      // If SrcReg is a physical register, the copy won't be coalesced.\n      // Ignoring it may have other side effect (like missing\n      // rematerialization). So keep it.\n      SrcReg.isPhysical() || !isTerminalReg(DstReg, Copy, MRI))\n    return false;\n\n  // DstReg is a terminal node. Check if it interferes with any other\n  // copy involving SrcReg.\n  const MachineBasicBlock *OrigBB = Copy.getParent();\n  const LiveInterval &DstLI = LIS->getInterval(DstReg);\n  for (const MachineInstr &MI : MRI->reg_nodbg_instructions(SrcReg)) {\n    // Technically we should check if the weight of the new copy is\n    // interesting compared to the other one and update the weight\n    // of the copies accordingly. However, this would only work if\n    // we would gather all the copies first then coalesce, whereas\n    // right now we interleave both actions.\n    // For now, just consider the copies that are in the same block.\n    if (&MI == &Copy || !MI.isCopyLike() || MI.getParent() != OrigBB)\n      continue;\n    Register OtherSrcReg, OtherReg;\n    unsigned OtherSrcSubReg = 0, OtherSubReg = 0;\n    if (!isMoveInstr(*TRI, &Copy, OtherSrcReg, OtherReg, OtherSrcSubReg,\n                OtherSubReg))\n      return false;\n    if (OtherReg == SrcReg)\n      OtherReg = OtherSrcReg;\n    // Check if OtherReg is a non-terminal.\n    if (Register::isPhysicalRegister(OtherReg) ||\n        isTerminalReg(OtherReg, MI, MRI))\n      continue;\n    // Check that OtherReg interfere with DstReg.\n    if (LIS->getInterval(OtherReg).overlaps(DstLI)) {\n      LLVM_DEBUG(dbgs() << \"Apply terminal rule for: \" << printReg(DstReg)\n                        << '\\n');\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid\nRegisterCoalescer::copyCoalesceInMBB(MachineBasicBlock *MBB) {\n  LLVM_DEBUG(dbgs() << MBB->getName() << \":\\n\");\n\n  // Collect all copy-like instructions in MBB. Don't start coalescing anything\n  // yet, it might invalidate the iterator.\n  const unsigned PrevSize = WorkList.size();\n  if (JoinGlobalCopies) {\n    SmallVector<MachineInstr*, 2> LocalTerminals;\n    SmallVector<MachineInstr*, 2> GlobalTerminals;\n    // Coalesce copies bottom-up to coalesce local defs before local uses. They\n    // are not inherently easier to resolve, but slightly preferable until we\n    // have local live range splitting. In particular this is required by\n    // cmp+jmp macro fusion.\n    for (MachineBasicBlock::iterator MII = MBB->begin(), E = MBB->end();\n         MII != E; ++MII) {\n      if (!MII->isCopyLike())\n        continue;\n      bool ApplyTerminalRule = applyTerminalRule(*MII);\n      if (isLocalCopy(&(*MII), LIS)) {\n        if (ApplyTerminalRule)\n          LocalTerminals.push_back(&(*MII));\n        else\n          LocalWorkList.push_back(&(*MII));\n      } else {\n        if (ApplyTerminalRule)\n          GlobalTerminals.push_back(&(*MII));\n        else\n          WorkList.push_back(&(*MII));\n      }\n    }\n    // Append the copies evicted by the terminal rule at the end of the list.\n    LocalWorkList.append(LocalTerminals.begin(), LocalTerminals.end());\n    WorkList.append(GlobalTerminals.begin(), GlobalTerminals.end());\n  }\n  else {\n    SmallVector<MachineInstr*, 2> Terminals;\n    for (MachineInstr &MII : *MBB)\n      if (MII.isCopyLike()) {\n        if (applyTerminalRule(MII))\n          Terminals.push_back(&MII);\n        else\n          WorkList.push_back(&MII);\n      }\n    // Append the copies evicted by the terminal rule at the end of the list.\n    WorkList.append(Terminals.begin(), Terminals.end());\n  }\n  // Try coalescing the collected copies immediately, and remove the nulls.\n  // This prevents the WorkList from getting too large since most copies are\n  // joinable on the first attempt.\n  MutableArrayRef<MachineInstr*>\n    CurrList(WorkList.begin() + PrevSize, WorkList.end());\n  if (copyCoalesceWorkList(CurrList))\n    WorkList.erase(std::remove(WorkList.begin() + PrevSize, WorkList.end(),\n                               nullptr), WorkList.end());\n}\n\nvoid RegisterCoalescer::coalesceLocals() {\n  copyCoalesceWorkList(LocalWorkList);\n  for (unsigned j = 0, je = LocalWorkList.size(); j != je; ++j) {\n    if (LocalWorkList[j])\n      WorkList.push_back(LocalWorkList[j]);\n  }\n  LocalWorkList.clear();\n}\n\nvoid RegisterCoalescer::joinAllIntervals() {\n  LLVM_DEBUG(dbgs() << \"********** JOINING INTERVALS ***********\\n\");\n  assert(WorkList.empty() && LocalWorkList.empty() && \"Old data still around.\");\n\n  std::vector<MBBPriorityInfo> MBBs;\n  MBBs.reserve(MF->size());\n  for (MachineFunction::iterator I = MF->begin(), E = MF->end(); I != E; ++I) {\n    MachineBasicBlock *MBB = &*I;\n    MBBs.push_back(MBBPriorityInfo(MBB, Loops->getLoopDepth(MBB),\n                                   JoinSplitEdges && isSplitEdge(MBB)));\n  }\n  array_pod_sort(MBBs.begin(), MBBs.end(), compareMBBPriority);\n\n  // Coalesce intervals in MBB priority order.\n  unsigned CurrDepth = std::numeric_limits<unsigned>::max();\n  for (unsigned i = 0, e = MBBs.size(); i != e; ++i) {\n    // Try coalescing the collected local copies for deeper loops.\n    if (JoinGlobalCopies && MBBs[i].Depth < CurrDepth) {\n      coalesceLocals();\n      CurrDepth = MBBs[i].Depth;\n    }\n    copyCoalesceInMBB(MBBs[i].MBB);\n  }\n  lateLiveIntervalUpdate();\n  coalesceLocals();\n\n  // Joining intervals can allow other intervals to be joined.  Iteratively join\n  // until we make no progress.\n  while (copyCoalesceWorkList(WorkList))\n    /* empty */ ;\n  lateLiveIntervalUpdate();\n}\n\nvoid RegisterCoalescer::releaseMemory() {\n  ErasedInstrs.clear();\n  WorkList.clear();\n  DeadDefs.clear();\n  InflateRegs.clear();\n  LargeLIVisitCounter.clear();\n}\n\nbool RegisterCoalescer::runOnMachineFunction(MachineFunction &fn) {\n  LLVM_DEBUG(dbgs() << \"********** SIMPLE REGISTER COALESCING **********\\n\"\n                    << \"********** Function: \" << fn.getName() << '\\n');\n\n  // Variables changed between a setjmp and a longjump can have undefined value\n  // after the longjmp. This behaviour can be observed if such a variable is\n  // spilled, so longjmp won't restore the value in the spill slot.\n  // RegisterCoalescer should not run in functions with a setjmp to avoid\n  // merging such undefined variables with predictable ones.\n  //\n  // TODO: Could specifically disable coalescing registers live across setjmp\n  // calls\n  if (fn.exposesReturnsTwice()) {\n    LLVM_DEBUG(\n        dbgs() << \"* Skipped as it exposes funcions that returns twice.\\n\");\n    return false;\n  }\n\n  MF = &fn;\n  MRI = &fn.getRegInfo();\n  const TargetSubtargetInfo &STI = fn.getSubtarget();\n  TRI = STI.getRegisterInfo();\n  TII = STI.getInstrInfo();\n  LIS = &getAnalysis<LiveIntervals>();\n  AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();\n  Loops = &getAnalysis<MachineLoopInfo>();\n  if (EnableGlobalCopies == cl::BOU_UNSET)\n    JoinGlobalCopies = STI.enableJoinGlobalCopies();\n  else\n    JoinGlobalCopies = (EnableGlobalCopies == cl::BOU_TRUE);\n\n  // The MachineScheduler does not currently require JoinSplitEdges. This will\n  // either be enabled unconditionally or replaced by a more general live range\n  // splitting optimization.\n  JoinSplitEdges = EnableJoinSplits;\n\n  if (VerifyCoalescing)\n    MF->verify(this, \"Before register coalescing\");\n\n  DbgVRegToValues.clear();\n  DbgMergedVRegNums.clear();\n  buildVRegToDbgValueMap(fn);\n\n  RegClassInfo.runOnMachineFunction(fn);\n\n  // Join (coalesce) intervals if requested.\n  if (EnableJoining)\n    joinAllIntervals();\n\n  // After deleting a lot of copies, register classes may be less constrained.\n  // Removing sub-register operands may allow GR32_ABCD -> GR32 and DPR_VFP2 ->\n  // DPR inflation.\n  array_pod_sort(InflateRegs.begin(), InflateRegs.end());\n  InflateRegs.erase(std::unique(InflateRegs.begin(), InflateRegs.end()),\n                    InflateRegs.end());\n  LLVM_DEBUG(dbgs() << \"Trying to inflate \" << InflateRegs.size()\n                    << \" regs.\\n\");\n  for (unsigned i = 0, e = InflateRegs.size(); i != e; ++i) {\n    Register Reg = InflateRegs[i];\n    if (MRI->reg_nodbg_empty(Reg))\n      continue;\n    if (MRI->recomputeRegClass(Reg)) {\n      LLVM_DEBUG(dbgs() << printReg(Reg) << \" inflated to \"\n                        << TRI->getRegClassName(MRI->getRegClass(Reg)) << '\\n');\n      ++NumInflated;\n\n      LiveInterval &LI = LIS->getInterval(Reg);\n      if (LI.hasSubRanges()) {\n        // If the inflated register class does not support subregisters anymore\n        // remove the subranges.\n        if (!MRI->shouldTrackSubRegLiveness(Reg)) {\n          LI.clearSubRanges();\n        } else {\n#ifndef NDEBUG\n          LaneBitmask MaxMask = MRI->getMaxLaneMaskForVReg(Reg);\n          // If subranges are still supported, then the same subregs\n          // should still be supported.\n          for (LiveInterval::SubRange &S : LI.subranges()) {\n            assert((S.LaneMask & ~MaxMask).none());\n          }\n#endif\n        }\n      }\n    }\n  }\n\n  LLVM_DEBUG(dump());\n  if (VerifyCoalescing)\n    MF->verify(this, \"After register coalescing\");\n  return true;\n}\n\nvoid RegisterCoalescer::print(raw_ostream &O, const Module* m) const {\n   LIS->print(O, m);\n}\n"}}, "reports": [{"events": [{"location": {"col": 25, "file": 4, "line": 3409}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 4, "line": 254}, "message": "differing parameters are named here: ('DstIdx'), in definition: ('ComposeSubRegIdx')"}, {"location": {"col": 10, "file": 4, "line": 254}, "message": "function '(anonymous namespace)::RegisterCoalescer::mergeSubRangeInto' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp", "reportHash": "bb8a7646f5767d4ff1d89d6f2f8ccfe0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 4, "line": 3626}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 4, "line": 366}, "message": "differing parameters are named here: ('OtherRange', 'RegRange', 'Vals2'), in definition: ('OtherLR', 'RegLR', 'RegVals')"}, {"location": {"col": 10, "file": 4, "line": 366}, "message": "function '(anonymous namespace)::RegisterCoalescer::checkMergingChangesDbgValuesImpl' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp", "reportHash": "07935be96ad2896a51fda0225e79a292", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
