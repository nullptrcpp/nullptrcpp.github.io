<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Analysis/ValueTracking.cpp", "content": "//===- ValueTracking.cpp - Walk computations to compute properties --------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains routines that help analyze properties that chains of\n// computations have.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumeBundleQueries.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/GuardUtils.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/Loads.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/OptimizationRemarkEmitter.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/DiagnosticInfo.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GetElementPtrTypeIterator.h\"\n#include \"llvm/IR/GlobalAlias.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/IntrinsicsAArch64.h\"\n#include \"llvm/IR/IntrinsicsX86.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nusing namespace llvm;\nusing namespace llvm::PatternMatch;\n\n// Controls the number of uses of the value searched for possible\n// dominating comparisons.\nstatic cl::opt<unsigned> DomConditionsMaxUses(\"dom-conditions-max-uses\",\n                                              cl::Hidden, cl::init(20));\n\n/// Returns the bitwidth of the given scalar or pointer type. For vector types,\n/// returns the element type's bitwidth.\nstatic unsigned getBitWidth(Type *Ty, const DataLayout &DL) {\n  if (unsigned BitWidth = Ty->getScalarSizeInBits())\n    return BitWidth;\n\n  return DL.getPointerTypeSizeInBits(Ty);\n}\n\nnamespace {\n\n// Simplifying using an assume can only be done in a particular control-flow\n// context (the context instruction provides that context). If an assume and\n// the context instruction are not in the same block then the DT helps in\n// figuring out if we can use it.\nstruct Query {\n  const DataLayout &DL;\n  AssumptionCache *AC;\n  const Instruction *CxtI;\n  const DominatorTree *DT;\n\n  // Unlike the other analyses, this may be a nullptr because not all clients\n  // provide it currently.\n  OptimizationRemarkEmitter *ORE;\n\n  /// Set of assumptions that should be excluded from further queries.\n  /// This is because of the potential for mutual recursion to cause\n  /// computeKnownBits to repeatedly visit the same assume intrinsic. The\n  /// classic case of this is assume(x = y), which will attempt to determine\n  /// bits in x from bits in y, which will attempt to determine bits in y from\n  /// bits in x, etc. Regarding the mutual recursion, computeKnownBits can call\n  /// isKnownNonZero, which calls computeKnownBits and isKnownToBeAPowerOfTwo\n  /// (all of which can call computeKnownBits), and so on.\n  std::array<const Value *, MaxAnalysisRecursionDepth> Excluded;\n\n  /// If true, it is safe to use metadata during simplification.\n  InstrInfoQuery IIQ;\n\n  unsigned NumExcluded = 0;\n\n  Query(const DataLayout &DL, AssumptionCache *AC, const Instruction *CxtI,\n        const DominatorTree *DT, bool UseInstrInfo,\n        OptimizationRemarkEmitter *ORE = nullptr)\n      : DL(DL), AC(AC), CxtI(CxtI), DT(DT), ORE(ORE), IIQ(UseInstrInfo) {}\n\n  Query(const Query &Q, const Value *NewExcl)\n      : DL(Q.DL), AC(Q.AC), CxtI(Q.CxtI), DT(Q.DT), ORE(Q.ORE), IIQ(Q.IIQ),\n        NumExcluded(Q.NumExcluded) {\n    Excluded = Q.Excluded;\n    Excluded[NumExcluded++] = NewExcl;\n    assert(NumExcluded <= Excluded.size());\n  }\n\n  bool isExcluded(const Value *Value) const {\n    if (NumExcluded == 0)\n      return false;\n    auto End = Excluded.begin() + NumExcluded;\n    return std::find(Excluded.begin(), End, Value) != End;\n  }\n};\n\n} // end anonymous namespace\n\n// Given the provided Value and, potentially, a context instruction, return\n// the preferred context instruction (if any).\nstatic const Instruction *safeCxtI(const Value *V, const Instruction *CxtI) {\n  // If we've been provided with a context instruction, then use that (provided\n  // it has been inserted).\n  if (CxtI && CxtI->getParent())\n    return CxtI;\n\n  // If the value is really an already-inserted instruction, then use that.\n  CxtI = dyn_cast<Instruction>(V);\n  if (CxtI && CxtI->getParent())\n    return CxtI;\n\n  return nullptr;\n}\n\nstatic bool getShuffleDemandedElts(const ShuffleVectorInst *Shuf,\n                                   const APInt &DemandedElts,\n                                   APInt &DemandedLHS, APInt &DemandedRHS) {\n  // The length of scalable vectors is unknown at compile time, thus we\n  // cannot check their values\n  if (isa<ScalableVectorType>(Shuf->getType()))\n    return false;\n\n  int NumElts =\n      cast<FixedVectorType>(Shuf->getOperand(0)->getType())->getNumElements();\n  int NumMaskElts = cast<FixedVectorType>(Shuf->getType())->getNumElements();\n  DemandedLHS = DemandedRHS = APInt::getNullValue(NumElts);\n  if (DemandedElts.isNullValue())\n    return true;\n  // Simple case of a shuffle with zeroinitializer.\n  if (all_of(Shuf->getShuffleMask(), [](int Elt) { return Elt == 0; })) {\n    DemandedLHS.setBit(0);\n    return true;\n  }\n  for (int i = 0; i != NumMaskElts; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    int M = Shuf->getMaskValue(i);\n    assert(M < (NumElts * 2) && \"Invalid shuffle mask constant\");\n\n    // For undef elements, we don't know anything about the common state of\n    // the shuffle result.\n    if (M == -1)\n      return false;\n    if (M < NumElts)\n      DemandedLHS.setBit(M % NumElts);\n    else\n      DemandedRHS.setBit(M % NumElts);\n  }\n\n  return true;\n}\n\nstatic void computeKnownBits(const Value *V, const APInt &DemandedElts,\n                             KnownBits &Known, unsigned Depth, const Query &Q);\n\nstatic void computeKnownBits(const Value *V, KnownBits &Known, unsigned Depth,\n                             const Query &Q) {\n  // FIXME: We currently have no way to represent the DemandedElts of a scalable\n  // vector\n  if (isa<ScalableVectorType>(V->getType())) {\n    Known.resetAll();\n    return;\n  }\n\n  auto *FVTy = dyn_cast<FixedVectorType>(V->getType());\n  APInt DemandedElts =\n      FVTy ? APInt::getAllOnesValue(FVTy->getNumElements()) : APInt(1, 1);\n  computeKnownBits(V, DemandedElts, Known, Depth, Q);\n}\n\nvoid llvm::computeKnownBits(const Value *V, KnownBits &Known,\n                            const DataLayout &DL, unsigned Depth,\n                            AssumptionCache *AC, const Instruction *CxtI,\n                            const DominatorTree *DT,\n                            OptimizationRemarkEmitter *ORE, bool UseInstrInfo) {\n  ::computeKnownBits(V, Known, Depth,\n                     Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo, ORE));\n}\n\nvoid llvm::computeKnownBits(const Value *V, const APInt &DemandedElts,\n                            KnownBits &Known, const DataLayout &DL,\n                            unsigned Depth, AssumptionCache *AC,\n                            const Instruction *CxtI, const DominatorTree *DT,\n                            OptimizationRemarkEmitter *ORE, bool UseInstrInfo) {\n  ::computeKnownBits(V, DemandedElts, Known, Depth,\n                     Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo, ORE));\n}\n\nstatic KnownBits computeKnownBits(const Value *V, const APInt &DemandedElts,\n                                  unsigned Depth, const Query &Q);\n\nstatic KnownBits computeKnownBits(const Value *V, unsigned Depth,\n                                  const Query &Q);\n\nKnownBits llvm::computeKnownBits(const Value *V, const DataLayout &DL,\n                                 unsigned Depth, AssumptionCache *AC,\n                                 const Instruction *CxtI,\n                                 const DominatorTree *DT,\n                                 OptimizationRemarkEmitter *ORE,\n                                 bool UseInstrInfo) {\n  return ::computeKnownBits(\n      V, Depth, Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo, ORE));\n}\n\nKnownBits llvm::computeKnownBits(const Value *V, const APInt &DemandedElts,\n                                 const DataLayout &DL, unsigned Depth,\n                                 AssumptionCache *AC, const Instruction *CxtI,\n                                 const DominatorTree *DT,\n                                 OptimizationRemarkEmitter *ORE,\n                                 bool UseInstrInfo) {\n  return ::computeKnownBits(\n      V, DemandedElts, Depth,\n      Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo, ORE));\n}\n\nbool llvm::haveNoCommonBitsSet(const Value *LHS, const Value *RHS,\n                               const DataLayout &DL, AssumptionCache *AC,\n                               const Instruction *CxtI, const DominatorTree *DT,\n                               bool UseInstrInfo) {\n  assert(LHS->getType() == RHS->getType() &&\n         \"LHS and RHS should have the same type\");\n  assert(LHS->getType()->isIntOrIntVectorTy() &&\n         \"LHS and RHS should be integers\");\n  // Look for an inverted mask: (X & ~M) op (Y & M).\n  Value *M;\n  if (match(LHS, m_c_And(m_Not(m_Value(M)), m_Value())) &&\n      match(RHS, m_c_And(m_Specific(M), m_Value())))\n    return true;\n  if (match(RHS, m_c_And(m_Not(m_Value(M)), m_Value())) &&\n      match(LHS, m_c_And(m_Specific(M), m_Value())))\n    return true;\n  IntegerType *IT = cast<IntegerType>(LHS->getType()->getScalarType());\n  KnownBits LHSKnown(IT->getBitWidth());\n  KnownBits RHSKnown(IT->getBitWidth());\n  computeKnownBits(LHS, LHSKnown, DL, 0, AC, CxtI, DT, nullptr, UseInstrInfo);\n  computeKnownBits(RHS, RHSKnown, DL, 0, AC, CxtI, DT, nullptr, UseInstrInfo);\n  return (LHSKnown.Zero | RHSKnown.Zero).isAllOnesValue();\n}\n\nbool llvm::isOnlyUsedInZeroEqualityComparison(const Instruction *CxtI) {\n  for (const User *U : CxtI->users()) {\n    if (const ICmpInst *IC = dyn_cast<ICmpInst>(U))\n      if (IC->isEquality())\n        if (Constant *C = dyn_cast<Constant>(IC->getOperand(1)))\n          if (C->isNullValue())\n            continue;\n    return false;\n  }\n  return true;\n}\n\nstatic bool isKnownToBeAPowerOfTwo(const Value *V, bool OrZero, unsigned Depth,\n                                   const Query &Q);\n\nbool llvm::isKnownToBeAPowerOfTwo(const Value *V, const DataLayout &DL,\n                                  bool OrZero, unsigned Depth,\n                                  AssumptionCache *AC, const Instruction *CxtI,\n                                  const DominatorTree *DT, bool UseInstrInfo) {\n  return ::isKnownToBeAPowerOfTwo(\n      V, OrZero, Depth, Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo));\n}\n\nstatic bool isKnownNonZero(const Value *V, const APInt &DemandedElts,\n                           unsigned Depth, const Query &Q);\n\nstatic bool isKnownNonZero(const Value *V, unsigned Depth, const Query &Q);\n\nbool llvm::isKnownNonZero(const Value *V, const DataLayout &DL, unsigned Depth,\n                          AssumptionCache *AC, const Instruction *CxtI,\n                          const DominatorTree *DT, bool UseInstrInfo) {\n  return ::isKnownNonZero(V, Depth,\n                          Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo));\n}\n\nbool llvm::isKnownNonNegative(const Value *V, const DataLayout &DL,\n                              unsigned Depth, AssumptionCache *AC,\n                              const Instruction *CxtI, const DominatorTree *DT,\n                              bool UseInstrInfo) {\n  KnownBits Known =\n      computeKnownBits(V, DL, Depth, AC, CxtI, DT, nullptr, UseInstrInfo);\n  return Known.isNonNegative();\n}\n\nbool llvm::isKnownPositive(const Value *V, const DataLayout &DL, unsigned Depth,\n                           AssumptionCache *AC, const Instruction *CxtI,\n                           const DominatorTree *DT, bool UseInstrInfo) {\n  if (auto *CI = dyn_cast<ConstantInt>(V))\n    return CI->getValue().isStrictlyPositive();\n\n  // TODO: We'd doing two recursive queries here.  We should factor this such\n  // that only a single query is needed.\n  return isKnownNonNegative(V, DL, Depth, AC, CxtI, DT, UseInstrInfo) &&\n         isKnownNonZero(V, DL, Depth, AC, CxtI, DT, UseInstrInfo);\n}\n\nbool llvm::isKnownNegative(const Value *V, const DataLayout &DL, unsigned Depth,\n                           AssumptionCache *AC, const Instruction *CxtI,\n                           const DominatorTree *DT, bool UseInstrInfo) {\n  KnownBits Known =\n      computeKnownBits(V, DL, Depth, AC, CxtI, DT, nullptr, UseInstrInfo);\n  return Known.isNegative();\n}\n\nstatic bool isKnownNonEqual(const Value *V1, const Value *V2, unsigned Depth,\n                            const Query &Q);\n\nbool llvm::isKnownNonEqual(const Value *V1, const Value *V2,\n                           const DataLayout &DL, AssumptionCache *AC,\n                           const Instruction *CxtI, const DominatorTree *DT,\n                           bool UseInstrInfo) {\n  return ::isKnownNonEqual(V1, V2, 0,\n                           Query(DL, AC, safeCxtI(V1, safeCxtI(V2, CxtI)), DT,\n                                 UseInstrInfo, /*ORE=*/nullptr));\n}\n\nstatic bool MaskedValueIsZero(const Value *V, const APInt &Mask, unsigned Depth,\n                              const Query &Q);\n\nbool llvm::MaskedValueIsZero(const Value *V, const APInt &Mask,\n                             const DataLayout &DL, unsigned Depth,\n                             AssumptionCache *AC, const Instruction *CxtI,\n                             const DominatorTree *DT, bool UseInstrInfo) {\n  return ::MaskedValueIsZero(\n      V, Mask, Depth, Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo));\n}\n\nstatic unsigned ComputeNumSignBits(const Value *V, const APInt &DemandedElts,\n                                   unsigned Depth, const Query &Q);\n\nstatic unsigned ComputeNumSignBits(const Value *V, unsigned Depth,\n                                   const Query &Q) {\n  // FIXME: We currently have no way to represent the DemandedElts of a scalable\n  // vector\n  if (isa<ScalableVectorType>(V->getType()))\n    return 1;\n\n  auto *FVTy = dyn_cast<FixedVectorType>(V->getType());\n  APInt DemandedElts =\n      FVTy ? APInt::getAllOnesValue(FVTy->getNumElements()) : APInt(1, 1);\n  return ComputeNumSignBits(V, DemandedElts, Depth, Q);\n}\n\nunsigned llvm::ComputeNumSignBits(const Value *V, const DataLayout &DL,\n                                  unsigned Depth, AssumptionCache *AC,\n                                  const Instruction *CxtI,\n                                  const DominatorTree *DT, bool UseInstrInfo) {\n  return ::ComputeNumSignBits(\n      V, Depth, Query(DL, AC, safeCxtI(V, CxtI), DT, UseInstrInfo));\n}\n\nstatic void computeKnownBitsAddSub(bool Add, const Value *Op0, const Value *Op1,\n                                   bool NSW, const APInt &DemandedElts,\n                                   KnownBits &KnownOut, KnownBits &Known2,\n                                   unsigned Depth, const Query &Q) {\n  computeKnownBits(Op1, DemandedElts, KnownOut, Depth + 1, Q);\n\n  // If one operand is unknown and we have no nowrap information,\n  // the result will be unknown independently of the second operand.\n  if (KnownOut.isUnknown() && !NSW)\n    return;\n\n  computeKnownBits(Op0, DemandedElts, Known2, Depth + 1, Q);\n  KnownOut = KnownBits::computeForAddSub(Add, NSW, Known2, KnownOut);\n}\n\nstatic void computeKnownBitsMul(const Value *Op0, const Value *Op1, bool NSW,\n                                const APInt &DemandedElts, KnownBits &Known,\n                                KnownBits &Known2, unsigned Depth,\n                                const Query &Q) {\n  computeKnownBits(Op1, DemandedElts, Known, Depth + 1, Q);\n  computeKnownBits(Op0, DemandedElts, Known2, Depth + 1, Q);\n\n  bool isKnownNegative = false;\n  bool isKnownNonNegative = false;\n  // If the multiplication is known not to overflow, compute the sign bit.\n  if (NSW) {\n    if (Op0 == Op1) {\n      // The product of a number with itself is non-negative.\n      isKnownNonNegative = true;\n    } else {\n      bool isKnownNonNegativeOp1 = Known.isNonNegative();\n      bool isKnownNonNegativeOp0 = Known2.isNonNegative();\n      bool isKnownNegativeOp1 = Known.isNegative();\n      bool isKnownNegativeOp0 = Known2.isNegative();\n      // The product of two numbers with the same sign is non-negative.\n      isKnownNonNegative = (isKnownNegativeOp1 && isKnownNegativeOp0) ||\n                           (isKnownNonNegativeOp1 && isKnownNonNegativeOp0);\n      // The product of a negative number and a non-negative number is either\n      // negative or zero.\n      if (!isKnownNonNegative)\n        isKnownNegative =\n            (isKnownNegativeOp1 && isKnownNonNegativeOp0 &&\n             Known2.isNonZero()) ||\n            (isKnownNegativeOp0 && isKnownNonNegativeOp1 && Known.isNonZero());\n    }\n  }\n\n  Known = KnownBits::computeForMul(Known, Known2);\n\n  // Only make use of no-wrap flags if we failed to compute the sign bit\n  // directly.  This matters if the multiplication always overflows, in\n  // which case we prefer to follow the result of the direct computation,\n  // though as the program is invoking undefined behaviour we can choose\n  // whatever we like here.\n  if (isKnownNonNegative && !Known.isNegative())\n    Known.makeNonNegative();\n  else if (isKnownNegative && !Known.isNonNegative())\n    Known.makeNegative();\n}\n\nvoid llvm::computeKnownBitsFromRangeMetadata(const MDNode &Ranges,\n                                             KnownBits &Known) {\n  unsigned BitWidth = Known.getBitWidth();\n  unsigned NumRanges = Ranges.getNumOperands() / 2;\n  assert(NumRanges >= 1);\n\n  Known.Zero.setAllBits();\n  Known.One.setAllBits();\n\n  for (unsigned i = 0; i < NumRanges; ++i) {\n    ConstantInt *Lower =\n        mdconst::extract<ConstantInt>(Ranges.getOperand(2 * i + 0));\n    ConstantInt *Upper =\n        mdconst::extract<ConstantInt>(Ranges.getOperand(2 * i + 1));\n    ConstantRange Range(Lower->getValue(), Upper->getValue());\n\n    // The first CommonPrefixBits of all values in Range are equal.\n    unsigned CommonPrefixBits =\n        (Range.getUnsignedMax() ^ Range.getUnsignedMin()).countLeadingZeros();\n    APInt Mask = APInt::getHighBitsSet(BitWidth, CommonPrefixBits);\n    APInt UnsignedMax = Range.getUnsignedMax().zextOrTrunc(BitWidth);\n    Known.One &= UnsignedMax & Mask;\n    Known.Zero &= ~UnsignedMax & Mask;\n  }\n}\n\nstatic bool isEphemeralValueOf(const Instruction *I, const Value *E) {\n  SmallVector<const Value *, 16> WorkSet(1, I);\n  SmallPtrSet<const Value *, 32> Visited;\n  SmallPtrSet<const Value *, 16> EphValues;\n\n  // The instruction defining an assumption's condition itself is always\n  // considered ephemeral to that assumption (even if it has other\n  // non-ephemeral users). See r246696's test case for an example.\n  if (is_contained(I->operands(), E))\n    return true;\n\n  while (!WorkSet.empty()) {\n    const Value *V = WorkSet.pop_back_val();\n    if (!Visited.insert(V).second)\n      continue;\n\n    // If all uses of this value are ephemeral, then so is this value.\n    if (llvm::all_of(V->users(), [&](const User *U) {\n                                   return EphValues.count(U);\n                                 })) {\n      if (V == E)\n        return true;\n\n      if (V == I || isSafeToSpeculativelyExecute(V)) {\n       EphValues.insert(V);\n       if (const User *U = dyn_cast<User>(V))\n         append_range(WorkSet, U->operands());\n      }\n    }\n  }\n\n  return false;\n}\n\n// Is this an intrinsic that cannot be speculated but also cannot trap?\nbool llvm::isAssumeLikeIntrinsic(const Instruction *I) {\n  if (const CallInst *CI = dyn_cast<CallInst>(I))\n    if (Function *F = CI->getCalledFunction())\n      switch (F->getIntrinsicID()) {\n      default: break;\n      // FIXME: This list is repeated from NoTTI::getIntrinsicCost.\n      case Intrinsic::assume:\n      case Intrinsic::sideeffect:\n      case Intrinsic::pseudoprobe:\n      case Intrinsic::dbg_declare:\n      case Intrinsic::dbg_value:\n      case Intrinsic::dbg_label:\n      case Intrinsic::invariant_start:\n      case Intrinsic::invariant_end:\n      case Intrinsic::lifetime_start:\n      case Intrinsic::lifetime_end:\n      case Intrinsic::experimental_noalias_scope_decl:\n      case Intrinsic::objectsize:\n      case Intrinsic::ptr_annotation:\n      case Intrinsic::var_annotation:\n        return true;\n      }\n\n  return false;\n}\n\nbool llvm::isValidAssumeForContext(const Instruction *Inv,\n                                   const Instruction *CxtI,\n                                   const DominatorTree *DT) {\n  // There are two restrictions on the use of an assume:\n  //  1. The assume must dominate the context (or the control flow must\n  //     reach the assume whenever it reaches the context).\n  //  2. The context must not be in the assume's set of ephemeral values\n  //     (otherwise we will use the assume to prove that the condition\n  //     feeding the assume is trivially true, thus causing the removal of\n  //     the assume).\n\n  if (Inv->getParent() == CxtI->getParent()) {\n    // If Inv and CtxI are in the same block, check if the assume (Inv) is first\n    // in the BB.\n    if (Inv->comesBefore(CxtI))\n      return true;\n\n    // Don't let an assume affect itself - this would cause the problems\n    // `isEphemeralValueOf` is trying to prevent, and it would also make\n    // the loop below go out of bounds.\n    if (Inv == CxtI)\n      return false;\n\n    // The context comes first, but they're both in the same block.\n    // Make sure there is nothing in between that might interrupt\n    // the control flow, not even CxtI itself.\n    for (BasicBlock::const_iterator I(CxtI), IE(Inv); I != IE; ++I)\n      if (!isGuaranteedToTransferExecutionToSuccessor(&*I))\n        return false;\n\n    return !isEphemeralValueOf(Inv, CxtI);\n  }\n\n  // Inv and CxtI are in different blocks.\n  if (DT) {\n    if (DT->dominates(Inv, CxtI))\n      return true;\n  } else if (Inv->getParent() == CxtI->getParent()->getSinglePredecessor()) {\n    // We don't have a DT, but this trivially dominates.\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool cmpExcludesZero(CmpInst::Predicate Pred, const Value *RHS) {\n  // v u> y implies v != 0.\n  if (Pred == ICmpInst::ICMP_UGT)\n    return true;\n\n  // Special-case v != 0 to also handle v != null.\n  if (Pred == ICmpInst::ICMP_NE)\n    return match(RHS, m_Zero());\n\n  // All other predicates - rely on generic ConstantRange handling.\n  const APInt *C;\n  if (!match(RHS, m_APInt(C)))\n    return false;\n\n  ConstantRange TrueValues = ConstantRange::makeExactICmpRegion(Pred, *C);\n  return !TrueValues.contains(APInt::getNullValue(C->getBitWidth()));\n}\n\nstatic bool isKnownNonZeroFromAssume(const Value *V, const Query &Q) {\n  // Use of assumptions is context-sensitive. If we don't have a context, we\n  // cannot use them!\n  if (!Q.AC || !Q.CxtI)\n    return false;\n\n  if (Q.CxtI && V->getType()->isPointerTy()) {\n    SmallVector<Attribute::AttrKind, 2> AttrKinds{Attribute::NonNull};\n    if (!NullPointerIsDefined(Q.CxtI->getFunction(),\n                              V->getType()->getPointerAddressSpace()))\n      AttrKinds.push_back(Attribute::Dereferenceable);\n\n    if (getKnowledgeValidInContext(V, AttrKinds, Q.CxtI, Q.DT, Q.AC))\n      return true;\n  }\n\n  for (auto &AssumeVH : Q.AC->assumptionsFor(V)) {\n    if (!AssumeVH)\n      continue;\n    CallInst *I = cast<CallInst>(AssumeVH);\n    assert(I->getFunction() == Q.CxtI->getFunction() &&\n           \"Got assumption for the wrong function!\");\n    if (Q.isExcluded(I))\n      continue;\n\n    // Warning: This loop can end up being somewhat performance sensitive.\n    // We're running this loop for once for each value queried resulting in a\n    // runtime of ~O(#assumes * #values).\n\n    assert(I->getCalledFunction()->getIntrinsicID() == Intrinsic::assume &&\n           \"must be an assume intrinsic\");\n\n    Value *RHS;\n    CmpInst::Predicate Pred;\n    auto m_V = m_CombineOr(m_Specific(V), m_PtrToInt(m_Specific(V)));\n    if (!match(I->getArgOperand(0), m_c_ICmp(Pred, m_V, m_Value(RHS))))\n      return false;\n\n    if (cmpExcludesZero(Pred, RHS) && isValidAssumeForContext(I, Q.CxtI, Q.DT))\n      return true;\n  }\n\n  return false;\n}\n\nstatic void computeKnownBitsFromAssume(const Value *V, KnownBits &Known,\n                                       unsigned Depth, const Query &Q) {\n  // Use of assumptions is context-sensitive. If we don't have a context, we\n  // cannot use them!\n  if (!Q.AC || !Q.CxtI)\n    return;\n\n  unsigned BitWidth = Known.getBitWidth();\n\n  // Refine Known set if the pointer alignment is set by assume bundles.\n  if (V->getType()->isPointerTy()) {\n    if (RetainedKnowledge RK = getKnowledgeValidInContext(\n            V, {Attribute::Alignment}, Q.CxtI, Q.DT, Q.AC)) {\n      Known.Zero.setLowBits(Log2_32(RK.ArgValue));\n    }\n  }\n\n  // Note that the patterns below need to be kept in sync with the code\n  // in AssumptionCache::updateAffectedValues.\n\n  for (auto &AssumeVH : Q.AC->assumptionsFor(V)) {\n    if (!AssumeVH)\n      continue;\n    CallInst *I = cast<CallInst>(AssumeVH);\n    assert(I->getParent()->getParent() == Q.CxtI->getParent()->getParent() &&\n           \"Got assumption for the wrong function!\");\n    if (Q.isExcluded(I))\n      continue;\n\n    // Warning: This loop can end up being somewhat performance sensitive.\n    // We're running this loop for once for each value queried resulting in a\n    // runtime of ~O(#assumes * #values).\n\n    assert(I->getCalledFunction()->getIntrinsicID() == Intrinsic::assume &&\n           \"must be an assume intrinsic\");\n\n    Value *Arg = I->getArgOperand(0);\n\n    if (Arg == V && isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n      assert(BitWidth == 1 && \"assume operand is not i1?\");\n      Known.setAllOnes();\n      return;\n    }\n    if (match(Arg, m_Not(m_Specific(V))) &&\n        isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n      assert(BitWidth == 1 && \"assume operand is not i1?\");\n      Known.setAllZero();\n      return;\n    }\n\n    // The remaining tests are all recursive, so bail out if we hit the limit.\n    if (Depth == MaxAnalysisRecursionDepth)\n      continue;\n\n    ICmpInst *Cmp = dyn_cast<ICmpInst>(Arg);\n    if (!Cmp)\n      continue;\n\n    // Note that ptrtoint may change the bitwidth.\n    Value *A, *B;\n    auto m_V = m_CombineOr(m_Specific(V), m_PtrToInt(m_Specific(V)));\n\n    CmpInst::Predicate Pred;\n    uint64_t C;\n    switch (Cmp->getPredicate()) {\n    default:\n      break;\n    case ICmpInst::ICMP_EQ:\n      // assume(v = a)\n      if (match(Cmp, m_c_ICmp(Pred, m_V, m_Value(A))) &&\n          isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        Known.Zero |= RHSKnown.Zero;\n        Known.One  |= RHSKnown.One;\n      // assume(v & b = a)\n      } else if (match(Cmp,\n                       m_c_ICmp(Pred, m_c_And(m_V, m_Value(B)), m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        KnownBits MaskKnown =\n            computeKnownBits(B, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // For those bits in the mask that are known to be one, we can propagate\n        // known bits from the RHS to V.\n        Known.Zero |= RHSKnown.Zero & MaskKnown.One;\n        Known.One  |= RHSKnown.One  & MaskKnown.One;\n      // assume(~(v & b) = a)\n      } else if (match(Cmp, m_c_ICmp(Pred, m_Not(m_c_And(m_V, m_Value(B))),\n                                     m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        KnownBits MaskKnown =\n            computeKnownBits(B, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // For those bits in the mask that are known to be one, we can propagate\n        // inverted known bits from the RHS to V.\n        Known.Zero |= RHSKnown.One  & MaskKnown.One;\n        Known.One  |= RHSKnown.Zero & MaskKnown.One;\n      // assume(v | b = a)\n      } else if (match(Cmp,\n                       m_c_ICmp(Pred, m_c_Or(m_V, m_Value(B)), m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        KnownBits BKnown =\n            computeKnownBits(B, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // For those bits in B that are known to be zero, we can propagate known\n        // bits from the RHS to V.\n        Known.Zero |= RHSKnown.Zero & BKnown.Zero;\n        Known.One  |= RHSKnown.One  & BKnown.Zero;\n      // assume(~(v | b) = a)\n      } else if (match(Cmp, m_c_ICmp(Pred, m_Not(m_c_Or(m_V, m_Value(B))),\n                                     m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        KnownBits BKnown =\n            computeKnownBits(B, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // For those bits in B that are known to be zero, we can propagate\n        // inverted known bits from the RHS to V.\n        Known.Zero |= RHSKnown.One  & BKnown.Zero;\n        Known.One  |= RHSKnown.Zero & BKnown.Zero;\n      // assume(v ^ b = a)\n      } else if (match(Cmp,\n                       m_c_ICmp(Pred, m_c_Xor(m_V, m_Value(B)), m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        KnownBits BKnown =\n            computeKnownBits(B, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // For those bits in B that are known to be zero, we can propagate known\n        // bits from the RHS to V. For those bits in B that are known to be one,\n        // we can propagate inverted known bits from the RHS to V.\n        Known.Zero |= RHSKnown.Zero & BKnown.Zero;\n        Known.One  |= RHSKnown.One  & BKnown.Zero;\n        Known.Zero |= RHSKnown.One  & BKnown.One;\n        Known.One  |= RHSKnown.Zero & BKnown.One;\n      // assume(~(v ^ b) = a)\n      } else if (match(Cmp, m_c_ICmp(Pred, m_Not(m_c_Xor(m_V, m_Value(B))),\n                                     m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        KnownBits BKnown =\n            computeKnownBits(B, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // For those bits in B that are known to be zero, we can propagate\n        // inverted known bits from the RHS to V. For those bits in B that are\n        // known to be one, we can propagate known bits from the RHS to V.\n        Known.Zero |= RHSKnown.One  & BKnown.Zero;\n        Known.One  |= RHSKnown.Zero & BKnown.Zero;\n        Known.Zero |= RHSKnown.Zero & BKnown.One;\n        Known.One  |= RHSKnown.One  & BKnown.One;\n      // assume(v << c = a)\n      } else if (match(Cmp, m_c_ICmp(Pred, m_Shl(m_V, m_ConstantInt(C)),\n                                     m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT) && C < BitWidth) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // For those bits in RHS that are known, we can propagate them to known\n        // bits in V shifted to the right by C.\n        RHSKnown.Zero.lshrInPlace(C);\n        Known.Zero |= RHSKnown.Zero;\n        RHSKnown.One.lshrInPlace(C);\n        Known.One  |= RHSKnown.One;\n      // assume(~(v << c) = a)\n      } else if (match(Cmp, m_c_ICmp(Pred, m_Not(m_Shl(m_V, m_ConstantInt(C))),\n                                     m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT) && C < BitWidth) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        // For those bits in RHS that are known, we can propagate them inverted\n        // to known bits in V shifted to the right by C.\n        RHSKnown.One.lshrInPlace(C);\n        Known.Zero |= RHSKnown.One;\n        RHSKnown.Zero.lshrInPlace(C);\n        Known.One  |= RHSKnown.Zero;\n      // assume(v >> c = a)\n      } else if (match(Cmp, m_c_ICmp(Pred, m_Shr(m_V, m_ConstantInt(C)),\n                                     m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT) && C < BitWidth) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        // For those bits in RHS that are known, we can propagate them to known\n        // bits in V shifted to the right by C.\n        Known.Zero |= RHSKnown.Zero << C;\n        Known.One  |= RHSKnown.One  << C;\n      // assume(~(v >> c) = a)\n      } else if (match(Cmp, m_c_ICmp(Pred, m_Not(m_Shr(m_V, m_ConstantInt(C))),\n                                     m_Value(A))) &&\n                 isValidAssumeForContext(I, Q.CxtI, Q.DT) && C < BitWidth) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n        // For those bits in RHS that are known, we can propagate them inverted\n        // to known bits in V shifted to the right by C.\n        Known.Zero |= RHSKnown.One  << C;\n        Known.One  |= RHSKnown.Zero << C;\n      }\n      break;\n    case ICmpInst::ICMP_SGE:\n      // assume(v >=_s c) where c is non-negative\n      if (match(Cmp, m_ICmp(Pred, m_V, m_Value(A))) &&\n          isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth + 1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        if (RHSKnown.isNonNegative()) {\n          // We know that the sign bit is zero.\n          Known.makeNonNegative();\n        }\n      }\n      break;\n    case ICmpInst::ICMP_SGT:\n      // assume(v >_s c) where c is at least -1.\n      if (match(Cmp, m_ICmp(Pred, m_V, m_Value(A))) &&\n          isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth + 1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        if (RHSKnown.isAllOnes() || RHSKnown.isNonNegative()) {\n          // We know that the sign bit is zero.\n          Known.makeNonNegative();\n        }\n      }\n      break;\n    case ICmpInst::ICMP_SLE:\n      // assume(v <=_s c) where c is negative\n      if (match(Cmp, m_ICmp(Pred, m_V, m_Value(A))) &&\n          isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth + 1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        if (RHSKnown.isNegative()) {\n          // We know that the sign bit is one.\n          Known.makeNegative();\n        }\n      }\n      break;\n    case ICmpInst::ICMP_SLT:\n      // assume(v <_s c) where c is non-positive\n      if (match(Cmp, m_ICmp(Pred, m_V, m_Value(A))) &&\n          isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        if (RHSKnown.isZero() || RHSKnown.isNegative()) {\n          // We know that the sign bit is one.\n          Known.makeNegative();\n        }\n      }\n      break;\n    case ICmpInst::ICMP_ULE:\n      // assume(v <=_u c)\n      if (match(Cmp, m_ICmp(Pred, m_V, m_Value(A))) &&\n          isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // Whatever high bits in c are zero are known to be zero.\n        Known.Zero.setHighBits(RHSKnown.countMinLeadingZeros());\n      }\n      break;\n    case ICmpInst::ICMP_ULT:\n      // assume(v <_u c)\n      if (match(Cmp, m_ICmp(Pred, m_V, m_Value(A))) &&\n          isValidAssumeForContext(I, Q.CxtI, Q.DT)) {\n        KnownBits RHSKnown =\n            computeKnownBits(A, Depth+1, Query(Q, I)).anyextOrTrunc(BitWidth);\n\n        // If the RHS is known zero, then this assumption must be wrong (nothing\n        // is unsigned less than zero). Signal a conflict and get out of here.\n        if (RHSKnown.isZero()) {\n          Known.Zero.setAllBits();\n          Known.One.setAllBits();\n          break;\n        }\n\n        // Whatever high bits in c are zero are known to be zero (if c is a power\n        // of 2, then one more).\n        if (isKnownToBeAPowerOfTwo(A, false, Depth + 1, Query(Q, I)))\n          Known.Zero.setHighBits(RHSKnown.countMinLeadingZeros() + 1);\n        else\n          Known.Zero.setHighBits(RHSKnown.countMinLeadingZeros());\n      }\n      break;\n    }\n  }\n\n  // If assumptions conflict with each other or previous known bits, then we\n  // have a logical fallacy. It's possible that the assumption is not reachable,\n  // so this isn't a real bug. On the other hand, the program may have undefined\n  // behavior, or we might have a bug in the compiler. We can't assert/crash, so\n  // clear out the known bits, try to warn the user, and hope for the best.\n  if (Known.Zero.intersects(Known.One)) {\n    Known.resetAll();\n\n    if (Q.ORE)\n      Q.ORE->emit([&]() {\n        auto *CxtI = const_cast<Instruction *>(Q.CxtI);\n        return OptimizationRemarkAnalysis(\"value-tracking\", \"BadAssumption\",\n                                          CxtI)\n               << \"Detected conflicting code assumptions. Program may \"\n                  \"have undefined behavior, or compiler may have \"\n                  \"internal error.\";\n      });\n  }\n}\n\n/// Compute known bits from a shift operator, including those with a\n/// non-constant shift amount. Known is the output of this function. Known2 is a\n/// pre-allocated temporary with the same bit width as Known and on return\n/// contains the known bit of the shift value source. KF is an\n/// operator-specific function that, given the known-bits and a shift amount,\n/// compute the implied known-bits of the shift operator's result respectively\n/// for that shift amount. The results from calling KF are conservatively\n/// combined for all permitted shift amounts.\nstatic void computeKnownBitsFromShiftOperator(\n    const Operator *I, const APInt &DemandedElts, KnownBits &Known,\n    KnownBits &Known2, unsigned Depth, const Query &Q,\n    function_ref<KnownBits(const KnownBits &, const KnownBits &)> KF) {\n  unsigned BitWidth = Known.getBitWidth();\n  computeKnownBits(I->getOperand(0), DemandedElts, Known2, Depth + 1, Q);\n  computeKnownBits(I->getOperand(1), DemandedElts, Known, Depth + 1, Q);\n\n  // Note: We cannot use Known.Zero.getLimitedValue() here, because if\n  // BitWidth > 64 and any upper bits are known, we'll end up returning the\n  // limit value (which implies all bits are known).\n  uint64_t ShiftAmtKZ = Known.Zero.zextOrTrunc(64).getZExtValue();\n  uint64_t ShiftAmtKO = Known.One.zextOrTrunc(64).getZExtValue();\n  bool ShiftAmtIsConstant = Known.isConstant();\n  bool MaxShiftAmtIsOutOfRange = Known.getMaxValue().uge(BitWidth);\n\n  if (ShiftAmtIsConstant) {\n    Known = KF(Known2, Known);\n\n    // If the known bits conflict, this must be an overflowing left shift, so\n    // the shift result is poison. We can return anything we want. Choose 0 for\n    // the best folding opportunity.\n    if (Known.hasConflict())\n      Known.setAllZero();\n\n    return;\n  }\n\n  // If the shift amount could be greater than or equal to the bit-width of the\n  // LHS, the value could be poison, but bail out because the check below is\n  // expensive.\n  // TODO: Should we just carry on?\n  if (MaxShiftAmtIsOutOfRange) {\n    Known.resetAll();\n    return;\n  }\n\n  // It would be more-clearly correct to use the two temporaries for this\n  // calculation. Reusing the APInts here to prevent unnecessary allocations.\n  Known.resetAll();\n\n  // If we know the shifter operand is nonzero, we can sometimes infer more\n  // known bits. However this is expensive to compute, so be lazy about it and\n  // only compute it when absolutely necessary.\n  Optional<bool> ShifterOperandIsNonZero;\n\n  // Early exit if we can't constrain any well-defined shift amount.\n  if (!(ShiftAmtKZ & (PowerOf2Ceil(BitWidth) - 1)) &&\n      !(ShiftAmtKO & (PowerOf2Ceil(BitWidth) - 1))) {\n    ShifterOperandIsNonZero =\n        isKnownNonZero(I->getOperand(1), DemandedElts, Depth + 1, Q);\n    if (!*ShifterOperandIsNonZero)\n      return;\n  }\n\n  Known.Zero.setAllBits();\n  Known.One.setAllBits();\n  for (unsigned ShiftAmt = 0; ShiftAmt < BitWidth; ++ShiftAmt) {\n    // Combine the shifted known input bits only for those shift amounts\n    // compatible with its known constraints.\n    if ((ShiftAmt & ~ShiftAmtKZ) != ShiftAmt)\n      continue;\n    if ((ShiftAmt | ShiftAmtKO) != ShiftAmt)\n      continue;\n    // If we know the shifter is nonzero, we may be able to infer more known\n    // bits. This check is sunk down as far as possible to avoid the expensive\n    // call to isKnownNonZero if the cheaper checks above fail.\n    if (ShiftAmt == 0) {\n      if (!ShifterOperandIsNonZero.hasValue())\n        ShifterOperandIsNonZero =\n            isKnownNonZero(I->getOperand(1), DemandedElts, Depth + 1, Q);\n      if (*ShifterOperandIsNonZero)\n        continue;\n    }\n\n    Known = KnownBits::commonBits(\n        Known, KF(Known2, KnownBits::makeConstant(APInt(32, ShiftAmt))));\n  }\n\n  // If the known bits conflict, the result is poison. Return a 0 and hope the\n  // caller can further optimize that.\n  if (Known.hasConflict())\n    Known.setAllZero();\n}\n\nstatic void computeKnownBitsFromOperator(const Operator *I,\n                                         const APInt &DemandedElts,\n                                         KnownBits &Known, unsigned Depth,\n                                         const Query &Q) {\n  unsigned BitWidth = Known.getBitWidth();\n\n  KnownBits Known2(BitWidth);\n  switch (I->getOpcode()) {\n  default: break;\n  case Instruction::Load:\n    if (MDNode *MD =\n            Q.IIQ.getMetadata(cast<LoadInst>(I), LLVMContext::MD_range))\n      computeKnownBitsFromRangeMetadata(*MD, Known);\n    break;\n  case Instruction::And: {\n    // If either the LHS or the RHS are Zero, the result is zero.\n    computeKnownBits(I->getOperand(1), DemandedElts, Known, Depth + 1, Q);\n    computeKnownBits(I->getOperand(0), DemandedElts, Known2, Depth + 1, Q);\n\n    Known &= Known2;\n\n    // and(x, add (x, -1)) is a common idiom that always clears the low bit;\n    // here we handle the more general case of adding any odd number by\n    // matching the form add(x, add(x, y)) where y is odd.\n    // TODO: This could be generalized to clearing any bit set in y where the\n    // following bit is known to be unset in y.\n    Value *X = nullptr, *Y = nullptr;\n    if (!Known.Zero[0] && !Known.One[0] &&\n        match(I, m_c_BinOp(m_Value(X), m_Add(m_Deferred(X), m_Value(Y))))) {\n      Known2.resetAll();\n      computeKnownBits(Y, DemandedElts, Known2, Depth + 1, Q);\n      if (Known2.countMinTrailingOnes() > 0)\n        Known.Zero.setBit(0);\n    }\n    break;\n  }\n  case Instruction::Or:\n    computeKnownBits(I->getOperand(1), DemandedElts, Known, Depth + 1, Q);\n    computeKnownBits(I->getOperand(0), DemandedElts, Known2, Depth + 1, Q);\n\n    Known |= Known2;\n    break;\n  case Instruction::Xor:\n    computeKnownBits(I->getOperand(1), DemandedElts, Known, Depth + 1, Q);\n    computeKnownBits(I->getOperand(0), DemandedElts, Known2, Depth + 1, Q);\n\n    Known ^= Known2;\n    break;\n  case Instruction::Mul: {\n    bool NSW = Q.IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(I));\n    computeKnownBitsMul(I->getOperand(0), I->getOperand(1), NSW, DemandedElts,\n                        Known, Known2, Depth, Q);\n    break;\n  }\n  case Instruction::UDiv: {\n    computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n    computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n    Known = KnownBits::udiv(Known, Known2);\n    break;\n  }\n  case Instruction::Select: {\n    const Value *LHS = nullptr, *RHS = nullptr;\n    SelectPatternFlavor SPF = matchSelectPattern(I, LHS, RHS).Flavor;\n    if (SelectPatternResult::isMinOrMax(SPF)) {\n      computeKnownBits(RHS, Known, Depth + 1, Q);\n      computeKnownBits(LHS, Known2, Depth + 1, Q);\n      switch (SPF) {\n      default:\n        llvm_unreachable(\"Unhandled select pattern flavor!\");\n      case SPF_SMAX:\n        Known = KnownBits::smax(Known, Known2);\n        break;\n      case SPF_SMIN:\n        Known = KnownBits::smin(Known, Known2);\n        break;\n      case SPF_UMAX:\n        Known = KnownBits::umax(Known, Known2);\n        break;\n      case SPF_UMIN:\n        Known = KnownBits::umin(Known, Known2);\n        break;\n      }\n      break;\n    }\n\n    computeKnownBits(I->getOperand(2), Known, Depth + 1, Q);\n    computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n\n    // Only known if known in both the LHS and RHS.\n    Known = KnownBits::commonBits(Known, Known2);\n\n    if (SPF == SPF_ABS) {\n      // RHS from matchSelectPattern returns the negation part of abs pattern.\n      // If the negate has an NSW flag we can assume the sign bit of the result\n      // will be 0 because that makes abs(INT_MIN) undefined.\n      if (match(RHS, m_Neg(m_Specific(LHS))) &&\n          Q.IIQ.hasNoSignedWrap(cast<Instruction>(RHS)))\n        Known.Zero.setSignBit();\n    }\n\n    break;\n  }\n  case Instruction::FPTrunc:\n  case Instruction::FPExt:\n  case Instruction::FPToUI:\n  case Instruction::FPToSI:\n  case Instruction::SIToFP:\n  case Instruction::UIToFP:\n    break; // Can't work with floating point.\n  case Instruction::PtrToInt:\n  case Instruction::IntToPtr:\n    // Fall through and handle them the same as zext/trunc.\n    LLVM_FALLTHROUGH;\n  case Instruction::ZExt:\n  case Instruction::Trunc: {\n    Type *SrcTy = I->getOperand(0)->getType();\n\n    unsigned SrcBitWidth;\n    // Note that we handle pointer operands here because of inttoptr/ptrtoint\n    // which fall through here.\n    Type *ScalarTy = SrcTy->getScalarType();\n    SrcBitWidth = ScalarTy->isPointerTy() ?\n      Q.DL.getPointerTypeSizeInBits(ScalarTy) :\n      Q.DL.getTypeSizeInBits(ScalarTy);\n\n    assert(SrcBitWidth && \"SrcBitWidth can't be zero\");\n    Known = Known.anyextOrTrunc(SrcBitWidth);\n    computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n    Known = Known.zextOrTrunc(BitWidth);\n    break;\n  }\n  case Instruction::BitCast: {\n    Type *SrcTy = I->getOperand(0)->getType();\n    if (SrcTy->isIntOrPtrTy() &&\n        // TODO: For now, not handling conversions like:\n        // (bitcast i64 %x to <2 x i32>)\n        !I->getType()->isVectorTy()) {\n      computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n      break;\n    }\n    break;\n  }\n  case Instruction::SExt: {\n    // Compute the bits in the result that are not present in the input.\n    unsigned SrcBitWidth = I->getOperand(0)->getType()->getScalarSizeInBits();\n\n    Known = Known.trunc(SrcBitWidth);\n    computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n    // If the sign bit of the input is known set or clear, then we know the\n    // top bits of the result.\n    Known = Known.sext(BitWidth);\n    break;\n  }\n  case Instruction::Shl: {\n    bool NSW = Q.IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(I));\n    auto KF = [NSW](const KnownBits &KnownVal, const KnownBits &KnownAmt) {\n      KnownBits Result = KnownBits::shl(KnownVal, KnownAmt);\n      // If this shift has \"nsw\" keyword, then the result is either a poison\n      // value or has the same sign bit as the first operand.\n      if (NSW) {\n        if (KnownVal.Zero.isSignBitSet())\n          Result.Zero.setSignBit();\n        if (KnownVal.One.isSignBitSet())\n          Result.One.setSignBit();\n      }\n      return Result;\n    };\n    computeKnownBitsFromShiftOperator(I, DemandedElts, Known, Known2, Depth, Q,\n                                      KF);\n    break;\n  }\n  case Instruction::LShr: {\n    auto KF = [](const KnownBits &KnownVal, const KnownBits &KnownAmt) {\n      return KnownBits::lshr(KnownVal, KnownAmt);\n    };\n    computeKnownBitsFromShiftOperator(I, DemandedElts, Known, Known2, Depth, Q,\n                                      KF);\n    break;\n  }\n  case Instruction::AShr: {\n    auto KF = [](const KnownBits &KnownVal, const KnownBits &KnownAmt) {\n      return KnownBits::ashr(KnownVal, KnownAmt);\n    };\n    computeKnownBitsFromShiftOperator(I, DemandedElts, Known, Known2, Depth, Q,\n                                      KF);\n    break;\n  }\n  case Instruction::Sub: {\n    bool NSW = Q.IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(I));\n    computeKnownBitsAddSub(false, I->getOperand(0), I->getOperand(1), NSW,\n                           DemandedElts, Known, Known2, Depth, Q);\n    break;\n  }\n  case Instruction::Add: {\n    bool NSW = Q.IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(I));\n    computeKnownBitsAddSub(true, I->getOperand(0), I->getOperand(1), NSW,\n                           DemandedElts, Known, Known2, Depth, Q);\n    break;\n  }\n  case Instruction::SRem:\n    computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n    computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n    Known = KnownBits::srem(Known, Known2);\n    break;\n\n  case Instruction::URem:\n    computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n    computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n    Known = KnownBits::urem(Known, Known2);\n    break;\n  case Instruction::Alloca:\n    Known.Zero.setLowBits(Log2(cast<AllocaInst>(I)->getAlign()));\n    break;\n  case Instruction::GetElementPtr: {\n    // Analyze all of the subscripts of this getelementptr instruction\n    // to determine if we can prove known low zero bits.\n    computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n    // Accumulate the constant indices in a separate variable\n    // to minimize the number of calls to computeForAddSub.\n    APInt AccConstIndices(BitWidth, 0, /*IsSigned*/ true);\n\n    gep_type_iterator GTI = gep_type_begin(I);\n    for (unsigned i = 1, e = I->getNumOperands(); i != e; ++i, ++GTI) {\n      // TrailZ can only become smaller, short-circuit if we hit zero.\n      if (Known.isUnknown())\n        break;\n\n      Value *Index = I->getOperand(i);\n\n      // Handle case when index is zero.\n      Constant *CIndex = dyn_cast<Constant>(Index);\n      if (CIndex && CIndex->isZeroValue())\n        continue;\n\n      if (StructType *STy = GTI.getStructTypeOrNull()) {\n        // Handle struct member offset arithmetic.\n\n        assert(CIndex &&\n               \"Access to structure field must be known at compile time\");\n\n        if (CIndex->getType()->isVectorTy())\n          Index = CIndex->getSplatValue();\n\n        unsigned Idx = cast<ConstantInt>(Index)->getZExtValue();\n        const StructLayout *SL = Q.DL.getStructLayout(STy);\n        uint64_t Offset = SL->getElementOffset(Idx);\n        AccConstIndices += Offset;\n        continue;\n      }\n\n      // Handle array index arithmetic.\n      Type *IndexedTy = GTI.getIndexedType();\n      if (!IndexedTy->isSized()) {\n        Known.resetAll();\n        break;\n      }\n\n      unsigned IndexBitWidth = Index->getType()->getScalarSizeInBits();\n      KnownBits IndexBits(IndexBitWidth);\n      computeKnownBits(Index, IndexBits, Depth + 1, Q);\n      TypeSize IndexTypeSize = Q.DL.getTypeAllocSize(IndexedTy);\n      uint64_t TypeSizeInBytes = IndexTypeSize.getKnownMinSize();\n      KnownBits ScalingFactor(IndexBitWidth);\n      // Multiply by current sizeof type.\n      // &A[i] == A + i * sizeof(*A[i]).\n      if (IndexTypeSize.isScalable()) {\n        // For scalable types the only thing we know about sizeof is\n        // that this is a multiple of the minimum size.\n        ScalingFactor.Zero.setLowBits(countTrailingZeros(TypeSizeInBytes));\n      } else if (IndexBits.isConstant()) {\n        APInt IndexConst = IndexBits.getConstant();\n        APInt ScalingFactor(IndexBitWidth, TypeSizeInBytes);\n        IndexConst *= ScalingFactor;\n        AccConstIndices += IndexConst.sextOrTrunc(BitWidth);\n        continue;\n      } else {\n        ScalingFactor =\n            KnownBits::makeConstant(APInt(IndexBitWidth, TypeSizeInBytes));\n      }\n      IndexBits = KnownBits::computeForMul(IndexBits, ScalingFactor);\n\n      // If the offsets have a different width from the pointer, according\n      // to the language reference we need to sign-extend or truncate them\n      // to the width of the pointer.\n      IndexBits = IndexBits.sextOrTrunc(BitWidth);\n\n      // Note that inbounds does *not* guarantee nsw for the addition, as only\n      // the offset is signed, while the base address is unsigned.\n      Known = KnownBits::computeForAddSub(\n          /*Add=*/true, /*NSW=*/false, Known, IndexBits);\n    }\n    if (!Known.isUnknown() && !AccConstIndices.isNullValue()) {\n      KnownBits Index = KnownBits::makeConstant(AccConstIndices);\n      Known = KnownBits::computeForAddSub(\n          /*Add=*/true, /*NSW=*/false, Known, Index);\n    }\n    break;\n  }\n  case Instruction::PHI: {\n    const PHINode *P = cast<PHINode>(I);\n    // Handle the case of a simple two-predecessor recurrence PHI.\n    // There's a lot more that could theoretically be done here, but\n    // this is sufficient to catch some interesting cases.\n    if (P->getNumIncomingValues() == 2) {\n      for (unsigned i = 0; i != 2; ++i) {\n        Value *L = P->getIncomingValue(i);\n        Value *R = P->getIncomingValue(!i);\n        Instruction *RInst = P->getIncomingBlock(!i)->getTerminator();\n        Instruction *LInst = P->getIncomingBlock(i)->getTerminator();\n        Operator *LU = dyn_cast<Operator>(L);\n        if (!LU)\n          continue;\n        unsigned Opcode = LU->getOpcode();\n        // Check for operations that have the property that if\n        // both their operands have low zero bits, the result\n        // will have low zero bits.\n        if (Opcode == Instruction::Add ||\n            Opcode == Instruction::Sub ||\n            Opcode == Instruction::And ||\n            Opcode == Instruction::Or ||\n            Opcode == Instruction::Mul) {\n          Value *LL = LU->getOperand(0);\n          Value *LR = LU->getOperand(1);\n          // Find a recurrence.\n          if (LL == I)\n            L = LR;\n          else if (LR == I)\n            L = LL;\n          else\n            continue; // Check for recurrence with L and R flipped.\n\n          // Change the context instruction to the \"edge\" that flows into the\n          // phi. This is important because that is where the value is actually\n          // \"evaluated\" even though it is used later somewhere else. (see also\n          // D69571).\n          Query RecQ = Q;\n\n          // Ok, we have a PHI of the form L op= R. Check for low\n          // zero bits.\n          RecQ.CxtI = RInst;\n          computeKnownBits(R, Known2, Depth + 1, RecQ);\n\n          // We need to take the minimum number of known bits\n          KnownBits Known3(BitWidth);\n          RecQ.CxtI = LInst;\n          computeKnownBits(L, Known3, Depth + 1, RecQ);\n\n          Known.Zero.setLowBits(std::min(Known2.countMinTrailingZeros(),\n                                         Known3.countMinTrailingZeros()));\n\n          auto *OverflowOp = dyn_cast<OverflowingBinaryOperator>(LU);\n          if (OverflowOp && Q.IIQ.hasNoSignedWrap(OverflowOp)) {\n            // If initial value of recurrence is nonnegative, and we are adding\n            // a nonnegative number with nsw, the result can only be nonnegative\n            // or poison value regardless of the number of times we execute the\n            // add in phi recurrence. If initial value is negative and we are\n            // adding a negative number with nsw, the result can only be\n            // negative or poison value. Similar arguments apply to sub and mul.\n            //\n            // (add non-negative, non-negative) --> non-negative\n            // (add negative, negative) --> negative\n            if (Opcode == Instruction::Add) {\n              if (Known2.isNonNegative() && Known3.isNonNegative())\n                Known.makeNonNegative();\n              else if (Known2.isNegative() && Known3.isNegative())\n                Known.makeNegative();\n            }\n\n            // (sub nsw non-negative, negative) --> non-negative\n            // (sub nsw negative, non-negative) --> negative\n            else if (Opcode == Instruction::Sub && LL == I) {\n              if (Known2.isNonNegative() && Known3.isNegative())\n                Known.makeNonNegative();\n              else if (Known2.isNegative() && Known3.isNonNegative())\n                Known.makeNegative();\n            }\n\n            // (mul nsw non-negative, non-negative) --> non-negative\n            else if (Opcode == Instruction::Mul && Known2.isNonNegative() &&\n                     Known3.isNonNegative())\n              Known.makeNonNegative();\n          }\n\n          break;\n        }\n      }\n    }\n\n    // Unreachable blocks may have zero-operand PHI nodes.\n    if (P->getNumIncomingValues() == 0)\n      break;\n\n    // Otherwise take the unions of the known bit sets of the operands,\n    // taking conservative care to avoid excessive recursion.\n    if (Depth < MaxAnalysisRecursionDepth - 1 && !Known.Zero && !Known.One) {\n      // Skip if every incoming value references to ourself.\n      if (dyn_cast_or_null<UndefValue>(P->hasConstantValue()))\n        break;\n\n      Known.Zero.setAllBits();\n      Known.One.setAllBits();\n      for (unsigned u = 0, e = P->getNumIncomingValues(); u < e; ++u) {\n        Value *IncValue = P->getIncomingValue(u);\n        // Skip direct self references.\n        if (IncValue == P) continue;\n\n        // Change the context instruction to the \"edge\" that flows into the\n        // phi. This is important because that is where the value is actually\n        // \"evaluated\" even though it is used later somewhere else. (see also\n        // D69571).\n        Query RecQ = Q;\n        RecQ.CxtI = P->getIncomingBlock(u)->getTerminator();\n\n        Known2 = KnownBits(BitWidth);\n        // Recurse, but cap the recursion to one level, because we don't\n        // want to waste time spinning around in loops.\n        computeKnownBits(IncValue, Known2, MaxAnalysisRecursionDepth - 1, RecQ);\n        Known = KnownBits::commonBits(Known, Known2);\n        // If all bits have been ruled out, there's no need to check\n        // more operands.\n        if (Known.isUnknown())\n          break;\n      }\n    }\n    break;\n  }\n  case Instruction::Call:\n  case Instruction::Invoke:\n    // If range metadata is attached to this call, set known bits from that,\n    // and then intersect with known bits based on other properties of the\n    // function.\n    if (MDNode *MD =\n            Q.IIQ.getMetadata(cast<Instruction>(I), LLVMContext::MD_range))\n      computeKnownBitsFromRangeMetadata(*MD, Known);\n    if (const Value *RV = cast<CallBase>(I)->getReturnedArgOperand()) {\n      computeKnownBits(RV, Known2, Depth + 1, Q);\n      Known.Zero |= Known2.Zero;\n      Known.One |= Known2.One;\n    }\n    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {\n      switch (II->getIntrinsicID()) {\n      default: break;\n      case Intrinsic::abs: {\n        computeKnownBits(I->getOperand(0), Known2, Depth + 1, Q);\n        bool IntMinIsPoison = match(II->getArgOperand(1), m_One());\n        Known = Known2.abs(IntMinIsPoison);\n        break;\n      }\n      case Intrinsic::bitreverse:\n        computeKnownBits(I->getOperand(0), DemandedElts, Known2, Depth + 1, Q);\n        Known.Zero |= Known2.Zero.reverseBits();\n        Known.One |= Known2.One.reverseBits();\n        break;\n      case Intrinsic::bswap:\n        computeKnownBits(I->getOperand(0), DemandedElts, Known2, Depth + 1, Q);\n        Known.Zero |= Known2.Zero.byteSwap();\n        Known.One |= Known2.One.byteSwap();\n        break;\n      case Intrinsic::ctlz: {\n        computeKnownBits(I->getOperand(0), Known2, Depth + 1, Q);\n        // If we have a known 1, its position is our upper bound.\n        unsigned PossibleLZ = Known2.countMaxLeadingZeros();\n        // If this call is undefined for 0, the result will be less than 2^n.\n        if (II->getArgOperand(1) == ConstantInt::getTrue(II->getContext()))\n          PossibleLZ = std::min(PossibleLZ, BitWidth - 1);\n        unsigned LowBits = Log2_32(PossibleLZ)+1;\n        Known.Zero.setBitsFrom(LowBits);\n        break;\n      }\n      case Intrinsic::cttz: {\n        computeKnownBits(I->getOperand(0), Known2, Depth + 1, Q);\n        // If we have a known 1, its position is our upper bound.\n        unsigned PossibleTZ = Known2.countMaxTrailingZeros();\n        // If this call is undefined for 0, the result will be less than 2^n.\n        if (II->getArgOperand(1) == ConstantInt::getTrue(II->getContext()))\n          PossibleTZ = std::min(PossibleTZ, BitWidth - 1);\n        unsigned LowBits = Log2_32(PossibleTZ)+1;\n        Known.Zero.setBitsFrom(LowBits);\n        break;\n      }\n      case Intrinsic::ctpop: {\n        computeKnownBits(I->getOperand(0), Known2, Depth + 1, Q);\n        // We can bound the space the count needs.  Also, bits known to be zero\n        // can't contribute to the population.\n        unsigned BitsPossiblySet = Known2.countMaxPopulation();\n        unsigned LowBits = Log2_32(BitsPossiblySet)+1;\n        Known.Zero.setBitsFrom(LowBits);\n        // TODO: we could bound KnownOne using the lower bound on the number\n        // of bits which might be set provided by popcnt KnownOne2.\n        break;\n      }\n      case Intrinsic::fshr:\n      case Intrinsic::fshl: {\n        const APInt *SA;\n        if (!match(I->getOperand(2), m_APInt(SA)))\n          break;\n\n        // Normalize to funnel shift left.\n        uint64_t ShiftAmt = SA->urem(BitWidth);\n        if (II->getIntrinsicID() == Intrinsic::fshr)\n          ShiftAmt = BitWidth - ShiftAmt;\n\n        KnownBits Known3(BitWidth);\n        computeKnownBits(I->getOperand(0), Known2, Depth + 1, Q);\n        computeKnownBits(I->getOperand(1), Known3, Depth + 1, Q);\n\n        Known.Zero =\n            Known2.Zero.shl(ShiftAmt) | Known3.Zero.lshr(BitWidth - ShiftAmt);\n        Known.One =\n            Known2.One.shl(ShiftAmt) | Known3.One.lshr(BitWidth - ShiftAmt);\n        break;\n      }\n      case Intrinsic::uadd_sat:\n      case Intrinsic::usub_sat: {\n        bool IsAdd = II->getIntrinsicID() == Intrinsic::uadd_sat;\n        computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n        computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n\n        // Add: Leading ones of either operand are preserved.\n        // Sub: Leading zeros of LHS and leading ones of RHS are preserved\n        // as leading zeros in the result.\n        unsigned LeadingKnown;\n        if (IsAdd)\n          LeadingKnown = std::max(Known.countMinLeadingOnes(),\n                                  Known2.countMinLeadingOnes());\n        else\n          LeadingKnown = std::max(Known.countMinLeadingZeros(),\n                                  Known2.countMinLeadingOnes());\n\n        Known = KnownBits::computeForAddSub(\n            IsAdd, /* NSW */ false, Known, Known2);\n\n        // We select between the operation result and all-ones/zero\n        // respectively, so we can preserve known ones/zeros.\n        if (IsAdd) {\n          Known.One.setHighBits(LeadingKnown);\n          Known.Zero.clearAllBits();\n        } else {\n          Known.Zero.setHighBits(LeadingKnown);\n          Known.One.clearAllBits();\n        }\n        break;\n      }\n      case Intrinsic::umin:\n        computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n        computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n        Known = KnownBits::umin(Known, Known2);\n        break;\n      case Intrinsic::umax:\n        computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n        computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n        Known = KnownBits::umax(Known, Known2);\n        break;\n      case Intrinsic::smin:\n        computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n        computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n        Known = KnownBits::smin(Known, Known2);\n        break;\n      case Intrinsic::smax:\n        computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n        computeKnownBits(I->getOperand(1), Known2, Depth + 1, Q);\n        Known = KnownBits::smax(Known, Known2);\n        break;\n      case Intrinsic::x86_sse42_crc32_64_64:\n        Known.Zero.setBitsFrom(32);\n        break;\n      }\n    }\n    break;\n  case Instruction::ShuffleVector: {\n    auto *Shuf = dyn_cast<ShuffleVectorInst>(I);\n    // FIXME: Do we need to handle ConstantExpr involving shufflevectors?\n    if (!Shuf) {\n      Known.resetAll();\n      return;\n    }\n    // For undef elements, we don't know anything about the common state of\n    // the shuffle result.\n    APInt DemandedLHS, DemandedRHS;\n    if (!getShuffleDemandedElts(Shuf, DemandedElts, DemandedLHS, DemandedRHS)) {\n      Known.resetAll();\n      return;\n    }\n    Known.One.setAllBits();\n    Known.Zero.setAllBits();\n    if (!!DemandedLHS) {\n      const Value *LHS = Shuf->getOperand(0);\n      computeKnownBits(LHS, DemandedLHS, Known, Depth + 1, Q);\n      // If we don't know any bits, early out.\n      if (Known.isUnknown())\n        break;\n    }\n    if (!!DemandedRHS) {\n      const Value *RHS = Shuf->getOperand(1);\n      computeKnownBits(RHS, DemandedRHS, Known2, Depth + 1, Q);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case Instruction::InsertElement: {\n    const Value *Vec = I->getOperand(0);\n    const Value *Elt = I->getOperand(1);\n    auto *CIdx = dyn_cast<ConstantInt>(I->getOperand(2));\n    // Early out if the index is non-constant or out-of-range.\n    unsigned NumElts = DemandedElts.getBitWidth();\n    if (!CIdx || CIdx->getValue().uge(NumElts)) {\n      Known.resetAll();\n      return;\n    }\n    Known.One.setAllBits();\n    Known.Zero.setAllBits();\n    unsigned EltIdx = CIdx->getZExtValue();\n    // Do we demand the inserted element?\n    if (DemandedElts[EltIdx]) {\n      computeKnownBits(Elt, Known, Depth + 1, Q);\n      // If we don't know any bits, early out.\n      if (Known.isUnknown())\n        break;\n    }\n    // We don't need the base vector element that has been inserted.\n    APInt DemandedVecElts = DemandedElts;\n    DemandedVecElts.clearBit(EltIdx);\n    if (!!DemandedVecElts) {\n      computeKnownBits(Vec, DemandedVecElts, Known2, Depth + 1, Q);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case Instruction::ExtractElement: {\n    // Look through extract element. If the index is non-constant or\n    // out-of-range demand all elements, otherwise just the extracted element.\n    const Value *Vec = I->getOperand(0);\n    const Value *Idx = I->getOperand(1);\n    auto *CIdx = dyn_cast<ConstantInt>(Idx);\n    if (isa<ScalableVectorType>(Vec->getType())) {\n      // FIXME: there's probably *something* we can do with scalable vectors\n      Known.resetAll();\n      break;\n    }\n    unsigned NumElts = cast<FixedVectorType>(Vec->getType())->getNumElements();\n    APInt DemandedVecElts = APInt::getAllOnesValue(NumElts);\n    if (CIdx && CIdx->getValue().ult(NumElts))\n      DemandedVecElts = APInt::getOneBitSet(NumElts, CIdx->getZExtValue());\n    computeKnownBits(Vec, DemandedVecElts, Known, Depth + 1, Q);\n    break;\n  }\n  case Instruction::ExtractValue:\n    if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I->getOperand(0))) {\n      const ExtractValueInst *EVI = cast<ExtractValueInst>(I);\n      if (EVI->getNumIndices() != 1) break;\n      if (EVI->getIndices()[0] == 0) {\n        switch (II->getIntrinsicID()) {\n        default: break;\n        case Intrinsic::uadd_with_overflow:\n        case Intrinsic::sadd_with_overflow:\n          computeKnownBitsAddSub(true, II->getArgOperand(0),\n                                 II->getArgOperand(1), false, DemandedElts,\n                                 Known, Known2, Depth, Q);\n          break;\n        case Intrinsic::usub_with_overflow:\n        case Intrinsic::ssub_with_overflow:\n          computeKnownBitsAddSub(false, II->getArgOperand(0),\n                                 II->getArgOperand(1), false, DemandedElts,\n                                 Known, Known2, Depth, Q);\n          break;\n        case Intrinsic::umul_with_overflow:\n        case Intrinsic::smul_with_overflow:\n          computeKnownBitsMul(II->getArgOperand(0), II->getArgOperand(1), false,\n                              DemandedElts, Known, Known2, Depth, Q);\n          break;\n        }\n      }\n    }\n    break;\n  case Instruction::Freeze:\n    if (isGuaranteedNotToBePoison(I->getOperand(0), Q.AC, Q.CxtI, Q.DT,\n                                  Depth + 1))\n      computeKnownBits(I->getOperand(0), Known, Depth + 1, Q);\n    break;\n  }\n}\n\n/// Determine which bits of V are known to be either zero or one and return\n/// them.\nKnownBits computeKnownBits(const Value *V, const APInt &DemandedElts,\n                           unsigned Depth, const Query &Q) {\n  KnownBits Known(getBitWidth(V->getType(), Q.DL));\n  computeKnownBits(V, DemandedElts, Known, Depth, Q);\n  return Known;\n}\n\n/// Determine which bits of V are known to be either zero or one and return\n/// them.\nKnownBits computeKnownBits(const Value *V, unsigned Depth, const Query &Q) {\n  KnownBits Known(getBitWidth(V->getType(), Q.DL));\n  computeKnownBits(V, Known, Depth, Q);\n  return Known;\n}\n\n/// Determine which bits of V are known to be either zero or one and return\n/// them in the Known bit set.\n///\n/// NOTE: we cannot consider 'undef' to be \"IsZero\" here.  The problem is that\n/// we cannot optimize based on the assumption that it is zero without changing\n/// it to be an explicit zero.  If we don't change it to zero, other code could\n/// optimized based on the contradictory assumption that it is non-zero.\n/// Because instcombine aggressively folds operations with undef args anyway,\n/// this won't lose us code quality.\n///\n/// This function is defined on values with integer type, values with pointer\n/// type, and vectors of integers.  In the case\n/// where V is a vector, known zero, and known one values are the\n/// same width as the vector element, and the bit is set only if it is true\n/// for all of the demanded elements in the vector specified by DemandedElts.\nvoid computeKnownBits(const Value *V, const APInt &DemandedElts,\n                      KnownBits &Known, unsigned Depth, const Query &Q) {\n  if (!DemandedElts || isa<ScalableVectorType>(V->getType())) {\n    // No demanded elts or V is a scalable vector, better to assume we don't\n    // know anything.\n    Known.resetAll();\n    return;\n  }\n\n  assert(V && \"No Value?\");\n  assert(Depth <= MaxAnalysisRecursionDepth && \"Limit Search Depth\");\n\n#ifndef NDEBUG\n  Type *Ty = V->getType();\n  unsigned BitWidth = Known.getBitWidth();\n\n  assert((Ty->isIntOrIntVectorTy(BitWidth) || Ty->isPtrOrPtrVectorTy()) &&\n         \"Not integer or pointer type!\");\n\n  if (auto *FVTy = dyn_cast<FixedVectorType>(Ty)) {\n    assert(\n        FVTy->getNumElements() == DemandedElts.getBitWidth() &&\n        \"DemandedElt width should equal the fixed vector number of elements\");\n  } else {\n    assert(DemandedElts == APInt(1, 1) &&\n           \"DemandedElt width should be 1 for scalars\");\n  }\n\n  Type *ScalarTy = Ty->getScalarType();\n  if (ScalarTy->isPointerTy()) {\n    assert(BitWidth == Q.DL.getPointerTypeSizeInBits(ScalarTy) &&\n           \"V and Known should have same BitWidth\");\n  } else {\n    assert(BitWidth == Q.DL.getTypeSizeInBits(ScalarTy) &&\n           \"V and Known should have same BitWidth\");\n  }\n#endif\n\n  const APInt *C;\n  if (match(V, m_APInt(C))) {\n    // We know all of the bits for a scalar constant or a splat vector constant!\n    Known = KnownBits::makeConstant(*C);\n    return;\n  }\n  // Null and aggregate-zero are all-zeros.\n  if (isa<ConstantPointerNull>(V) || isa<ConstantAggregateZero>(V)) {\n    Known.setAllZero();\n    return;\n  }\n  // Handle a constant vector by taking the intersection of the known bits of\n  // each element.\n  if (const ConstantDataVector *CDV = dyn_cast<ConstantDataVector>(V)) {\n    // We know that CDV must be a vector of integers. Take the intersection of\n    // each element.\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    for (unsigned i = 0, e = CDV->getNumElements(); i != e; ++i) {\n      if (!DemandedElts[i])\n        continue;\n      APInt Elt = CDV->getElementAsAPInt(i);\n      Known.Zero &= ~Elt;\n      Known.One &= Elt;\n    }\n    return;\n  }\n\n  if (const auto *CV = dyn_cast<ConstantVector>(V)) {\n    // We know that CV must be a vector of integers. Take the intersection of\n    // each element.\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    for (unsigned i = 0, e = CV->getNumOperands(); i != e; ++i) {\n      if (!DemandedElts[i])\n        continue;\n      Constant *Element = CV->getAggregateElement(i);\n      auto *ElementCI = dyn_cast_or_null<ConstantInt>(Element);\n      if (!ElementCI) {\n        Known.resetAll();\n        return;\n      }\n      const APInt &Elt = ElementCI->getValue();\n      Known.Zero &= ~Elt;\n      Known.One &= Elt;\n    }\n    return;\n  }\n\n  // Start out not knowing anything.\n  Known.resetAll();\n\n  // We can't imply anything about undefs.\n  if (isa<UndefValue>(V))\n    return;\n\n  // There's no point in looking through other users of ConstantData for\n  // assumptions.  Confirm that we've handled them all.\n  assert(!isa<ConstantData>(V) && \"Unhandled constant data!\");\n\n  // All recursive calls that increase depth must come after this.\n  if (Depth == MaxAnalysisRecursionDepth)\n    return;\n\n  // A weak GlobalAlias is totally unknown. A non-weak GlobalAlias has\n  // the bits of its aliasee.\n  if (const GlobalAlias *GA = dyn_cast<GlobalAlias>(V)) {\n    if (!GA->isInterposable())\n      computeKnownBits(GA->getAliasee(), Known, Depth + 1, Q);\n    return;\n  }\n\n  if (const Operator *I = dyn_cast<Operator>(V))\n    computeKnownBitsFromOperator(I, DemandedElts, Known, Depth, Q);\n\n  // Aligned pointers have trailing zeros - refine Known.Zero set\n  if (isa<PointerType>(V->getType())) {\n    Align Alignment = V->getPointerAlignment(Q.DL);\n    Known.Zero.setLowBits(Log2(Alignment));\n  }\n\n  // computeKnownBitsFromAssume strictly refines Known.\n  // Therefore, we run them after computeKnownBitsFromOperator.\n\n  // Check whether a nearby assume intrinsic can determine some known bits.\n  computeKnownBitsFromAssume(V, Known, Depth, Q);\n\n  assert((Known.Zero & Known.One) == 0 && \"Bits known to be one AND zero?\");\n}\n\n/// Return true if the given value is known to have exactly one\n/// bit set when defined. For vectors return true if every element is known to\n/// be a power of two when defined. Supports values with integer or pointer\n/// types and vectors of integers.\nbool isKnownToBeAPowerOfTwo(const Value *V, bool OrZero, unsigned Depth,\n                            const Query &Q) {\n  assert(Depth <= MaxAnalysisRecursionDepth && \"Limit Search Depth\");\n\n  // Attempt to match against constants.\n  if (OrZero && match(V, m_Power2OrZero()))\n      return true;\n  if (match(V, m_Power2()))\n      return true;\n\n  // 1 << X is clearly a power of two if the one is not shifted off the end.  If\n  // it is shifted off the end then the result is undefined.\n  if (match(V, m_Shl(m_One(), m_Value())))\n    return true;\n\n  // (signmask) >>l X is clearly a power of two if the one is not shifted off\n  // the bottom.  If it is shifted off the bottom then the result is undefined.\n  if (match(V, m_LShr(m_SignMask(), m_Value())))\n    return true;\n\n  // The remaining tests are all recursive, so bail out if we hit the limit.\n  if (Depth++ == MaxAnalysisRecursionDepth)\n    return false;\n\n  Value *X = nullptr, *Y = nullptr;\n  // A shift left or a logical shift right of a power of two is a power of two\n  // or zero.\n  if (OrZero && (match(V, m_Shl(m_Value(X), m_Value())) ||\n                 match(V, m_LShr(m_Value(X), m_Value()))))\n    return isKnownToBeAPowerOfTwo(X, /*OrZero*/ true, Depth, Q);\n\n  if (const ZExtInst *ZI = dyn_cast<ZExtInst>(V))\n    return isKnownToBeAPowerOfTwo(ZI->getOperand(0), OrZero, Depth, Q);\n\n  if (const SelectInst *SI = dyn_cast<SelectInst>(V))\n    return isKnownToBeAPowerOfTwo(SI->getTrueValue(), OrZero, Depth, Q) &&\n           isKnownToBeAPowerOfTwo(SI->getFalseValue(), OrZero, Depth, Q);\n\n  if (OrZero && match(V, m_And(m_Value(X), m_Value(Y)))) {\n    // A power of two and'd with anything is a power of two or zero.\n    if (isKnownToBeAPowerOfTwo(X, /*OrZero*/ true, Depth, Q) ||\n        isKnownToBeAPowerOfTwo(Y, /*OrZero*/ true, Depth, Q))\n      return true;\n    // X & (-X) is always a power of two or zero.\n    if (match(X, m_Neg(m_Specific(Y))) || match(Y, m_Neg(m_Specific(X))))\n      return true;\n    return false;\n  }\n\n  // Adding a power-of-two or zero to the same power-of-two or zero yields\n  // either the original power-of-two, a larger power-of-two or zero.\n  if (match(V, m_Add(m_Value(X), m_Value(Y)))) {\n    const OverflowingBinaryOperator *VOBO = cast<OverflowingBinaryOperator>(V);\n    if (OrZero || Q.IIQ.hasNoUnsignedWrap(VOBO) ||\n        Q.IIQ.hasNoSignedWrap(VOBO)) {\n      if (match(X, m_And(m_Specific(Y), m_Value())) ||\n          match(X, m_And(m_Value(), m_Specific(Y))))\n        if (isKnownToBeAPowerOfTwo(Y, OrZero, Depth, Q))\n          return true;\n      if (match(Y, m_And(m_Specific(X), m_Value())) ||\n          match(Y, m_And(m_Value(), m_Specific(X))))\n        if (isKnownToBeAPowerOfTwo(X, OrZero, Depth, Q))\n          return true;\n\n      unsigned BitWidth = V->getType()->getScalarSizeInBits();\n      KnownBits LHSBits(BitWidth);\n      computeKnownBits(X, LHSBits, Depth, Q);\n\n      KnownBits RHSBits(BitWidth);\n      computeKnownBits(Y, RHSBits, Depth, Q);\n      // If i8 V is a power of two or zero:\n      //  ZeroBits: 1 1 1 0 1 1 1 1\n      // ~ZeroBits: 0 0 0 1 0 0 0 0\n      if ((~(LHSBits.Zero & RHSBits.Zero)).isPowerOf2())\n        // If OrZero isn't set, we cannot give back a zero result.\n        // Make sure either the LHS or RHS has a bit set.\n        if (OrZero || RHSBits.One.getBoolValue() || LHSBits.One.getBoolValue())\n          return true;\n    }\n  }\n\n  // An exact divide or right shift can only shift off zero bits, so the result\n  // is a power of two only if the first operand is a power of two and not\n  // copying a sign bit (sdiv int_min, 2).\n  if (match(V, m_Exact(m_LShr(m_Value(), m_Value()))) ||\n      match(V, m_Exact(m_UDiv(m_Value(), m_Value())))) {\n    return isKnownToBeAPowerOfTwo(cast<Operator>(V)->getOperand(0), OrZero,\n                                  Depth, Q);\n  }\n\n  return false;\n}\n\n/// Test whether a GEP's result is known to be non-null.\n///\n/// Uses properties inherent in a GEP to try to determine whether it is known\n/// to be non-null.\n///\n/// Currently this routine does not support vector GEPs.\nstatic bool isGEPKnownNonNull(const GEPOperator *GEP, unsigned Depth,\n                              const Query &Q) {\n  const Function *F = nullptr;\n  if (const Instruction *I = dyn_cast<Instruction>(GEP))\n    F = I->getFunction();\n\n  if (!GEP->isInBounds() ||\n      NullPointerIsDefined(F, GEP->getPointerAddressSpace()))\n    return false;\n\n  // FIXME: Support vector-GEPs.\n  assert(GEP->getType()->isPointerTy() && \"We only support plain pointer GEP\");\n\n  // If the base pointer is non-null, we cannot walk to a null address with an\n  // inbounds GEP in address space zero.\n  if (isKnownNonZero(GEP->getPointerOperand(), Depth, Q))\n    return true;\n\n  // Walk the GEP operands and see if any operand introduces a non-zero offset.\n  // If so, then the GEP cannot produce a null pointer, as doing so would\n  // inherently violate the inbounds contract within address space zero.\n  for (gep_type_iterator GTI = gep_type_begin(GEP), GTE = gep_type_end(GEP);\n       GTI != GTE; ++GTI) {\n    // Struct types are easy -- they must always be indexed by a constant.\n    if (StructType *STy = GTI.getStructTypeOrNull()) {\n      ConstantInt *OpC = cast<ConstantInt>(GTI.getOperand());\n      unsigned ElementIdx = OpC->getZExtValue();\n      const StructLayout *SL = Q.DL.getStructLayout(STy);\n      uint64_t ElementOffset = SL->getElementOffset(ElementIdx);\n      if (ElementOffset > 0)\n        return true;\n      continue;\n    }\n\n    // If we have a zero-sized type, the index doesn't matter. Keep looping.\n    if (Q.DL.getTypeAllocSize(GTI.getIndexedType()).getKnownMinSize() == 0)\n      continue;\n\n    // Fast path the constant operand case both for efficiency and so we don't\n    // increment Depth when just zipping down an all-constant GEP.\n    if (ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand())) {\n      if (!OpC->isZero())\n        return true;\n      continue;\n    }\n\n    // We post-increment Depth here because while isKnownNonZero increments it\n    // as well, when we pop back up that increment won't persist. We don't want\n    // to recurse 10k times just because we have 10k GEP operands. We don't\n    // bail completely out because we want to handle constant GEPs regardless\n    // of depth.\n    if (Depth++ >= MaxAnalysisRecursionDepth)\n      continue;\n\n    if (isKnownNonZero(GTI.getOperand(), Depth, Q))\n      return true;\n  }\n\n  return false;\n}\n\nstatic bool isKnownNonNullFromDominatingCondition(const Value *V,\n                                                  const Instruction *CtxI,\n                                                  const DominatorTree *DT) {\n  if (isa<Constant>(V))\n    return false;\n\n  if (!CtxI || !DT)\n    return false;\n\n  unsigned NumUsesExplored = 0;\n  for (auto *U : V->users()) {\n    // Avoid massive lists\n    if (NumUsesExplored >= DomConditionsMaxUses)\n      break;\n    NumUsesExplored++;\n\n    // If the value is used as an argument to a call or invoke, then argument\n    // attributes may provide an answer about null-ness.\n    if (const auto *CB = dyn_cast<CallBase>(U))\n      if (auto *CalledFunc = CB->getCalledFunction())\n        for (const Argument &Arg : CalledFunc->args())\n          if (CB->getArgOperand(Arg.getArgNo()) == V &&\n              Arg.hasNonNullAttr(/* AllowUndefOrPoison */ false) &&\n              DT->dominates(CB, CtxI))\n            return true;\n\n    // If the value is used as a load/store, then the pointer must be non null.\n    if (V == getLoadStorePointerOperand(U)) {\n      const Instruction *I = cast<Instruction>(U);\n      if (!NullPointerIsDefined(I->getFunction(),\n                                V->getType()->getPointerAddressSpace()) &&\n          DT->dominates(I, CtxI))\n        return true;\n    }\n\n    // Consider only compare instructions uniquely controlling a branch\n    Value *RHS;\n    CmpInst::Predicate Pred;\n    if (!match(U, m_c_ICmp(Pred, m_Specific(V), m_Value(RHS))))\n      continue;\n\n    bool NonNullIfTrue;\n    if (cmpExcludesZero(Pred, RHS))\n      NonNullIfTrue = true;\n    else if (cmpExcludesZero(CmpInst::getInversePredicate(Pred), RHS))\n      NonNullIfTrue = false;\n    else\n      continue;\n\n    SmallVector<const User *, 4> WorkList;\n    SmallPtrSet<const User *, 4> Visited;\n    for (auto *CmpU : U->users()) {\n      assert(WorkList.empty() && \"Should be!\");\n      if (Visited.insert(CmpU).second)\n        WorkList.push_back(CmpU);\n\n      while (!WorkList.empty()) {\n        auto *Curr = WorkList.pop_back_val();\n\n        // If a user is an AND, add all its users to the work list. We only\n        // propagate \"pred != null\" condition through AND because it is only\n        // correct to assume that all conditions of AND are met in true branch.\n        // TODO: Support similar logic of OR and EQ predicate?\n        if (NonNullIfTrue)\n          if (match(Curr, m_LogicalAnd(m_Value(), m_Value()))) {\n            for (auto *CurrU : Curr->users())\n              if (Visited.insert(CurrU).second)\n                WorkList.push_back(CurrU);\n            continue;\n          }\n\n        if (const BranchInst *BI = dyn_cast<BranchInst>(Curr)) {\n          assert(BI->isConditional() && \"uses a comparison!\");\n\n          BasicBlock *NonNullSuccessor =\n              BI->getSuccessor(NonNullIfTrue ? 0 : 1);\n          BasicBlockEdge Edge(BI->getParent(), NonNullSuccessor);\n          if (Edge.isSingleEdge() && DT->dominates(Edge, CtxI->getParent()))\n            return true;\n        } else if (NonNullIfTrue && isGuard(Curr) &&\n                   DT->dominates(cast<Instruction>(Curr), CtxI)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/// Does the 'Range' metadata (which must be a valid MD_range operand list)\n/// ensure that the value it's attached to is never Value?  'RangeType' is\n/// is the type of the value described by the range.\nstatic bool rangeMetadataExcludesValue(const MDNode* Ranges, const APInt& Value) {\n  const unsigned NumRanges = Ranges->getNumOperands() / 2;\n  assert(NumRanges >= 1);\n  for (unsigned i = 0; i < NumRanges; ++i) {\n    ConstantInt *Lower =\n        mdconst::extract<ConstantInt>(Ranges->getOperand(2 * i + 0));\n    ConstantInt *Upper =\n        mdconst::extract<ConstantInt>(Ranges->getOperand(2 * i + 1));\n    ConstantRange Range(Lower->getValue(), Upper->getValue());\n    if (Range.contains(Value))\n      return false;\n  }\n  return true;\n}\n\n/// Return true if the given value is known to be non-zero when defined. For\n/// vectors, return true if every demanded element is known to be non-zero when\n/// defined. For pointers, if the context instruction and dominator tree are\n/// specified, perform context-sensitive analysis and return true if the\n/// pointer couldn't possibly be null at the specified instruction.\n/// Supports values with integer or pointer type and vectors of integers.\nbool isKnownNonZero(const Value *V, const APInt &DemandedElts, unsigned Depth,\n                    const Query &Q) {\n  // FIXME: We currently have no way to represent the DemandedElts of a scalable\n  // vector\n  if (isa<ScalableVectorType>(V->getType()))\n    return false;\n\n  if (auto *C = dyn_cast<Constant>(V)) {\n    if (C->isNullValue())\n      return false;\n    if (isa<ConstantInt>(C))\n      // Must be non-zero due to null test above.\n      return true;\n\n    if (auto *CE = dyn_cast<ConstantExpr>(C)) {\n      // See the comment for IntToPtr/PtrToInt instructions below.\n      if (CE->getOpcode() == Instruction::IntToPtr ||\n          CE->getOpcode() == Instruction::PtrToInt)\n        if (Q.DL.getTypeSizeInBits(CE->getOperand(0)->getType())\n                .getFixedSize() <=\n            Q.DL.getTypeSizeInBits(CE->getType()).getFixedSize())\n          return isKnownNonZero(CE->getOperand(0), Depth, Q);\n    }\n\n    // For constant vectors, check that all elements are undefined or known\n    // non-zero to determine that the whole vector is known non-zero.\n    if (auto *VecTy = dyn_cast<FixedVectorType>(C->getType())) {\n      for (unsigned i = 0, e = VecTy->getNumElements(); i != e; ++i) {\n        if (!DemandedElts[i])\n          continue;\n        Constant *Elt = C->getAggregateElement(i);\n        if (!Elt || Elt->isNullValue())\n          return false;\n        if (!isa<UndefValue>(Elt) && !isa<ConstantInt>(Elt))\n          return false;\n      }\n      return true;\n    }\n\n    // A global variable in address space 0 is non null unless extern weak\n    // or an absolute symbol reference. Other address spaces may have null as a\n    // valid address for a global, so we can't assume anything.\n    if (const GlobalValue *GV = dyn_cast<GlobalValue>(V)) {\n      if (!GV->isAbsoluteSymbolRef() && !GV->hasExternalWeakLinkage() &&\n          GV->getType()->getAddressSpace() == 0)\n        return true;\n    } else\n      return false;\n  }\n\n  if (auto *I = dyn_cast<Instruction>(V)) {\n    if (MDNode *Ranges = Q.IIQ.getMetadata(I, LLVMContext::MD_range)) {\n      // If the possible ranges don't contain zero, then the value is\n      // definitely non-zero.\n      if (auto *Ty = dyn_cast<IntegerType>(V->getType())) {\n        const APInt ZeroValue(Ty->getBitWidth(), 0);\n        if (rangeMetadataExcludesValue(Ranges, ZeroValue))\n          return true;\n      }\n    }\n  }\n\n  if (isKnownNonZeroFromAssume(V, Q))\n    return true;\n\n  // Some of the tests below are recursive, so bail out if we hit the limit.\n  if (Depth++ >= MaxAnalysisRecursionDepth)\n    return false;\n\n  // Check for pointer simplifications.\n\n  if (PointerType *PtrTy = dyn_cast<PointerType>(V->getType())) {\n    // Alloca never returns null, malloc might.\n    if (isa<AllocaInst>(V) && Q.DL.getAllocaAddrSpace() == 0)\n      return true;\n\n    // A byval, inalloca may not be null in a non-default addres space. A\n    // nonnull argument is assumed never 0.\n    if (const Argument *A = dyn_cast<Argument>(V)) {\n      if (((A->hasPassPointeeByValueCopyAttr() &&\n            !NullPointerIsDefined(A->getParent(), PtrTy->getAddressSpace())) ||\n           A->hasNonNullAttr()))\n        return true;\n    }\n\n    // A Load tagged with nonnull metadata is never null.\n    if (const LoadInst *LI = dyn_cast<LoadInst>(V))\n      if (Q.IIQ.getMetadata(LI, LLVMContext::MD_nonnull))\n        return true;\n\n    if (const auto *Call = dyn_cast<CallBase>(V)) {\n      if (Call->isReturnNonNull())\n        return true;\n      if (const auto *RP = getArgumentAliasingToReturnedPointer(Call, true))\n        return isKnownNonZero(RP, Depth, Q);\n    }\n  }\n\n  if (isKnownNonNullFromDominatingCondition(V, Q.CxtI, Q.DT))\n    return true;\n\n  // Check for recursive pointer simplifications.\n  if (V->getType()->isPointerTy()) {\n    // Look through bitcast operations, GEPs, and int2ptr instructions as they\n    // do not alter the value, or at least not the nullness property of the\n    // value, e.g., int2ptr is allowed to zero/sign extend the value.\n    //\n    // Note that we have to take special care to avoid looking through\n    // truncating casts, e.g., int2ptr/ptr2int with appropriate sizes, as well\n    // as casts that can alter the value, e.g., AddrSpaceCasts.\n    if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V))\n      return isGEPKnownNonNull(GEP, Depth, Q);\n\n    if (auto *BCO = dyn_cast<BitCastOperator>(V))\n      return isKnownNonZero(BCO->getOperand(0), Depth, Q);\n\n    if (auto *I2P = dyn_cast<IntToPtrInst>(V))\n      if (Q.DL.getTypeSizeInBits(I2P->getSrcTy()).getFixedSize() <=\n          Q.DL.getTypeSizeInBits(I2P->getDestTy()).getFixedSize())\n        return isKnownNonZero(I2P->getOperand(0), Depth, Q);\n  }\n\n  // Similar to int2ptr above, we can look through ptr2int here if the cast\n  // is a no-op or an extend and not a truncate.\n  if (auto *P2I = dyn_cast<PtrToIntInst>(V))\n    if (Q.DL.getTypeSizeInBits(P2I->getSrcTy()).getFixedSize() <=\n        Q.DL.getTypeSizeInBits(P2I->getDestTy()).getFixedSize())\n      return isKnownNonZero(P2I->getOperand(0), Depth, Q);\n\n  unsigned BitWidth = getBitWidth(V->getType()->getScalarType(), Q.DL);\n\n  // X | Y != 0 if X != 0 or Y != 0.\n  Value *X = nullptr, *Y = nullptr;\n  if (match(V, m_Or(m_Value(X), m_Value(Y))))\n    return isKnownNonZero(X, DemandedElts, Depth, Q) ||\n           isKnownNonZero(Y, DemandedElts, Depth, Q);\n\n  // ext X != 0 if X != 0.\n  if (isa<SExtInst>(V) || isa<ZExtInst>(V))\n    return isKnownNonZero(cast<Instruction>(V)->getOperand(0), Depth, Q);\n\n  // shl X, Y != 0 if X is odd.  Note that the value of the shift is undefined\n  // if the lowest bit is shifted off the end.\n  if (match(V, m_Shl(m_Value(X), m_Value(Y)))) {\n    // shl nuw can't remove any non-zero bits.\n    const OverflowingBinaryOperator *BO = cast<OverflowingBinaryOperator>(V);\n    if (Q.IIQ.hasNoUnsignedWrap(BO))\n      return isKnownNonZero(X, Depth, Q);\n\n    KnownBits Known(BitWidth);\n    computeKnownBits(X, DemandedElts, Known, Depth, Q);\n    if (Known.One[0])\n      return true;\n  }\n  // shr X, Y != 0 if X is negative.  Note that the value of the shift is not\n  // defined if the sign bit is shifted off the end.\n  else if (match(V, m_Shr(m_Value(X), m_Value(Y)))) {\n    // shr exact can only shift out zero bits.\n    const PossiblyExactOperator *BO = cast<PossiblyExactOperator>(V);\n    if (BO->isExact())\n      return isKnownNonZero(X, Depth, Q);\n\n    KnownBits Known = computeKnownBits(X, DemandedElts, Depth, Q);\n    if (Known.isNegative())\n      return true;\n\n    // If the shifter operand is a constant, and all of the bits shifted\n    // out are known to be zero, and X is known non-zero then at least one\n    // non-zero bit must remain.\n    if (ConstantInt *Shift = dyn_cast<ConstantInt>(Y)) {\n      auto ShiftVal = Shift->getLimitedValue(BitWidth - 1);\n      // Is there a known one in the portion not shifted out?\n      if (Known.countMaxLeadingZeros() < BitWidth - ShiftVal)\n        return true;\n      // Are all the bits to be shifted out known zero?\n      if (Known.countMinTrailingZeros() >= ShiftVal)\n        return isKnownNonZero(X, DemandedElts, Depth, Q);\n    }\n  }\n  // div exact can only produce a zero if the dividend is zero.\n  else if (match(V, m_Exact(m_IDiv(m_Value(X), m_Value())))) {\n    return isKnownNonZero(X, DemandedElts, Depth, Q);\n  }\n  // X + Y.\n  else if (match(V, m_Add(m_Value(X), m_Value(Y)))) {\n    KnownBits XKnown = computeKnownBits(X, DemandedElts, Depth, Q);\n    KnownBits YKnown = computeKnownBits(Y, DemandedElts, Depth, Q);\n\n    // If X and Y are both non-negative (as signed values) then their sum is not\n    // zero unless both X and Y are zero.\n    if (XKnown.isNonNegative() && YKnown.isNonNegative())\n      if (isKnownNonZero(X, DemandedElts, Depth, Q) ||\n          isKnownNonZero(Y, DemandedElts, Depth, Q))\n        return true;\n\n    // If X and Y are both negative (as signed values) then their sum is not\n    // zero unless both X and Y equal INT_MIN.\n    if (XKnown.isNegative() && YKnown.isNegative()) {\n      APInt Mask = APInt::getSignedMaxValue(BitWidth);\n      // The sign bit of X is set.  If some other bit is set then X is not equal\n      // to INT_MIN.\n      if (XKnown.One.intersects(Mask))\n        return true;\n      // The sign bit of Y is set.  If some other bit is set then Y is not equal\n      // to INT_MIN.\n      if (YKnown.One.intersects(Mask))\n        return true;\n    }\n\n    // The sum of a non-negative number and a power of two is not zero.\n    if (XKnown.isNonNegative() &&\n        isKnownToBeAPowerOfTwo(Y, /*OrZero*/ false, Depth, Q))\n      return true;\n    if (YKnown.isNonNegative() &&\n        isKnownToBeAPowerOfTwo(X, /*OrZero*/ false, Depth, Q))\n      return true;\n  }\n  // X * Y.\n  else if (match(V, m_Mul(m_Value(X), m_Value(Y)))) {\n    const OverflowingBinaryOperator *BO = cast<OverflowingBinaryOperator>(V);\n    // If X and Y are non-zero then so is X * Y as long as the multiplication\n    // does not overflow.\n    if ((Q.IIQ.hasNoSignedWrap(BO) || Q.IIQ.hasNoUnsignedWrap(BO)) &&\n        isKnownNonZero(X, DemandedElts, Depth, Q) &&\n        isKnownNonZero(Y, DemandedElts, Depth, Q))\n      return true;\n  }\n  // (C ? X : Y) != 0 if X != 0 and Y != 0.\n  else if (const SelectInst *SI = dyn_cast<SelectInst>(V)) {\n    if (isKnownNonZero(SI->getTrueValue(), DemandedElts, Depth, Q) &&\n        isKnownNonZero(SI->getFalseValue(), DemandedElts, Depth, Q))\n      return true;\n  }\n  // PHI\n  else if (const PHINode *PN = dyn_cast<PHINode>(V)) {\n    // Try and detect a recurrence that monotonically increases from a\n    // starting value, as these are common as induction variables.\n    if (PN->getNumIncomingValues() == 2) {\n      Value *Start = PN->getIncomingValue(0);\n      Value *Induction = PN->getIncomingValue(1);\n      if (isa<ConstantInt>(Induction) && !isa<ConstantInt>(Start))\n        std::swap(Start, Induction);\n      if (ConstantInt *C = dyn_cast<ConstantInt>(Start)) {\n        if (!C->isZero() && !C->isNegative()) {\n          ConstantInt *X;\n          if (Q.IIQ.UseInstrInfo &&\n              (match(Induction, m_NSWAdd(m_Specific(PN), m_ConstantInt(X))) ||\n               match(Induction, m_NUWAdd(m_Specific(PN), m_ConstantInt(X)))) &&\n              !X->isNegative())\n            return true;\n        }\n      }\n    }\n    // Check if all incoming values are non-zero using recursion.\n    Query RecQ = Q;\n    unsigned NewDepth = std::max(Depth, MaxAnalysisRecursionDepth - 1);\n    return llvm::all_of(PN->operands(), [&](const Use &U) {\n      if (U.get() == PN)\n        return true;\n      RecQ.CxtI = PN->getIncomingBlock(U)->getTerminator();\n      return isKnownNonZero(U.get(), DemandedElts, NewDepth, RecQ);\n    });\n  }\n  // ExtractElement\n  else if (const auto *EEI = dyn_cast<ExtractElementInst>(V)) {\n    const Value *Vec = EEI->getVectorOperand();\n    const Value *Idx = EEI->getIndexOperand();\n    auto *CIdx = dyn_cast<ConstantInt>(Idx);\n    if (auto *VecTy = dyn_cast<FixedVectorType>(Vec->getType())) {\n      unsigned NumElts = VecTy->getNumElements();\n      APInt DemandedVecElts = APInt::getAllOnesValue(NumElts);\n      if (CIdx && CIdx->getValue().ult(NumElts))\n        DemandedVecElts = APInt::getOneBitSet(NumElts, CIdx->getZExtValue());\n      return isKnownNonZero(Vec, DemandedVecElts, Depth, Q);\n    }\n  }\n  // Freeze\n  else if (const FreezeInst *FI = dyn_cast<FreezeInst>(V)) {\n    auto *Op = FI->getOperand(0);\n    if (isKnownNonZero(Op, Depth, Q) &&\n        isGuaranteedNotToBePoison(Op, Q.AC, Q.CxtI, Q.DT, Depth))\n      return true;\n  }\n\n  KnownBits Known(BitWidth);\n  computeKnownBits(V, DemandedElts, Known, Depth, Q);\n  return Known.One != 0;\n}\n\nbool isKnownNonZero(const Value* V, unsigned Depth, const Query& Q) {\n  // FIXME: We currently have no way to represent the DemandedElts of a scalable\n  // vector\n  if (isa<ScalableVectorType>(V->getType()))\n    return false;\n\n  auto *FVTy = dyn_cast<FixedVectorType>(V->getType());\n  APInt DemandedElts =\n      FVTy ? APInt::getAllOnesValue(FVTy->getNumElements()) : APInt(1, 1);\n  return isKnownNonZero(V, DemandedElts, Depth, Q);\n}\n\n/// Return true if V2 == V1 + X, where X is known non-zero.\nstatic bool isAddOfNonZero(const Value *V1, const Value *V2, unsigned Depth,\n                           const Query &Q) {\n  const BinaryOperator *BO = dyn_cast<BinaryOperator>(V1);\n  if (!BO || BO->getOpcode() != Instruction::Add)\n    return false;\n  Value *Op = nullptr;\n  if (V2 == BO->getOperand(0))\n    Op = BO->getOperand(1);\n  else if (V2 == BO->getOperand(1))\n    Op = BO->getOperand(0);\n  else\n    return false;\n  return isKnownNonZero(Op, Depth + 1, Q);\n}\n\n\n/// Return true if it is known that V1 != V2.\nstatic bool isKnownNonEqual(const Value *V1, const Value *V2, unsigned Depth,\n                            const Query &Q) {\n  if (V1 == V2)\n    return false;\n  if (V1->getType() != V2->getType())\n    // We can't look through casts yet.\n    return false;\n\n  if (Depth >= MaxAnalysisRecursionDepth)\n    return false;\n\n  // See if we can recurse through (exactly one of) our operands.  This\n  // requires our operation be 1-to-1 and map every input value to exactly\n  // one output value.  Such an operation is invertible.\n  auto *O1 = dyn_cast<Operator>(V1);\n  auto *O2 = dyn_cast<Operator>(V2);\n  if (O1 && O2 && O1->getOpcode() == O2->getOpcode()) {\n    switch (O1->getOpcode()) {\n    default: break;\n    case Instruction::Add:\n    case Instruction::Sub:\n      // Assume operand order has been canonicalized\n      if (O1->getOperand(0) == O2->getOperand(0))\n        return isKnownNonEqual(O1->getOperand(1), O2->getOperand(1),\n                               Depth + 1, Q);\n      if (O1->getOperand(1) == O2->getOperand(1))\n        return isKnownNonEqual(O1->getOperand(0), O2->getOperand(0),\n                               Depth + 1, Q);\n      break;\n    case Instruction::Mul: {\n      // invertible if A * B == (A * B) mod 2^N where A, and B are integers\n      // and N is the bitwdith.  The nsw case is non-obvious, but proven by\n      // alive2: https://alive2.llvm.org/ce/z/Z6D5qK\n      auto *OBO1 = cast<OverflowingBinaryOperator>(O1);\n      auto *OBO2 = cast<OverflowingBinaryOperator>(O2);\n      if ((!OBO1->hasNoUnsignedWrap() || !OBO2->hasNoUnsignedWrap()) &&\n          (!OBO1->hasNoSignedWrap() || !OBO2->hasNoSignedWrap()))\n        break;\n\n      // Assume operand order has been canonicalized\n      if (O1->getOperand(1) == O2->getOperand(1) &&\n          isa<ConstantInt>(O1->getOperand(1)) &&\n          !cast<ConstantInt>(O1->getOperand(1))->isZero())\n        return isKnownNonEqual(O1->getOperand(0), O2->getOperand(0),\n                               Depth + 1, Q);\n      break;\n    }\n    case Instruction::SExt:\n    case Instruction::ZExt:\n      if (O1->getOperand(0)->getType() == O2->getOperand(0)->getType())\n        return isKnownNonEqual(O1->getOperand(0), O2->getOperand(0),\n                               Depth + 1, Q);\n      break;\n    };\n  }\n  \n  if (isAddOfNonZero(V1, V2, Depth, Q) || isAddOfNonZero(V2, V1, Depth, Q))\n    return true;\n\n  if (V1->getType()->isIntOrIntVectorTy()) {\n    // Are any known bits in V1 contradictory to known bits in V2? If V1\n    // has a known zero where V2 has a known one, they must not be equal.\n    KnownBits Known1 = computeKnownBits(V1, Depth, Q);\n    KnownBits Known2 = computeKnownBits(V2, Depth, Q);\n\n    if (Known1.Zero.intersects(Known2.One) ||\n        Known2.Zero.intersects(Known1.One))\n      return true;\n  }\n  return false;\n}\n\n/// Return true if 'V & Mask' is known to be zero.  We use this predicate to\n/// simplify operations downstream. Mask is known to be zero for bits that V\n/// cannot have.\n///\n/// This function is defined on values with integer type, values with pointer\n/// type, and vectors of integers.  In the case\n/// where V is a vector, the mask, known zero, and known one values are the\n/// same width as the vector element, and the bit is set only if it is true\n/// for all of the elements in the vector.\nbool MaskedValueIsZero(const Value *V, const APInt &Mask, unsigned Depth,\n                       const Query &Q) {\n  KnownBits Known(Mask.getBitWidth());\n  computeKnownBits(V, Known, Depth, Q);\n  return Mask.isSubsetOf(Known.Zero);\n}\n\n// Match a signed min+max clamp pattern like smax(smin(In, CHigh), CLow).\n// Returns the input and lower/upper bounds.\nstatic bool isSignedMinMaxClamp(const Value *Select, const Value *&In,\n                                const APInt *&CLow, const APInt *&CHigh) {\n  assert(isa<Operator>(Select) &&\n         cast<Operator>(Select)->getOpcode() == Instruction::Select &&\n         \"Input should be a Select!\");\n\n  const Value *LHS = nullptr, *RHS = nullptr;\n  SelectPatternFlavor SPF = matchSelectPattern(Select, LHS, RHS).Flavor;\n  if (SPF != SPF_SMAX && SPF != SPF_SMIN)\n    return false;\n\n  if (!match(RHS, m_APInt(CLow)))\n    return false;\n\n  const Value *LHS2 = nullptr, *RHS2 = nullptr;\n  SelectPatternFlavor SPF2 = matchSelectPattern(LHS, LHS2, RHS2).Flavor;\n  if (getInverseMinMaxFlavor(SPF) != SPF2)\n    return false;\n\n  if (!match(RHS2, m_APInt(CHigh)))\n    return false;\n\n  if (SPF == SPF_SMIN)\n    std::swap(CLow, CHigh);\n\n  In = LHS2;\n  return CLow->sle(*CHigh);\n}\n\n/// For vector constants, loop over the elements and find the constant with the\n/// minimum number of sign bits. Return 0 if the value is not a vector constant\n/// or if any element was not analyzed; otherwise, return the count for the\n/// element with the minimum number of sign bits.\nstatic unsigned computeNumSignBitsVectorConstant(const Value *V,\n                                                 const APInt &DemandedElts,\n                                                 unsigned TyBits) {\n  const auto *CV = dyn_cast<Constant>(V);\n  if (!CV || !isa<FixedVectorType>(CV->getType()))\n    return 0;\n\n  unsigned MinSignBits = TyBits;\n  unsigned NumElts = cast<FixedVectorType>(CV->getType())->getNumElements();\n  for (unsigned i = 0; i != NumElts; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    // If we find a non-ConstantInt, bail out.\n    auto *Elt = dyn_cast_or_null<ConstantInt>(CV->getAggregateElement(i));\n    if (!Elt)\n      return 0;\n\n    MinSignBits = std::min(MinSignBits, Elt->getValue().getNumSignBits());\n  }\n\n  return MinSignBits;\n}\n\nstatic unsigned ComputeNumSignBitsImpl(const Value *V,\n                                       const APInt &DemandedElts,\n                                       unsigned Depth, const Query &Q);\n\nstatic unsigned ComputeNumSignBits(const Value *V, const APInt &DemandedElts,\n                                   unsigned Depth, const Query &Q) {\n  unsigned Result = ComputeNumSignBitsImpl(V, DemandedElts, Depth, Q);\n  assert(Result > 0 && \"At least one sign bit needs to be present!\");\n  return Result;\n}\n\n/// Return the number of times the sign bit of the register is replicated into\n/// the other bits. We know that at least 1 bit is always equal to the sign bit\n/// (itself), but other cases can give us information. For example, immediately\n/// after an \"ashr X, 2\", we know that the top 3 bits are all equal to each\n/// other, so we return 3. For vectors, return the number of sign bits for the\n/// vector element with the minimum number of known sign bits of the demanded\n/// elements in the vector specified by DemandedElts.\nstatic unsigned ComputeNumSignBitsImpl(const Value *V,\n                                       const APInt &DemandedElts,\n                                       unsigned Depth, const Query &Q) {\n  Type *Ty = V->getType();\n\n  // FIXME: We currently have no way to represent the DemandedElts of a scalable\n  // vector\n  if (isa<ScalableVectorType>(Ty))\n    return 1;\n\n#ifndef NDEBUG\n  assert(Depth <= MaxAnalysisRecursionDepth && \"Limit Search Depth\");\n\n  if (auto *FVTy = dyn_cast<FixedVectorType>(Ty)) {\n    assert(\n        FVTy->getNumElements() == DemandedElts.getBitWidth() &&\n        \"DemandedElt width should equal the fixed vector number of elements\");\n  } else {\n    assert(DemandedElts == APInt(1, 1) &&\n           \"DemandedElt width should be 1 for scalars\");\n  }\n#endif\n\n  // We return the minimum number of sign bits that are guaranteed to be present\n  // in V, so for undef we have to conservatively return 1.  We don't have the\n  // same behavior for poison though -- that's a FIXME today.\n\n  Type *ScalarTy = Ty->getScalarType();\n  unsigned TyBits = ScalarTy->isPointerTy() ?\n    Q.DL.getPointerTypeSizeInBits(ScalarTy) :\n    Q.DL.getTypeSizeInBits(ScalarTy);\n\n  unsigned Tmp, Tmp2;\n  unsigned FirstAnswer = 1;\n\n  // Note that ConstantInt is handled by the general computeKnownBits case\n  // below.\n\n  if (Depth == MaxAnalysisRecursionDepth)\n    return 1;\n\n  if (auto *U = dyn_cast<Operator>(V)) {\n    switch (Operator::getOpcode(V)) {\n    default: break;\n    case Instruction::SExt:\n      Tmp = TyBits - U->getOperand(0)->getType()->getScalarSizeInBits();\n      return ComputeNumSignBits(U->getOperand(0), Depth + 1, Q) + Tmp;\n\n    case Instruction::SDiv: {\n      const APInt *Denominator;\n      // sdiv X, C -> adds log(C) sign bits.\n      if (match(U->getOperand(1), m_APInt(Denominator))) {\n\n        // Ignore non-positive denominator.\n        if (!Denominator->isStrictlyPositive())\n          break;\n\n        // Calculate the incoming numerator bits.\n        unsigned NumBits = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n\n        // Add floor(log(C)) bits to the numerator bits.\n        return std::min(TyBits, NumBits + Denominator->logBase2());\n      }\n      break;\n    }\n\n    case Instruction::SRem: {\n      const APInt *Denominator;\n      // srem X, C -> we know that the result is within [-C+1,C) when C is a\n      // positive constant.  This let us put a lower bound on the number of sign\n      // bits.\n      if (match(U->getOperand(1), m_APInt(Denominator))) {\n\n        // Ignore non-positive denominator.\n        if (!Denominator->isStrictlyPositive())\n          break;\n\n        // Calculate the incoming numerator bits. SRem by a positive constant\n        // can't lower the number of sign bits.\n        unsigned NumrBits = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n\n        // Calculate the leading sign bit constraints by examining the\n        // denominator.  Given that the denominator is positive, there are two\n        // cases:\n        //\n        //  1. the numerator is positive. The result range is [0,C) and [0,C) u<\n        //     (1 << ceilLogBase2(C)).\n        //\n        //  2. the numerator is negative. Then the result range is (-C,0] and\n        //     integers in (-C,0] are either 0 or >u (-1 << ceilLogBase2(C)).\n        //\n        // Thus a lower bound on the number of sign bits is `TyBits -\n        // ceilLogBase2(C)`.\n\n        unsigned ResBits = TyBits - Denominator->ceilLogBase2();\n        return std::max(NumrBits, ResBits);\n      }\n      break;\n    }\n\n    case Instruction::AShr: {\n      Tmp = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n      // ashr X, C   -> adds C sign bits.  Vectors too.\n      const APInt *ShAmt;\n      if (match(U->getOperand(1), m_APInt(ShAmt))) {\n        if (ShAmt->uge(TyBits))\n          break; // Bad shift.\n        unsigned ShAmtLimited = ShAmt->getZExtValue();\n        Tmp += ShAmtLimited;\n        if (Tmp > TyBits) Tmp = TyBits;\n      }\n      return Tmp;\n    }\n    case Instruction::Shl: {\n      const APInt *ShAmt;\n      if (match(U->getOperand(1), m_APInt(ShAmt))) {\n        // shl destroys sign bits.\n        Tmp = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n        if (ShAmt->uge(TyBits) ||   // Bad shift.\n            ShAmt->uge(Tmp)) break; // Shifted all sign bits out.\n        Tmp2 = ShAmt->getZExtValue();\n        return Tmp - Tmp2;\n      }\n      break;\n    }\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor: // NOT is handled here.\n      // Logical binary ops preserve the number of sign bits at the worst.\n      Tmp = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n      if (Tmp != 1) {\n        Tmp2 = ComputeNumSignBits(U->getOperand(1), Depth + 1, Q);\n        FirstAnswer = std::min(Tmp, Tmp2);\n        // We computed what we know about the sign bits as our first\n        // answer. Now proceed to the generic code that uses\n        // computeKnownBits, and pick whichever answer is better.\n      }\n      break;\n\n    case Instruction::Select: {\n      // If we have a clamp pattern, we know that the number of sign bits will\n      // be the minimum of the clamp min/max range.\n      const Value *X;\n      const APInt *CLow, *CHigh;\n      if (isSignedMinMaxClamp(U, X, CLow, CHigh))\n        return std::min(CLow->getNumSignBits(), CHigh->getNumSignBits());\n\n      Tmp = ComputeNumSignBits(U->getOperand(1), Depth + 1, Q);\n      if (Tmp == 1) break;\n      Tmp2 = ComputeNumSignBits(U->getOperand(2), Depth + 1, Q);\n      return std::min(Tmp, Tmp2);\n    }\n\n    case Instruction::Add:\n      // Add can have at most one carry bit.  Thus we know that the output\n      // is, at worst, one more bit than the inputs.\n      Tmp = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n      if (Tmp == 1) break;\n\n      // Special case decrementing a value (ADD X, -1):\n      if (const auto *CRHS = dyn_cast<Constant>(U->getOperand(1)))\n        if (CRHS->isAllOnesValue()) {\n          KnownBits Known(TyBits);\n          computeKnownBits(U->getOperand(0), Known, Depth + 1, Q);\n\n          // If the input is known to be 0 or 1, the output is 0/-1, which is\n          // all sign bits set.\n          if ((Known.Zero | 1).isAllOnesValue())\n            return TyBits;\n\n          // If we are subtracting one from a positive number, there is no carry\n          // out of the result.\n          if (Known.isNonNegative())\n            return Tmp;\n        }\n\n      Tmp2 = ComputeNumSignBits(U->getOperand(1), Depth + 1, Q);\n      if (Tmp2 == 1) break;\n      return std::min(Tmp, Tmp2) - 1;\n\n    case Instruction::Sub:\n      Tmp2 = ComputeNumSignBits(U->getOperand(1), Depth + 1, Q);\n      if (Tmp2 == 1) break;\n\n      // Handle NEG.\n      if (const auto *CLHS = dyn_cast<Constant>(U->getOperand(0)))\n        if (CLHS->isNullValue()) {\n          KnownBits Known(TyBits);\n          computeKnownBits(U->getOperand(1), Known, Depth + 1, Q);\n          // If the input is known to be 0 or 1, the output is 0/-1, which is\n          // all sign bits set.\n          if ((Known.Zero | 1).isAllOnesValue())\n            return TyBits;\n\n          // If the input is known to be positive (the sign bit is known clear),\n          // the output of the NEG has the same number of sign bits as the\n          // input.\n          if (Known.isNonNegative())\n            return Tmp2;\n\n          // Otherwise, we treat this like a SUB.\n        }\n\n      // Sub can have at most one carry bit.  Thus we know that the output\n      // is, at worst, one more bit than the inputs.\n      Tmp = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n      if (Tmp == 1) break;\n      return std::min(Tmp, Tmp2) - 1;\n\n    case Instruction::Mul: {\n      // The output of the Mul can be at most twice the valid bits in the\n      // inputs.\n      unsigned SignBitsOp0 = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n      if (SignBitsOp0 == 1) break;\n      unsigned SignBitsOp1 = ComputeNumSignBits(U->getOperand(1), Depth + 1, Q);\n      if (SignBitsOp1 == 1) break;\n      unsigned OutValidBits =\n          (TyBits - SignBitsOp0 + 1) + (TyBits - SignBitsOp1 + 1);\n      return OutValidBits > TyBits ? 1 : TyBits - OutValidBits + 1;\n    }\n\n    case Instruction::PHI: {\n      const PHINode *PN = cast<PHINode>(U);\n      unsigned NumIncomingValues = PN->getNumIncomingValues();\n      // Don't analyze large in-degree PHIs.\n      if (NumIncomingValues > 4) break;\n      // Unreachable blocks may have zero-operand PHI nodes.\n      if (NumIncomingValues == 0) break;\n\n      // Take the minimum of all incoming values.  This can't infinitely loop\n      // because of our depth threshold.\n      Query RecQ = Q;\n      Tmp = TyBits;\n      for (unsigned i = 0, e = NumIncomingValues; i != e; ++i) {\n        if (Tmp == 1) return Tmp;\n        RecQ.CxtI = PN->getIncomingBlock(i)->getTerminator();\n        Tmp = std::min(\n            Tmp, ComputeNumSignBits(PN->getIncomingValue(i), Depth + 1, RecQ));\n      }\n      return Tmp;\n    }\n\n    case Instruction::Trunc:\n      // FIXME: it's tricky to do anything useful for this, but it is an\n      // important case for targets like X86.\n      break;\n\n    case Instruction::ExtractElement:\n      // Look through extract element. At the moment we keep this simple and\n      // skip tracking the specific element. But at least we might find\n      // information valid for all elements of the vector (for example if vector\n      // is sign extended, shifted, etc).\n      return ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n\n    case Instruction::ShuffleVector: {\n      // Collect the minimum number of sign bits that are shared by every vector\n      // element referenced by the shuffle.\n      auto *Shuf = dyn_cast<ShuffleVectorInst>(U);\n      if (!Shuf) {\n        // FIXME: Add support for shufflevector constant expressions.\n        return 1;\n      }\n      APInt DemandedLHS, DemandedRHS;\n      // For undef elements, we don't know anything about the common state of\n      // the shuffle result.\n      if (!getShuffleDemandedElts(Shuf, DemandedElts, DemandedLHS, DemandedRHS))\n        return 1;\n      Tmp = std::numeric_limits<unsigned>::max();\n      if (!!DemandedLHS) {\n        const Value *LHS = Shuf->getOperand(0);\n        Tmp = ComputeNumSignBits(LHS, DemandedLHS, Depth + 1, Q);\n      }\n      // If we don't know anything, early out and try computeKnownBits\n      // fall-back.\n      if (Tmp == 1)\n        break;\n      if (!!DemandedRHS) {\n        const Value *RHS = Shuf->getOperand(1);\n        Tmp2 = ComputeNumSignBits(RHS, DemandedRHS, Depth + 1, Q);\n        Tmp = std::min(Tmp, Tmp2);\n      }\n      // If we don't know anything, early out and try computeKnownBits\n      // fall-back.\n      if (Tmp == 1)\n        break;\n      assert(Tmp <= TyBits && \"Failed to determine minimum sign bits\");\n      return Tmp;\n    }\n    case Instruction::Call: {\n      if (const auto *II = dyn_cast<IntrinsicInst>(U)) {\n        switch (II->getIntrinsicID()) {\n        default: break;\n        case Intrinsic::abs:\n          Tmp = ComputeNumSignBits(U->getOperand(0), Depth + 1, Q);\n          if (Tmp == 1) break;\n\n          // Absolute value reduces number of sign bits by at most 1.\n          return Tmp - 1;\n        }\n      }\n    }\n    }\n  }\n\n  // Finally, if we can prove that the top bits of the result are 0's or 1's,\n  // use this information.\n\n  // If we can examine all elements of a vector constant successfully, we're\n  // done (we can't do any better than that). If not, keep trying.\n  if (unsigned VecSignBits =\n          computeNumSignBitsVectorConstant(V, DemandedElts, TyBits))\n    return VecSignBits;\n\n  KnownBits Known(TyBits);\n  computeKnownBits(V, DemandedElts, Known, Depth, Q);\n\n  // If we know that the sign bit is either zero or one, determine the number of\n  // identical bits in the top of the input value.\n  return std::max(FirstAnswer, Known.countMinSignBits());\n}\n\n/// This function computes the integer multiple of Base that equals V.\n/// If successful, it returns true and returns the multiple in\n/// Multiple. If unsuccessful, it returns false. It looks\n/// through SExt instructions only if LookThroughSExt is true.\nbool llvm::ComputeMultiple(Value *V, unsigned Base, Value *&Multiple,\n                           bool LookThroughSExt, unsigned Depth) {\n  assert(V && \"No Value?\");\n  assert(Depth <= MaxAnalysisRecursionDepth && \"Limit Search Depth\");\n  assert(V->getType()->isIntegerTy() && \"Not integer or pointer type!\");\n\n  Type *T = V->getType();\n\n  ConstantInt *CI = dyn_cast<ConstantInt>(V);\n\n  if (Base == 0)\n    return false;\n\n  if (Base == 1) {\n    Multiple = V;\n    return true;\n  }\n\n  ConstantExpr *CO = dyn_cast<ConstantExpr>(V);\n  Constant *BaseVal = ConstantInt::get(T, Base);\n  if (CO && CO == BaseVal) {\n    // Multiple is 1.\n    Multiple = ConstantInt::get(T, 1);\n    return true;\n  }\n\n  if (CI && CI->getZExtValue() % Base == 0) {\n    Multiple = ConstantInt::get(T, CI->getZExtValue() / Base);\n    return true;\n  }\n\n  if (Depth == MaxAnalysisRecursionDepth) return false;\n\n  Operator *I = dyn_cast<Operator>(V);\n  if (!I) return false;\n\n  switch (I->getOpcode()) {\n  default: break;\n  case Instruction::SExt:\n    if (!LookThroughSExt) return false;\n    // otherwise fall through to ZExt\n    LLVM_FALLTHROUGH;\n  case Instruction::ZExt:\n    return ComputeMultiple(I->getOperand(0), Base, Multiple,\n                           LookThroughSExt, Depth+1);\n  case Instruction::Shl:\n  case Instruction::Mul: {\n    Value *Op0 = I->getOperand(0);\n    Value *Op1 = I->getOperand(1);\n\n    if (I->getOpcode() == Instruction::Shl) {\n      ConstantInt *Op1CI = dyn_cast<ConstantInt>(Op1);\n      if (!Op1CI) return false;\n      // Turn Op0 << Op1 into Op0 * 2^Op1\n      APInt Op1Int = Op1CI->getValue();\n      uint64_t BitToSet = Op1Int.getLimitedValue(Op1Int.getBitWidth() - 1);\n      APInt API(Op1Int.getBitWidth(), 0);\n      API.setBit(BitToSet);\n      Op1 = ConstantInt::get(V->getContext(), API);\n    }\n\n    Value *Mul0 = nullptr;\n    if (ComputeMultiple(Op0, Base, Mul0, LookThroughSExt, Depth+1)) {\n      if (Constant *Op1C = dyn_cast<Constant>(Op1))\n        if (Constant *MulC = dyn_cast<Constant>(Mul0)) {\n          if (Op1C->getType()->getPrimitiveSizeInBits().getFixedSize() <\n              MulC->getType()->getPrimitiveSizeInBits().getFixedSize())\n            Op1C = ConstantExpr::getZExt(Op1C, MulC->getType());\n          if (Op1C->getType()->getPrimitiveSizeInBits().getFixedSize() >\n              MulC->getType()->getPrimitiveSizeInBits().getFixedSize())\n            MulC = ConstantExpr::getZExt(MulC, Op1C->getType());\n\n          // V == Base * (Mul0 * Op1), so return (Mul0 * Op1)\n          Multiple = ConstantExpr::getMul(MulC, Op1C);\n          return true;\n        }\n\n      if (ConstantInt *Mul0CI = dyn_cast<ConstantInt>(Mul0))\n        if (Mul0CI->getValue() == 1) {\n          // V == Base * Op1, so return Op1\n          Multiple = Op1;\n          return true;\n        }\n    }\n\n    Value *Mul1 = nullptr;\n    if (ComputeMultiple(Op1, Base, Mul1, LookThroughSExt, Depth+1)) {\n      if (Constant *Op0C = dyn_cast<Constant>(Op0))\n        if (Constant *MulC = dyn_cast<Constant>(Mul1)) {\n          if (Op0C->getType()->getPrimitiveSizeInBits().getFixedSize() <\n              MulC->getType()->getPrimitiveSizeInBits().getFixedSize())\n            Op0C = ConstantExpr::getZExt(Op0C, MulC->getType());\n          if (Op0C->getType()->getPrimitiveSizeInBits().getFixedSize() >\n              MulC->getType()->getPrimitiveSizeInBits().getFixedSize())\n            MulC = ConstantExpr::getZExt(MulC, Op0C->getType());\n\n          // V == Base * (Mul1 * Op0), so return (Mul1 * Op0)\n          Multiple = ConstantExpr::getMul(MulC, Op0C);\n          return true;\n        }\n\n      if (ConstantInt *Mul1CI = dyn_cast<ConstantInt>(Mul1))\n        if (Mul1CI->getValue() == 1) {\n          // V == Base * Op0, so return Op0\n          Multiple = Op0;\n          return true;\n        }\n    }\n  }\n  }\n\n  // We could not determine if V is a multiple of Base.\n  return false;\n}\n\nIntrinsic::ID llvm::getIntrinsicForCallSite(const CallBase &CB,\n                                            const TargetLibraryInfo *TLI) {\n  const Function *F = CB.getCalledFunction();\n  if (!F)\n    return Intrinsic::not_intrinsic;\n\n  if (F->isIntrinsic())\n    return F->getIntrinsicID();\n\n  // We are going to infer semantics of a library function based on mapping it\n  // to an LLVM intrinsic. Check that the library function is available from\n  // this callbase and in this environment.\n  LibFunc Func;\n  if (F->hasLocalLinkage() || !TLI || !TLI->getLibFunc(CB, Func) ||\n      !CB.onlyReadsMemory())\n    return Intrinsic::not_intrinsic;\n\n  switch (Func) {\n  default:\n    break;\n  case LibFunc_sin:\n  case LibFunc_sinf:\n  case LibFunc_sinl:\n    return Intrinsic::sin;\n  case LibFunc_cos:\n  case LibFunc_cosf:\n  case LibFunc_cosl:\n    return Intrinsic::cos;\n  case LibFunc_exp:\n  case LibFunc_expf:\n  case LibFunc_expl:\n    return Intrinsic::exp;\n  case LibFunc_exp2:\n  case LibFunc_exp2f:\n  case LibFunc_exp2l:\n    return Intrinsic::exp2;\n  case LibFunc_log:\n  case LibFunc_logf:\n  case LibFunc_logl:\n    return Intrinsic::log;\n  case LibFunc_log10:\n  case LibFunc_log10f:\n  case LibFunc_log10l:\n    return Intrinsic::log10;\n  case LibFunc_log2:\n  case LibFunc_log2f:\n  case LibFunc_log2l:\n    return Intrinsic::log2;\n  case LibFunc_fabs:\n  case LibFunc_fabsf:\n  case LibFunc_fabsl:\n    return Intrinsic::fabs;\n  case LibFunc_fmin:\n  case LibFunc_fminf:\n  case LibFunc_fminl:\n    return Intrinsic::minnum;\n  case LibFunc_fmax:\n  case LibFunc_fmaxf:\n  case LibFunc_fmaxl:\n    return Intrinsic::maxnum;\n  case LibFunc_copysign:\n  case LibFunc_copysignf:\n  case LibFunc_copysignl:\n    return Intrinsic::copysign;\n  case LibFunc_floor:\n  case LibFunc_floorf:\n  case LibFunc_floorl:\n    return Intrinsic::floor;\n  case LibFunc_ceil:\n  case LibFunc_ceilf:\n  case LibFunc_ceill:\n    return Intrinsic::ceil;\n  case LibFunc_trunc:\n  case LibFunc_truncf:\n  case LibFunc_truncl:\n    return Intrinsic::trunc;\n  case LibFunc_rint:\n  case LibFunc_rintf:\n  case LibFunc_rintl:\n    return Intrinsic::rint;\n  case LibFunc_nearbyint:\n  case LibFunc_nearbyintf:\n  case LibFunc_nearbyintl:\n    return Intrinsic::nearbyint;\n  case LibFunc_round:\n  case LibFunc_roundf:\n  case LibFunc_roundl:\n    return Intrinsic::round;\n  case LibFunc_roundeven:\n  case LibFunc_roundevenf:\n  case LibFunc_roundevenl:\n    return Intrinsic::roundeven;\n  case LibFunc_pow:\n  case LibFunc_powf:\n  case LibFunc_powl:\n    return Intrinsic::pow;\n  case LibFunc_sqrt:\n  case LibFunc_sqrtf:\n  case LibFunc_sqrtl:\n    return Intrinsic::sqrt;\n  }\n\n  return Intrinsic::not_intrinsic;\n}\n\n/// Return true if we can prove that the specified FP value is never equal to\n/// -0.0.\n/// NOTE: Do not check 'nsz' here because that fast-math-flag does not guarantee\n///       that a value is not -0.0. It only guarantees that -0.0 may be treated\n///       the same as +0.0 in floating-point ops.\n///\n/// NOTE: this function will need to be revisited when we support non-default\n/// rounding modes!\nbool llvm::CannotBeNegativeZero(const Value *V, const TargetLibraryInfo *TLI,\n                                unsigned Depth) {\n  if (auto *CFP = dyn_cast<ConstantFP>(V))\n    return !CFP->getValueAPF().isNegZero();\n\n  if (Depth == MaxAnalysisRecursionDepth)\n    return false;\n\n  auto *Op = dyn_cast<Operator>(V);\n  if (!Op)\n    return false;\n\n  // (fadd x, 0.0) is guaranteed to return +0.0, not -0.0.\n  if (match(Op, m_FAdd(m_Value(), m_PosZeroFP())))\n    return true;\n\n  // sitofp and uitofp turn into +0.0 for zero.\n  if (isa<SIToFPInst>(Op) || isa<UIToFPInst>(Op))\n    return true;\n\n  if (auto *Call = dyn_cast<CallInst>(Op)) {\n    Intrinsic::ID IID = getIntrinsicForCallSite(*Call, TLI);\n    switch (IID) {\n    default:\n      break;\n    // sqrt(-0.0) = -0.0, no other negative results are possible.\n    case Intrinsic::sqrt:\n    case Intrinsic::canonicalize:\n      return CannotBeNegativeZero(Call->getArgOperand(0), TLI, Depth + 1);\n    // fabs(x) != -0.0\n    case Intrinsic::fabs:\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// If \\p SignBitOnly is true, test for a known 0 sign bit rather than a\n/// standard ordered compare. e.g. make -0.0 olt 0.0 be true because of the sign\n/// bit despite comparing equal.\nstatic bool cannotBeOrderedLessThanZeroImpl(const Value *V,\n                                            const TargetLibraryInfo *TLI,\n                                            bool SignBitOnly,\n                                            unsigned Depth) {\n  // TODO: This function does not do the right thing when SignBitOnly is true\n  // and we're lowering to a hypothetical IEEE 754-compliant-but-evil platform\n  // which flips the sign bits of NaNs.  See\n  // https://llvm.org/bugs/show_bug.cgi?id=31702.\n\n  if (const ConstantFP *CFP = dyn_cast<ConstantFP>(V)) {\n    return !CFP->getValueAPF().isNegative() ||\n           (!SignBitOnly && CFP->getValueAPF().isZero());\n  }\n\n  // Handle vector of constants.\n  if (auto *CV = dyn_cast<Constant>(V)) {\n    if (auto *CVFVTy = dyn_cast<FixedVectorType>(CV->getType())) {\n      unsigned NumElts = CVFVTy->getNumElements();\n      for (unsigned i = 0; i != NumElts; ++i) {\n        auto *CFP = dyn_cast_or_null<ConstantFP>(CV->getAggregateElement(i));\n        if (!CFP)\n          return false;\n        if (CFP->getValueAPF().isNegative() &&\n            (SignBitOnly || !CFP->getValueAPF().isZero()))\n          return false;\n      }\n\n      // All non-negative ConstantFPs.\n      return true;\n    }\n  }\n\n  if (Depth == MaxAnalysisRecursionDepth)\n    return false;\n\n  const Operator *I = dyn_cast<Operator>(V);\n  if (!I)\n    return false;\n\n  switch (I->getOpcode()) {\n  default:\n    break;\n  // Unsigned integers are always nonnegative.\n  case Instruction::UIToFP:\n    return true;\n  case Instruction::FMul:\n  case Instruction::FDiv:\n    // X * X is always non-negative or a NaN.\n    // X / X is always exactly 1.0 or a NaN.\n    if (I->getOperand(0) == I->getOperand(1) &&\n        (!SignBitOnly || cast<FPMathOperator>(I)->hasNoNaNs()))\n      return true;\n\n    LLVM_FALLTHROUGH;\n  case Instruction::FAdd:\n  case Instruction::FRem:\n    return cannotBeOrderedLessThanZeroImpl(I->getOperand(0), TLI, SignBitOnly,\n                                           Depth + 1) &&\n           cannotBeOrderedLessThanZeroImpl(I->getOperand(1), TLI, SignBitOnly,\n                                           Depth + 1);\n  case Instruction::Select:\n    return cannotBeOrderedLessThanZeroImpl(I->getOperand(1), TLI, SignBitOnly,\n                                           Depth + 1) &&\n           cannotBeOrderedLessThanZeroImpl(I->getOperand(2), TLI, SignBitOnly,\n                                           Depth + 1);\n  case Instruction::FPExt:\n  case Instruction::FPTrunc:\n    // Widening/narrowing never change sign.\n    return cannotBeOrderedLessThanZeroImpl(I->getOperand(0), TLI, SignBitOnly,\n                                           Depth + 1);\n  case Instruction::ExtractElement:\n    // Look through extract element. At the moment we keep this simple and skip\n    // tracking the specific element. But at least we might find information\n    // valid for all elements of the vector.\n    return cannotBeOrderedLessThanZeroImpl(I->getOperand(0), TLI, SignBitOnly,\n                                           Depth + 1);\n  case Instruction::Call:\n    const auto *CI = cast<CallInst>(I);\n    Intrinsic::ID IID = getIntrinsicForCallSite(*CI, TLI);\n    switch (IID) {\n    default:\n      break;\n    case Intrinsic::maxnum: {\n      Value *V0 = I->getOperand(0), *V1 = I->getOperand(1);\n      auto isPositiveNum = [&](Value *V) {\n        if (SignBitOnly) {\n          // With SignBitOnly, this is tricky because the result of\n          // maxnum(+0.0, -0.0) is unspecified. Just check if the operand is\n          // a constant strictly greater than 0.0.\n          const APFloat *C;\n          return match(V, m_APFloat(C)) &&\n                 *C > APFloat::getZero(C->getSemantics());\n        }\n\n        // -0.0 compares equal to 0.0, so if this operand is at least -0.0,\n        // maxnum can't be ordered-less-than-zero.\n        return isKnownNeverNaN(V, TLI) &&\n               cannotBeOrderedLessThanZeroImpl(V, TLI, false, Depth + 1);\n      };\n\n      // TODO: This could be improved. We could also check that neither operand\n      //       has its sign bit set (and at least 1 is not-NAN?).\n      return isPositiveNum(V0) || isPositiveNum(V1);\n    }\n\n    case Intrinsic::maximum:\n      return cannotBeOrderedLessThanZeroImpl(I->getOperand(0), TLI, SignBitOnly,\n                                             Depth + 1) ||\n             cannotBeOrderedLessThanZeroImpl(I->getOperand(1), TLI, SignBitOnly,\n                                             Depth + 1);\n    case Intrinsic::minnum:\n    case Intrinsic::minimum:\n      return cannotBeOrderedLessThanZeroImpl(I->getOperand(0), TLI, SignBitOnly,\n                                             Depth + 1) &&\n             cannotBeOrderedLessThanZeroImpl(I->getOperand(1), TLI, SignBitOnly,\n                                             Depth + 1);\n    case Intrinsic::exp:\n    case Intrinsic::exp2:\n    case Intrinsic::fabs:\n      return true;\n\n    case Intrinsic::sqrt:\n      // sqrt(x) is always >= -0 or NaN.  Moreover, sqrt(x) == -0 iff x == -0.\n      if (!SignBitOnly)\n        return true;\n      return CI->hasNoNaNs() && (CI->hasNoSignedZeros() ||\n                                 CannotBeNegativeZero(CI->getOperand(0), TLI));\n\n    case Intrinsic::powi:\n      if (ConstantInt *Exponent = dyn_cast<ConstantInt>(I->getOperand(1))) {\n        // powi(x,n) is non-negative if n is even.\n        if (Exponent->getBitWidth() <= 64 && Exponent->getSExtValue() % 2u == 0)\n          return true;\n      }\n      // TODO: This is not correct.  Given that exp is an integer, here are the\n      // ways that pow can return a negative value:\n      //\n      //   pow(x, exp)    --> negative if exp is odd and x is negative.\n      //   pow(-0, exp)   --> -inf if exp is negative odd.\n      //   pow(-0, exp)   --> -0 if exp is positive odd.\n      //   pow(-inf, exp) --> -0 if exp is negative odd.\n      //   pow(-inf, exp) --> -inf if exp is positive odd.\n      //\n      // Therefore, if !SignBitOnly, we can return true if x >= +0 or x is NaN,\n      // but we must return false if x == -0.  Unfortunately we do not currently\n      // have a way of expressing this constraint.  See details in\n      // https://llvm.org/bugs/show_bug.cgi?id=31702.\n      return cannotBeOrderedLessThanZeroImpl(I->getOperand(0), TLI, SignBitOnly,\n                                             Depth + 1);\n\n    case Intrinsic::fma:\n    case Intrinsic::fmuladd:\n      // x*x+y is non-negative if y is non-negative.\n      return I->getOperand(0) == I->getOperand(1) &&\n             (!SignBitOnly || cast<FPMathOperator>(I)->hasNoNaNs()) &&\n             cannotBeOrderedLessThanZeroImpl(I->getOperand(2), TLI, SignBitOnly,\n                                             Depth + 1);\n    }\n    break;\n  }\n  return false;\n}\n\nbool llvm::CannotBeOrderedLessThanZero(const Value *V,\n                                       const TargetLibraryInfo *TLI) {\n  return cannotBeOrderedLessThanZeroImpl(V, TLI, false, 0);\n}\n\nbool llvm::SignBitMustBeZero(const Value *V, const TargetLibraryInfo *TLI) {\n  return cannotBeOrderedLessThanZeroImpl(V, TLI, true, 0);\n}\n\nbool llvm::isKnownNeverInfinity(const Value *V, const TargetLibraryInfo *TLI,\n                                unsigned Depth) {\n  assert(V->getType()->isFPOrFPVectorTy() && \"Querying for Inf on non-FP type\");\n\n  // If we're told that infinities won't happen, assume they won't.\n  if (auto *FPMathOp = dyn_cast<FPMathOperator>(V))\n    if (FPMathOp->hasNoInfs())\n      return true;\n\n  // Handle scalar constants.\n  if (auto *CFP = dyn_cast<ConstantFP>(V))\n    return !CFP->isInfinity();\n\n  if (Depth == MaxAnalysisRecursionDepth)\n    return false;\n\n  if (auto *Inst = dyn_cast<Instruction>(V)) {\n    switch (Inst->getOpcode()) {\n    case Instruction::Select: {\n      return isKnownNeverInfinity(Inst->getOperand(1), TLI, Depth + 1) &&\n             isKnownNeverInfinity(Inst->getOperand(2), TLI, Depth + 1);\n    }\n    case Instruction::SIToFP:\n    case Instruction::UIToFP: {\n      // Get width of largest magnitude integer (remove a bit if signed).\n      // This still works for a signed minimum value because the largest FP\n      // value is scaled by some fraction close to 2.0 (1.0 + 0.xxxx).\n      int IntSize = Inst->getOperand(0)->getType()->getScalarSizeInBits();\n      if (Inst->getOpcode() == Instruction::SIToFP)\n        --IntSize;\n\n      // If the exponent of the largest finite FP value can hold the largest\n      // integer, the result of the cast must be finite.\n      Type *FPTy = Inst->getType()->getScalarType();\n      return ilogb(APFloat::getLargest(FPTy->getFltSemantics())) >= IntSize;\n    }\n    default:\n      break;\n    }\n  }\n\n  // try to handle fixed width vector constants\n  auto *VFVTy = dyn_cast<FixedVectorType>(V->getType());\n  if (VFVTy && isa<Constant>(V)) {\n    // For vectors, verify that each element is not infinity.\n    unsigned NumElts = VFVTy->getNumElements();\n    for (unsigned i = 0; i != NumElts; ++i) {\n      Constant *Elt = cast<Constant>(V)->getAggregateElement(i);\n      if (!Elt)\n        return false;\n      if (isa<UndefValue>(Elt))\n        continue;\n      auto *CElt = dyn_cast<ConstantFP>(Elt);\n      if (!CElt || CElt->isInfinity())\n        return false;\n    }\n    // All elements were confirmed non-infinity or undefined.\n    return true;\n  }\n\n  // was not able to prove that V never contains infinity\n  return false;\n}\n\nbool llvm::isKnownNeverNaN(const Value *V, const TargetLibraryInfo *TLI,\n                           unsigned Depth) {\n  assert(V->getType()->isFPOrFPVectorTy() && \"Querying for NaN on non-FP type\");\n\n  // If we're told that NaNs won't happen, assume they won't.\n  if (auto *FPMathOp = dyn_cast<FPMathOperator>(V))\n    if (FPMathOp->hasNoNaNs())\n      return true;\n\n  // Handle scalar constants.\n  if (auto *CFP = dyn_cast<ConstantFP>(V))\n    return !CFP->isNaN();\n\n  if (Depth == MaxAnalysisRecursionDepth)\n    return false;\n\n  if (auto *Inst = dyn_cast<Instruction>(V)) {\n    switch (Inst->getOpcode()) {\n    case Instruction::FAdd:\n    case Instruction::FSub:\n      // Adding positive and negative infinity produces NaN.\n      return isKnownNeverNaN(Inst->getOperand(0), TLI, Depth + 1) &&\n             isKnownNeverNaN(Inst->getOperand(1), TLI, Depth + 1) &&\n             (isKnownNeverInfinity(Inst->getOperand(0), TLI, Depth + 1) ||\n              isKnownNeverInfinity(Inst->getOperand(1), TLI, Depth + 1));\n\n    case Instruction::FMul:\n      // Zero multiplied with infinity produces NaN.\n      // FIXME: If neither side can be zero fmul never produces NaN.\n      return isKnownNeverNaN(Inst->getOperand(0), TLI, Depth + 1) &&\n             isKnownNeverInfinity(Inst->getOperand(0), TLI, Depth + 1) &&\n             isKnownNeverNaN(Inst->getOperand(1), TLI, Depth + 1) &&\n             isKnownNeverInfinity(Inst->getOperand(1), TLI, Depth + 1);\n\n    case Instruction::FDiv:\n    case Instruction::FRem:\n      // FIXME: Only 0/0, Inf/Inf, Inf REM x and x REM 0 produce NaN.\n      return false;\n\n    case Instruction::Select: {\n      return isKnownNeverNaN(Inst->getOperand(1), TLI, Depth + 1) &&\n             isKnownNeverNaN(Inst->getOperand(2), TLI, Depth + 1);\n    }\n    case Instruction::SIToFP:\n    case Instruction::UIToFP:\n      return true;\n    case Instruction::FPTrunc:\n    case Instruction::FPExt:\n      return isKnownNeverNaN(Inst->getOperand(0), TLI, Depth + 1);\n    default:\n      break;\n    }\n  }\n\n  if (const auto *II = dyn_cast<IntrinsicInst>(V)) {\n    switch (II->getIntrinsicID()) {\n    case Intrinsic::canonicalize:\n    case Intrinsic::fabs:\n    case Intrinsic::copysign:\n    case Intrinsic::exp:\n    case Intrinsic::exp2:\n    case Intrinsic::floor:\n    case Intrinsic::ceil:\n    case Intrinsic::trunc:\n    case Intrinsic::rint:\n    case Intrinsic::nearbyint:\n    case Intrinsic::round:\n    case Intrinsic::roundeven:\n      return isKnownNeverNaN(II->getArgOperand(0), TLI, Depth + 1);\n    case Intrinsic::sqrt:\n      return isKnownNeverNaN(II->getArgOperand(0), TLI, Depth + 1) &&\n             CannotBeOrderedLessThanZero(II->getArgOperand(0), TLI);\n    case Intrinsic::minnum:\n    case Intrinsic::maxnum:\n      // If either operand is not NaN, the result is not NaN.\n      return isKnownNeverNaN(II->getArgOperand(0), TLI, Depth + 1) ||\n             isKnownNeverNaN(II->getArgOperand(1), TLI, Depth + 1);\n    default:\n      return false;\n    }\n  }\n\n  // Try to handle fixed width vector constants\n  auto *VFVTy = dyn_cast<FixedVectorType>(V->getType());\n  if (VFVTy && isa<Constant>(V)) {\n    // For vectors, verify that each element is not NaN.\n    unsigned NumElts = VFVTy->getNumElements();\n    for (unsigned i = 0; i != NumElts; ++i) {\n      Constant *Elt = cast<Constant>(V)->getAggregateElement(i);\n      if (!Elt)\n        return false;\n      if (isa<UndefValue>(Elt))\n        continue;\n      auto *CElt = dyn_cast<ConstantFP>(Elt);\n      if (!CElt || CElt->isNaN())\n        return false;\n    }\n    // All elements were confirmed not-NaN or undefined.\n    return true;\n  }\n\n  // Was not able to prove that V never contains NaN\n  return false;\n}\n\nValue *llvm::isBytewiseValue(Value *V, const DataLayout &DL) {\n\n  // All byte-wide stores are splatable, even of arbitrary variables.\n  if (V->getType()->isIntegerTy(8))\n    return V;\n\n  LLVMContext &Ctx = V->getContext();\n\n  // Undef don't care.\n  auto *UndefInt8 = UndefValue::get(Type::getInt8Ty(Ctx));\n  if (isa<UndefValue>(V))\n    return UndefInt8;\n\n  // Return Undef for zero-sized type.\n  if (!DL.getTypeStoreSize(V->getType()).isNonZero())\n    return UndefInt8;\n\n  Constant *C = dyn_cast<Constant>(V);\n  if (!C) {\n    // Conceptually, we could handle things like:\n    //   %a = zext i8 %X to i16\n    //   %b = shl i16 %a, 8\n    //   %c = or i16 %a, %b\n    // but until there is an example that actually needs this, it doesn't seem\n    // worth worrying about.\n    return nullptr;\n  }\n\n  // Handle 'null' ConstantArrayZero etc.\n  if (C->isNullValue())\n    return Constant::getNullValue(Type::getInt8Ty(Ctx));\n\n  // Constant floating-point values can be handled as integer values if the\n  // corresponding integer value is \"byteable\".  An important case is 0.0.\n  if (ConstantFP *CFP = dyn_cast<ConstantFP>(C)) {\n    Type *Ty = nullptr;\n    if (CFP->getType()->isHalfTy())\n      Ty = Type::getInt16Ty(Ctx);\n    else if (CFP->getType()->isFloatTy())\n      Ty = Type::getInt32Ty(Ctx);\n    else if (CFP->getType()->isDoubleTy())\n      Ty = Type::getInt64Ty(Ctx);\n    // Don't handle long double formats, which have strange constraints.\n    return Ty ? isBytewiseValue(ConstantExpr::getBitCast(CFP, Ty), DL)\n              : nullptr;\n  }\n\n  // We can handle constant integers that are multiple of 8 bits.\n  if (ConstantInt *CI = dyn_cast<ConstantInt>(C)) {\n    if (CI->getBitWidth() % 8 == 0) {\n      assert(CI->getBitWidth() > 8 && \"8 bits should be handled above!\");\n      if (!CI->getValue().isSplat(8))\n        return nullptr;\n      return ConstantInt::get(Ctx, CI->getValue().trunc(8));\n    }\n  }\n\n  if (auto *CE = dyn_cast<ConstantExpr>(C)) {\n    if (CE->getOpcode() == Instruction::IntToPtr) {\n      if (auto *PtrTy = dyn_cast<PointerType>(CE->getType())) {\n        unsigned BitWidth = DL.getPointerSizeInBits(PtrTy->getAddressSpace());\n        return isBytewiseValue(\n            ConstantExpr::getIntegerCast(CE->getOperand(0),\n                                         Type::getIntNTy(Ctx, BitWidth), false),\n            DL);\n      }\n    }\n  }\n\n  auto Merge = [&](Value *LHS, Value *RHS) -> Value * {\n    if (LHS == RHS)\n      return LHS;\n    if (!LHS || !RHS)\n      return nullptr;\n    if (LHS == UndefInt8)\n      return RHS;\n    if (RHS == UndefInt8)\n      return LHS;\n    return nullptr;\n  };\n\n  if (ConstantDataSequential *CA = dyn_cast<ConstantDataSequential>(C)) {\n    Value *Val = UndefInt8;\n    for (unsigned I = 0, E = CA->getNumElements(); I != E; ++I)\n      if (!(Val = Merge(Val, isBytewiseValue(CA->getElementAsConstant(I), DL))))\n        return nullptr;\n    return Val;\n  }\n\n  if (isa<ConstantAggregate>(C)) {\n    Value *Val = UndefInt8;\n    for (unsigned I = 0, E = C->getNumOperands(); I != E; ++I)\n      if (!(Val = Merge(Val, isBytewiseValue(C->getOperand(I), DL))))\n        return nullptr;\n    return Val;\n  }\n\n  // Don't try to handle the handful of other constants.\n  return nullptr;\n}\n\n// This is the recursive version of BuildSubAggregate. It takes a few different\n// arguments. Idxs is the index within the nested struct From that we are\n// looking at now (which is of type IndexedType). IdxSkip is the number of\n// indices from Idxs that should be left out when inserting into the resulting\n// struct. To is the result struct built so far, new insertvalue instructions\n// build on that.\nstatic Value *BuildSubAggregate(Value *From, Value* To, Type *IndexedType,\n                                SmallVectorImpl<unsigned> &Idxs,\n                                unsigned IdxSkip,\n                                Instruction *InsertBefore) {\n  StructType *STy = dyn_cast<StructType>(IndexedType);\n  if (STy) {\n    // Save the original To argument so we can modify it\n    Value *OrigTo = To;\n    // General case, the type indexed by Idxs is a struct\n    for (unsigned i = 0, e = STy->getNumElements(); i != e; ++i) {\n      // Process each struct element recursively\n      Idxs.push_back(i);\n      Value *PrevTo = To;\n      To = BuildSubAggregate(From, To, STy->getElementType(i), Idxs, IdxSkip,\n                             InsertBefore);\n      Idxs.pop_back();\n      if (!To) {\n        // Couldn't find any inserted value for this index? Cleanup\n        while (PrevTo != OrigTo) {\n          InsertValueInst* Del = cast<InsertValueInst>(PrevTo);\n          PrevTo = Del->getAggregateOperand();\n          Del->eraseFromParent();\n        }\n        // Stop processing elements\n        break;\n      }\n    }\n    // If we successfully found a value for each of our subaggregates\n    if (To)\n      return To;\n  }\n  // Base case, the type indexed by SourceIdxs is not a struct, or not all of\n  // the struct's elements had a value that was inserted directly. In the latter\n  // case, perhaps we can't determine each of the subelements individually, but\n  // we might be able to find the complete struct somewhere.\n\n  // Find the value that is at that particular spot\n  Value *V = FindInsertedValue(From, Idxs);\n\n  if (!V)\n    return nullptr;\n\n  // Insert the value in the new (sub) aggregate\n  return InsertValueInst::Create(To, V, makeArrayRef(Idxs).slice(IdxSkip),\n                                 \"tmp\", InsertBefore);\n}\n\n// This helper takes a nested struct and extracts a part of it (which is again a\n// struct) into a new value. For example, given the struct:\n// { a, { b, { c, d }, e } }\n// and the indices \"1, 1\" this returns\n// { c, d }.\n//\n// It does this by inserting an insertvalue for each element in the resulting\n// struct, as opposed to just inserting a single struct. This will only work if\n// each of the elements of the substruct are known (ie, inserted into From by an\n// insertvalue instruction somewhere).\n//\n// All inserted insertvalue instructions are inserted before InsertBefore\nstatic Value *BuildSubAggregate(Value *From, ArrayRef<unsigned> idx_range,\n                                Instruction *InsertBefore) {\n  assert(InsertBefore && \"Must have someplace to insert!\");\n  Type *IndexedType = ExtractValueInst::getIndexedType(From->getType(),\n                                                             idx_range);\n  Value *To = UndefValue::get(IndexedType);\n  SmallVector<unsigned, 10> Idxs(idx_range.begin(), idx_range.end());\n  unsigned IdxSkip = Idxs.size();\n\n  return BuildSubAggregate(From, To, IndexedType, Idxs, IdxSkip, InsertBefore);\n}\n\n/// Given an aggregate and a sequence of indices, see if the scalar value\n/// indexed is already around as a register, for example if it was inserted\n/// directly into the aggregate.\n///\n/// If InsertBefore is not null, this function will duplicate (modified)\n/// insertvalues when a part of a nested struct is extracted.\nValue *llvm::FindInsertedValue(Value *V, ArrayRef<unsigned> idx_range,\n                               Instruction *InsertBefore) {\n  // Nothing to index? Just return V then (this is useful at the end of our\n  // recursion).\n  if (idx_range.empty())\n    return V;\n  // We have indices, so V should have an indexable type.\n  assert((V->getType()->isStructTy() || V->getType()->isArrayTy()) &&\n         \"Not looking at a struct or array?\");\n  assert(ExtractValueInst::getIndexedType(V->getType(), idx_range) &&\n         \"Invalid indices for type?\");\n\n  if (Constant *C = dyn_cast<Constant>(V)) {\n    C = C->getAggregateElement(idx_range[0]);\n    if (!C) return nullptr;\n    return FindInsertedValue(C, idx_range.slice(1), InsertBefore);\n  }\n\n  if (InsertValueInst *I = dyn_cast<InsertValueInst>(V)) {\n    // Loop the indices for the insertvalue instruction in parallel with the\n    // requested indices\n    const unsigned *req_idx = idx_range.begin();\n    for (const unsigned *i = I->idx_begin(), *e = I->idx_end();\n         i != e; ++i, ++req_idx) {\n      if (req_idx == idx_range.end()) {\n        // We can't handle this without inserting insertvalues\n        if (!InsertBefore)\n          return nullptr;\n\n        // The requested index identifies a part of a nested aggregate. Handle\n        // this specially. For example,\n        // %A = insertvalue { i32, {i32, i32 } } undef, i32 10, 1, 0\n        // %B = insertvalue { i32, {i32, i32 } } %A, i32 11, 1, 1\n        // %C = extractvalue {i32, { i32, i32 } } %B, 1\n        // This can be changed into\n        // %A = insertvalue {i32, i32 } undef, i32 10, 0\n        // %C = insertvalue {i32, i32 } %A, i32 11, 1\n        // which allows the unused 0,0 element from the nested struct to be\n        // removed.\n        return BuildSubAggregate(V, makeArrayRef(idx_range.begin(), req_idx),\n                                 InsertBefore);\n      }\n\n      // This insert value inserts something else than what we are looking for.\n      // See if the (aggregate) value inserted into has the value we are\n      // looking for, then.\n      if (*req_idx != *i)\n        return FindInsertedValue(I->getAggregateOperand(), idx_range,\n                                 InsertBefore);\n    }\n    // If we end up here, the indices of the insertvalue match with those\n    // requested (though possibly only partially). Now we recursively look at\n    // the inserted value, passing any remaining indices.\n    return FindInsertedValue(I->getInsertedValueOperand(),\n                             makeArrayRef(req_idx, idx_range.end()),\n                             InsertBefore);\n  }\n\n  if (ExtractValueInst *I = dyn_cast<ExtractValueInst>(V)) {\n    // If we're extracting a value from an aggregate that was extracted from\n    // something else, we can extract from that something else directly instead.\n    // However, we will need to chain I's indices with the requested indices.\n\n    // Calculate the number of indices required\n    unsigned size = I->getNumIndices() + idx_range.size();\n    // Allocate some space to put the new indices in\n    SmallVector<unsigned, 5> Idxs;\n    Idxs.reserve(size);\n    // Add indices from the extract value instruction\n    Idxs.append(I->idx_begin(), I->idx_end());\n\n    // Add requested indices\n    Idxs.append(idx_range.begin(), idx_range.end());\n\n    assert(Idxs.size() == size\n           && \"Number of indices added not correct?\");\n\n    return FindInsertedValue(I->getAggregateOperand(), Idxs, InsertBefore);\n  }\n  // Otherwise, we don't know (such as, extracting from a function return value\n  // or load instruction)\n  return nullptr;\n}\n\nbool llvm::isGEPBasedOnPointerToString(const GEPOperator *GEP,\n                                       unsigned CharSize) {\n  // Make sure the GEP has exactly three arguments.\n  if (GEP->getNumOperands() != 3)\n    return false;\n\n  // Make sure the index-ee is a pointer to array of \\p CharSize integers.\n  // CharSize.\n  ArrayType *AT = dyn_cast<ArrayType>(GEP->getSourceElementType());\n  if (!AT || !AT->getElementType()->isIntegerTy(CharSize))\n    return false;\n\n  // Check to make sure that the first operand of the GEP is an integer and\n  // has value 0 so that we are sure we're indexing into the initializer.\n  const ConstantInt *FirstIdx = dyn_cast<ConstantInt>(GEP->getOperand(1));\n  if (!FirstIdx || !FirstIdx->isZero())\n    return false;\n\n  return true;\n}\n\nbool llvm::getConstantDataArrayInfo(const Value *V,\n                                    ConstantDataArraySlice &Slice,\n                                    unsigned ElementSize, uint64_t Offset) {\n  assert(V);\n\n  // Look through bitcast instructions and geps.\n  V = V->stripPointerCasts();\n\n  // If the value is a GEP instruction or constant expression, treat it as an\n  // offset.\n  if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n    // The GEP operator should be based on a pointer to string constant, and is\n    // indexing into the string constant.\n    if (!isGEPBasedOnPointerToString(GEP, ElementSize))\n      return false;\n\n    // If the second index isn't a ConstantInt, then this is a variable index\n    // into the array.  If this occurs, we can't say anything meaningful about\n    // the string.\n    uint64_t StartIdx = 0;\n    if (const ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(2)))\n      StartIdx = CI->getZExtValue();\n    else\n      return false;\n    return getConstantDataArrayInfo(GEP->getOperand(0), Slice, ElementSize,\n                                    StartIdx + Offset);\n  }\n\n  // The GEP instruction, constant or instruction, must reference a global\n  // variable that is a constant and is initialized. The referenced constant\n  // initializer is the array that we'll use for optimization.\n  const GlobalVariable *GV = dyn_cast<GlobalVariable>(V);\n  if (!GV || !GV->isConstant() || !GV->hasDefinitiveInitializer())\n    return false;\n\n  const ConstantDataArray *Array;\n  ArrayType *ArrayTy;\n  if (GV->getInitializer()->isNullValue()) {\n    Type *GVTy = GV->getValueType();\n    if ( (ArrayTy = dyn_cast<ArrayType>(GVTy)) ) {\n      // A zeroinitializer for the array; there is no ConstantDataArray.\n      Array = nullptr;\n    } else {\n      const DataLayout &DL = GV->getParent()->getDataLayout();\n      uint64_t SizeInBytes = DL.getTypeStoreSize(GVTy).getFixedSize();\n      uint64_t Length = SizeInBytes / (ElementSize / 8);\n      if (Length <= Offset)\n        return false;\n\n      Slice.Array = nullptr;\n      Slice.Offset = 0;\n      Slice.Length = Length - Offset;\n      return true;\n    }\n  } else {\n    // This must be a ConstantDataArray.\n    Array = dyn_cast<ConstantDataArray>(GV->getInitializer());\n    if (!Array)\n      return false;\n    ArrayTy = Array->getType();\n  }\n  if (!ArrayTy->getElementType()->isIntegerTy(ElementSize))\n    return false;\n\n  uint64_t NumElts = ArrayTy->getArrayNumElements();\n  if (Offset > NumElts)\n    return false;\n\n  Slice.Array = Array;\n  Slice.Offset = Offset;\n  Slice.Length = NumElts - Offset;\n  return true;\n}\n\n/// This function computes the length of a null-terminated C string pointed to\n/// by V. If successful, it returns true and returns the string in Str.\n/// If unsuccessful, it returns false.\nbool llvm::getConstantStringInfo(const Value *V, StringRef &Str,\n                                 uint64_t Offset, bool TrimAtNul) {\n  ConstantDataArraySlice Slice;\n  if (!getConstantDataArrayInfo(V, Slice, 8, Offset))\n    return false;\n\n  if (Slice.Array == nullptr) {\n    if (TrimAtNul) {\n      Str = StringRef();\n      return true;\n    }\n    if (Slice.Length == 1) {\n      Str = StringRef(\"\", 1);\n      return true;\n    }\n    // We cannot instantiate a StringRef as we do not have an appropriate string\n    // of 0s at hand.\n    return false;\n  }\n\n  // Start out with the entire array in the StringRef.\n  Str = Slice.Array->getAsString();\n  // Skip over 'offset' bytes.\n  Str = Str.substr(Slice.Offset);\n\n  if (TrimAtNul) {\n    // Trim off the \\0 and anything after it.  If the array is not nul\n    // terminated, we just return the whole end of string.  The client may know\n    // some other way that the string is length-bound.\n    Str = Str.substr(0, Str.find('\\0'));\n  }\n  return true;\n}\n\n// These next two are very similar to the above, but also look through PHI\n// nodes.\n// TODO: See if we can integrate these two together.\n\n/// If we can compute the length of the string pointed to by\n/// the specified pointer, return 'len+1'.  If we can't, return 0.\nstatic uint64_t GetStringLengthH(const Value *V,\n                                 SmallPtrSetImpl<const PHINode*> &PHIs,\n                                 unsigned CharSize) {\n  // Look through noop bitcast instructions.\n  V = V->stripPointerCasts();\n\n  // If this is a PHI node, there are two cases: either we have already seen it\n  // or we haven't.\n  if (const PHINode *PN = dyn_cast<PHINode>(V)) {\n    if (!PHIs.insert(PN).second)\n      return ~0ULL;  // already in the set.\n\n    // If it was new, see if all the input strings are the same length.\n    uint64_t LenSoFar = ~0ULL;\n    for (Value *IncValue : PN->incoming_values()) {\n      uint64_t Len = GetStringLengthH(IncValue, PHIs, CharSize);\n      if (Len == 0) return 0; // Unknown length -> unknown.\n\n      if (Len == ~0ULL) continue;\n\n      if (Len != LenSoFar && LenSoFar != ~0ULL)\n        return 0;    // Disagree -> unknown.\n      LenSoFar = Len;\n    }\n\n    // Success, all agree.\n    return LenSoFar;\n  }\n\n  // strlen(select(c,x,y)) -> strlen(x) ^ strlen(y)\n  if (const SelectInst *SI = dyn_cast<SelectInst>(V)) {\n    uint64_t Len1 = GetStringLengthH(SI->getTrueValue(), PHIs, CharSize);\n    if (Len1 == 0) return 0;\n    uint64_t Len2 = GetStringLengthH(SI->getFalseValue(), PHIs, CharSize);\n    if (Len2 == 0) return 0;\n    if (Len1 == ~0ULL) return Len2;\n    if (Len2 == ~0ULL) return Len1;\n    if (Len1 != Len2) return 0;\n    return Len1;\n  }\n\n  // Otherwise, see if we can read the string.\n  ConstantDataArraySlice Slice;\n  if (!getConstantDataArrayInfo(V, Slice, CharSize))\n    return 0;\n\n  if (Slice.Array == nullptr)\n    return 1;\n\n  // Search for nul characters\n  unsigned NullIndex = 0;\n  for (unsigned E = Slice.Length; NullIndex < E; ++NullIndex) {\n    if (Slice.Array->getElementAsInteger(Slice.Offset + NullIndex) == 0)\n      break;\n  }\n\n  return NullIndex + 1;\n}\n\n/// If we can compute the length of the string pointed to by\n/// the specified pointer, return 'len+1'.  If we can't, return 0.\nuint64_t llvm::GetStringLength(const Value *V, unsigned CharSize) {\n  if (!V->getType()->isPointerTy())\n    return 0;\n\n  SmallPtrSet<const PHINode*, 32> PHIs;\n  uint64_t Len = GetStringLengthH(V, PHIs, CharSize);\n  // If Len is ~0ULL, we had an infinite phi cycle: this is dead code, so return\n  // an empty string as a length.\n  return Len == ~0ULL ? 1 : Len;\n}\n\nconst Value *\nllvm::getArgumentAliasingToReturnedPointer(const CallBase *Call,\n                                           bool MustPreserveNullness) {\n  assert(Call &&\n         \"getArgumentAliasingToReturnedPointer only works on nonnull calls\");\n  if (const Value *RV = Call->getReturnedArgOperand())\n    return RV;\n  // This can be used only as a aliasing property.\n  if (isIntrinsicReturningPointerAliasingArgumentWithoutCapturing(\n          Call, MustPreserveNullness))\n    return Call->getArgOperand(0);\n  return nullptr;\n}\n\nbool llvm::isIntrinsicReturningPointerAliasingArgumentWithoutCapturing(\n    const CallBase *Call, bool MustPreserveNullness) {\n  switch (Call->getIntrinsicID()) {\n  case Intrinsic::launder_invariant_group:\n  case Intrinsic::strip_invariant_group:\n  case Intrinsic::aarch64_irg:\n  case Intrinsic::aarch64_tagp:\n    return true;\n  case Intrinsic::ptrmask:\n    return !MustPreserveNullness;\n  default:\n    return false;\n  }\n}\n\n/// \\p PN defines a loop-variant pointer to an object.  Check if the\n/// previous iteration of the loop was referring to the same object as \\p PN.\nstatic bool isSameUnderlyingObjectInLoop(const PHINode *PN,\n                                         const LoopInfo *LI) {\n  // Find the loop-defined value.\n  Loop *L = LI->getLoopFor(PN->getParent());\n  if (PN->getNumIncomingValues() != 2)\n    return true;\n\n  // Find the value from previous iteration.\n  auto *PrevValue = dyn_cast<Instruction>(PN->getIncomingValue(0));\n  if (!PrevValue || LI->getLoopFor(PrevValue->getParent()) != L)\n    PrevValue = dyn_cast<Instruction>(PN->getIncomingValue(1));\n  if (!PrevValue || LI->getLoopFor(PrevValue->getParent()) != L)\n    return true;\n\n  // If a new pointer is loaded in the loop, the pointer references a different\n  // object in every iteration.  E.g.:\n  //    for (i)\n  //       int *p = a[i];\n  //       ...\n  if (auto *Load = dyn_cast<LoadInst>(PrevValue))\n    if (!L->isLoopInvariant(Load->getPointerOperand()))\n      return false;\n  return true;\n}\n\nValue *llvm::getUnderlyingObject(Value *V, unsigned MaxLookup) {\n  if (!V->getType()->isPointerTy())\n    return V;\n  for (unsigned Count = 0; MaxLookup == 0 || Count < MaxLookup; ++Count) {\n    if (GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n      V = GEP->getPointerOperand();\n    } else if (Operator::getOpcode(V) == Instruction::BitCast ||\n               Operator::getOpcode(V) == Instruction::AddrSpaceCast) {\n      V = cast<Operator>(V)->getOperand(0);\n      if (!V->getType()->isPointerTy())\n        return V;\n    } else if (GlobalAlias *GA = dyn_cast<GlobalAlias>(V)) {\n      if (GA->isInterposable())\n        return V;\n      V = GA->getAliasee();\n    } else {\n      if (auto *PHI = dyn_cast<PHINode>(V)) {\n        // Look through single-arg phi nodes created by LCSSA.\n        if (PHI->getNumIncomingValues() == 1) {\n          V = PHI->getIncomingValue(0);\n          continue;\n        }\n      } else if (auto *Call = dyn_cast<CallBase>(V)) {\n        // CaptureTracking can know about special capturing properties of some\n        // intrinsics like launder.invariant.group, that can't be expressed with\n        // the attributes, but have properties like returning aliasing pointer.\n        // Because some analysis may assume that nocaptured pointer is not\n        // returned from some special intrinsic (because function would have to\n        // be marked with returns attribute), it is crucial to use this function\n        // because it should be in sync with CaptureTracking. Not using it may\n        // cause weird miscompilations where 2 aliasing pointers are assumed to\n        // noalias.\n        if (auto *RP = getArgumentAliasingToReturnedPointer(Call, false)) {\n          V = RP;\n          continue;\n        }\n      }\n\n      return V;\n    }\n    assert(V->getType()->isPointerTy() && \"Unexpected operand type!\");\n  }\n  return V;\n}\n\nvoid llvm::getUnderlyingObjects(const Value *V,\n                                SmallVectorImpl<const Value *> &Objects,\n                                LoopInfo *LI, unsigned MaxLookup) {\n  SmallPtrSet<const Value *, 4> Visited;\n  SmallVector<const Value *, 4> Worklist;\n  Worklist.push_back(V);\n  do {\n    const Value *P = Worklist.pop_back_val();\n    P = getUnderlyingObject(P, MaxLookup);\n\n    if (!Visited.insert(P).second)\n      continue;\n\n    if (auto *SI = dyn_cast<SelectInst>(P)) {\n      Worklist.push_back(SI->getTrueValue());\n      Worklist.push_back(SI->getFalseValue());\n      continue;\n    }\n\n    if (auto *PN = dyn_cast<PHINode>(P)) {\n      // If this PHI changes the underlying object in every iteration of the\n      // loop, don't look through it.  Consider:\n      //   int **A;\n      //   for (i) {\n      //     Prev = Curr;     // Prev = PHI (Prev_0, Curr)\n      //     Curr = A[i];\n      //     *Prev, *Curr;\n      //\n      // Prev is tracking Curr one iteration behind so they refer to different\n      // underlying objects.\n      if (!LI || !LI->isLoopHeader(PN->getParent()) ||\n          isSameUnderlyingObjectInLoop(PN, LI))\n        append_range(Worklist, PN->incoming_values());\n      continue;\n    }\n\n    Objects.push_back(P);\n  } while (!Worklist.empty());\n}\n\n/// This is the function that does the work of looking through basic\n/// ptrtoint+arithmetic+inttoptr sequences.\nstatic const Value *getUnderlyingObjectFromInt(const Value *V) {\n  do {\n    if (const Operator *U = dyn_cast<Operator>(V)) {\n      // If we find a ptrtoint, we can transfer control back to the\n      // regular getUnderlyingObjectFromInt.\n      if (U->getOpcode() == Instruction::PtrToInt)\n        return U->getOperand(0);\n      // If we find an add of a constant, a multiplied value, or a phi, it's\n      // likely that the other operand will lead us to the base\n      // object. We don't have to worry about the case where the\n      // object address is somehow being computed by the multiply,\n      // because our callers only care when the result is an\n      // identifiable object.\n      if (U->getOpcode() != Instruction::Add ||\n          (!isa<ConstantInt>(U->getOperand(1)) &&\n           Operator::getOpcode(U->getOperand(1)) != Instruction::Mul &&\n           !isa<PHINode>(U->getOperand(1))))\n        return V;\n      V = U->getOperand(0);\n    } else {\n      return V;\n    }\n    assert(V->getType()->isIntegerTy() && \"Unexpected operand type!\");\n  } while (true);\n}\n\n/// This is a wrapper around getUnderlyingObjects and adds support for basic\n/// ptrtoint+arithmetic+inttoptr sequences.\n/// It returns false if unidentified object is found in getUnderlyingObjects.\nbool llvm::getUnderlyingObjectsForCodeGen(const Value *V,\n                                          SmallVectorImpl<Value *> &Objects) {\n  SmallPtrSet<const Value *, 16> Visited;\n  SmallVector<const Value *, 4> Working(1, V);\n  do {\n    V = Working.pop_back_val();\n\n    SmallVector<const Value *, 4> Objs;\n    getUnderlyingObjects(V, Objs);\n\n    for (const Value *V : Objs) {\n      if (!Visited.insert(V).second)\n        continue;\n      if (Operator::getOpcode(V) == Instruction::IntToPtr) {\n        const Value *O =\n          getUnderlyingObjectFromInt(cast<User>(V)->getOperand(0));\n        if (O->getType()->isPointerTy()) {\n          Working.push_back(O);\n          continue;\n        }\n      }\n      // If getUnderlyingObjects fails to find an identifiable object,\n      // getUnderlyingObjectsForCodeGen also fails for safety.\n      if (!isIdentifiedObject(V)) {\n        Objects.clear();\n        return false;\n      }\n      Objects.push_back(const_cast<Value *>(V));\n    }\n  } while (!Working.empty());\n  return true;\n}\n\nAllocaInst *llvm::findAllocaForValue(Value *V, bool OffsetZero) {\n  AllocaInst *Result = nullptr;\n  SmallPtrSet<Value *, 4> Visited;\n  SmallVector<Value *, 4> Worklist;\n\n  auto AddWork = [&](Value *V) {\n    if (Visited.insert(V).second)\n      Worklist.push_back(V);\n  };\n\n  AddWork(V);\n  do {\n    V = Worklist.pop_back_val();\n    assert(Visited.count(V));\n\n    if (AllocaInst *AI = dyn_cast<AllocaInst>(V)) {\n      if (Result && Result != AI)\n        return nullptr;\n      Result = AI;\n    } else if (CastInst *CI = dyn_cast<CastInst>(V)) {\n      AddWork(CI->getOperand(0));\n    } else if (PHINode *PN = dyn_cast<PHINode>(V)) {\n      for (Value *IncValue : PN->incoming_values())\n        AddWork(IncValue);\n    } else if (auto *SI = dyn_cast<SelectInst>(V)) {\n      AddWork(SI->getTrueValue());\n      AddWork(SI->getFalseValue());\n    } else if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(V)) {\n      if (OffsetZero && !GEP->hasAllZeroIndices())\n        return nullptr;\n      AddWork(GEP->getPointerOperand());\n    } else {\n      return nullptr;\n    }\n  } while (!Worklist.empty());\n\n  return Result;\n}\n\nstatic bool onlyUsedByLifetimeMarkersOrDroppableInstsHelper(\n    const Value *V, bool AllowLifetime, bool AllowDroppable) {\n  for (const User *U : V->users()) {\n    const IntrinsicInst *II = dyn_cast<IntrinsicInst>(U);\n    if (!II)\n      return false;\n\n    if (AllowLifetime && II->isLifetimeStartOrEnd())\n      continue;\n\n    if (AllowDroppable && II->isDroppable())\n      continue;\n\n    return false;\n  }\n  return true;\n}\n\nbool llvm::onlyUsedByLifetimeMarkers(const Value *V) {\n  return onlyUsedByLifetimeMarkersOrDroppableInstsHelper(\n      V, /* AllowLifetime */ true, /* AllowDroppable */ false);\n}\nbool llvm::onlyUsedByLifetimeMarkersOrDroppableInsts(const Value *V) {\n  return onlyUsedByLifetimeMarkersOrDroppableInstsHelper(\n      V, /* AllowLifetime */ true, /* AllowDroppable */ true);\n}\n\nbool llvm::mustSuppressSpeculation(const LoadInst &LI) {\n  if (!LI.isUnordered())\n    return true;\n  const Function &F = *LI.getFunction();\n  // Speculative load may create a race that did not exist in the source.\n  return F.hasFnAttribute(Attribute::SanitizeThread) ||\n    // Speculative load may load data from dirty regions.\n    F.hasFnAttribute(Attribute::SanitizeAddress) ||\n    F.hasFnAttribute(Attribute::SanitizeHWAddress);\n}\n\n\nbool llvm::isSafeToSpeculativelyExecute(const Value *V,\n                                        const Instruction *CtxI,\n                                        const DominatorTree *DT) {\n  const Operator *Inst = dyn_cast<Operator>(V);\n  if (!Inst)\n    return false;\n\n  for (unsigned i = 0, e = Inst->getNumOperands(); i != e; ++i)\n    if (Constant *C = dyn_cast<Constant>(Inst->getOperand(i)))\n      if (C->canTrap())\n        return false;\n\n  switch (Inst->getOpcode()) {\n  default:\n    return true;\n  case Instruction::UDiv:\n  case Instruction::URem: {\n    // x / y is undefined if y == 0.\n    const APInt *V;\n    if (match(Inst->getOperand(1), m_APInt(V)))\n      return *V != 0;\n    return false;\n  }\n  case Instruction::SDiv:\n  case Instruction::SRem: {\n    // x / y is undefined if y == 0 or x == INT_MIN and y == -1\n    const APInt *Numerator, *Denominator;\n    if (!match(Inst->getOperand(1), m_APInt(Denominator)))\n      return false;\n    // We cannot hoist this division if the denominator is 0.\n    if (*Denominator == 0)\n      return false;\n    // It's safe to hoist if the denominator is not 0 or -1.\n    if (!Denominator->isAllOnesValue())\n      return true;\n    // At this point we know that the denominator is -1.  It is safe to hoist as\n    // long we know that the numerator is not INT_MIN.\n    if (match(Inst->getOperand(0), m_APInt(Numerator)))\n      return !Numerator->isMinSignedValue();\n    // The numerator *might* be MinSignedValue.\n    return false;\n  }\n  case Instruction::Load: {\n    const LoadInst *LI = cast<LoadInst>(Inst);\n    if (mustSuppressSpeculation(*LI))\n      return false;\n    const DataLayout &DL = LI->getModule()->getDataLayout();\n    return isDereferenceableAndAlignedPointer(\n        LI->getPointerOperand(), LI->getType(), MaybeAlign(LI->getAlignment()),\n        DL, CtxI, DT);\n  }\n  case Instruction::Call: {\n    auto *CI = cast<const CallInst>(Inst);\n    const Function *Callee = CI->getCalledFunction();\n\n    // The called function could have undefined behavior or side-effects, even\n    // if marked readnone nounwind.\n    return Callee && Callee->isSpeculatable();\n  }\n  case Instruction::VAArg:\n  case Instruction::Alloca:\n  case Instruction::Invoke:\n  case Instruction::CallBr:\n  case Instruction::PHI:\n  case Instruction::Store:\n  case Instruction::Ret:\n  case Instruction::Br:\n  case Instruction::IndirectBr:\n  case Instruction::Switch:\n  case Instruction::Unreachable:\n  case Instruction::Fence:\n  case Instruction::AtomicRMW:\n  case Instruction::AtomicCmpXchg:\n  case Instruction::LandingPad:\n  case Instruction::Resume:\n  case Instruction::CatchSwitch:\n  case Instruction::CatchPad:\n  case Instruction::CatchRet:\n  case Instruction::CleanupPad:\n  case Instruction::CleanupRet:\n    return false; // Misc instructions which have effects\n  }\n}\n\nbool llvm::mayBeMemoryDependent(const Instruction &I) {\n  return I.mayReadOrWriteMemory() || !isSafeToSpeculativelyExecute(&I);\n}\n\n/// Convert ConstantRange OverflowResult into ValueTracking OverflowResult.\nstatic OverflowResult mapOverflowResult(ConstantRange::OverflowResult OR) {\n  switch (OR) {\n    case ConstantRange::OverflowResult::MayOverflow:\n      return OverflowResult::MayOverflow;\n    case ConstantRange::OverflowResult::AlwaysOverflowsLow:\n      return OverflowResult::AlwaysOverflowsLow;\n    case ConstantRange::OverflowResult::AlwaysOverflowsHigh:\n      return OverflowResult::AlwaysOverflowsHigh;\n    case ConstantRange::OverflowResult::NeverOverflows:\n      return OverflowResult::NeverOverflows;\n  }\n  llvm_unreachable(\"Unknown OverflowResult\");\n}\n\n/// Combine constant ranges from computeConstantRange() and computeKnownBits().\nstatic ConstantRange computeConstantRangeIncludingKnownBits(\n    const Value *V, bool ForSigned, const DataLayout &DL, unsigned Depth,\n    AssumptionCache *AC, const Instruction *CxtI, const DominatorTree *DT,\n    OptimizationRemarkEmitter *ORE = nullptr, bool UseInstrInfo = true) {\n  KnownBits Known = computeKnownBits(\n      V, DL, Depth, AC, CxtI, DT, ORE, UseInstrInfo);\n  ConstantRange CR1 = ConstantRange::fromKnownBits(Known, ForSigned);\n  ConstantRange CR2 = computeConstantRange(V, UseInstrInfo);\n  ConstantRange::PreferredRangeType RangeType =\n      ForSigned ? ConstantRange::Signed : ConstantRange::Unsigned;\n  return CR1.intersectWith(CR2, RangeType);\n}\n\nOverflowResult llvm::computeOverflowForUnsignedMul(\n    const Value *LHS, const Value *RHS, const DataLayout &DL,\n    AssumptionCache *AC, const Instruction *CxtI, const DominatorTree *DT,\n    bool UseInstrInfo) {\n  KnownBits LHSKnown = computeKnownBits(LHS, DL, /*Depth=*/0, AC, CxtI, DT,\n                                        nullptr, UseInstrInfo);\n  KnownBits RHSKnown = computeKnownBits(RHS, DL, /*Depth=*/0, AC, CxtI, DT,\n                                        nullptr, UseInstrInfo);\n  ConstantRange LHSRange = ConstantRange::fromKnownBits(LHSKnown, false);\n  ConstantRange RHSRange = ConstantRange::fromKnownBits(RHSKnown, false);\n  return mapOverflowResult(LHSRange.unsignedMulMayOverflow(RHSRange));\n}\n\nOverflowResult\nllvm::computeOverflowForSignedMul(const Value *LHS, const Value *RHS,\n                                  const DataLayout &DL, AssumptionCache *AC,\n                                  const Instruction *CxtI,\n                                  const DominatorTree *DT, bool UseInstrInfo) {\n  // Multiplying n * m significant bits yields a result of n + m significant\n  // bits. If the total number of significant bits does not exceed the\n  // result bit width (minus 1), there is no overflow.\n  // This means if we have enough leading sign bits in the operands\n  // we can guarantee that the result does not overflow.\n  // Ref: \"Hacker's Delight\" by Henry Warren\n  unsigned BitWidth = LHS->getType()->getScalarSizeInBits();\n\n  // Note that underestimating the number of sign bits gives a more\n  // conservative answer.\n  unsigned SignBits = ComputeNumSignBits(LHS, DL, 0, AC, CxtI, DT) +\n                      ComputeNumSignBits(RHS, DL, 0, AC, CxtI, DT);\n\n  // First handle the easy case: if we have enough sign bits there's\n  // definitely no overflow.\n  if (SignBits > BitWidth + 1)\n    return OverflowResult::NeverOverflows;\n\n  // There are two ambiguous cases where there can be no overflow:\n  //   SignBits == BitWidth + 1    and\n  //   SignBits == BitWidth\n  // The second case is difficult to check, therefore we only handle the\n  // first case.\n  if (SignBits == BitWidth + 1) {\n    // It overflows only when both arguments are negative and the true\n    // product is exactly the minimum negative number.\n    // E.g. mul i16 with 17 sign bits: 0xff00 * 0xff80 = 0x8000\n    // For simplicity we just check if at least one side is not negative.\n    KnownBits LHSKnown = computeKnownBits(LHS, DL, /*Depth=*/0, AC, CxtI, DT,\n                                          nullptr, UseInstrInfo);\n    KnownBits RHSKnown = computeKnownBits(RHS, DL, /*Depth=*/0, AC, CxtI, DT,\n                                          nullptr, UseInstrInfo);\n    if (LHSKnown.isNonNegative() || RHSKnown.isNonNegative())\n      return OverflowResult::NeverOverflows;\n  }\n  return OverflowResult::MayOverflow;\n}\n\nOverflowResult llvm::computeOverflowForUnsignedAdd(\n    const Value *LHS, const Value *RHS, const DataLayout &DL,\n    AssumptionCache *AC, const Instruction *CxtI, const DominatorTree *DT,\n    bool UseInstrInfo) {\n  ConstantRange LHSRange = computeConstantRangeIncludingKnownBits(\n      LHS, /*ForSigned=*/false, DL, /*Depth=*/0, AC, CxtI, DT,\n      nullptr, UseInstrInfo);\n  ConstantRange RHSRange = computeConstantRangeIncludingKnownBits(\n      RHS, /*ForSigned=*/false, DL, /*Depth=*/0, AC, CxtI, DT,\n      nullptr, UseInstrInfo);\n  return mapOverflowResult(LHSRange.unsignedAddMayOverflow(RHSRange));\n}\n\nstatic OverflowResult computeOverflowForSignedAdd(const Value *LHS,\n                                                  const Value *RHS,\n                                                  const AddOperator *Add,\n                                                  const DataLayout &DL,\n                                                  AssumptionCache *AC,\n                                                  const Instruction *CxtI,\n                                                  const DominatorTree *DT) {\n  if (Add && Add->hasNoSignedWrap()) {\n    return OverflowResult::NeverOverflows;\n  }\n\n  // If LHS and RHS each have at least two sign bits, the addition will look\n  // like\n  //\n  // XX..... +\n  // YY.....\n  //\n  // If the carry into the most significant position is 0, X and Y can't both\n  // be 1 and therefore the carry out of the addition is also 0.\n  //\n  // If the carry into the most significant position is 1, X and Y can't both\n  // be 0 and therefore the carry out of the addition is also 1.\n  //\n  // Since the carry into the most significant position is always equal to\n  // the carry out of the addition, there is no signed overflow.\n  if (ComputeNumSignBits(LHS, DL, 0, AC, CxtI, DT) > 1 &&\n      ComputeNumSignBits(RHS, DL, 0, AC, CxtI, DT) > 1)\n    return OverflowResult::NeverOverflows;\n\n  ConstantRange LHSRange = computeConstantRangeIncludingKnownBits(\n      LHS, /*ForSigned=*/true, DL, /*Depth=*/0, AC, CxtI, DT);\n  ConstantRange RHSRange = computeConstantRangeIncludingKnownBits(\n      RHS, /*ForSigned=*/true, DL, /*Depth=*/0, AC, CxtI, DT);\n  OverflowResult OR =\n      mapOverflowResult(LHSRange.signedAddMayOverflow(RHSRange));\n  if (OR != OverflowResult::MayOverflow)\n    return OR;\n\n  // The remaining code needs Add to be available. Early returns if not so.\n  if (!Add)\n    return OverflowResult::MayOverflow;\n\n  // If the sign of Add is the same as at least one of the operands, this add\n  // CANNOT overflow. If this can be determined from the known bits of the\n  // operands the above signedAddMayOverflow() check will have already done so.\n  // The only other way to improve on the known bits is from an assumption, so\n  // call computeKnownBitsFromAssume() directly.\n  bool LHSOrRHSKnownNonNegative =\n      (LHSRange.isAllNonNegative() || RHSRange.isAllNonNegative());\n  bool LHSOrRHSKnownNegative =\n      (LHSRange.isAllNegative() || RHSRange.isAllNegative());\n  if (LHSOrRHSKnownNonNegative || LHSOrRHSKnownNegative) {\n    KnownBits AddKnown(LHSRange.getBitWidth());\n    computeKnownBitsFromAssume(\n        Add, AddKnown, /*Depth=*/0, Query(DL, AC, CxtI, DT, true));\n    if ((AddKnown.isNonNegative() && LHSOrRHSKnownNonNegative) ||\n        (AddKnown.isNegative() && LHSOrRHSKnownNegative))\n      return OverflowResult::NeverOverflows;\n  }\n\n  return OverflowResult::MayOverflow;\n}\n\nOverflowResult llvm::computeOverflowForUnsignedSub(const Value *LHS,\n                                                   const Value *RHS,\n                                                   const DataLayout &DL,\n                                                   AssumptionCache *AC,\n                                                   const Instruction *CxtI,\n                                                   const DominatorTree *DT) {\n  // Checking for conditions implied by dominating conditions may be expensive.\n  // Limit it to usub_with_overflow calls for now.\n  if (match(CxtI,\n            m_Intrinsic<Intrinsic::usub_with_overflow>(m_Value(), m_Value())))\n    if (auto C =\n            isImpliedByDomCondition(CmpInst::ICMP_UGE, LHS, RHS, CxtI, DL)) {\n      if (*C)\n        return OverflowResult::NeverOverflows;\n      return OverflowResult::AlwaysOverflowsLow;\n    }\n  ConstantRange LHSRange = computeConstantRangeIncludingKnownBits(\n      LHS, /*ForSigned=*/false, DL, /*Depth=*/0, AC, CxtI, DT);\n  ConstantRange RHSRange = computeConstantRangeIncludingKnownBits(\n      RHS, /*ForSigned=*/false, DL, /*Depth=*/0, AC, CxtI, DT);\n  return mapOverflowResult(LHSRange.unsignedSubMayOverflow(RHSRange));\n}\n\nOverflowResult llvm::computeOverflowForSignedSub(const Value *LHS,\n                                                 const Value *RHS,\n                                                 const DataLayout &DL,\n                                                 AssumptionCache *AC,\n                                                 const Instruction *CxtI,\n                                                 const DominatorTree *DT) {\n  // If LHS and RHS each have at least two sign bits, the subtraction\n  // cannot overflow.\n  if (ComputeNumSignBits(LHS, DL, 0, AC, CxtI, DT) > 1 &&\n      ComputeNumSignBits(RHS, DL, 0, AC, CxtI, DT) > 1)\n    return OverflowResult::NeverOverflows;\n\n  ConstantRange LHSRange = computeConstantRangeIncludingKnownBits(\n      LHS, /*ForSigned=*/true, DL, /*Depth=*/0, AC, CxtI, DT);\n  ConstantRange RHSRange = computeConstantRangeIncludingKnownBits(\n      RHS, /*ForSigned=*/true, DL, /*Depth=*/0, AC, CxtI, DT);\n  return mapOverflowResult(LHSRange.signedSubMayOverflow(RHSRange));\n}\n\nbool llvm::isOverflowIntrinsicNoWrap(const WithOverflowInst *WO,\n                                     const DominatorTree &DT) {\n  SmallVector<const BranchInst *, 2> GuardingBranches;\n  SmallVector<const ExtractValueInst *, 2> Results;\n\n  for (const User *U : WO->users()) {\n    if (const auto *EVI = dyn_cast<ExtractValueInst>(U)) {\n      assert(EVI->getNumIndices() == 1 && \"Obvious from CI's type\");\n\n      if (EVI->getIndices()[0] == 0)\n        Results.push_back(EVI);\n      else {\n        assert(EVI->getIndices()[0] == 1 && \"Obvious from CI's type\");\n\n        for (const auto *U : EVI->users())\n          if (const auto *B = dyn_cast<BranchInst>(U)) {\n            assert(B->isConditional() && \"How else is it using an i1?\");\n            GuardingBranches.push_back(B);\n          }\n      }\n    } else {\n      // We are using the aggregate directly in a way we don't want to analyze\n      // here (storing it to a global, say).\n      return false;\n    }\n  }\n\n  auto AllUsesGuardedByBranch = [&](const BranchInst *BI) {\n    BasicBlockEdge NoWrapEdge(BI->getParent(), BI->getSuccessor(1));\n    if (!NoWrapEdge.isSingleEdge())\n      return false;\n\n    // Check if all users of the add are provably no-wrap.\n    for (const auto *Result : Results) {\n      // If the extractvalue itself is not executed on overflow, the we don't\n      // need to check each use separately, since domination is transitive.\n      if (DT.dominates(NoWrapEdge, Result->getParent()))\n        continue;\n\n      for (auto &RU : Result->uses())\n        if (!DT.dominates(NoWrapEdge, RU))\n          return false;\n    }\n\n    return true;\n  };\n\n  return llvm::any_of(GuardingBranches, AllUsesGuardedByBranch);\n}\n\nstatic bool canCreateUndefOrPoison(const Operator *Op, bool PoisonOnly) {\n  // See whether I has flags that may create poison\n  if (const auto *OvOp = dyn_cast<OverflowingBinaryOperator>(Op)) {\n    if (OvOp->hasNoSignedWrap() || OvOp->hasNoUnsignedWrap())\n      return true;\n  }\n  if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(Op))\n    if (ExactOp->isExact())\n      return true;\n  if (const auto *FP = dyn_cast<FPMathOperator>(Op)) {\n    auto FMF = FP->getFastMathFlags();\n    if (FMF.noNaNs() || FMF.noInfs())\n      return true;\n  }\n\n  unsigned Opcode = Op->getOpcode();\n\n  // Check whether opcode is a poison/undef-generating operation\n  switch (Opcode) {\n  case Instruction::Shl:\n  case Instruction::AShr:\n  case Instruction::LShr: {\n    // Shifts return poison if shiftwidth is larger than the bitwidth.\n    if (auto *C = dyn_cast<Constant>(Op->getOperand(1))) {\n      SmallVector<Constant *, 4> ShiftAmounts;\n      if (auto *FVTy = dyn_cast<FixedVectorType>(C->getType())) {\n        unsigned NumElts = FVTy->getNumElements();\n        for (unsigned i = 0; i < NumElts; ++i)\n          ShiftAmounts.push_back(C->getAggregateElement(i));\n      } else if (isa<ScalableVectorType>(C->getType()))\n        return true; // Can't tell, just return true to be safe\n      else\n        ShiftAmounts.push_back(C);\n\n      bool Safe = llvm::all_of(ShiftAmounts, [](Constant *C) {\n        auto *CI = dyn_cast_or_null<ConstantInt>(C);\n        return CI && CI->getValue().ult(C->getType()->getIntegerBitWidth());\n      });\n      return !Safe;\n    }\n    return true;\n  }\n  case Instruction::FPToSI:\n  case Instruction::FPToUI:\n    // fptosi/ui yields poison if the resulting value does not fit in the\n    // destination type.\n    return true;\n  case Instruction::Call:\n  case Instruction::CallBr:\n  case Instruction::Invoke: {\n    const auto *CB = cast<CallBase>(Op);\n    return !CB->hasRetAttr(Attribute::NoUndef);\n  }\n  case Instruction::InsertElement:\n  case Instruction::ExtractElement: {\n    // If index exceeds the length of the vector, it returns poison\n    auto *VTy = cast<VectorType>(Op->getOperand(0)->getType());\n    unsigned IdxOp = Op->getOpcode() == Instruction::InsertElement ? 2 : 1;\n    auto *Idx = dyn_cast<ConstantInt>(Op->getOperand(IdxOp));\n    if (!Idx || Idx->getValue().uge(VTy->getElementCount().getKnownMinValue()))\n      return true;\n    return false;\n  }\n  case Instruction::ShuffleVector: {\n    // shufflevector may return undef.\n    if (PoisonOnly)\n      return false;\n    ArrayRef<int> Mask = isa<ConstantExpr>(Op)\n                             ? cast<ConstantExpr>(Op)->getShuffleMask()\n                             : cast<ShuffleVectorInst>(Op)->getShuffleMask();\n    return is_contained(Mask, UndefMaskElem);\n  }\n  case Instruction::FNeg:\n  case Instruction::PHI:\n  case Instruction::Select:\n  case Instruction::URem:\n  case Instruction::SRem:\n  case Instruction::ExtractValue:\n  case Instruction::InsertValue:\n  case Instruction::Freeze:\n  case Instruction::ICmp:\n  case Instruction::FCmp:\n    return false;\n  case Instruction::GetElementPtr: {\n    const auto *GEP = cast<GEPOperator>(Op);\n    return GEP->isInBounds();\n  }\n  default: {\n    const auto *CE = dyn_cast<ConstantExpr>(Op);\n    if (isa<CastInst>(Op) || (CE && CE->isCast()))\n      return false;\n    else if (Instruction::isBinaryOp(Opcode))\n      return false;\n    // Be conservative and return true.\n    return true;\n  }\n  }\n}\n\nbool llvm::canCreateUndefOrPoison(const Operator *Op) {\n  return ::canCreateUndefOrPoison(Op, /*PoisonOnly=*/false);\n}\n\nbool llvm::canCreatePoison(const Operator *Op) {\n  return ::canCreateUndefOrPoison(Op, /*PoisonOnly=*/true);\n}\n\nstatic bool directlyImpliesPoison(const Value *ValAssumedPoison,\n                                  const Value *V, unsigned Depth) {\n  if (ValAssumedPoison == V)\n    return true;\n\n  const unsigned MaxDepth = 2;\n  if (Depth >= MaxDepth)\n    return false;\n\n  const auto *I = dyn_cast<Instruction>(V);\n  if (I && propagatesPoison(cast<Operator>(I))) {\n    return any_of(I->operands(), [=](const Value *Op) {\n      return directlyImpliesPoison(ValAssumedPoison, Op, Depth + 1);\n    });\n  }\n  return false;\n}\n\nstatic bool impliesPoison(const Value *ValAssumedPoison, const Value *V,\n                          unsigned Depth) {\n  if (isGuaranteedNotToBeUndefOrPoison(ValAssumedPoison))\n    return true;\n\n  if (directlyImpliesPoison(ValAssumedPoison, V, /* Depth */ 0))\n    return true;\n\n  const unsigned MaxDepth = 2;\n  if (Depth >= MaxDepth)\n    return false;\n\n  const auto *I = dyn_cast<Instruction>(ValAssumedPoison);\n  if (I && !canCreatePoison(cast<Operator>(I))) {\n    return all_of(I->operands(), [=](const Value *Op) {\n      return impliesPoison(Op, V, Depth + 1);\n    });\n  }\n  return false;\n}\n\nbool llvm::impliesPoison(const Value *ValAssumedPoison, const Value *V) {\n  return ::impliesPoison(ValAssumedPoison, V, /* Depth */ 0);\n}\n\nstatic bool programUndefinedIfUndefOrPoison(const Value *V,\n                                            bool PoisonOnly);\n\nstatic bool isGuaranteedNotToBeUndefOrPoison(const Value *V,\n                                             AssumptionCache *AC,\n                                             const Instruction *CtxI,\n                                             const DominatorTree *DT,\n                                             unsigned Depth, bool PoisonOnly) {\n  if (Depth >= MaxAnalysisRecursionDepth)\n    return false;\n\n  if (isa<MetadataAsValue>(V))\n    return false;\n\n  if (const auto *A = dyn_cast<Argument>(V)) {\n    if (A->hasAttribute(Attribute::NoUndef))\n      return true;\n  }\n\n  if (auto *C = dyn_cast<Constant>(V)) {\n    if (isa<UndefValue>(C))\n      return PoisonOnly && !isa<PoisonValue>(C);\n\n    if (isa<ConstantInt>(C) || isa<GlobalVariable>(C) || isa<ConstantFP>(V) ||\n        isa<ConstantPointerNull>(C) || isa<Function>(C))\n      return true;\n\n    if (C->getType()->isVectorTy() && !isa<ConstantExpr>(C))\n      return (PoisonOnly ? !C->containsPoisonElement()\n                         : !C->containsUndefOrPoisonElement()) &&\n             !C->containsConstantExpression();\n  }\n\n  // Strip cast operations from a pointer value.\n  // Note that stripPointerCastsSameRepresentation can strip off getelementptr\n  // inbounds with zero offset. To guarantee that the result isn't poison, the\n  // stripped pointer is checked as it has to be pointing into an allocated\n  // object or be null `null` to ensure `inbounds` getelement pointers with a\n  // zero offset could not produce poison.\n  // It can strip off addrspacecast that do not change bit representation as\n  // well. We believe that such addrspacecast is equivalent to no-op.\n  auto *StrippedV = V->stripPointerCastsSameRepresentation();\n  if (isa<AllocaInst>(StrippedV) || isa<GlobalVariable>(StrippedV) ||\n      isa<Function>(StrippedV) || isa<ConstantPointerNull>(StrippedV))\n    return true;\n\n  auto OpCheck = [&](const Value *V) {\n    return isGuaranteedNotToBeUndefOrPoison(V, AC, CtxI, DT, Depth + 1,\n                                            PoisonOnly);\n  };\n\n  if (auto *Opr = dyn_cast<Operator>(V)) {\n    // If the value is a freeze instruction, then it can never\n    // be undef or poison.\n    if (isa<FreezeInst>(V))\n      return true;\n\n    if (const auto *CB = dyn_cast<CallBase>(V)) {\n      if (CB->hasRetAttr(Attribute::NoUndef))\n        return true;\n    }\n\n    if (const auto *PN = dyn_cast<PHINode>(V)) {\n      unsigned Num = PN->getNumIncomingValues();\n      bool IsWellDefined = true;\n      for (unsigned i = 0; i < Num; ++i) {\n        auto *TI = PN->getIncomingBlock(i)->getTerminator();\n        if (!isGuaranteedNotToBeUndefOrPoison(PN->getIncomingValue(i), AC, TI,\n                                              DT, Depth + 1, PoisonOnly)) {\n          IsWellDefined = false;\n          break;\n        }\n      }\n      if (IsWellDefined)\n        return true;\n    } else if (!canCreateUndefOrPoison(Opr) && all_of(Opr->operands(), OpCheck))\n      return true;\n  }\n\n  if (auto *I = dyn_cast<LoadInst>(V))\n    if (I->getMetadata(LLVMContext::MD_noundef))\n      return true;\n\n  if (programUndefinedIfUndefOrPoison(V, PoisonOnly))\n    return true;\n\n  // CxtI may be null or a cloned instruction.\n  if (!CtxI || !CtxI->getParent() || !DT)\n    return false;\n\n  auto *DNode = DT->getNode(CtxI->getParent());\n  if (!DNode)\n    // Unreachable block\n    return false;\n\n  // If V is used as a branch condition before reaching CtxI, V cannot be\n  // undef or poison.\n  //   br V, BB1, BB2\n  // BB1:\n  //   CtxI ; V cannot be undef or poison here\n  auto *Dominator = DNode->getIDom();\n  while (Dominator) {\n    auto *TI = Dominator->getBlock()->getTerminator();\n\n    Value *Cond = nullptr;\n    if (auto BI = dyn_cast<BranchInst>(TI)) {\n      if (BI->isConditional())\n        Cond = BI->getCondition();\n    } else if (auto SI = dyn_cast<SwitchInst>(TI)) {\n      Cond = SI->getCondition();\n    }\n\n    if (Cond) {\n      if (Cond == V)\n        return true;\n      else if (PoisonOnly && isa<Operator>(Cond)) {\n        // For poison, we can analyze further\n        auto *Opr = cast<Operator>(Cond);\n        if (propagatesPoison(Opr) && is_contained(Opr->operand_values(), V))\n          return true;\n      }\n    }\n\n    Dominator = Dominator->getIDom();\n  }\n\n  SmallVector<Attribute::AttrKind, 2> AttrKinds{Attribute::NoUndef};\n  if (getKnowledgeValidInContext(V, AttrKinds, CtxI, DT, AC))\n    return true;\n\n  return false;\n}\n\nbool llvm::isGuaranteedNotToBeUndefOrPoison(const Value *V, AssumptionCache *AC,\n                                            const Instruction *CtxI,\n                                            const DominatorTree *DT,\n                                            unsigned Depth) {\n  return ::isGuaranteedNotToBeUndefOrPoison(V, AC, CtxI, DT, Depth, false);\n}\n\nbool llvm::isGuaranteedNotToBePoison(const Value *V, AssumptionCache *AC,\n                                     const Instruction *CtxI,\n                                     const DominatorTree *DT, unsigned Depth) {\n  return ::isGuaranteedNotToBeUndefOrPoison(V, AC, CtxI, DT, Depth, true);\n}\n\nOverflowResult llvm::computeOverflowForSignedAdd(const AddOperator *Add,\n                                                 const DataLayout &DL,\n                                                 AssumptionCache *AC,\n                                                 const Instruction *CxtI,\n                                                 const DominatorTree *DT) {\n  return ::computeOverflowForSignedAdd(Add->getOperand(0), Add->getOperand(1),\n                                       Add, DL, AC, CxtI, DT);\n}\n\nOverflowResult llvm::computeOverflowForSignedAdd(const Value *LHS,\n                                                 const Value *RHS,\n                                                 const DataLayout &DL,\n                                                 AssumptionCache *AC,\n                                                 const Instruction *CxtI,\n                                                 const DominatorTree *DT) {\n  return ::computeOverflowForSignedAdd(LHS, RHS, nullptr, DL, AC, CxtI, DT);\n}\n\nbool llvm::isGuaranteedToTransferExecutionToSuccessor(const Instruction *I) {\n  // Note: An atomic operation isn't guaranteed to return in a reasonable amount\n  // of time because it's possible for another thread to interfere with it for an\n  // arbitrary length of time, but programs aren't allowed to rely on that.\n\n  // If there is no successor, then execution can't transfer to it.\n  if (const auto *CRI = dyn_cast<CleanupReturnInst>(I))\n    return !CRI->unwindsToCaller();\n  if (const auto *CatchSwitch = dyn_cast<CatchSwitchInst>(I))\n    return !CatchSwitch->unwindsToCaller();\n  if (isa<ResumeInst>(I))\n    return false;\n  if (isa<ReturnInst>(I))\n    return false;\n  if (isa<UnreachableInst>(I))\n    return false;\n\n  // Calls can throw, or contain an infinite loop, or kill the process.\n  if (const auto *CB = dyn_cast<CallBase>(I)) {\n    // Call sites that throw have implicit non-local control flow.\n    if (!CB->doesNotThrow())\n      return false;\n\n    // A function which doens't throw and has \"willreturn\" attribute will\n    // always return.\n    if (CB->hasFnAttr(Attribute::WillReturn))\n      return true;\n\n    // FIXME: Temporarily assume that all side-effect free intrinsics will\n    // return. Remove this workaround once all intrinsics are appropriately\n    // annotated.\n    return isa<IntrinsicInst>(CB) && CB->onlyReadsMemory();\n  }\n\n  // Other instructions return normally.\n  return true;\n}\n\nbool llvm::isGuaranteedToTransferExecutionToSuccessor(const BasicBlock *BB) {\n  // TODO: This is slightly conservative for invoke instruction since exiting\n  // via an exception *is* normal control for them.\n  for (auto I = BB->begin(), E = BB->end(); I != E; ++I)\n    if (!isGuaranteedToTransferExecutionToSuccessor(&*I))\n      return false;\n  return true;\n}\n\nbool llvm::isGuaranteedToExecuteForEveryIteration(const Instruction *I,\n                                                  const Loop *L) {\n  // The loop header is guaranteed to be executed for every iteration.\n  //\n  // FIXME: Relax this constraint to cover all basic blocks that are\n  // guaranteed to be executed at every iteration.\n  if (I->getParent() != L->getHeader()) return false;\n\n  for (const Instruction &LI : *L->getHeader()) {\n    if (&LI == I) return true;\n    if (!isGuaranteedToTransferExecutionToSuccessor(&LI)) return false;\n  }\n  llvm_unreachable(\"Instruction not contained in its own parent basic block.\");\n}\n\nbool llvm::propagatesPoison(const Operator *I) {\n  switch (I->getOpcode()) {\n  case Instruction::Freeze:\n  case Instruction::Select:\n  case Instruction::PHI:\n  case Instruction::Call:\n  case Instruction::Invoke:\n    return false;\n  case Instruction::ICmp:\n  case Instruction::FCmp:\n  case Instruction::GetElementPtr:\n    return true;\n  default:\n    if (isa<BinaryOperator>(I) || isa<UnaryOperator>(I) || isa<CastInst>(I))\n      return true;\n\n    // Be conservative and return false.\n    return false;\n  }\n}\n\nvoid llvm::getGuaranteedNonPoisonOps(const Instruction *I,\n                                     SmallPtrSetImpl<const Value *> &Operands) {\n  switch (I->getOpcode()) {\n    case Instruction::Store:\n      Operands.insert(cast<StoreInst>(I)->getPointerOperand());\n      break;\n\n    case Instruction::Load:\n      Operands.insert(cast<LoadInst>(I)->getPointerOperand());\n      break;\n\n    case Instruction::AtomicCmpXchg:\n      Operands.insert(cast<AtomicCmpXchgInst>(I)->getPointerOperand());\n      break;\n\n    case Instruction::AtomicRMW:\n      Operands.insert(cast<AtomicRMWInst>(I)->getPointerOperand());\n      break;\n\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n      Operands.insert(I->getOperand(1));\n      break;\n\n    case Instruction::Call:\n    case Instruction::Invoke: {\n      const CallBase *CB = cast<CallBase>(I);\n      if (CB->isIndirectCall())\n        Operands.insert(CB->getCalledOperand());\n      for (unsigned i = 0; i < CB->arg_size(); ++i) {\n        if (CB->paramHasAttr(i, Attribute::NoUndef))\n          Operands.insert(CB->getArgOperand(i));\n      }\n      break;\n    }\n\n    default:\n      break;\n  }\n}\n\nbool llvm::mustTriggerUB(const Instruction *I,\n                         const SmallSet<const Value *, 16>& KnownPoison) {\n  SmallPtrSet<const Value *, 4> NonPoisonOps;\n  getGuaranteedNonPoisonOps(I, NonPoisonOps);\n\n  for (const auto *V : NonPoisonOps)\n    if (KnownPoison.count(V))\n      return true;\n\n  return false;\n}\n\nstatic bool programUndefinedIfUndefOrPoison(const Value *V,\n                                            bool PoisonOnly) {\n  // We currently only look for uses of values within the same basic\n  // block, as that makes it easier to guarantee that the uses will be\n  // executed given that Inst is executed.\n  //\n  // FIXME: Expand this to consider uses beyond the same basic block. To do\n  // this, look out for the distinction between post-dominance and strong\n  // post-dominance.\n  const BasicBlock *BB = nullptr;\n  BasicBlock::const_iterator Begin;\n  if (const auto *Inst = dyn_cast<Instruction>(V)) {\n    BB = Inst->getParent();\n    Begin = Inst->getIterator();\n    Begin++;\n  } else if (const auto *Arg = dyn_cast<Argument>(V)) {\n    BB = &Arg->getParent()->getEntryBlock();\n    Begin = BB->begin();\n  } else {\n    return false;\n  }\n\n  BasicBlock::const_iterator End = BB->end();\n\n  if (!PoisonOnly) {\n    // Be conservative & just check whether a value is passed to a noundef\n    // argument.\n    // Instructions that raise UB with a poison operand are well-defined\n    // or have unclear semantics when the input is partially undef.\n    // For example, 'udiv x, (undef | 1)' isn't UB.\n\n    for (auto &I : make_range(Begin, End)) {\n      if (const auto *CB = dyn_cast<CallBase>(&I)) {\n        for (unsigned i = 0; i < CB->arg_size(); ++i) {\n          if (CB->paramHasAttr(i, Attribute::NoUndef) &&\n              CB->getArgOperand(i) == V)\n            return true;\n        }\n      }\n      if (!isGuaranteedToTransferExecutionToSuccessor(&I))\n        break;\n    }\n    return false;\n  }\n\n  // Set of instructions that we have proved will yield poison if Inst\n  // does.\n  SmallSet<const Value *, 16> YieldsPoison;\n  SmallSet<const BasicBlock *, 4> Visited;\n\n  YieldsPoison.insert(V);\n  auto Propagate = [&](const User *User) {\n    if (propagatesPoison(cast<Operator>(User)))\n      YieldsPoison.insert(User);\n  };\n  for_each(V->users(), Propagate);\n  Visited.insert(BB);\n\n  unsigned Iter = 0;\n  while (Iter++ < MaxAnalysisRecursionDepth) {\n    for (auto &I : make_range(Begin, End)) {\n      if (mustTriggerUB(&I, YieldsPoison))\n        return true;\n      if (!isGuaranteedToTransferExecutionToSuccessor(&I))\n        return false;\n\n      // Mark poison that propagates from I through uses of I.\n      if (YieldsPoison.count(&I))\n        for_each(I.users(), Propagate);\n    }\n\n    if (auto *NextBB = BB->getSingleSuccessor()) {\n      if (Visited.insert(NextBB).second) {\n        BB = NextBB;\n        Begin = BB->getFirstNonPHI()->getIterator();\n        End = BB->end();\n        continue;\n      }\n    }\n\n    break;\n  }\n  return false;\n}\n\nbool llvm::programUndefinedIfUndefOrPoison(const Instruction *Inst) {\n  return ::programUndefinedIfUndefOrPoison(Inst, false);\n}\n\nbool llvm::programUndefinedIfPoison(const Instruction *Inst) {\n  return ::programUndefinedIfUndefOrPoison(Inst, true);\n}\n\nstatic bool isKnownNonNaN(const Value *V, FastMathFlags FMF) {\n  if (FMF.noNaNs())\n    return true;\n\n  if (auto *C = dyn_cast<ConstantFP>(V))\n    return !C->isNaN();\n\n  if (auto *C = dyn_cast<ConstantDataVector>(V)) {\n    if (!C->getElementType()->isFloatingPointTy())\n      return false;\n    for (unsigned I = 0, E = C->getNumElements(); I < E; ++I) {\n      if (C->getElementAsAPFloat(I).isNaN())\n        return false;\n    }\n    return true;\n  }\n\n  if (isa<ConstantAggregateZero>(V))\n    return true;\n\n  return false;\n}\n\nstatic bool isKnownNonZero(const Value *V) {\n  if (auto *C = dyn_cast<ConstantFP>(V))\n    return !C->isZero();\n\n  if (auto *C = dyn_cast<ConstantDataVector>(V)) {\n    if (!C->getElementType()->isFloatingPointTy())\n      return false;\n    for (unsigned I = 0, E = C->getNumElements(); I < E; ++I) {\n      if (C->getElementAsAPFloat(I).isZero())\n        return false;\n    }\n    return true;\n  }\n\n  return false;\n}\n\n/// Match clamp pattern for float types without care about NaNs or signed zeros.\n/// Given non-min/max outer cmp/select from the clamp pattern this\n/// function recognizes if it can be substitued by a \"canonical\" min/max\n/// pattern.\nstatic SelectPatternResult matchFastFloatClamp(CmpInst::Predicate Pred,\n                                               Value *CmpLHS, Value *CmpRHS,\n                                               Value *TrueVal, Value *FalseVal,\n                                               Value *&LHS, Value *&RHS) {\n  // Try to match\n  //   X < C1 ? C1 : Min(X, C2) --> Max(C1, Min(X, C2))\n  //   X > C1 ? C1 : Max(X, C2) --> Min(C1, Max(X, C2))\n  // and return description of the outer Max/Min.\n\n  // First, check if select has inverse order:\n  if (CmpRHS == FalseVal) {\n    std::swap(TrueVal, FalseVal);\n    Pred = CmpInst::getInversePredicate(Pred);\n  }\n\n  // Assume success now. If there's no match, callers should not use these anyway.\n  LHS = TrueVal;\n  RHS = FalseVal;\n\n  const APFloat *FC1;\n  if (CmpRHS != TrueVal || !match(CmpRHS, m_APFloat(FC1)) || !FC1->isFinite())\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  const APFloat *FC2;\n  switch (Pred) {\n  case CmpInst::FCMP_OLT:\n  case CmpInst::FCMP_OLE:\n  case CmpInst::FCMP_ULT:\n  case CmpInst::FCMP_ULE:\n    if (match(FalseVal,\n              m_CombineOr(m_OrdFMin(m_Specific(CmpLHS), m_APFloat(FC2)),\n                          m_UnordFMin(m_Specific(CmpLHS), m_APFloat(FC2)))) &&\n        *FC1 < *FC2)\n      return {SPF_FMAXNUM, SPNB_RETURNS_ANY, false};\n    break;\n  case CmpInst::FCMP_OGT:\n  case CmpInst::FCMP_OGE:\n  case CmpInst::FCMP_UGT:\n  case CmpInst::FCMP_UGE:\n    if (match(FalseVal,\n              m_CombineOr(m_OrdFMax(m_Specific(CmpLHS), m_APFloat(FC2)),\n                          m_UnordFMax(m_Specific(CmpLHS), m_APFloat(FC2)))) &&\n        *FC1 > *FC2)\n      return {SPF_FMINNUM, SPNB_RETURNS_ANY, false};\n    break;\n  default:\n    break;\n  }\n\n  return {SPF_UNKNOWN, SPNB_NA, false};\n}\n\n/// Recognize variations of:\n///   CLAMP(v,l,h) ==> ((v) < (l) ? (l) : ((v) > (h) ? (h) : (v)))\nstatic SelectPatternResult matchClamp(CmpInst::Predicate Pred,\n                                      Value *CmpLHS, Value *CmpRHS,\n                                      Value *TrueVal, Value *FalseVal) {\n  // Swap the select operands and predicate to match the patterns below.\n  if (CmpRHS != TrueVal) {\n    Pred = ICmpInst::getSwappedPredicate(Pred);\n    std::swap(TrueVal, FalseVal);\n  }\n  const APInt *C1;\n  if (CmpRHS == TrueVal && match(CmpRHS, m_APInt(C1))) {\n    const APInt *C2;\n    // (X <s C1) ? C1 : SMIN(X, C2) ==> SMAX(SMIN(X, C2), C1)\n    if (match(FalseVal, m_SMin(m_Specific(CmpLHS), m_APInt(C2))) &&\n        C1->slt(*C2) && Pred == CmpInst::ICMP_SLT)\n      return {SPF_SMAX, SPNB_NA, false};\n\n    // (X >s C1) ? C1 : SMAX(X, C2) ==> SMIN(SMAX(X, C2), C1)\n    if (match(FalseVal, m_SMax(m_Specific(CmpLHS), m_APInt(C2))) &&\n        C1->sgt(*C2) && Pred == CmpInst::ICMP_SGT)\n      return {SPF_SMIN, SPNB_NA, false};\n\n    // (X <u C1) ? C1 : UMIN(X, C2) ==> UMAX(UMIN(X, C2), C1)\n    if (match(FalseVal, m_UMin(m_Specific(CmpLHS), m_APInt(C2))) &&\n        C1->ult(*C2) && Pred == CmpInst::ICMP_ULT)\n      return {SPF_UMAX, SPNB_NA, false};\n\n    // (X >u C1) ? C1 : UMAX(X, C2) ==> UMIN(UMAX(X, C2), C1)\n    if (match(FalseVal, m_UMax(m_Specific(CmpLHS), m_APInt(C2))) &&\n        C1->ugt(*C2) && Pred == CmpInst::ICMP_UGT)\n      return {SPF_UMIN, SPNB_NA, false};\n  }\n  return {SPF_UNKNOWN, SPNB_NA, false};\n}\n\n/// Recognize variations of:\n///   a < c ? min(a,b) : min(b,c) ==> min(min(a,b),min(b,c))\nstatic SelectPatternResult matchMinMaxOfMinMax(CmpInst::Predicate Pred,\n                                               Value *CmpLHS, Value *CmpRHS,\n                                               Value *TVal, Value *FVal,\n                                               unsigned Depth) {\n  // TODO: Allow FP min/max with nnan/nsz.\n  assert(CmpInst::isIntPredicate(Pred) && \"Expected integer comparison\");\n\n  Value *A = nullptr, *B = nullptr;\n  SelectPatternResult L = matchSelectPattern(TVal, A, B, nullptr, Depth + 1);\n  if (!SelectPatternResult::isMinOrMax(L.Flavor))\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  Value *C = nullptr, *D = nullptr;\n  SelectPatternResult R = matchSelectPattern(FVal, C, D, nullptr, Depth + 1);\n  if (L.Flavor != R.Flavor)\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  // We have something like: x Pred y ? min(a, b) : min(c, d).\n  // Try to match the compare to the min/max operations of the select operands.\n  // First, make sure we have the right compare predicate.\n  switch (L.Flavor) {\n  case SPF_SMIN:\n    if (Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE) {\n      Pred = ICmpInst::getSwappedPredicate(Pred);\n      std::swap(CmpLHS, CmpRHS);\n    }\n    if (Pred == ICmpInst::ICMP_SLT || Pred == ICmpInst::ICMP_SLE)\n      break;\n    return {SPF_UNKNOWN, SPNB_NA, false};\n  case SPF_SMAX:\n    if (Pred == ICmpInst::ICMP_SLT || Pred == ICmpInst::ICMP_SLE) {\n      Pred = ICmpInst::getSwappedPredicate(Pred);\n      std::swap(CmpLHS, CmpRHS);\n    }\n    if (Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE)\n      break;\n    return {SPF_UNKNOWN, SPNB_NA, false};\n  case SPF_UMIN:\n    if (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_UGE) {\n      Pred = ICmpInst::getSwappedPredicate(Pred);\n      std::swap(CmpLHS, CmpRHS);\n    }\n    if (Pred == ICmpInst::ICMP_ULT || Pred == ICmpInst::ICMP_ULE)\n      break;\n    return {SPF_UNKNOWN, SPNB_NA, false};\n  case SPF_UMAX:\n    if (Pred == ICmpInst::ICMP_ULT || Pred == ICmpInst::ICMP_ULE) {\n      Pred = ICmpInst::getSwappedPredicate(Pred);\n      std::swap(CmpLHS, CmpRHS);\n    }\n    if (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_UGE)\n      break;\n    return {SPF_UNKNOWN, SPNB_NA, false};\n  default:\n    return {SPF_UNKNOWN, SPNB_NA, false};\n  }\n\n  // If there is a common operand in the already matched min/max and the other\n  // min/max operands match the compare operands (either directly or inverted),\n  // then this is min/max of the same flavor.\n\n  // a pred c ? m(a, b) : m(c, b) --> m(m(a, b), m(c, b))\n  // ~c pred ~a ? m(a, b) : m(c, b) --> m(m(a, b), m(c, b))\n  if (D == B) {\n    if ((CmpLHS == A && CmpRHS == C) || (match(C, m_Not(m_Specific(CmpLHS))) &&\n                                         match(A, m_Not(m_Specific(CmpRHS)))))\n      return {L.Flavor, SPNB_NA, false};\n  }\n  // a pred d ? m(a, b) : m(b, d) --> m(m(a, b), m(b, d))\n  // ~d pred ~a ? m(a, b) : m(b, d) --> m(m(a, b), m(b, d))\n  if (C == B) {\n    if ((CmpLHS == A && CmpRHS == D) || (match(D, m_Not(m_Specific(CmpLHS))) &&\n                                         match(A, m_Not(m_Specific(CmpRHS)))))\n      return {L.Flavor, SPNB_NA, false};\n  }\n  // b pred c ? m(a, b) : m(c, a) --> m(m(a, b), m(c, a))\n  // ~c pred ~b ? m(a, b) : m(c, a) --> m(m(a, b), m(c, a))\n  if (D == A) {\n    if ((CmpLHS == B && CmpRHS == C) || (match(C, m_Not(m_Specific(CmpLHS))) &&\n                                         match(B, m_Not(m_Specific(CmpRHS)))))\n      return {L.Flavor, SPNB_NA, false};\n  }\n  // b pred d ? m(a, b) : m(a, d) --> m(m(a, b), m(a, d))\n  // ~d pred ~b ? m(a, b) : m(a, d) --> m(m(a, b), m(a, d))\n  if (C == A) {\n    if ((CmpLHS == B && CmpRHS == D) || (match(D, m_Not(m_Specific(CmpLHS))) &&\n                                         match(B, m_Not(m_Specific(CmpRHS)))))\n      return {L.Flavor, SPNB_NA, false};\n  }\n\n  return {SPF_UNKNOWN, SPNB_NA, false};\n}\n\n/// If the input value is the result of a 'not' op, constant integer, or vector\n/// splat of a constant integer, return the bitwise-not source value.\n/// TODO: This could be extended to handle non-splat vector integer constants.\nstatic Value *getNotValue(Value *V) {\n  Value *NotV;\n  if (match(V, m_Not(m_Value(NotV))))\n    return NotV;\n\n  const APInt *C;\n  if (match(V, m_APInt(C)))\n    return ConstantInt::get(V->getType(), ~(*C));\n\n  return nullptr;\n}\n\n/// Match non-obvious integer minimum and maximum sequences.\nstatic SelectPatternResult matchMinMax(CmpInst::Predicate Pred,\n                                       Value *CmpLHS, Value *CmpRHS,\n                                       Value *TrueVal, Value *FalseVal,\n                                       Value *&LHS, Value *&RHS,\n                                       unsigned Depth) {\n  // Assume success. If there's no match, callers should not use these anyway.\n  LHS = TrueVal;\n  RHS = FalseVal;\n\n  SelectPatternResult SPR = matchClamp(Pred, CmpLHS, CmpRHS, TrueVal, FalseVal);\n  if (SPR.Flavor != SelectPatternFlavor::SPF_UNKNOWN)\n    return SPR;\n\n  SPR = matchMinMaxOfMinMax(Pred, CmpLHS, CmpRHS, TrueVal, FalseVal, Depth);\n  if (SPR.Flavor != SelectPatternFlavor::SPF_UNKNOWN)\n    return SPR;\n\n  // Look through 'not' ops to find disguised min/max.\n  // (X > Y) ? ~X : ~Y ==> (~X < ~Y) ? ~X : ~Y ==> MIN(~X, ~Y)\n  // (X < Y) ? ~X : ~Y ==> (~X > ~Y) ? ~X : ~Y ==> MAX(~X, ~Y)\n  if (CmpLHS == getNotValue(TrueVal) && CmpRHS == getNotValue(FalseVal)) {\n    switch (Pred) {\n    case CmpInst::ICMP_SGT: return {SPF_SMIN, SPNB_NA, false};\n    case CmpInst::ICMP_SLT: return {SPF_SMAX, SPNB_NA, false};\n    case CmpInst::ICMP_UGT: return {SPF_UMIN, SPNB_NA, false};\n    case CmpInst::ICMP_ULT: return {SPF_UMAX, SPNB_NA, false};\n    default: break;\n    }\n  }\n\n  // (X > Y) ? ~Y : ~X ==> (~X < ~Y) ? ~Y : ~X ==> MAX(~Y, ~X)\n  // (X < Y) ? ~Y : ~X ==> (~X > ~Y) ? ~Y : ~X ==> MIN(~Y, ~X)\n  if (CmpLHS == getNotValue(FalseVal) && CmpRHS == getNotValue(TrueVal)) {\n    switch (Pred) {\n    case CmpInst::ICMP_SGT: return {SPF_SMAX, SPNB_NA, false};\n    case CmpInst::ICMP_SLT: return {SPF_SMIN, SPNB_NA, false};\n    case CmpInst::ICMP_UGT: return {SPF_UMAX, SPNB_NA, false};\n    case CmpInst::ICMP_ULT: return {SPF_UMIN, SPNB_NA, false};\n    default: break;\n    }\n  }\n\n  if (Pred != CmpInst::ICMP_SGT && Pred != CmpInst::ICMP_SLT)\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  // Z = X -nsw Y\n  // (X >s Y) ? 0 : Z ==> (Z >s 0) ? 0 : Z ==> SMIN(Z, 0)\n  // (X <s Y) ? 0 : Z ==> (Z <s 0) ? 0 : Z ==> SMAX(Z, 0)\n  if (match(TrueVal, m_Zero()) &&\n      match(FalseVal, m_NSWSub(m_Specific(CmpLHS), m_Specific(CmpRHS))))\n    return {Pred == CmpInst::ICMP_SGT ? SPF_SMIN : SPF_SMAX, SPNB_NA, false};\n\n  // Z = X -nsw Y\n  // (X >s Y) ? Z : 0 ==> (Z >s 0) ? Z : 0 ==> SMAX(Z, 0)\n  // (X <s Y) ? Z : 0 ==> (Z <s 0) ? Z : 0 ==> SMIN(Z, 0)\n  if (match(FalseVal, m_Zero()) &&\n      match(TrueVal, m_NSWSub(m_Specific(CmpLHS), m_Specific(CmpRHS))))\n    return {Pred == CmpInst::ICMP_SGT ? SPF_SMAX : SPF_SMIN, SPNB_NA, false};\n\n  const APInt *C1;\n  if (!match(CmpRHS, m_APInt(C1)))\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  // An unsigned min/max can be written with a signed compare.\n  const APInt *C2;\n  if ((CmpLHS == TrueVal && match(FalseVal, m_APInt(C2))) ||\n      (CmpLHS == FalseVal && match(TrueVal, m_APInt(C2)))) {\n    // Is the sign bit set?\n    // (X <s 0) ? X : MAXVAL ==> (X >u MAXVAL) ? X : MAXVAL ==> UMAX\n    // (X <s 0) ? MAXVAL : X ==> (X >u MAXVAL) ? MAXVAL : X ==> UMIN\n    if (Pred == CmpInst::ICMP_SLT && C1->isNullValue() &&\n        C2->isMaxSignedValue())\n      return {CmpLHS == TrueVal ? SPF_UMAX : SPF_UMIN, SPNB_NA, false};\n\n    // Is the sign bit clear?\n    // (X >s -1) ? MINVAL : X ==> (X <u MINVAL) ? MINVAL : X ==> UMAX\n    // (X >s -1) ? X : MINVAL ==> (X <u MINVAL) ? X : MINVAL ==> UMIN\n    if (Pred == CmpInst::ICMP_SGT && C1->isAllOnesValue() &&\n        C2->isMinSignedValue())\n      return {CmpLHS == FalseVal ? SPF_UMAX : SPF_UMIN, SPNB_NA, false};\n  }\n\n  return {SPF_UNKNOWN, SPNB_NA, false};\n}\n\nbool llvm::isKnownNegation(const Value *X, const Value *Y, bool NeedNSW) {\n  assert(X && Y && \"Invalid operand\");\n\n  // X = sub (0, Y) || X = sub nsw (0, Y)\n  if ((!NeedNSW && match(X, m_Sub(m_ZeroInt(), m_Specific(Y)))) ||\n      (NeedNSW && match(X, m_NSWSub(m_ZeroInt(), m_Specific(Y)))))\n    return true;\n\n  // Y = sub (0, X) || Y = sub nsw (0, X)\n  if ((!NeedNSW && match(Y, m_Sub(m_ZeroInt(), m_Specific(X)))) ||\n      (NeedNSW && match(Y, m_NSWSub(m_ZeroInt(), m_Specific(X)))))\n    return true;\n\n  // X = sub (A, B), Y = sub (B, A) || X = sub nsw (A, B), Y = sub nsw (B, A)\n  Value *A, *B;\n  return (!NeedNSW && (match(X, m_Sub(m_Value(A), m_Value(B))) &&\n                        match(Y, m_Sub(m_Specific(B), m_Specific(A))))) ||\n         (NeedNSW && (match(X, m_NSWSub(m_Value(A), m_Value(B))) &&\n                       match(Y, m_NSWSub(m_Specific(B), m_Specific(A)))));\n}\n\nstatic SelectPatternResult matchSelectPattern(CmpInst::Predicate Pred,\n                                              FastMathFlags FMF,\n                                              Value *CmpLHS, Value *CmpRHS,\n                                              Value *TrueVal, Value *FalseVal,\n                                              Value *&LHS, Value *&RHS,\n                                              unsigned Depth) {\n  if (CmpInst::isFPPredicate(Pred)) {\n    // IEEE-754 ignores the sign of 0.0 in comparisons. So if the select has one\n    // 0.0 operand, set the compare's 0.0 operands to that same value for the\n    // purpose of identifying min/max. Disregard vector constants with undefined\n    // elements because those can not be back-propagated for analysis.\n    Value *OutputZeroVal = nullptr;\n    if (match(TrueVal, m_AnyZeroFP()) && !match(FalseVal, m_AnyZeroFP()) &&\n        !cast<Constant>(TrueVal)->containsUndefOrPoisonElement())\n      OutputZeroVal = TrueVal;\n    else if (match(FalseVal, m_AnyZeroFP()) && !match(TrueVal, m_AnyZeroFP()) &&\n             !cast<Constant>(FalseVal)->containsUndefOrPoisonElement())\n      OutputZeroVal = FalseVal;\n\n    if (OutputZeroVal) {\n      if (match(CmpLHS, m_AnyZeroFP()))\n        CmpLHS = OutputZeroVal;\n      if (match(CmpRHS, m_AnyZeroFP()))\n        CmpRHS = OutputZeroVal;\n    }\n  }\n\n  LHS = CmpLHS;\n  RHS = CmpRHS;\n\n  // Signed zero may return inconsistent results between implementations.\n  //  (0.0 <= -0.0) ? 0.0 : -0.0 // Returns 0.0\n  //  minNum(0.0, -0.0)          // May return -0.0 or 0.0 (IEEE 754-2008 5.3.1)\n  // Therefore, we behave conservatively and only proceed if at least one of the\n  // operands is known to not be zero or if we don't care about signed zero.\n  switch (Pred) {\n  default: break;\n  // FIXME: Include OGT/OLT/UGT/ULT.\n  case CmpInst::FCMP_OGE: case CmpInst::FCMP_OLE:\n  case CmpInst::FCMP_UGE: case CmpInst::FCMP_ULE:\n    if (!FMF.noSignedZeros() && !isKnownNonZero(CmpLHS) &&\n        !isKnownNonZero(CmpRHS))\n      return {SPF_UNKNOWN, SPNB_NA, false};\n  }\n\n  SelectPatternNaNBehavior NaNBehavior = SPNB_NA;\n  bool Ordered = false;\n\n  // When given one NaN and one non-NaN input:\n  //   - maxnum/minnum (C99 fmaxf()/fminf()) return the non-NaN input.\n  //   - A simple C99 (a < b ? a : b) construction will return 'b' (as the\n  //     ordered comparison fails), which could be NaN or non-NaN.\n  // so here we discover exactly what NaN behavior is required/accepted.\n  if (CmpInst::isFPPredicate(Pred)) {\n    bool LHSSafe = isKnownNonNaN(CmpLHS, FMF);\n    bool RHSSafe = isKnownNonNaN(CmpRHS, FMF);\n\n    if (LHSSafe && RHSSafe) {\n      // Both operands are known non-NaN.\n      NaNBehavior = SPNB_RETURNS_ANY;\n    } else if (CmpInst::isOrdered(Pred)) {\n      // An ordered comparison will return false when given a NaN, so it\n      // returns the RHS.\n      Ordered = true;\n      if (LHSSafe)\n        // LHS is non-NaN, so if RHS is NaN then NaN will be returned.\n        NaNBehavior = SPNB_RETURNS_NAN;\n      else if (RHSSafe)\n        NaNBehavior = SPNB_RETURNS_OTHER;\n      else\n        // Completely unsafe.\n        return {SPF_UNKNOWN, SPNB_NA, false};\n    } else {\n      Ordered = false;\n      // An unordered comparison will return true when given a NaN, so it\n      // returns the LHS.\n      if (LHSSafe)\n        // LHS is non-NaN, so if RHS is NaN then non-NaN will be returned.\n        NaNBehavior = SPNB_RETURNS_OTHER;\n      else if (RHSSafe)\n        NaNBehavior = SPNB_RETURNS_NAN;\n      else\n        // Completely unsafe.\n        return {SPF_UNKNOWN, SPNB_NA, false};\n    }\n  }\n\n  if (TrueVal == CmpRHS && FalseVal == CmpLHS) {\n    std::swap(CmpLHS, CmpRHS);\n    Pred = CmpInst::getSwappedPredicate(Pred);\n    if (NaNBehavior == SPNB_RETURNS_NAN)\n      NaNBehavior = SPNB_RETURNS_OTHER;\n    else if (NaNBehavior == SPNB_RETURNS_OTHER)\n      NaNBehavior = SPNB_RETURNS_NAN;\n    Ordered = !Ordered;\n  }\n\n  // ([if]cmp X, Y) ? X : Y\n  if (TrueVal == CmpLHS && FalseVal == CmpRHS) {\n    switch (Pred) {\n    default: return {SPF_UNKNOWN, SPNB_NA, false}; // Equality.\n    case ICmpInst::ICMP_UGT:\n    case ICmpInst::ICMP_UGE: return {SPF_UMAX, SPNB_NA, false};\n    case ICmpInst::ICMP_SGT:\n    case ICmpInst::ICMP_SGE: return {SPF_SMAX, SPNB_NA, false};\n    case ICmpInst::ICMP_ULT:\n    case ICmpInst::ICMP_ULE: return {SPF_UMIN, SPNB_NA, false};\n    case ICmpInst::ICMP_SLT:\n    case ICmpInst::ICMP_SLE: return {SPF_SMIN, SPNB_NA, false};\n    case FCmpInst::FCMP_UGT:\n    case FCmpInst::FCMP_UGE:\n    case FCmpInst::FCMP_OGT:\n    case FCmpInst::FCMP_OGE: return {SPF_FMAXNUM, NaNBehavior, Ordered};\n    case FCmpInst::FCMP_ULT:\n    case FCmpInst::FCMP_ULE:\n    case FCmpInst::FCMP_OLT:\n    case FCmpInst::FCMP_OLE: return {SPF_FMINNUM, NaNBehavior, Ordered};\n    }\n  }\n\n  if (isKnownNegation(TrueVal, FalseVal)) {\n    // Sign-extending LHS does not change its sign, so TrueVal/FalseVal can\n    // match against either LHS or sext(LHS).\n    auto MaybeSExtCmpLHS =\n        m_CombineOr(m_Specific(CmpLHS), m_SExt(m_Specific(CmpLHS)));\n    auto ZeroOrAllOnes = m_CombineOr(m_ZeroInt(), m_AllOnes());\n    auto ZeroOrOne = m_CombineOr(m_ZeroInt(), m_One());\n    if (match(TrueVal, MaybeSExtCmpLHS)) {\n      // Set the return values. If the compare uses the negated value (-X >s 0),\n      // swap the return values because the negated value is always 'RHS'.\n      LHS = TrueVal;\n      RHS = FalseVal;\n      if (match(CmpLHS, m_Neg(m_Specific(FalseVal))))\n        std::swap(LHS, RHS);\n\n      // (X >s 0) ? X : -X or (X >s -1) ? X : -X --> ABS(X)\n      // (-X >s 0) ? -X : X or (-X >s -1) ? -X : X --> ABS(X)\n      if (Pred == ICmpInst::ICMP_SGT && match(CmpRHS, ZeroOrAllOnes))\n        return {SPF_ABS, SPNB_NA, false};\n\n      // (X >=s 0) ? X : -X or (X >=s 1) ? X : -X --> ABS(X)\n      if (Pred == ICmpInst::ICMP_SGE && match(CmpRHS, ZeroOrOne))\n        return {SPF_ABS, SPNB_NA, false};\n\n      // (X <s 0) ? X : -X or (X <s 1) ? X : -X --> NABS(X)\n      // (-X <s 0) ? -X : X or (-X <s 1) ? -X : X --> NABS(X)\n      if (Pred == ICmpInst::ICMP_SLT && match(CmpRHS, ZeroOrOne))\n        return {SPF_NABS, SPNB_NA, false};\n    }\n    else if (match(FalseVal, MaybeSExtCmpLHS)) {\n      // Set the return values. If the compare uses the negated value (-X >s 0),\n      // swap the return values because the negated value is always 'RHS'.\n      LHS = FalseVal;\n      RHS = TrueVal;\n      if (match(CmpLHS, m_Neg(m_Specific(TrueVal))))\n        std::swap(LHS, RHS);\n\n      // (X >s 0) ? -X : X or (X >s -1) ? -X : X --> NABS(X)\n      // (-X >s 0) ? X : -X or (-X >s -1) ? X : -X --> NABS(X)\n      if (Pred == ICmpInst::ICMP_SGT && match(CmpRHS, ZeroOrAllOnes))\n        return {SPF_NABS, SPNB_NA, false};\n\n      // (X <s 0) ? -X : X or (X <s 1) ? -X : X --> ABS(X)\n      // (-X <s 0) ? X : -X or (-X <s 1) ? X : -X --> ABS(X)\n      if (Pred == ICmpInst::ICMP_SLT && match(CmpRHS, ZeroOrOne))\n        return {SPF_ABS, SPNB_NA, false};\n    }\n  }\n\n  if (CmpInst::isIntPredicate(Pred))\n    return matchMinMax(Pred, CmpLHS, CmpRHS, TrueVal, FalseVal, LHS, RHS, Depth);\n\n  // According to (IEEE 754-2008 5.3.1), minNum(0.0, -0.0) and similar\n  // may return either -0.0 or 0.0, so fcmp/select pair has stricter\n  // semantics than minNum. Be conservative in such case.\n  if (NaNBehavior != SPNB_RETURNS_ANY ||\n      (!FMF.noSignedZeros() && !isKnownNonZero(CmpLHS) &&\n       !isKnownNonZero(CmpRHS)))\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  return matchFastFloatClamp(Pred, CmpLHS, CmpRHS, TrueVal, FalseVal, LHS, RHS);\n}\n\n/// Helps to match a select pattern in case of a type mismatch.\n///\n/// The function processes the case when type of true and false values of a\n/// select instruction differs from type of the cmp instruction operands because\n/// of a cast instruction. The function checks if it is legal to move the cast\n/// operation after \"select\". If yes, it returns the new second value of\n/// \"select\" (with the assumption that cast is moved):\n/// 1. As operand of cast instruction when both values of \"select\" are same cast\n/// instructions.\n/// 2. As restored constant (by applying reverse cast operation) when the first\n/// value of the \"select\" is a cast operation and the second value is a\n/// constant.\n/// NOTE: We return only the new second value because the first value could be\n/// accessed as operand of cast instruction.\nstatic Value *lookThroughCast(CmpInst *CmpI, Value *V1, Value *V2,\n                              Instruction::CastOps *CastOp) {\n  auto *Cast1 = dyn_cast<CastInst>(V1);\n  if (!Cast1)\n    return nullptr;\n\n  *CastOp = Cast1->getOpcode();\n  Type *SrcTy = Cast1->getSrcTy();\n  if (auto *Cast2 = dyn_cast<CastInst>(V2)) {\n    // If V1 and V2 are both the same cast from the same type, look through V1.\n    if (*CastOp == Cast2->getOpcode() && SrcTy == Cast2->getSrcTy())\n      return Cast2->getOperand(0);\n    return nullptr;\n  }\n\n  auto *C = dyn_cast<Constant>(V2);\n  if (!C)\n    return nullptr;\n\n  Constant *CastedTo = nullptr;\n  switch (*CastOp) {\n  case Instruction::ZExt:\n    if (CmpI->isUnsigned())\n      CastedTo = ConstantExpr::getTrunc(C, SrcTy);\n    break;\n  case Instruction::SExt:\n    if (CmpI->isSigned())\n      CastedTo = ConstantExpr::getTrunc(C, SrcTy, true);\n    break;\n  case Instruction::Trunc:\n    Constant *CmpConst;\n    if (match(CmpI->getOperand(1), m_Constant(CmpConst)) &&\n        CmpConst->getType() == SrcTy) {\n      // Here we have the following case:\n      //\n      //   %cond = cmp iN %x, CmpConst\n      //   %tr = trunc iN %x to iK\n      //   %narrowsel = select i1 %cond, iK %t, iK C\n      //\n      // We can always move trunc after select operation:\n      //\n      //   %cond = cmp iN %x, CmpConst\n      //   %widesel = select i1 %cond, iN %x, iN CmpConst\n      //   %tr = trunc iN %widesel to iK\n      //\n      // Note that C could be extended in any way because we don't care about\n      // upper bits after truncation. It can't be abs pattern, because it would\n      // look like:\n      //\n      //   select i1 %cond, x, -x.\n      //\n      // So only min/max pattern could be matched. Such match requires widened C\n      // == CmpConst. That is why set widened C = CmpConst, condition trunc\n      // CmpConst == C is checked below.\n      CastedTo = CmpConst;\n    } else {\n      CastedTo = ConstantExpr::getIntegerCast(C, SrcTy, CmpI->isSigned());\n    }\n    break;\n  case Instruction::FPTrunc:\n    CastedTo = ConstantExpr::getFPExtend(C, SrcTy, true);\n    break;\n  case Instruction::FPExt:\n    CastedTo = ConstantExpr::getFPTrunc(C, SrcTy, true);\n    break;\n  case Instruction::FPToUI:\n    CastedTo = ConstantExpr::getUIToFP(C, SrcTy, true);\n    break;\n  case Instruction::FPToSI:\n    CastedTo = ConstantExpr::getSIToFP(C, SrcTy, true);\n    break;\n  case Instruction::UIToFP:\n    CastedTo = ConstantExpr::getFPToUI(C, SrcTy, true);\n    break;\n  case Instruction::SIToFP:\n    CastedTo = ConstantExpr::getFPToSI(C, SrcTy, true);\n    break;\n  default:\n    break;\n  }\n\n  if (!CastedTo)\n    return nullptr;\n\n  // Make sure the cast doesn't lose any information.\n  Constant *CastedBack =\n      ConstantExpr::getCast(*CastOp, CastedTo, C->getType(), true);\n  if (CastedBack != C)\n    return nullptr;\n\n  return CastedTo;\n}\n\nSelectPatternResult llvm::matchSelectPattern(Value *V, Value *&LHS, Value *&RHS,\n                                             Instruction::CastOps *CastOp,\n                                             unsigned Depth) {\n  if (Depth >= MaxAnalysisRecursionDepth)\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  SelectInst *SI = dyn_cast<SelectInst>(V);\n  if (!SI) return {SPF_UNKNOWN, SPNB_NA, false};\n\n  CmpInst *CmpI = dyn_cast<CmpInst>(SI->getCondition());\n  if (!CmpI) return {SPF_UNKNOWN, SPNB_NA, false};\n\n  Value *TrueVal = SI->getTrueValue();\n  Value *FalseVal = SI->getFalseValue();\n\n  return llvm::matchDecomposedSelectPattern(CmpI, TrueVal, FalseVal, LHS, RHS,\n                                            CastOp, Depth);\n}\n\nSelectPatternResult llvm::matchDecomposedSelectPattern(\n    CmpInst *CmpI, Value *TrueVal, Value *FalseVal, Value *&LHS, Value *&RHS,\n    Instruction::CastOps *CastOp, unsigned Depth) {\n  CmpInst::Predicate Pred = CmpI->getPredicate();\n  Value *CmpLHS = CmpI->getOperand(0);\n  Value *CmpRHS = CmpI->getOperand(1);\n  FastMathFlags FMF;\n  if (isa<FPMathOperator>(CmpI))\n    FMF = CmpI->getFastMathFlags();\n\n  // Bail out early.\n  if (CmpI->isEquality())\n    return {SPF_UNKNOWN, SPNB_NA, false};\n\n  // Deal with type mismatches.\n  if (CastOp && CmpLHS->getType() != TrueVal->getType()) {\n    if (Value *C = lookThroughCast(CmpI, TrueVal, FalseVal, CastOp)) {\n      // If this is a potential fmin/fmax with a cast to integer, then ignore\n      // -0.0 because there is no corresponding integer value.\n      if (*CastOp == Instruction::FPToSI || *CastOp == Instruction::FPToUI)\n        FMF.setNoSignedZeros();\n      return ::matchSelectPattern(Pred, FMF, CmpLHS, CmpRHS,\n                                  cast<CastInst>(TrueVal)->getOperand(0), C,\n                                  LHS, RHS, Depth);\n    }\n    if (Value *C = lookThroughCast(CmpI, FalseVal, TrueVal, CastOp)) {\n      // If this is a potential fmin/fmax with a cast to integer, then ignore\n      // -0.0 because there is no corresponding integer value.\n      if (*CastOp == Instruction::FPToSI || *CastOp == Instruction::FPToUI)\n        FMF.setNoSignedZeros();\n      return ::matchSelectPattern(Pred, FMF, CmpLHS, CmpRHS,\n                                  C, cast<CastInst>(FalseVal)->getOperand(0),\n                                  LHS, RHS, Depth);\n    }\n  }\n  return ::matchSelectPattern(Pred, FMF, CmpLHS, CmpRHS, TrueVal, FalseVal,\n                              LHS, RHS, Depth);\n}\n\nCmpInst::Predicate llvm::getMinMaxPred(SelectPatternFlavor SPF, bool Ordered) {\n  if (SPF == SPF_SMIN) return ICmpInst::ICMP_SLT;\n  if (SPF == SPF_UMIN) return ICmpInst::ICMP_ULT;\n  if (SPF == SPF_SMAX) return ICmpInst::ICMP_SGT;\n  if (SPF == SPF_UMAX) return ICmpInst::ICMP_UGT;\n  if (SPF == SPF_FMINNUM)\n    return Ordered ? FCmpInst::FCMP_OLT : FCmpInst::FCMP_ULT;\n  if (SPF == SPF_FMAXNUM)\n    return Ordered ? FCmpInst::FCMP_OGT : FCmpInst::FCMP_UGT;\n  llvm_unreachable(\"unhandled!\");\n}\n\nSelectPatternFlavor llvm::getInverseMinMaxFlavor(SelectPatternFlavor SPF) {\n  if (SPF == SPF_SMIN) return SPF_SMAX;\n  if (SPF == SPF_UMIN) return SPF_UMAX;\n  if (SPF == SPF_SMAX) return SPF_SMIN;\n  if (SPF == SPF_UMAX) return SPF_UMIN;\n  llvm_unreachable(\"unhandled!\");\n}\n\nCmpInst::Predicate llvm::getInverseMinMaxPred(SelectPatternFlavor SPF) {\n  return getMinMaxPred(getInverseMinMaxFlavor(SPF));\n}\n\nstd::pair<Intrinsic::ID, bool>\nllvm::canConvertToMinOrMaxIntrinsic(ArrayRef<Value *> VL) {\n  // Check if VL contains select instructions that can be folded into a min/max\n  // vector intrinsic and return the intrinsic if it is possible.\n  // TODO: Support floating point min/max.\n  bool AllCmpSingleUse = true;\n  SelectPatternResult SelectPattern;\n  SelectPattern.Flavor = SPF_UNKNOWN;\n  if (all_of(VL, [&SelectPattern, &AllCmpSingleUse](Value *I) {\n        Value *LHS, *RHS;\n        auto CurrentPattern = matchSelectPattern(I, LHS, RHS);\n        if (!SelectPatternResult::isMinOrMax(CurrentPattern.Flavor) ||\n            CurrentPattern.Flavor == SPF_FMINNUM ||\n            CurrentPattern.Flavor == SPF_FMAXNUM ||\n            !I->getType()->isIntOrIntVectorTy())\n          return false;\n        if (SelectPattern.Flavor != SPF_UNKNOWN &&\n            SelectPattern.Flavor != CurrentPattern.Flavor)\n          return false;\n        SelectPattern = CurrentPattern;\n        AllCmpSingleUse &=\n            match(I, m_Select(m_OneUse(m_Value()), m_Value(), m_Value()));\n        return true;\n      })) {\n    switch (SelectPattern.Flavor) {\n    case SPF_SMIN:\n      return {Intrinsic::smin, AllCmpSingleUse};\n    case SPF_UMIN:\n      return {Intrinsic::umin, AllCmpSingleUse};\n    case SPF_SMAX:\n      return {Intrinsic::smax, AllCmpSingleUse};\n    case SPF_UMAX:\n      return {Intrinsic::umax, AllCmpSingleUse};\n    default:\n      llvm_unreachable(\"unexpected select pattern flavor\");\n    }\n  }\n  return {Intrinsic::not_intrinsic, false};\n}\n\n/// Return true if \"icmp Pred LHS RHS\" is always true.\nstatic bool isTruePredicate(CmpInst::Predicate Pred, const Value *LHS,\n                            const Value *RHS, const DataLayout &DL,\n                            unsigned Depth) {\n  assert(!LHS->getType()->isVectorTy() && \"TODO: extend to handle vectors!\");\n  if (ICmpInst::isTrueWhenEqual(Pred) && LHS == RHS)\n    return true;\n\n  switch (Pred) {\n  default:\n    return false;\n\n  case CmpInst::ICMP_SLE: {\n    const APInt *C;\n\n    // LHS s<= LHS +_{nsw} C   if C >= 0\n    if (match(RHS, m_NSWAdd(m_Specific(LHS), m_APInt(C))))\n      return !C->isNegative();\n    return false;\n  }\n\n  case CmpInst::ICMP_ULE: {\n    const APInt *C;\n\n    // LHS u<= LHS +_{nuw} C   for any C\n    if (match(RHS, m_NUWAdd(m_Specific(LHS), m_APInt(C))))\n      return true;\n\n    // Match A to (X +_{nuw} CA) and B to (X +_{nuw} CB)\n    auto MatchNUWAddsToSameValue = [&](const Value *A, const Value *B,\n                                       const Value *&X,\n                                       const APInt *&CA, const APInt *&CB) {\n      if (match(A, m_NUWAdd(m_Value(X), m_APInt(CA))) &&\n          match(B, m_NUWAdd(m_Specific(X), m_APInt(CB))))\n        return true;\n\n      // If X & C == 0 then (X | C) == X +_{nuw} C\n      if (match(A, m_Or(m_Value(X), m_APInt(CA))) &&\n          match(B, m_Or(m_Specific(X), m_APInt(CB)))) {\n        KnownBits Known(CA->getBitWidth());\n        computeKnownBits(X, Known, DL, Depth + 1, /*AC*/ nullptr,\n                         /*CxtI*/ nullptr, /*DT*/ nullptr);\n        if (CA->isSubsetOf(Known.Zero) && CB->isSubsetOf(Known.Zero))\n          return true;\n      }\n\n      return false;\n    };\n\n    const Value *X;\n    const APInt *CLHS, *CRHS;\n    if (MatchNUWAddsToSameValue(LHS, RHS, X, CLHS, CRHS))\n      return CLHS->ule(*CRHS);\n\n    return false;\n  }\n  }\n}\n\n/// Return true if \"icmp Pred BLHS BRHS\" is true whenever \"icmp Pred\n/// ALHS ARHS\" is true.  Otherwise, return None.\nstatic Optional<bool>\nisImpliedCondOperands(CmpInst::Predicate Pred, const Value *ALHS,\n                      const Value *ARHS, const Value *BLHS, const Value *BRHS,\n                      const DataLayout &DL, unsigned Depth) {\n  switch (Pred) {\n  default:\n    return None;\n\n  case CmpInst::ICMP_SLT:\n  case CmpInst::ICMP_SLE:\n    if (isTruePredicate(CmpInst::ICMP_SLE, BLHS, ALHS, DL, Depth) &&\n        isTruePredicate(CmpInst::ICMP_SLE, ARHS, BRHS, DL, Depth))\n      return true;\n    return None;\n\n  case CmpInst::ICMP_ULT:\n  case CmpInst::ICMP_ULE:\n    if (isTruePredicate(CmpInst::ICMP_ULE, BLHS, ALHS, DL, Depth) &&\n        isTruePredicate(CmpInst::ICMP_ULE, ARHS, BRHS, DL, Depth))\n      return true;\n    return None;\n  }\n}\n\n/// Return true if the operands of the two compares match.  IsSwappedOps is true\n/// when the operands match, but are swapped.\nstatic bool isMatchingOps(const Value *ALHS, const Value *ARHS,\n                          const Value *BLHS, const Value *BRHS,\n                          bool &IsSwappedOps) {\n\n  bool IsMatchingOps = (ALHS == BLHS && ARHS == BRHS);\n  IsSwappedOps = (ALHS == BRHS && ARHS == BLHS);\n  return IsMatchingOps || IsSwappedOps;\n}\n\n/// Return true if \"icmp1 APred X, Y\" implies \"icmp2 BPred X, Y\" is true.\n/// Return false if \"icmp1 APred X, Y\" implies \"icmp2 BPred X, Y\" is false.\n/// Otherwise, return None if we can't infer anything.\nstatic Optional<bool> isImpliedCondMatchingOperands(CmpInst::Predicate APred,\n                                                    CmpInst::Predicate BPred,\n                                                    bool AreSwappedOps) {\n  // Canonicalize the predicate as if the operands were not commuted.\n  if (AreSwappedOps)\n    BPred = ICmpInst::getSwappedPredicate(BPred);\n\n  if (CmpInst::isImpliedTrueByMatchingCmp(APred, BPred))\n    return true;\n  if (CmpInst::isImpliedFalseByMatchingCmp(APred, BPred))\n    return false;\n\n  return None;\n}\n\n/// Return true if \"icmp APred X, C1\" implies \"icmp BPred X, C2\" is true.\n/// Return false if \"icmp APred X, C1\" implies \"icmp BPred X, C2\" is false.\n/// Otherwise, return None if we can't infer anything.\nstatic Optional<bool>\nisImpliedCondMatchingImmOperands(CmpInst::Predicate APred,\n                                 const ConstantInt *C1,\n                                 CmpInst::Predicate BPred,\n                                 const ConstantInt *C2) {\n  ConstantRange DomCR =\n      ConstantRange::makeExactICmpRegion(APred, C1->getValue());\n  ConstantRange CR =\n      ConstantRange::makeAllowedICmpRegion(BPred, C2->getValue());\n  ConstantRange Intersection = DomCR.intersectWith(CR);\n  ConstantRange Difference = DomCR.difference(CR);\n  if (Intersection.isEmptySet())\n    return false;\n  if (Difference.isEmptySet())\n    return true;\n  return None;\n}\n\n/// Return true if LHS implies RHS is true.  Return false if LHS implies RHS is\n/// false.  Otherwise, return None if we can't infer anything.\nstatic Optional<bool> isImpliedCondICmps(const ICmpInst *LHS,\n                                         CmpInst::Predicate BPred,\n                                         const Value *BLHS, const Value *BRHS,\n                                         const DataLayout &DL, bool LHSIsTrue,\n                                         unsigned Depth) {\n  Value *ALHS = LHS->getOperand(0);\n  Value *ARHS = LHS->getOperand(1);\n\n  // The rest of the logic assumes the LHS condition is true.  If that's not the\n  // case, invert the predicate to make it so.\n  CmpInst::Predicate APred =\n      LHSIsTrue ? LHS->getPredicate() : LHS->getInversePredicate();\n\n  // Can we infer anything when the two compares have matching operands?\n  bool AreSwappedOps;\n  if (isMatchingOps(ALHS, ARHS, BLHS, BRHS, AreSwappedOps)) {\n    if (Optional<bool> Implication = isImpliedCondMatchingOperands(\n            APred, BPred, AreSwappedOps))\n      return Implication;\n    // No amount of additional analysis will infer the second condition, so\n    // early exit.\n    return None;\n  }\n\n  // Can we infer anything when the LHS operands match and the RHS operands are\n  // constants (not necessarily matching)?\n  if (ALHS == BLHS && isa<ConstantInt>(ARHS) && isa<ConstantInt>(BRHS)) {\n    if (Optional<bool> Implication = isImpliedCondMatchingImmOperands(\n            APred, cast<ConstantInt>(ARHS), BPred, cast<ConstantInt>(BRHS)))\n      return Implication;\n    // No amount of additional analysis will infer the second condition, so\n    // early exit.\n    return None;\n  }\n\n  if (APred == BPred)\n    return isImpliedCondOperands(APred, ALHS, ARHS, BLHS, BRHS, DL, Depth);\n  return None;\n}\n\n/// Return true if LHS implies RHS is true.  Return false if LHS implies RHS is\n/// false.  Otherwise, return None if we can't infer anything.  We expect the\n/// RHS to be an icmp and the LHS to be an 'and', 'or', or a 'select' instruction.\nstatic Optional<bool>\nisImpliedCondAndOr(const Instruction *LHS, CmpInst::Predicate RHSPred,\n                   const Value *RHSOp0, const Value *RHSOp1,\n                   const DataLayout &DL, bool LHSIsTrue, unsigned Depth) {\n  // The LHS must be an 'or', 'and', or a 'select' instruction.\n  assert((LHS->getOpcode() == Instruction::And ||\n          LHS->getOpcode() == Instruction::Or ||\n          LHS->getOpcode() == Instruction::Select) &&\n         \"Expected LHS to be 'and', 'or', or 'select'.\");\n\n  assert(Depth <= MaxAnalysisRecursionDepth && \"Hit recursion limit\");\n\n  // If the result of an 'or' is false, then we know both legs of the 'or' are\n  // false.  Similarly, if the result of an 'and' is true, then we know both\n  // legs of the 'and' are true.\n  const Value *ALHS, *ARHS;\n  if ((!LHSIsTrue && match(LHS, m_LogicalOr(m_Value(ALHS), m_Value(ARHS)))) ||\n      (LHSIsTrue && match(LHS, m_LogicalAnd(m_Value(ALHS), m_Value(ARHS))))) {\n    // FIXME: Make this non-recursion.\n    if (Optional<bool> Implication = isImpliedCondition(\n            ALHS, RHSPred, RHSOp0, RHSOp1, DL, LHSIsTrue, Depth + 1))\n      return Implication;\n    if (Optional<bool> Implication = isImpliedCondition(\n            ARHS, RHSPred, RHSOp0, RHSOp1, DL, LHSIsTrue, Depth + 1))\n      return Implication;\n    return None;\n  }\n  return None;\n}\n\nOptional<bool>\nllvm::isImpliedCondition(const Value *LHS, CmpInst::Predicate RHSPred,\n                         const Value *RHSOp0, const Value *RHSOp1,\n                         const DataLayout &DL, bool LHSIsTrue, unsigned Depth) {\n  // Bail out when we hit the limit.\n  if (Depth == MaxAnalysisRecursionDepth)\n    return None;\n\n  // A mismatch occurs when we compare a scalar cmp to a vector cmp, for\n  // example.\n  if (RHSOp0->getType()->isVectorTy() != LHS->getType()->isVectorTy())\n    return None;\n\n  Type *OpTy = LHS->getType();\n  assert(OpTy->isIntOrIntVectorTy(1) && \"Expected integer type only!\");\n\n  // FIXME: Extending the code below to handle vectors.\n  if (OpTy->isVectorTy())\n    return None;\n\n  assert(OpTy->isIntegerTy(1) && \"implied by above\");\n\n  // Both LHS and RHS are icmps.\n  const ICmpInst *LHSCmp = dyn_cast<ICmpInst>(LHS);\n  if (LHSCmp)\n    return isImpliedCondICmps(LHSCmp, RHSPred, RHSOp0, RHSOp1, DL, LHSIsTrue,\n                              Depth);\n\n  /// The LHS should be an 'or', 'and', or a 'select' instruction.  We expect\n  /// the RHS to be an icmp.\n  /// FIXME: Add support for and/or/select on the RHS.\n  if (const Instruction *LHSI = dyn_cast<Instruction>(LHS)) {\n    if ((LHSI->getOpcode() == Instruction::And ||\n         LHSI->getOpcode() == Instruction::Or ||\n         LHSI->getOpcode() == Instruction::Select))\n      return isImpliedCondAndOr(LHSI, RHSPred, RHSOp0, RHSOp1, DL, LHSIsTrue,\n                                Depth);\n  }\n  return None;\n}\n\nOptional<bool> llvm::isImpliedCondition(const Value *LHS, const Value *RHS,\n                                        const DataLayout &DL, bool LHSIsTrue,\n                                        unsigned Depth) {\n  // LHS ==> RHS by definition\n  if (LHS == RHS)\n    return LHSIsTrue;\n\n  const ICmpInst *RHSCmp = dyn_cast<ICmpInst>(RHS);\n  if (RHSCmp)\n    return isImpliedCondition(LHS, RHSCmp->getPredicate(),\n                              RHSCmp->getOperand(0), RHSCmp->getOperand(1), DL,\n                              LHSIsTrue, Depth);\n  return None;\n}\n\n// Returns a pair (Condition, ConditionIsTrue), where Condition is a branch\n// condition dominating ContextI or nullptr, if no condition is found.\nstatic std::pair<Value *, bool>\ngetDomPredecessorCondition(const Instruction *ContextI) {\n  if (!ContextI || !ContextI->getParent())\n    return {nullptr, false};\n\n  // TODO: This is a poor/cheap way to determine dominance. Should we use a\n  // dominator tree (eg, from a SimplifyQuery) instead?\n  const BasicBlock *ContextBB = ContextI->getParent();\n  const BasicBlock *PredBB = ContextBB->getSinglePredecessor();\n  if (!PredBB)\n    return {nullptr, false};\n\n  // We need a conditional branch in the predecessor.\n  Value *PredCond;\n  BasicBlock *TrueBB, *FalseBB;\n  if (!match(PredBB->getTerminator(), m_Br(m_Value(PredCond), TrueBB, FalseBB)))\n    return {nullptr, false};\n\n  // The branch should get simplified. Don't bother simplifying this condition.\n  if (TrueBB == FalseBB)\n    return {nullptr, false};\n\n  assert((TrueBB == ContextBB || FalseBB == ContextBB) &&\n         \"Predecessor block does not point to successor?\");\n\n  // Is this condition implied by the predecessor condition?\n  return {PredCond, TrueBB == ContextBB};\n}\n\nOptional<bool> llvm::isImpliedByDomCondition(const Value *Cond,\n                                             const Instruction *ContextI,\n                                             const DataLayout &DL) {\n  assert(Cond->getType()->isIntOrIntVectorTy(1) && \"Condition must be bool\");\n  auto PredCond = getDomPredecessorCondition(ContextI);\n  if (PredCond.first)\n    return isImpliedCondition(PredCond.first, Cond, DL, PredCond.second);\n  return None;\n}\n\nOptional<bool> llvm::isImpliedByDomCondition(CmpInst::Predicate Pred,\n                                             const Value *LHS, const Value *RHS,\n                                             const Instruction *ContextI,\n                                             const DataLayout &DL) {\n  auto PredCond = getDomPredecessorCondition(ContextI);\n  if (PredCond.first)\n    return isImpliedCondition(PredCond.first, Pred, LHS, RHS, DL,\n                              PredCond.second);\n  return None;\n}\n\nstatic void setLimitsForBinOp(const BinaryOperator &BO, APInt &Lower,\n                              APInt &Upper, const InstrInfoQuery &IIQ) {\n  unsigned Width = Lower.getBitWidth();\n  const APInt *C;\n  switch (BO.getOpcode()) {\n  case Instruction::Add:\n    if (match(BO.getOperand(1), m_APInt(C)) && !C->isNullValue()) {\n      // FIXME: If we have both nuw and nsw, we should reduce the range further.\n      if (IIQ.hasNoUnsignedWrap(cast<OverflowingBinaryOperator>(&BO))) {\n        // 'add nuw x, C' produces [C, UINT_MAX].\n        Lower = *C;\n      } else if (IIQ.hasNoSignedWrap(cast<OverflowingBinaryOperator>(&BO))) {\n        if (C->isNegative()) {\n          // 'add nsw x, -C' produces [SINT_MIN, SINT_MAX - C].\n          Lower = APInt::getSignedMinValue(Width);\n          Upper = APInt::getSignedMaxValue(Width) + *C + 1;\n        } else {\n          // 'add nsw x, +C' produces [SINT_MIN + C, SINT_MAX].\n          Lower = APInt::getSignedMinValue(Width) + *C;\n          Upper = APInt::getSignedMaxValue(Width) + 1;\n        }\n      }\n    }\n    break;\n\n  case Instruction::And:\n    if (match(BO.getOperand(1), m_APInt(C)))\n      // 'and x, C' produces [0, C].\n      Upper = *C + 1;\n    break;\n\n  case Instruction::Or:\n    if (match(BO.getOperand(1), m_APInt(C)))\n      // 'or x, C' produces [C, UINT_MAX].\n      Lower = *C;\n    break;\n\n  case Instruction::AShr:\n    if (match(BO.getOperand(1), m_APInt(C)) && C->ult(Width)) {\n      // 'ashr x, C' produces [INT_MIN >> C, INT_MAX >> C].\n      Lower = APInt::getSignedMinValue(Width).ashr(*C);\n      Upper = APInt::getSignedMaxValue(Width).ashr(*C) + 1;\n    } else if (match(BO.getOperand(0), m_APInt(C))) {\n      unsigned ShiftAmount = Width - 1;\n      if (!C->isNullValue() && IIQ.isExact(&BO))\n        ShiftAmount = C->countTrailingZeros();\n      if (C->isNegative()) {\n        // 'ashr C, x' produces [C, C >> (Width-1)]\n        Lower = *C;\n        Upper = C->ashr(ShiftAmount) + 1;\n      } else {\n        // 'ashr C, x' produces [C >> (Width-1), C]\n        Lower = C->ashr(ShiftAmount);\n        Upper = *C + 1;\n      }\n    }\n    break;\n\n  case Instruction::LShr:\n    if (match(BO.getOperand(1), m_APInt(C)) && C->ult(Width)) {\n      // 'lshr x, C' produces [0, UINT_MAX >> C].\n      Upper = APInt::getAllOnesValue(Width).lshr(*C) + 1;\n    } else if (match(BO.getOperand(0), m_APInt(C))) {\n      // 'lshr C, x' produces [C >> (Width-1), C].\n      unsigned ShiftAmount = Width - 1;\n      if (!C->isNullValue() && IIQ.isExact(&BO))\n        ShiftAmount = C->countTrailingZeros();\n      Lower = C->lshr(ShiftAmount);\n      Upper = *C + 1;\n    }\n    break;\n\n  case Instruction::Shl:\n    if (match(BO.getOperand(0), m_APInt(C))) {\n      if (IIQ.hasNoUnsignedWrap(&BO)) {\n        // 'shl nuw C, x' produces [C, C << CLZ(C)]\n        Lower = *C;\n        Upper = Lower.shl(Lower.countLeadingZeros()) + 1;\n      } else if (BO.hasNoSignedWrap()) { // TODO: What if both nuw+nsw?\n        if (C->isNegative()) {\n          // 'shl nsw C, x' produces [C << CLO(C)-1, C]\n          unsigned ShiftAmount = C->countLeadingOnes() - 1;\n          Lower = C->shl(ShiftAmount);\n          Upper = *C + 1;\n        } else {\n          // 'shl nsw C, x' produces [C, C << CLZ(C)-1]\n          unsigned ShiftAmount = C->countLeadingZeros() - 1;\n          Lower = *C;\n          Upper = C->shl(ShiftAmount) + 1;\n        }\n      }\n    }\n    break;\n\n  case Instruction::SDiv:\n    if (match(BO.getOperand(1), m_APInt(C))) {\n      APInt IntMin = APInt::getSignedMinValue(Width);\n      APInt IntMax = APInt::getSignedMaxValue(Width);\n      if (C->isAllOnesValue()) {\n        // 'sdiv x, -1' produces [INT_MIN + 1, INT_MAX]\n        //    where C != -1 and C != 0 and C != 1\n        Lower = IntMin + 1;\n        Upper = IntMax + 1;\n      } else if (C->countLeadingZeros() < Width - 1) {\n        // 'sdiv x, C' produces [INT_MIN / C, INT_MAX / C]\n        //    where C != -1 and C != 0 and C != 1\n        Lower = IntMin.sdiv(*C);\n        Upper = IntMax.sdiv(*C);\n        if (Lower.sgt(Upper))\n          std::swap(Lower, Upper);\n        Upper = Upper + 1;\n        assert(Upper != Lower && \"Upper part of range has wrapped!\");\n      }\n    } else if (match(BO.getOperand(0), m_APInt(C))) {\n      if (C->isMinSignedValue()) {\n        // 'sdiv INT_MIN, x' produces [INT_MIN, INT_MIN / -2].\n        Lower = *C;\n        Upper = Lower.lshr(1) + 1;\n      } else {\n        // 'sdiv C, x' produces [-|C|, |C|].\n        Upper = C->abs() + 1;\n        Lower = (-Upper) + 1;\n      }\n    }\n    break;\n\n  case Instruction::UDiv:\n    if (match(BO.getOperand(1), m_APInt(C)) && !C->isNullValue()) {\n      // 'udiv x, C' produces [0, UINT_MAX / C].\n      Upper = APInt::getMaxValue(Width).udiv(*C) + 1;\n    } else if (match(BO.getOperand(0), m_APInt(C))) {\n      // 'udiv C, x' produces [0, C].\n      Upper = *C + 1;\n    }\n    break;\n\n  case Instruction::SRem:\n    if (match(BO.getOperand(1), m_APInt(C))) {\n      // 'srem x, C' produces (-|C|, |C|).\n      Upper = C->abs();\n      Lower = (-Upper) + 1;\n    }\n    break;\n\n  case Instruction::URem:\n    if (match(BO.getOperand(1), m_APInt(C)))\n      // 'urem x, C' produces [0, C).\n      Upper = *C;\n    break;\n\n  default:\n    break;\n  }\n}\n\nstatic void setLimitsForIntrinsic(const IntrinsicInst &II, APInt &Lower,\n                                  APInt &Upper) {\n  unsigned Width = Lower.getBitWidth();\n  const APInt *C;\n  switch (II.getIntrinsicID()) {\n  case Intrinsic::ctpop:\n  case Intrinsic::ctlz:\n  case Intrinsic::cttz:\n    // Maximum of set/clear bits is the bit width.\n    assert(Lower == 0 && \"Expected lower bound to be zero\");\n    Upper = Width + 1;\n    break;\n  case Intrinsic::uadd_sat:\n    // uadd.sat(x, C) produces [C, UINT_MAX].\n    if (match(II.getOperand(0), m_APInt(C)) ||\n        match(II.getOperand(1), m_APInt(C)))\n      Lower = *C;\n    break;\n  case Intrinsic::sadd_sat:\n    if (match(II.getOperand(0), m_APInt(C)) ||\n        match(II.getOperand(1), m_APInt(C))) {\n      if (C->isNegative()) {\n        // sadd.sat(x, -C) produces [SINT_MIN, SINT_MAX + (-C)].\n        Lower = APInt::getSignedMinValue(Width);\n        Upper = APInt::getSignedMaxValue(Width) + *C + 1;\n      } else {\n        // sadd.sat(x, +C) produces [SINT_MIN + C, SINT_MAX].\n        Lower = APInt::getSignedMinValue(Width) + *C;\n        Upper = APInt::getSignedMaxValue(Width) + 1;\n      }\n    }\n    break;\n  case Intrinsic::usub_sat:\n    // usub.sat(C, x) produces [0, C].\n    if (match(II.getOperand(0), m_APInt(C)))\n      Upper = *C + 1;\n    // usub.sat(x, C) produces [0, UINT_MAX - C].\n    else if (match(II.getOperand(1), m_APInt(C)))\n      Upper = APInt::getMaxValue(Width) - *C + 1;\n    break;\n  case Intrinsic::ssub_sat:\n    if (match(II.getOperand(0), m_APInt(C))) {\n      if (C->isNegative()) {\n        // ssub.sat(-C, x) produces [SINT_MIN, -SINT_MIN + (-C)].\n        Lower = APInt::getSignedMinValue(Width);\n        Upper = *C - APInt::getSignedMinValue(Width) + 1;\n      } else {\n        // ssub.sat(+C, x) produces [-SINT_MAX + C, SINT_MAX].\n        Lower = *C - APInt::getSignedMaxValue(Width);\n        Upper = APInt::getSignedMaxValue(Width) + 1;\n      }\n    } else if (match(II.getOperand(1), m_APInt(C))) {\n      if (C->isNegative()) {\n        // ssub.sat(x, -C) produces [SINT_MIN - (-C), SINT_MAX]:\n        Lower = APInt::getSignedMinValue(Width) - *C;\n        Upper = APInt::getSignedMaxValue(Width) + 1;\n      } else {\n        // ssub.sat(x, +C) produces [SINT_MIN, SINT_MAX - C].\n        Lower = APInt::getSignedMinValue(Width);\n        Upper = APInt::getSignedMaxValue(Width) - *C + 1;\n      }\n    }\n    break;\n  case Intrinsic::umin:\n  case Intrinsic::umax:\n  case Intrinsic::smin:\n  case Intrinsic::smax:\n    if (!match(II.getOperand(0), m_APInt(C)) &&\n        !match(II.getOperand(1), m_APInt(C)))\n      break;\n\n    switch (II.getIntrinsicID()) {\n    case Intrinsic::umin:\n      Upper = *C + 1;\n      break;\n    case Intrinsic::umax:\n      Lower = *C;\n      break;\n    case Intrinsic::smin:\n      Lower = APInt::getSignedMinValue(Width);\n      Upper = *C + 1;\n      break;\n    case Intrinsic::smax:\n      Lower = *C;\n      Upper = APInt::getSignedMaxValue(Width) + 1;\n      break;\n    default:\n      llvm_unreachable(\"Must be min/max intrinsic\");\n    }\n    break;\n  case Intrinsic::abs:\n    // If abs of SIGNED_MIN is poison, then the result is [0..SIGNED_MAX],\n    // otherwise it is [0..SIGNED_MIN], as -SIGNED_MIN == SIGNED_MIN.\n    if (match(II.getOperand(1), m_One()))\n      Upper = APInt::getSignedMaxValue(Width) + 1;\n    else\n      Upper = APInt::getSignedMinValue(Width) + 1;\n    break;\n  default:\n    break;\n  }\n}\n\nstatic void setLimitsForSelectPattern(const SelectInst &SI, APInt &Lower,\n                                      APInt &Upper, const InstrInfoQuery &IIQ) {\n  const Value *LHS = nullptr, *RHS = nullptr;\n  SelectPatternResult R = matchSelectPattern(&SI, LHS, RHS);\n  if (R.Flavor == SPF_UNKNOWN)\n    return;\n\n  unsigned BitWidth = SI.getType()->getScalarSizeInBits();\n\n  if (R.Flavor == SelectPatternFlavor::SPF_ABS) {\n    // If the negation part of the abs (in RHS) has the NSW flag,\n    // then the result of abs(X) is [0..SIGNED_MAX],\n    // otherwise it is [0..SIGNED_MIN], as -SIGNED_MIN == SIGNED_MIN.\n    Lower = APInt::getNullValue(BitWidth);\n    if (match(RHS, m_Neg(m_Specific(LHS))) &&\n        IIQ.hasNoSignedWrap(cast<Instruction>(RHS)))\n      Upper = APInt::getSignedMaxValue(BitWidth) + 1;\n    else\n      Upper = APInt::getSignedMinValue(BitWidth) + 1;\n    return;\n  }\n\n  if (R.Flavor == SelectPatternFlavor::SPF_NABS) {\n    // The result of -abs(X) is <= 0.\n    Lower = APInt::getSignedMinValue(BitWidth);\n    Upper = APInt(BitWidth, 1);\n    return;\n  }\n\n  const APInt *C;\n  if (!match(LHS, m_APInt(C)) && !match(RHS, m_APInt(C)))\n    return;\n\n  switch (R.Flavor) {\n    case SPF_UMIN:\n      Upper = *C + 1;\n      break;\n    case SPF_UMAX:\n      Lower = *C;\n      break;\n    case SPF_SMIN:\n      Lower = APInt::getSignedMinValue(BitWidth);\n      Upper = *C + 1;\n      break;\n    case SPF_SMAX:\n      Lower = *C;\n      Upper = APInt::getSignedMaxValue(BitWidth) + 1;\n      break;\n    default:\n      break;\n  }\n}\n\nConstantRange llvm::computeConstantRange(const Value *V, bool UseInstrInfo,\n                                         AssumptionCache *AC,\n                                         const Instruction *CtxI,\n                                         unsigned Depth) {\n  assert(V->getType()->isIntOrIntVectorTy() && \"Expected integer instruction\");\n\n  if (Depth == MaxAnalysisRecursionDepth)\n    return ConstantRange::getFull(V->getType()->getScalarSizeInBits());\n\n  const APInt *C;\n  if (match(V, m_APInt(C)))\n    return ConstantRange(*C);\n\n  InstrInfoQuery IIQ(UseInstrInfo);\n  unsigned BitWidth = V->getType()->getScalarSizeInBits();\n  APInt Lower = APInt(BitWidth, 0);\n  APInt Upper = APInt(BitWidth, 0);\n  if (auto *BO = dyn_cast<BinaryOperator>(V))\n    setLimitsForBinOp(*BO, Lower, Upper, IIQ);\n  else if (auto *II = dyn_cast<IntrinsicInst>(V))\n    setLimitsForIntrinsic(*II, Lower, Upper);\n  else if (auto *SI = dyn_cast<SelectInst>(V))\n    setLimitsForSelectPattern(*SI, Lower, Upper, IIQ);\n\n  ConstantRange CR = ConstantRange::getNonEmpty(Lower, Upper);\n\n  if (auto *I = dyn_cast<Instruction>(V))\n    if (auto *Range = IIQ.getMetadata(I, LLVMContext::MD_range))\n      CR = CR.intersectWith(getConstantRangeFromMetadata(*Range));\n\n  if (CtxI && AC) {\n    // Try to restrict the range based on information from assumptions.\n    for (auto &AssumeVH : AC->assumptionsFor(V)) {\n      if (!AssumeVH)\n        continue;\n      CallInst *I = cast<CallInst>(AssumeVH);\n      assert(I->getParent()->getParent() == CtxI->getParent()->getParent() &&\n             \"Got assumption for the wrong function!\");\n      assert(I->getCalledFunction()->getIntrinsicID() == Intrinsic::assume &&\n             \"must be an assume intrinsic\");\n\n      if (!isValidAssumeForContext(I, CtxI, nullptr))\n        continue;\n      Value *Arg = I->getArgOperand(0);\n      ICmpInst *Cmp = dyn_cast<ICmpInst>(Arg);\n      // Currently we just use information from comparisons.\n      if (!Cmp || Cmp->getOperand(0) != V)\n        continue;\n      ConstantRange RHS = computeConstantRange(Cmp->getOperand(1), UseInstrInfo,\n                                               AC, I, Depth + 1);\n      CR = CR.intersectWith(\n          ConstantRange::makeSatisfyingICmpRegion(Cmp->getPredicate(), RHS));\n    }\n  }\n\n  return CR;\n}\n\nstatic Optional<int64_t>\ngetOffsetFromIndex(const GEPOperator *GEP, unsigned Idx, const DataLayout &DL) {\n  // Skip over the first indices.\n  gep_type_iterator GTI = gep_type_begin(GEP);\n  for (unsigned i = 1; i != Idx; ++i, ++GTI)\n    /*skip along*/;\n\n  // Compute the offset implied by the rest of the indices.\n  int64_t Offset = 0;\n  for (unsigned i = Idx, e = GEP->getNumOperands(); i != e; ++i, ++GTI) {\n    ConstantInt *OpC = dyn_cast<ConstantInt>(GEP->getOperand(i));\n    if (!OpC)\n      return None;\n    if (OpC->isZero())\n      continue; // No offset.\n\n    // Handle struct indices, which add their field offset to the pointer.\n    if (StructType *STy = GTI.getStructTypeOrNull()) {\n      Offset += DL.getStructLayout(STy)->getElementOffset(OpC->getZExtValue());\n      continue;\n    }\n\n    // Otherwise, we have a sequential type like an array or fixed-length\n    // vector. Multiply the index by the ElementSize.\n    TypeSize Size = DL.getTypeAllocSize(GTI.getIndexedType());\n    if (Size.isScalable())\n      return None;\n    Offset += Size.getFixedSize() * OpC->getSExtValue();\n  }\n\n  return Offset;\n}\n\nOptional<int64_t> llvm::isPointerOffset(const Value *Ptr1, const Value *Ptr2,\n                                        const DataLayout &DL) {\n  Ptr1 = Ptr1->stripPointerCasts();\n  Ptr2 = Ptr2->stripPointerCasts();\n\n  // Handle the trivial case first.\n  if (Ptr1 == Ptr2) {\n    return 0;\n  }\n\n  const GEPOperator *GEP1 = dyn_cast<GEPOperator>(Ptr1);\n  const GEPOperator *GEP2 = dyn_cast<GEPOperator>(Ptr2);\n\n  // If one pointer is a GEP see if the GEP is a constant offset from the base,\n  // as in \"P\" and \"gep P, 1\".\n  // Also do this iteratively to handle the the following case:\n  //   Ptr_t1 = GEP Ptr1, c1\n  //   Ptr_t2 = GEP Ptr_t1, c2\n  //   Ptr2 = GEP Ptr_t2, c3\n  // where we will return c1+c2+c3.\n  // TODO: Handle the case when both Ptr1 and Ptr2 are GEPs of some common base\n  // -- replace getOffsetFromBase with getOffsetAndBase, check that the bases\n  // are the same, and return the difference between offsets.\n  auto getOffsetFromBase = [&DL](const GEPOperator *GEP,\n                                 const Value *Ptr) -> Optional<int64_t> {\n    const GEPOperator *GEP_T = GEP;\n    int64_t OffsetVal = 0;\n    bool HasSameBase = false;\n    while (GEP_T) {\n      auto Offset = getOffsetFromIndex(GEP_T, 1, DL);\n      if (!Offset)\n        return None;\n      OffsetVal += *Offset;\n      auto Op0 = GEP_T->getOperand(0)->stripPointerCasts();\n      if (Op0 == Ptr) {\n        HasSameBase = true;\n        break;\n      }\n      GEP_T = dyn_cast<GEPOperator>(Op0);\n    }\n    if (!HasSameBase)\n      return None;\n    return OffsetVal;\n  };\n\n  if (GEP1) {\n    auto Offset = getOffsetFromBase(GEP1, Ptr2);\n    if (Offset)\n      return -*Offset;\n  }\n  if (GEP2) {\n    auto Offset = getOffsetFromBase(GEP2, Ptr1);\n    if (Offset)\n      return Offset;\n  }\n\n  // Right now we handle the case when Ptr1/Ptr2 are both GEPs with an identical\n  // base.  After that base, they may have some number of common (and\n  // potentially variable) indices.  After that they handle some constant\n  // offset, which determines their offset from each other.  At this point, we\n  // handle no other case.\n  if (!GEP1 || !GEP2 || GEP1->getOperand(0) != GEP2->getOperand(0))\n    return None;\n\n  // Skip any common indices and track the GEP types.\n  unsigned Idx = 1;\n  for (; Idx != GEP1->getNumOperands() && Idx != GEP2->getNumOperands(); ++Idx)\n    if (GEP1->getOperand(Idx) != GEP2->getOperand(Idx))\n      break;\n\n  auto Offset1 = getOffsetFromIndex(GEP1, Idx, DL);\n  auto Offset2 = getOffsetFromIndex(GEP2, Idx, DL);\n  if (!Offset1 || !Offset2)\n    return None;\n  return *Offset2 - *Offset1;\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h", "content": "//===- llvm/Analysis/ValueTracking.h - Walk computations --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains routines that help analyze properties that chains of\n// computations have.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_VALUETRACKING_H\n#define LLVM_ANALYSIS_VALUETRACKING_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Operator.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\n\nclass AddOperator;\nclass AllocaInst;\nclass APInt;\nclass AssumptionCache;\nclass DominatorTree;\nclass GEPOperator;\nclass IntrinsicInst;\nclass LoadInst;\nclass WithOverflowInst;\nstruct KnownBits;\nclass Loop;\nclass LoopInfo;\nclass MDNode;\nclass OptimizationRemarkEmitter;\nclass StringRef;\nclass TargetLibraryInfo;\nclass Value;\n\nconstexpr unsigned MaxAnalysisRecursionDepth = 6;\n\n  /// Determine which bits of V are known to be either zero or one and return\n  /// them in the KnownZero/KnownOne bit sets.\n  ///\n  /// This function is defined on values with integer type, values with pointer\n  /// type, and vectors of integers.  In the case\n  /// where V is a vector, the known zero and known one values are the\n  /// same width as the vector element, and the bit is set only if it is true\n  /// for all of the elements in the vector.\n  void computeKnownBits(const Value *V, KnownBits &Known,\n                        const DataLayout &DL, unsigned Depth = 0,\n                        AssumptionCache *AC = nullptr,\n                        const Instruction *CxtI = nullptr,\n                        const DominatorTree *DT = nullptr,\n                        OptimizationRemarkEmitter *ORE = nullptr,\n                        bool UseInstrInfo = true);\n\n  /// Determine which bits of V are known to be either zero or one and return\n  /// them in the KnownZero/KnownOne bit sets.\n  ///\n  /// This function is defined on values with integer type, values with pointer\n  /// type, and vectors of integers.  In the case\n  /// where V is a vector, the known zero and known one values are the\n  /// same width as the vector element, and the bit is set only if it is true\n  /// for all of the demanded elements in the vector.\n  void computeKnownBits(const Value *V, const APInt &DemandedElts,\n                        KnownBits &Known, const DataLayout &DL,\n                        unsigned Depth = 0, AssumptionCache *AC = nullptr,\n                        const Instruction *CxtI = nullptr,\n                        const DominatorTree *DT = nullptr,\n                        OptimizationRemarkEmitter *ORE = nullptr,\n                        bool UseInstrInfo = true);\n\n  /// Returns the known bits rather than passing by reference.\n  KnownBits computeKnownBits(const Value *V, const DataLayout &DL,\n                             unsigned Depth = 0, AssumptionCache *AC = nullptr,\n                             const Instruction *CxtI = nullptr,\n                             const DominatorTree *DT = nullptr,\n                             OptimizationRemarkEmitter *ORE = nullptr,\n                             bool UseInstrInfo = true);\n\n  /// Returns the known bits rather than passing by reference.\n  KnownBits computeKnownBits(const Value *V, const APInt &DemandedElts,\n                             const DataLayout &DL, unsigned Depth = 0,\n                             AssumptionCache *AC = nullptr,\n                             const Instruction *CxtI = nullptr,\n                             const DominatorTree *DT = nullptr,\n                             OptimizationRemarkEmitter *ORE = nullptr,\n                             bool UseInstrInfo = true);\n\n  /// Compute known bits from the range metadata.\n  /// \\p KnownZero the set of bits that are known to be zero\n  /// \\p KnownOne the set of bits that are known to be one\n  void computeKnownBitsFromRangeMetadata(const MDNode &Ranges,\n                                         KnownBits &Known);\n\n  /// Return true if LHS and RHS have no common bits set.\n  bool haveNoCommonBitsSet(const Value *LHS, const Value *RHS,\n                           const DataLayout &DL,\n                           AssumptionCache *AC = nullptr,\n                           const Instruction *CxtI = nullptr,\n                           const DominatorTree *DT = nullptr,\n                           bool UseInstrInfo = true);\n\n  /// Return true if the given value is known to have exactly one bit set when\n  /// defined. For vectors return true if every element is known to be a power\n  /// of two when defined. Supports values with integer or pointer type and\n  /// vectors of integers. If 'OrZero' is set, then return true if the given\n  /// value is either a power of two or zero.\n  bool isKnownToBeAPowerOfTwo(const Value *V, const DataLayout &DL,\n                              bool OrZero = false, unsigned Depth = 0,\n                              AssumptionCache *AC = nullptr,\n                              const Instruction *CxtI = nullptr,\n                              const DominatorTree *DT = nullptr,\n                              bool UseInstrInfo = true);\n\n  bool isOnlyUsedInZeroEqualityComparison(const Instruction *CxtI);\n\n  /// Return true if the given value is known to be non-zero when defined. For\n  /// vectors, return true if every element is known to be non-zero when\n  /// defined. For pointers, if the context instruction and dominator tree are\n  /// specified, perform context-sensitive analysis and return true if the\n  /// pointer couldn't possibly be null at the specified instruction.\n  /// Supports values with integer or pointer type and vectors of integers.\n  bool isKnownNonZero(const Value *V, const DataLayout &DL, unsigned Depth = 0,\n                      AssumptionCache *AC = nullptr,\n                      const Instruction *CxtI = nullptr,\n                      const DominatorTree *DT = nullptr,\n                      bool UseInstrInfo = true);\n\n  /// Return true if the two given values are negation.\n  /// Currently can recoginze Value pair:\n  /// 1: <X, Y> if X = sub (0, Y) or Y = sub (0, X)\n  /// 2: <X, Y> if X = sub (A, B) and Y = sub (B, A)\n  bool isKnownNegation(const Value *X, const Value *Y, bool NeedNSW = false);\n\n  /// Returns true if the give value is known to be non-negative.\n  bool isKnownNonNegative(const Value *V, const DataLayout &DL,\n                          unsigned Depth = 0,\n                          AssumptionCache *AC = nullptr,\n                          const Instruction *CxtI = nullptr,\n                          const DominatorTree *DT = nullptr,\n                          bool UseInstrInfo = true);\n\n  /// Returns true if the given value is known be positive (i.e. non-negative\n  /// and non-zero).\n  bool isKnownPositive(const Value *V, const DataLayout &DL, unsigned Depth = 0,\n                       AssumptionCache *AC = nullptr,\n                       const Instruction *CxtI = nullptr,\n                       const DominatorTree *DT = nullptr,\n                       bool UseInstrInfo = true);\n\n  /// Returns true if the given value is known be negative (i.e. non-positive\n  /// and non-zero).\n  bool isKnownNegative(const Value *V, const DataLayout &DL, unsigned Depth = 0,\n                       AssumptionCache *AC = nullptr,\n                       const Instruction *CxtI = nullptr,\n                       const DominatorTree *DT = nullptr,\n                       bool UseInstrInfo = true);\n\n  /// Return true if the given values are known to be non-equal when defined.\n  /// Supports scalar integer types only.\n  bool isKnownNonEqual(const Value *V1, const Value *V2, const DataLayout &DL,\n                       AssumptionCache *AC = nullptr,\n                       const Instruction *CxtI = nullptr,\n                       const DominatorTree *DT = nullptr,\n                       bool UseInstrInfo = true);\n\n  /// Return true if 'V & Mask' is known to be zero. We use this predicate to\n  /// simplify operations downstream. Mask is known to be zero for bits that V\n  /// cannot have.\n  ///\n  /// This function is defined on values with integer type, values with pointer\n  /// type, and vectors of integers.  In the case\n  /// where V is a vector, the mask, known zero, and known one values are the\n  /// same width as the vector element, and the bit is set only if it is true\n  /// for all of the elements in the vector.\n  bool MaskedValueIsZero(const Value *V, const APInt &Mask,\n                         const DataLayout &DL,\n                         unsigned Depth = 0, AssumptionCache *AC = nullptr,\n                         const Instruction *CxtI = nullptr,\n                         const DominatorTree *DT = nullptr,\n                         bool UseInstrInfo = true);\n\n  /// Return the number of times the sign bit of the register is replicated into\n  /// the other bits. We know that at least 1 bit is always equal to the sign\n  /// bit (itself), but other cases can give us information. For example,\n  /// immediately after an \"ashr X, 2\", we know that the top 3 bits are all\n  /// equal to each other, so we return 3. For vectors, return the number of\n  /// sign bits for the vector element with the mininum number of known sign\n  /// bits.\n  unsigned ComputeNumSignBits(const Value *Op, const DataLayout &DL,\n                              unsigned Depth = 0, AssumptionCache *AC = nullptr,\n                              const Instruction *CxtI = nullptr,\n                              const DominatorTree *DT = nullptr,\n                              bool UseInstrInfo = true);\n\n  /// This function computes the integer multiple of Base that equals V. If\n  /// successful, it returns true and returns the multiple in Multiple. If\n  /// unsuccessful, it returns false. Also, if V can be simplified to an\n  /// integer, then the simplified V is returned in Val. Look through sext only\n  /// if LookThroughSExt=true.\n  bool ComputeMultiple(Value *V, unsigned Base, Value *&Multiple,\n                       bool LookThroughSExt = false,\n                       unsigned Depth = 0);\n\n  /// Map a call instruction to an intrinsic ID.  Libcalls which have equivalent\n  /// intrinsics are treated as-if they were intrinsics.\n  Intrinsic::ID getIntrinsicForCallSite(const CallBase &CB,\n                                        const TargetLibraryInfo *TLI);\n\n  /// Return true if we can prove that the specified FP value is never equal to\n  /// -0.0.\n  bool CannotBeNegativeZero(const Value *V, const TargetLibraryInfo *TLI,\n                            unsigned Depth = 0);\n\n  /// Return true if we can prove that the specified FP value is either NaN or\n  /// never less than -0.0.\n  ///\n  ///      NaN --> true\n  ///       +0 --> true\n  ///       -0 --> true\n  ///   x > +0 --> true\n  ///   x < -0 --> false\n  bool CannotBeOrderedLessThanZero(const Value *V, const TargetLibraryInfo *TLI);\n\n  /// Return true if the floating-point scalar value is not an infinity or if\n  /// the floating-point vector value has no infinities. Return false if a value\n  /// could ever be infinity.\n  bool isKnownNeverInfinity(const Value *V, const TargetLibraryInfo *TLI,\n                            unsigned Depth = 0);\n\n  /// Return true if the floating-point scalar value is not a NaN or if the\n  /// floating-point vector value has no NaN elements. Return false if a value\n  /// could ever be NaN.\n  bool isKnownNeverNaN(const Value *V, const TargetLibraryInfo *TLI,\n                       unsigned Depth = 0);\n\n  /// Return true if we can prove that the specified FP value's sign bit is 0.\n  ///\n  ///      NaN --> true/false (depending on the NaN's sign bit)\n  ///       +0 --> true\n  ///       -0 --> false\n  ///   x > +0 --> true\n  ///   x < -0 --> false\n  bool SignBitMustBeZero(const Value *V, const TargetLibraryInfo *TLI);\n\n  /// If the specified value can be set by repeating the same byte in memory,\n  /// return the i8 value that it is represented with. This is true for all i8\n  /// values obviously, but is also true for i32 0, i32 -1, i16 0xF0F0, double\n  /// 0.0 etc. If the value can't be handled with a repeated byte store (e.g.\n  /// i16 0x1234), return null. If the value is entirely undef and padding,\n  /// return undef.\n  Value *isBytewiseValue(Value *V, const DataLayout &DL);\n\n  /// Given an aggregate and an sequence of indices, see if the scalar value\n  /// indexed is already around as a register, for example if it were inserted\n  /// directly into the aggregate.\n  ///\n  /// If InsertBefore is not null, this function will duplicate (modified)\n  /// insertvalues when a part of a nested struct is extracted.\n  Value *FindInsertedValue(Value *V,\n                           ArrayRef<unsigned> idx_range,\n                           Instruction *InsertBefore = nullptr);\n\n  /// Analyze the specified pointer to see if it can be expressed as a base\n  /// pointer plus a constant offset. Return the base and offset to the caller.\n  ///\n  /// This is a wrapper around Value::stripAndAccumulateConstantOffsets that\n  /// creates and later unpacks the required APInt.\n  inline Value *GetPointerBaseWithConstantOffset(Value *Ptr, int64_t &Offset,\n                                                 const DataLayout &DL,\n                                                 bool AllowNonInbounds = true) {\n    APInt OffsetAPInt(DL.getIndexTypeSizeInBits(Ptr->getType()), 0);\n    Value *Base =\n        Ptr->stripAndAccumulateConstantOffsets(DL, OffsetAPInt, AllowNonInbounds);\n\n    Offset = OffsetAPInt.getSExtValue();\n    return Base;\n  }\n  inline const Value *\n  GetPointerBaseWithConstantOffset(const Value *Ptr, int64_t &Offset,\n                                   const DataLayout &DL,\n                                   bool AllowNonInbounds = true) {\n    return GetPointerBaseWithConstantOffset(const_cast<Value *>(Ptr), Offset, DL,\n                                            AllowNonInbounds);\n  }\n\n  /// Returns true if the GEP is based on a pointer to a string (array of\n  // \\p CharSize integers) and is indexing into this string.\n  bool isGEPBasedOnPointerToString(const GEPOperator *GEP,\n                                   unsigned CharSize = 8);\n\n  /// Represents offset+length into a ConstantDataArray.\n  struct ConstantDataArraySlice {\n    /// ConstantDataArray pointer. nullptr indicates a zeroinitializer (a valid\n    /// initializer, it just doesn't fit the ConstantDataArray interface).\n    const ConstantDataArray *Array;\n\n    /// Slice starts at this Offset.\n    uint64_t Offset;\n\n    /// Length of the slice.\n    uint64_t Length;\n\n    /// Moves the Offset and adjusts Length accordingly.\n    void move(uint64_t Delta) {\n      assert(Delta < Length);\n      Offset += Delta;\n      Length -= Delta;\n    }\n\n    /// Convenience accessor for elements in the slice.\n    uint64_t operator[](unsigned I) const {\n      return Array==nullptr ? 0 : Array->getElementAsInteger(I + Offset);\n    }\n  };\n\n  /// Returns true if the value \\p V is a pointer into a ConstantDataArray.\n  /// If successful \\p Slice will point to a ConstantDataArray info object\n  /// with an appropriate offset.\n  bool getConstantDataArrayInfo(const Value *V, ConstantDataArraySlice &Slice,\n                                unsigned ElementSize, uint64_t Offset = 0);\n\n  /// This function computes the length of a null-terminated C string pointed to\n  /// by V. If successful, it returns true and returns the string in Str. If\n  /// unsuccessful, it returns false. This does not include the trailing null\n  /// character by default. If TrimAtNul is set to false, then this returns any\n  /// trailing null characters as well as any other characters that come after\n  /// it.\n  bool getConstantStringInfo(const Value *V, StringRef &Str,\n                             uint64_t Offset = 0, bool TrimAtNul = true);\n\n  /// If we can compute the length of the string pointed to by the specified\n  /// pointer, return 'len+1'.  If we can't, return 0.\n  uint64_t GetStringLength(const Value *V, unsigned CharSize = 8);\n\n  /// This function returns call pointer argument that is considered the same by\n  /// aliasing rules. You CAN'T use it to replace one value with another. If\n  /// \\p MustPreserveNullness is true, the call must preserve the nullness of\n  /// the pointer.\n  const Value *getArgumentAliasingToReturnedPointer(const CallBase *Call,\n                                                    bool MustPreserveNullness);\n  inline Value *\n  getArgumentAliasingToReturnedPointer(CallBase *Call,\n                                       bool MustPreserveNullness) {\n    return const_cast<Value *>(getArgumentAliasingToReturnedPointer(\n        const_cast<const CallBase *>(Call), MustPreserveNullness));\n  }\n\n  /// {launder,strip}.invariant.group returns pointer that aliases its argument,\n  /// and it only captures pointer by returning it.\n  /// These intrinsics are not marked as nocapture, because returning is\n  /// considered as capture. The arguments are not marked as returned neither,\n  /// because it would make it useless. If \\p MustPreserveNullness is true,\n  /// the intrinsic must preserve the nullness of the pointer.\n  bool isIntrinsicReturningPointerAliasingArgumentWithoutCapturing(\n      const CallBase *Call, bool MustPreserveNullness);\n\n  /// This method strips off any GEP address adjustments and pointer casts from\n  /// the specified value, returning the original object being addressed. Note\n  /// that the returned value has pointer type if the specified value does. If\n  /// the MaxLookup value is non-zero, it limits the number of instructions to\n  /// be stripped off.\n  Value *getUnderlyingObject(Value *V, unsigned MaxLookup = 6);\n  inline const Value *getUnderlyingObject(const Value *V,\n                                          unsigned MaxLookup = 6) {\n    return getUnderlyingObject(const_cast<Value *>(V), MaxLookup);\n  }\n\n  /// This method is similar to getUnderlyingObject except that it can\n  /// look through phi and select instructions and return multiple objects.\n  ///\n  /// If LoopInfo is passed, loop phis are further analyzed.  If a pointer\n  /// accesses different objects in each iteration, we don't look through the\n  /// phi node. E.g. consider this loop nest:\n  ///\n  ///   int **A;\n  ///   for (i)\n  ///     for (j) {\n  ///        A[i][j] = A[i-1][j] * B[j]\n  ///     }\n  ///\n  /// This is transformed by Load-PRE to stash away A[i] for the next iteration\n  /// of the outer loop:\n  ///\n  ///   Curr = A[0];          // Prev_0\n  ///   for (i: 1..N) {\n  ///     Prev = Curr;        // Prev = PHI (Prev_0, Curr)\n  ///     Curr = A[i];\n  ///     for (j: 0..N) {\n  ///        Curr[j] = Prev[j] * B[j]\n  ///     }\n  ///   }\n  ///\n  /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects\n  /// should not assume that Curr and Prev share the same underlying object thus\n  /// it shouldn't look through the phi above.\n  void getUnderlyingObjects(const Value *V,\n                            SmallVectorImpl<const Value *> &Objects,\n                            LoopInfo *LI = nullptr, unsigned MaxLookup = 6);\n\n  /// This is a wrapper around getUnderlyingObjects and adds support for basic\n  /// ptrtoint+arithmetic+inttoptr sequences.\n  bool getUnderlyingObjectsForCodeGen(const Value *V,\n                                      SmallVectorImpl<Value *> &Objects);\n\n  /// Returns unique alloca where the value comes from, or nullptr.\n  /// If OffsetZero is true check that V points to the begining of the alloca.\n  AllocaInst *findAllocaForValue(Value *V, bool OffsetZero = false);\n  inline const AllocaInst *findAllocaForValue(const Value *V,\n                                              bool OffsetZero = false) {\n    return findAllocaForValue(const_cast<Value *>(V), OffsetZero);\n  }\n\n  /// Return true if the only users of this pointer are lifetime markers.\n  bool onlyUsedByLifetimeMarkers(const Value *V);\n\n  /// Return true if the only users of this pointer are lifetime markers or\n  /// droppable instructions.\n  bool onlyUsedByLifetimeMarkersOrDroppableInsts(const Value *V);\n\n  /// Return true if speculation of the given load must be suppressed to avoid\n  /// ordering or interfering with an active sanitizer.  If not suppressed,\n  /// dereferenceability and alignment must be proven separately.  Note: This\n  /// is only needed for raw reasoning; if you use the interface below\n  /// (isSafeToSpeculativelyExecute), this is handled internally.\n  bool mustSuppressSpeculation(const LoadInst &LI);\n\n  /// Return true if the instruction does not have any effects besides\n  /// calculating the result and does not have undefined behavior.\n  ///\n  /// This method never returns true for an instruction that returns true for\n  /// mayHaveSideEffects; however, this method also does some other checks in\n  /// addition. It checks for undefined behavior, like dividing by zero or\n  /// loading from an invalid pointer (but not for undefined results, like a\n  /// shift with a shift amount larger than the width of the result). It checks\n  /// for malloc and alloca because speculatively executing them might cause a\n  /// memory leak. It also returns false for instructions related to control\n  /// flow, specifically terminators and PHI nodes.\n  ///\n  /// If the CtxI is specified this method performs context-sensitive analysis\n  /// and returns true if it is safe to execute the instruction immediately\n  /// before the CtxI.\n  ///\n  /// If the CtxI is NOT specified this method only looks at the instruction\n  /// itself and its operands, so if this method returns true, it is safe to\n  /// move the instruction as long as the correct dominance relationships for\n  /// the operands and users hold.\n  ///\n  /// This method can return true for instructions that read memory;\n  /// for such instructions, moving them may change the resulting value.\n  bool isSafeToSpeculativelyExecute(const Value *V,\n                                    const Instruction *CtxI = nullptr,\n                                    const DominatorTree *DT = nullptr);\n\n  /// Returns true if the result or effects of the given instructions \\p I\n  /// depend on or influence global memory.\n  /// Memory dependence arises for example if the instruction reads from\n  /// memory or may produce effects or undefined behaviour. Memory dependent\n  /// instructions generally cannot be reorderd with respect to other memory\n  /// dependent instructions or moved into non-dominated basic blocks.\n  /// Instructions which just compute a value based on the values of their\n  /// operands are not memory dependent.\n  bool mayBeMemoryDependent(const Instruction &I);\n\n  /// Return true if it is an intrinsic that cannot be speculated but also\n  /// cannot trap.\n  bool isAssumeLikeIntrinsic(const Instruction *I);\n\n  /// Return true if it is valid to use the assumptions provided by an\n  /// assume intrinsic, I, at the point in the control-flow identified by the\n  /// context instruction, CxtI.\n  bool isValidAssumeForContext(const Instruction *I, const Instruction *CxtI,\n                               const DominatorTree *DT = nullptr);\n\n  enum class OverflowResult {\n    /// Always overflows in the direction of signed/unsigned min value.\n    AlwaysOverflowsLow,\n    /// Always overflows in the direction of signed/unsigned max value.\n    AlwaysOverflowsHigh,\n    /// May or may not overflow.\n    MayOverflow,\n    /// Never overflows.\n    NeverOverflows,\n  };\n\n  OverflowResult computeOverflowForUnsignedMul(const Value *LHS,\n                                               const Value *RHS,\n                                               const DataLayout &DL,\n                                               AssumptionCache *AC,\n                                               const Instruction *CxtI,\n                                               const DominatorTree *DT,\n                                               bool UseInstrInfo = true);\n  OverflowResult computeOverflowForSignedMul(const Value *LHS, const Value *RHS,\n                                             const DataLayout &DL,\n                                             AssumptionCache *AC,\n                                             const Instruction *CxtI,\n                                             const DominatorTree *DT,\n                                             bool UseInstrInfo = true);\n  OverflowResult computeOverflowForUnsignedAdd(const Value *LHS,\n                                               const Value *RHS,\n                                               const DataLayout &DL,\n                                               AssumptionCache *AC,\n                                               const Instruction *CxtI,\n                                               const DominatorTree *DT,\n                                               bool UseInstrInfo = true);\n  OverflowResult computeOverflowForSignedAdd(const Value *LHS, const Value *RHS,\n                                             const DataLayout &DL,\n                                             AssumptionCache *AC = nullptr,\n                                             const Instruction *CxtI = nullptr,\n                                             const DominatorTree *DT = nullptr);\n  /// This version also leverages the sign bit of Add if known.\n  OverflowResult computeOverflowForSignedAdd(const AddOperator *Add,\n                                             const DataLayout &DL,\n                                             AssumptionCache *AC = nullptr,\n                                             const Instruction *CxtI = nullptr,\n                                             const DominatorTree *DT = nullptr);\n  OverflowResult computeOverflowForUnsignedSub(const Value *LHS, const Value *RHS,\n                                               const DataLayout &DL,\n                                               AssumptionCache *AC,\n                                               const Instruction *CxtI,\n                                               const DominatorTree *DT);\n  OverflowResult computeOverflowForSignedSub(const Value *LHS, const Value *RHS,\n                                             const DataLayout &DL,\n                                             AssumptionCache *AC,\n                                             const Instruction *CxtI,\n                                             const DominatorTree *DT);\n\n  /// Returns true if the arithmetic part of the \\p WO 's result is\n  /// used only along the paths control dependent on the computation\n  /// not overflowing, \\p WO being an <op>.with.overflow intrinsic.\n  bool isOverflowIntrinsicNoWrap(const WithOverflowInst *WO,\n                                 const DominatorTree &DT);\n\n\n  /// Determine the possible constant range of an integer or vector of integer\n  /// value. This is intended as a cheap, non-recursive check.\n  ConstantRange computeConstantRange(const Value *V, bool UseInstrInfo = true,\n                                     AssumptionCache *AC = nullptr,\n                                     const Instruction *CtxI = nullptr,\n                                     unsigned Depth = 0);\n\n  /// Return true if this function can prove that the instruction I will\n  /// always transfer execution to one of its successors (including the next\n  /// instruction that follows within a basic block). E.g. this is not\n  /// guaranteed for function calls that could loop infinitely.\n  ///\n  /// In other words, this function returns false for instructions that may\n  /// transfer execution or fail to transfer execution in a way that is not\n  /// captured in the CFG nor in the sequence of instructions within a basic\n  /// block.\n  ///\n  /// Undefined behavior is assumed not to happen, so e.g. division is\n  /// guaranteed to transfer execution to the following instruction even\n  /// though division by zero might cause undefined behavior.\n  bool isGuaranteedToTransferExecutionToSuccessor(const Instruction *I);\n\n  /// Returns true if this block does not contain a potential implicit exit.\n  /// This is equivelent to saying that all instructions within the basic block\n  /// are guaranteed to transfer execution to their successor within the basic\n  /// block. This has the same assumptions w.r.t. undefined behavior as the\n  /// instruction variant of this function.\n  bool isGuaranteedToTransferExecutionToSuccessor(const BasicBlock *BB);\n\n  /// Return true if this function can prove that the instruction I\n  /// is executed for every iteration of the loop L.\n  ///\n  /// Note that this currently only considers the loop header.\n  bool isGuaranteedToExecuteForEveryIteration(const Instruction *I,\n                                              const Loop *L);\n\n  /// Return true if I yields poison or raises UB if any of its operands is\n  /// poison.\n  /// Formally, given I = `r = op v1 v2 .. vN`, propagatesPoison returns true\n  /// if, for all i, r is evaluated to poison or op raises UB if vi = poison.\n  /// To filter out operands that raise UB on poison, you can use\n  /// getGuaranteedNonPoisonOp.\n  bool propagatesPoison(const Operator *I);\n\n  /// Insert operands of I into Ops such that I will trigger undefined behavior\n  /// if I is executed and that operand has a poison value.\n  void getGuaranteedNonPoisonOps(const Instruction *I,\n                                 SmallPtrSetImpl<const Value *> &Ops);\n\n  /// Return true if the given instruction must trigger undefined behavior\n  /// when I is executed with any operands which appear in KnownPoison holding\n  /// a poison value at the point of execution.\n  bool mustTriggerUB(const Instruction *I,\n                     const SmallSet<const Value *, 16>& KnownPoison);\n\n  /// Return true if this function can prove that if Inst is executed\n  /// and yields a poison value or undef bits, then that will trigger\n  /// undefined behavior.\n  ///\n  /// Note that this currently only considers the basic block that is\n  /// the parent of Inst.\n  bool programUndefinedIfUndefOrPoison(const Instruction *Inst);\n  bool programUndefinedIfPoison(const Instruction *Inst);\n\n  /// canCreateUndefOrPoison returns true if Op can create undef or poison from\n  /// non-undef & non-poison operands.\n  /// For vectors, canCreateUndefOrPoison returns true if there is potential\n  /// poison or undef in any element of the result when vectors without\n  /// undef/poison poison are given as operands.\n  /// For example, given `Op = shl <2 x i32> %x, <0, 32>`, this function returns\n  /// true. If Op raises immediate UB but never creates poison or undef\n  /// (e.g. sdiv I, 0), canCreatePoison returns false.\n  ///\n  /// canCreatePoison returns true if Op can create poison from non-poison\n  /// operands.\n  bool canCreateUndefOrPoison(const Operator *Op);\n  bool canCreatePoison(const Operator *Op);\n\n  /// Return true if V is poison given that ValAssumedPoison is already poison.\n  /// For example, if ValAssumedPoison is `icmp X, 10` and V is `icmp X, 5`,\n  /// impliesPoison returns true.\n  bool impliesPoison(const Value *ValAssumedPoison, const Value *V);\n\n  /// Return true if this function can prove that V does not have undef bits\n  /// and is never poison. If V is an aggregate value or vector, check whether\n  /// all elements (except padding) are not undef or poison.\n  /// Note that this is different from canCreateUndefOrPoison because the\n  /// function assumes Op's operands are not poison/undef.\n  ///\n  /// If CtxI and DT are specified this method performs flow-sensitive analysis\n  /// and returns true if it is guaranteed to be never undef or poison\n  /// immediately before the CtxI.\n  bool isGuaranteedNotToBeUndefOrPoison(const Value *V,\n                                        AssumptionCache *AC = nullptr,\n                                        const Instruction *CtxI = nullptr,\n                                        const DominatorTree *DT = nullptr,\n                                        unsigned Depth = 0);\n  bool isGuaranteedNotToBePoison(const Value *V, AssumptionCache *AC = nullptr,\n                                 const Instruction *CtxI = nullptr,\n                                 const DominatorTree *DT = nullptr,\n                                 unsigned Depth = 0);\n\n  /// Specific patterns of select instructions we can match.\n  enum SelectPatternFlavor {\n    SPF_UNKNOWN = 0,\n    SPF_SMIN,                   /// Signed minimum\n    SPF_UMIN,                   /// Unsigned minimum\n    SPF_SMAX,                   /// Signed maximum\n    SPF_UMAX,                   /// Unsigned maximum\n    SPF_FMINNUM,                /// Floating point minnum\n    SPF_FMAXNUM,                /// Floating point maxnum\n    SPF_ABS,                    /// Absolute value\n    SPF_NABS                    /// Negated absolute value\n  };\n\n  /// Behavior when a floating point min/max is given one NaN and one\n  /// non-NaN as input.\n  enum SelectPatternNaNBehavior {\n    SPNB_NA = 0,                /// NaN behavior not applicable.\n    SPNB_RETURNS_NAN,           /// Given one NaN input, returns the NaN.\n    SPNB_RETURNS_OTHER,         /// Given one NaN input, returns the non-NaN.\n    SPNB_RETURNS_ANY            /// Given one NaN input, can return either (or\n                                /// it has been determined that no operands can\n                                /// be NaN).\n  };\n\n  struct SelectPatternResult {\n    SelectPatternFlavor Flavor;\n    SelectPatternNaNBehavior NaNBehavior; /// Only applicable if Flavor is\n                                          /// SPF_FMINNUM or SPF_FMAXNUM.\n    bool Ordered;               /// When implementing this min/max pattern as\n                                /// fcmp; select, does the fcmp have to be\n                                /// ordered?\n\n    /// Return true if \\p SPF is a min or a max pattern.\n    static bool isMinOrMax(SelectPatternFlavor SPF) {\n      return SPF != SPF_UNKNOWN && SPF != SPF_ABS && SPF != SPF_NABS;\n    }\n  };\n\n  /// Pattern match integer [SU]MIN, [SU]MAX and ABS idioms, returning the kind\n  /// and providing the out parameter results if we successfully match.\n  ///\n  /// For ABS/NABS, LHS will be set to the input to the abs idiom. RHS will be\n  /// the negation instruction from the idiom.\n  ///\n  /// If CastOp is not nullptr, also match MIN/MAX idioms where the type does\n  /// not match that of the original select. If this is the case, the cast\n  /// operation (one of Trunc,SExt,Zext) that must be done to transform the\n  /// type of LHS and RHS into the type of V is returned in CastOp.\n  ///\n  /// For example:\n  ///   %1 = icmp slt i32 %a, i32 4\n  ///   %2 = sext i32 %a to i64\n  ///   %3 = select i1 %1, i64 %2, i64 4\n  ///\n  /// -> LHS = %a, RHS = i32 4, *CastOp = Instruction::SExt\n  ///\n  SelectPatternResult matchSelectPattern(Value *V, Value *&LHS, Value *&RHS,\n                                         Instruction::CastOps *CastOp = nullptr,\n                                         unsigned Depth = 0);\n\n  inline SelectPatternResult\n  matchSelectPattern(const Value *V, const Value *&LHS, const Value *&RHS) {\n    Value *L = const_cast<Value *>(LHS);\n    Value *R = const_cast<Value *>(RHS);\n    auto Result = matchSelectPattern(const_cast<Value *>(V), L, R);\n    LHS = L;\n    RHS = R;\n    return Result;\n  }\n\n  /// Determine the pattern that a select with the given compare as its\n  /// predicate and given values as its true/false operands would match.\n  SelectPatternResult matchDecomposedSelectPattern(\n      CmpInst *CmpI, Value *TrueVal, Value *FalseVal, Value *&LHS, Value *&RHS,\n      Instruction::CastOps *CastOp = nullptr, unsigned Depth = 0);\n\n  /// Return the canonical comparison predicate for the specified\n  /// minimum/maximum flavor.\n  CmpInst::Predicate getMinMaxPred(SelectPatternFlavor SPF,\n                                   bool Ordered = false);\n\n  /// Return the inverse minimum/maximum flavor of the specified flavor.\n  /// For example, signed minimum is the inverse of signed maximum.\n  SelectPatternFlavor getInverseMinMaxFlavor(SelectPatternFlavor SPF);\n\n  /// Return the canonical inverse comparison predicate for the specified\n  /// minimum/maximum flavor.\n  CmpInst::Predicate getInverseMinMaxPred(SelectPatternFlavor SPF);\n\n  /// Check if the values in \\p VL are select instructions that can be converted\n  /// to a min or max (vector) intrinsic. Returns the intrinsic ID, if such a\n  /// conversion is possible, together with a bool indicating whether all select\n  /// conditions are only used by the selects. Otherwise return\n  /// Intrinsic::not_intrinsic.\n  std::pair<Intrinsic::ID, bool>\n  canConvertToMinOrMaxIntrinsic(ArrayRef<Value *> VL);\n\n  /// Return true if RHS is known to be implied true by LHS.  Return false if\n  /// RHS is known to be implied false by LHS.  Otherwise, return None if no\n  /// implication can be made.\n  /// A & B must be i1 (boolean) values or a vector of such values. Note that\n  /// the truth table for implication is the same as <=u on i1 values (but not\n  /// <=s!).  The truth table for both is:\n  ///    | T | F (B)\n  ///  T | T | F\n  ///  F | T | T\n  /// (A)\n  Optional<bool> isImpliedCondition(const Value *LHS, const Value *RHS,\n                                    const DataLayout &DL, bool LHSIsTrue = true,\n                                    unsigned Depth = 0);\n  Optional<bool> isImpliedCondition(const Value *LHS,\n                                    CmpInst::Predicate RHSPred,\n                                    const Value *RHSOp0, const Value *RHSOp1,\n                                    const DataLayout &DL, bool LHSIsTrue = true,\n                                    unsigned Depth = 0);\n\n  /// Return the boolean condition value in the context of the given instruction\n  /// if it is known based on dominating conditions.\n  Optional<bool> isImpliedByDomCondition(const Value *Cond,\n                                         const Instruction *ContextI,\n                                         const DataLayout &DL);\n  Optional<bool> isImpliedByDomCondition(CmpInst::Predicate Pred,\n                                         const Value *LHS, const Value *RHS,\n                                         const Instruction *ContextI,\n                                         const DataLayout &DL);\n\n  /// If Ptr1 is provably equal to Ptr2 plus a constant offset, return that\n  /// offset. For example, Ptr1 might be &A[42], and Ptr2 might be &A[40]. In\n  /// this case offset would be -8.\n  Optional<int64_t> isPointerOffset(const Value *Ptr1, const Value *Ptr2,\n                                    const DataLayout &DL);\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_VALUETRACKING_H\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 2, "line": 392}, "message": "the definition seen here"}, {"location": {"col": 12, "file": 1, "line": 200}, "message": "differing parameters are named here: ('Op'), in definition: ('V')"}, {"location": {"col": 12, "file": 1, "line": 200}, "message": "function 'llvm::ComputeNumSignBits' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h", "reportHash": "4a4c0a55f61c43111d8f339af2637b10", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 2, "line": 5098}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 591}, "message": "differing parameters are named here: ('Ops'), in definition: ('Operands')"}, {"location": {"col": 8, "file": 1, "line": 591}, "message": "function 'llvm::getGuaranteedNonPoisonOps' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h", "reportHash": "010d7419d90f5be1f0b475696bd4cb86", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
