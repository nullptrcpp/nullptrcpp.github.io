<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Headers.h", "content": "//===--- Headers.h - Include headers -----------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEADERS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEADERS_H\n\n#include \"Protocol.h\"\n#include \"SourceCode.h\"\n#include \"index/Symbol.h\"\n#include \"support/Path.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Format/Format.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"clang/Tooling/Inclusions/HeaderIncludes.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\n/// Returns true if \\p Include is literal include like \"path\" or <path>.\nbool isLiteralInclude(llvm::StringRef Include);\n\n/// Represents a header file to be #include'd.\nstruct HeaderFile {\n  std::string File;\n  /// If this is true, `File` is a literal string quoted with <> or \"\" that\n  /// can be #included directly; otherwise, `File` is an absolute file path.\n  bool Verbatim;\n\n  bool valid() const;\n};\n\n/// Creates a `HeaderFile` from \\p Header which can be either a URI or a literal\n/// include.\nllvm::Expected<HeaderFile> toHeaderFile(llvm::StringRef Header,\n                                        llvm::StringRef HintPath);\n\n// Returns include headers for \\p Sym sorted by popularity. If two headers are\n// equally popular, prefer the shorter one.\nllvm::SmallVector<llvm::StringRef, 1> getRankedIncludes(const Symbol &Sym);\n\n// An #include directive that we found in the main file.\nstruct Inclusion {\n  tok::PPKeywordKind Directive; // Directive used for inclusion, e.g. import\n  std::string Written;          // Inclusion name as written e.g. <vector>.\n  Path Resolved; // Resolved path of included file. Empty if not resolved.\n  unsigned HashOffset = 0; // Byte offset from start of file to #.\n  int HashLine = 0;        // Line number containing the directive, 0-indexed.\n  SrcMgr::CharacteristicKind FileKind = SrcMgr::C_User;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Inclusion &);\nbool operator==(const Inclusion &LHS, const Inclusion &RHS);\n\n// Contains information about one file in the build grpah and its direct\n// dependencies. Doesn't own the strings it references (IncludeGraph is\n// self-contained).\nstruct IncludeGraphNode {\n  enum class SourceFlag : uint8_t {\n    None = 0,\n    // Whether current file is a main file rather than a header.\n    IsTU = 1 << 0,\n    // Whether current file had any uncompilable errors during indexing.\n    HadErrors = 1 << 1,\n  };\n\n  SourceFlag Flags = SourceFlag::None;\n  llvm::StringRef URI;\n  FileDigest Digest{{0}};\n  std::vector<llvm::StringRef> DirectIncludes;\n};\n// FileURI and FileInclusions are references to keys of the map containing\n// them.\n// Important: The graph generated by those callbacks might contain cycles, self\n// edges and multi edges.\nusing IncludeGraph = llvm::StringMap<IncludeGraphNode>;\n\ninline IncludeGraphNode::SourceFlag operator|(IncludeGraphNode::SourceFlag A,\n                                              IncludeGraphNode::SourceFlag B) {\n  return static_cast<IncludeGraphNode::SourceFlag>(static_cast<uint8_t>(A) |\n                                                   static_cast<uint8_t>(B));\n}\n\ninline bool operator&(IncludeGraphNode::SourceFlag A,\n                      IncludeGraphNode::SourceFlag B) {\n  return static_cast<uint8_t>(A) & static_cast<uint8_t>(B);\n}\n\ninline IncludeGraphNode::SourceFlag &\noperator|=(IncludeGraphNode::SourceFlag &A, IncludeGraphNode::SourceFlag B) {\n  return A = A | B;\n}\n\n// Information captured about the inclusion graph in a translation unit.\n// This includes detailed information about the direct #includes, and summary\n// information about all transitive includes.\n//\n// It should be built incrementally with collectIncludeStructureCallback().\n// When we build the preamble, we capture and store its include structure along\n// with the preamble data. When we use the preamble, we can copy its\n// IncludeStructure and use another collectIncludeStructureCallback() to fill\n// in any non-preamble inclusions.\nclass IncludeStructure {\npublic:\n  std::vector<Inclusion> MainFileIncludes;\n\n  // Return all transitively reachable files.\n  llvm::ArrayRef<std::string> allHeaders() const { return RealPathNames; }\n\n  // Return all transitively reachable files, and their minimum include depth.\n  // All transitive includes (absolute paths), with their minimum include depth.\n  // Root --> 0, #included file --> 1, etc.\n  // Root is clang's name for a file, which may not be absolute.\n  // Usually it should be SM.getFileEntryForID(SM.getMainFileID())->getName().\n  llvm::StringMap<unsigned> includeDepth(llvm::StringRef Root) const;\n\n  // This updates IncludeDepth(), but not MainFileIncludes.\n  void recordInclude(llvm::StringRef IncludingName,\n                     llvm::StringRef IncludedName,\n                     llvm::StringRef IncludedRealName);\n\nprivate:\n  // Identifying files in a way that persists from preamble build to subsequent\n  // builds is surprisingly hard. FileID is unavailable in InclusionDirective(),\n  // and RealPathName and UniqueID are not preserved in the preamble.\n  // We use the FileEntry::Name, which is stable, interned into a \"file index\".\n  // The paths we want to expose are the RealPathName, so store those too.\n  std::vector<std::string> RealPathNames; // In file index order.\n  unsigned fileIndex(llvm::StringRef Name);\n  llvm::StringMap<unsigned> NameToIndex; // Values are file indexes.\n  // Maps a file's index to that of the files it includes.\n  llvm::DenseMap<unsigned, llvm::SmallVector<unsigned>> IncludeChildren;\n};\n\n/// Returns a PPCallback that visits all inclusions in the main file.\nstd::unique_ptr<PPCallbacks>\ncollectIncludeStructureCallback(const SourceManager &SM, IncludeStructure *Out);\n\n// Calculates insertion edit for including a new header in a file.\nclass IncludeInserter {\npublic:\n  // If \\p HeaderSearchInfo is nullptr (e.g. when compile command is\n  // infeasible), this will only try to insert verbatim headers, and\n  // include path of non-verbatim header will not be shortened.\n  IncludeInserter(StringRef FileName, StringRef Code,\n                  const format::FormatStyle &Style, StringRef BuildDir,\n                  HeaderSearch *HeaderSearchInfo)\n      : FileName(FileName), Code(Code), BuildDir(BuildDir),\n        HeaderSearchInfo(HeaderSearchInfo),\n        Inserter(FileName, Code, Style.IncludeStyle) {}\n\n  void addExisting(const Inclusion &Inc);\n\n  /// Checks whether to add an #include of the header into \\p File.\n  /// An #include will not be added if:\n  ///   - Either \\p DeclaringHeader or \\p InsertedHeader is already (directly)\n  ///   in \\p Inclusions (including those included via different paths).\n  ///   - \\p DeclaringHeader or \\p InsertedHeader is the same as \\p File.\n  ///\n  /// \\param DeclaringHeader is path of the original header corresponding to \\p\n  /// InsertedHeader e.g. the header that declares a symbol.\n  /// \\param InsertedHeader The preferred header to be inserted. This could be\n  /// the same as DeclaringHeader but must be provided.\n  bool shouldInsertInclude(PathRef DeclaringHeader,\n                           const HeaderFile &InsertedHeader) const;\n\n  /// Determines the preferred way to #include a file, taking into account the\n  /// search path. Usually this will prefer a shorter representation like\n  /// 'Foo/Bar.h' over a longer one like 'Baz/include/Foo/Bar.h'.\n  ///\n  /// \\param InsertedHeader The preferred header to be inserted.\n  ///\n  /// \\param IncludingFile is the absolute path of the file that InsertedHeader\n  /// will be inserted.\n  ///\n  /// \\return A quoted \"path\" or <path> to be included, or None if it couldn't\n  /// be shortened.\n  llvm::Optional<std::string>\n  calculateIncludePath(const HeaderFile &InsertedHeader,\n                       llvm::StringRef IncludingFile) const;\n\n  /// Calculates an edit that inserts \\p VerbatimHeader into code. If the header\n  /// is already included, this returns None.\n  llvm::Optional<TextEdit> insert(llvm::StringRef VerbatimHeader) const;\n\nprivate:\n  StringRef FileName;\n  StringRef Code;\n  StringRef BuildDir;\n  HeaderSearch *HeaderSearchInfo = nullptr;\n  llvm::StringSet<> IncludedHeaders; // Both written and resolved.\n  tooling::HeaderIncludes Inserter;  // Computers insertion replacement.\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEADERS_H\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "content": "//===--- Protocol.h - Language Server Protocol Implementation ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains structs based on the LSP specification at\n// https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md\n//\n// This is not meant to be a complete implementation, new interfaces are added\n// when they're needed.\n//\n// Each struct has a toJSON and fromJSON function, that converts between\n// the struct and a JSON representation. (See JSON.h)\n//\n// Some structs also have operator<< serialization. This is for debugging and\n// tests, and is not generally machine-readable.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n\n#include \"URI.h\"\n#include \"index/SymbolID.h\"\n#include \"support/MemoryTree.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/JSON.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nenum class ErrorCode {\n  // Defined by JSON RPC.\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603,\n\n  ServerNotInitialized = -32002,\n  UnknownErrorCode = -32001,\n\n  // Defined by the protocol.\n  RequestCancelled = -32800,\n  ContentModified = -32801,\n};\n// Models an LSP error as an llvm::Error.\nclass LSPError : public llvm::ErrorInfo<LSPError> {\npublic:\n  std::string Message;\n  ErrorCode Code;\n  static char ID;\n\n  LSPError(std::string Message, ErrorCode Code)\n      : Message(std::move(Message)), Code(Code) {}\n\n  void log(llvm::raw_ostream &OS) const override {\n    OS << int(Code) << \": \" << Message;\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n// URI in \"file\" scheme for a file.\nstruct URIForFile {\n  URIForFile() = default;\n\n  /// Canonicalizes \\p AbsPath via URI.\n  ///\n  /// File paths in URIForFile can come from index or local AST. Path from\n  /// index goes through URI transformation, and the final path is resolved by\n  /// URI scheme and could potentially be different from the original path.\n  /// Hence, we do the same transformation for all paths.\n  ///\n  /// Files can be referred to by several paths (e.g. in the presence of links).\n  /// Which one we prefer may depend on where we're coming from. \\p TUPath is a\n  /// hint, and should usually be the main entrypoint file we're processing.\n  static URIForFile canonicalize(llvm::StringRef AbsPath,\n                                 llvm::StringRef TUPath);\n\n  static llvm::Expected<URIForFile> fromURI(const URI &U,\n                                            llvm::StringRef HintPath);\n\n  /// Retrieves absolute path to the file.\n  llvm::StringRef file() const { return File; }\n\n  explicit operator bool() const { return !File.empty(); }\n  std::string uri() const { return URI::createFile(File).toString(); }\n\n  friend bool operator==(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File == RHS.File;\n  }\n\n  friend bool operator!=(const URIForFile &LHS, const URIForFile &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File < RHS.File;\n  }\n\nprivate:\n  explicit URIForFile(std::string &&File) : File(std::move(File)) {}\n\n  std::string File;\n};\n\n/// Serialize/deserialize \\p URIForFile to/from a string URI.\nllvm::json::Value toJSON(const URIForFile &U);\nbool fromJSON(const llvm::json::Value &, URIForFile &, llvm::json::Path);\n\nstruct TextDocumentIdentifier {\n  /// The text document's URI.\n  URIForFile uri;\n};\nllvm::json::Value toJSON(const TextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, TextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct VersionedTextDocumentIdentifier : public TextDocumentIdentifier {\n  /// The version number of this document. If a versioned text document\n  /// identifier is sent from the server to the client and the file is not open\n  /// in the editor (the server has not received an open notification before)\n  /// the server can send `null` to indicate that the version is known and the\n  /// content on disk is the master (as speced with document content ownership).\n  ///\n  /// The version number of a document will increase after each change,\n  /// including undo/redo. The number doesn't need to be consecutive.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<std::int64_t> version;\n};\nllvm::json::Value toJSON(const VersionedTextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, VersionedTextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct Position {\n  /// Line position in a document (zero-based).\n  int line = 0;\n\n  /// Character offset on a line in a document (zero-based).\n  /// WARNING: this is in UTF-16 codepoints, not bytes or characters!\n  /// Use the functions in SourceCode.h to construct/interpret Positions.\n  int character = 0;\n\n  friend bool operator==(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) ==\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator!=(const Position &LHS, const Position &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator<=(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <=\n           std::tie(RHS.line, RHS.character);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Position &, llvm::json::Path);\nllvm::json::Value toJSON(const Position &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Position &);\n\nstruct Range {\n  /// The range's start position.\n  Position start;\n\n  /// The range's end position.\n  Position end;\n\n  friend bool operator==(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) == std::tie(RHS.start, RHS.end);\n  }\n  friend bool operator!=(const Range &LHS, const Range &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) < std::tie(RHS.start, RHS.end);\n  }\n\n  bool contains(Position Pos) const { return start <= Pos && Pos < end; }\n  bool contains(Range Rng) const {\n    return start <= Rng.start && Rng.end <= end;\n  }\n};\nbool fromJSON(const llvm::json::Value &, Range &, llvm::json::Path);\nllvm::json::Value toJSON(const Range &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Range &);\n\nstruct Location {\n  /// The text document's URI.\n  URIForFile uri;\n  Range range;\n\n  friend bool operator==(const Location &LHS, const Location &RHS) {\n    return LHS.uri == RHS.uri && LHS.range == RHS.range;\n  }\n\n  friend bool operator!=(const Location &LHS, const Location &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const Location &LHS, const Location &RHS) {\n    return std::tie(LHS.uri, LHS.range) < std::tie(RHS.uri, RHS.range);\n  }\n};\nllvm::json::Value toJSON(const Location &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Location &);\n\nstruct TextEdit {\n  /// The range of the text document to be manipulated. To insert\n  /// text into a document create a range where start === end.\n  Range range;\n\n  /// The string to be inserted. For delete operations use an\n  /// empty string.\n  std::string newText;\n};\ninline bool operator==(const TextEdit &L, const TextEdit &R) {\n  return std::tie(L.newText, L.range) == std::tie(R.newText, R.range);\n}\nbool fromJSON(const llvm::json::Value &, TextEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const TextEdit &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TextEdit &);\n\nstruct TextDocumentItem {\n  /// The text document's URI.\n  URIForFile uri;\n\n  /// The text document's language identifier.\n  std::string languageId;\n\n  /// The version number of this document (it will strictly increase after each\n  /// change, including undo/redo.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<int64_t> version;\n\n  /// The content of the opened text document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentItem &, llvm::json::Path);\n\nenum class TraceLevel {\n  Off = 0,\n  Messages = 1,\n  Verbose = 2,\n};\nbool fromJSON(const llvm::json::Value &E, TraceLevel &Out, llvm::json::Path);\n\nstruct NoParams {};\ninline llvm::json::Value toJSON(const NoParams &) { return nullptr; }\ninline bool fromJSON(const llvm::json::Value &, NoParams &, llvm::json::Path) {\n  return true;\n}\nusing InitializedParams = NoParams;\n\n/// Defines how the host (editor) should sync document changes to the language\n/// server.\nenum class TextDocumentSyncKind {\n  /// Documents should not be synced at all.\n  None = 0,\n\n  /// Documents are synced by always sending the full content of the document.\n  Full = 1,\n\n  /// Documents are synced by sending the full content on open.  After that\n  /// only incremental updates to the document are send.\n  Incremental = 2,\n};\n\n/// The kind of a completion entry.\nenum class CompletionItemKind {\n  Missing = 0,\n  Text = 1,\n  Method = 2,\n  Function = 3,\n  Constructor = 4,\n  Field = 5,\n  Variable = 6,\n  Class = 7,\n  Interface = 8,\n  Module = 9,\n  Property = 10,\n  Unit = 11,\n  Value = 12,\n  Enum = 13,\n  Keyword = 14,\n  Snippet = 15,\n  Color = 16,\n  File = 17,\n  Reference = 18,\n  Folder = 19,\n  EnumMember = 20,\n  Constant = 21,\n  Struct = 22,\n  Event = 23,\n  Operator = 24,\n  TypeParameter = 25,\n};\nbool fromJSON(const llvm::json::Value &, CompletionItemKind &,\n              llvm::json::Path);\nconstexpr auto CompletionItemKindMin =\n    static_cast<size_t>(CompletionItemKind::Text);\nconstexpr auto CompletionItemKindMax =\n    static_cast<size_t>(CompletionItemKind::TypeParameter);\nusing CompletionItemKindBitset = std::bitset<CompletionItemKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, CompletionItemKindBitset &,\n              llvm::json::Path);\nCompletionItemKind\nadjustKindToCapability(CompletionItemKind Kind,\n                       CompletionItemKindBitset &SupportedCompletionItemKinds);\n\n/// A symbol kind.\nenum class SymbolKind {\n  File = 1,\n  Module = 2,\n  Namespace = 3,\n  Package = 4,\n  Class = 5,\n  Method = 6,\n  Property = 7,\n  Field = 8,\n  Constructor = 9,\n  Enum = 10,\n  Interface = 11,\n  Function = 12,\n  Variable = 13,\n  Constant = 14,\n  String = 15,\n  Number = 16,\n  Boolean = 17,\n  Array = 18,\n  Object = 19,\n  Key = 20,\n  Null = 21,\n  EnumMember = 22,\n  Struct = 23,\n  Event = 24,\n  Operator = 25,\n  TypeParameter = 26\n};\nbool fromJSON(const llvm::json::Value &, SymbolKind &, llvm::json::Path);\nconstexpr auto SymbolKindMin = static_cast<size_t>(SymbolKind::File);\nconstexpr auto SymbolKindMax = static_cast<size_t>(SymbolKind::TypeParameter);\nusing SymbolKindBitset = std::bitset<SymbolKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, SymbolKindBitset &, llvm::json::Path);\nSymbolKind adjustKindToCapability(SymbolKind Kind,\n                                  SymbolKindBitset &supportedSymbolKinds);\n\n// Convert a index::SymbolKind to clangd::SymbolKind (LSP)\n// Note, some are not perfect matches and should be improved when this LSP\n// issue is addressed:\n// https://github.com/Microsoft/language-server-protocol/issues/344\nSymbolKind indexSymbolKindToSymbolKind(index::SymbolKind Kind);\n\n// Determines the encoding used to measure offsets and lengths of source in LSP.\nenum class OffsetEncoding {\n  // Any string is legal on the wire. Unrecognized encodings parse as this.\n  UnsupportedEncoding,\n  // Length counts code units of UTF-16 encoded text. (Standard LSP behavior).\n  UTF16,\n  // Length counts bytes of UTF-8 encoded text. (Clangd extension).\n  UTF8,\n  // Length counts codepoints in unicode text. (Clangd extension).\n  UTF32,\n};\nllvm::json::Value toJSON(const OffsetEncoding &);\nbool fromJSON(const llvm::json::Value &, OffsetEncoding &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, OffsetEncoding);\n\n// Describes the content type that a client supports in various result literals\n// like `Hover`, `ParameterInfo` or `CompletionItem`.\nenum class MarkupKind {\n  PlainText,\n  Markdown,\n};\nbool fromJSON(const llvm::json::Value &, MarkupKind &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, MarkupKind);\n\n// This struct doesn't mirror LSP!\n// The protocol defines deeply nested structures for client capabilities.\n// Instead of mapping them all, this just parses out the bits we care about.\nstruct ClientCapabilities {\n  /// The supported set of SymbolKinds for workspace/symbol.\n  /// workspace.symbol.symbolKind.valueSet\n  llvm::Optional<SymbolKindBitset> WorkspaceSymbolKinds;\n\n  /// Whether the client accepts diagnostics with codeActions attached inline.\n  /// textDocument.publishDiagnostics.codeActionsInline.\n  bool DiagnosticFixes = false;\n\n  /// Whether the client accepts diagnostics with related locations.\n  /// textDocument.publishDiagnostics.relatedInformation.\n  bool DiagnosticRelatedInformation = false;\n\n  /// Whether the client accepts diagnostics with category attached to it\n  /// using the \"category\" extension.\n  /// textDocument.publishDiagnostics.categorySupport\n  bool DiagnosticCategory = false;\n\n  /// Client supports snippets as insert text.\n  /// textDocument.completion.completionItem.snippetSupport\n  bool CompletionSnippets = false;\n\n  /// Client supports completions with additionalTextEdit near the cursor.\n  /// This is a clangd extension. (LSP says this is for unrelated text only).\n  /// textDocument.completion.editsNearCursor\n  bool CompletionFixes = false;\n\n  /// Client supports hierarchical document symbols.\n  /// textDocument.documentSymbol.hierarchicalDocumentSymbolSupport\n  bool HierarchicalDocumentSymbol = false;\n\n  /// Client supports signature help.\n  /// textDocument.signatureHelp\n  bool HasSignatureHelp = false;\n\n  /// Client supports processing label offsets instead of a simple label string.\n  /// textDocument.signatureHelp.signatureInformation.parameterInformation.labelOffsetSupport\n  bool OffsetsInSignatureHelp = false;\n\n  /// The supported set of CompletionItemKinds for textDocument/completion.\n  /// textDocument.completion.completionItemKind.valueSet\n  llvm::Optional<CompletionItemKindBitset> CompletionItemKinds;\n\n  /// The documentation format that should be used for textDocument/completion.\n  /// textDocument.completion.completionItem.documentationFormat\n  MarkupKind CompletionDocumentationFormat = MarkupKind::PlainText;\n\n  /// Client supports CodeAction return value for textDocument/codeAction.\n  /// textDocument.codeAction.codeActionLiteralSupport.\n  bool CodeActionStructure = false;\n\n  /// Client advertises support for the semanticTokens feature.\n  /// We support the textDocument/semanticTokens request in any case.\n  /// textDocument.semanticTokens\n  bool SemanticTokens = false;\n  /// Client supports Theia semantic highlighting extension.\n  /// https://github.com/microsoft/vscode-languageserver-node/pull/367\n  /// clangd no longer supports this, we detect it just to log a warning.\n  /// textDocument.semanticHighlightingCapabilities.semanticHighlighting\n  bool TheiaSemanticHighlighting = false;\n\n  /// Supported encodings for LSP character offsets. (clangd extension).\n  llvm::Optional<std::vector<OffsetEncoding>> offsetEncoding;\n\n  /// The content format that should be used for Hover requests.\n  /// textDocument.hover.contentEncoding\n  MarkupKind HoverContentFormat = MarkupKind::PlainText;\n\n  /// The client supports testing for validity of rename operations\n  /// before execution.\n  bool RenamePrepareSupport = false;\n\n  /// The client supports progress notifications.\n  /// window.workDoneProgress\n  bool WorkDoneProgress = false;\n\n  /// The client supports implicit $/progress work-done progress streams,\n  /// without a preceding window/workDoneProgress/create.\n  /// This is a clangd extension.\n  /// window.implicitWorkDoneProgressCreate\n  bool ImplicitProgressCreation = false;\n\n  /// Whether the client claims to cancel stale requests.\n  /// general.staleRequestSupport.cancel\n  bool CancelsStaleRequests = false;\n\n  /// Whether the client implementation supports a refresh request sent from the\n  /// server to the client.\n  bool SemanticTokenRefreshSupport = false;\n};\nbool fromJSON(const llvm::json::Value &, ClientCapabilities &,\n              llvm::json::Path);\n\n/// Clangd extension that's used in the 'compilationDatabaseChanges' in\n/// workspace/didChangeConfiguration to record updates to the in-memory\n/// compilation database.\nstruct ClangdCompileCommand {\n  std::string workingDirectory;\n  std::vector<std::string> compilationCommand;\n};\nbool fromJSON(const llvm::json::Value &, ClangdCompileCommand &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at any time, via the\n/// `workspace/didChangeConfiguration` notification.\n/// LSP defines this type as `any`.\nstruct ConfigurationSettings {\n  // Changes to the in-memory compilation database.\n  // The key of the map is a file name.\n  std::map<std::string, ClangdCompileCommand> compilationDatabaseChanges;\n};\nbool fromJSON(const llvm::json::Value &, ConfigurationSettings &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at `initialize` time.\n/// LSP defines this type as `any`.\nstruct InitializationOptions {\n  // What we can change throught the didChangeConfiguration request, we can\n  // also set through the initialize request (initializationOptions field).\n  ConfigurationSettings ConfigSettings;\n\n  llvm::Optional<std::string> compilationDatabasePath;\n  // Additional flags to be included in the \"fallback command\" used when\n  // the compilation database doesn't describe an opened file.\n  // The command used will be approximately `clang $FILE $fallbackFlags`.\n  std::vector<std::string> fallbackFlags;\n\n  /// Clients supports show file status for textDocument/clangd.fileStatus.\n  bool FileStatus = false;\n};\nbool fromJSON(const llvm::json::Value &, InitializationOptions &,\n              llvm::json::Path);\n\nstruct InitializeParams {\n  /// The process Id of the parent process that started\n  /// the server. Is null if the process has not been started by another\n  /// process. If the parent process is not alive then the server should exit\n  /// (see exit notification) its process.\n  llvm::Optional<int> processId;\n\n  /// The rootPath of the workspace. Is null\n  /// if no folder is open.\n  ///\n  /// @deprecated in favour of rootUri.\n  llvm::Optional<std::string> rootPath;\n\n  /// The rootUri of the workspace. Is null if no\n  /// folder is open. If both `rootPath` and `rootUri` are set\n  /// `rootUri` wins.\n  llvm::Optional<URIForFile> rootUri;\n\n  // User provided initialization options.\n  // initializationOptions?: any;\n\n  /// The capabilities provided by the client (editor or tool)\n  ClientCapabilities capabilities;\n  /// The same data as capabilities, but not parsed (to expose to modules).\n  llvm::json::Object rawCapabilities;\n\n  /// The initial trace setting. If omitted trace is disabled ('off').\n  llvm::Optional<TraceLevel> trace;\n\n  /// User-provided initialization options.\n  InitializationOptions initializationOptions;\n};\nbool fromJSON(const llvm::json::Value &, InitializeParams &, llvm::json::Path);\n\nstruct WorkDoneProgressCreateParams {\n  /// The token to be used to report progress.\n  llvm::json::Value token = nullptr;\n};\nllvm::json::Value toJSON(const WorkDoneProgressCreateParams &P);\n\ntemplate <typename T> struct ProgressParams {\n  /// The progress token provided by the client or server.\n  llvm::json::Value token = nullptr;\n\n  /// The progress data.\n  T value;\n};\ntemplate <typename T> llvm::json::Value toJSON(const ProgressParams<T> &P) {\n  return llvm::json::Object{{\"token\", P.token}, {\"value\", P.value}};\n}\n/// To start progress reporting a $/progress notification with the following\n/// payload must be sent.\nstruct WorkDoneProgressBegin {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls if a cancel button should show to allow the user to cancel the\n  /// long-running operation. Clients that don't support cancellation are\n  /// allowed to ignore the setting.\n  bool cancellable = false;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  ///\n  /// Clangd implementation note: we only send nonzero percentages in\n  /// the WorkProgressReport. 'true' here means percentages will be used.\n  bool percentage = false;\n};\nllvm::json::Value toJSON(const WorkDoneProgressBegin &);\n\n/// Reporting progress is done using the following payload.\nstruct WorkDoneProgressReport {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls enablement state of a cancel button. This property is only valid\n  /// if a cancel button got requested in the `WorkDoneProgressStart` payload.\n  ///\n  /// Clients that don't support cancellation or don't support control\n  /// the button's enablement state are allowed to ignore the setting.\n  llvm::Optional<bool> cancellable;\n\n  /// Optional, more detailed associated progress message. Contains\n  /// complementary information to the `title`.\n  ///\n  /// Examples: \"3/25 files\", \"project/src/module2\", \"node_modules/some_dep\".\n  /// If unset, the previous progress message (if any) is still valid.\n  llvm::Optional<std::string> message;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  llvm::Optional<double> percentage;\n};\nllvm::json::Value toJSON(const WorkDoneProgressReport &);\n//\n/// Signals the end of progress reporting.\nstruct WorkDoneProgressEnd {\n  /// Optional, a final message indicating to for example indicate the outcome\n  /// of the operation.\n  llvm::Optional<std::string> message;\n};\nllvm::json::Value toJSON(const WorkDoneProgressEnd &);\n\nenum class MessageType {\n  /// An error message.\n  Error = 1,\n  /// A warning message.\n  Warning = 2,\n  /// An information message.\n  Info = 3,\n  /// A log message.\n  Log = 4,\n};\nllvm::json::Value toJSON(const MessageType &);\n\n/// The show message notification is sent from a server to a client to ask the\n/// client to display a particular message in the user interface.\nstruct ShowMessageParams {\n  /// The message type.\n  MessageType type = MessageType::Info;\n  /// The actual message.\n  std::string message;\n};\nllvm::json::Value toJSON(const ShowMessageParams &);\n\nstruct DidOpenTextDocumentParams {\n  /// The document that was opened.\n  TextDocumentItem textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidOpenTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidCloseTextDocumentParams {\n  /// The document that was closed.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidCloseTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidSaveTextDocumentParams {\n  /// The document that was saved.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidSaveTextDocumentParams &,\n              llvm::json::Path);\n\nstruct TextDocumentContentChangeEvent {\n  /// The range of the document that changed.\n  llvm::Optional<Range> range;\n\n  /// The length of the range that got replaced.\n  llvm::Optional<int> rangeLength;\n\n  /// The new text of the range/document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentContentChangeEvent &,\n              llvm::json::Path);\n\nstruct DidChangeTextDocumentParams {\n  /// The document that did change. The version number points\n  /// to the version after all provided content changes have\n  /// been applied.\n  VersionedTextDocumentIdentifier textDocument;\n\n  /// The actual content changes.\n  std::vector<TextDocumentContentChangeEvent> contentChanges;\n\n  /// Forces diagnostics to be generated, or to not be generated, for this\n  /// version of the file. If not set, diagnostics are eventually consistent:\n  /// either they will be provided for this version or some subsequent one.\n  /// This is a clangd extension.\n  llvm::Optional<bool> wantDiagnostics;\n\n  /// Force a complete rebuild of the file, ignoring all cached state. Slow!\n  /// This is useful to defeat clangd's assumption that missing headers will\n  /// stay missing.\n  /// This is a clangd extension.\n  bool forceRebuild = false;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeTextDocumentParams &,\n              llvm::json::Path);\n\nenum class FileChangeType {\n  /// The file got created.\n  Created = 1,\n  /// The file got changed.\n  Changed = 2,\n  /// The file got deleted.\n  Deleted = 3\n};\nbool fromJSON(const llvm::json::Value &E, FileChangeType &Out,\n              llvm::json::Path);\n\nstruct FileEvent {\n  /// The file's URI.\n  URIForFile uri;\n  /// The change type.\n  FileChangeType type = FileChangeType::Created;\n};\nbool fromJSON(const llvm::json::Value &, FileEvent &, llvm::json::Path);\n\nstruct DidChangeWatchedFilesParams {\n  /// The actual file events.\n  std::vector<FileEvent> changes;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeWatchedFilesParams &,\n              llvm::json::Path);\n\nstruct DidChangeConfigurationParams {\n  ConfigurationSettings settings;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeConfigurationParams &,\n              llvm::json::Path);\n\n// Note: we do not parse FormattingOptions for *FormattingParams.\n// In general, we use a clang-format style detected from common mechanisms\n// (.clang-format files and the -fallback-style flag).\n// It would be possible to override these with FormatOptions, but:\n//  - the protocol makes FormatOptions mandatory, so many clients set them to\n//    useless values, and we can't tell when to respect them\n// - we also format in other places, where FormatOptions aren't available.\n\nstruct DocumentRangeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The range to format\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, DocumentRangeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentOnTypeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The character that has been typed.\n  std::string ch;\n};\nbool fromJSON(const llvm::json::Value &, DocumentOnTypeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentSymbolParams {\n  // The text document to find symbols in.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentSymbolParams &,\n              llvm::json::Path);\n\n/// Represents a related message and source code location for a diagnostic.\n/// This should be used to point to code locations that cause or related to a\n/// diagnostics, e.g when duplicating a symbol in a scope.\nstruct DiagnosticRelatedInformation {\n  /// The location of this related diagnostic information.\n  Location location;\n  /// The message of this related diagnostic information.\n  std::string message;\n};\nllvm::json::Value toJSON(const DiagnosticRelatedInformation &);\n\nstruct CodeAction;\nstruct Diagnostic {\n  /// The range at which the message applies.\n  Range range;\n\n  /// The diagnostic's severity. Can be omitted. If omitted it is up to the\n  /// client to interpret diagnostics as error, warning, info or hint.\n  int severity = 0;\n\n  /// The diagnostic's code. Can be omitted.\n  std::string code;\n\n  /// A human-readable string describing the source of this\n  /// diagnostic, e.g. 'typescript' or 'super lint'.\n  std::string source;\n\n  /// The diagnostic's message.\n  std::string message;\n\n  /// An array of related diagnostic information, e.g. when symbol-names within\n  /// a scope collide all definitions can be marked via this property.\n  llvm::Optional<std::vector<DiagnosticRelatedInformation>> relatedInformation;\n\n  /// The diagnostic's category. Can be omitted.\n  /// An LSP extension that's used to send the name of the category over to the\n  /// client. The category typically describes the compilation stage during\n  /// which the issue was produced, e.g. \"Semantic Issue\" or \"Parse Issue\".\n  llvm::Optional<std::string> category;\n\n  /// Clangd extension: code actions related to this diagnostic.\n  /// Only with capability textDocument.publishDiagnostics.codeActionsInline.\n  /// (These actions can also be obtained using textDocument/codeAction).\n  llvm::Optional<std::vector<CodeAction>> codeActions;\n};\nllvm::json::Value toJSON(const Diagnostic &);\n\n/// A LSP-specific comparator used to find diagnostic in a container like\n/// std:map.\n/// We only use the required fields of Diagnostic to do the comparison to avoid\n/// any regression issues from LSP clients (e.g. VScode), see\n/// https://git.io/vbr29\nstruct LSPDiagnosticCompare {\n  bool operator()(const Diagnostic &LHS, const Diagnostic &RHS) const {\n    return std::tie(LHS.range, LHS.message) < std::tie(RHS.range, RHS.message);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Diagnostic &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Diagnostic &);\n\nstruct PublishDiagnosticsParams {\n  /// The URI for which diagnostic information is reported.\n  URIForFile uri;\n  /// An array of diagnostic information items.\n  std::vector<Diagnostic> diagnostics;\n  /// The version number of the document the diagnostics are published for.\n  llvm::Optional<int64_t> version;\n};\nllvm::json::Value toJSON(const PublishDiagnosticsParams &);\n\nstruct CodeActionContext {\n  /// An array of diagnostics known on the client side overlapping the range\n  /// provided to the `textDocument/codeAction` request. They are provided so\n  /// that the server knows which errors are currently presented to the user for\n  /// the given range. There is no guarantee that these accurately reflect the\n  /// error state of the resource. The primary parameter to compute code actions\n  /// is the provided range.\n  std::vector<Diagnostic> diagnostics;\n\n  /// Requested kind of actions to return.\n  ///\n  /// Actions not of this kind are filtered out by the client before being\n  /// shown. So servers can omit computing them.\n  std::vector<std::string> only;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionContext &, llvm::json::Path);\n\nstruct CodeActionParams {\n  /// The document in which the command was invoked.\n  TextDocumentIdentifier textDocument;\n\n  /// The range for which the command was invoked.\n  Range range;\n\n  /// Context carrying additional information.\n  CodeActionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionParams &, llvm::json::Path);\n\nstruct WorkspaceEdit {\n  /// Holds changes to existing resources.\n  llvm::Optional<std::map<std::string, std::vector<TextEdit>>> changes;\n\n  /// Note: \"documentChanges\" is not currently used because currently there is\n  /// no support for versioned edits.\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const WorkspaceEdit &WE);\n\n/// Arguments for the 'applyTweak' command. The server sends these commands as a\n/// response to the textDocument/codeAction request. The client can later send a\n/// command back to the server if the user requests to execute a particular code\n/// tweak.\nstruct TweakArgs {\n  /// A file provided by the client on a textDocument/codeAction request.\n  URIForFile file;\n  /// A selection provided by the client on a textDocument/codeAction request.\n  Range selection;\n  /// ID of the tweak that should be executed. Corresponds to Tweak::id().\n  std::string tweakID;\n};\nbool fromJSON(const llvm::json::Value &, TweakArgs &, llvm::json::Path);\nllvm::json::Value toJSON(const TweakArgs &A);\n\nstruct ExecuteCommandParams {\n  /// The identifier of the actual command handler.\n  std::string command;\n\n  // This is `arguments?: []any` in LSP.\n  // All clangd's commands accept a single argument (or none => null).\n  llvm::json::Value argument = nullptr;\n};\nbool fromJSON(const llvm::json::Value &, ExecuteCommandParams &,\n              llvm::json::Path);\n\nstruct Command : public ExecuteCommandParams {\n  std::string title;\n};\nllvm::json::Value toJSON(const Command &C);\n\n/// A code action represents a change that can be performed in code, e.g. to fix\n/// a problem or to refactor code.\n///\n/// A CodeAction must set either `edit` and/or a `command`. If both are\n/// supplied, the `edit` is applied first, then the `command` is executed.\nstruct CodeAction {\n  /// A short, human-readable, title for this code action.\n  std::string title;\n\n  /// The kind of the code action.\n  /// Used to filter code actions.\n  llvm::Optional<std::string> kind;\n  const static llvm::StringLiteral QUICKFIX_KIND;\n  const static llvm::StringLiteral REFACTOR_KIND;\n  const static llvm::StringLiteral INFO_KIND;\n\n  /// The diagnostics that this code action resolves.\n  llvm::Optional<std::vector<Diagnostic>> diagnostics;\n\n  /// Marks this as a preferred action. Preferred actions are used by the\n  /// `auto fix` command and can be targeted by keybindings.\n  /// A quick fix should be marked preferred if it properly addresses the\n  /// underlying error. A refactoring should be marked preferred if it is the\n  /// most reasonable choice of actions to take.\n  bool isPreferred = false;\n\n  /// The workspace edit this code action performs.\n  llvm::Optional<WorkspaceEdit> edit;\n\n  /// A command this code action executes. If a code action provides an edit\n  /// and a command, first the edit is executed and then the command.\n  llvm::Optional<Command> command;\n};\nllvm::json::Value toJSON(const CodeAction &);\n\n/// Represents programming constructs like variables, classes, interfaces etc.\n/// that appear in a document. Document symbols can be hierarchical and they\n/// have two ranges: one that encloses its definition and one that points to its\n/// most interesting range, e.g. the range of an identifier.\nstruct DocumentSymbol {\n  /// The name of this symbol.\n  std::string name;\n\n  /// More detail for this symbol, e.g the signature of a function.\n  std::string detail;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// Indicates if this symbol is deprecated.\n  bool deprecated = false;\n\n  /// The range enclosing this symbol not including leading/trailing whitespace\n  /// but everything else like comments. This information is typically used to\n  /// determine if the clients cursor is inside the symbol to reveal in the\n  /// symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol is being\n  /// picked, e.g the name of a function. Must be contained by the `range`.\n  Range selectionRange;\n\n  /// Children of this symbol, e.g. properties of a class.\n  std::vector<DocumentSymbol> children;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &O, const DocumentSymbol &S);\nllvm::json::Value toJSON(const DocumentSymbol &S);\n\n/// Represents information about programming constructs like variables, classes,\n/// interfaces etc.\nstruct SymbolInformation {\n  /// The name of this symbol.\n  std::string name;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// The location of this symbol.\n  Location location;\n\n  /// The name of the symbol containing this symbol.\n  std::string containerName;\n\n  /// The score that clangd calculates to rank the returned symbols.\n  /// This excludes the fuzzy-matching score between `name` and the query.\n  /// (Specifically, the last ::-separated component).\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension, set only for workspace/symbol responses.\n  llvm::Optional<float> score;\n};\nllvm::json::Value toJSON(const SymbolInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolInformation &);\n\n/// Represents information about identifier.\n/// This is returned from textDocument/symbolInfo, which is a clangd extension.\nstruct SymbolDetails {\n  std::string name;\n\n  std::string containerName;\n\n  /// Unified Symbol Resolution identifier\n  /// This is an opaque string uniquely identifying a symbol.\n  /// Unlike SymbolID, it is variable-length and somewhat human-readable.\n  /// It is a common representation across several clang tools.\n  /// (See USRGeneration.h)\n  std::string USR;\n\n  SymbolID ID;\n};\nllvm::json::Value toJSON(const SymbolDetails &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolDetails &);\nbool operator==(const SymbolDetails &, const SymbolDetails &);\n\n/// The parameters of a Workspace Symbol Request.\nstruct WorkspaceSymbolParams {\n  /// A query string to filter symbols by.\n  /// Clients may send an empty string here to request all the symbols.\n  std::string query;\n\n  /// Max results to return, overriding global default. 0 means no limit.\n  /// Clangd extension.\n  llvm::Optional<int> limit;\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceSymbolParams &,\n              llvm::json::Path);\n\nstruct ApplyWorkspaceEditParams {\n  WorkspaceEdit edit;\n};\nllvm::json::Value toJSON(const ApplyWorkspaceEditParams &);\n\nstruct ApplyWorkspaceEditResponse {\n  bool applied = true;\n  llvm::Optional<std::string> failureReason;\n};\nbool fromJSON(const llvm::json::Value &, ApplyWorkspaceEditResponse &,\n              llvm::json::Path);\n\nstruct TextDocumentPositionParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position inside the text document.\n  Position position;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentPositionParams &,\n              llvm::json::Path);\n\nenum class CompletionTriggerKind {\n  /// Completion was triggered by typing an identifier (24x7 code\n  /// complete), manual invocation (e.g Ctrl+Space) or via API.\n  Invoked = 1,\n  /// Completion was triggered by a trigger character specified by\n  /// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n  TriggerCharacter = 2,\n  /// Completion was re-triggered as the current completion list is incomplete.\n  TriggerTriggerForIncompleteCompletions = 3\n};\n\nstruct CompletionContext {\n  /// How the completion was triggered.\n  CompletionTriggerKind triggerKind = CompletionTriggerKind::Invoked;\n  /// The trigger character (a single character) that has trigger code complete.\n  /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`\n  std::string triggerCharacter;\n};\nbool fromJSON(const llvm::json::Value &, CompletionContext &, llvm::json::Path);\n\nstruct CompletionParams : TextDocumentPositionParams {\n  CompletionContext context;\n\n  /// Max results to return, overriding global default. 0 means no limit.\n  /// Clangd extension.\n  llvm::Optional<int> limit;\n};\nbool fromJSON(const llvm::json::Value &, CompletionParams &, llvm::json::Path);\n\nstruct MarkupContent {\n  MarkupKind kind = MarkupKind::PlainText;\n  std::string value;\n};\nllvm::json::Value toJSON(const MarkupContent &MC);\n\nstruct Hover {\n  /// The hover's content\n  MarkupContent contents;\n\n  /// An optional range is a range inside a text document\n  /// that is used to visualize a hover, e.g. by changing the background color.\n  llvm::Optional<Range> range;\n};\nllvm::json::Value toJSON(const Hover &H);\n\n/// Defines whether the insert text in a completion item should be interpreted\n/// as plain text or a snippet.\nenum class InsertTextFormat {\n  Missing = 0,\n  /// The primary text to be inserted is treated as a plain string.\n  PlainText = 1,\n  /// The primary text to be inserted is treated as a snippet.\n  ///\n  /// A snippet can define tab stops and placeholders with `$1`, `$2`\n  /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to the end\n  /// of the snippet. Placeholders with equal identifiers are linked, that is\n  /// typing in one will update others too.\n  ///\n  /// See also:\n  /// https//github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\n  Snippet = 2,\n};\n\nstruct CompletionItem {\n  /// The label of this completion item. By default also the text that is\n  /// inserted when selecting this completion.\n  std::string label;\n\n  /// The kind of this completion item. Based of the kind an icon is chosen by\n  /// the editor.\n  CompletionItemKind kind = CompletionItemKind::Missing;\n\n  /// A human-readable string with additional information about this item, like\n  /// type or symbol information.\n  std::string detail;\n\n  /// A human-readable string that represents a doc-comment.\n  llvm::Optional<MarkupContent> documentation;\n\n  /// A string that should be used when comparing this item with other items.\n  /// When `falsy` the label is used.\n  std::string sortText;\n\n  /// A string that should be used when filtering a set of completion items.\n  /// When `falsy` the label is used.\n  std::string filterText;\n\n  /// A string that should be inserted to a document when selecting this\n  /// completion. When `falsy` the label is used.\n  std::string insertText;\n\n  /// The format of the insert text. The format applies to both the `insertText`\n  /// property and the `newText` property of a provided `textEdit`.\n  InsertTextFormat insertTextFormat = InsertTextFormat::Missing;\n\n  /// An edit which is applied to a document when selecting this completion.\n  /// When an edit is provided `insertText` is ignored.\n  ///\n  /// Note: The range of the edit must be a single line range and it must\n  /// contain the position at which completion has been requested.\n  llvm::Optional<TextEdit> textEdit;\n\n  /// An optional array of additional text edits that are applied when selecting\n  /// this completion. Edits must not overlap with the main edit nor with\n  /// themselves.\n  std::vector<TextEdit> additionalTextEdits;\n\n  /// Indicates if this item is deprecated.\n  bool deprecated = false;\n\n  /// The score that clangd calculates to rank the returned completions.\n  /// This excludes the fuzzy-match between `filterText` and the partial word.\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension.\n  float score = 0.f;\n\n  // TODO: Add custom commitCharacters for some of the completion items. For\n  // example, it makes sense to use () only for the functions.\n  // TODO(krasimir): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a completion item\n  //              between a completion and a completion resolve request.\n};\nllvm::json::Value toJSON(const CompletionItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const CompletionItem &);\n\nbool operator<(const CompletionItem &, const CompletionItem &);\n\n/// Represents a collection of completion items to be presented in the editor.\nstruct CompletionList {\n  /// The list is not complete. Further typing should result in recomputing the\n  /// list.\n  bool isIncomplete = false;\n\n  /// The completion items.\n  std::vector<CompletionItem> items;\n};\nllvm::json::Value toJSON(const CompletionList &);\n\n/// A single parameter of a particular signature.\nstruct ParameterInformation {\n\n  /// The label of this parameter. Ignored when labelOffsets is set.\n  std::string labelString;\n\n  /// Inclusive start and exclusive end offsets withing the containing signature\n  /// label.\n  /// Offsets are computed by lspLength(), which counts UTF-16 code units by\n  /// default but that can be overriden, see its documentation for details.\n  llvm::Optional<std::pair<unsigned, unsigned>> labelOffsets;\n\n  /// The documentation of this parameter. Optional.\n  std::string documentation;\n};\nllvm::json::Value toJSON(const ParameterInformation &);\n\n/// Represents the signature of something callable.\nstruct SignatureInformation {\n\n  /// The label of this signature. Mandatory.\n  std::string label;\n\n  /// The documentation of this signature. Optional.\n  std::string documentation;\n\n  /// The parameters of this signature.\n  std::vector<ParameterInformation> parameters;\n};\nllvm::json::Value toJSON(const SignatureInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SignatureInformation &);\n\n/// Represents the signature of a callable.\nstruct SignatureHelp {\n\n  /// The resulting signatures.\n  std::vector<SignatureInformation> signatures;\n\n  /// The active signature.\n  int activeSignature = 0;\n\n  /// The active parameter of the active signature.\n  int activeParameter = 0;\n\n  /// Position of the start of the argument list, including opening paren. e.g.\n  /// foo(\"first arg\",   \"second arg\",\n  ///    ^-argListStart   ^-cursor\n  /// This is a clangd-specific extension, it is only available via C++ API and\n  /// not currently serialized for the LSP.\n  Position argListStart;\n};\nllvm::json::Value toJSON(const SignatureHelp &);\n\nstruct RenameParams {\n  /// The document that was opened.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The new name of the symbol.\n  std::string newName;\n};\nbool fromJSON(const llvm::json::Value &, RenameParams &, llvm::json::Path);\n\nenum class DocumentHighlightKind { Text = 1, Read = 2, Write = 3 };\n\n/// A document highlight is a range inside a text document which deserves\n/// special attention. Usually a document highlight is visualized by changing\n/// the background color of its range.\n\nstruct DocumentHighlight {\n  /// The range this highlight applies to.\n  Range range;\n\n  /// The highlight kind, default is DocumentHighlightKind.Text.\n  DocumentHighlightKind kind = DocumentHighlightKind::Text;\n\n  friend bool operator<(const DocumentHighlight &LHS,\n                        const DocumentHighlight &RHS) {\n    int LHSKind = static_cast<int>(LHS.kind);\n    int RHSKind = static_cast<int>(RHS.kind);\n    return std::tie(LHS.range, LHSKind) < std::tie(RHS.range, RHSKind);\n  }\n\n  friend bool operator==(const DocumentHighlight &LHS,\n                         const DocumentHighlight &RHS) {\n    return LHS.kind == RHS.kind && LHS.range == RHS.range;\n  }\n};\nllvm::json::Value toJSON(const DocumentHighlight &DH);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const DocumentHighlight &);\n\nenum class TypeHierarchyDirection { Children = 0, Parents = 1, Both = 2 };\nbool fromJSON(const llvm::json::Value &E, TypeHierarchyDirection &Out,\n              llvm::json::Path);\n\n/// The type hierarchy params is an extension of the\n/// `TextDocumentPositionsParams` with optional properties which can be used to\n/// eagerly resolve the item when requesting from the server.\nstruct TypeHierarchyParams : public TextDocumentPositionParams {\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve = 0;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction = TypeHierarchyDirection::Parents;\n};\nbool fromJSON(const llvm::json::Value &, TypeHierarchyParams &,\n              llvm::json::Path);\n\nstruct TypeHierarchyItem {\n  /// The human readable name of the hierarchy item.\n  std::string name;\n\n  /// Optional detail for the hierarchy item. It can be, for instance, the\n  /// signature of a function or method.\n  llvm::Optional<std::string> detail;\n\n  /// The kind of the hierarchy item. For instance, class or interface.\n  SymbolKind kind;\n\n  /// `true` if the hierarchy item is deprecated. Otherwise, `false`.\n  bool deprecated = false;\n\n  /// The URI of the text document where this type hierarchy item belongs to.\n  URIForFile uri;\n\n  /// The range enclosing this type hierarchy item not including\n  /// leading/trailing whitespace but everything else like comments. This\n  /// information is typically used to determine if the client's cursor is\n  /// inside the type hierarch item to reveal in the symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this type hierarchy\n  /// item is being picked, e.g. the name of a function. Must be contained by\n  /// the `range`.\n  Range selectionRange;\n\n  /// If this type hierarchy item is resolved, it contains the direct parents.\n  /// Could be empty if the item does not have direct parents. If not defined,\n  /// the parents have not been resolved yet.\n  llvm::Optional<std::vector<TypeHierarchyItem>> parents;\n\n  /// If this type hierarchy item is resolved, it contains the direct children\n  /// of the current item. Could be empty if the item does not have any\n  /// descendants. If not defined, the children have not been resolved.\n  llvm::Optional<std::vector<TypeHierarchyItem>> children;\n\n  /// An optional 'data' field, which can be used to identify a type hierarchy\n  /// item in a resolve request.\n  llvm::Optional<std::string> data;\n};\nllvm::json::Value toJSON(const TypeHierarchyItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TypeHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, TypeHierarchyItem &, llvm::json::Path);\n\n/// Parameters for the `typeHierarchy/resolve` request.\nstruct ResolveTypeHierarchyItemParams {\n  /// The item to resolve.\n  TypeHierarchyItem item;\n\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction;\n};\nbool fromJSON(const llvm::json::Value &, ResolveTypeHierarchyItemParams &,\n              llvm::json::Path);\n\nenum class SymbolTag { Deprecated = 1 };\nllvm::json::Value toJSON(SymbolTag);\n\n/// The parameter of a `textDocument/prepareCallHierarchy` request.\nstruct CallHierarchyPrepareParams : public TextDocumentPositionParams {};\n\n/// Represents programming constructs like functions or constructors\n/// in the context of call hierarchy.\nstruct CallHierarchyItem {\n  /// The name of this item.\n  std::string name;\n\n  /// The kind of this item.\n  SymbolKind kind;\n\n  /// Tags for this item.\n  std::vector<SymbolTag> tags;\n\n  /// More detaill for this item, e.g. the signature of a function.\n  std::string detail;\n\n  /// The resource identifier of this item.\n  URIForFile uri;\n\n  /// The range enclosing this symbol not including leading / trailing\n  /// whitespace but everything else, e.g. comments and code.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol\n  /// is being picked, e.g. the name of a function.\n  /// Must be contained by `Rng`.\n  Range selectionRange;\n\n  /// An optional 'data' field, which can be used to identify a call\n  /// hierarchy item in an incomingCalls or outgoingCalls request.\n  std::string data;\n};\nllvm::json::Value toJSON(const CallHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, CallHierarchyItem &, llvm::json::Path);\n\n/// The parameter of a `callHierarchy/incomingCalls` request.\nstruct CallHierarchyIncomingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyIncomingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an incoming call, e.g. a caller of a method or constructor.\nstruct CallHierarchyIncomingCall {\n  /// The item that makes the call.\n  CallHierarchyItem from;\n\n  /// The range at which the calls appear.\n  /// This is relative to the caller denoted by `From`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyIncomingCall &);\n\n/// The parameter of a `callHierarchy/outgoingCalls` request.\nstruct CallHierarchyOutgoingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyOutgoingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an outgoing call, e.g. calling a getter from a method or\n/// a method from a constructor etc.\nstruct CallHierarchyOutgoingCall {\n  /// The item that is called.\n  CallHierarchyItem to;\n\n  /// The range at which this item is called.\n  /// This is the range relative to the caller, and not `To`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyOutgoingCall &);\n\nstruct ReferenceContext {\n  /// Include the declaration of the current symbol.\n  bool includeDeclaration = false;\n};\n\nstruct ReferenceParams : public TextDocumentPositionParams {\n  ReferenceContext context;\n};\nbool fromJSON(const llvm::json::Value &, ReferenceParams &, llvm::json::Path);\n\n/// Clangd extension: indicates the current state of the file in clangd,\n/// sent from server via the `textDocument/clangd.fileStatus` notification.\nstruct FileStatus {\n  /// The text document's URI.\n  URIForFile uri;\n  /// The human-readable string presents the current state of the file, can be\n  /// shown in the UI (e.g. status bar).\n  std::string state;\n  // FIXME: add detail messages.\n};\nllvm::json::Value toJSON(const FileStatus &);\n\n/// Specifies a single semantic token in the document.\n/// This struct is not part of LSP, which just encodes lists of tokens as\n/// arrays of numbers directly.\nstruct SemanticToken {\n  /// token line number, relative to the previous token\n  unsigned deltaLine = 0;\n  /// token start character, relative to the previous token\n  /// (relative to 0 or the previous token's start if they are on the same line)\n  unsigned deltaStart = 0;\n  /// the length of the token. A token cannot be multiline\n  unsigned length = 0;\n  /// will be looked up in `SemanticTokensLegend.tokenTypes`\n  unsigned tokenType = 0;\n  /// each set bit will be looked up in `SemanticTokensLegend.tokenModifiers`\n  unsigned tokenModifiers = 0;\n};\nbool operator==(const SemanticToken &, const SemanticToken &);\n\n/// A versioned set of tokens.\nstruct SemanticTokens {\n  // An optional result id. If provided and clients support delta updating\n  // the client will include the result id in the next semantic token request.\n  // A server can then instead of computing all semantic tokens again simply\n  // send a delta.\n  std::string resultId;\n\n  /// The actual tokens.\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array.\n};\nllvm::json::Value toJSON(const SemanticTokens &);\n\n/// Body of textDocument/semanticTokens/full request.\nstruct SemanticTokensParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, SemanticTokensParams &,\n              llvm::json::Path);\n\n/// Body of textDocument/semanticTokens/full/delta request.\n/// Requests the changes in semantic tokens since a previous response.\nstruct SemanticTokensDeltaParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n  /// The previous result id.\n  std::string previousResultId;\n};\nbool fromJSON(const llvm::json::Value &Params, SemanticTokensDeltaParams &R,\n              llvm::json::Path);\n\n/// Describes a a replacement of a contiguous range of semanticTokens.\nstruct SemanticTokensEdit {\n  // LSP specifies `start` and `deleteCount` which are relative to the array\n  // encoding of the previous tokens.\n  // We use token counts instead, and translate when serializing this struct.\n  unsigned startToken = 0;\n  unsigned deleteTokens = 0;\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array\n};\nllvm::json::Value toJSON(const SemanticTokensEdit &);\n\n/// This models LSP SemanticTokensDelta | SemanticTokens, which is the result of\n/// textDocument/semanticTokens/full/delta.\nstruct SemanticTokensOrDelta {\n  std::string resultId;\n  /// Set if we computed edits relative to a previous set of tokens.\n  llvm::Optional<std::vector<SemanticTokensEdit>> edits;\n  /// Set if we computed a fresh set of tokens.\n  llvm::Optional<std::vector<SemanticToken>> tokens; // encoded as integer array\n};\nllvm::json::Value toJSON(const SemanticTokensOrDelta &);\n\nstruct SelectionRangeParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The positions inside the text document.\n  std::vector<Position> positions;\n};\nbool fromJSON(const llvm::json::Value &, SelectionRangeParams &,\n              llvm::json::Path);\n\nstruct SelectionRange {\n  /**\n   * The range of this selection range.\n   */\n  Range range;\n  /**\n   * The parent selection range containing this range. Therefore `parent.range`\n   * must contain `this.range`.\n   */\n  std::unique_ptr<SelectionRange> parent;\n};\nllvm::json::Value toJSON(const SelectionRange &);\n\n/// Parameters for the document link request.\nstruct DocumentLinkParams {\n  /// The document to provide document links for.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentLinkParams &,\n              llvm::json::Path);\n\n/// A range in a text document that links to an internal or external resource,\n/// like another text document or a web site.\nstruct DocumentLink {\n  /// The range this link applies to.\n  Range range;\n\n  /// The uri this link points to. If missing a resolve request is sent later.\n  URIForFile target;\n\n  // TODO(forster): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a document link\n  //              between a DocumentLinkRequest and a\n  //              DocumentLinkResolveRequest.\n\n  friend bool operator==(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return LHS.range == RHS.range && LHS.target == RHS.target;\n  }\n\n  friend bool operator!=(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return !(LHS == RHS);\n  }\n};\nllvm::json::Value toJSON(const DocumentLink &DocumentLink);\n\n// FIXME(kirillbobyrev): Add FoldingRangeClientCapabilities so we can support\n// per-line-folding editors.\nstruct FoldingRangeParams {\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, FoldingRangeParams &,\n              llvm::json::Path);\n\n/// Stores information about a region of code that can be folded.\nstruct FoldingRange {\n  unsigned startLine = 0;\n  unsigned startCharacter;\n  unsigned endLine = 0;\n  unsigned endCharacter;\n  llvm::Optional<std::string> kind;\n};\nllvm::json::Value toJSON(const FoldingRange &Range);\n\n/// Keys starting with an underscore(_) represent leaves, e.g. _total or _self\n/// for memory usage of whole subtree or only that specific node in bytes. All\n/// other keys represents children. An example:\n///   {\n///     \"_self\": 0,\n///     \"_total\": 8,\n///     \"child1\": {\n///       \"_self\": 4,\n///       \"_total\": 4,\n///     }\n///     \"child2\": {\n///       \"_self\": 2,\n///       \"_total\": 4,\n///       \"child_deep\": {\n///         \"_self\": 2,\n///         \"_total\": 2,\n///       }\n///     }\n///   }\nllvm::json::Value toJSON(const MemoryTree &MT);\n\n/// Payload for textDocument/ast request.\n/// This request is a clangd extension.\nstruct ASTParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position of the node to be dumped.\n  /// The highest-level node that entirely contains the range will be returned.\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, ASTParams &, llvm::json::Path);\n\n/// Simplified description of a clang AST node.\n/// This is clangd's internal representation of C++ code.\nstruct ASTNode {\n  /// The general kind of node, such as \"expression\"\n  /// Corresponds to the base AST node type such as Expr.\n  std::string role;\n  /// The specific kind of node this is, such as \"BinaryOperator\".\n  /// This is usually a concrete node class (with Expr etc suffix dropped).\n  /// When there's no hierarchy (e.g. TemplateName), the variant (NameKind).\n  std::string kind;\n  /// Brief additional information, such as \"||\" for the particular operator.\n  /// The information included depends on the node kind, and may be empty.\n  std::string detail;\n  /// A one-line dump of detailed information about the node.\n  /// This includes role/kind/description information, but is rather cryptic.\n  /// It is similar to the output from `clang -Xclang -ast-dump`.\n  /// May be empty for certain types of nodes.\n  std::string arcana;\n  /// The range of the original source file covered by this node.\n  /// May be missing for implicit nodes, or those created by macro expansion.\n  llvm::Optional<Range> range;\n  /// Nodes nested within this one, such as the operands of a BinaryOperator.\n  std::vector<ASTNode> children;\n};\nllvm::json::Value toJSON(const ASTNode &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const ASTNode &);\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct format_provider<clang::clangd::Position> {\n  static void format(const clang::clangd::Position &Pos, raw_ostream &OS,\n                     StringRef Style) {\n    assert(Style.empty() && \"style modifiers for this type are not supported\");\n    OS << Pos;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "content": "//===--- URI.h - File URIs with schemes --------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Registry.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// A URI describes the location of a source file.\n/// In the simplest case, this is a \"file\" URI that directly encodes the\n/// absolute path to a file. More abstract cases are possible: a shared index\n/// service might expose repo:// URIs that are relative to the source control\n/// root.\n///\n/// Clangd handles URIs of the form <scheme>:[//<authority>]<body>. It doesn't\n/// further split the authority or body into constituent parts (e.g. query\n/// strings is included in the body).\nclass URI {\npublic:\n  URI(llvm::StringRef Scheme, llvm::StringRef Authority, llvm::StringRef Body);\n\n  /// Returns decoded scheme e.g. \"https\"\n  llvm::StringRef scheme() const { return Scheme; }\n  /// Returns decoded authority e.g. \"reviews.lvm.org\"\n  llvm::StringRef authority() const { return Authority; }\n  /// Returns decoded body e.g. \"/D41946\"\n  llvm::StringRef body() const { return Body; }\n\n  /// Returns a string URI with all components percent-encoded.\n  std::string toString() const;\n\n  /// Creates a URI for a file in the given scheme. \\p Scheme must be\n  /// registered. The URI is percent-encoded.\n  static llvm::Expected<URI> create(llvm::StringRef AbsolutePath,\n                                    llvm::StringRef Scheme);\n\n  // Similar to above except this picks a registered scheme that works. If none\n  // works, this falls back to \"file\" scheme.\n  static URI create(llvm::StringRef AbsolutePath);\n\n  /// This creates a file:// URI for \\p AbsolutePath. The path must be absolute.\n  static URI createFile(llvm::StringRef AbsolutePath);\n\n  /// Parse a URI string \"<scheme>:[//<authority>/]<path>\". Percent-encoded\n  /// characters in the URI will be decoded.\n  static llvm::Expected<URI> parse(llvm::StringRef Uri);\n\n  /// Resolves the absolute path of \\p U. If there is no matching scheme, or the\n  /// URI is invalid in the scheme, this returns an error.\n  ///\n  /// \\p HintPath A related path, such as the current file or working directory,\n  /// which can help disambiguate when the same file exists in many workspaces.\n  static llvm::Expected<std::string> resolve(const URI &U,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Same as above, in addition it parses the \\p FileURI using URI::parse.\n  static llvm::Expected<std::string> resolve(llvm::StringRef FileURI,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Resolves \\p AbsPath into a canonical path of its URI, by converting\n  /// \\p AbsPath to URI and resolving the URI to get th canonical path.\n  /// This ensures that paths with the same URI are resolved into consistent\n  /// file path.\n  static llvm::Expected<std::string> resolvePath(llvm::StringRef AbsPath,\n                                                 llvm::StringRef HintPath = \"\");\n\n  /// Gets the preferred spelling of this file for #include, if there is one,\n  /// e.g. <system_header.h>, \"path/to/x.h\".\n  ///\n  /// This allows URI schemas to provide their customized include paths.\n  ///\n  /// Returns an empty string if normal include-shortening based on the absolute\n  /// path should be used.\n  /// Fails if the URI is not valid in the schema.\n  static llvm::Expected<std::string> includeSpelling(const URI &U);\n\n  friend bool operator==(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) ==\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\n  friend bool operator<(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) <\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\nprivate:\n  URI() = default;\n\n  std::string Scheme;\n  std::string Authority;\n  std::string Body;\n};\n\n/// URIScheme is an extension point for teaching clangd to recognize a custom\n/// URI scheme. This is expected to be implemented and exposed via the\n/// URISchemeRegistry.\nclass URIScheme {\npublic:\n  virtual ~URIScheme() = default;\n\n  /// Returns the absolute path of the file corresponding to the URI\n  /// authority+body in the file system. See URI::resolve for semantics of\n  /// \\p HintPath.\n  virtual llvm::Expected<std::string>\n  getAbsolutePath(llvm::StringRef Authority, llvm::StringRef Body,\n                  llvm::StringRef HintPath) const = 0;\n\n  virtual llvm::Expected<URI>\n  uriFromAbsolutePath(llvm::StringRef AbsolutePath) const = 0;\n\n  /// Returns the include path of the file (e.g. <path>, \"path\"), which can be\n  /// #included directly. See URI::includeSpelling for details.\n  virtual llvm::Expected<std::string> getIncludeSpelling(const URI &U) const {\n    return \"\"; // no customized include path for this scheme.\n  }\n};\n\n/// By default, a \"file\" scheme is supported where URI paths are always absolute\n/// in the file system.\ntypedef llvm::Registry<URIScheme> URISchemeRegistry;\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "content": "//===--- Index.h -------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n\n#include \"Ref.h\"\n#include \"Relation.h\"\n#include \"Symbol.h\"\n#include \"SymbolID.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Support/JSON.h\"\n#include <mutex>\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nstruct FuzzyFindRequest {\n  /// A query string for the fuzzy find. This is matched against symbols'\n  /// un-qualified identifiers and should not contain qualifiers like \"::\".\n  std::string Query;\n  /// If this is non-empty, symbols must be in at least one of the scopes\n  /// (e.g. namespaces) excluding nested scopes. For example, if a scope \"xyz::\"\n  /// is provided, the matched symbols must be defined in namespace xyz but not\n  /// namespace xyz::abc.\n  ///\n  /// The global scope is \"\", a top level scope is \"foo::\", etc.\n  std::vector<std::string> Scopes;\n  /// If set to true, allow symbols from any scope. Scopes explicitly listed\n  /// above will be ranked higher.\n  bool AnyScope = false;\n  /// The number of top candidates to return. The index may choose to\n  /// return more than this, e.g. if it doesn't know which candidates are best.\n  llvm::Optional<uint32_t> Limit;\n  /// If set to true, only symbols for completion support will be considered.\n  bool RestrictForCodeCompletion = false;\n  /// Contextually relevant files (e.g. the file we're code-completing in).\n  /// Paths should be absolute.\n  std::vector<std::string> ProximityPaths;\n  /// Preferred types of symbols. These are raw representation of `OpaqueType`.\n  std::vector<std::string> PreferredTypes;\n\n  bool operator==(const FuzzyFindRequest &Req) const {\n    return std::tie(Query, Scopes, Limit, RestrictForCodeCompletion,\n                    ProximityPaths, PreferredTypes) ==\n           std::tie(Req.Query, Req.Scopes, Req.Limit,\n                    Req.RestrictForCodeCompletion, Req.ProximityPaths,\n                    Req.PreferredTypes);\n  }\n  bool operator!=(const FuzzyFindRequest &Req) const { return !(*this == Req); }\n};\nbool fromJSON(const llvm::json::Value &Value, FuzzyFindRequest &Request,\n              llvm::json::Path);\nllvm::json::Value toJSON(const FuzzyFindRequest &Request);\n\nstruct LookupRequest {\n  llvm::DenseSet<SymbolID> IDs;\n};\n\nstruct RefsRequest {\n  llvm::DenseSet<SymbolID> IDs;\n  RefKind Filter = RefKind::All;\n  /// If set, limit the number of refers returned from the index. The index may\n  /// choose to return less than this, e.g. it tries to avoid returning stale\n  /// results.\n  llvm::Optional<uint32_t> Limit;\n};\n\nstruct RelationsRequest {\n  llvm::DenseSet<SymbolID> Subjects;\n  RelationKind Predicate;\n  /// If set, limit the number of relations returned from the index.\n  llvm::Optional<uint32_t> Limit;\n};\n\n/// Describes what data is covered by an index.\n///\n/// Indexes may contain symbols but not references from a file, etc.\n/// This affects merging: if a staler index contains a reference but a fresher\n/// one does not, we want to trust the fresher index *only* if it actually\n/// includes references in general.\nenum class IndexContents : uint8_t {\n  None = 0,\n  Symbols = 1 << 1,\n  References = 1 << 2,\n  Relations = 1 << 3,\n  All = Symbols | References | Relations\n};\n\ninline constexpr IndexContents operator&(IndexContents L, IndexContents R) {\n  return static_cast<IndexContents>(static_cast<uint8_t>(L) &\n                                    static_cast<uint8_t>(R));\n}\n\ninline constexpr IndexContents operator|(IndexContents L, IndexContents R) {\n  return static_cast<IndexContents>(static_cast<uint8_t>(L) |\n                                    static_cast<uint8_t>(R));\n}\n\n/// Interface for symbol indexes that can be used for searching or\n/// matching symbols among a set of symbols based on names or unique IDs.\nclass SymbolIndex {\npublic:\n  virtual ~SymbolIndex() = default;\n\n  /// Matches symbols in the index fuzzily and applies \\p Callback on\n  /// each matched symbol before returning.\n  /// If returned Symbols are used outside Callback, they must be deep-copied!\n  ///\n  /// Returns true if there may be more results (limited by Req.Limit).\n  virtual bool\n  fuzzyFind(const FuzzyFindRequest &Req,\n            llvm::function_ref<void(const Symbol &)> Callback) const = 0;\n\n  /// Looks up symbols with any of the given symbol IDs and applies \\p Callback\n  /// on each matched symbol.\n  /// The returned symbol must be deep-copied if it's used outside Callback.\n  virtual void\n  lookup(const LookupRequest &Req,\n         llvm::function_ref<void(const Symbol &)> Callback) const = 0;\n\n  /// Finds all occurrences (e.g. references, declarations, definitions) of\n  /// symbols and applies \\p Callback on each result.\n  ///\n  /// Results should be returned in arbitrary order.\n  /// The returned result must be deep-copied if it's used outside Callback.\n  /// FIXME: there's no indication which result references which symbol.\n  ///\n  /// Returns true if there will be more results (limited by Req.Limit);\n  virtual bool refs(const RefsRequest &Req,\n                    llvm::function_ref<void(const Ref &)> Callback) const = 0;\n\n  /// Finds all relations (S, P, O) stored in the index such that S is among\n  /// Req.Subjects and P is Req.Predicate, and invokes \\p Callback for (S, O) in\n  /// each.\n  virtual void relations(\n      const RelationsRequest &Req,\n      llvm::function_ref<void(const SymbolID &Subject, const Symbol &Object)>\n          Callback) const = 0;\n\n  /// Returns function which checks if the specified file was used to build this\n  /// index or not. The function must only be called while the index is alive.\n  virtual llvm::unique_function<IndexContents(llvm::StringRef) const>\n  indexedFiles() const = 0;\n\n  /// Returns estimated size of index (in bytes).\n  virtual size_t estimateMemoryUsage() const = 0;\n};\n\n// Delegating implementation of SymbolIndex whose delegate can be swapped out.\nclass SwapIndex : public SymbolIndex {\npublic:\n  // If an index is not provided, reset() must be called.\n  SwapIndex(std::unique_ptr<SymbolIndex> Index = nullptr)\n      : Index(std::move(Index)) {}\n  void reset(std::unique_ptr<SymbolIndex>);\n\n  // SymbolIndex methods delegate to the current index, which is kept alive\n  // until the call returns (even if reset() is called).\n  bool fuzzyFind(const FuzzyFindRequest &,\n                 llvm::function_ref<void(const Symbol &)>) const override;\n  void lookup(const LookupRequest &,\n              llvm::function_ref<void(const Symbol &)>) const override;\n  bool refs(const RefsRequest &,\n            llvm::function_ref<void(const Ref &)>) const override;\n  void relations(const RelationsRequest &,\n                 llvm::function_ref<void(const SymbolID &, const Symbol &)>)\n      const override;\n\n  llvm::unique_function<IndexContents(llvm::StringRef) const>\n  indexedFiles() const override;\n\n  size_t estimateMemoryUsage() const override;\n\nprivate:\n  std::shared_ptr<SymbolIndex> snapshot() const;\n  mutable std::mutex Mutex;\n  std::shared_ptr<SymbolIndex> Index;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "content": "//===--- Ref.h ---------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <set>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\n/// Describes the kind of a cross-reference.\n///\n/// This is a bitfield which can be combined from different kinds.\nenum class RefKind : uint8_t {\n  Unknown = 0,\n  // Points to symbol declaration. Example:\n  //\n  // class Foo;\n  //       ^ Foo declaration\n  // Foo foo;\n  // ^ this does not reference Foo declaration\n  Declaration = 1 << 0,\n  // Points to symbol definition. Example:\n  //\n  // int foo();\n  //     ^ references foo declaration, but not foo definition\n  // int foo() { return 42; }\n  //     ^ references foo definition, but not declaration\n  // bool bar() { return true; }\n  //      ^ references both definition and declaration\n  Definition = 1 << 1,\n  // Points to symbol reference. Example:\n  //\n  // int Foo = 42;\n  // int Bar = Foo + 1;\n  //           ^ this is a reference to Foo\n  Reference = 1 << 2,\n  // The reference explicitly spells out declaration's name. Such references can\n  // not come from macro expansions or implicit AST nodes.\n  //\n  // class Foo { public: Foo() {} };\n  //       ^ references declaration, definition and explicitly spells out name\n  // #define MACRO Foo\n  //     v there is an implicit constructor call here which is not a spelled ref\n  // Foo foo;\n  // ^ this reference explicitly spells out Foo's name\n  // struct Bar {\n  //   MACRO Internal;\n  //   ^ this references Foo, but does not explicitly spell out its name\n  // };\n  Spelled = 1 << 3,\n  All = Declaration | Definition | Reference | Spelled,\n};\n\ninline RefKind operator|(RefKind L, RefKind R) {\n  return static_cast<RefKind>(static_cast<uint8_t>(L) |\n                              static_cast<uint8_t>(R));\n}\ninline RefKind &operator|=(RefKind &L, RefKind R) { return L = L | R; }\ninline RefKind operator&(RefKind A, RefKind B) {\n  return static_cast<RefKind>(static_cast<uint8_t>(A) &\n                              static_cast<uint8_t>(B));\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, RefKind);\n\n/// Represents a symbol occurrence in the source file.\n/// Despite the name, it could be a declaration/definition/reference.\n///\n/// WARNING: Location does not own the underlying data - Copies are shallow.\nstruct Ref {\n  /// The source location where the symbol is named.\n  SymbolLocation Location;\n  RefKind Kind = RefKind::Unknown;\n  /// The ID of the symbol whose definition contains this reference.\n  /// For example, for a reference inside a function body, this would\n  /// be that function. For top-level definitions this isNull().\n  SymbolID Container;\n};\n\ninline bool operator<(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) <\n         std::tie(R.Location, R.Kind, R.Container);\n}\ninline bool operator==(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) ==\n         std::tie(R.Location, R.Kind, R.Container);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Ref &);\n\n/// An efficient structure of storing large set of symbol references in memory.\n/// Filenames are deduplicated.\nclass RefSlab {\npublic:\n  // Refs are stored in order.\n  using value_type = std::pair<SymbolID, llvm::ArrayRef<Ref>>;\n  using const_iterator = std::vector<value_type>::const_iterator;\n  using iterator = const_iterator;\n\n  RefSlab() = default;\n  RefSlab(RefSlab &&Slab) = default;\n  RefSlab &operator=(RefSlab &&RHS) = default;\n\n  const_iterator begin() const { return Refs.begin(); }\n  const_iterator end() const { return Refs.end(); }\n  /// Gets the number of symbols.\n  size_t size() const { return Refs.size(); }\n  size_t numRefs() const { return NumRefs; }\n  bool empty() const { return Refs.empty(); }\n\n  size_t bytes() const {\n    return sizeof(*this) + Arena.getTotalMemory() +\n           sizeof(value_type) * Refs.capacity();\n  }\n\n  /// RefSlab::Builder is a mutable container that can 'freeze' to RefSlab.\n  class Builder {\n  public:\n    Builder() : UniqueStrings(Arena) {}\n    /// Adds a ref to the slab. Deep copy: Strings will be owned by the slab.\n    void insert(const SymbolID &ID, const Ref &S);\n    /// Consumes the builder to finalize the slab.\n    RefSlab build() &&;\n\n  private:\n    // A ref we're storing with its symbol to consume with build().\n    // All strings are interned, so DenseMapInfo can use pointer comparisons.\n    struct Entry {\n      SymbolID Symbol;\n      Ref Reference;\n    };\n    friend struct llvm::DenseMapInfo<Entry>;\n\n    llvm::BumpPtrAllocator Arena;\n    llvm::UniqueStringSaver UniqueStrings; // Contents on the arena.\n    llvm::DenseSet<Entry> Entries;\n  };\n\nprivate:\n  RefSlab(std::vector<value_type> Refs, llvm::BumpPtrAllocator Arena,\n          size_t NumRefs)\n      : Arena(std::move(Arena)), Refs(std::move(Refs)), NumRefs(NumRefs) {}\n\n  llvm::BumpPtrAllocator Arena;\n  std::vector<value_type> Refs;\n  /// Number of all references.\n  size_t NumRefs = 0;\n};\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct DenseMapInfo<clang::clangd::RefSlab::Builder::Entry> {\n  using Entry = clang::clangd::RefSlab::Builder::Entry;\n  static inline Entry getEmptyKey() {\n    static Entry E{clang::clangd::SymbolID(\"\"), {}};\n    return E;\n  }\n  static inline Entry getTombstoneKey() {\n    static Entry E{clang::clangd::SymbolID(\"TOMBSTONE\"), {}};\n    return E;\n  }\n  static unsigned getHashValue(const Entry &Val) {\n    return llvm::hash_combine(\n        Val.Symbol, reinterpret_cast<uintptr_t>(Val.Reference.Location.FileURI),\n        Val.Reference.Location.Start.rep(), Val.Reference.Location.End.rep());\n  }\n  static bool isEqual(const Entry &LHS, const Entry &RHS) {\n    return std::tie(LHS.Symbol, LHS.Reference.Location.FileURI,\n                    LHS.Reference.Kind) ==\n               std::tie(RHS.Symbol, RHS.Reference.Location.FileURI,\n                        RHS.Reference.Kind) &&\n           LHS.Reference.Location.Start == RHS.Reference.Location.Start &&\n           LHS.Reference.Location.End == RHS.Reference.Location.End;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Relation.h", "content": "//===--- Relation.h ----------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RELATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RELATION_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <cstdint>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\nenum class RelationKind : uint8_t {\n  BaseOf,\n  OverriddenBy,\n};\n\n/// Represents a relation between two symbols.\n/// For an example:\n///   - \"A is a base class of B\" is represented as\n///     { Subject = A, Predicate = BaseOf, Object = B }.\n///   - \"Derived::Foo overrides Base::Foo\" is represented as\n///     { Subject = Base::Foo, Predicate = OverriddenBy, Object = Derived::Foo\n///     }.\nstruct Relation {\n  SymbolID Subject;\n  RelationKind Predicate;\n  SymbolID Object;\n\n  bool operator==(const Relation &Other) const {\n    return std::tie(Subject, Predicate, Object) ==\n           std::tie(Other.Subject, Other.Predicate, Other.Object);\n  }\n  // SPO order\n  bool operator<(const Relation &Other) const {\n    return std::tie(Subject, Predicate, Object) <\n           std::tie(Other.Subject, Other.Predicate, Other.Object);\n  }\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const RelationKind R);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Relation &R);\n\nclass RelationSlab {\npublic:\n  using value_type = Relation;\n  using const_iterator = std::vector<value_type>::const_iterator;\n  using iterator = const_iterator;\n\n  RelationSlab() = default;\n  RelationSlab(RelationSlab &&Slab) = default;\n  RelationSlab &operator=(RelationSlab &&RHS) = default;\n\n  const_iterator begin() const { return Relations.begin(); }\n  const_iterator end() const { return Relations.end(); }\n  size_t size() const { return Relations.size(); }\n  bool empty() const { return Relations.empty(); }\n\n  size_t bytes() const {\n    return sizeof(*this) + sizeof(value_type) * Relations.capacity();\n  }\n\n  /// Lookup all relations matching the given subject and predicate.\n  llvm::iterator_range<iterator> lookup(const SymbolID &Subject,\n                                        RelationKind Predicate) const;\n\n  /// RelationSlab::Builder is a mutable container that can 'freeze' to\n  /// RelationSlab.\n  class Builder {\n  public:\n    /// Adds a relation to the slab.\n    void insert(const Relation &R) { Relations.push_back(R); }\n\n    /// Consumes the builder to finalize the slab.\n    RelationSlab build() &&;\n\n  private:\n    std::vector<Relation> Relations;\n  };\n\nprivate:\n  RelationSlab(std::vector<Relation> Relations)\n      : Relations(std::move(Relations)) {}\n\n  std::vector<Relation> Relations;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RELATION_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolID.h", "content": "//===--- SymbolID.h ----------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLID_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLID_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <array>\n#include <cstdint>\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\n// The class identifies a particular C++ symbol (class, function, method, etc).\n//\n// As USRs (Unified Symbol Resolution) could be large, especially for functions\n// with long type arguments, SymbolID is using truncated SHA1(USR) values to\n// guarantee the uniqueness of symbols while using a relatively small amount of\n// memory (vs storing USRs directly).\n//\n// SymbolID can be used as key in the symbol indexes to lookup the symbol.\nclass SymbolID {\npublic:\n  SymbolID() = default;\n  explicit SymbolID(llvm::StringRef USR);\n\n  bool operator==(const SymbolID &Sym) const {\n    return HashValue == Sym.HashValue;\n  }\n  bool operator!=(const SymbolID &Sym) const {\n    return !(*this == Sym);\n  }\n  bool operator<(const SymbolID &Sym) const {\n    return HashValue < Sym.HashValue;\n  }\n\n  // The stored hash is truncated to RawSize bytes.\n  // This trades off memory against the number of symbols we can handle.\n  constexpr static size_t RawSize = 8;\n  llvm::StringRef raw() const;\n  static SymbolID fromRaw(llvm::StringRef);\n\n  // Returns a hex encoded string.\n  std::string str() const;\n  static llvm::Expected<SymbolID> fromStr(llvm::StringRef);\n\n  bool isNull() const { return *this == SymbolID(); }\n  explicit operator bool() const { return !isNull(); }\n\nprivate:\n  std::array<uint8_t, RawSize> HashValue{};\n};\n\nllvm::hash_code hash_value(const SymbolID &ID);\n\n// Write SymbolID into the given stream. SymbolID is encoded as ID.str().\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const SymbolID &ID);\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\n// Support SymbolIDs as DenseMap keys.\ntemplate <> struct DenseMapInfo<clang::clangd::SymbolID> {\n  static inline clang::clangd::SymbolID getEmptyKey() {\n    static clang::clangd::SymbolID EmptyKey(\"EMPTYKEY\");\n    return EmptyKey;\n  }\n  static inline clang::clangd::SymbolID getTombstoneKey() {\n    static clang::clangd::SymbolID TombstoneKey(\"TOMBSTONEKEY\");\n    return TombstoneKey;\n  }\n  static unsigned getHashValue(const clang::clangd::SymbolID &Sym) {\n    return hash_value(Sym);\n  }\n  static bool isEqual(const clang::clangd::SymbolID &LHS,\n                      const clang::clangd::SymbolID &RHS) {\n    return LHS == RHS;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLID_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "content": "//===--- SymbolLocation.h ----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\nstruct SymbolLocation {\n  // Specify a position (Line, Column) of symbol. Using Line/Column allows us to\n  // build LSP responses without reading the file content.\n  //\n  // clangd uses the following definitions, which differ slightly from LSP:\n  //  - Line is the number of newline characters (\\n) before the point.\n  //  - Column is (by default) the number of UTF-16 code between the last \\n\n  //    (or start of file) and the point.\n  //    If the `offsetEncoding` protocol extension is used to negotiate UTF-8,\n  //    then it is instead the number of *bytes* since the last \\n.\n  //\n  // Position is encoded into 32 bits to save space.\n  // If Line/Column overflow, the value will be their maximum value.\n  struct Position {\n    Position() : LineColumnPacked(0) {}\n    void setLine(uint32_t Line);\n    uint32_t line() const { return LineColumnPacked >> ColumnBits; }\n    void setColumn(uint32_t Column);\n    uint32_t column() const { return LineColumnPacked & MaxColumn; }\n    uint32_t rep() const { return LineColumnPacked; }\n\n    bool hasOverflow() const {\n      return line() == MaxLine || column() == MaxColumn;\n    }\n\n    static constexpr unsigned ColumnBits = 12;\n    static constexpr uint32_t MaxLine = (1 << (32 - ColumnBits)) - 1;\n    static constexpr uint32_t MaxColumn = (1 << ColumnBits) - 1;\n\n  private:\n    uint32_t LineColumnPacked; // Top 20 bit line, bottom 12 bits column.\n  };\n\n  /// The symbol range, using half-open range [Start, End).\n  Position Start;\n  Position End;\n\n  explicit operator bool() const { return !llvm::StringRef(FileURI).empty(); }\n\n  // The URI of the source file where a symbol occurs.\n  // The string must be null-terminated.\n  //\n  // We avoid using llvm::StringRef here to save memory.\n  // WARNING: unless you know what you are doing, it is recommended to use it\n  // via llvm::StringRef.\n  const char *FileURI = \"\";\n};\n\ninline bool operator==(const SymbolLocation::Position &L,\n                       const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) ==\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator<(const SymbolLocation::Position &L,\n                      const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) <\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator==(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  return !std::strcmp(L.FileURI, R.FileURI) &&\n         std::tie(L.Start, L.End) == std::tie(R.Start, R.End);\n}\ninline bool operator<(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  int Cmp = std::strcmp(L.FileURI, R.FileURI);\n  if (Cmp != 0)\n    return Cmp < 0;\n  return std::tie(L.Start, L.End) < std::tie(R.Start, R.End);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolLocation &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "content": "//===--- Threading.h - Abstractions for multithreading -----------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n\n#include \"support/Context.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <cassert>\n#include <condition_variable>\n#include <future>\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// A threadsafe flag that is initially clear.\nclass Notification {\npublic:\n  // Sets the flag. No-op if already set.\n  void notify();\n  // Blocks until flag is set.\n  void wait() const;\n\nprivate:\n  bool Notified = false;\n  mutable std::condition_variable CV;\n  mutable std::mutex Mu;\n};\n\n/// Limits the number of threads that can acquire the lock at the same time.\nclass Semaphore {\npublic:\n  Semaphore(std::size_t MaxLocks);\n\n  bool try_lock();\n  void lock();\n  void unlock();\n\nprivate:\n  std::mutex Mutex;\n  std::condition_variable SlotsChanged;\n  std::size_t FreeSlots;\n};\n\n/// A point in time we can wait for.\n/// Can be zero (don't wait) or infinity (wait forever).\n/// (Not time_point::max(), because many std::chrono implementations overflow).\nclass Deadline {\npublic:\n  Deadline(std::chrono::steady_clock::time_point Time)\n      : Type(Finite), Time(Time) {}\n  static Deadline zero() { return Deadline(Zero); }\n  static Deadline infinity() { return Deadline(Infinite); }\n\n  std::chrono::steady_clock::time_point time() const {\n    assert(Type == Finite);\n    return Time;\n  }\n  bool expired() const {\n    return (Type == Zero) ||\n           (Type == Finite && Time < std::chrono::steady_clock::now());\n  }\n  bool operator==(const Deadline &Other) const {\n    return (Type == Other.Type) && (Type != Finite || Time == Other.Time);\n  }\n\nprivate:\n  enum Type { Zero, Infinite, Finite };\n\n  Deadline(enum Type Type) : Type(Type) {}\n  enum Type Type;\n  std::chrono::steady_clock::time_point Time;\n};\n\n/// Makes a deadline from a timeout in seconds. None means wait forever.\nDeadline timeoutSeconds(llvm::Optional<double> Seconds);\n/// Wait once on CV for the specified duration.\nvoid wait(std::unique_lock<std::mutex> &Lock, std::condition_variable &CV,\n          Deadline D);\n/// Waits on a condition variable until F() is true or D expires.\ntemplate <typename Func>\nLLVM_NODISCARD bool wait(std::unique_lock<std::mutex> &Lock,\n                         std::condition_variable &CV, Deadline D, Func F) {\n  while (!F()) {\n    if (D.expired())\n      return false;\n    wait(Lock, CV, D);\n  }\n  return true;\n}\n\n/// Runs tasks on separate (detached) threads and wait for all tasks to finish.\n/// Objects that need to spawn threads can own an AsyncTaskRunner to ensure they\n/// all complete on destruction.\nclass AsyncTaskRunner {\npublic:\n  /// Destructor waits for all pending tasks to finish.\n  ~AsyncTaskRunner();\n\n  void wait() const { (void)wait(Deadline::infinity()); }\n  LLVM_NODISCARD bool wait(Deadline D) const;\n  // The name is used for tracing and debugging (e.g. to name a spawned thread).\n  void runAsync(const llvm::Twine &Name, llvm::unique_function<void()> Action);\n\nprivate:\n  mutable std::mutex Mutex;\n  mutable std::condition_variable TasksReachedZero;\n  std::size_t InFlightTasks = 0;\n};\n\n/// Runs \\p Action asynchronously with a new std::thread. The context will be\n/// propagated.\ntemplate <typename T>\nstd::future<T> runAsync(llvm::unique_function<T()> Action) {\n  return std::async(\n      std::launch::async,\n      [](llvm::unique_function<T()> &&Action, Context Ctx) {\n        WithContext WithCtx(std::move(Ctx));\n        return Action();\n      },\n      std::move(Action), Context::current().clone());\n}\n\n/// Memoize is a cache to store and reuse computation results based on a key.\n///\n///   Memoize<DenseMap<int, bool>> PrimeCache;\n///   for (int I : RepetitiveNumbers)\n///     if (PrimeCache.get(I, [&] { return expensiveIsPrime(I); }))\n///       llvm::errs() << \"Prime: \" << I << \"\\n\";\n///\n/// The computation will only be run once for each key.\n/// This class is threadsafe. Concurrent calls for the same key may run the\n/// computation multiple times, but each call will return the same result.\ntemplate <typename Container> class Memoize {\n  mutable Container Cache;\n  std::unique_ptr<std::mutex> Mu;\n\npublic:\n  Memoize() : Mu(std::make_unique<std::mutex>()) {}\n\n  template <typename T, typename Func>\n  typename Container::mapped_type get(T &&Key, Func Compute) const {\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto It = Cache.find(Key);\n      if (It != Cache.end())\n        return It->second;\n    }\n    // Don't hold the mutex while computing.\n    auto V = Compute();\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto R = Cache.try_emplace(std::forward<T>(Key), V);\n      // Insert into cache may fail if we raced with another thread.\n      if (!R.second)\n        return R.first->second; // Canonical value, from other thread.\n    }\n    return V;\n  }\n};\n\n/// Used to guard an operation that should run at most every N seconds.\n///\n/// Usage:\n///   mutable PeriodicThrottler ShouldLog(std::chrono::seconds(1));\n///   void calledFrequently() {\n///     if (ShouldLog())\n///       log(\"this is not spammy\");\n///   }\n///\n/// This class is threadsafe. If multiple threads are involved, then the guarded\n/// operation still needs to be threadsafe!\nclass PeriodicThrottler {\n  using Stopwatch = std::chrono::steady_clock;\n  using Rep = Stopwatch::duration::rep;\n\n  Rep Period;\n  std::atomic<Rep> Next;\n\npublic:\n  /// If Period is zero, the throttler will return true every time.\n  PeriodicThrottler(Stopwatch::duration Period, Stopwatch::duration Delay = {})\n      : Period(Period.count()),\n        Next((Stopwatch::now() + Delay).time_since_epoch().count()) {}\n\n  /// Returns whether the operation should run at this time.\n  /// operator() is safe to call concurrently.\n  bool operator()();\n};\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "content": "//===--- ASTTypeTraits.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Provides a dynamic type identifier and a dynamically typed node container\n//  that can be used to store an AST base node at runtime in the same storage in\n//  a type safe way.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTTYPETRAITS_H\n#define LLVM_CLANG_AST_ASTTYPETRAITS_H\n\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\n\n}\n\nnamespace clang {\n\nstruct PrintingPolicy;\n\n/// Defines how we descend a level in the AST when we pass\n/// through expressions.\nenum TraversalKind {\n  /// Will traverse all child nodes.\n  TK_AsIs,\n\n  /// Ignore AST nodes not written in the source\n  TK_IgnoreUnlessSpelledInSource\n};\n\n/// Kind identifier.\n///\n/// It can be constructed from any node kind and allows for runtime type\n/// hierarchy checks.\n/// Use getFromNodeKind<T>() to construct them.\nclass ASTNodeKind {\npublic:\n  /// Empty identifier. It matches nothing.\n  ASTNodeKind() : KindId(NKI_None) {}\n\n  /// Construct an identifier for T.\n  template <class T>\n  static ASTNodeKind getFromNodeKind() {\n    return ASTNodeKind(KindToKindId<T>::Id);\n  }\n\n  /// \\{\n  /// Construct an identifier for the dynamic type of the node\n  static ASTNodeKind getFromNode(const Decl &D);\n  static ASTNodeKind getFromNode(const Stmt &S);\n  static ASTNodeKind getFromNode(const Type &T);\n  static ASTNodeKind getFromNode(const OMPClause &C);\n  /// \\}\n\n  /// Returns \\c true if \\c this and \\c Other represent the same kind.\n  bool isSame(ASTNodeKind Other) const {\n    return KindId != NKI_None && KindId == Other.KindId;\n  }\n\n  /// Returns \\c true only for the default \\c ASTNodeKind()\n  bool isNone() const { return KindId == NKI_None; }\n\n  /// Returns \\c true if \\c this is a base kind of (or same as) \\c Other.\n  /// \\param Distance If non-null, used to return the distance between \\c this\n  /// and \\c Other in the class hierarchy.\n  bool isBaseOf(ASTNodeKind Other, unsigned *Distance = nullptr) const;\n\n  /// String representation of the kind.\n  StringRef asStringRef() const;\n\n  /// Strict weak ordering for ASTNodeKind.\n  bool operator<(const ASTNodeKind &Other) const {\n    return KindId < Other.KindId;\n  }\n\n  /// Return the most derived type between \\p Kind1 and \\p Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedType(ASTNodeKind Kind1, ASTNodeKind Kind2);\n\n  /// Return the most derived common ancestor between Kind1 and Kind2.\n  ///\n  /// Return ASTNodeKind() if they are not related.\n  static ASTNodeKind getMostDerivedCommonAncestor(ASTNodeKind Kind1,\n                                                  ASTNodeKind Kind2);\n\n  ASTNodeKind getCladeKind() const;\n\n  /// Hooks for using ASTNodeKind as a key in a DenseMap.\n  struct DenseMapInfo {\n    // ASTNodeKind() is a good empty key because it is represented as a 0.\n    static inline ASTNodeKind getEmptyKey() { return ASTNodeKind(); }\n    // NKI_NumberOfKinds is not a valid value, so it is good for a\n    // tombstone key.\n    static inline ASTNodeKind getTombstoneKey() {\n      return ASTNodeKind(NKI_NumberOfKinds);\n    }\n    static unsigned getHashValue(const ASTNodeKind &Val) { return Val.KindId; }\n    static bool isEqual(const ASTNodeKind &LHS, const ASTNodeKind &RHS) {\n      return LHS.KindId == RHS.KindId;\n    }\n  };\n\n  /// Check if the given ASTNodeKind identifies a type that offers pointer\n  /// identity. This is useful for the fast path in DynTypedNode.\n  bool hasPointerIdentity() const {\n    return KindId > NKI_LastKindWithoutPointerIdentity;\n  }\n\nprivate:\n  /// Kind ids.\n  ///\n  /// Includes all possible base and derived kinds.\n  enum NodeKindId {\n    NKI_None,\n    NKI_TemplateArgument,\n    NKI_TemplateArgumentLoc,\n    NKI_TemplateName,\n    NKI_NestedNameSpecifierLoc,\n    NKI_QualType,\n    NKI_TypeLoc,\n    NKI_LastKindWithoutPointerIdentity = NKI_TypeLoc,\n    NKI_CXXBaseSpecifier,\n    NKI_CXXCtorInitializer,\n    NKI_NestedNameSpecifier,\n    NKI_Decl,\n#define DECL(DERIVED, BASE) NKI_##DERIVED##Decl,\n#include \"clang/AST/DeclNodes.inc\"\n    NKI_Stmt,\n#define STMT(DERIVED, BASE) NKI_##DERIVED,\n#include \"clang/AST/StmtNodes.inc\"\n    NKI_Type,\n#define TYPE(DERIVED, BASE) NKI_##DERIVED##Type,\n#include \"clang/AST/TypeNodes.inc\"\n    NKI_OMPClause,\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) NKI_##Class,\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n    NKI_NumberOfKinds\n  };\n\n  /// Use getFromNodeKind<T>() to construct the kind.\n  ASTNodeKind(NodeKindId KindId) : KindId(KindId) {}\n\n  /// Returns \\c true if \\c Base is a base kind of (or same as) \\c\n  ///   Derived.\n  /// \\param Distance If non-null, used to return the distance between \\c Base\n  /// and \\c Derived in the class hierarchy.\n  static bool isBaseOf(NodeKindId Base, NodeKindId Derived, unsigned *Distance);\n\n  /// Helper meta-function to convert a kind T to its enum value.\n  ///\n  /// This struct is specialized below for all known kinds.\n  template <class T> struct KindToKindId {\n    static const NodeKindId Id = NKI_None;\n  };\n  template <class T>\n  struct KindToKindId<const T> : KindToKindId<T> {};\n\n  /// Per kind info.\n  struct KindInfo {\n    /// The id of the parent kind, or None if it has no parent.\n    NodeKindId ParentId;\n    /// Name of the kind.\n    const char *Name;\n  };\n  static const KindInfo AllKindInfo[NKI_NumberOfKinds];\n\n  NodeKindId KindId;\n};\n\n#define KIND_TO_KIND_ID(Class)                                                 \\\n  template <> struct ASTNodeKind::KindToKindId<Class> {                        \\\n    static const NodeKindId Id = NKI_##Class;                                  \\\n  };\nKIND_TO_KIND_ID(CXXCtorInitializer)\nKIND_TO_KIND_ID(TemplateArgument)\nKIND_TO_KIND_ID(TemplateArgumentLoc)\nKIND_TO_KIND_ID(TemplateName)\nKIND_TO_KIND_ID(NestedNameSpecifier)\nKIND_TO_KIND_ID(NestedNameSpecifierLoc)\nKIND_TO_KIND_ID(QualType)\nKIND_TO_KIND_ID(TypeLoc)\nKIND_TO_KIND_ID(Decl)\nKIND_TO_KIND_ID(Stmt)\nKIND_TO_KIND_ID(Type)\nKIND_TO_KIND_ID(OMPClause)\nKIND_TO_KIND_ID(CXXBaseSpecifier)\n#define DECL(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Decl)\n#include \"clang/AST/DeclNodes.inc\"\n#define STMT(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED)\n#include \"clang/AST/StmtNodes.inc\"\n#define TYPE(DERIVED, BASE) KIND_TO_KIND_ID(DERIVED##Type)\n#include \"clang/AST/TypeNodes.inc\"\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) KIND_TO_KIND_ID(Class)\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n#undef KIND_TO_KIND_ID\n\ninline raw_ostream &operator<<(raw_ostream &OS, ASTNodeKind K) {\n  OS << K.asStringRef();\n  return OS;\n}\n\n/// A dynamically typed AST node container.\n///\n/// Stores an AST node in a type safe way. This allows writing code that\n/// works with different kinds of AST nodes, despite the fact that they don't\n/// have a common base class.\n///\n/// Use \\c create(Node) to create a \\c DynTypedNode from an AST node,\n/// and \\c get<T>() to retrieve the node as type T if the types match.\n///\n/// See \\c ASTNodeKind for which node base types are currently supported;\n/// You can create DynTypedNodes for all nodes in the inheritance hierarchy of\n/// the supported base types.\nclass DynTypedNode {\npublic:\n  /// Creates a \\c DynTypedNode from \\c Node.\n  template <typename T>\n  static DynTypedNode create(const T &Node) {\n    return BaseConverter<T>::create(Node);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Returns NULL if the stored node does not have a type that is\n  /// convertible to \\c T.\n  ///\n  /// For types that have identity via their pointer in the AST\n  /// (like \\c Stmt, \\c Decl, \\c Type and \\c NestedNameSpecifier) the returned\n  /// pointer points to the referenced AST node.\n  /// For other types (like \\c QualType) the value is stored directly\n  /// in the \\c DynTypedNode, and the returned pointer points at\n  /// the storage inside DynTypedNode. For those nodes, do not\n  /// use the pointer outside the scope of the DynTypedNode.\n  template <typename T> const T *get() const {\n    return BaseConverter<T>::get(NodeKind, &Storage);\n  }\n\n  /// Retrieve the stored node as type \\c T.\n  ///\n  /// Similar to \\c get(), but asserts that the type is what we are expecting.\n  template <typename T>\n  const T &getUnchecked() const {\n    return BaseConverter<T>::getUnchecked(NodeKind, &Storage);\n  }\n\n  ASTNodeKind getNodeKind() const { return NodeKind; }\n\n  /// Returns a pointer that identifies the stored AST node.\n  ///\n  /// Note that this is not supported by all AST nodes. For AST nodes\n  /// that don't have a pointer-defined identity inside the AST, this\n  /// method returns NULL.\n  const void *getMemoizationData() const {\n    return NodeKind.hasPointerIdentity()\n               ? *reinterpret_cast<void *const *>(&Storage)\n               : nullptr;\n  }\n\n  /// Prints the node to the given output stream.\n  void print(llvm::raw_ostream &OS, const PrintingPolicy &PP) const;\n\n  /// Dumps the node to the given output stream.\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  /// For nodes which represent textual entities in the source code,\n  /// return their SourceRange.  For all other nodes, return SourceRange().\n  SourceRange getSourceRange() const;\n\n  /// @{\n  /// Imposes an order on \\c DynTypedNode.\n  ///\n  /// Supports comparison of nodes that support memoization.\n  /// FIXME: Implement comparison for other node types (currently\n  /// only Stmt, Decl, Type and NestedNameSpecifier return memoization data).\n  bool operator<(const DynTypedNode &Other) const {\n    if (!NodeKind.isSame(Other.NodeKind))\n      return NodeKind < Other.NodeKind;\n\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>().getAsOpaquePtr() <\n             Other.getUnchecked<QualType>().getAsOpaquePtr();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(NodeKind)) {\n      auto TLA = getUnchecked<TypeLoc>();\n      auto TLB = Other.getUnchecked<TypeLoc>();\n      return std::make_pair(TLA.getType().getAsOpaquePtr(),\n                            TLA.getOpaqueData()) <\n             std::make_pair(TLB.getType().getAsOpaquePtr(),\n                            TLB.getOpaqueData());\n    }\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n            NodeKind)) {\n      auto NNSLA = getUnchecked<NestedNameSpecifierLoc>();\n      auto NNSLB = Other.getUnchecked<NestedNameSpecifierLoc>();\n      return std::make_pair(NNSLA.getNestedNameSpecifier(),\n                            NNSLA.getOpaqueData()) <\n             std::make_pair(NNSLB.getNestedNameSpecifier(),\n                            NNSLB.getOpaqueData());\n    }\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() < Other.getMemoizationData();\n  }\n  bool operator==(const DynTypedNode &Other) const {\n    // DynTypedNode::create() stores the exact kind of the node in NodeKind.\n    // If they contain the same node, their NodeKind must be the same.\n    if (!NodeKind.isSame(Other.NodeKind))\n      return false;\n\n    // FIXME: Implement for other types.\n    if (ASTNodeKind::getFromNodeKind<QualType>().isSame(NodeKind))\n      return getUnchecked<QualType>() == Other.getUnchecked<QualType>();\n\n    if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(NodeKind))\n      return getUnchecked<TypeLoc>() == Other.getUnchecked<TypeLoc>();\n\n    if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(NodeKind))\n      return getUnchecked<NestedNameSpecifierLoc>() ==\n             Other.getUnchecked<NestedNameSpecifierLoc>();\n\n    assert(getMemoizationData() && Other.getMemoizationData());\n    return getMemoizationData() == Other.getMemoizationData();\n  }\n  bool operator!=(const DynTypedNode &Other) const {\n    return !operator==(Other);\n  }\n  /// @}\n\n  /// Hooks for using DynTypedNode as a key in a DenseMap.\n  struct DenseMapInfo {\n    static inline DynTypedNode getEmptyKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      return Node;\n    }\n    static inline DynTypedNode getTombstoneKey() {\n      DynTypedNode Node;\n      Node.NodeKind = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return Node;\n    }\n    static unsigned getHashValue(const DynTypedNode &Val) {\n      // FIXME: Add hashing support for the remaining types.\n      if (ASTNodeKind::getFromNodeKind<TypeLoc>().isSame(Val.NodeKind)) {\n        auto TL = Val.getUnchecked<TypeLoc>();\n        return llvm::hash_combine(TL.getType().getAsOpaquePtr(),\n                                  TL.getOpaqueData());\n      }\n\n      if (ASTNodeKind::getFromNodeKind<NestedNameSpecifierLoc>().isSame(\n              Val.NodeKind)) {\n        auto NNSL = Val.getUnchecked<NestedNameSpecifierLoc>();\n        return llvm::hash_combine(NNSL.getNestedNameSpecifier(),\n                                  NNSL.getOpaqueData());\n      }\n\n      assert(Val.getMemoizationData());\n      return llvm::hash_value(Val.getMemoizationData());\n    }\n    static bool isEqual(const DynTypedNode &LHS, const DynTypedNode &RHS) {\n      auto Empty = ASTNodeKind::DenseMapInfo::getEmptyKey();\n      auto TombStone = ASTNodeKind::DenseMapInfo::getTombstoneKey();\n      return (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, Empty) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, Empty)) ||\n             (ASTNodeKind::DenseMapInfo::isEqual(LHS.NodeKind, TombStone) &&\n              ASTNodeKind::DenseMapInfo::isEqual(RHS.NodeKind, TombStone)) ||\n             LHS == RHS;\n    }\n  };\n\nprivate:\n  /// Takes care of converting from and to \\c T.\n  template <typename T, typename EnablerT = void> struct BaseConverter;\n\n  /// Converter that uses dyn_cast<T> from a stored BaseT*.\n  template <typename T, typename BaseT> struct DynCastPtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isBaseOf(NodeKind));\n      return *cast<T>(static_cast<const BaseT *>(\n          *reinterpret_cast<const void *const *>(Storage)));\n    }\n    static DynTypedNode create(const BaseT &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNode(Node);\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T* (by pointer).\n  template <typename T> struct PtrConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return &getUnchecked(NodeKind, Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *static_cast<const T *>(\n          *reinterpret_cast<const void *const *>(Storage));\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) const void *(&Node);\n      return Result;\n    }\n  };\n\n  /// Converter that stores T (by value).\n  template <typename T> struct ValueConverter {\n    static const T *get(ASTNodeKind NodeKind, const void *Storage) {\n      if (ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind))\n        return reinterpret_cast<const T *>(Storage);\n      return nullptr;\n    }\n    static const T &getUnchecked(ASTNodeKind NodeKind, const void *Storage) {\n      assert(ASTNodeKind::getFromNodeKind<T>().isSame(NodeKind));\n      return *reinterpret_cast<const T *>(Storage);\n    }\n    static DynTypedNode create(const T &Node) {\n      DynTypedNode Result;\n      Result.NodeKind = ASTNodeKind::getFromNodeKind<T>();\n      new (&Result.Storage) T(Node);\n      return Result;\n    }\n  };\n\n  ASTNodeKind NodeKind;\n\n  /// Stores the data of the node.\n  ///\n  /// Note that we can store \\c Decls, \\c Stmts, \\c Types,\n  /// \\c NestedNameSpecifiers and \\c CXXCtorInitializer by pointer as they are\n  /// guaranteed to be unique pointers pointing to dedicated storage in the AST.\n  /// \\c QualTypes, \\c NestedNameSpecifierLocs, \\c TypeLocs,\n  /// \\c TemplateArguments and \\c TemplateArgumentLocs on the other hand do not\n  /// have storage or unique pointers and thus need to be stored by value.\n  llvm::AlignedCharArrayUnion<const void *, TemplateArgument,\n                              TemplateArgumentLoc, NestedNameSpecifierLoc,\n                              QualType, TypeLoc>\n      Storage;\n};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Decl, T>::value>>\n    : public DynCastPtrConverter<T, Decl> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Stmt, T>::value>>\n    : public DynCastPtrConverter<T, Stmt> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<Type, T>::value>>\n    : public DynCastPtrConverter<T, Type> {};\n\ntemplate <typename T>\nstruct DynTypedNode::BaseConverter<\n    T, std::enable_if_t<std::is_base_of<OMPClause, T>::value>>\n    : public DynCastPtrConverter<T, OMPClause> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    NestedNameSpecifier, void> : public PtrConverter<NestedNameSpecifier> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    CXXCtorInitializer, void> : public PtrConverter<CXXCtorInitializer> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TemplateArgument, void> : public ValueConverter<TemplateArgument> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<TemplateArgumentLoc, void>\n    : public ValueConverter<TemplateArgumentLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TemplateName, void> : public ValueConverter<TemplateName> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    NestedNameSpecifierLoc,\n    void> : public ValueConverter<NestedNameSpecifierLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<QualType,\n                                   void> : public ValueConverter<QualType> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<\n    TypeLoc, void> : public ValueConverter<TypeLoc> {};\n\ntemplate <>\nstruct DynTypedNode::BaseConverter<CXXBaseSpecifier, void>\n    : public PtrConverter<CXXBaseSpecifier> {};\n\n// The only operation we allow on unsupported types is \\c get.\n// This allows to conveniently use \\c DynTypedNode when having an arbitrary\n// AST node that is not supported, but prevents misuse - a user cannot create\n// a DynTypedNode from arbitrary types.\ntemplate <typename T, typename EnablerT> struct DynTypedNode::BaseConverter {\n  static const T *get(ASTNodeKind NodeKind, const char Storage[]) {\n    return NULL;\n  }\n};\n\n} // end namespace clang\n\nnamespace llvm {\n\ntemplate <>\nstruct DenseMapInfo<clang::ASTNodeKind> : clang::ASTNodeKind::DenseMapInfo {};\n\ntemplate <>\nstruct DenseMapInfo<clang::DynTypedNode> : clang::DynTypedNode::DenseMapInfo {};\n\n}  // end namespace llvm\n\n#endif\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "content": "//===- PathDiagnostic.h - Path-Specific Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PathDiagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <deque>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass BinaryOperator;\nclass CallEnter;\nclass CallExitEnd;\nclass CallExpr;\nclass ConditionalOperator;\nclass Decl;\nclass Expr;\nclass LocationContext;\nclass MemberExpr;\nclass ProgramPoint;\nclass SourceManager;\n\nnamespace ento {\n\n//===----------------------------------------------------------------------===//\n// High-level interface for handlers of path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnostic;\n\n/// These options tweak the behavior of path diangostic consumers.\n/// Most of these options are currently supported by very few consumers.\nstruct PathDiagnosticConsumerOptions {\n  /// Run-line of the tool that produced the diagnostic.\n  /// It can be included with the diagnostic for debugging purposes.\n  std::string ToolInvocation;\n\n  /// Whether to include additional information about macro expansions\n  /// with the diagnostics, because otherwise they can be hard to obtain\n  /// without re-compiling the program under analysis.\n  bool ShouldDisplayMacroExpansions = false;\n\n  /// Whether to include LLVM statistics of the process in the diagnostic.\n  /// Useful for profiling the tool on large real-world codebases.\n  bool ShouldSerializeStats = false;\n\n  /// If the consumer intends to produce multiple output files, should it\n  /// use randomly generated file names for these files (with the tiny risk of\n  /// having random collisions) or deterministic human-readable file names\n  /// (with a larger risk of deterministic collisions or invalid characters\n  /// in the file name). We should not really give this choice to the users\n  /// because deterministic mode is always superior when done right, but\n  /// for some consumers this mode is experimental and needs to be\n  /// off by default.\n  bool ShouldWriteStableReportFilename = false;\n\n  /// Whether the consumer should treat consumed diagnostics as hard errors.\n  /// Useful for breaking your build when issues are found.\n  bool ShouldDisplayWarningsAsErrors = false;\n\n  /// Whether the consumer should attempt to rewrite the source file\n  /// with fix-it hints attached to the diagnostics it consumes.\n  bool ShouldApplyFixIts = false;\n\n  /// Whether the consumer should present the name of the entity that emitted\n  /// the diagnostic (eg., a checker) so that the user knew how to disable it.\n  bool ShouldDisplayDiagnosticName = false;\n};\n\nclass PathDiagnosticConsumer {\npublic:\n  class PDFileEntry : public llvm::FoldingSetNode {\n  public:\n    PDFileEntry(llvm::FoldingSetNodeID &NodeID) : NodeID(NodeID) {}\n\n    using ConsumerFiles = std::vector<std::pair<StringRef, StringRef>>;\n\n    /// A vector of <consumer,file> pairs.\n    ConsumerFiles files;\n\n    /// A precomputed hash tag used for uniquing PDFileEntry objects.\n    const llvm::FoldingSetNodeID NodeID;\n\n    /// Used for profiling in the FoldingSet.\n    void Profile(llvm::FoldingSetNodeID &ID) { ID = NodeID; }\n  };\n\n  class FilesMade {\n    llvm::BumpPtrAllocator Alloc;\n    llvm::FoldingSet<PDFileEntry> Set;\n\n  public:\n    ~FilesMade();\n\n    bool empty() const { return Set.empty(); }\n\n    void addDiagnostic(const PathDiagnostic &PD,\n                       StringRef ConsumerName,\n                       StringRef fileName);\n\n    PDFileEntry::ConsumerFiles *getFiles(const PathDiagnostic &PD);\n  };\n\nprivate:\n  virtual void anchor();\n\npublic:\n  PathDiagnosticConsumer() = default;\n  virtual ~PathDiagnosticConsumer();\n\n  void FlushDiagnostics(FilesMade *FilesMade);\n\n  virtual void FlushDiagnosticsImpl(std::vector<const PathDiagnostic *> &Diags,\n                                    FilesMade *filesMade) = 0;\n\n  virtual StringRef getName() const = 0;\n\n  void HandlePathDiagnostic(std::unique_ptr<PathDiagnostic> D);\n\n  enum PathGenerationScheme {\n    /// Only runs visitors, no output generated.\n    None,\n\n    /// Used for HTML, SARIF, and text output.\n    Minimal,\n\n    /// Used for plist output, used for \"arrows\" generation.\n    Extensive,\n  };\n\n  virtual PathGenerationScheme getGenerationScheme() const { return Minimal; }\n\n  bool shouldGenerateDiagnostics() const {\n    return getGenerationScheme() != None;\n  }\n\n  bool shouldAddPathEdges() const { return getGenerationScheme() == Extensive; }\n\n  virtual bool supportsLogicalOpControlFlow() const { return false; }\n\n  /// Return true if the PathDiagnosticConsumer supports individual\n  /// PathDiagnostics that span multiple files.\n  virtual bool supportsCrossFileDiagnostics() const { return false; }\n\nprotected:\n  bool flushed = false;\n  llvm::FoldingSet<PathDiagnostic> Diags;\n};\n\n//===----------------------------------------------------------------------===//\n// Path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticRange : public SourceRange {\npublic:\n  bool isPoint = false;\n\n  PathDiagnosticRange(SourceRange R, bool isP = false)\n      : SourceRange(R), isPoint(isP) {}\n  PathDiagnosticRange() = default;\n};\n\nusing LocationOrAnalysisDeclContext =\n    llvm::PointerUnion<const LocationContext *, AnalysisDeclContext *>;\n\nclass PathDiagnosticLocation {\nprivate:\n  enum Kind { RangeK, SingleLocK, StmtK, DeclK } K = SingleLocK;\n\n  const Stmt *S = nullptr;\n  const Decl *D = nullptr;\n  const SourceManager *SM = nullptr;\n  FullSourceLoc Loc;\n  PathDiagnosticRange Range;\n\n  PathDiagnosticLocation(SourceLocation L, const SourceManager &sm, Kind kind)\n      : K(kind), SM(&sm), Loc(genLocation(L)), Range(genRange()) {}\n\n  FullSourceLoc genLocation(\n      SourceLocation L = SourceLocation(),\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\n  PathDiagnosticRange genRange(\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\npublic:\n  /// Create an invalid location.\n  PathDiagnosticLocation() = default;\n\n  /// Create a location corresponding to the given statement.\n  PathDiagnosticLocation(const Stmt *s, const SourceManager &sm,\n                         LocationOrAnalysisDeclContext lac)\n      : K(s->getBeginLoc().isValid() ? StmtK : SingleLocK),\n        S(K == StmtK ? s : nullptr), SM(&sm),\n        Loc(genLocation(SourceLocation(), lac)), Range(genRange(lac)) {\n    assert(K == SingleLocK || S);\n    assert(K == SingleLocK || Loc.isValid());\n    assert(K == SingleLocK || Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  PathDiagnosticLocation(const Decl *d, const SourceManager &sm)\n      : K(DeclK), D(d), SM(&sm), Loc(genLocation()), Range(genRange()) {\n    assert(D);\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location at an explicit offset in the source.\n  ///\n  /// This should only be used if there are no more appropriate constructors.\n  PathDiagnosticLocation(SourceLocation loc, const SourceManager &sm)\n      : SM(&sm), Loc(loc, sm), Range(genRange()) {\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  static PathDiagnosticLocation create(const Decl *D,\n                                       const SourceManager &SM) {\n    return PathDiagnosticLocation(D, SM);\n  }\n\n  /// Create a location for the beginning of the declaration.\n  static PathDiagnosticLocation createBegin(const Decl *D,\n                                            const SourceManager &SM);\n\n  /// Create a location for the beginning of the declaration.\n  /// The third argument is ignored, useful for generic treatment\n  /// of statements and declarations.\n  static PathDiagnosticLocation\n  createBegin(const Decl *D, const SourceManager &SM,\n              const LocationOrAnalysisDeclContext LAC) {\n    return createBegin(D, SM);\n  }\n\n  /// Create a location for the beginning of the statement.\n  static PathDiagnosticLocation createBegin(const Stmt *S,\n                                            const SourceManager &SM,\n                                            const LocationOrAnalysisDeclContext LAC);\n\n  /// Create a location for the end of the statement.\n  ///\n  /// If the statement is a CompoundStatement, the location will point to the\n  /// closing brace instead of following it.\n  static PathDiagnosticLocation createEnd(const Stmt *S,\n                                          const SourceManager &SM,\n                                       const LocationOrAnalysisDeclContext LAC);\n\n  /// Create the location for the operator of the binary expression.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createOperatorLoc(const BinaryOperator *BO,\n                                                  const SourceManager &SM);\n  static PathDiagnosticLocation createConditionalColonLoc(\n                                                  const ConditionalOperator *CO,\n                                                  const SourceManager &SM);\n\n  /// For member expressions, return the location of the '.' or '->'.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createMemberLoc(const MemberExpr *ME,\n                                                const SourceManager &SM);\n\n  /// Create a location for the beginning of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createBeginBrace(const CompoundStmt *CS,\n                                                 const SourceManager &SM);\n\n  /// Create a location for the end of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createEndBrace(const CompoundStmt *CS,\n                                               const SourceManager &SM);\n\n  /// Create a location for the beginning of the enclosing declaration body.\n  /// Defaults to the beginning of the first statement in the declaration body.\n  static PathDiagnosticLocation createDeclBegin(const LocationContext *LC,\n                                                const SourceManager &SM);\n\n  /// Constructs a location for the end of the enclosing declaration body.\n  /// Defaults to the end of brace.\n  static PathDiagnosticLocation createDeclEnd(const LocationContext *LC,\n                                                   const SourceManager &SM);\n\n  /// Create a location corresponding to the given valid ProgramPoint.\n  static PathDiagnosticLocation create(const ProgramPoint &P,\n                                       const SourceManager &SMng);\n\n  /// Convert the given location into a single kind location.\n  static PathDiagnosticLocation createSingleLocation(\n                                             const PathDiagnosticLocation &PDL);\n\n  /// Construct a source location that corresponds to either the beginning\n  /// or the end of the given statement, or a nearby valid source location\n  /// if the statement does not have a valid source location of its own.\n  static SourceLocation\n  getValidSourceLocation(const Stmt *S, LocationOrAnalysisDeclContext LAC,\n                         bool UseEndOfStatement = false);\n\n  bool operator==(const PathDiagnosticLocation &X) const {\n    return K == X.K && Loc == X.Loc && Range == X.Range;\n  }\n\n  bool operator!=(const PathDiagnosticLocation &X) const {\n    return !(*this == X);\n  }\n\n  bool isValid() const {\n    return SM != nullptr;\n  }\n\n  FullSourceLoc asLocation() const {\n    return Loc;\n  }\n\n  PathDiagnosticRange asRange() const {\n    return Range;\n  }\n\n  const Stmt *asStmt() const { assert(isValid()); return S; }\n  const Stmt *getStmtOrNull() const {\n    if (!isValid())\n      return nullptr;\n    return asStmt();\n  }\n\n  const Decl *asDecl() const { assert(isValid()); return D; }\n\n  bool hasRange() const { return K == StmtK || K == RangeK || K == DeclK; }\n\n  bool hasValidLocation() const { return asLocation().isValid(); }\n\n  void invalidate() {\n    *this = PathDiagnosticLocation();\n  }\n\n  void flatten();\n\n  const SourceManager& getManager() const { assert(isValid()); return *SM; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void dump() const;\n};\n\nclass PathDiagnosticLocationPair {\nprivate:\n  PathDiagnosticLocation Start, End;\n\npublic:\n  PathDiagnosticLocationPair(const PathDiagnosticLocation &start,\n                             const PathDiagnosticLocation &end)\n      : Start(start), End(end) {}\n\n  const PathDiagnosticLocation &getStart() const { return Start; }\n  const PathDiagnosticLocation &getEnd() const { return End; }\n\n  void setStart(const PathDiagnosticLocation &L) { Start = L; }\n  void setEnd(const PathDiagnosticLocation &L) { End = L; }\n\n  void flatten() {\n    Start.flatten();\n    End.flatten();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Start.Profile(ID);\n    End.Profile(ID);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Path \"pieces\" for path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticPiece: public llvm::FoldingSetNode {\npublic:\n  enum Kind { ControlFlow, Event, Macro, Call, Note, PopUp };\n  enum DisplayHint { Above, Below };\n\nprivate:\n  const std::string str;\n  const Kind kind;\n  const DisplayHint Hint;\n\n  /// In the containing bug report, this piece is the last piece from\n  /// the main source file.\n  bool LastInMainSourceFile = false;\n\n  /// A constant string that can be used to tag the PathDiagnosticPiece,\n  /// typically with the identification of the creator.  The actual pointer\n  /// value is meant to be an identifier; the string itself is useful for\n  /// debugging.\n  StringRef Tag;\n\n  std::vector<SourceRange> ranges;\n  std::vector<FixItHint> fixits;\n\nprotected:\n  PathDiagnosticPiece(StringRef s, Kind k, DisplayHint hint = Below);\n  PathDiagnosticPiece(Kind k, DisplayHint hint = Below);\n\npublic:\n  PathDiagnosticPiece() = delete;\n  PathDiagnosticPiece(const PathDiagnosticPiece &) = delete;\n  PathDiagnosticPiece &operator=(const PathDiagnosticPiece &) = delete;\n  virtual ~PathDiagnosticPiece();\n\n  StringRef getString() const { return str; }\n\n  /// Tag this PathDiagnosticPiece with the given C-string.\n  void setTag(const char *tag) { Tag = tag; }\n\n  /// Return the opaque tag (if any) on the PathDiagnosticPiece.\n  const void *getTag() const { return Tag.data(); }\n\n  /// Return the string representation of the tag.  This is useful\n  /// for debugging.\n  StringRef getTagStr() const { return Tag; }\n\n  /// getDisplayHint - Return a hint indicating where the diagnostic should\n  ///  be displayed by the PathDiagnosticConsumer.\n  DisplayHint getDisplayHint() const { return Hint; }\n\n  virtual PathDiagnosticLocation getLocation() const = 0;\n  virtual void flattenLocations() = 0;\n\n  Kind getKind() const { return kind; }\n\n  void addRange(SourceRange R) {\n    if (!R.isValid())\n      return;\n    ranges.push_back(R);\n  }\n\n  void addRange(SourceLocation B, SourceLocation E) {\n    if (!B.isValid() || !E.isValid())\n      return;\n    ranges.push_back(SourceRange(B,E));\n  }\n\n  void addFixit(FixItHint F) {\n    fixits.push_back(F);\n  }\n\n  /// Return the SourceRanges associated with this PathDiagnosticPiece.\n  ArrayRef<SourceRange> getRanges() const { return ranges; }\n\n  /// Return the fix-it hints associated with this PathDiagnosticPiece.\n  ArrayRef<FixItHint> getFixits() const { return fixits; }\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void setAsLastInMainSourceFile() {\n    LastInMainSourceFile = true;\n  }\n\n  bool isLastInMainSourceFile() const {\n    return LastInMainSourceFile;\n  }\n\n  virtual void dump() const = 0;\n};\n\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\nclass PathPieces : public std::list<PathDiagnosticPieceRef> {\n  void flattenTo(PathPieces &Primary, PathPieces &Current,\n                 bool ShouldFlattenMacros) const;\n\npublic:\n  PathPieces flatten(bool ShouldFlattenMacros) const {\n    PathPieces Result;\n    flattenTo(Result, Result, ShouldFlattenMacros);\n    return Result;\n  }\n\n  void dump() const;\n};\n\nclass PathDiagnosticSpotPiece : public PathDiagnosticPiece {\nprivate:\n  PathDiagnosticLocation Pos;\n\npublic:\n  PathDiagnosticSpotPiece(const PathDiagnosticLocation &pos,\n                          StringRef s,\n                          PathDiagnosticPiece::Kind k,\n                          bool addPosRange = true)\n      : PathDiagnosticPiece(s, k), Pos(pos) {\n    assert(Pos.isValid() && Pos.hasValidLocation() &&\n           \"PathDiagnosticSpotPiece's must have a valid location.\");\n    if (addPosRange && Pos.hasRange()) addRange(Pos.asRange());\n  }\n\n  PathDiagnosticLocation getLocation() const override { return Pos; }\n  void flattenLocations() override { Pos.flatten(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event || P->getKind() == Macro ||\n           P->getKind() == Note || P->getKind() == PopUp;\n  }\n};\n\nclass PathDiagnosticEventPiece : public PathDiagnosticSpotPiece {\n  Optional<bool> IsPrunable;\n\npublic:\n  PathDiagnosticEventPiece(const PathDiagnosticLocation &pos,\n                           StringRef s, bool addPosRange = true)\n      : PathDiagnosticSpotPiece(pos, s, Event, addPosRange) {}\n  ~PathDiagnosticEventPiece() override;\n\n  /// Mark the diagnostic piece as being potentially prunable.  This\n  /// flag may have been previously set, at which point it will not\n  /// be reset unless one specifies to do so.\n  void setPrunable(bool isPrunable, bool override = false) {\n    if (IsPrunable.hasValue() && !override)\n     return;\n    IsPrunable = isPrunable;\n  }\n\n  /// Return true if the diagnostic piece is prunable.\n  bool isPrunable() const {\n    return IsPrunable.hasValue() ? IsPrunable.getValue() : false;\n  }\n\n  void dump() const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event;\n  }\n};\n\nclass PathDiagnosticCallPiece : public PathDiagnosticPiece {\n  const Decl *Caller;\n  const Decl *Callee = nullptr;\n\n  // Flag signifying that this diagnostic has only call enter and no matching\n  // call exit.\n  bool NoExit;\n\n  // Flag signifying that the callee function is an Objective-C autosynthesized\n  // property getter or setter.\n  bool IsCalleeAnAutosynthesizedPropertyAccessor = false;\n\n  // The custom string, which should appear after the call Return Diagnostic.\n  // TODO: Should we allow multiple diagnostics?\n  std::string CallStackMessage;\n\n  PathDiagnosticCallPiece(const Decl *callerD,\n                          const PathDiagnosticLocation &callReturnPos)\n      : PathDiagnosticPiece(Call), Caller(callerD), NoExit(false),\n        callReturn(callReturnPos) {}\n  PathDiagnosticCallPiece(PathPieces &oldPath, const Decl *caller)\n      : PathDiagnosticPiece(Call), Caller(caller), NoExit(true),\n        path(oldPath) {}\n\npublic:\n  PathDiagnosticLocation callEnter;\n  PathDiagnosticLocation callEnterWithin;\n  PathDiagnosticLocation callReturn;\n  PathPieces path;\n\n  ~PathDiagnosticCallPiece() override;\n\n  const Decl *getCaller() const { return Caller; }\n\n  const Decl *getCallee() const { return Callee; }\n  void setCallee(const CallEnter &CE, const SourceManager &SM);\n\n  bool hasCallStackMessage() { return !CallStackMessage.empty(); }\n  void setCallStackMessage(StringRef st) { CallStackMessage = std::string(st); }\n\n  PathDiagnosticLocation getLocation() const override { return callEnter; }\n\n  std::shared_ptr<PathDiagnosticEventPiece> getCallEnterEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece>\n  getCallEnterWithinCallerEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece> getCallExitEvent() const;\n\n  void flattenLocations() override {\n    callEnter.flatten();\n    callReturn.flatten();\n    for (const auto &I : path)\n      I->flattenLocations();\n  }\n\n  static std::shared_ptr<PathDiagnosticCallPiece>\n  construct(const CallExitEnd &CE,\n            const SourceManager &SM);\n\n  static PathDiagnosticCallPiece *construct(PathPieces &pieces,\n                                            const Decl *caller);\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Call;\n  }\n};\n\nclass PathDiagnosticControlFlowPiece : public PathDiagnosticPiece {\n  std::vector<PathDiagnosticLocationPair> LPairs;\n\npublic:\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos,\n                                 StringRef s)\n      : PathDiagnosticPiece(s, ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos)\n      : PathDiagnosticPiece(ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  ~PathDiagnosticControlFlowPiece() override;\n\n  PathDiagnosticLocation getStartLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getStart();\n  }\n\n  PathDiagnosticLocation getEndLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getEnd();\n  }\n\n  void setStartLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setStart(L);\n  }\n\n  void setEndLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setEnd(L);\n  }\n\n  void push_back(const PathDiagnosticLocationPair &X) { LPairs.push_back(X); }\n\n  PathDiagnosticLocation getLocation() const override {\n    return getStartLocation();\n  }\n\n  using iterator = std::vector<PathDiagnosticLocationPair>::iterator;\n\n  iterator begin() { return LPairs.begin(); }\n  iterator end() { return LPairs.end(); }\n\n  void flattenLocations() override {\n    for (auto &I : *this)\n      I.flatten();\n  }\n\n  using const_iterator =\n      std::vector<PathDiagnosticLocationPair>::const_iterator;\n\n  const_iterator begin() const { return LPairs.begin(); }\n  const_iterator end() const { return LPairs.end(); }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == ControlFlow;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticMacroPiece : public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticMacroPiece(const PathDiagnosticLocation &pos)\n      : PathDiagnosticSpotPiece(pos, \"\", Macro) {}\n  ~PathDiagnosticMacroPiece() override;\n\n  PathPieces subPieces;\n\n  void flattenLocations() override {\n    PathDiagnosticSpotPiece::flattenLocations();\n    for (const auto &I : subPieces)\n      I->flattenLocations();\n  }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Macro;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticNotePiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticNotePiece(const PathDiagnosticLocation &Pos, StringRef S,\n                          bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, Note, AddPosRange) {}\n  ~PathDiagnosticNotePiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Note;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticPopUpPiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticPopUpPiece(const PathDiagnosticLocation &Pos, StringRef S,\n                           bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, PopUp, AddPosRange) {}\n  ~PathDiagnosticPopUpPiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == PopUp;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\n/// File IDs mapped to sets of line numbers.\nusing FilesToLineNumsMap = std::map<FileID, std::set<unsigned>>;\n\n/// PathDiagnostic - PathDiagnostic objects represent a single path-sensitive\n///  diagnostic.  It represents an ordered-collection of PathDiagnosticPieces,\n///  each which represent the pieces of the path.\nclass PathDiagnostic : public llvm::FoldingSetNode {\n  std::string CheckerName;\n  const Decl *DeclWithIssue;\n  std::string BugType;\n  std::string VerboseDesc;\n  std::string ShortDesc;\n  std::string Category;\n  std::deque<std::string> OtherDesc;\n\n  /// Loc The location of the path diagnostic report.\n  PathDiagnosticLocation Loc;\n\n  PathPieces pathImpl;\n  SmallVector<PathPieces *, 3> pathStack;\n\n  /// Important bug uniqueing location.\n  /// The location info is useful to differentiate between bugs.\n  PathDiagnosticLocation UniqueingLoc;\n  const Decl *UniqueingDecl;\n\n  /// Lines executed in the path.\n  std::unique_ptr<FilesToLineNumsMap> ExecutedLines;\n\npublic:\n  PathDiagnostic() = delete;\n  PathDiagnostic(StringRef CheckerName, const Decl *DeclWithIssue,\n                 StringRef bugtype, StringRef verboseDesc, StringRef shortDesc,\n                 StringRef category, PathDiagnosticLocation LocationToUnique,\n                 const Decl *DeclToUnique,\n                 std::unique_ptr<FilesToLineNumsMap> ExecutedLines);\n  ~PathDiagnostic();\n\n  const PathPieces &path;\n\n  /// Return the path currently used by builders for constructing the\n  /// PathDiagnostic.\n  PathPieces &getActivePath() {\n    if (pathStack.empty())\n      return pathImpl;\n    return *pathStack.back();\n  }\n\n  /// Return a mutable version of 'path'.\n  PathPieces &getMutablePieces() {\n    return pathImpl;\n  }\n\n  /// Return the unrolled size of the path.\n  unsigned full_size();\n\n  void pushActivePath(PathPieces *p) { pathStack.push_back(p); }\n  void popActivePath() { if (!pathStack.empty()) pathStack.pop_back(); }\n\n  bool isWithinCall() const { return !pathStack.empty(); }\n\n  void setEndOfPath(PathDiagnosticPieceRef EndPiece) {\n    assert(!Loc.isValid() && \"End location already set!\");\n    Loc = EndPiece->getLocation();\n    assert(Loc.isValid() && \"Invalid location for end-of-path piece\");\n    getActivePath().push_back(std::move(EndPiece));\n  }\n\n  void appendToDesc(StringRef S) {\n    if (!ShortDesc.empty())\n      ShortDesc += S;\n    VerboseDesc += S;\n  }\n\n  StringRef getVerboseDescription() const { return VerboseDesc; }\n\n  StringRef getShortDescription() const {\n    return ShortDesc.empty() ? VerboseDesc : ShortDesc;\n  }\n\n  StringRef getCheckerName() const { return CheckerName; }\n  StringRef getBugType() const { return BugType; }\n  StringRef getCategory() const { return Category; }\n\n  using meta_iterator = std::deque<std::string>::const_iterator;\n\n  meta_iterator meta_begin() const { return OtherDesc.begin(); }\n  meta_iterator meta_end() const { return OtherDesc.end(); }\n  void addMeta(StringRef s) { OtherDesc.push_back(std::string(s)); }\n\n  const FilesToLineNumsMap &getExecutedLines() const {\n    return *ExecutedLines;\n  }\n\n  FilesToLineNumsMap &getExecutedLines() {\n    return *ExecutedLines;\n  }\n\n  /// Return the semantic context where an issue occurred.  If the\n  /// issue occurs along a path, this represents the \"central\" area\n  /// where the bug manifests.\n  const Decl *getDeclWithIssue() const { return DeclWithIssue; }\n\n  void setDeclWithIssue(const Decl *D) {\n    DeclWithIssue = D;\n  }\n\n  PathDiagnosticLocation getLocation() const {\n    return Loc;\n  }\n\n  void setLocation(PathDiagnosticLocation NewLoc) {\n    Loc = NewLoc;\n  }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLoc() const {\n    return UniqueingLoc;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const {\n    return UniqueingDecl;\n  }\n\n  void flattenLocations() {\n    Loc.flatten();\n    for (const auto &I : pathImpl)\n      I->flattenLocations();\n  }\n\n  /// Profiles the diagnostic, independent of the path it references.\n  ///\n  /// This can be used to merge diagnostics that refer to the same issue\n  /// along different paths.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  /// Profiles the diagnostic, including its path.\n  ///\n  /// Two diagnostics with the same issue along different paths will generate\n  /// different profiles.\n  void FullProfile(llvm::FoldingSetNodeID &ID) const;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "content": "//===- clang/Basic/FileEntry.h - File references ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines interfaces for clang::FileEntry and clang::FileEntryRef.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_FILEENTRY_H\n#define LLVM_CLANG_BASIC_FILEENTRY_H\n\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nnamespace vfs {\n\nclass File;\n\n} // namespace vfs\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntryRef;\n\n} // namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Forward declare a template specialization for OptionalStorage.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef, /*is_trivially_copyable*/ true>;\n\n} // namespace optional_detail\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntry;\n\n/// A reference to a \\c FileEntry that includes the name of the file as it was\n/// accessed by the FileManager's client.\nclass FileEntryRef {\npublic:\n  StringRef getName() const { return ME->first(); }\n  const FileEntry &getFileEntry() const {\n    return *ME->second->V.get<FileEntry *>();\n  }\n  DirectoryEntryRef getDir() const { return *ME->second->Dir; }\n\n  inline bool isValid() const;\n  inline off_t getSize() const;\n  inline unsigned getUID() const;\n  inline const llvm::sys::fs::UniqueID &getUniqueID() const;\n  inline time_t getModificationTime() const;\n  inline bool isNamedPipe() const;\n  inline void closeFile() const;\n\n  /// Check if the underlying FileEntry is the same, intentially ignoring\n  /// whether the file was referenced with the same spelling of the filename.\n  friend bool operator==(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return &LHS.getFileEntry() == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return LHS == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return &LHS.getFileEntry() == RHS;\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Hash code is based on the FileEntry, not the specific named reference,\n  /// just like operator==.\n  friend llvm::hash_code hash_value(FileEntryRef Ref) {\n    return llvm::hash_value(&Ref.getFileEntry());\n  }\n\n  struct MapValue;\n\n  /// Type used in the StringMap.\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<MapValue>>;\n\n  /// Type stored in the StringMap.\n  struct MapValue {\n    /// The pointer at another MapEntry is used when the FileManager should\n    /// silently forward from one name to another, which occurs in Redirecting\n    /// VFSs that use external names. In that case, the \\c FileEntryRef\n    /// returned by the \\c FileManager will have the external name, and not the\n    /// name that was used to lookup the file.\n    ///\n    /// The second type is really a `const MapEntry *`, but that confuses\n    /// gcc5.3.  Once that's no longer supported, change this back.\n    llvm::PointerUnion<FileEntry *, const void *> V;\n\n    /// Directory the file was found in. Set if and only if V is a FileEntry.\n    Optional<DirectoryEntryRef> Dir;\n\n    MapValue() = delete;\n    MapValue(FileEntry &FE, DirectoryEntryRef Dir) : V(&FE), Dir(Dir) {}\n    MapValue(MapEntry &ME) : V(&ME) {}\n  };\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(const FileEntryRef &RHS) const { return ME == RHS.ME; }\n\n  /// Allow FileEntryRef to degrade into 'const FileEntry*' to facilitate\n  /// incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getFileEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this implicit conversion.\n  operator const FileEntry *() const { return &getFileEntry(); }\n\n  FileEntryRef() = delete;\n  explicit FileEntryRef(const MapEntry &ME) : ME(&ME) {\n    assert(ME.second && \"Expected payload\");\n    assert(ME.second->V && \"Expected non-null\");\n    assert(ME.second->V.is<FileEntry *>() && \"Expected FileEntry\");\n  }\n\n  /// Expose the underlying MapEntry to simplify packing in a PointerIntPair or\n  /// PointerUnion and allow construction in Optional.\n  const clang::FileEntryRef::MapEntry &getMapEntry() const { return *ME; }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<FileEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  FileEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<FileEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  FileEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  FileEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(FileEntryRef(dense_map_empty_tag())) ||\n           isSameRef(FileEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nstatic_assert(sizeof(FileEntryRef) == sizeof(const FileEntry *),\n              \"FileEntryRef must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<FileEntryRef>::value,\n              \"FileEntryRef must be trivially copyable\");\n\n} // end namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Customize OptionalStorage<FileEntryRef> to use FileEntryRef and its\n/// optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(in_place_t, ArgTypes &&...Args)\n      : StorageImpl(in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::FileEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(Optional<clang::FileEntryRef>) ==\n                  sizeof(clang::FileEntryRef),\n              \"Optional<FileEntryRef> must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<Optional<clang::FileEntryRef>>::value,\n              \"Optional<FileEntryRef> should be trivially copyable\");\n\n} // end namespace optional_detail\n\n/// Specialisation of DenseMapInfo for FileEntryRef.\ntemplate <> struct DenseMapInfo<clang::FileEntryRef> {\n  static inline clang::FileEntryRef getEmptyKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_empty_tag());\n  }\n\n  static inline clang::FileEntryRef getTombstoneKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_tombstone_tag());\n  }\n\n  static unsigned getHashValue(clang::FileEntryRef Val) {\n    return hash_value(Val);\n  }\n\n  static bool isEqual(clang::FileEntryRef LHS, clang::FileEntryRef RHS) {\n    // Catch the easy cases: both empty, both tombstone, or the same ref.\n    if (LHS.isSameRef(RHS))\n      return true;\n\n    // Confirm LHS and RHS are valid.\n    if (LHS.isSpecialDenseMapKey() || RHS.isSpecialDenseMapKey())\n      return false;\n\n    // It's safe to use operator==.\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace clang {\n\n/// Wrapper around Optional<FileEntryRef> that degrades to 'const FileEntry*',\n/// facilitating incremental patches to propagate FileEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an Optional<FileEntryRef> to degrade to a 'const FileEntry*'. The purpose\n/// is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// Optional<FileEntryRef> MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getFileEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n/// FileEntry::getName have been deleted, delete this class and replace\n/// instances with Optional<FileEntryRef>.\nclass OptionalFileEntryRefDegradesToFileEntryPtr\n    : public Optional<FileEntryRef> {\npublic:\n  OptionalFileEntryRefDegradesToFileEntryPtr() = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n\n  OptionalFileEntryRefDegradesToFileEntryPtr(llvm::NoneType) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(FileEntryRef Ref)\n      : Optional<FileEntryRef>(Ref) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(Optional<FileEntryRef> MaybeRef)\n      : Optional<FileEntryRef>(MaybeRef) {}\n\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(llvm::NoneType) {\n    Optional<FileEntryRef>::operator=(None);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(FileEntryRef Ref) {\n    Optional<FileEntryRef>::operator=(Ref);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(Optional<FileEntryRef> MaybeRef) {\n    Optional<FileEntryRef>::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const FileEntry *' to allow  FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this class and replace\n  /// instances with Optional<FileEntryRef>\n  operator const FileEntry *() const {\n    return hasValue() ? &getValue().getFileEntry() : nullptr;\n  }\n};\n\nstatic_assert(\n    std::is_trivially_copyable<\n        OptionalFileEntryRefDegradesToFileEntryPtr>::value,\n    \"OptionalFileEntryRefDegradesToFileEntryPtr should be trivially copyable\");\n\n/// Cached information about one file (either on disk\n/// or in the virtual file system).\n///\n/// If the 'File' member is valid, then this FileEntry has an open file\n/// descriptor for the file.\nclass FileEntry {\n  friend class FileManager;\n\n  std::string RealPathName;   // Real path to the file; could be empty.\n  off_t Size = 0;             // File size in bytes.\n  time_t ModTime = 0;         // Modification time of file.\n  const DirectoryEntry *Dir = nullptr; // Directory file lives in.\n  llvm::sys::fs::UniqueID UniqueID;\n  unsigned UID = 0; // A unique (small) ID for the file.\n  bool IsNamedPipe = false;\n  bool IsValid = false; // Is this \\c FileEntry initialized and valid?\n\n  /// The open file, if it is owned by the \\p FileEntry.\n  mutable std::unique_ptr<llvm::vfs::File> File;\n\n  /// The file content, if it is owned by the \\p FileEntry.\n  std::unique_ptr<llvm::MemoryBuffer> Content;\n\n  // First access name for this FileEntry.\n  //\n  // This is Optional only to allow delayed construction (FileEntryRef has no\n  // default constructor). It should always have a value in practice.\n  //\n  // TODO: remove this once everyone that needs a name uses FileEntryRef.\n  Optional<FileEntryRef> LastRef;\n\npublic:\n  FileEntry();\n  ~FileEntry();\n\n  FileEntry(const FileEntry &) = delete;\n  FileEntry &operator=(const FileEntry &) = delete;\n\n  StringRef getName() const { return LastRef->getName(); }\n  FileEntryRef getLastRef() const { return *LastRef; }\n\n  StringRef tryGetRealPathName() const { return RealPathName; }\n  bool isValid() const { return IsValid; }\n  off_t getSize() const { return Size; }\n  unsigned getUID() const { return UID; }\n  const llvm::sys::fs::UniqueID &getUniqueID() const { return UniqueID; }\n  time_t getModificationTime() const { return ModTime; }\n\n  /// Return the directory the file lives in.\n  const DirectoryEntry *getDir() const { return Dir; }\n\n  bool operator<(const FileEntry &RHS) const { return UniqueID < RHS.UniqueID; }\n\n  /// Check whether the file is a named pipe (and thus can't be opened by\n  /// the native FileManager methods).\n  bool isNamedPipe() const { return IsNamedPipe; }\n\n  void closeFile() const;\n};\n\nbool FileEntryRef::isValid() const { return getFileEntry().isValid(); }\n\noff_t FileEntryRef::getSize() const { return getFileEntry().getSize(); }\n\nunsigned FileEntryRef::getUID() const { return getFileEntry().getUID(); }\n\nconst llvm::sys::fs::UniqueID &FileEntryRef::getUniqueID() const {\n  return getFileEntry().getUniqueID();\n}\n\ntime_t FileEntryRef::getModificationTime() const {\n  return getFileEntry().getModificationTime();\n}\n\nbool FileEntryRef::isNamedPipe() const { return getFileEntry().isNamedPipe(); }\n\nvoid FileEntryRef::closeFile() const { getFileEntry().closeFile(); }\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_FILEENTRY_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "content": "//===--- Format.h - Format C++ code -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Various functions to configurably format source code.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FORMAT_FORMAT_H\n#define LLVM_CLANG_FORMAT_FORMAT_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Tooling/Core/Replacement.h\"\n#include \"clang/Tooling/Inclusions/IncludeStyle.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <system_error>\n\nnamespace llvm {\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\n\nclass Lexer;\nclass SourceManager;\nclass DiagnosticConsumer;\n\nnamespace format {\n\nenum class ParseError {\n  Success = 0,\n  Error,\n  Unsuitable,\n  BinPackTrailingCommaConflict\n};\nclass ParseErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int EV) const override;\n};\nconst std::error_category &getParseCategory();\nstd::error_code make_error_code(ParseError e);\n\n/// The ``FormatStyle`` is used to configure the formatting to follow\n/// specific guidelines.\nstruct FormatStyle {\n  // If the BasedOn: was InheritParentConfig and this style needs the file from\n  // the parent directories. It is not part of the actual style for formatting.\n  // Thus the // instead of ///.\n  bool InheritsParentConfig;\n\n  /// The extra indent or outdent of access modifiers, e.g. ``public:``.\n  int AccessModifierOffset;\n\n  /// Different styles for aligning after open brackets.\n  enum BracketAlignmentStyle : unsigned char {\n    /// Align parameters on the open bracket, e.g.:\n    /// \\code\n    ///   someLongFunction(argument1,\n    ///                    argument2);\n    /// \\endcode\n    BAS_Align,\n    /// Don't align, instead use ``ContinuationIndentWidth``, e.g.:\n    /// \\code\n    ///   someLongFunction(argument1,\n    ///       argument2);\n    /// \\endcode\n    BAS_DontAlign,\n    /// Always break after an open bracket, if the parameters don't fit\n    /// on a single line, e.g.:\n    /// \\code\n    ///   someLongFunction(\n    ///       argument1, argument2);\n    /// \\endcode\n    BAS_AlwaysBreak,\n  };\n\n  /// If ``true``, horizontally aligns arguments after an open bracket.\n  ///\n  /// This applies to round brackets (parentheses), angle brackets and square\n  /// brackets.\n  BracketAlignmentStyle AlignAfterOpenBracket;\n\n  /// Styles for alignment of consecutive tokens. Tokens can be assignment signs\n  /// (see\n  /// ``AlignConsecutiveAssignments``), bitfield member separators (see\n  /// ``AlignConsecutiveBitFields``), names in declarations (see\n  /// ``AlignConsecutiveDeclarations``) or macro definitions (see\n  /// ``AlignConsecutiveMacros``).\n  enum AlignConsecutiveStyle {\n    ACS_None,\n    ACS_Consecutive,\n    ACS_AcrossEmptyLines,\n    ACS_AcrossComments,\n    ACS_AcrossEmptyLinesAndComments\n  };\n\n  /// Style of aligning consecutive macro definitions.\n  ///\n  /// ``Consecutive`` will result in formattings like:\n  /// \\code\n  ///   #define SHORT_NAME       42\n  ///   #define LONGER_NAME      0x007f\n  ///   #define EVEN_LONGER_NAME (2)\n  ///   #define foo(x)           (x * x)\n  ///   #define bar(y, z)        (y + z)\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align macro definitions on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align macro definitions on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x) (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)           (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)    (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)           (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z)        (y + z)\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveMacros;\n\n  /// Style of aligning consecutive assignments.\n  ///\n  /// ``Consecutive`` will result in formattings like:\n  /// \\code\n  ///   int a            = 1;\n  ///   int somelongname = 2;\n  ///   double c         = 3;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align assignments on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align assignments on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d            = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d    = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d            = 3;\n  ///      /* A comment. */\n  ///      double e         = 4;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveAssignments;\n\n  /// Style of aligning consecutive bit field.\n  ///\n  /// ``Consecutive`` will align the bitfield separators of consecutive lines.\n  /// This will result in formattings like:\n  /// \\code\n  ///   int aaaa : 1;\n  ///   int b    : 12;\n  ///   int ccc  : 8;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align bit fields on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align bit fields on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d    : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d  : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d    : 2;\n  ///      /* A comment. */\n  ///      int ee   : 3;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveBitFields;\n\n  /// Style of aligning consecutive declarations.\n  ///\n  /// ``Consecutive`` will align the declaration names of consecutive lines.\n  /// This will result in formattings like:\n  /// \\code\n  ///   int         aaaa = 12;\n  ///   float       b = 23;\n  ///   std::string ccc;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align bit declarations on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align declarations on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int         a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int  a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int         a = 42;\n  ///      /* A comment. */\n  ///      bool        c = false;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveDeclarations;\n\n  /// Different styles for aligning escaped newlines.\n  enum EscapedNewlineAlignmentStyle : unsigned char {\n    /// Don't align escaped newlines.\n    /// \\code\n    ///   #define A \\\n    ///     int aaaa; \\\n    ///     int b; \\\n    ///     int dddddddddd;\n    /// \\endcode\n    ENAS_DontAlign,\n    /// Align escaped newlines as far left as possible.\n    /// \\code\n    ///   true:\n    ///   #define A   \\\n    ///     int aaaa; \\\n    ///     int b;    \\\n    ///     int dddddddddd;\n    ///\n    ///   false:\n    /// \\endcode\n    ENAS_Left,\n    /// Align escaped newlines in the right-most column.\n    /// \\code\n    ///   #define A                                                                      \\\n    ///     int aaaa;                                                                    \\\n    ///     int b;                                                                       \\\n    ///     int dddddddddd;\n    /// \\endcode\n    ENAS_Right,\n  };\n\n  /// Options for aligning backslashes in escaped newlines.\n  EscapedNewlineAlignmentStyle AlignEscapedNewlines;\n\n  /// Different styles for aligning operands.\n  enum OperandAlignmentStyle : unsigned char {\n    /// Do not align operands of binary and ternary expressions.\n    /// The wrapped lines are indented ``ContinuationIndentWidth`` spaces from\n    /// the start of the line.\n    OAS_DontAlign,\n    /// Horizontally align operands of binary and ternary expressions.\n    ///\n    /// Specifically, this aligns operands of a single expression that needs\n    /// to be split over multiple lines, e.g.:\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb +\n    ///             ccccccccccccccc;\n    /// \\endcode\n    ///\n    /// When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is\n    /// aligned with the operand on the first line.\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb\n    ///             + ccccccccccccccc;\n    /// \\endcode\n    OAS_Align,\n    /// Horizontally align operands of binary and ternary expressions.\n    ///\n    /// This is similar to ``AO_Align``, except when\n    /// ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so\n    /// that the wrapped operand is aligned with the operand on the first line.\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb\n    ///           + ccccccccccccccc;\n    /// \\endcode\n    OAS_AlignAfterOperator,\n  };\n\n  /// If ``true``, horizontally align operands of binary and ternary\n  /// expressions.\n  OperandAlignmentStyle AlignOperands;\n\n  /// If ``true``, aligns trailing comments.\n  /// \\code\n  ///   true:                                   false:\n  ///   int a;     // My comment a      vs.     int a; // My comment a\n  ///   int b = 2; // comment  b                int b = 2; // comment about b\n  /// \\endcode\n  bool AlignTrailingComments;\n\n  /// \\brief If a function call or braced initializer list doesn't fit on a\n  /// line, allow putting all arguments onto the next line, even if\n  /// ``BinPackArguments`` is ``false``.\n  /// \\code\n  ///   true:\n  ///   callFunction(\n  ///       a, b, c, d);\n  ///\n  ///   false:\n  ///   callFunction(a,\n  ///                b,\n  ///                c,\n  ///                d);\n  /// \\endcode\n  bool AllowAllArgumentsOnNextLine;\n\n  /// \\brief If a constructor definition with a member initializer list doesn't\n  /// fit on a single line, allow putting all member initializers onto the next\n  /// line, if ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is true.\n  /// Note that this parameter has no effect if\n  /// ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is false.\n  /// \\code\n  ///   true:\n  ///   MyClass::MyClass() :\n  ///       member0(0), member1(2) {}\n  ///\n  ///   false:\n  ///   MyClass::MyClass() :\n  ///       member0(0),\n  ///       member1(2) {}\n  bool AllowAllConstructorInitializersOnNextLine;\n\n  /// If the function declaration doesn't fit on a line,\n  /// allow putting all parameters of a function declaration onto\n  /// the next line even if ``BinPackParameters`` is ``false``.\n  /// \\code\n  ///   true:\n  ///   void myFunction(\n  ///       int a, int b, int c, int d, int e);\n  ///\n  ///   false:\n  ///   void myFunction(int a,\n  ///                   int b,\n  ///                   int c,\n  ///                   int d,\n  ///                   int e);\n  /// \\endcode\n  bool AllowAllParametersOfDeclarationOnNextLine;\n\n  /// Allow short enums on a single line.\n  /// \\code\n  ///   true:\n  ///   enum { A, B } myEnum;\n  ///\n  ///   false:\n  ///   enum\n  ///   {\n  ///     A,\n  ///     B\n  ///   } myEnum;\n  /// \\endcode\n  bool AllowShortEnumsOnASingleLine;\n\n  /// Different styles for merging short blocks containing at most one\n  /// statement.\n  enum ShortBlockStyle : unsigned char {\n    /// Never merge blocks into a single line.\n    /// \\code\n    ///   while (true) {\n    ///   }\n    ///   while (true) {\n    ///     continue;\n    ///   }\n    /// \\endcode\n    SBS_Never,\n    /// Only merge empty blocks.\n    /// \\code\n    ///   while (true) {}\n    ///   while (true) {\n    ///     continue;\n    ///   }\n    /// \\endcode\n    SBS_Empty,\n    /// Always merge short blocks into a single line.\n    /// \\code\n    ///   while (true) {}\n    ///   while (true) { continue; }\n    /// \\endcode\n    SBS_Always,\n  };\n\n  /// Dependent on the value, ``while (true) { continue; }`` can be put on a\n  /// single line.\n  ShortBlockStyle AllowShortBlocksOnASingleLine;\n\n  /// If ``true``, short case labels will be contracted to a single line.\n  /// \\code\n  ///   true:                                   false:\n  ///   switch (a) {                    vs.     switch (a) {\n  ///   case 1: x = 1; break;                   case 1:\n  ///   case 2: return;                           x = 1;\n  ///   }                                         break;\n  ///                                           case 2:\n  ///                                             return;\n  ///                                           }\n  /// \\endcode\n  bool AllowShortCaseLabelsOnASingleLine;\n\n  /// Different styles for merging short functions containing at most one\n  /// statement.\n  enum ShortFunctionStyle : unsigned char {\n    /// Never merge functions into a single line.\n    SFS_None,\n    /// Only merge functions defined inside a class. Same as \"inline\",\n    /// except it does not implies \"empty\": i.e. top level empty functions\n    /// are not merged either.\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() {\n    ///     foo();\n    ///   }\n    ///   void f() {\n    ///   }\n    /// \\endcode\n    SFS_InlineOnly,\n    /// Only merge empty functions.\n    /// \\code\n    ///   void f() {}\n    ///   void f2() {\n    ///     bar2();\n    ///   }\n    /// \\endcode\n    SFS_Empty,\n    /// Only merge functions defined inside a class. Implies \"empty\".\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() {\n    ///     foo();\n    ///   }\n    ///   void f() {}\n    /// \\endcode\n    SFS_Inline,\n    /// Merge all functions fitting on a single line.\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() { bar(); }\n    /// \\endcode\n    SFS_All,\n  };\n\n  /// Dependent on the value, ``int f() { return 0; }`` can be put on a\n  /// single line.\n  ShortFunctionStyle AllowShortFunctionsOnASingleLine;\n\n  /// Different styles for handling short if lines\n  enum ShortIfStyle : unsigned char {\n    /// Never put short ifs on the same line.\n    /// \\code\n    ///   if (a)\n    ///     return ;\n    ///   else {\n    ///     return;\n    ///   }\n    /// \\endcode\n    SIS_Never,\n    /// Without else put short ifs on the same line only if\n    /// the else is not a compound statement.\n    /// \\code\n    ///   if (a) return;\n    ///   else\n    ///     return;\n    /// \\endcode\n    SIS_WithoutElse,\n    /// Always put short ifs on the same line if\n    /// the else is not a compound statement or not.\n    /// \\code\n    ///   if (a) return;\n    ///   else {\n    ///     return;\n    ///   }\n    /// \\endcode\n    SIS_Always,\n  };\n\n  /// If ``true``, ``if (a) return;`` can be put on a single line.\n  ShortIfStyle AllowShortIfStatementsOnASingleLine;\n\n  /// Different styles for merging short lambdas containing at most one\n  /// statement.\n  enum ShortLambdaStyle : unsigned char {\n    /// Never merge lambdas into a single line.\n    SLS_None,\n    /// Only merge empty lambdas.\n    /// \\code\n    ///   auto lambda = [](int a) {}\n    ///   auto lambda2 = [](int a) {\n    ///       return a;\n    ///   };\n    /// \\endcode\n    SLS_Empty,\n    /// Merge lambda into a single line if argument of a function.\n    /// \\code\n    ///   auto lambda = [](int a) {\n    ///       return a;\n    ///   };\n    ///   sort(a.begin(), a.end(), ()[] { return x < y; })\n    /// \\endcode\n    SLS_Inline,\n    /// Merge all lambdas fitting on a single line.\n    /// \\code\n    ///   auto lambda = [](int a) {}\n    ///   auto lambda2 = [](int a) { return a; };\n    /// \\endcode\n    SLS_All,\n  };\n\n  /// Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a\n  /// single line.\n  ShortLambdaStyle AllowShortLambdasOnASingleLine;\n\n  /// If ``true``, ``while (true) continue;`` can be put on a single\n  /// line.\n  bool AllowShortLoopsOnASingleLine;\n\n  /// Different ways to break after the function definition return type.\n  /// This option is **deprecated** and is retained for backwards compatibility.\n  enum DefinitionReturnTypeBreakingStyle : unsigned char {\n    /// Break after return type automatically.\n    /// ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n    DRTBS_None,\n    /// Always break after the return type.\n    DRTBS_All,\n    /// Always break after the return types of top-level functions.\n    DRTBS_TopLevel,\n  };\n\n  /// Different ways to break after the function definition or\n  /// declaration return type.\n  enum ReturnTypeBreakingStyle : unsigned char {\n    /// Break after return type automatically.\n    /// ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int f();\n    ///   int f() { return 1; }\n    /// \\endcode\n    RTBS_None,\n    /// Always break after the return type.\n    /// \\code\n    ///   class A {\n    ///     int\n    ///     f() {\n    ///       return 0;\n    ///     };\n    ///   };\n    ///   int\n    ///   f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_All,\n    /// Always break after the return types of top-level functions.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int\n    ///   f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_TopLevel,\n    /// Always break after the return type of function definitions.\n    /// \\code\n    ///   class A {\n    ///     int\n    ///     f() {\n    ///       return 0;\n    ///     };\n    ///   };\n    ///   int f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_AllDefinitions,\n    /// Always break after the return type of top-level definitions.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_TopLevelDefinitions,\n  };\n\n  /// The function definition return type breaking style to use.  This\n  /// option is **deprecated** and is retained for backwards compatibility.\n  DefinitionReturnTypeBreakingStyle AlwaysBreakAfterDefinitionReturnType;\n\n  /// The function declaration return type breaking style to use.\n  ReturnTypeBreakingStyle AlwaysBreakAfterReturnType;\n\n  /// If ``true``, always break before multiline string literals.\n  ///\n  /// This flag is mean to make cases where there are multiple multiline strings\n  /// in a file look more consistent. Thus, it will only take effect if wrapping\n  /// the string at that point leads to it being indented\n  /// ``ContinuationIndentWidth`` spaces from the start of the line.\n  /// \\code\n  ///    true:                                  false:\n  ///    aaaa =                         vs.     aaaa = \"bbbb\"\n  ///        \"bbbb\"                                    \"cccc\";\n  ///        \"cccc\";\n  /// \\endcode\n  bool AlwaysBreakBeforeMultilineStrings;\n\n  /// Different ways to break after the template declaration.\n  enum BreakTemplateDeclarationsStyle : unsigned char {\n    /// Do not force break before declaration.\n    /// ``PenaltyBreakTemplateDeclaration`` is taken into account.\n    /// \\code\n    ///    template <typename T> T foo() {\n    ///    }\n    ///    template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///                                int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_No,\n    /// Force break after template declaration only when the following\n    /// declaration spans multiple lines.\n    /// \\code\n    ///    template <typename T> T foo() {\n    ///    }\n    ///    template <typename T>\n    ///    T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///          int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_MultiLine,\n    /// Always break after template declaration.\n    /// \\code\n    ///    template <typename T>\n    ///    T foo() {\n    ///    }\n    ///    template <typename T>\n    ///    T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///          int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_Yes\n  };\n\n  /// The template declaration breaking style to use.\n  BreakTemplateDeclarationsStyle AlwaysBreakTemplateDeclarations;\n\n  /// A vector of strings that should be interpreted as attributes/qualifiers\n  /// instead of identifiers. This can be useful for language extensions or\n  /// static analyzer annotations.\n  ///\n  /// For example:\n  /// \\code\n  ///   x = (char *__capability)&y;\n  ///   int function(void) __ununsed;\n  ///   void only_writes_to_buffer(char *__output buffer);\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   AttributeMacros: ['__capability', '__output', '__ununsed']\n  /// \\endcode\n  ///\n  std::vector<std::string> AttributeMacros;\n\n  /// If ``false``, a function call's arguments will either be all on the\n  /// same line or will have one line each.\n  /// \\code\n  ///   true:\n  ///   void f() {\n  ///     f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  ///   }\n  ///\n  ///   false:\n  ///   void f() {\n  ///     f(aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  ///   }\n  /// \\endcode\n  bool BinPackArguments;\n\n  /// The style of inserting trailing commas into container literals.\n  enum TrailingCommaStyle : unsigned char {\n    /// Do not insert trailing commas.\n    TCS_None,\n    /// Insert trailing commas in container literals that were wrapped over\n    /// multiple lines. Note that this is conceptually incompatible with\n    /// bin-packing, because the trailing comma is used as an indicator\n    /// that a container should be formatted one-per-line (i.e. not bin-packed).\n    /// So inserting a trailing comma counteracts bin-packing.\n    TCS_Wrapped,\n  };\n\n  /// If set to ``TCS_Wrapped`` will insert trailing commas in container\n  /// literals (arrays and objects) that wrap across multiple lines.\n  /// It is currently only available for JavaScript\n  /// and disabled by default ``TCS_None``.\n  /// ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``\n  /// as inserting the comma disables bin-packing.\n  /// \\code\n  ///   TSC_Wrapped:\n  ///   const someArray = [\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   //                        ^ inserted\n  ///   ]\n  /// \\endcode\n  TrailingCommaStyle InsertTrailingCommas;\n\n  /// If ``false``, a function declaration's or function definition's\n  /// parameters will either all be on the same line or will have one line each.\n  /// \\code\n  ///   true:\n  ///   void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n  ///\n  ///   false:\n  ///   void f(int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n  /// \\endcode\n  bool BinPackParameters;\n\n  /// The style of wrapping parameters on the same line (bin-packed) or\n  /// on one line each.\n  enum BinPackStyle : unsigned char {\n    /// Automatically determine parameter bin-packing behavior.\n    BPS_Auto,\n    /// Always bin-pack parameters.\n    BPS_Always,\n    /// Never bin-pack parameters.\n    BPS_Never,\n  };\n\n  /// The style of breaking before or after binary operators.\n  enum BinaryOperatorStyle : unsigned char {\n    /// Break after operators.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable =\n    ///        someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n    ///                         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n    ///                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&\n    ///                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >\n    ///                     ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_None,\n    /// Break before operators that aren't assignments.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable =\n    ///        someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                 && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                        > ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_NonAssignment,\n    /// Break before operators.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable\n    ///        = someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                 && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                        > ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_All,\n  };\n\n  /// The way to wrap binary operators.\n  BinaryOperatorStyle BreakBeforeBinaryOperators;\n\n  /// Different ways to attach braces to their surrounding context.\n  enum BraceBreakingStyle : unsigned char {\n    /// Always attach braces to surrounding context.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i) {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b) {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Attach,\n    /// Like ``Attach``, but break before braces on function, namespace and\n    /// class definitions.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Linux,\n    /// Like ``Attach``, but break before braces on enum, function, and record\n    /// definitions.\n    /// \\code\n    ///   namespace N {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Mozilla,\n    /// Like ``Attach``, but break before function definitions, ``catch``, and\n    /// ``else``.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     }\n    ///     catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     }\n    ///     else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Stroustrup,\n    /// Always break before braces.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try\n    ///     {\n    ///       do\n    ///       {\n    ///         switch (i)\n    ///         {\n    ///         case 1:\n    ///         {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default:\n    ///         {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     }\n    ///     catch (...)\n    ///     {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b)\n    ///     {\n    ///       baz(2);\n    ///     }\n    ///     else\n    ///     {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Allman,\n    /// Like ``Allman`` but always indent braces and line up code with braces.\n    /// \\code\n    ///   namespace N\n    ///     {\n    ///   enum E\n    ///     {\n    ///     E1,\n    ///     E2,\n    ///     };\n    ///\n    ///   class C\n    ///     {\n    ///   public:\n    ///     C();\n    ///     };\n    ///\n    ///   bool baz(int i)\n    ///     {\n    ///     try\n    ///       {\n    ///       do\n    ///         {\n    ///         switch (i)\n    ///           {\n    ///           case 1:\n    ///           {\n    ///           foobar();\n    ///           break;\n    ///           }\n    ///           default:\n    ///           {\n    ///           break;\n    ///           }\n    ///           }\n    ///         } while (--i);\n    ///       return true;\n    ///       }\n    ///     catch (...)\n    ///       {\n    ///       handleError();\n    ///       return false;\n    ///       }\n    ///     }\n    ///\n    ///   void foo(bool b)\n    ///     {\n    ///     if (b)\n    ///       {\n    ///       baz(2);\n    ///       }\n    ///     else\n    ///       {\n    ///       baz(5);\n    ///       }\n    ///     }\n    ///\n    ///   void bar() { foo(true); }\n    ///     } // namespace N\n    /// \\endcode\n    BS_Whitesmiths,\n    /// Always break before braces and add an extra level of indentation to\n    /// braces of control statements, not to those of class, function\n    /// or other definitions.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try\n    ///       {\n    ///         do\n    ///           {\n    ///             switch (i)\n    ///               {\n    ///               case 1:\n    ///                 {\n    ///                   foobar();\n    ///                   break;\n    ///                 }\n    ///               default:\n    ///                 {\n    ///                   break;\n    ///                 }\n    ///               }\n    ///           }\n    ///         while (--i);\n    ///         return true;\n    ///       }\n    ///     catch (...)\n    ///       {\n    ///         handleError();\n    ///         return false;\n    ///       }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b)\n    ///       {\n    ///         baz(2);\n    ///       }\n    ///     else\n    ///       {\n    ///         baz(5);\n    ///       }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_GNU,\n    /// Like ``Attach``, but break before functions.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_WebKit,\n    /// Configure each individual brace in `BraceWrapping`.\n    BS_Custom\n  };\n\n  /// The brace breaking style to use.\n  BraceBreakingStyle BreakBeforeBraces;\n\n  /// Different ways to wrap braces after control statements.\n  enum BraceWrappingAfterControlStatementStyle : unsigned char {\n    /// Never wrap braces after a control statement.\n    /// \\code\n    ///   if (foo()) {\n    ///   } else {\n    ///   }\n    ///   for (int i = 0; i < 10; ++i) {\n    ///   }\n    /// \\endcode\n    BWACS_Never,\n    /// Only wrap braces after a multi-line control statement.\n    /// \\code\n    ///   if (foo && bar &&\n    ///       baz)\n    ///   {\n    ///     quux();\n    ///   }\n    ///   while (foo || bar) {\n    ///   }\n    /// \\endcode\n    BWACS_MultiLine,\n    /// Always wrap braces after a control statement.\n    /// \\code\n    ///   if (foo())\n    ///   {\n    ///   } else\n    ///   {}\n    ///   for (int i = 0; i < 10; ++i)\n    ///   {}\n    /// \\endcode\n    BWACS_Always\n  };\n\n  /// Precise control over the wrapping of braces.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   BreakBeforeBraces: Custom\n  ///   BraceWrapping:\n  ///       AfterClass: true\n  /// \\endcode\n  struct BraceWrappingFlags {\n    /// Wrap case labels.\n    /// \\code\n    ///   false:                                true:\n    ///   switch (foo) {                vs.     switch (foo) {\n    ///     case 1: {                             case 1:\n    ///       bar();                              {\n    ///       break;                                bar();\n    ///     }                                       break;\n    ///     default: {                            }\n    ///       plop();                             default:\n    ///     }                                     {\n    ///   }                                         plop();\n    ///                                           }\n    ///                                         }\n    /// \\endcode\n    bool AfterCaseLabel;\n    /// Wrap class definitions.\n    /// \\code\n    ///   true:\n    ///   class foo {};\n    ///\n    ///   false:\n    ///   class foo\n    ///   {};\n    /// \\endcode\n    bool AfterClass;\n\n    /// Wrap control statements (``if``/``for``/``while``/``switch``/..).\n    BraceWrappingAfterControlStatementStyle AfterControlStatement;\n    /// Wrap enum definitions.\n    /// \\code\n    ///   true:\n    ///   enum X : int\n    ///   {\n    ///     B\n    ///   };\n    ///\n    ///   false:\n    ///   enum X : int { B };\n    /// \\endcode\n    bool AfterEnum;\n    /// Wrap function definitions.\n    /// \\code\n    ///   true:\n    ///   void foo()\n    ///   {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    ///\n    ///   false:\n    ///   void foo() {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    /// \\endcode\n    bool AfterFunction;\n    /// Wrap namespace definitions.\n    /// \\code\n    ///   true:\n    ///   namespace\n    ///   {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    ///\n    ///   false:\n    ///   namespace {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    /// \\endcode\n    bool AfterNamespace;\n    /// Wrap ObjC definitions (interfaces, implementations...).\n    /// \\note @autoreleasepool and @synchronized blocks are wrapped\n    /// according to `AfterControlStatement` flag.\n    bool AfterObjCDeclaration;\n    /// Wrap struct definitions.\n    /// \\code\n    ///   true:\n    ///   struct foo\n    ///   {\n    ///     int x;\n    ///   };\n    ///\n    ///   false:\n    ///   struct foo {\n    ///     int x;\n    ///   };\n    /// \\endcode\n    bool AfterStruct;\n    /// Wrap union definitions.\n    /// \\code\n    ///   true:\n    ///   union foo\n    ///   {\n    ///     int x;\n    ///   }\n    ///\n    ///   false:\n    ///   union foo {\n    ///     int x;\n    ///   }\n    /// \\endcode\n    bool AfterUnion;\n    /// Wrap extern blocks.\n    /// \\code\n    ///   true:\n    ///   extern \"C\"\n    ///   {\n    ///     int foo();\n    ///   }\n    ///\n    ///   false:\n    ///   extern \"C\" {\n    ///   int foo();\n    ///   }\n    /// \\endcode\n    bool AfterExternBlock; // Partially superseded by IndentExternBlock\n    /// Wrap before ``catch``.\n    /// \\code\n    ///   true:\n    ///   try {\n    ///     foo();\n    ///   }\n    ///   catch () {\n    ///   }\n    ///\n    ///   false:\n    ///   try {\n    ///     foo();\n    ///   } catch () {\n    ///   }\n    /// \\endcode\n    bool BeforeCatch;\n    /// Wrap before ``else``.\n    /// \\code\n    ///   true:\n    ///   if (foo()) {\n    ///   }\n    ///   else {\n    ///   }\n    ///\n    ///   false:\n    ///   if (foo()) {\n    ///   } else {\n    ///   }\n    /// \\endcode\n    bool BeforeElse;\n    /// Wrap lambda block.\n    /// \\code\n    ///   true:\n    ///   connect(\n    ///     []()\n    ///     {\n    ///       foo();\n    ///       bar();\n    ///     });\n    ///\n    ///   false:\n    ///   connect([]() {\n    ///     foo();\n    ///     bar();\n    ///   });\n    /// \\endcode\n    bool BeforeLambdaBody;\n    /// Wrap before ``while``.\n    /// \\code\n    ///   true:\n    ///   do {\n    ///     foo();\n    ///   }\n    ///   while (1);\n    ///\n    ///   false:\n    ///   do {\n    ///     foo();\n    ///   } while (1);\n    /// \\endcode\n    bool BeforeWhile;\n    /// Indent the wrapped braces themselves.\n    bool IndentBraces;\n    /// If ``false``, empty function body can be put on a single line.\n    /// This option is used only if the opening brace of the function has\n    /// already been wrapped, i.e. the `AfterFunction` brace wrapping mode is\n    /// set, and the function could/should not be put on a single line (as per\n    /// `AllowShortFunctionsOnASingleLine` and constructor formatting options).\n    /// \\code\n    ///   int f()   vs.   int f()\n    ///   {}              {\n    ///                   }\n    /// \\endcode\n    ///\n    bool SplitEmptyFunction;\n    /// If ``false``, empty record (e.g. class, struct or union) body\n    /// can be put on a single line. This option is used only if the opening\n    /// brace of the record has already been wrapped, i.e. the `AfterClass`\n    /// (for classes) brace wrapping mode is set.\n    /// \\code\n    ///   class Foo   vs.  class Foo\n    ///   {}               {\n    ///                    }\n    /// \\endcode\n    ///\n    bool SplitEmptyRecord;\n    /// If ``false``, empty namespace body can be put on a single line.\n    /// This option is used only if the opening brace of the namespace has\n    /// already been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\n    /// set.\n    /// \\code\n    ///   namespace Foo   vs.  namespace Foo\n    ///   {}                   {\n    ///                        }\n    /// \\endcode\n    ///\n    bool SplitEmptyNamespace;\n  };\n\n  /// Control of individual brace wrapping cases.\n  ///\n  /// If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how\n  /// each individual brace case should be handled. Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   BreakBeforeBraces: Custom\n  ///   BraceWrapping:\n  ///     AfterEnum: true\n  ///     AfterStruct: false\n  ///     SplitEmptyFunction: false\n  /// \\endcode\n  BraceWrappingFlags BraceWrapping;\n\n  /// If ``true``, concept will be placed on a new line.\n  /// \\code\n  ///   true:\n  ///    template<typename T>\n  ///    concept ...\n  ///\n  ///   false:\n  ///    template<typename T> concept ...\n  /// \\endcode\n  bool BreakBeforeConceptDeclarations;\n\n  /// If ``true``, ternary operators will be placed after line breaks.\n  /// \\code\n  ///    true:\n  ///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n  ///        ? firstValue\n  ///        : SecondValueVeryVeryVeryVeryLong;\n  ///\n  ///    false:\n  ///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n  ///        firstValue :\n  ///        SecondValueVeryVeryVeryVeryLong;\n  /// \\endcode\n  bool BreakBeforeTernaryOperators;\n\n  /// Different ways to break initializers.\n  enum BreakConstructorInitializersStyle : unsigned char {\n    /// Break constructor initializers before the colon and after the commas.\n    /// \\code\n    ///    Constructor()\n    ///        : initializer1(),\n    ///          initializer2()\n    /// \\endcode\n    BCIS_BeforeColon,\n    /// Break constructor initializers before the colon and commas, and align\n    /// the commas with the colon.\n    /// \\code\n    ///    Constructor()\n    ///        : initializer1()\n    ///        , initializer2()\n    /// \\endcode\n    BCIS_BeforeComma,\n    /// Break constructor initializers after the colon and commas.\n    /// \\code\n    ///    Constructor() :\n    ///        initializer1(),\n    ///        initializer2()\n    /// \\endcode\n    BCIS_AfterColon\n  };\n\n  /// The constructor initializers style to use.\n  BreakConstructorInitializersStyle BreakConstructorInitializers;\n\n  /// Break after each annotation on a field in Java files.\n  /// \\code{.java}\n  ///    true:                                  false:\n  ///    @Partial                       vs.     @Partial @Mock DataLoad loader;\n  ///    @Mock\n  ///    DataLoad loader;\n  /// \\endcode\n  bool BreakAfterJavaFieldAnnotations;\n\n  /// Allow breaking string literals when formatting.\n  /// \\code\n  ///    true:\n  ///    const char* x = \"veryVeryVeryVeryVeryVe\"\n  ///                    \"ryVeryVeryVeryVeryVery\"\n  ///                    \"VeryLongString\";\n  ///\n  ///    false:\n  ///    const char* x =\n  ///      \"veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString\";\n  /// \\endcode\n  bool BreakStringLiterals;\n\n  /// The column limit.\n  ///\n  /// A column limit of ``0`` means that there is no column limit. In this case,\n  /// clang-format will respect the input's line breaking decisions within\n  /// statements unless they contradict other rules.\n  unsigned ColumnLimit;\n\n  /// A regular expression that describes comments with special meaning,\n  /// which should not be split into lines or otherwise changed.\n  /// \\code\n  ///    // CommentPragmas: '^ FOOBAR pragma:'\n  ///    // Will leave the following line unaffected\n  ///    #include <vector> // FOOBAR pragma: keep\n  /// \\endcode\n  std::string CommentPragmas;\n\n  /// Different ways to break inheritance list.\n  enum BreakInheritanceListStyle : unsigned char {\n    /// Break inheritance list before the colon and after the commas.\n    /// \\code\n    ///    class Foo\n    ///        : Base1,\n    ///          Base2\n    ///    {};\n    /// \\endcode\n    BILS_BeforeColon,\n    /// Break inheritance list before the colon and commas, and align\n    /// the commas with the colon.\n    /// \\code\n    ///    class Foo\n    ///        : Base1\n    ///        , Base2\n    ///    {};\n    /// \\endcode\n    BILS_BeforeComma,\n    /// Break inheritance list after the colon and commas.\n    /// \\code\n    ///    class Foo :\n    ///        Base1,\n    ///        Base2\n    ///    {};\n    /// \\endcode\n    BILS_AfterColon\n  };\n\n  /// The inheritance list style to use.\n  BreakInheritanceListStyle BreakInheritanceList;\n\n  /// If ``true``, consecutive namespace declarations will be on the same\n  /// line. If ``false``, each namespace is declared on a new line.\n  /// \\code\n  ///   true:\n  ///   namespace Foo { namespace Bar {\n  ///   }}\n  ///\n  ///   false:\n  ///   namespace Foo {\n  ///   namespace Bar {\n  ///   }\n  ///   }\n  /// \\endcode\n  ///\n  /// If it does not fit on a single line, the overflowing namespaces get\n  /// wrapped:\n  /// \\code\n  ///   namespace Foo { namespace Bar {\n  ///   namespace Extra {\n  ///   }}}\n  /// \\endcode\n  bool CompactNamespaces;\n\n  // clang-format off\n  /// If the constructor initializers don't fit on a line, put each\n  /// initializer on its own line.\n  /// \\code\n  ///   true:\n  ///   SomeClass::Constructor()\n  ///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  ///     return 0;\n  ///   }\n  ///\n  ///   false:\n  ///   SomeClass::Constructor()\n  ///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n  ///         aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  ///     return 0;\n  ///   }\n  /// \\endcode\n  bool ConstructorInitializerAllOnOneLineOrOnePerLine;\n  // clang-format on\n\n  /// The number of characters to use for indentation of constructor\n  /// initializer lists as well as inheritance lists.\n  unsigned ConstructorInitializerIndentWidth;\n\n  /// Indent width for line continuations.\n  /// \\code\n  ///    ContinuationIndentWidth: 2\n  ///\n  ///    int i =         //  VeryVeryVeryVeryVeryLongComment\n  ///      longFunction( // Again a long comment\n  ///        arg);\n  /// \\endcode\n  unsigned ContinuationIndentWidth;\n\n  /// If ``true``, format braced lists as best suited for C++11 braced\n  /// lists.\n  ///\n  /// Important differences:\n  /// - No spaces inside the braced list.\n  /// - No line break before the closing brace.\n  /// - Indentation with the continuation indent, not with the block indent.\n  ///\n  /// Fundamentally, C++11 braced lists are formatted exactly like function\n  /// calls would be formatted in their place. If the braced list follows a name\n  /// (e.g. a type or variable name), clang-format formats as if the ``{}`` were\n  /// the parentheses of a function call with that name. If there is no name,\n  /// a zero-length name is assumed.\n  /// \\code\n  ///    true:                                  false:\n  ///    vector<int> x{1, 2, 3, 4};     vs.     vector<int> x{ 1, 2, 3, 4 };\n  ///    vector<T> x{{}, {}, {}, {}};           vector<T> x{ {}, {}, {}, {} };\n  ///    f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n  ///    new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  bool Cpp11BracedListStyle;\n\n  /// \\brief Analyze the formatted file for the most used line ending (``\\r\\n``\n  /// or ``\\n``). ``UseCRLF`` is only used as a fallback if none can be derived.\n  bool DeriveLineEnding;\n\n  /// If ``true``, analyze the formatted file for the most common\n  /// alignment of ``&`` and ``*``.\n  /// Pointer and reference alignment styles are going to be updated according\n  /// to the preferences found in the file.\n  /// ``PointerAlignment`` is then used only as fallback.\n  bool DerivePointerAlignment;\n\n  /// Disables formatting completely.\n  bool DisableFormat;\n\n  /// Different styles for empty line before access modifiers.\n  enum EmptyLineBeforeAccessModifierStyle : unsigned char {\n    /// Remove all empty lines before access modifiers.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///   public:\n    ///     foo() {}\n    ///   private:\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_Never,\n    /// Keep existing empty lines before access modifiers.\n    ELBAMS_Leave,\n    /// Add empty line only when access modifier starts a new logical block.\n    /// Logical block is a group of one or more member fields or functions.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///   public:\n    ///     foo() {}\n    ///\n    ///   private:\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_LogicalBlock,\n    /// Always add empty line before access modifiers unless access modifier\n    /// is at the start of struct or class definition.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///\n    ///   public:\n    ///     foo() {}\n    ///\n    ///   private:\n    ///\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_Always,\n  };\n\n  /// Defines in which cases to put empty line before access modifiers.\n  EmptyLineBeforeAccessModifierStyle EmptyLineBeforeAccessModifier;\n\n  /// If ``true``, clang-format detects whether function calls and\n  /// definitions are formatted with one parameter per line.\n  ///\n  /// Each call can be bin-packed, one-per-line or inconclusive. If it is\n  /// inconclusive, e.g. completely on one line, but a decision needs to be\n  /// made, clang-format analyzes whether there are other bin-packed cases in\n  /// the input file and act accordingly.\n  ///\n  /// NOTE: This is an experimental flag, that might go away or be renamed. Do\n  /// not use this in config files, etc. Use at your own risk.\n  bool ExperimentalAutoDetectBinPacking;\n\n  /// If ``true``, clang-format adds missing namespace end comments for\n  /// short namespaces and fixes invalid existing ones. Short ones are\n  /// controlled by \"ShortNamespaceLines\".\n  /// \\code\n  ///    true:                                  false:\n  ///    namespace a {                  vs.     namespace a {\n  ///    foo();                                 foo();\n  ///    bar();                                 bar();\n  ///    } // namespace a                       }\n  /// \\endcode\n  bool FixNamespaceComments;\n\n  /// A vector of macros that should be interpreted as foreach loops\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   FOREACH(<variable-declaration>, ...)\n  ///     <loop-body>\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   ForEachMacros: ['RANGES_FOR', 'FOREACH']\n  /// \\endcode\n  ///\n  /// For example: BOOST_FOREACH.\n  std::vector<std::string> ForEachMacros;\n\n  /// \\brief A vector of macros that should be interpreted as type declarations\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STACK_OF(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   TypenameMacros: ['STACK_OF', 'LIST']\n  /// \\endcode\n  ///\n  /// For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n  std::vector<std::string> TypenameMacros;\n\n  /// A vector of macros that should be interpreted as complete\n  /// statements.\n  ///\n  /// Typical macros are expressions, and require a semi-colon to be\n  /// added; sometimes this is not the case, and this allows to make\n  /// clang-format aware of such cases.\n  ///\n  /// For example: Q_UNUSED\n  std::vector<std::string> StatementMacros;\n\n  /// A vector of macros which are used to open namespace blocks.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   NAMESPACE(<namespace-name>, ...) {\n  ///     <namespace-content>\n  ///   }\n  /// \\endcode\n  ///\n  /// For example: TESTSUITE\n  std::vector<std::string> NamespaceMacros;\n\n  /// A vector of macros which are whitespace-sensitive and should not\n  /// be touched.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STRINGIZE(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n  /// \\endcode\n  ///\n  /// For example: BOOST_PP_STRINGIZE\n  std::vector<std::string> WhitespaceSensitiveMacros;\n\n  tooling::IncludeStyle IncludeStyle;\n\n  /// Specify whether access modifiers should have their own indentation level.\n  ///\n  /// When ``false``, access modifiers are indented (or outdented) relative to\n  /// the record members, respecting the ``AccessModifierOffset``. Record\n  /// members are indented one level below the record.\n  /// When ``true``, access modifiers get their own indentation level. As a\n  /// consequence, record members are always indented 2 levels below the record,\n  /// regardless of the access modifier presence. Value of the\n  /// ``AccessModifierOffset`` is ignored.\n  /// \\code\n  ///    false:                                 true:\n  ///    class C {                      vs.     class C {\n  ///      class D {                                class D {\n  ///        void bar();                                void bar();\n  ///      protected:                                 protected:\n  ///        D();                                       D();\n  ///      };                                       };\n  ///    public:                                  public:\n  ///      C();                                     C();\n  ///    };                                     };\n  ///    void foo() {                           void foo() {\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  bool IndentAccessModifiers;\n\n  /// Indent case labels one level from the switch statement.\n  ///\n  /// When ``false``, use the same indentation level as for the switch\n  /// statement. Switch statement body is always indented one level more than\n  /// case labels (except the first block following the case label, which\n  /// itself indents the code - unless IndentCaseBlocks is enabled).\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1:                                  case 1:\n  ///      bar();                                   bar();\n  ///      break;                                   break;\n  ///    default:                                 default:\n  ///      plop();                                  plop();\n  ///    }                                      }\n  /// \\endcode\n  bool IndentCaseLabels;\n\n  /// Indent case label blocks one level from the case label.\n  ///\n  /// When ``false``, the block following the case label uses the same\n  /// indentation level as for the case label, treating the case label the same\n  /// as an if-statement.\n  /// When ``true``, the block gets indented as a scope block.\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1: {                              case 1:\n  ///      bar();                                 {\n  ///    } break;                                   bar();\n  ///    default: {                               }\n  ///      plop();                                break;\n  ///    }                                      default:\n  ///    }                                        {\n  ///                                               plop();\n  ///                                             }\n  ///                                           }\n  /// \\endcode\n  bool IndentCaseBlocks;\n\n  /// Indent goto labels.\n  ///\n  /// When ``false``, goto labels are flushed left.\n  /// \\code\n  ///    true:                                  false:\n  ///    int f() {                      vs.     int f() {\n  ///      if (foo()) {                           if (foo()) {\n  ///      label1:                              label1:\n  ///        bar();                                 bar();\n  ///      }                                      }\n  ///    label2:                                label2:\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  bool IndentGotoLabels;\n\n  /// Options for indenting preprocessor directives.\n  enum PPDirectiveIndentStyle : unsigned char {\n    /// Does not indent any directives.\n    /// \\code\n    ///    #if FOO\n    ///    #if BAR\n    ///    #include <foo>\n    ///    #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_None,\n    /// Indents directives after the hash.\n    /// \\code\n    ///    #if FOO\n    ///    #  if BAR\n    ///    #    include <foo>\n    ///    #  endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_AfterHash,\n    /// Indents directives before the hash.\n    /// \\code\n    ///    #if FOO\n    ///      #if BAR\n    ///        #include <foo>\n    ///      #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_BeforeHash\n  };\n\n  /// The preprocessor directive indenting style to use.\n  PPDirectiveIndentStyle IndentPPDirectives;\n\n  /// Indents extern blocks\n  enum IndentExternBlockStyle : unsigned char {\n    /// Backwards compatible with AfterExternBlock's indenting.\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: true\n    ///    extern \"C\"\n    ///    {\n    ///        void foo();\n    ///    }\n    /// \\endcode\n    ///\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: false\n    ///    extern \"C\" {\n    ///    void foo();\n    ///    }\n    /// \\endcode\n    IEBS_AfterExternBlock,\n    /// Does not indent extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///     void foo();\n    ///     }\n    /// \\endcode\n    IEBS_NoIndent,\n    /// Indents extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///       void foo();\n    ///     }\n    /// \\endcode\n    IEBS_Indent,\n  };\n\n  /// IndentExternBlockStyle is the type of indenting of extern blocks.\n  IndentExternBlockStyle IndentExternBlock;\n\n  /// Indent the requires clause in a template\n  /// \\code\n  ///    true:\n  ///    template <typename It>\n  ///      requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  ///\n  ///    false:\n  ///    template <typename It>\n  ///    requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  /// \\endcode\n  bool IndentRequires;\n\n  /// The number of columns to use for indentation.\n  /// \\code\n  ///    IndentWidth: 3\n  ///\n  ///    void f() {\n  ///       someFunction();\n  ///       if (true, false) {\n  ///          f();\n  ///       }\n  ///    }\n  /// \\endcode\n  unsigned IndentWidth;\n\n  /// Indent if a function definition or declaration is wrapped after the\n  /// type.\n  /// \\code\n  ///    true:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///        LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  ///\n  ///    false:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///    LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  /// \\endcode\n  bool IndentWrappedFunctionNames;\n\n  /// A vector of prefixes ordered by the desired groups for Java imports.\n  ///\n  /// One group's prefix can be a subset of another - the longest prefix is\n  /// always matched. Within a group, the imports are ordered lexicographically.\n  /// Static imports are grouped separately and follow the same group rules.\n  /// By default, static imports are placed before non-static imports,\n  /// but this behavior is changed by another option,\n  /// ``SortJavaStaticImport``.\n  ///\n  /// In the .clang-format configuration file, this can be configured like\n  /// in the following yaml example. This will result in imports being\n  /// formatted as in the Java example below.\n  /// \\code{.yaml}\n  ///   JavaImportGroups: ['com.example', 'com', 'org']\n  /// \\endcode\n  ///\n  /// \\code{.java}\n  ///    import static com.example.function1;\n  ///\n  ///    import static com.test.function2;\n  ///\n  ///    import static org.example.function3;\n  ///\n  ///    import com.example.ClassA;\n  ///    import com.example.Test;\n  ///    import com.example.a.ClassB;\n  ///\n  ///    import com.test.ClassC;\n  ///\n  ///    import org.example.ClassD;\n  /// \\endcode\n  std::vector<std::string> JavaImportGroups;\n\n  /// Quotation styles for JavaScript strings. Does not affect template\n  /// strings.\n  enum JavaScriptQuoteStyle : unsigned char {\n    /// Leave string quotes as they are.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Leave,\n    /// Always use single quotes.\n    /// \\code{.js}\n    ///    string1 = 'foo';\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Single,\n    /// Always use double quotes.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = \"bar\";\n    /// \\endcode\n    JSQS_Double\n  };\n\n  /// The JavaScriptQuoteStyle to use for JavaScript strings.\n  JavaScriptQuoteStyle JavaScriptQuotes;\n\n  // clang-format off\n  /// Whether to wrap JavaScript import/export statements.\n  /// \\code{.js}\n  ///    true:\n  ///    import {\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///    } from 'some/module.js'\n  ///\n  ///    false:\n  ///    import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from \"some/module.js\"\n  /// \\endcode\n  bool JavaScriptWrapImports;\n  // clang-format on\n\n  /// If true, the empty line at the start of blocks is kept.\n  /// \\code\n  ///    true:                                  false:\n  ///    if (foo) {                     vs.     if (foo) {\n  ///                                             bar();\n  ///      bar();                               }\n  ///    }\n  /// \\endcode\n  bool KeepEmptyLinesAtTheStartOfBlocks;\n\n  /// Supported languages.\n  ///\n  /// When stored in a configuration file, specifies the language, that the\n  /// configuration targets. When passed to the ``reformat()`` function, enables\n  /// syntax features specific to the language.\n  enum LanguageKind : unsigned char {\n    /// Do not use.\n    LK_None,\n    /// Should be used for C, C++.\n    LK_Cpp,\n    /// Should be used for C#.\n    LK_CSharp,\n    /// Should be used for Java.\n    LK_Java,\n    /// Should be used for JavaScript.\n    LK_JavaScript,\n    /// Should be used for Objective-C, Objective-C++.\n    LK_ObjC,\n    /// Should be used for Protocol Buffers\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_Proto,\n    /// Should be used for TableGen code.\n    LK_TableGen,\n    /// Should be used for Protocol Buffer messages in text format\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_TextProto\n  };\n  bool isCpp() const { return Language == LK_Cpp || Language == LK_ObjC; }\n  bool isCSharp() const { return Language == LK_CSharp; }\n\n  /// Language, this format style is targeted at.\n  LanguageKind Language;\n\n  /// A regular expression matching macros that start a block.\n  /// \\code\n  ///    # With:\n  ///    MacroBlockBegin: \"^NS_MAP_BEGIN|\\\n  ///    NS_TABLE_HEAD$\"\n  ///    MacroBlockEnd: \"^\\\n  ///    NS_MAP_END|\\\n  ///    NS_TABLE_.*_END$\"\n  ///\n  ///    NS_MAP_BEGIN\n  ///      foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///      bar();\n  ///    NS_TABLE_FOO_END\n  ///\n  ///    # Without:\n  ///    NS_MAP_BEGIN\n  ///    foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///    bar();\n  ///    NS_TABLE_FOO_END\n  /// \\endcode\n  std::string MacroBlockBegin;\n\n  /// A regular expression matching macros that end a block.\n  std::string MacroBlockEnd;\n\n  /// The maximum number of consecutive empty lines to keep.\n  /// \\code\n  ///    MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n  ///    int f() {                              int f() {\n  ///      int = 1;                                 int i = 1;\n  ///                                               i = foo();\n  ///      i = foo();                               return i;\n  ///                                           }\n  ///      return i;\n  ///    }\n  /// \\endcode\n  unsigned MaxEmptyLinesToKeep;\n\n  /// Different ways to indent namespace contents.\n  enum NamespaceIndentationKind : unsigned char {\n    /// Don't indent in namespaces.\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///    int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_None,\n    /// Indent only in inner namespaces (nested in other namespaces).\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///      int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_Inner,\n    /// Indent in all namespaces.\n    /// \\code\n    ///    namespace out {\n    ///      int i;\n    ///      namespace in {\n    ///        int i;\n    ///      }\n    ///    }\n    /// \\endcode\n    NI_All\n  };\n\n  /// The indentation used for namespaces.\n  NamespaceIndentationKind NamespaceIndentation;\n\n  /// Controls bin-packing Objective-C protocol conformance list\n  /// items into as few lines as possible when they go over ``ColumnLimit``.\n  ///\n  /// If ``Auto`` (the default), delegates to the value in\n  /// ``BinPackParameters``. If that is ``true``, bin-packs Objective-C\n  /// protocol conformance list items into as few lines as possible\n  /// whenever they go over ``ColumnLimit``.\n  ///\n  /// If ``Always``, always bin-packs Objective-C protocol conformance\n  /// list items into as few lines as possible whenever they go over\n  /// ``ColumnLimit``.\n  ///\n  /// If ``Never``, lays out Objective-C protocol conformance list items\n  /// onto individual lines whenever they go over ``ColumnLimit``.\n  ///\n  /// \\code{.objc}\n  ///    Always (or Auto, if BinPackParameters=true):\n  ///    @interface ccccccccccccc () <\n  ///        ccccccccccccc, ccccccccccccc,\n  ///        ccccccccccccc, ccccccccccccc> {\n  ///    }\n  ///\n  ///    Never (or Auto, if BinPackParameters=false):\n  ///    @interface ddddddddddddd () <\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd> {\n  ///    }\n  /// \\endcode\n  BinPackStyle ObjCBinPackProtocolList;\n\n  /// The number of characters to use for indentation of ObjC blocks.\n  /// \\code{.objc}\n  ///    ObjCBlockIndentWidth: 4\n  ///\n  ///    [operation setCompletionBlock:^{\n  ///        [self onOperationDone];\n  ///    }];\n  /// \\endcode\n  unsigned ObjCBlockIndentWidth;\n\n  /// Add a space after ``@property`` in Objective-C, i.e. use\n  /// ``@property (readonly)`` instead of ``@property(readonly)``.\n  bool ObjCSpaceAfterProperty;\n\n  /// Break parameters list into lines when there is nested block\n  /// parameters in a function call.\n  /// \\code\n  ///   false:\n  ///    - (void)_aMethod\n  ///    {\n  ///        [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber\n  ///        *u, NSNumber *v) {\n  ///            u = c;\n  ///        }]\n  ///    }\n  ///    true:\n  ///    - (void)_aMethod\n  ///    {\n  ///       [self.test1 t:self\n  ///                    w:self\n  ///           callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {\n  ///                u = c;\n  ///            }]\n  ///    }\n  /// \\endcode\n  bool ObjCBreakBeforeNestedBlockParam;\n\n  /// Add a space in front of an Objective-C protocol list, i.e. use\n  /// ``Foo <Protocol>`` instead of ``Foo<Protocol>``.\n  bool ObjCSpaceBeforeProtocolList;\n\n  /// The penalty for breaking around an assignment operator.\n  unsigned PenaltyBreakAssignment;\n\n  /// The penalty for breaking a function call after ``call(``.\n  unsigned PenaltyBreakBeforeFirstCallParameter;\n\n  /// The penalty for each line break introduced inside a comment.\n  unsigned PenaltyBreakComment;\n\n  /// The penalty for breaking before the first ``<<``.\n  unsigned PenaltyBreakFirstLessLess;\n\n  /// The penalty for each line break introduced inside a string literal.\n  unsigned PenaltyBreakString;\n\n  /// The penalty for breaking after template declaration.\n  unsigned PenaltyBreakTemplateDeclaration;\n\n  /// The penalty for each character outside of the column limit.\n  unsigned PenaltyExcessCharacter;\n\n  /// Penalty for putting the return type of a function onto its own\n  /// line.\n  unsigned PenaltyReturnTypeOnItsOwnLine;\n\n  /// Penalty for each character of whitespace indentation\n  /// (counted relative to leading non-whitespace column).\n  unsigned PenaltyIndentedWhitespace;\n\n  /// The ``&`` and ``*`` alignment style.\n  enum PointerAlignmentStyle : unsigned char {\n    /// Align pointer to the left.\n    /// \\code\n    ///   int* a;\n    /// \\endcode\n    PAS_Left,\n    /// Align pointer to the right.\n    /// \\code\n    ///   int *a;\n    /// \\endcode\n    PAS_Right,\n    /// Align pointer in the middle.\n    /// \\code\n    ///   int * a;\n    /// \\endcode\n    PAS_Middle\n  };\n\n  /// Pointer and reference alignment style.\n  PointerAlignmentStyle PointerAlignment;\n\n  /// See documentation of ``RawStringFormats``.\n  struct RawStringFormat {\n    /// The language of this raw string.\n    LanguageKind Language;\n    /// A list of raw string delimiters that match this language.\n    std::vector<std::string> Delimiters;\n    /// A list of enclosing function names that match this language.\n    std::vector<std::string> EnclosingFunctions;\n    /// The canonical delimiter for this language.\n    std::string CanonicalDelimiter;\n    /// The style name on which this raw string format is based on.\n    /// If not specified, the raw string format is based on the style that this\n    /// format is based on.\n    std::string BasedOnStyle;\n    bool operator==(const RawStringFormat &Other) const {\n      return Language == Other.Language && Delimiters == Other.Delimiters &&\n             EnclosingFunctions == Other.EnclosingFunctions &&\n             CanonicalDelimiter == Other.CanonicalDelimiter &&\n             BasedOnStyle == Other.BasedOnStyle;\n    }\n  };\n\n  /// Defines hints for detecting supported languages code blocks in raw\n  /// strings.\n  ///\n  /// A raw string with a matching delimiter or a matching enclosing function\n  /// name will be reformatted assuming the specified language based on the\n  /// style for that language defined in the .clang-format file. If no style has\n  /// been defined in the .clang-format file for the specific language, a\n  /// predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not\n  /// found, the formatting is based on llvm style. A matching delimiter takes\n  /// precedence over a matching enclosing function name for determining the\n  /// language of the raw string contents.\n  ///\n  /// If a canonical delimiter is specified, occurrences of other delimiters for\n  /// the same language will be updated to the canonical if possible.\n  ///\n  /// There should be at most one specification per language and each delimiter\n  /// and enclosing function should not occur in multiple specifications.\n  ///\n  /// To configure this in the .clang-format file, use:\n  /// \\code{.yaml}\n  ///   RawStringFormats:\n  ///     - Language: TextProto\n  ///         Delimiters:\n  ///           - 'pb'\n  ///           - 'proto'\n  ///         EnclosingFunctions:\n  ///           - 'PARSE_TEXT_PROTO'\n  ///         BasedOnStyle: google\n  ///     - Language: Cpp\n  ///         Delimiters:\n  ///           - 'cc'\n  ///           - 'cpp'\n  ///         BasedOnStyle: llvm\n  ///         CanonicalDelimiter: 'cc'\n  /// \\endcode\n  std::vector<RawStringFormat> RawStringFormats;\n\n  // clang-format off\n  /// If ``true``, clang-format will attempt to re-flow comments.\n  /// \\code\n  ///    false:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n  ///\n  ///    true:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///    // information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///     * information */\n  /// \\endcode\n  bool ReflowComments;\n  // clang-format on\n\n  /// The maximal number of unwrapped lines that a short namespace spans.\n  /// Defaults to 1.\n  ///\n  /// This determines the maximum length of short namespaces by counting\n  /// unwrapped lines (i.e. containing neither opening nor closing\n  /// namespace brace) and makes \"FixNamespaceComments\" omit adding\n  /// end comments for those.\n  /// \\code\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace a {                      namespace a {\n  ///      int foo;                           int foo;\n  ///    }                                  } // namespace a\n  ///\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace b {                      namespace b {\n  ///      int foo;                           int foo;\n  ///      int bar;                           int bar;\n  ///    } // namespace b                   } // namespace b\n  /// \\endcode\n  unsigned ShortNamespaceLines;\n\n  /// Include sorting options.\n  enum SortIncludesOptions : unsigned char {\n    /// Includes are never sorted.\n    /// \\code\n    ///    #include \"B/A.h\"\n    ///    #include \"A/B.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_Never,\n    /// Includes are sorted in an ASCIIbetical or case sensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    ///    #include \"a/b.h\"\n    /// \\endcode\n    SI_CaseSensitive,\n    /// Includes are sorted in an alphabetical or case insensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_CaseInsensitive,\n  };\n\n  /// Controls if and how clang-format will sort ``#includes``.\n  /// If ``Never``, includes are never sorted.\n  /// If ``CaseInsensitive``, includes are sorted in an ASCIIbetical or case\n  /// insensitive fashion.\n  /// If ``CaseSensitive``, includes are sorted in an alphabetical or case\n  /// sensitive fashion.\n  SortIncludesOptions SortIncludes;\n\n  /// Position for Java Static imports.\n  enum SortJavaStaticImportOptions : unsigned char {\n    /// Static imports are placed before non-static imports.\n    /// \\code{.java}\n    ///   import static org.example.function1;\n    ///\n    ///   import org.example.ClassA;\n    /// \\endcode\n    SJSIO_Before,\n    /// Static imports are placed after non-static imports.\n    /// \\code{.java}\n    ///   import org.example.ClassA;\n    ///\n    ///   import static org.example.function1;\n    /// \\endcode\n    SJSIO_After,\n  };\n\n  /// When sorting Java imports, by default static imports are placed before\n  /// non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\n  /// static imports are placed after non-static imports.\n  SortJavaStaticImportOptions SortJavaStaticImport;\n\n  /// If ``true``, clang-format will sort using declarations.\n  ///\n  /// The order of using declarations is defined as follows:\n  /// Split the strings by \"::\" and discard any initial empty strings. The last\n  /// element of each list is a non-namespace name; all others are namespace\n  /// names. Sort the lists of names lexicographically, where the sort order of\n  /// individual names is that all non-namespace names come before all namespace\n  /// names, and within those groups, names are in case-insensitive\n  /// lexicographic order.\n  /// \\code\n  ///    false:                                 true:\n  ///    using std::cout;               vs.     using std::cin;\n  ///    using std::cin;                        using std::cout;\n  /// \\endcode\n  bool SortUsingDeclarations;\n\n  /// If ``true``, a space is inserted after C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    (int) i;                       vs.     (int)i;\n  /// \\endcode\n  bool SpaceAfterCStyleCast;\n\n  /// If ``true``, a space is inserted after the logical not operator (``!``).\n  /// \\code\n  ///    true:                                  false:\n  ///    ! someExpression();            vs.     !someExpression();\n  /// \\endcode\n  bool SpaceAfterLogicalNot;\n\n  /// If \\c true, a space will be inserted after the 'template' keyword.\n  /// \\code\n  ///    true:                                  false:\n  ///    template <int> void foo();     vs.     template<int> void foo();\n  /// \\endcode\n  bool SpaceAfterTemplateKeyword;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceAroundPointerQualifiersStyle : unsigned char {\n    /// Don't ensure spaces around pointer qualifiers and use PointerAlignment\n    /// instead.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_Default,\n    /// Ensure that there is a space before pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Before,\n    /// Ensure that there is a space after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_After,\n    /// Ensure that there is a space both before and after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Both,\n  };\n\n  ///  Defines in which cases to put a space before or after pointer qualifiers\n  SpaceAroundPointerQualifiersStyle SpaceAroundPointerQualifiers;\n\n  /// If ``false``, spaces will be removed before assignment operators.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a = 5;                     vs.     int a= 5;\n  ///    a += 42;                               a+= 42;\n  /// \\endcode\n  bool SpaceBeforeAssignmentOperators;\n\n  /// If ``false``, spaces will be removed before case colon.\n  /// \\code\n  ///   true:                                   false\n  ///   switch (x) {                    vs.     switch (x) {\n  ///     case 1 : break;                         case 1: break;\n  ///   }                                       }\n  /// \\endcode\n  bool SpaceBeforeCaseColon;\n\n  /// If ``true``, a space will be inserted before a C++11 braced list\n  /// used to initialize an object (after the preceding identifier or type).\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo foo { bar };               vs.     Foo foo{ bar };\n  ///    Foo {};                                Foo{};\n  ///    vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n  ///    new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  bool SpaceBeforeCpp11BracedList;\n\n  /// If ``false``, spaces will be removed before constructor initializer\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n  /// \\endcode\n  bool SpaceBeforeCtorInitializerColon;\n\n  /// If ``false``, spaces will be removed before inheritance colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    class Foo : Bar {}             vs.     class Foo: Bar {}\n  /// \\endcode\n  bool SpaceBeforeInheritanceColon;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceBeforeParensOptions : unsigned char {\n    /// Never put a space before opening parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Never,\n    /// Put a space before opening parentheses only after control statement\n    /// keywords (``for/if/while...``).\n    /// \\code\n    ///    void f() {\n    ///      if (true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatements,\n    /// Same as ``SBPO_ControlStatements`` except this option doesn't apply to\n    /// ForEach macros. This is useful in projects where ForEach macros are\n    /// treated as function calls instead of control statements.\n    /// \\code\n    ///    void f() {\n    ///      Q_FOREACH(...) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatementsExceptForEachMacros,\n    /// Put a space before opening parentheses only if the parentheses are not\n    /// empty i.e. '()'\n    /// \\code\n    ///   void() {\n    ///     if (true) {\n    ///       f();\n    ///       g (x, y, z);\n    ///     }\n    ///   }\n    /// \\endcode\n    SBPO_NonEmptyParentheses,\n    /// Always put a space before opening parentheses, except when it's\n    /// prohibited by the syntax rules (in function-like macro definitions) or\n    /// when determined by other style rules (after unary operators, opening\n    /// parentheses, etc.)\n    /// \\code\n    ///    void f () {\n    ///      if (true) {\n    ///        f ();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Always\n  };\n\n  /// Defines in which cases to put a space before opening parentheses.\n  SpaceBeforeParensOptions SpaceBeforeParens;\n\n  /// If ``false``, spaces will be removed before range-based for loop\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    for (auto v : values) {}       vs.     for(auto v: values) {}\n  /// \\endcode\n  bool SpaceBeforeRangeBasedForLoopColon;\n\n  /// If ``true``, spaces will be inserted into ``{}``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f() { }                   vs.   void f() {}\n  ///    while (true) { }                     while (true) {}\n  /// \\endcode\n  bool SpaceInEmptyBlock;\n\n  /// If ``true``, spaces may be inserted into ``()``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f( ) {                    vs.   void f() {\n  ///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n  ///      if (true) {                          if (true) {\n  ///        f( );                                f();\n  ///      }                                    }\n  ///    }                                    }\n  /// \\endcode\n  bool SpaceInEmptyParentheses;\n\n  /// The number of spaces before trailing line comments\n  /// (``//`` - comments).\n  ///\n  /// This does not affect trailing block comments (``/*`` - comments) as\n  /// those commonly have different usage patterns and a number of special\n  /// cases.\n  /// \\code\n  ///    SpacesBeforeTrailingComments: 3\n  ///    void f() {\n  ///      if (true) {   // foo1\n  ///        f();        // bar\n  ///      }             // foo\n  ///    }\n  /// \\endcode\n  unsigned SpacesBeforeTrailingComments;\n\n  /// If ``true``, spaces will be inserted after ``<`` and before ``>``\n  /// in template argument lists.\n  /// \\code\n  ///    true:                                  false:\n  ///    static_cast< int >(arg);       vs.     static_cast<int>(arg);\n  ///    std::function< void(int) > fct;        std::function<void(int)> fct;\n  /// \\endcode\n  bool SpacesInAngles;\n\n  /// If ``true``, spaces will be inserted around if/for/switch/while\n  /// conditions.\n  /// \\code\n  ///    true:                                  false:\n  ///    if ( a )  { ... }              vs.     if (a) { ... }\n  ///    while ( i < 5 )  { ... }               while (i < 5) { ... }\n  /// \\endcode\n  bool SpacesInConditionalStatement;\n\n  /// If ``true``, spaces are inserted inside container literals (e.g.\n  /// ObjC and Javascript array and dict literals).\n  /// \\code{.js}\n  ///    true:                                  false:\n  ///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n  ///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n  /// \\endcode\n  bool SpacesInContainerLiterals;\n\n  /// If ``true``, spaces may be inserted into C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    x = ( int32 )y                 vs.     x = (int32)y\n  /// \\endcode\n  bool SpacesInCStyleCastParentheses;\n\n  /// Control of spaces within a single line comment\n  struct SpacesInLineComment {\n    /// The minimum number of spaces at the start of the comment.\n    unsigned Minimum;\n    /// The maximum number of spaces at the start of the comment.\n    unsigned Maximum;\n  };\n\n  /// How many spaces are allowed at the start of a line comment. To disable the\n  /// maximum set it to ``-1``, apart from that the maximum takes precedence\n  /// over the minimum.\n  /// \\code Minimum = 1 Maximum = -1\n  /// // One space is forced\n  ///\n  /// //  but more spaces are possible\n  ///\n  /// Minimum = 0\n  /// Maximum = 0\n  /// //Forces to start every comment directly after the slashes\n  /// \\endcode\n  ///\n  /// Note that in line comment sections the relative indent of the subsequent\n  /// lines is kept, that means the following:\n  /// \\code\n  /// before:                                   after:\n  /// Minimum: 1\n  /// //if (b) {                                // if (b) {\n  /// //  return true;                          //   return true;\n  /// //}                                       // }\n  ///\n  /// Maximum: 0\n  /// /// List:                                 ///List:\n  /// ///  - Foo                                /// - Foo\n  /// ///    - Bar                              ///   - Bar\n  /// \\endcode\n  SpacesInLineComment SpacesInLineCommentPrefix;\n\n  /// If ``true``, spaces will be inserted after ``(`` and before ``)``.\n  /// \\code\n  ///    true:                                  false:\n  ///    t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n  /// \\endcode\n  bool SpacesInParentheses;\n\n  /// If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  /// Lambdas without arguments or unspecified size array declarations will not\n  /// be affected.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a[ 5 ];                    vs.     int a[5];\n  ///    std::unique_ptr<int[]> foo() {} // Won't be affected\n  /// \\endcode\n  bool SpacesInSquareBrackets;\n\n  /// If ``true``, spaces will be before  ``[``.\n  /// Lambdas will not be affected. Only the first ``[`` will get a space added.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a [5];                    vs.      int a[5];\n  ///    int a [5][5];                 vs.      int a[5][5];\n  /// \\endcode\n  bool SpaceBeforeSquareBrackets;\n\n  /// Styles for adding spacing around ``:`` in bitfield definitions.\n  enum BitFieldColonSpacingStyle : unsigned char {\n    /// Add one space on each side of the ``:``\n    /// \\code\n    ///   unsigned bf : 2;\n    /// \\endcode\n    BFCS_Both,\n    /// Add no space around the ``:`` (except when needed for\n    /// ``AlignConsecutiveBitFields``).\n    /// \\code\n    ///   unsigned bf:2;\n    /// \\endcode\n    BFCS_None,\n    /// Add space before the ``:`` only\n    /// \\code\n    ///   unsigned bf :2;\n    /// \\endcode\n    BFCS_Before,\n    /// Add space after the ``:`` only (space may be added before if\n    /// needed for ``AlignConsecutiveBitFields``).\n    /// \\code\n    ///   unsigned bf: 2;\n    /// \\endcode\n    BFCS_After\n  };\n  /// The BitFieldColonSpacingStyle to use for bitfields.\n  BitFieldColonSpacingStyle BitFieldColonSpacing;\n\n  /// Supported language standards for parsing and formatting C++ constructs.\n  /// \\code\n  ///    Latest:                                vector<set<int>>\n  ///    c++03                          vs.     vector<set<int> >\n  /// \\endcode\n  ///\n  /// The correct way to spell a specific language version is e.g. ``c++11``.\n  /// The historical aliases ``Cpp03`` and ``Cpp11`` are deprecated.\n  enum LanguageStandard : unsigned char {\n    /// Parse and format as C++03.\n    /// ``Cpp03`` is a deprecated alias for ``c++03``\n    LS_Cpp03, // c++03\n    /// Parse and format as C++11.\n    LS_Cpp11, // c++11\n    /// Parse and format as C++14.\n    LS_Cpp14, // c++14\n    /// Parse and format as C++17.\n    LS_Cpp17, // c++17\n    /// Parse and format as C++20.\n    LS_Cpp20, // c++20\n    /// Parse and format using the latest supported language version.\n    /// ``Cpp11`` is a deprecated alias for ``Latest``\n    LS_Latest,\n    /// Automatic detection based on the input.\n    LS_Auto,\n  };\n\n  /// Parse and format C++ constructs compatible with this standard.\n  /// \\code\n  ///    c++03:                                 latest:\n  ///    vector<set<int> > x;           vs.     vector<set<int>> x;\n  /// \\endcode\n  LanguageStandard Standard;\n\n  /// Macros which are ignored in front of a statement, as if they were an\n  /// attribute. So that they are not parsed as identifier, for example for Qts\n  /// emit.\n  /// \\code\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: []\n  ///   unsigned char data = 'x';\n  ///   emit          signal(data); // This is parsed as variable declaration.\n  ///\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: [emit]\n  ///   unsigned char data = 'x';\n  ///   emit signal(data); // Now it's fine again.\n  /// \\endcode\n  std::vector<std::string> StatementAttributeLikeMacros;\n\n  /// The number of columns used for tab stops.\n  unsigned TabWidth;\n\n  /// Different ways to use tab in formatting.\n  enum UseTabStyle : unsigned char {\n    /// Never use tab.\n    UT_Never,\n    /// Use tabs only for indentation.\n    UT_ForIndentation,\n    /// Fill all leading whitespace with tabs, and use spaces for alignment that\n    /// appears within a line (e.g. consecutive assignments and declarations).\n    UT_ForContinuationAndIndentation,\n    /// Use tabs for line continuation and indentation, and spaces for\n    /// alignment.\n    UT_AlignWithSpaces,\n    /// Use tabs whenever we need to fill whitespace that spans at least from\n    /// one tab stop to the next one.\n    UT_Always\n  };\n\n  /// \\brief Use ``\\r\\n`` instead of ``\\n`` for line breaks.\n  /// Also used as fallback if ``DeriveLineEnding`` is true.\n  bool UseCRLF;\n\n  /// The way to use tab characters in the resulting file.\n  UseTabStyle UseTab;\n\n  bool operator==(const FormatStyle &R) const {\n    return AccessModifierOffset == R.AccessModifierOffset &&\n           AlignAfterOpenBracket == R.AlignAfterOpenBracket &&\n           AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &&\n           AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &&\n           AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &&\n           AlignConsecutiveMacros == R.AlignConsecutiveMacros &&\n           AlignEscapedNewlines == R.AlignEscapedNewlines &&\n           AlignOperands == R.AlignOperands &&\n           AlignTrailingComments == R.AlignTrailingComments &&\n           AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &&\n           AllowAllConstructorInitializersOnNextLine ==\n               R.AllowAllConstructorInitializersOnNextLine &&\n           AllowAllParametersOfDeclarationOnNextLine ==\n               R.AllowAllParametersOfDeclarationOnNextLine &&\n           AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &&\n           AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &&\n           AllowShortCaseLabelsOnASingleLine ==\n               R.AllowShortCaseLabelsOnASingleLine &&\n           AllowShortFunctionsOnASingleLine ==\n               R.AllowShortFunctionsOnASingleLine &&\n           AllowShortIfStatementsOnASingleLine ==\n               R.AllowShortIfStatementsOnASingleLine &&\n           AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &&\n           AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &&\n           AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &&\n           AlwaysBreakBeforeMultilineStrings ==\n               R.AlwaysBreakBeforeMultilineStrings &&\n           AlwaysBreakTemplateDeclarations ==\n               R.AlwaysBreakTemplateDeclarations &&\n           AttributeMacros == R.AttributeMacros &&\n           BinPackArguments == R.BinPackArguments &&\n           BinPackParameters == R.BinPackParameters &&\n           BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &&\n           BreakBeforeBraces == R.BreakBeforeBraces &&\n           BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &&\n           BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &&\n           BreakConstructorInitializers == R.BreakConstructorInitializers &&\n           CompactNamespaces == R.CompactNamespaces &&\n           BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &&\n           BreakStringLiterals == R.BreakStringLiterals &&\n           ColumnLimit == R.ColumnLimit && CommentPragmas == R.CommentPragmas &&\n           BreakInheritanceList == R.BreakInheritanceList &&\n           ConstructorInitializerAllOnOneLineOrOnePerLine ==\n               R.ConstructorInitializerAllOnOneLineOrOnePerLine &&\n           ConstructorInitializerIndentWidth ==\n               R.ConstructorInitializerIndentWidth &&\n           ContinuationIndentWidth == R.ContinuationIndentWidth &&\n           Cpp11BracedListStyle == R.Cpp11BracedListStyle &&\n           DeriveLineEnding == R.DeriveLineEnding &&\n           DerivePointerAlignment == R.DerivePointerAlignment &&\n           DisableFormat == R.DisableFormat &&\n           EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &&\n           ExperimentalAutoDetectBinPacking ==\n               R.ExperimentalAutoDetectBinPacking &&\n           FixNamespaceComments == R.FixNamespaceComments &&\n           ForEachMacros == R.ForEachMacros &&\n           IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &&\n           IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &&\n           IncludeStyle.IncludeIsMainRegex ==\n               R.IncludeStyle.IncludeIsMainRegex &&\n           IncludeStyle.IncludeIsMainSourceRegex ==\n               R.IncludeStyle.IncludeIsMainSourceRegex &&\n           IndentAccessModifiers == R.IndentAccessModifiers &&\n           IndentCaseLabels == R.IndentCaseLabels &&\n           IndentCaseBlocks == R.IndentCaseBlocks &&\n           IndentGotoLabels == R.IndentGotoLabels &&\n           IndentPPDirectives == R.IndentPPDirectives &&\n           IndentExternBlock == R.IndentExternBlock &&\n           IndentRequires == R.IndentRequires && IndentWidth == R.IndentWidth &&\n           Language == R.Language &&\n           IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &&\n           JavaImportGroups == R.JavaImportGroups &&\n           JavaScriptQuotes == R.JavaScriptQuotes &&\n           JavaScriptWrapImports == R.JavaScriptWrapImports &&\n           KeepEmptyLinesAtTheStartOfBlocks ==\n               R.KeepEmptyLinesAtTheStartOfBlocks &&\n           MacroBlockBegin == R.MacroBlockBegin &&\n           MacroBlockEnd == R.MacroBlockEnd &&\n           MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &&\n           NamespaceIndentation == R.NamespaceIndentation &&\n           NamespaceMacros == R.NamespaceMacros &&\n           ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &&\n           ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &&\n           ObjCBreakBeforeNestedBlockParam ==\n               R.ObjCBreakBeforeNestedBlockParam &&\n           ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &&\n           ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &&\n           PenaltyBreakAssignment == R.PenaltyBreakAssignment &&\n           PenaltyBreakBeforeFirstCallParameter ==\n               R.PenaltyBreakBeforeFirstCallParameter &&\n           PenaltyBreakComment == R.PenaltyBreakComment &&\n           PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &&\n           PenaltyBreakString == R.PenaltyBreakString &&\n           PenaltyExcessCharacter == R.PenaltyExcessCharacter &&\n           PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &&\n           PenaltyBreakTemplateDeclaration ==\n               R.PenaltyBreakTemplateDeclaration &&\n           PointerAlignment == R.PointerAlignment &&\n           RawStringFormats == R.RawStringFormats &&\n           ShortNamespaceLines == R.ShortNamespaceLines &&\n           SortIncludes == R.SortIncludes &&\n           SortJavaStaticImport == R.SortJavaStaticImport &&\n           SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &&\n           SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &&\n           SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &&\n           SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &&\n           SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &&\n           SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &&\n           SpaceBeforeCtorInitializerColon ==\n               R.SpaceBeforeCtorInitializerColon &&\n           SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &&\n           SpaceBeforeParens == R.SpaceBeforeParens &&\n           SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &&\n           SpaceBeforeRangeBasedForLoopColon ==\n               R.SpaceBeforeRangeBasedForLoopColon &&\n           SpaceInEmptyBlock == R.SpaceInEmptyBlock &&\n           SpaceInEmptyParentheses == R.SpaceInEmptyParentheses &&\n           SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &&\n           SpacesInAngles == R.SpacesInAngles &&\n           SpacesInConditionalStatement == R.SpacesInConditionalStatement &&\n           SpacesInContainerLiterals == R.SpacesInContainerLiterals &&\n           SpacesInCStyleCastParentheses == R.SpacesInCStyleCastParentheses &&\n           SpacesInLineCommentPrefix.Minimum ==\n               R.SpacesInLineCommentPrefix.Minimum &&\n           SpacesInLineCommentPrefix.Maximum ==\n               R.SpacesInLineCommentPrefix.Maximum &&\n           SpacesInParentheses == R.SpacesInParentheses &&\n           SpacesInSquareBrackets == R.SpacesInSquareBrackets &&\n           SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &&\n           BitFieldColonSpacing == R.BitFieldColonSpacing &&\n           Standard == R.Standard &&\n           StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &&\n           StatementMacros == R.StatementMacros && TabWidth == R.TabWidth &&\n           UseTab == R.UseTab && UseCRLF == R.UseCRLF &&\n           TypenameMacros == R.TypenameMacros;\n  }\n\n  llvm::Optional<FormatStyle> GetLanguageStyle(LanguageKind Language) const;\n\n  // Stores per-language styles. A FormatStyle instance inside has an empty\n  // StyleSet. A FormatStyle instance returned by the Get method has its\n  // StyleSet set to a copy of the originating StyleSet, effectively keeping the\n  // internal representation of that StyleSet alive.\n  //\n  // The memory management and ownership reminds of a birds nest: chicks\n  // leaving the nest take photos of the nest with them.\n  struct FormatStyleSet {\n    typedef std::map<FormatStyle::LanguageKind, FormatStyle> MapType;\n\n    llvm::Optional<FormatStyle> Get(FormatStyle::LanguageKind Language) const;\n\n    // Adds \\p Style to this FormatStyleSet. Style must not have an associated\n    // FormatStyleSet.\n    // Style.Language should be different than LK_None. If this FormatStyleSet\n    // already contains an entry for Style.Language, that gets replaced with the\n    // passed Style.\n    void Add(FormatStyle Style);\n\n    // Clears this FormatStyleSet.\n    void Clear();\n\n  private:\n    std::shared_ptr<MapType> Styles;\n  };\n\n  static FormatStyleSet BuildStyleSetFromConfiguration(\n      const FormatStyle &MainStyle,\n      const std::vector<FormatStyle> &ConfigurationStyles);\n\nprivate:\n  FormatStyleSet StyleSet;\n\n  friend std::error_code\n  parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                     bool AllowUnknownOptions,\n                     llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                     void *DiagHandlerCtxt);\n};\n\n/// Returns a format style complying with the LLVM coding standards:\n/// http://llvm.org/docs/CodingStandards.html.\nFormatStyle getLLVMStyle(\n    FormatStyle::LanguageKind Language = FormatStyle::LanguageKind::LK_Cpp);\n\n/// Returns a format style complying with one of Google's style guides:\n/// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.\n/// http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml.\n/// https://developers.google.com/protocol-buffers/docs/style.\nFormatStyle getGoogleStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Chromium's style guide:\n/// http://www.chromium.org/developers/coding-style.\nFormatStyle getChromiumStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Mozilla's style guide:\n/// https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style.\nFormatStyle getMozillaStyle();\n\n/// Returns a format style complying with Webkit's style guide:\n/// http://www.webkit.org/coding/coding-style.html\nFormatStyle getWebKitStyle();\n\n/// Returns a format style complying with GNU Coding Standards:\n/// http://www.gnu.org/prep/standards/standards.html\nFormatStyle getGNUStyle();\n\n/// Returns a format style complying with Microsoft style guide:\n/// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017\nFormatStyle getMicrosoftStyle(FormatStyle::LanguageKind Language);\n\n/// Returns style indicating formatting should be not applied at all.\nFormatStyle getNoStyle();\n\n/// Gets a predefined style for the specified language by name.\n///\n/// Currently supported names: LLVM, Google, Chromium, Mozilla. Names are\n/// compared case-insensitively.\n///\n/// Returns ``true`` if the Style has been set.\nbool getPredefinedStyle(StringRef Name, FormatStyle::LanguageKind Language,\n                        FormatStyle *Style);\n\n/// Parse configuration from YAML-formatted text.\n///\n/// Style->Language is used to get the base style, if the ``BasedOnStyle``\n/// option is present.\n///\n/// The FormatStyleSet of Style is reset.\n///\n/// When ``BasedOnStyle`` is not present, options not present in the YAML\n/// document, are retained in \\p Style.\n///\n/// If AllowUnknownOptions is true, no errors are emitted if unknown\n/// format options are occured.\n///\n/// If set all diagnostics are emitted through the DiagHandler.\nstd::error_code\nparseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                   bool AllowUnknownOptions = false,\n                   llvm::SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n                   void *DiagHandlerCtx = nullptr);\n\n/// Like above but accepts an unnamed buffer.\ninline std::error_code parseConfiguration(StringRef Config, FormatStyle *Style,\n                                          bool AllowUnknownOptions = false) {\n  return parseConfiguration(llvm::MemoryBufferRef(Config, \"YAML\"), Style,\n                            AllowUnknownOptions);\n}\n\n/// Gets configuration in a YAML string.\nstd::string configurationAsText(const FormatStyle &Style);\n\n/// Returns the replacements necessary to sort all ``#include`` blocks\n/// that are affected by ``Ranges``.\ntooling::Replacements sortIncludes(const FormatStyle &Style, StringRef Code,\n                                   ArrayRef<tooling::Range> Ranges,\n                                   StringRef FileName,\n                                   unsigned *Cursor = nullptr);\n\n/// Returns the replacements corresponding to applying and formatting\n/// \\p Replaces on success; otheriwse, return an llvm::Error carrying\n/// llvm::StringError.\nllvm::Expected<tooling::Replacements>\nformatReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                   const FormatStyle &Style);\n\n/// Returns the replacements corresponding to applying \\p Replaces and\n/// cleaning up the code after that on success; otherwise, return an llvm::Error\n/// carrying llvm::StringError.\n/// This also supports inserting/deleting C++ #include directives:\n/// - If a replacement has offset UINT_MAX, length 0, and a replacement text\n///   that is an #include directive, this will insert the #include into the\n///   correct block in the \\p Code.\n/// - If a replacement has offset UINT_MAX, length 1, and a replacement text\n///   that is the name of the header to be removed, the header will be removed\n///   from \\p Code if it exists.\n/// The include manipulation is done via `tooling::HeaderInclude`, see its\n/// documentation for more details on how include insertion points are found and\n/// what edits are produced.\nllvm::Expected<tooling::Replacements>\ncleanupAroundReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                          const FormatStyle &Style);\n\n/// Represents the status of a formatting attempt.\nstruct FormattingAttemptStatus {\n  /// A value of ``false`` means that any of the affected ranges were not\n  /// formatted due to a non-recoverable syntax error.\n  bool FormatComplete = true;\n\n  /// If ``FormatComplete`` is false, ``Line`` records a one-based\n  /// original line number at which a syntax error might have occurred. This is\n  /// based on a best-effort analysis and could be imprecise.\n  unsigned Line = 0;\n};\n\n/// Reformats the given \\p Ranges in \\p Code.\n///\n/// Each range is extended on either end to its next bigger logic unit, i.e.\n/// everything that might influence its formatting or might be influenced by its\n/// formatting.\n///\n/// Returns the ``Replacements`` necessary to make all \\p Ranges comply with\n/// \\p Style.\n///\n/// If ``Status`` is non-null, its value will be populated with the status of\n/// this formatting attempt. See \\c FormattingAttemptStatus.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName = \"<stdin>\",\n                               FormattingAttemptStatus *Status = nullptr);\n\n/// Same as above, except if ``IncompleteFormat`` is non-null, its value\n/// will be set to true if any of the affected ranges were not formatted due to\n/// a non-recoverable syntax error.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName, bool *IncompleteFormat);\n\n/// Clean up any erroneous/redundant code in the given \\p Ranges in \\p\n/// Code.\n///\n/// Returns the ``Replacements`` that clean up all \\p Ranges in \\p Code.\ntooling::Replacements cleanup(const FormatStyle &Style, StringRef Code,\n                              ArrayRef<tooling::Range> Ranges,\n                              StringRef FileName = \"<stdin>\");\n\n/// Fix namespace end comments in the given \\p Ranges in \\p Code.\n///\n/// Returns the ``Replacements`` that fix the namespace comments in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements fixNamespaceEndComments(const FormatStyle &Style,\n                                              StringRef Code,\n                                              ArrayRef<tooling::Range> Ranges,\n                                              StringRef FileName = \"<stdin>\");\n\n/// Sort consecutive using declarations in the given \\p Ranges in\n/// \\p Code.\n///\n/// Returns the ``Replacements`` that sort the using declarations in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements sortUsingDeclarations(const FormatStyle &Style,\n                                            StringRef Code,\n                                            ArrayRef<tooling::Range> Ranges,\n                                            StringRef FileName = \"<stdin>\");\n\n/// Returns the ``LangOpts`` that the formatter expects you to set.\n///\n/// \\param Style determines specific settings for lexing mode.\nLangOptions getFormattingLangOpts(const FormatStyle &Style = getLLVMStyle());\n\n/// Description to be used for help text for a ``llvm::cl`` option for\n/// specifying format style. The description is closely related to the operation\n/// of ``getStyle()``.\nextern const char *StyleOptionHelpDescription;\n\n/// The suggested format style to use by default. This allows tools using\n/// `getStyle` to have a consistent default style.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFormatStyle;\n\n/// The suggested predefined style to use as the fallback style in `getStyle`.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFallbackStyle;\n\n/// Construct a FormatStyle based on ``StyleName``.\n///\n/// ``StyleName`` can take several forms:\n/// * \"{<key>: <value>, ...}\" - Set specic style parameters.\n/// * \"<style name>\" - One of the style names supported by\n/// getPredefinedStyle().\n/// * \"file\" - Load style configuration from a file called ``.clang-format``\n/// located in one of the parent directories of ``FileName`` or the current\n/// directory if ``FileName`` is empty.\n///\n/// \\param[in] StyleName Style name to interpret according to the description\n/// above.\n/// \\param[in] FileName Path to start search for .clang-format if ``StyleName``\n/// == \"file\".\n/// \\param[in] FallbackStyle The name of a predefined style used to fallback to\n/// in case \\p StyleName is \"file\" and no file can be found.\n/// \\param[in] Code The actual code to be formatted. Used to determine the\n/// language if the filename isn't sufficient.\n/// \\param[in] FS The underlying file system, in which the file resides. By\n/// default, the file system is the real file system.\n/// \\param[in] AllowUnknownOptions If true, unknown format options only\n///             emit a warning. If false, errors are emitted on unknown format\n///             options.\n///\n/// \\returns FormatStyle as specified by ``StyleName``. If ``StyleName`` is\n/// \"file\" and no file is found, returns ``FallbackStyle``. If no style could be\n/// determined, returns an Error.\nllvm::Expected<FormatStyle> getStyle(StringRef StyleName, StringRef FileName,\n                                     StringRef FallbackStyle,\n                                     StringRef Code = \"\",\n                                     llvm::vfs::FileSystem *FS = nullptr,\n                                     bool AllowUnknownOptions = false);\n\n// Guesses the language from the ``FileName`` and ``Code`` to be formatted.\n// Defaults to FormatStyle::LK_Cpp.\nFormatStyle::LanguageKind guessLanguage(StringRef FileName, StringRef Code);\n\n// Returns a string representation of ``Language``.\ninline StringRef getLanguageName(FormatStyle::LanguageKind Language) {\n  switch (Language) {\n  case FormatStyle::LK_Cpp:\n    return \"C++\";\n  case FormatStyle::LK_CSharp:\n    return \"CSharp\";\n  case FormatStyle::LK_ObjC:\n    return \"Objective-C\";\n  case FormatStyle::LK_Java:\n    return \"Java\";\n  case FormatStyle::LK_JavaScript:\n    return \"JavaScript\";\n  case FormatStyle::LK_Proto:\n    return \"Proto\";\n  case FormatStyle::LK_TableGen:\n    return \"TableGen\";\n  case FormatStyle::LK_TextProto:\n    return \"TextProto\";\n  default:\n    return \"Unknown\";\n  }\n}\n\n} // end namespace format\n} // end namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::format::ParseError> : std::true_type {};\n} // namespace std\n\n#endif // LLVM_CLANG_FORMAT_FORMAT_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "content": "//===--- PrecompiledPreamble.h - Build precompiled preambles ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Helper class to build precompiled preamble.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n#define LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cstddef>\n#include <memory>\n#include <system_error>\n#include <type_traits>\n\nnamespace llvm {\nclass MemoryBuffer;\nclass MemoryBufferRef;\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\nclass CompilerInstance;\nclass CompilerInvocation;\nclass Decl;\nclass DeclGroupRef;\nclass PCHContainerOperations;\n\n/// Runs lexer to compute suggested preamble bounds.\nPreambleBounds ComputePreambleBounds(const LangOptions &LangOpts,\n                                     const llvm::MemoryBufferRef &Buffer,\n                                     unsigned MaxLines);\n\nclass PreambleCallbacks;\n\n/// A class holding a PCH and all information to check whether it is valid to\n/// reuse the PCH for the subsequent runs. Use BuildPreamble to create PCH and\n/// CanReusePreamble + AddImplicitPreamble to make use of it.\nclass PrecompiledPreamble {\n  class PCHStorage;\n  struct PreambleFileHash;\n\npublic:\n  /// Try to build PrecompiledPreamble for \\p Invocation. See\n  /// BuildPreambleError for possible error codes.\n  ///\n  /// \\param Invocation Original CompilerInvocation with options to compile the\n  /// file.\n  ///\n  /// \\param MainFileBuffer Buffer with the contents of the main file.\n  ///\n  /// \\param Bounds Bounds of the preamble, result of calling\n  /// ComputePreambleBounds.\n  ///\n  /// \\param Diagnostics Diagnostics engine to be used while building the\n  /// preamble.\n  ///\n  /// \\param VFS An instance of vfs::FileSystem to be used for file\n  /// accesses.\n  ///\n  /// \\param PCHContainerOps An instance of PCHContainerOperations.\n  ///\n  /// \\param StoreInMemory Store PCH in memory. If false, PCH will be stored in\n  /// a temporary file.\n  ///\n  /// \\param Callbacks A set of callbacks to be executed when building\n  /// the preamble.\n  static llvm::ErrorOr<PrecompiledPreamble>\n  Build(const CompilerInvocation &Invocation,\n        const llvm::MemoryBuffer *MainFileBuffer, PreambleBounds Bounds,\n        DiagnosticsEngine &Diagnostics,\n        IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS,\n        std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n        bool StoreInMemory, PreambleCallbacks &Callbacks);\n\n  PrecompiledPreamble(PrecompiledPreamble &&) = default;\n  PrecompiledPreamble &operator=(PrecompiledPreamble &&) = default;\n\n  /// PreambleBounds used to build the preamble.\n  PreambleBounds getBounds() const;\n\n  /// Returns the size, in bytes, that preamble takes on disk or in memory.\n  /// For on-disk preambles returns 0 if filesystem operations fail. Intended to\n  /// be used for logging and debugging purposes only.\n  std::size_t getSize() const;\n\n  /// Returned string is not null-terminated.\n  llvm::StringRef getContents() const {\n    return {PreambleBytes.data(), PreambleBytes.size()};\n  }\n\n  /// Check whether PrecompiledPreamble can be reused for the new contents(\\p\n  /// MainFileBuffer) of the main file.\n  bool CanReuse(const CompilerInvocation &Invocation,\n                const llvm::MemoryBufferRef &MainFileBuffer,\n                PreambleBounds Bounds, llvm::vfs::FileSystem &VFS) const;\n\n  /// Changes options inside \\p CI to use PCH from this preamble. Also remaps\n  /// main file to \\p MainFileBuffer and updates \\p VFS to ensure the preamble\n  /// is accessible.\n  /// Requires that CanReuse() is true.\n  /// For in-memory preambles, PrecompiledPreamble instance continues to own the\n  /// MemoryBuffer with the Preamble after this method returns. The caller is\n  /// responsible for making sure the PrecompiledPreamble instance outlives the\n  /// compiler run and the AST that will be using the PCH.\n  void AddImplicitPreamble(CompilerInvocation &CI,\n                           IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                           llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Configure \\p CI to use this preamble.\n  /// Like AddImplicitPreamble, but doesn't assume CanReuse() is true.\n  /// If this preamble does not match the file, it may parse differently.\n  void OverridePreamble(CompilerInvocation &CI,\n                        IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                        llvm::MemoryBuffer *MainFileBuffer) const;\n\nprivate:\n  PrecompiledPreamble(PCHStorage Storage, std::vector<char> PreambleBytes,\n                      bool PreambleEndsAtStartOfLine,\n                      llvm::StringMap<PreambleFileHash> FilesInPreamble,\n                      llvm::StringSet<> MissingFiles);\n\n  /// A temp file that would be deleted on destructor call. If destructor is not\n  /// called for any reason, the file will be deleted at static objects'\n  /// destruction.\n  /// An assertion will fire if two TempPCHFiles are created with the same name,\n  /// so it's not intended to be used outside preamble-handling.\n  class TempPCHFile {\n  public:\n    // A main method used to construct TempPCHFile.\n    static llvm::ErrorOr<TempPCHFile> CreateNewPreamblePCHFile();\n\n  private:\n    TempPCHFile(std::string FilePath);\n\n  public:\n    TempPCHFile(TempPCHFile &&Other);\n    TempPCHFile &operator=(TempPCHFile &&Other);\n\n    TempPCHFile(const TempPCHFile &) = delete;\n    ~TempPCHFile();\n\n    /// A path where temporary file is stored.\n    llvm::StringRef getFilePath() const;\n\n  private:\n    void RemoveFileIfPresent();\n\n  private:\n    llvm::Optional<std::string> FilePath;\n  };\n\n  class InMemoryPreamble {\n  public:\n    std::string Data;\n  };\n\n  class PCHStorage {\n  public:\n    enum class Kind { Empty, InMemory, TempFile };\n\n    PCHStorage() = default;\n    PCHStorage(TempPCHFile File);\n    PCHStorage(InMemoryPreamble Memory);\n\n    PCHStorage(const PCHStorage &) = delete;\n    PCHStorage &operator=(const PCHStorage &) = delete;\n\n    PCHStorage(PCHStorage &&Other);\n    PCHStorage &operator=(PCHStorage &&Other);\n\n    ~PCHStorage();\n\n    Kind getKind() const;\n\n    TempPCHFile &asFile();\n    const TempPCHFile &asFile() const;\n\n    InMemoryPreamble &asMemory();\n    const InMemoryPreamble &asMemory() const;\n\n  private:\n    void destroy();\n    void setEmpty();\n\n  private:\n    Kind StorageKind = Kind::Empty;\n    llvm::AlignedCharArrayUnion<TempPCHFile, InMemoryPreamble> Storage = {};\n  };\n\n  /// Data used to determine if a file used in the preamble has been changed.\n  struct PreambleFileHash {\n    /// All files have size set.\n    off_t Size = 0;\n\n    /// Modification time is set for files that are on disk.  For memory\n    /// buffers it is zero.\n    time_t ModTime = 0;\n\n    /// Memory buffers have MD5 instead of modification time.  We don't\n    /// compute MD5 for on-disk files because we hope that modification time is\n    /// enough to tell if the file was changed.\n    llvm::MD5::MD5Result MD5 = {};\n\n    static PreambleFileHash createForFile(off_t Size, time_t ModTime);\n    static PreambleFileHash\n    createForMemoryBuffer(const llvm::MemoryBufferRef &Buffer);\n\n    friend bool operator==(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return LHS.Size == RHS.Size && LHS.ModTime == RHS.ModTime &&\n             LHS.MD5 == RHS.MD5;\n    }\n    friend bool operator!=(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return !(LHS == RHS);\n    }\n  };\n\n  /// Helper function to set up PCH for the preamble into \\p CI and \\p VFS to\n  /// with the specified \\p Bounds.\n  void configurePreamble(PreambleBounds Bounds, CompilerInvocation &CI,\n                         IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                         llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Sets up the PreprocessorOptions and changes VFS, so that PCH stored in \\p\n  /// Storage is accessible to clang. This method is an implementation detail of\n  /// AddImplicitPreamble.\n  static void\n  setupPreambleStorage(const PCHStorage &Storage,\n                       PreprocessorOptions &PreprocessorOpts,\n                       IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS);\n\n  /// Manages the memory buffer or temporary file that stores the PCH.\n  PCHStorage Storage;\n  /// Keeps track of the files that were used when computing the\n  /// preamble, with both their buffer size and their modification time.\n  ///\n  /// If any of the files have changed from one compile to the next,\n  /// the preamble must be thrown away.\n  llvm::StringMap<PreambleFileHash> FilesInPreamble;\n  /// Files that were not found during preamble building. If any of these now\n  /// exist then the preamble should not be reused.\n  ///\n  /// Storing *all* the missing files that could invalidate the preamble would\n  /// make it too expensive to revalidate (when the include path has many\n  /// entries, each #include will miss half of them on average).\n  /// Instead, we track only files that could have satisfied an #include that\n  /// was ultimately not found.\n  llvm::StringSet<> MissingFiles;\n  /// The contents of the file that was used to precompile the preamble. Only\n  /// contains first PreambleBounds::Size bytes. Used to compare if the relevant\n  /// part of the file has not changed, so that preamble can be reused.\n  std::vector<char> PreambleBytes;\n  /// See PreambleBounds::PreambleEndsAtStartOfLine\n  bool PreambleEndsAtStartOfLine;\n};\n\n/// A set of callbacks to gather useful information while building a preamble.\nclass PreambleCallbacks {\npublic:\n  virtual ~PreambleCallbacks() = default;\n\n  /// Called before FrontendAction::BeginSourceFile.\n  /// Can be used to store references to various CompilerInstance fields\n  /// (e.g. SourceManager) that may be interesting to the consumers of other\n  /// callbacks.\n  virtual void BeforeExecute(CompilerInstance &CI);\n  /// Called after FrontendAction::Execute(), but before\n  /// FrontendAction::EndSourceFile(). Can be used to transfer ownership of\n  /// various CompilerInstance fields before they are destroyed.\n  virtual void AfterExecute(CompilerInstance &CI);\n  /// Called after PCH has been emitted. \\p Writer may be used to retrieve\n  /// information about AST, serialized in PCH.\n  virtual void AfterPCHEmitted(ASTWriter &Writer);\n  /// Called for each TopLevelDecl.\n  /// NOTE: To allow more flexibility a custom ASTConsumer could probably be\n  /// used instead, but having only this method allows a simpler API.\n  virtual void HandleTopLevelDecl(DeclGroupRef DG);\n  /// Creates wrapper class for PPCallbacks so we can also process information\n  /// about includes that are inside of a preamble\n  virtual std::unique_ptr<PPCallbacks> createPPCallbacks();\n  /// The returned CommentHandler will be added to the preprocessor if not null.\n  virtual CommentHandler *getCommentHandler();\n  /// Determines which function bodies are parsed, by default skips everything.\n  /// Only used if FrontendOpts::SkipFunctionBodies is true.\n  /// See ASTConsumer::shouldSkipFunctionBody.\n  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }\n};\n\nenum class BuildPreambleError {\n  CouldntCreateTempFile = 1,\n  CouldntCreateTargetInfo,\n  BeginSourceFileFailed,\n  CouldntEmitPCH,\n  BadInputs\n};\n\nclass BuildPreambleErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int condition) const override;\n};\n\nstd::error_code make_error_code(BuildPreambleError Error);\n} // namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::BuildPreambleError> : std::true_type {};\n} // namespace std\n\n#endif\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "content": "//===- ModuleMap.h - Describe the layout of modules -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ModuleMap interface, which describes the layout of a\n// module as it relates to headers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MODULEMAP_H\n#define LLVM_CLANG_LEX_MODULEMAP_H\n\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <ctime>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass DiagnosticsEngine;\nclass DirectoryEntry;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearch;\nclass SourceManager;\n\n/// A mechanism to observe the actions of the module map parser as it\n/// reads module map files.\nclass ModuleMapCallbacks {\n  virtual void anchor();\n\npublic:\n  virtual ~ModuleMapCallbacks() = default;\n\n  /// Called when a module map file has been read.\n  ///\n  /// \\param FileStart A SourceLocation referring to the start of the file's\n  /// contents.\n  /// \\param File The file itself.\n  /// \\param IsSystem Whether this is a module map from a system include path.\n  virtual void moduleMapFileRead(SourceLocation FileStart,\n                                 const FileEntry &File, bool IsSystem) {}\n\n  /// Called when a header is added during module map parsing.\n  ///\n  /// \\param Filename The header file itself.\n  virtual void moduleMapAddHeader(StringRef Filename) {}\n\n  /// Called when an umbrella header is added during module map parsing.\n  ///\n  /// \\param FileMgr FileManager instance\n  /// \\param Header The umbrella header to collect.\n  virtual void moduleMapAddUmbrellaHeader(FileManager *FileMgr,\n                                          const FileEntry *Header) {}\n};\n\nclass ModuleMap {\n  SourceManager &SourceMgr;\n  DiagnosticsEngine &Diags;\n  const LangOptions &LangOpts;\n  const TargetInfo *Target;\n  HeaderSearch &HeaderInfo;\n\n  llvm::SmallVector<std::unique_ptr<ModuleMapCallbacks>, 1> Callbacks;\n\n  /// The directory used for Clang-supplied, builtin include headers,\n  /// such as \"stdint.h\".\n  const DirectoryEntry *BuiltinIncludeDir = nullptr;\n\n  /// Language options used to parse the module map itself.\n  ///\n  /// These are always simple C language options.\n  LangOptions MMapLangOpts;\n\n  /// The module that the main source file is associated with (the module\n  /// named LangOpts::CurrentModule, if we've loaded it).\n  Module *SourceModule = nullptr;\n\n  /// Submodules of the current module that have not yet been attached to it.\n  /// (Ownership is transferred if/when we create an enclosing module.)\n  llvm::SmallVector<std::unique_ptr<Module>, 8> PendingSubmodules;\n\n  /// The top-level modules that are known.\n  llvm::StringMap<Module *> Modules;\n\n  /// Module loading cache that includes submodules, indexed by IdentifierInfo.\n  /// nullptr is stored for modules that are known to fail to load.\n  llvm::DenseMap<const IdentifierInfo *, Module *> CachedModuleLoads;\n\n  /// Shadow modules created while building this module map.\n  llvm::SmallVector<Module*, 2> ShadowModules;\n\n  /// The number of modules we have created in total.\n  unsigned NumCreatedModules = 0;\n\n  /// In case a module has a export_as entry, it might have a pending link\n  /// name to be determined if that module is imported.\n  llvm::StringMap<llvm::StringSet<>> PendingLinkAsModule;\n\npublic:\n  /// Use PendingLinkAsModule information to mark top level link names that\n  /// are going to be replaced by export_as aliases.\n  void resolveLinkAsDependencies(Module *Mod);\n\n  /// Make module to use export_as as the link dependency name if enough\n  /// information is available or add it to a pending list otherwise.\n  void addLinkAsDependency(Module *Mod);\n\n  /// Flags describing the role of a module header.\n  enum ModuleHeaderRole {\n    /// This header is normally included in the module.\n    NormalHeader  = 0x0,\n\n    /// This header is included but private.\n    PrivateHeader = 0x1,\n\n    /// This header is part of the module (for layering purposes) but\n    /// should be textually included.\n    TextualHeader = 0x2,\n\n    // Caution: Adding an enumerator needs other changes.\n    // Adjust the number of bits for KnownHeader::Storage.\n    // Adjust the bitfield HeaderFileInfo::HeaderRole size.\n    // Adjust the HeaderFileInfoTrait::ReadData streaming.\n    // Adjust the HeaderFileInfoTrait::EmitData streaming.\n    // Adjust ModuleMap::addHeader.\n  };\n\n  /// Convert a header kind to a role. Requires Kind to not be HK_Excluded.\n  static ModuleHeaderRole headerKindToRole(Module::HeaderKind Kind);\n\n  /// Convert a header role to a kind.\n  static Module::HeaderKind headerRoleToKind(ModuleHeaderRole Role);\n\n  /// A header that is known to reside within a given module,\n  /// whether it was included or excluded.\n  class KnownHeader {\n    llvm::PointerIntPair<Module *, 2, ModuleHeaderRole> Storage;\n\n  public:\n    KnownHeader() : Storage(nullptr, NormalHeader) {}\n    KnownHeader(Module *M, ModuleHeaderRole Role) : Storage(M, Role) {}\n\n    friend bool operator==(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage == B.Storage;\n    }\n    friend bool operator!=(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage != B.Storage;\n    }\n\n    /// Retrieve the module the header is stored in.\n    Module *getModule() const { return Storage.getPointer(); }\n\n    /// The role of this header within the module.\n    ModuleHeaderRole getRole() const { return Storage.getInt(); }\n\n    /// Whether this header is available in the module.\n    bool isAvailable() const {\n      return getModule()->isAvailable();\n    }\n\n    /// Whether this header is accessible from the specified module.\n    bool isAccessibleFrom(Module *M) const {\n      return !(getRole() & PrivateHeader) ||\n             (M && M->getTopLevelModule() == getModule()->getTopLevelModule());\n    }\n\n    // Whether this known header is valid (i.e., it has an\n    // associated module).\n    explicit operator bool() const {\n      return Storage.getPointer() != nullptr;\n    }\n  };\n\n  using AdditionalModMapsSet = llvm::SmallPtrSet<const FileEntry *, 1>;\n\nprivate:\n  friend class ModuleMapParser;\n\n  using HeadersMap =\n      llvm::DenseMap<const FileEntry *, SmallVector<KnownHeader, 1>>;\n\n  /// Mapping from each header to the module that owns the contents of\n  /// that header.\n  HeadersMap Headers;\n\n  /// Map from file sizes to modules with lazy header directives of that size.\n  mutable llvm::DenseMap<off_t, llvm::TinyPtrVector<Module*>> LazyHeadersBySize;\n\n  /// Map from mtimes to modules with lazy header directives with those mtimes.\n  mutable llvm::DenseMap<time_t, llvm::TinyPtrVector<Module*>>\n              LazyHeadersByModTime;\n\n  /// Mapping from directories with umbrella headers to the module\n  /// that is generated from the umbrella header.\n  ///\n  /// This mapping is used to map headers that haven't explicitly been named\n  /// in the module map over to the module that includes them via its umbrella\n  /// header.\n  llvm::DenseMap<const DirectoryEntry *, Module *> UmbrellaDirs;\n\n  /// A generation counter that is used to test whether modules of the\n  /// same name may shadow or are illegal redefinitions.\n  ///\n  /// Modules from earlier scopes may shadow modules from later ones.\n  /// Modules from the same scope may not have the same name.\n  unsigned CurrentModuleScopeID = 0;\n\n  llvm::DenseMap<Module *, unsigned> ModuleScopeIDs;\n\n  /// The set of attributes that can be attached to a module.\n  struct Attributes {\n    /// Whether this is a system module.\n    unsigned IsSystem : 1;\n\n    /// Whether this is an extern \"C\" module.\n    unsigned IsExternC : 1;\n\n    /// Whether this is an exhaustive set of configuration macros.\n    unsigned IsExhaustive : 1;\n\n    /// Whether files in this module can only include non-modular headers\n    /// and headers from used modules.\n    unsigned NoUndeclaredIncludes : 1;\n\n    Attributes()\n        : IsSystem(false), IsExternC(false), IsExhaustive(false),\n          NoUndeclaredIncludes(false) {}\n  };\n\n  /// A directory for which framework modules can be inferred.\n  struct InferredDirectory {\n    /// Whether to infer modules from this directory.\n    unsigned InferModules : 1;\n\n    /// The attributes to use for inferred modules.\n    Attributes Attrs;\n\n    /// If \\c InferModules is non-zero, the module map file that allowed\n    /// inferred modules.  Otherwise, nullptr.\n    const FileEntry *ModuleMapFile;\n\n    /// The names of modules that cannot be inferred within this\n    /// directory.\n    SmallVector<std::string, 2> ExcludedModules;\n\n    InferredDirectory() : InferModules(false) {}\n  };\n\n  /// A mapping from directories to information about inferring\n  /// framework modules from within those directories.\n  llvm::DenseMap<const DirectoryEntry *, InferredDirectory> InferredDirectories;\n\n  /// A mapping from an inferred module to the module map that allowed the\n  /// inference.\n  llvm::DenseMap<const Module *, const FileEntry *> InferredModuleAllowedBy;\n\n  llvm::DenseMap<const Module *, AdditionalModMapsSet> AdditionalModMaps;\n\n  /// Describes whether we haved parsed a particular file as a module\n  /// map.\n  llvm::DenseMap<const FileEntry *, bool> ParsedModuleMap;\n\n  /// Resolve the given export declaration into an actual export\n  /// declaration.\n  ///\n  /// \\param Mod The module in which we're resolving the export declaration.\n  ///\n  /// \\param Unresolved The export declaration to resolve.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// exports.\n  ///\n  /// \\returns The resolved export declaration, which will have a NULL pointer\n  /// if the export could not be resolved.\n  Module::ExportDecl\n  resolveExport(Module *Mod, const Module::UnresolvedExportDecl &Unresolved,\n                bool Complain) const;\n\n  /// Resolve the given module id to an actual module.\n  ///\n  /// \\param Id The module-id to resolve.\n  ///\n  /// \\param Mod The module in which we're resolving the module-id.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// module-ids.\n  ///\n  /// \\returns The resolved module, or null if the module-id could not be\n  /// resolved.\n  Module *resolveModuleId(const ModuleId &Id, Module *Mod, bool Complain) const;\n\n  /// Add an unresolved header to a module.\n  ///\n  /// \\param Mod The module in which we're adding the unresolved header\n  ///        directive.\n  /// \\param Header The unresolved header directive.\n  /// \\param NeedsFramework If Mod is not a framework but a missing header would\n  ///        be found in case Mod was, set it to true. False otherwise.\n  void addUnresolvedHeader(Module *Mod,\n                           Module::UnresolvedHeaderDirective Header,\n                           bool &NeedsFramework);\n\n  /// Look up the given header directive to find an actual header file.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param RelativePathName Filled in with the relative path name from the\n  ///        module to the resolved header.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  /// \\return The resolved file, if any.\n  Optional<FileEntryRef>\n  findHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n             SmallVectorImpl<char> &RelativePathName, bool &NeedsFramework);\n\n  /// Resolve the given header directive.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  void resolveHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n                     bool &NeedsFramework);\n\n  /// Attempt to resolve the specified header directive as naming a builtin\n  /// header.\n  /// \\return \\c true if a corresponding builtin header was found.\n  bool resolveAsBuiltinHeader(Module *M,\n                              const Module::UnresolvedHeaderDirective &Header);\n\n  /// Looks up the modules that \\p File corresponds to.\n  ///\n  /// If \\p File represents a builtin header within Clang's builtin include\n  /// directory, this also loads all of the module maps to see if it will get\n  /// associated with a specific module (e.g. in /usr/include).\n  HeadersMap::iterator findKnownHeader(const FileEntry *File);\n\n  /// Searches for a module whose umbrella directory contains \\p File.\n  ///\n  /// \\param File The header to search for.\n  ///\n  /// \\param IntermediateDirs On success, contains the set of directories\n  /// searched before finding \\p File.\n  KnownHeader findHeaderInUmbrellaDirs(const FileEntry *File,\n                    SmallVectorImpl<const DirectoryEntry *> &IntermediateDirs);\n\n  /// Given that \\p File is not in the Headers map, look it up within\n  /// umbrella directories and find or create a module for it.\n  KnownHeader findOrCreateModuleForHeaderInUmbrellaDir(const FileEntry *File);\n\n  /// A convenience method to determine if \\p File is (possibly nested)\n  /// in an umbrella directory.\n  bool isHeaderInUmbrellaDirs(const FileEntry *File) {\n    SmallVector<const DirectoryEntry *, 2> IntermediateDirs;\n    return static_cast<bool>(findHeaderInUmbrellaDirs(File, IntermediateDirs));\n  }\n\n  Module *inferFrameworkModule(const DirectoryEntry *FrameworkDir,\n                               Attributes Attrs, Module *Parent);\n\npublic:\n  /// Construct a new module map.\n  ///\n  /// \\param SourceMgr The source manager used to find module files and headers.\n  /// This source manager should be shared with the header-search mechanism,\n  /// since they will refer to the same headers.\n  ///\n  /// \\param Diags A diagnostic engine used for diagnostics.\n  ///\n  /// \\param LangOpts Language options for this translation unit.\n  ///\n  /// \\param Target The target for this translation unit.\n  ModuleMap(SourceManager &SourceMgr, DiagnosticsEngine &Diags,\n            const LangOptions &LangOpts, const TargetInfo *Target,\n            HeaderSearch &HeaderInfo);\n\n  /// Destroy the module map.\n  ~ModuleMap();\n\n  /// Set the target information.\n  void setTarget(const TargetInfo &Target);\n\n  /// Set the directory that contains Clang-supplied include\n  /// files, such as our stdarg.h or tgmath.h.\n  void setBuiltinIncludeDir(const DirectoryEntry *Dir) {\n    BuiltinIncludeDir = Dir;\n  }\n\n  /// Get the directory that contains Clang-supplied include files.\n  const DirectoryEntry *getBuiltinDir() const {\n    return BuiltinIncludeDir;\n  }\n\n  /// Is this a compiler builtin header?\n  static bool isBuiltinHeader(StringRef FileName);\n  bool isBuiltinHeader(const FileEntry *File);\n\n  /// Add a module map callback.\n  void addModuleMapCallbacks(std::unique_ptr<ModuleMapCallbacks> Callback) {\n    Callbacks.push_back(std::move(Callback));\n  }\n\n  /// Retrieve the module that owns the given header file, if any. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// \\param File The header file that is likely to be included.\n  ///\n  /// \\param AllowTextual If \\c true and \\p File is a textual header, return\n  /// its owning module. Otherwise, no KnownHeader will be returned if the\n  /// file is only known as a textual header.\n  ///\n  /// \\returns The module KnownHeader, which provides the module that owns the\n  /// given header file.  The KnownHeader is default constructed to indicate\n  /// that no module owns this header file.\n  KnownHeader findModuleForHeader(const FileEntry *File,\n                                  bool AllowTextual = false);\n\n  /// Retrieve all the modules that contain the given header file. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// Typically, \\ref findModuleForHeader should be used instead, as it picks\n  /// the preferred module for the header.\n  ArrayRef<KnownHeader> findAllModulesForHeader(const FileEntry *File);\n\n  /// Like \\ref findAllModulesForHeader, but do not attempt to infer module\n  /// ownership from umbrella headers if we've not already done so.\n  ArrayRef<KnownHeader>\n  findResolvedModulesForHeader(const FileEntry *File) const;\n\n  /// Resolve all lazy header directives for the specified file.\n  ///\n  /// This ensures that the HeaderFileInfo on HeaderSearch is up to date. This\n  /// is effectively internal, but is exposed so HeaderSearch can call it.\n  void resolveHeaderDirectives(const FileEntry *File) const;\n\n  /// Resolve all lazy header directives for the specified module.\n  void resolveHeaderDirectives(Module *Mod) const;\n\n  /// Reports errors if a module must not include a specific file.\n  ///\n  /// \\param RequestingModule The module including a file.\n  ///\n  /// \\param RequestingModuleIsModuleInterface \\c true if the inclusion is in\n  ///        the interface of RequestingModule, \\c false if it's in the\n  ///        implementation of RequestingModule. Value is ignored and\n  ///        meaningless if RequestingModule is nullptr.\n  ///\n  /// \\param FilenameLoc The location of the inclusion's filename.\n  ///\n  /// \\param Filename The included filename as written.\n  ///\n  /// \\param File The included file.\n  void diagnoseHeaderInclusion(Module *RequestingModule,\n                               bool RequestingModuleIsModuleInterface,\n                               SourceLocation FilenameLoc, StringRef Filename,\n                               const FileEntry *File);\n\n  /// Determine whether the given header is part of a module\n  /// marked 'unavailable'.\n  bool isHeaderInUnavailableModule(const FileEntry *Header) const;\n\n  /// Determine whether the given header is unavailable as part\n  /// of the specified module.\n  bool isHeaderUnavailableInModule(const FileEntry *Header,\n                                   const Module *RequestingModule) const;\n\n  /// Retrieve a module with the given name.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *findModule(StringRef Name) const;\n\n  /// Retrieve a module with the given name using lexical name lookup,\n  /// starting at the given context.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module context, from which we will perform lexical\n  /// name lookup.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *lookupModuleUnqualified(StringRef Name, Module *Context) const;\n\n  /// Retrieve a module with the given name within the given context,\n  /// using direct (qualified) name lookup.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module for which we will look for a submodule. If\n  /// null, we will look for a top-level module.\n  ///\n  /// \\returns The named submodule, if known; otherwose, returns null.\n  Module *lookupModuleQualified(StringRef Name, Module *Context) const;\n\n  /// Find a new module or submodule, or create it if it does not already\n  /// exist.\n  ///\n  /// \\param Name The name of the module to find or create.\n  ///\n  /// \\param Parent The module that will act as the parent of this submodule,\n  /// or nullptr to indicate that this is a top-level module.\n  ///\n  /// \\param IsFramework Whether this is a framework module.\n  ///\n  /// \\param IsExplicit Whether this is an explicit submodule.\n  ///\n  /// \\returns The found or newly-created module, along with a boolean value\n  /// that will be true if the module is newly-created.\n  std::pair<Module *, bool> findOrCreateModule(StringRef Name, Module *Parent,\n                                               bool IsFramework,\n                                               bool IsExplicit);\n\n  /// Create a global module fragment for a C++ module unit.\n  ///\n  /// We model the global module fragment as a submodule of the module\n  /// interface unit. Unfortunately, we can't create the module interface\n  /// unit's Module until later, because we don't know what it will be called.\n  Module *createGlobalModuleFragmentForModuleUnit(SourceLocation Loc);\n\n  /// Create a global module fragment for a C++ module interface unit.\n  Module *createPrivateModuleFragmentForInterfaceUnit(Module *Parent,\n                                                      SourceLocation Loc);\n\n  /// Create a new module for a C++ module interface unit.\n  /// The module must not already exist, and will be configured for the current\n  /// compilation.\n  ///\n  /// Note that this also sets the current module to the newly-created module.\n  ///\n  /// \\returns The newly-created module.\n  Module *createModuleForInterfaceUnit(SourceLocation Loc, StringRef Name,\n                                       Module *GlobalModule);\n\n  /// Create a header module from the specified list of headers.\n  Module *createHeaderModule(StringRef Name, ArrayRef<Module::Header> Headers);\n\n  /// Infer the contents of a framework module map from the given\n  /// framework directory.\n  Module *inferFrameworkModule(const DirectoryEntry *FrameworkDir,\n                               bool IsSystem, Module *Parent);\n\n  /// Create a new top-level module that is shadowed by\n  /// \\p ShadowingModule.\n  Module *createShadowedModule(StringRef Name, bool IsFramework,\n                               Module *ShadowingModule);\n\n  /// Creates a new declaration scope for module names, allowing\n  /// previously defined modules to shadow definitions from the new scope.\n  ///\n  /// \\note Module names from earlier scopes will shadow names from the new\n  /// scope, which is the opposite of how shadowing works for variables.\n  void finishModuleDeclarationScope() { CurrentModuleScopeID += 1; }\n\n  bool mayShadowNewModule(Module *ExistingModule) {\n    assert(!ExistingModule->Parent && \"expected top-level module\");\n    assert(ModuleScopeIDs.count(ExistingModule) && \"unknown module\");\n    return ModuleScopeIDs[ExistingModule] < CurrentModuleScopeID;\n  }\n\n  /// Retrieve the module map file containing the definition of the given\n  /// module.\n  ///\n  /// \\param Module The module whose module map file will be returned, if known.\n  ///\n  /// \\returns The file entry for the module map file containing the given\n  /// module, or nullptr if the module definition was inferred.\n  const FileEntry *getContainingModuleMapFile(const Module *Module) const;\n\n  /// Get the module map file that (along with the module name) uniquely\n  /// identifies this module.\n  ///\n  /// The particular module that \\c Name refers to may depend on how the module\n  /// was found in header search. However, the combination of \\c Name and\n  /// this module map will be globally unique for top-level modules. In the case\n  /// of inferred modules, returns the module map that allowed the inference\n  /// (e.g. contained 'module *'). Otherwise, returns\n  /// getContainingModuleMapFile().\n  const FileEntry *getModuleMapFileForUniquing(const Module *M) const;\n\n  void setInferredModuleAllowedBy(Module *M, const FileEntry *ModMap);\n\n  /// Get any module map files other than getModuleMapFileForUniquing(M)\n  /// that define submodules of a top-level module \\p M. This is cheaper than\n  /// getting the module map file for each submodule individually, since the\n  /// expected number of results is very small.\n  AdditionalModMapsSet *getAdditionalModuleMapFiles(const Module *M) {\n    auto I = AdditionalModMaps.find(M);\n    if (I == AdditionalModMaps.end())\n      return nullptr;\n    return &I->second;\n  }\n\n  void addAdditionalModuleMapFile(const Module *M, const FileEntry *ModuleMap);\n\n  /// Resolve all of the unresolved exports in the given module.\n  ///\n  /// \\param Mod The module whose exports should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving exports,\n  /// false otherwise.\n  bool resolveExports(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved uses in the given module.\n  ///\n  /// \\param Mod The module whose uses should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving uses,\n  /// false otherwise.\n  bool resolveUses(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved conflicts in the given module.\n  ///\n  /// \\param Mod The module whose conflicts should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving conflicts,\n  /// false otherwise.\n  bool resolveConflicts(Module *Mod, bool Complain);\n\n  /// Sets the umbrella header of the given module to the given\n  /// header.\n  void setUmbrellaHeader(Module *Mod, const FileEntry *UmbrellaHeader,\n                         Twine NameAsWritten);\n\n  /// Sets the umbrella directory of the given module to the given\n  /// directory.\n  void setUmbrellaDir(Module *Mod, const DirectoryEntry *UmbrellaDir,\n                      Twine NameAsWritten);\n\n  /// Adds this header to the given module.\n  /// \\param Role The role of the header wrt the module.\n  void addHeader(Module *Mod, Module::Header Header,\n                 ModuleHeaderRole Role, bool Imported = false);\n\n  /// Marks this header as being excluded from the given module.\n  void excludeHeader(Module *Mod, Module::Header Header);\n\n  /// Parse the given module map file, and record any modules we\n  /// encounter.\n  ///\n  /// \\param File The file to be parsed.\n  ///\n  /// \\param IsSystem Whether this module map file is in a system header\n  /// directory, and therefore should be considered a system module.\n  ///\n  /// \\param HomeDir The directory in which relative paths within this module\n  ///        map file will be resolved.\n  ///\n  /// \\param ID The FileID of the file to process, if we've already entered it.\n  ///\n  /// \\param Offset [inout] On input the offset at which to start parsing. On\n  ///        output, the offset at which the module map terminated.\n  ///\n  /// \\param ExternModuleLoc The location of the \"extern module\" declaration\n  ///        that caused us to load this module map file, if any.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool parseModuleMapFile(const FileEntry *File, bool IsSystem,\n                          const DirectoryEntry *HomeDir,\n                          FileID ID = FileID(), unsigned *Offset = nullptr,\n                          SourceLocation ExternModuleLoc = SourceLocation());\n\n  /// Dump the contents of the module map, for debugging purposes.\n  void dump();\n\n  using module_iterator = llvm::StringMap<Module *>::const_iterator;\n\n  module_iterator module_begin() const { return Modules.begin(); }\n  module_iterator module_end()   const { return Modules.end(); }\n\n  /// Cache a module load.  M might be nullptr.\n  void cacheModuleLoad(const IdentifierInfo &II, Module *M) {\n    CachedModuleLoads[&II] = M;\n  }\n\n  /// Return a cached module load.\n  llvm::Optional<Module *> getCachedModuleLoad(const IdentifierInfo &II) {\n    auto I = CachedModuleLoads.find(&II);\n    if (I == CachedModuleLoads.end())\n      return None;\n    return I->second;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_MODULEMAP_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "content": "//===- Preprocessor.h - C Language Family Preprocessor ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Preprocessor interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSOR_H\n#define LLVM_CLANG_LEX_PREPROCESSOR_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/ModuleMap.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Lex/TokenLexer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Registry.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate<unsigned InternalLen> class SmallString;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass CodeCompletionHandler;\nclass CommentHandler;\nclass DirectoryEntry;\nclass DirectoryLookup;\nclass EmptylineHandler;\nclass ExternalPreprocessorSource;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearch;\nclass MacroArgs;\nclass PragmaHandler;\nclass PragmaNamespace;\nclass PreprocessingRecord;\nclass PreprocessorLexer;\nclass PreprocessorOptions;\nclass ScratchBuffer;\nclass TargetInfo;\n\nnamespace Builtin {\nclass Context;\n}\n\n/// Stores token information for comparing actual tokens with\n/// predefined values.  Only handles simple tokens and identifiers.\nclass TokenValue {\n  tok::TokenKind Kind;\n  IdentifierInfo *II;\n\npublic:\n  TokenValue(tok::TokenKind Kind) : Kind(Kind), II(nullptr) {\n    assert(Kind != tok::raw_identifier && \"Raw identifiers are not supported.\");\n    assert(Kind != tok::identifier &&\n           \"Identifiers should be created by TokenValue(IdentifierInfo *)\");\n    assert(!tok::isLiteral(Kind) && \"Literals are not supported.\");\n    assert(!tok::isAnnotation(Kind) && \"Annotations are not supported.\");\n  }\n\n  TokenValue(IdentifierInfo *II) : Kind(tok::identifier), II(II) {}\n\n  bool operator==(const Token &Tok) const {\n    return Tok.getKind() == Kind &&\n        (!II || II == Tok.getIdentifierInfo());\n  }\n};\n\n/// Context in which macro name is used.\nenum MacroUse {\n  // other than #define or #undef\n  MU_Other  = 0,\n\n  // macro name specified in #define\n  MU_Define = 1,\n\n  // macro name specified in #undef\n  MU_Undef  = 2\n};\n\n/// Engages in a tight little dance with the lexer to efficiently\n/// preprocess tokens.\n///\n/// Lexers know only about tokens within a single source file, and don't\n/// know anything about preprocessor-level issues like the \\#include stack,\n/// token expansion, etc.\nclass Preprocessor {\n  friend class VAOptDefinitionContext;\n  friend class VariadicMacroScopeGuard;\n\n  llvm::unique_function<void(const clang::Token &)> OnToken;\n  std::shared_ptr<PreprocessorOptions> PPOpts;\n  DiagnosticsEngine        *Diags;\n  LangOptions       &LangOpts;\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  FileManager       &FileMgr;\n  SourceManager     &SourceMgr;\n  std::unique_ptr<ScratchBuffer> ScratchBuf;\n  HeaderSearch      &HeaderInfo;\n  ModuleLoader      &TheModuleLoader;\n\n  /// External source of macros.\n  ExternalPreprocessorSource *ExternalSource;\n\n  /// A BumpPtrAllocator object used to quickly allocate and release\n  /// objects internal to the Preprocessor.\n  llvm::BumpPtrAllocator BP;\n\n  /// Identifiers for builtin macros and other builtins.\n  IdentifierInfo *Ident__LINE__, *Ident__FILE__;   // __LINE__, __FILE__\n  IdentifierInfo *Ident__DATE__, *Ident__TIME__;   // __DATE__, __TIME__\n  IdentifierInfo *Ident__INCLUDE_LEVEL__;          // __INCLUDE_LEVEL__\n  IdentifierInfo *Ident__BASE_FILE__;              // __BASE_FILE__\n  IdentifierInfo *Ident__FILE_NAME__;              // __FILE_NAME__\n  IdentifierInfo *Ident__TIMESTAMP__;              // __TIMESTAMP__\n  IdentifierInfo *Ident__COUNTER__;                // __COUNTER__\n  IdentifierInfo *Ident_Pragma, *Ident__pragma;    // _Pragma, __pragma\n  IdentifierInfo *Ident__identifier;               // __identifier\n  IdentifierInfo *Ident__VA_ARGS__;                // __VA_ARGS__\n  IdentifierInfo *Ident__VA_OPT__;                 // __VA_OPT__\n  IdentifierInfo *Ident__has_feature;              // __has_feature\n  IdentifierInfo *Ident__has_extension;            // __has_extension\n  IdentifierInfo *Ident__has_builtin;              // __has_builtin\n  IdentifierInfo *Ident__has_attribute;            // __has_attribute\n  IdentifierInfo *Ident__has_include;              // __has_include\n  IdentifierInfo *Ident__has_include_next;         // __has_include_next\n  IdentifierInfo *Ident__has_warning;              // __has_warning\n  IdentifierInfo *Ident__is_identifier;            // __is_identifier\n  IdentifierInfo *Ident__building_module;          // __building_module\n  IdentifierInfo *Ident__MODULE__;                 // __MODULE__\n  IdentifierInfo *Ident__has_cpp_attribute;        // __has_cpp_attribute\n  IdentifierInfo *Ident__has_c_attribute;          // __has_c_attribute\n  IdentifierInfo *Ident__has_declspec;             // __has_declspec_attribute\n  IdentifierInfo *Ident__is_target_arch;           // __is_target_arch\n  IdentifierInfo *Ident__is_target_vendor;         // __is_target_vendor\n  IdentifierInfo *Ident__is_target_os;             // __is_target_os\n  IdentifierInfo *Ident__is_target_environment;    // __is_target_environment\n\n  // Weak, only valid (and set) while InMacroArgs is true.\n  Token* ArgMacro;\n\n  SourceLocation DATELoc, TIMELoc;\n\n  // Next __COUNTER__ value, starts at 0.\n  unsigned CounterValue = 0;\n\n  enum {\n    /// Maximum depth of \\#includes.\n    MaxAllowedIncludeStackDepth = 200\n  };\n\n  // State that is set before the preprocessor begins.\n  bool KeepComments : 1;\n  bool KeepMacroComments : 1;\n  bool SuppressIncludeNotFoundError : 1;\n\n  // State that changes while the preprocessor runs:\n  bool InMacroArgs : 1;            // True if parsing fn macro invocation args.\n\n  /// Whether the preprocessor owns the header search object.\n  bool OwnsHeaderSearch : 1;\n\n  /// True if macro expansion is disabled.\n  bool DisableMacroExpansion : 1;\n\n  /// Temporarily disables DisableMacroExpansion (i.e. enables expansion)\n  /// when parsing preprocessor directives.\n  bool MacroExpansionInDirectivesOverride : 1;\n\n  class ResetMacroExpansionHelper;\n\n  /// Whether we have already loaded macros from the external source.\n  mutable bool ReadMacrosFromExternalSource : 1;\n\n  /// True if pragmas are enabled.\n  bool PragmasEnabled : 1;\n\n  /// True if the current build action is a preprocessing action.\n  bool PreprocessedOutput : 1;\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool ParsingIfOrElifDirective;\n\n  /// True if we are pre-expanding macro arguments.\n  bool InMacroArgPreExpansion;\n\n  /// Mapping/lookup information for all identifiers in\n  /// the program, including program keywords.\n  mutable IdentifierTable Identifiers;\n\n  /// This table contains all the selectors in the program.\n  ///\n  /// Unlike IdentifierTable above, this table *isn't* populated by the\n  /// preprocessor. It is declared/expanded here because its role/lifetime is\n  /// conceptually similar to the IdentifierTable. In addition, the current\n  /// control flow (in clang::ParseAST()), make it convenient to put here.\n  ///\n  /// FIXME: Make sure the lifetime of Identifiers/Selectors *isn't* tied to\n  /// the lifetime of the preprocessor.\n  SelectorTable Selectors;\n\n  /// Information about builtins.\n  std::unique_ptr<Builtin::Context> BuiltinInfo;\n\n  /// Tracks all of the pragmas that the client registered\n  /// with this preprocessor.\n  std::unique_ptr<PragmaNamespace> PragmaHandlers;\n\n  /// Pragma handlers of the original source is stored here during the\n  /// parsing of a model file.\n  std::unique_ptr<PragmaNamespace> PragmaHandlersBackup;\n\n  /// Tracks all of the comment handlers that the client registered\n  /// with this preprocessor.\n  std::vector<CommentHandler *> CommentHandlers;\n\n  /// Empty line handler.\n  EmptylineHandler *Emptyline = nullptr;\n\n  /// True if we want to ignore EOF token and continue later on (thus\n  /// avoid tearing the Lexer and etc. down).\n  bool IncrementalProcessing = false;\n\n  /// The kind of translation unit we are processing.\n  TranslationUnitKind TUKind;\n\n  /// The code-completion handler.\n  CodeCompletionHandler *CodeComplete = nullptr;\n\n  /// The file that we're performing code-completion for, if any.\n  const FileEntry *CodeCompletionFile = nullptr;\n\n  /// The offset in file for the code-completion point.\n  unsigned CodeCompletionOffset = 0;\n\n  /// The location for the code-completion point. This gets instantiated\n  /// when the CodeCompletionFile gets \\#include'ed for preprocessing.\n  SourceLocation CodeCompletionLoc;\n\n  /// The start location for the file of the code-completion point.\n  ///\n  /// This gets instantiated when the CodeCompletionFile gets \\#include'ed\n  /// for preprocessing.\n  SourceLocation CodeCompletionFileLoc;\n\n  /// The source location of the \\c import contextual keyword we just\n  /// lexed, if any.\n  SourceLocation ModuleImportLoc;\n\n  /// The module import path that we're currently processing.\n  SmallVector<std::pair<IdentifierInfo *, SourceLocation>, 2> ModuleImportPath;\n\n  /// Whether the last token we lexed was an '@'.\n  bool LastTokenWasAt = false;\n\n  /// A position within a C++20 import-seq.\n  class ImportSeq {\n  public:\n    enum State : int {\n      // Positive values represent a number of unclosed brackets.\n      AtTopLevel = 0,\n      AfterTopLevelTokenSeq = -1,\n      AfterExport = -2,\n      AfterImportSeq = -3,\n    };\n\n    ImportSeq(State S) : S(S) {}\n\n    /// Saw any kind of open bracket.\n    void handleOpenBracket() {\n      S = static_cast<State>(std::max<int>(S, 0) + 1);\n    }\n    /// Saw any kind of close bracket other than '}'.\n    void handleCloseBracket() {\n      S = static_cast<State>(std::max<int>(S, 1) - 1);\n    }\n    /// Saw a close brace.\n    void handleCloseBrace() {\n      handleCloseBracket();\n      if (S == AtTopLevel && !AfterHeaderName)\n        S = AfterTopLevelTokenSeq;\n    }\n    /// Saw a semicolon.\n    void handleSemi() {\n      if (atTopLevel()) {\n        S = AfterTopLevelTokenSeq;\n        AfterHeaderName = false;\n      }\n    }\n\n    /// Saw an 'export' identifier.\n    void handleExport() {\n      if (S == AfterTopLevelTokenSeq)\n        S = AfterExport;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n    /// Saw an 'import' identifier.\n    void handleImport() {\n      if (S == AfterTopLevelTokenSeq || S == AfterExport)\n        S = AfterImportSeq;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    /// Saw a 'header-name' token; do not recognize any more 'import' tokens\n    /// until we reach a top-level semicolon.\n    void handleHeaderName() {\n      if (S == AfterImportSeq)\n        AfterHeaderName = true;\n      handleMisc();\n    }\n\n    /// Saw any other token.\n    void handleMisc() {\n      if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    bool atTopLevel() { return S <= 0; }\n    bool afterImportSeq() { return S == AfterImportSeq; }\n\n  private:\n    State S;\n    /// Whether we're in the pp-import-suffix following the header-name in a\n    /// pp-import. If so, a close-brace is not sufficient to end the\n    /// top-level-token-seq of an import-seq.\n    bool AfterHeaderName = false;\n  };\n\n  /// Our current position within a C++20 import-seq.\n  ImportSeq ImportSeqState = ImportSeq::AfterTopLevelTokenSeq;\n\n  /// Whether the module import expects an identifier next. Otherwise,\n  /// it expects a '.' or ';'.\n  bool ModuleImportExpectsIdentifier = false;\n\n  /// The identifier and source location of the currently-active\n  /// \\#pragma clang arc_cf_code_audited begin.\n  std::pair<IdentifierInfo *, SourceLocation> PragmaARCCFCodeAuditedInfo;\n\n  /// The source location of the currently-active\n  /// \\#pragma clang assume_nonnull begin.\n  SourceLocation PragmaAssumeNonNullLoc;\n\n  /// True if we hit the code-completion point.\n  bool CodeCompletionReached = false;\n\n  /// The code completion token containing the information\n  /// on the stem that is to be code completed.\n  IdentifierInfo *CodeCompletionII = nullptr;\n\n  /// Range for the code completion token.\n  SourceRange CodeCompletionTokenRange;\n\n  /// The directory that the main file should be considered to occupy,\n  /// if it does not correspond to a real file (as happens when building a\n  /// module).\n  const DirectoryEntry *MainFileDir = nullptr;\n\n  /// The number of bytes that we will initially skip when entering the\n  /// main file, along with a flag that indicates whether skipping this number\n  /// of bytes will place the lexer at the start of a line.\n  ///\n  /// This is used when loading a precompiled preamble.\n  std::pair<int, bool> SkipMainFilePreamble;\n\n  /// Whether we hit an error due to reaching max allowed include depth. Allows\n  /// to avoid hitting the same error over and over again.\n  bool HasReachedMaxIncludeDepth = false;\n\n  /// The number of currently-active calls to Lex.\n  ///\n  /// Lex is reentrant, and asking for an (end-of-phase-4) token can often\n  /// require asking for multiple additional tokens. This counter makes it\n  /// possible for Lex to detect whether it's producing a token for the end\n  /// of phase 4 of translation or for some other situation.\n  unsigned LexLevel = 0;\n\n  /// The number of (LexLevel 0) preprocessor tokens.\n  unsigned TokenCount = 0;\n\n  /// Preprocess every token regardless of LexLevel.\n  bool PreprocessToken = false;\n\n  /// The maximum number of (LexLevel 0) tokens before issuing a -Wmax-tokens\n  /// warning, or zero for unlimited.\n  unsigned MaxTokens = 0;\n  SourceLocation MaxTokensOverrideLoc;\n\npublic:\n  struct PreambleSkipInfo {\n    SourceLocation HashTokenLoc;\n    SourceLocation IfTokenLoc;\n    bool FoundNonSkipPortion;\n    bool FoundElse;\n    SourceLocation ElseLoc;\n\n    PreambleSkipInfo(SourceLocation HashTokenLoc, SourceLocation IfTokenLoc,\n                     bool FoundNonSkipPortion, bool FoundElse,\n                     SourceLocation ElseLoc)\n        : HashTokenLoc(HashTokenLoc), IfTokenLoc(IfTokenLoc),\n          FoundNonSkipPortion(FoundNonSkipPortion), FoundElse(FoundElse),\n          ElseLoc(ElseLoc) {}\n  };\n\nprivate:\n  friend class ASTReader;\n  friend class MacroArgs;\n\n  class PreambleConditionalStackStore {\n    enum State {\n      Off = 0,\n      Recording = 1,\n      Replaying = 2,\n    };\n\n  public:\n    PreambleConditionalStackStore() = default;\n\n    void startRecording() { ConditionalStackState = Recording; }\n    void startReplaying() { ConditionalStackState = Replaying; }\n    bool isRecording() const { return ConditionalStackState == Recording; }\n    bool isReplaying() const { return ConditionalStackState == Replaying; }\n\n    ArrayRef<PPConditionalInfo> getStack() const {\n      return ConditionalStack;\n    }\n\n    void doneReplaying() {\n      ConditionalStack.clear();\n      ConditionalStackState = Off;\n    }\n\n    void setStack(ArrayRef<PPConditionalInfo> s) {\n      if (!isRecording() && !isReplaying())\n        return;\n      ConditionalStack.clear();\n      ConditionalStack.append(s.begin(), s.end());\n    }\n\n    bool hasRecordedPreamble() const { return !ConditionalStack.empty(); }\n\n    bool reachedEOFWhileSkipping() const { return SkipInfo.hasValue(); }\n\n    void clearSkipInfo() { SkipInfo.reset(); }\n\n    llvm::Optional<PreambleSkipInfo> SkipInfo;\n\n  private:\n    SmallVector<PPConditionalInfo, 4> ConditionalStack;\n    State ConditionalStackState = Off;\n  } PreambleConditionalStack;\n\n  /// The current top of the stack that we're lexing from if\n  /// not expanding a macro and we are lexing directly from source code.\n  ///\n  /// Only one of CurLexer, or CurTokenLexer will be non-null.\n  std::unique_ptr<Lexer> CurLexer;\n\n  /// The current top of the stack what we're lexing from\n  /// if not expanding a macro.\n  ///\n  /// This is an alias for CurLexer.\n  PreprocessorLexer *CurPPLexer = nullptr;\n\n  /// Used to find the current FileEntry, if CurLexer is non-null\n  /// and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *CurDirLookup = nullptr;\n\n  /// The current macro we are expanding, if we are expanding a macro.\n  ///\n  /// One of CurLexer and CurTokenLexer must be null.\n  std::unique_ptr<TokenLexer> CurTokenLexer;\n\n  /// The kind of lexer we're currently working with.\n  enum CurLexerKind {\n    CLK_Lexer,\n    CLK_TokenLexer,\n    CLK_CachingLexer,\n    CLK_LexAfterModuleImport\n  } CurLexerKind = CLK_Lexer;\n\n  /// If the current lexer is for a submodule that is being built, this\n  /// is that submodule.\n  Module *CurLexerSubmodule = nullptr;\n\n  /// Keeps track of the stack of files currently\n  /// \\#included, and macros currently being expanded from, not counting\n  /// CurLexer/CurTokenLexer.\n  struct IncludeStackInfo {\n    enum CurLexerKind           CurLexerKind;\n    Module                     *TheSubmodule;\n    std::unique_ptr<Lexer>      TheLexer;\n    PreprocessorLexer          *ThePPLexer;\n    std::unique_ptr<TokenLexer> TheTokenLexer;\n    const DirectoryLookup      *TheDirLookup;\n\n    // The following constructors are completely useless copies of the default\n    // versions, only needed to pacify MSVC.\n    IncludeStackInfo(enum CurLexerKind CurLexerKind, Module *TheSubmodule,\n                     std::unique_ptr<Lexer> &&TheLexer,\n                     PreprocessorLexer *ThePPLexer,\n                     std::unique_ptr<TokenLexer> &&TheTokenLexer,\n                     const DirectoryLookup *TheDirLookup)\n        : CurLexerKind(std::move(CurLexerKind)),\n          TheSubmodule(std::move(TheSubmodule)), TheLexer(std::move(TheLexer)),\n          ThePPLexer(std::move(ThePPLexer)),\n          TheTokenLexer(std::move(TheTokenLexer)),\n          TheDirLookup(std::move(TheDirLookup)) {}\n  };\n  std::vector<IncludeStackInfo> IncludeMacroStack;\n\n  /// Actions invoked when some preprocessor activity is\n  /// encountered (e.g. a file is \\#included, etc).\n  std::unique_ptr<PPCallbacks> Callbacks;\n\n  struct MacroExpandsInfo {\n    Token Tok;\n    MacroDefinition MD;\n    SourceRange Range;\n\n    MacroExpandsInfo(Token Tok, MacroDefinition MD, SourceRange Range)\n        : Tok(Tok), MD(MD), Range(Range) {}\n  };\n  SmallVector<MacroExpandsInfo, 2> DelayedMacroExpandsCallbacks;\n\n  /// Information about a name that has been used to define a module macro.\n  struct ModuleMacroInfo {\n    /// The most recent macro directive for this identifier.\n    MacroDirective *MD;\n\n    /// The active module macros for this identifier.\n    llvm::TinyPtrVector<ModuleMacro *> ActiveModuleMacros;\n\n    /// The generation number at which we last updated ActiveModuleMacros.\n    /// \\see Preprocessor::VisibleModules.\n    unsigned ActiveModuleMacrosGeneration = 0;\n\n    /// Whether this macro name is ambiguous.\n    bool IsAmbiguous = false;\n\n    /// The module macros that are overridden by this macro.\n    llvm::TinyPtrVector<ModuleMacro *> OverriddenMacros;\n\n    ModuleMacroInfo(MacroDirective *MD) : MD(MD) {}\n  };\n\n  /// The state of a macro for an identifier.\n  class MacroState {\n    mutable llvm::PointerUnion<MacroDirective *, ModuleMacroInfo *> State;\n\n    ModuleMacroInfo *getModuleInfo(Preprocessor &PP,\n                                   const IdentifierInfo *II) const {\n      if (II->isOutOfDate())\n        PP.updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n      // FIXME: Find a spare bit on IdentifierInfo and store a\n      //        HasModuleMacros flag.\n      if (!II->hasMacroDefinition() ||\n          (!PP.getLangOpts().Modules &&\n           !PP.getLangOpts().ModulesLocalVisibility) ||\n          !PP.CurSubmoduleState->VisibleModules.getGeneration())\n        return nullptr;\n\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n\n      if (PP.CurSubmoduleState->VisibleModules.getGeneration() !=\n          Info->ActiveModuleMacrosGeneration)\n        PP.updateModuleMacroInfo(II, *Info);\n      return Info;\n    }\n\n  public:\n    MacroState() : MacroState(nullptr) {}\n    MacroState(MacroDirective *MD) : State(MD) {}\n\n    MacroState(MacroState &&O) noexcept : State(O.State) {\n      O.State = (MacroDirective *)nullptr;\n    }\n\n    MacroState &operator=(MacroState &&O) noexcept {\n      auto S = O.State;\n      O.State = (MacroDirective *)nullptr;\n      State = S;\n      return *this;\n    }\n\n    ~MacroState() {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->~ModuleMacroInfo();\n    }\n\n    MacroDirective *getLatest() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->MD;\n      return State.get<MacroDirective*>();\n    }\n\n    void setLatest(MacroDirective *MD) {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->MD = MD;\n      else\n        State = MD;\n    }\n\n    bool isAmbiguous(Preprocessor &PP, const IdentifierInfo *II) const {\n      auto *Info = getModuleInfo(PP, II);\n      return Info ? Info->IsAmbiguous : false;\n    }\n\n    ArrayRef<ModuleMacro *>\n    getActiveModuleMacros(Preprocessor &PP, const IdentifierInfo *II) const {\n      if (auto *Info = getModuleInfo(PP, II))\n        return Info->ActiveModuleMacros;\n      return None;\n    }\n\n    MacroDirective::DefInfo findDirectiveAtLoc(SourceLocation Loc,\n                                               SourceManager &SourceMgr) const {\n      // FIXME: Incorporate module macros into the result of this.\n      if (auto *Latest = getLatest())\n        return Latest->findDirectiveAtLoc(Loc, SourceMgr);\n      return {};\n    }\n\n    void overrideActiveModuleMacros(Preprocessor &PP, IdentifierInfo *II) {\n      if (auto *Info = getModuleInfo(PP, II)) {\n        Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                      Info->ActiveModuleMacros.begin(),\n                                      Info->ActiveModuleMacros.end());\n        Info->ActiveModuleMacros.clear();\n        Info->IsAmbiguous = false;\n      }\n    }\n\n    ArrayRef<ModuleMacro*> getOverriddenMacros() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->OverriddenMacros;\n      return None;\n    }\n\n    void setOverriddenMacros(Preprocessor &PP,\n                             ArrayRef<ModuleMacro *> Overrides) {\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        if (Overrides.empty())\n          return;\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n      Info->OverriddenMacros.clear();\n      Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                    Overrides.begin(), Overrides.end());\n      Info->ActiveModuleMacrosGeneration = 0;\n    }\n  };\n\n  /// For each IdentifierInfo that was associated with a macro, we\n  /// keep a mapping to the history of all macro definitions and #undefs in\n  /// the reverse order (the latest one is in the head of the list).\n  ///\n  /// This mapping lives within the \\p CurSubmoduleState.\n  using MacroMap = llvm::DenseMap<const IdentifierInfo *, MacroState>;\n\n  struct SubmoduleState;\n\n  /// Information about a submodule that we're currently building.\n  struct BuildingSubmoduleInfo {\n    /// The module that we are building.\n    Module *M;\n\n    /// The location at which the module was included.\n    SourceLocation ImportLoc;\n\n    /// Whether we entered this submodule via a pragma.\n    bool IsPragma;\n\n    /// The previous SubmoduleState.\n    SubmoduleState *OuterSubmoduleState;\n\n    /// The number of pending module macro names when we started building this.\n    unsigned OuterPendingModuleMacroNames;\n\n    BuildingSubmoduleInfo(Module *M, SourceLocation ImportLoc, bool IsPragma,\n                          SubmoduleState *OuterSubmoduleState,\n                          unsigned OuterPendingModuleMacroNames)\n        : M(M), ImportLoc(ImportLoc), IsPragma(IsPragma),\n          OuterSubmoduleState(OuterSubmoduleState),\n          OuterPendingModuleMacroNames(OuterPendingModuleMacroNames) {}\n  };\n  SmallVector<BuildingSubmoduleInfo, 8> BuildingSubmoduleStack;\n\n  /// Information about a submodule's preprocessor state.\n  struct SubmoduleState {\n    /// The macros for the submodule.\n    MacroMap Macros;\n\n    /// The set of modules that are visible within the submodule.\n    VisibleModuleSet VisibleModules;\n\n    // FIXME: CounterValue?\n    // FIXME: PragmaPushMacroInfo?\n  };\n  std::map<Module *, SubmoduleState> Submodules;\n\n  /// The preprocessor state for preprocessing outside of any submodule.\n  SubmoduleState NullSubmoduleState;\n\n  /// The current submodule state. Will be \\p NullSubmoduleState if we're not\n  /// in a submodule.\n  SubmoduleState *CurSubmoduleState;\n\n  /// The set of known macros exported from modules.\n  llvm::FoldingSet<ModuleMacro> ModuleMacros;\n\n  /// The names of potential module macros that we've not yet processed.\n  llvm::SmallVector<const IdentifierInfo *, 32> PendingModuleMacroNames;\n\n  /// The list of module macros, for each identifier, that are not overridden by\n  /// any other module macro.\n  llvm::DenseMap<const IdentifierInfo *, llvm::TinyPtrVector<ModuleMacro *>>\n      LeafModuleMacros;\n\n  /// Macros that we want to warn because they are not used at the end\n  /// of the translation unit.\n  ///\n  /// We store just their SourceLocations instead of\n  /// something like MacroInfo*. The benefit of this is that when we are\n  /// deserializing from PCH, we don't need to deserialize identifier & macros\n  /// just so that we can report that they are unused, we just warn using\n  /// the SourceLocations of this set (that will be filled by the ASTReader).\n  /// We are using SmallPtrSet instead of a vector for faster removal.\n  using WarnUnusedMacroLocsTy = llvm::SmallPtrSet<SourceLocation, 32>;\n  WarnUnusedMacroLocsTy WarnUnusedMacroLocs;\n\n  /// A \"freelist\" of MacroArg objects that can be\n  /// reused for quick allocation.\n  MacroArgs *MacroArgCache = nullptr;\n\n  /// For each IdentifierInfo used in a \\#pragma push_macro directive,\n  /// we keep a MacroInfo stack used to restore the previous macro value.\n  llvm::DenseMap<IdentifierInfo *, std::vector<MacroInfo *>>\n      PragmaPushMacroInfo;\n\n  // Various statistics we track for performance analysis.\n  unsigned NumDirectives = 0;\n  unsigned NumDefined = 0;\n  unsigned NumUndefined = 0;\n  unsigned NumPragma = 0;\n  unsigned NumIf = 0;\n  unsigned NumElse = 0;\n  unsigned NumEndif = 0;\n  unsigned NumEnteredSourceFiles = 0;\n  unsigned MaxIncludeStackDepth = 0;\n  unsigned NumMacroExpanded = 0;\n  unsigned NumFnMacroExpanded = 0;\n  unsigned NumBuiltinMacroExpanded = 0;\n  unsigned NumFastMacroExpanded = 0;\n  unsigned NumTokenPaste = 0;\n  unsigned NumFastTokenPaste = 0;\n  unsigned NumSkipped = 0;\n\n  /// The predefined macros that preprocessor should use from the\n  /// command line etc.\n  std::string Predefines;\n\n  /// The file ID for the preprocessor predefines.\n  FileID PredefinesFileID;\n\n  /// The file ID for the PCH through header.\n  FileID PCHThroughHeaderFileID;\n\n  /// Whether tokens are being skipped until a #pragma hdrstop is seen.\n  bool SkippingUntilPragmaHdrStop = false;\n\n  /// Whether tokens are being skipped until the through header is seen.\n  bool SkippingUntilPCHThroughHeader = false;\n\n  /// \\{\n  /// Cache of macro expanders to reduce malloc traffic.\n  enum { TokenLexerCacheSize = 8 };\n  unsigned NumCachedTokenLexers;\n  std::unique_ptr<TokenLexer> TokenLexerCache[TokenLexerCacheSize];\n  /// \\}\n\n  /// Keeps macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  SmallVector<Token, 16> MacroExpandedTokens;\n  std::vector<std::pair<TokenLexer *, size_t>> MacroExpandingLexersStack;\n\n  /// A record of the macro definitions and expansions that\n  /// occurred during preprocessing.\n  ///\n  /// This is an optional side structure that can be enabled with\n  /// \\c createPreprocessingRecord() prior to preprocessing.\n  PreprocessingRecord *Record = nullptr;\n\n  /// Cached tokens state.\n  using CachedTokensTy = SmallVector<Token, 1>;\n\n  /// Cached tokens are stored here when we do backtracking or\n  /// lookahead. They are \"lexed\" by the CachingLex() method.\n  CachedTokensTy CachedTokens;\n\n  /// The position of the cached token that CachingLex() should\n  /// \"lex\" next.\n  ///\n  /// If it points beyond the CachedTokens vector, it means that a normal\n  /// Lex() should be invoked.\n  CachedTokensTy::size_type CachedLexPos = 0;\n\n  /// Stack of backtrack positions, allowing nested backtracks.\n  ///\n  /// The EnableBacktrackAtThisPos() method pushes a position to\n  /// indicate where CachedLexPos should be set when the BackTrack() method is\n  /// invoked (at which point the last position is popped).\n  std::vector<CachedTokensTy::size_type> BacktrackPositions;\n\n  struct MacroInfoChain {\n    MacroInfo MI;\n    MacroInfoChain *Next;\n  };\n\n  /// MacroInfos are managed as a chain for easy disposal.  This is the head\n  /// of that list.\n  MacroInfoChain *MIChainHead = nullptr;\n\n  void updateOutOfDateIdentifier(IdentifierInfo &II) const;\n\npublic:\n  Preprocessor(std::shared_ptr<PreprocessorOptions> PPOpts,\n               DiagnosticsEngine &diags, LangOptions &opts, SourceManager &SM,\n               HeaderSearch &Headers, ModuleLoader &TheModuleLoader,\n               IdentifierInfoLookup *IILookup = nullptr,\n               bool OwnsHeaderSearch = false,\n               TranslationUnitKind TUKind = TU_Complete);\n\n  ~Preprocessor();\n\n  /// Initialize the preprocessor using information about the target.\n  ///\n  /// \\param Target is owned by the caller and must remain valid for the\n  /// lifetime of the preprocessor.\n  /// \\param AuxTarget is owned by the caller and must remain valid for\n  /// the lifetime of the preprocessor.\n  void Initialize(const TargetInfo &Target,\n                  const TargetInfo *AuxTarget = nullptr);\n\n  /// Initialize the preprocessor to parse a model file\n  ///\n  /// To parse model files the preprocessor of the original source is reused to\n  /// preserver the identifier table. However to avoid some duplicate\n  /// information in the preprocessor some cleanup is needed before it is used\n  /// to parse model files. This method does that cleanup.\n  void InitializeForModelFile();\n\n  /// Cleanup after model file parsing\n  void FinalizeForModelFile();\n\n  /// Retrieve the preprocessor options used to initialize this\n  /// preprocessor.\n  PreprocessorOptions &getPreprocessorOpts() const { return *PPOpts; }\n\n  DiagnosticsEngine &getDiagnostics() const { return *Diags; }\n  void setDiagnostics(DiagnosticsEngine &D) { Diags = &D; }\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n  FileManager &getFileManager() const { return FileMgr; }\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  HeaderSearch &getHeaderSearchInfo() const { return HeaderInfo; }\n\n  IdentifierTable &getIdentifierTable() { return Identifiers; }\n  const IdentifierTable &getIdentifierTable() const { return Identifiers; }\n  SelectorTable &getSelectorTable() { return Selectors; }\n  Builtin::Context &getBuiltinInfo() { return *BuiltinInfo; }\n  llvm::BumpPtrAllocator &getPreprocessorAllocator() { return BP; }\n\n  void setExternalSource(ExternalPreprocessorSource *Source) {\n    ExternalSource = Source;\n  }\n\n  ExternalPreprocessorSource *getExternalSource() const {\n    return ExternalSource;\n  }\n\n  /// Retrieve the module loader associated with this preprocessor.\n  ModuleLoader &getModuleLoader() const { return TheModuleLoader; }\n\n  bool hadModuleLoaderFatalFailure() const {\n    return TheModuleLoader.HadFatalFailure;\n  }\n\n  /// Retrieve the number of Directives that have been processed by the\n  /// Preprocessor.\n  unsigned getNumDirectives() const {\n    return NumDirectives;\n  }\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool isParsingIfOrElifDirective() const {\n    return ParsingIfOrElifDirective;\n  }\n\n  /// Control whether the preprocessor retains comments in output.\n  void SetCommentRetentionState(bool KeepComments, bool KeepMacroComments) {\n    this->KeepComments = KeepComments | KeepMacroComments;\n    this->KeepMacroComments = KeepMacroComments;\n  }\n\n  bool getCommentRetentionState() const { return KeepComments; }\n\n  void setPragmasEnabled(bool Enabled) { PragmasEnabled = Enabled; }\n  bool getPragmasEnabled() const { return PragmasEnabled; }\n\n  void SetSuppressIncludeNotFoundError(bool Suppress) {\n    SuppressIncludeNotFoundError = Suppress;\n  }\n\n  bool GetSuppressIncludeNotFoundError() {\n    return SuppressIncludeNotFoundError;\n  }\n\n  /// Sets whether the preprocessor is responsible for producing output or if\n  /// it is producing tokens to be consumed by Parse and Sema.\n  void setPreprocessedOutput(bool IsPreprocessedOutput) {\n    PreprocessedOutput = IsPreprocessedOutput;\n  }\n\n  /// Returns true if the preprocessor is responsible for generating output,\n  /// false if it is producing tokens to be consumed by Parse and Sema.\n  bool isPreprocessedOutput() const { return PreprocessedOutput; }\n\n  /// Return true if we are lexing directly from the specified lexer.\n  bool isCurrentLexer(const PreprocessorLexer *L) const {\n    return CurPPLexer == L;\n  }\n\n  /// Return the current lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentLexer() const { return CurPPLexer; }\n\n  /// Return the current file lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentFileLexer() const;\n\n  /// Return the submodule owning the file being lexed. This may not be\n  /// the current module if we have changed modules since entering the file.\n  Module *getCurrentLexerSubmodule() const { return CurLexerSubmodule; }\n\n  /// Returns the FileID for the preprocessor predefines.\n  FileID getPredefinesFileID() const { return PredefinesFileID; }\n\n  /// \\{\n  /// Accessors for preprocessor callbacks.\n  ///\n  /// Note that this class takes ownership of any PPCallbacks object given to\n  /// it.\n  PPCallbacks *getPPCallbacks() const { return Callbacks.get(); }\n  void addPPCallbacks(std::unique_ptr<PPCallbacks> C) {\n    if (Callbacks)\n      C = std::make_unique<PPChainedCallbacks>(std::move(C),\n                                                std::move(Callbacks));\n    Callbacks = std::move(C);\n  }\n  /// \\}\n\n  /// Get the number of tokens processed so far.\n  unsigned getTokenCount() const { return TokenCount; }\n\n  /// Get the max number of tokens before issuing a -Wmax-tokens warning.\n  unsigned getMaxTokens() const { return MaxTokens; }\n\n  void overrideMaxTokens(unsigned Value, SourceLocation Loc) {\n    MaxTokens = Value;\n    MaxTokensOverrideLoc = Loc;\n  };\n\n  SourceLocation getMaxTokensOverrideLoc() const { return MaxTokensOverrideLoc; }\n\n  /// Register a function that would be called on each token in the final\n  /// expanded token stream.\n  /// This also reports annotation tokens produced by the parser.\n  void setTokenWatcher(llvm::unique_function<void(const clang::Token &)> F) {\n    OnToken = std::move(F);\n  }\n\n  void setPreprocessToken(bool Preprocess) { PreprocessToken = Preprocess; }\n\n  bool isMacroDefined(StringRef Id) {\n    return isMacroDefined(&Identifiers.get(Id));\n  }\n  bool isMacroDefined(const IdentifierInfo *II) {\n    return II->hasMacroDefinition() &&\n           (!getLangOpts().Modules || (bool)getMacroDefinition(II));\n  }\n\n  /// Determine whether II is defined as a macro within the module M,\n  /// if that is a module that we've already preprocessed. Does not check for\n  /// macros imported into M.\n  bool isMacroDefinedInLocalModule(const IdentifierInfo *II, Module *M) {\n    if (!II->hasMacroDefinition())\n      return false;\n    auto I = Submodules.find(M);\n    if (I == Submodules.end())\n      return false;\n    auto J = I->second.Macros.find(II);\n    if (J == I->second.Macros.end())\n      return false;\n    auto *MD = J->second.getLatest();\n    return MD && MD->isDefined();\n  }\n\n  MacroDefinition getMacroDefinition(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    auto *MD = S.getLatest();\n    while (MD && isa<VisibilityMacroDirective>(MD))\n      MD = MD->getPrevious();\n    return MacroDefinition(dyn_cast_or_null<DefMacroDirective>(MD),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  MacroDefinition getMacroDefinitionAtLoc(const IdentifierInfo *II,\n                                          SourceLocation Loc) {\n    if (!II->hadMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    MacroDirective::DefInfo DI;\n    if (auto *MD = S.getLatest())\n      DI = MD->findDirectiveAtLoc(Loc, getSourceManager());\n    // FIXME: Compute the set of active module macros at the specified location.\n    return MacroDefinition(DI.getDirective(),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  /// Given an identifier, return its latest non-imported MacroDirective\n  /// if it is \\#define'd and not \\#undef'd, or null if it isn't \\#define'd.\n  MacroDirective *getLocalMacroDirective(const IdentifierInfo *II) const {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n\n    auto *MD = getLocalMacroDirectiveHistory(II);\n    if (!MD || MD->getDefinition().isUndefined())\n      return nullptr;\n\n    return MD;\n  }\n\n  const MacroInfo *getMacroInfo(const IdentifierInfo *II) const {\n    return const_cast<Preprocessor*>(this)->getMacroInfo(II);\n  }\n\n  MacroInfo *getMacroInfo(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n    if (auto MD = getMacroDefinition(II))\n      return MD.getMacroInfo();\n    return nullptr;\n  }\n\n  /// Given an identifier, return the latest non-imported macro\n  /// directive for that identifier.\n  ///\n  /// One can iterate over all previous macro directives from the most recent\n  /// one.\n  MacroDirective *getLocalMacroDirectiveHistory(const IdentifierInfo *II) const;\n\n  /// Add a directive to the macro directive history for this identifier.\n  void appendMacroDirective(IdentifierInfo *II, MacroDirective *MD);\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II, MacroInfo *MI,\n                                             SourceLocation Loc) {\n    DefMacroDirective *MD = AllocateDefMacroDirective(MI, Loc);\n    appendMacroDirective(II, MD);\n    return MD;\n  }\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II,\n                                             MacroInfo *MI) {\n    return appendDefMacroDirective(II, MI, MI->getDefinitionLoc());\n  }\n\n  /// Set a MacroDirective that was loaded from a PCH file.\n  void setLoadedMacroDirective(IdentifierInfo *II, MacroDirective *ED,\n                               MacroDirective *MD);\n\n  /// Register an exported macro for a module and identifier.\n  ModuleMacro *addModuleMacro(Module *Mod, IdentifierInfo *II, MacroInfo *Macro,\n                              ArrayRef<ModuleMacro *> Overrides, bool &IsNew);\n  ModuleMacro *getModuleMacro(Module *Mod, IdentifierInfo *II);\n\n  /// Get the list of leaf (non-overridden) module macros for a name.\n  ArrayRef<ModuleMacro*> getLeafModuleMacros(const IdentifierInfo *II) const {\n    if (II->isOutOfDate())\n      updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n    auto I = LeafModuleMacros.find(II);\n    if (I != LeafModuleMacros.end())\n      return I->second;\n    return None;\n  }\n\n  /// \\{\n  /// Iterators for the macro history table. Currently defined macros have\n  /// IdentifierInfo::hasMacroDefinition() set and an empty\n  /// MacroInfo::getUndefLoc() at the head of the list.\n  using macro_iterator = MacroMap::const_iterator;\n\n  macro_iterator macro_begin(bool IncludeExternalMacros = true) const;\n  macro_iterator macro_end(bool IncludeExternalMacros = true) const;\n\n  llvm::iterator_range<macro_iterator>\n  macros(bool IncludeExternalMacros = true) const {\n    macro_iterator begin = macro_begin(IncludeExternalMacros);\n    macro_iterator end = macro_end(IncludeExternalMacros);\n    return llvm::make_range(begin, end);\n  }\n\n  /// \\}\n\n  /// Return the name of the macro defined before \\p Loc that has\n  /// spelling \\p Tokens.  If there are multiple macros with same spelling,\n  /// return the last one defined.\n  StringRef getLastMacroWithSpelling(SourceLocation Loc,\n                                     ArrayRef<TokenValue> Tokens) const;\n\n  const std::string &getPredefines() const { return Predefines; }\n\n  /// Set the predefines for this Preprocessor.\n  ///\n  /// These predefines are automatically injected when parsing the main file.\n  void setPredefines(const char *P) { Predefines = P; }\n  void setPredefines(StringRef P) { Predefines = std::string(P); }\n\n  /// Return information about the specified preprocessor\n  /// identifier token.\n  IdentifierInfo *getIdentifierInfo(StringRef Name) const {\n    return &Identifiers.get(Name);\n  }\n\n  /// Add the specified pragma handler to this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it is a token required to exist on the\n  /// pragma line before the pragma string starts, e.g. \"STDC\" or \"GCC\".\n  void AddPragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void AddPragmaHandler(PragmaHandler *Handler) {\n    AddPragmaHandler(StringRef(), Handler);\n  }\n\n  /// Remove the specific pragma handler from this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it should be the namespace that\n  /// \\p Handler was added to. It is an error to remove a handler that\n  /// has not been registered.\n  void RemovePragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void RemovePragmaHandler(PragmaHandler *Handler) {\n    RemovePragmaHandler(StringRef(), Handler);\n  }\n\n  /// Install empty handlers for all pragmas (making them ignored).\n  void IgnorePragmas();\n\n  /// Set empty line handler.\n  void setEmptylineHandler(EmptylineHandler *Handler) { Emptyline = Handler; }\n\n  EmptylineHandler *getEmptylineHandler() const { return Emptyline; }\n\n  /// Add the specified comment handler to the preprocessor.\n  void addCommentHandler(CommentHandler *Handler);\n\n  /// Remove the specified comment handler.\n  ///\n  /// It is an error to remove a handler that has not been registered.\n  void removeCommentHandler(CommentHandler *Handler);\n\n  /// Set the code completion handler to the given object.\n  void setCodeCompletionHandler(CodeCompletionHandler &Handler) {\n    CodeComplete = &Handler;\n  }\n\n  /// Retrieve the current code-completion handler.\n  CodeCompletionHandler *getCodeCompletionHandler() const {\n    return CodeComplete;\n  }\n\n  /// Clear out the code completion handler.\n  void clearCodeCompletionHandler() {\n    CodeComplete = nullptr;\n  }\n\n  /// Hook used by the lexer to invoke the \"included file\" code\n  /// completion point.\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);\n\n  /// Hook used by the lexer to invoke the \"natural language\" code\n  /// completion point.\n  void CodeCompleteNaturalLanguage();\n\n  /// Set the code completion token for filtering purposes.\n  void setCodeCompletionIdentifierInfo(IdentifierInfo *Filter) {\n    CodeCompletionII = Filter;\n  }\n\n  /// Set the code completion token range for detecting replacement range later\n  /// on.\n  void setCodeCompletionTokenRange(const SourceLocation Start,\n                                   const SourceLocation End) {\n    CodeCompletionTokenRange = {Start, End};\n  }\n  SourceRange getCodeCompletionTokenRange() const {\n    return CodeCompletionTokenRange;\n  }\n\n  /// Get the code completion token for filtering purposes.\n  StringRef getCodeCompletionFilter() {\n    if (CodeCompletionII)\n      return CodeCompletionII->getName();\n    return {};\n  }\n\n  /// Retrieve the preprocessing record, or NULL if there is no\n  /// preprocessing record.\n  PreprocessingRecord *getPreprocessingRecord() const { return Record; }\n\n  /// Create a new preprocessing record, which will keep track of\n  /// all macro expansions, macro definitions, etc.\n  void createPreprocessingRecord();\n\n  /// Returns true if the FileEntry is the PCH through header.\n  bool isPCHThroughHeader(const FileEntry *FE);\n\n  /// True if creating a PCH with a through header.\n  bool creatingPCHWithThroughHeader();\n\n  /// True if using a PCH with a through header.\n  bool usingPCHWithThroughHeader();\n\n  /// True if creating a PCH with a #pragma hdrstop.\n  bool creatingPCHWithPragmaHdrStop();\n\n  /// True if using a PCH with a #pragma hdrstop.\n  bool usingPCHWithPragmaHdrStop();\n\n  /// Skip tokens until after the #include of the through header or\n  /// until after a #pragma hdrstop.\n  void SkipTokensWhileUsingPCH();\n\n  /// Process directives while skipping until the through header or\n  /// #pragma hdrstop is found.\n  void HandleSkippedDirectiveWhileUsingPCH(Token &Result,\n                                           SourceLocation HashLoc);\n\n  /// Enter the specified FileID as the main source file,\n  /// which implicitly adds the builtin defines etc.\n  void EnterMainSourceFile();\n\n  /// Inform the preprocessor callbacks that processing is complete.\n  void EndSourceFile();\n\n  /// Add a source file to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  ///\n  /// Emits a diagnostic, doesn't enter the file, and returns true on error.\n  bool EnterSourceFile(FileID FID, const DirectoryLookup *Dir,\n                       SourceLocation Loc);\n\n  /// Add a Macro to the top of the include stack and start lexing\n  /// tokens from it instead of the current buffer.\n  ///\n  /// \\param Args specifies the tokens input to a function-like macro.\n  /// \\param ILEnd specifies the location of the ')' for a function-like macro\n  /// or the identifier for an object-like macro.\n  void EnterMacro(Token &Tok, SourceLocation ILEnd, MacroInfo *Macro,\n                  MacroArgs *Args);\n\nprivate:\n  /// Add a \"macro\" context to the top of the include stack,\n  /// which will cause the lexer to start returning the specified tokens.\n  ///\n  /// If \\p DisableMacroExpansion is true, tokens lexed from the token stream\n  /// will not be subject to further macro expansion. Otherwise, these tokens\n  /// will be re-macro-expanded when/if expansion is enabled.\n  ///\n  /// If \\p OwnsTokens is false, this method assumes that the specified stream\n  /// of tokens has a permanent owner somewhere, so they do not need to be\n  /// copied. If it is true, it assumes the array of tokens is allocated with\n  /// \\c new[] and the Preprocessor will delete[] it.\n  ///\n  /// If \\p IsReinject the resulting tokens will have Token::IsReinjected flag\n  /// set, see the flag documentation for details.\n  void EnterTokenStream(const Token *Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool OwnsTokens,\n                        bool IsReinject);\n\npublic:\n  void EnterTokenStream(std::unique_ptr<Token[]> Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool IsReinject) {\n    EnterTokenStream(Toks.release(), NumToks, DisableMacroExpansion, true,\n                     IsReinject);\n  }\n\n  void EnterTokenStream(ArrayRef<Token> Toks, bool DisableMacroExpansion,\n                        bool IsReinject) {\n    EnterTokenStream(Toks.data(), Toks.size(), DisableMacroExpansion, false,\n                     IsReinject);\n  }\n\n  /// Pop the current lexer/macro exp off the top of the lexer stack.\n  ///\n  /// This should only be used in situations where the current state of the\n  /// top-of-stack lexer is known.\n  void RemoveTopOfLexerStack();\n\n  /// From the point that this method is called, and until\n  /// CommitBacktrackedTokens() or Backtrack() is called, the Preprocessor\n  /// keeps track of the lexed tokens so that a subsequent Backtrack() call will\n  /// make the Preprocessor re-lex the same tokens.\n  ///\n  /// Nested backtracks are allowed, meaning that EnableBacktrackAtThisPos can\n  /// be called multiple times and CommitBacktrackedTokens/Backtrack calls will\n  /// be combined with the EnableBacktrackAtThisPos calls in reverse order.\n  ///\n  /// NOTE: *DO NOT* forget to call either CommitBacktrackedTokens or Backtrack\n  /// at some point after EnableBacktrackAtThisPos. If you don't, caching of\n  /// tokens will continue indefinitely.\n  ///\n  void EnableBacktrackAtThisPos();\n\n  /// Disable the last EnableBacktrackAtThisPos call.\n  void CommitBacktrackedTokens();\n\n  /// Make Preprocessor re-lex the tokens that were lexed since\n  /// EnableBacktrackAtThisPos() was previously called.\n  void Backtrack();\n\n  /// True if EnableBacktrackAtThisPos() was called and\n  /// caching of tokens is on.\n  bool isBacktrackEnabled() const { return !BacktrackPositions.empty(); }\n\n  /// Lex the next token for this preprocessor.\n  void Lex(Token &Result);\n\n  /// Lex a token, forming a header-name token if possible.\n  bool LexHeaderName(Token &Result, bool AllowMacroExpansion = true);\n\n  bool LexAfterModuleImport(Token &Result);\n  void CollectPpImportSuffix(SmallVectorImpl<Token> &Toks);\n\n  void makeModuleVisible(Module *M, SourceLocation Loc);\n\n  SourceLocation getModuleImportLoc(Module *M) const {\n    return CurSubmoduleState->VisibleModules.getImportLoc(M);\n  }\n\n  /// Lex a string literal, which may be the concatenation of multiple\n  /// string literals and may even come from macro expansion.\n  /// \\returns true on success, false if a error diagnostic has been generated.\n  bool LexStringLiteral(Token &Result, std::string &String,\n                        const char *DiagnosticTag, bool AllowMacroExpansion) {\n    if (AllowMacroExpansion)\n      Lex(Result);\n    else\n      LexUnexpandedToken(Result);\n    return FinishLexStringLiteral(Result, String, DiagnosticTag,\n                                  AllowMacroExpansion);\n  }\n\n  /// Complete the lexing of a string literal where the first token has\n  /// already been lexed (see LexStringLiteral).\n  bool FinishLexStringLiteral(Token &Result, std::string &String,\n                              const char *DiagnosticTag,\n                              bool AllowMacroExpansion);\n\n  /// Lex a token.  If it's a comment, keep lexing until we get\n  /// something not a comment.\n  ///\n  /// This is useful in -E -C mode where comments would foul up preprocessor\n  /// directive handling.\n  void LexNonComment(Token &Result) {\n    do\n      Lex(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Just like Lex, but disables macro expansion of identifier tokens.\n  void LexUnexpandedToken(Token &Result) {\n    // Disable macro expansion.\n    bool OldVal = DisableMacroExpansion;\n    DisableMacroExpansion = true;\n    // Lex the token.\n    Lex(Result);\n\n    // Reenable it.\n    DisableMacroExpansion = OldVal;\n  }\n\n  /// Like LexNonComment, but this disables macro expansion of\n  /// identifier tokens.\n  void LexUnexpandedNonComment(Token &Result) {\n    do\n      LexUnexpandedToken(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Parses a simple integer literal to get its numeric value.  Floating\n  /// point literals and user defined literals are rejected.  Used primarily to\n  /// handle pragmas that accept integer arguments.\n  bool parseSimpleIntegerLiteral(Token &Tok, uint64_t &Value);\n\n  /// Disables macro expansion everywhere except for preprocessor directives.\n  void SetMacroExpansionOnlyInDirectives() {\n    DisableMacroExpansion = true;\n    MacroExpansionInDirectivesOverride = true;\n  }\n\n  /// Peeks ahead N tokens and returns that token without consuming any\n  /// tokens.\n  ///\n  /// LookAhead(0) returns the next token that would be returned by Lex(),\n  /// LookAhead(1) returns the token after it, etc.  This returns normal\n  /// tokens after phase 5.  As such, it is equivalent to using\n  /// 'Lex', not 'LexUnexpandedToken'.\n  const Token &LookAhead(unsigned N) {\n    assert(LexLevel == 0 && \"cannot use lookahead while lexing\");\n    if (CachedLexPos + N < CachedTokens.size())\n      return CachedTokens[CachedLexPos+N];\n    else\n      return PeekAhead(N+1);\n  }\n\n  /// When backtracking is enabled and tokens are cached,\n  /// this allows to revert a specific number of tokens.\n  ///\n  /// Note that the number of tokens being reverted should be up to the last\n  /// backtrack position, not more.\n  void RevertCachedTokens(unsigned N) {\n    assert(isBacktrackEnabled() &&\n           \"Should only be called when tokens are cached for backtracking\");\n    assert(signed(CachedLexPos) - signed(N) >= signed(BacktrackPositions.back())\n         && \"Should revert tokens up to the last backtrack position, not more\");\n    assert(signed(CachedLexPos) - signed(N) >= 0 &&\n           \"Corrupted backtrack positions ?\");\n    CachedLexPos -= N;\n  }\n\n  /// Enters a token in the token stream to be lexed next.\n  ///\n  /// If BackTrack() is called afterwards, the token will remain at the\n  /// insertion point.\n  /// If \\p IsReinject is true, resulting token will have Token::IsReinjected\n  /// flag set. See the flag documentation for details.\n  void EnterToken(const Token &Tok, bool IsReinject) {\n    if (LexLevel) {\n      // It's not correct in general to enter caching lex mode while in the\n      // middle of a nested lexing action.\n      auto TokCopy = std::make_unique<Token[]>(1);\n      TokCopy[0] = Tok;\n      EnterTokenStream(std::move(TokCopy), 1, true, IsReinject);\n    } else {\n      EnterCachingLexMode();\n      assert(IsReinject && \"new tokens in the middle of cached stream\");\n      CachedTokens.insert(CachedTokens.begin()+CachedLexPos, Tok);\n    }\n  }\n\n  /// We notify the Preprocessor that if it is caching tokens (because\n  /// backtrack is enabled) it should replace the most recent cached tokens\n  /// with the given annotation token. This function has no effect if\n  /// backtracking is not enabled.\n  ///\n  /// Note that the use of this function is just for optimization, so that the\n  /// cached tokens doesn't get re-parsed and re-resolved after a backtrack is\n  /// invoked.\n  void AnnotateCachedTokens(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      AnnotatePreviousCachedTokens(Tok);\n  }\n\n  /// Get the location of the last cached token, suitable for setting the end\n  /// location of an annotation token.\n  SourceLocation getLastCachedTokenLocation() const {\n    assert(CachedLexPos != 0);\n    return CachedTokens[CachedLexPos-1].getLastLoc();\n  }\n\n  /// Whether \\p Tok is the most recent token (`CachedLexPos - 1`) in\n  /// CachedTokens.\n  bool IsPreviousCachedToken(const Token &Tok) const;\n\n  /// Replace token in `CachedLexPos - 1` in CachedTokens by the tokens\n  /// in \\p NewToks.\n  ///\n  /// Useful when a token needs to be split in smaller ones and CachedTokens\n  /// most recent token must to be updated to reflect that.\n  void ReplacePreviousCachedToken(ArrayRef<Token> NewToks);\n\n  /// Replace the last token with an annotation token.\n  ///\n  /// Like AnnotateCachedTokens(), this routine replaces an\n  /// already-parsed (and resolved) token with an annotation\n  /// token. However, this routine only replaces the last token with\n  /// the annotation token; it does not affect any other cached\n  /// tokens. This function has no effect if backtracking is not\n  /// enabled.\n  void ReplaceLastTokenWithAnnotation(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Enter an annotation token into the token stream.\n  void EnterAnnotationToken(SourceRange Range, tok::TokenKind Kind,\n                            void *AnnotationVal);\n\n  /// Determine whether it's possible for a future call to Lex to produce an\n  /// annotation token created by a previous call to EnterAnnotationToken.\n  bool mightHavePendingAnnotationTokens() {\n    return CurLexerKind != CLK_Lexer;\n  }\n\n  /// Update the current token to represent the provided\n  /// identifier, in order to cache an action performed by typo correction.\n  void TypoCorrectToken(const Token &Tok) {\n    assert(Tok.getIdentifierInfo() && \"Expected identifier token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Recompute the current lexer kind based on the CurLexer/\n  /// CurTokenLexer pointers.\n  void recomputeCurLexerKind();\n\n  /// Returns true if incremental processing is enabled\n  bool isIncrementalProcessingEnabled() const { return IncrementalProcessing; }\n\n  /// Enables the incremental processing\n  void enableIncrementalProcessing(bool value = true) {\n    IncrementalProcessing = value;\n  }\n\n  /// Specify the point at which code-completion will be performed.\n  ///\n  /// \\param File the file in which code completion should occur. If\n  /// this file is included multiple times, code-completion will\n  /// perform completion the first time it is included. If NULL, this\n  /// function clears out the code-completion point.\n  ///\n  /// \\param Line the line at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\param Column the column at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool SetCodeCompletionPoint(const FileEntry *File,\n                              unsigned Line, unsigned Column);\n\n  /// Determine if we are performing code completion.\n  bool isCodeCompletionEnabled() const { return CodeCompletionFile != nullptr; }\n\n  /// Returns the location of the code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionLoc() const { return CodeCompletionLoc; }\n\n  /// Returns the start location of the file of code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionFileLoc() const {\n    return CodeCompletionFileLoc;\n  }\n\n  /// Returns true if code-completion is enabled and we have hit the\n  /// code-completion point.\n  bool isCodeCompletionReached() const { return CodeCompletionReached; }\n\n  /// Note that we hit the code-completion point.\n  void setCodeCompletionReached() {\n    assert(isCodeCompletionEnabled() && \"Code-completion not enabled!\");\n    CodeCompletionReached = true;\n    // Silence any diagnostics that occur after we hit the code-completion.\n    getDiagnostics().setSuppressAllDiagnostics(true);\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  std::pair<IdentifierInfo *, SourceLocation>\n  getPragmaARCCFCodeAuditedInfo() const {\n    return PragmaARCCFCodeAuditedInfo;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.  An invalid location ends the pragma.\n  void setPragmaARCCFCodeAuditedInfo(IdentifierInfo *Ident,\n                                     SourceLocation Loc) {\n    PragmaARCCFCodeAuditedInfo = {Ident, Loc};\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  SourceLocation getPragmaAssumeNonNullLoc() const {\n    return PragmaAssumeNonNullLoc;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.  An invalid location ends the pragma.\n  void setPragmaAssumeNonNullLoc(SourceLocation Loc) {\n    PragmaAssumeNonNullLoc = Loc;\n  }\n\n  /// Set the directory in which the main file should be considered\n  /// to have been found, if it is not a real file.\n  void setMainFileDir(const DirectoryEntry *Dir) {\n    MainFileDir = Dir;\n  }\n\n  /// Instruct the preprocessor to skip part of the main source file.\n  ///\n  /// \\param Bytes The number of bytes in the preamble to skip.\n  ///\n  /// \\param StartOfLine Whether skipping these bytes puts the lexer at the\n  /// start of a line.\n  void setSkipMainFilePreamble(unsigned Bytes, bool StartOfLine) {\n    SkipMainFilePreamble.first = Bytes;\n    SkipMainFilePreamble.second = StartOfLine;\n  }\n\n  /// Forwarding function for diagnostics.  This emits a diagnostic at\n  /// the specified Token's location, translating the token's start\n  /// position in the current buffer into a SourcePosition object for rendering.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const {\n    return Diags->Report(Loc, DiagID);\n  }\n\n  DiagnosticBuilder Diag(const Token &Tok, unsigned DiagID) const {\n    return Diags->Report(Tok.getLocation(), DiagID);\n  }\n\n  /// Return the 'spelling' of the token at the given\n  /// location; does not go up to the spelling location or down to the\n  /// expansion location.\n  ///\n  /// \\param buffer A buffer which will be used only if the token requires\n  ///   \"cleaning\", e.g. if it contains trigraphs or escaped newlines\n  /// \\param invalid If non-null, will be set \\c true if an error occurs.\n  StringRef getSpelling(SourceLocation loc,\n                        SmallVectorImpl<char> &buffer,\n                        bool *invalid = nullptr) const {\n    return Lexer::getSpelling(loc, buffer, SourceMgr, LangOpts, invalid);\n  }\n\n  /// Return the 'spelling' of the Tok token.\n  ///\n  /// The spelling of a token is the characters used to represent the token in\n  /// the source file after trigraph expansion and escaped-newline folding.  In\n  /// particular, this wants to get the true, uncanonicalized, spelling of\n  /// things like digraphs, UCNs, etc.\n  ///\n  /// \\param Invalid If non-null, will be set \\c true if an error occurs.\n  std::string getSpelling(const Token &Tok, bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a preallocated buffer, instead\n  /// of as an std::string.\n  ///\n  /// The caller is required to allocate enough space for the token, which is\n  /// guaranteed to be at least Tok.getLength() bytes long. The length of the\n  /// actual result is returned.\n  ///\n  /// Note that this method may do two possible things: it may either fill in\n  /// the buffer specified with characters, or it may *change the input pointer*\n  /// to point to a constant buffer with the data already in it (avoiding a\n  /// copy).  The caller is not allowed to modify the returned buffer pointer\n  /// if an internal buffer is returned.\n  unsigned getSpelling(const Token &Tok, const char *&Buffer,\n                       bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, Buffer, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a SmallVector.\n  ///\n  /// Note that the returned StringRef may not point to the\n  /// supplied buffer if a copy can be avoided.\n  StringRef getSpelling(const Token &Tok,\n                        SmallVectorImpl<char> &Buffer,\n                        bool *Invalid = nullptr) const;\n\n  /// Relex the token at the specified location.\n  /// \\returns true if there was a failure, false on success.\n  bool getRawToken(SourceLocation Loc, Token &Result,\n                   bool IgnoreWhiteSpace = false) {\n    return Lexer::getRawToken(Loc, Result, SourceMgr, LangOpts, IgnoreWhiteSpace);\n  }\n\n  /// Given a Token \\p Tok that is a numeric constant with length 1,\n  /// return the character.\n  char\n  getSpellingOfSingleCharacterNumericConstant(const Token &Tok,\n                                              bool *Invalid = nullptr) const {\n    assert(Tok.is(tok::numeric_constant) &&\n           Tok.getLength() == 1 && \"Called on unsupported token\");\n    assert(!Tok.needsCleaning() && \"Token can't need cleaning with length 1\");\n\n    // If the token is carrying a literal data pointer, just use it.\n    if (const char *D = Tok.getLiteralData())\n      return *D;\n\n    // Otherwise, fall back on getCharacterData, which is slower, but always\n    // works.\n    return *SourceMgr.getCharacterData(Tok.getLocation(), Invalid);\n  }\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the\n  /// macro responsible for its immediate expansion. It looks through any\n  /// intervening macro argument expansions to compute this. It returns a\n  /// StringRef that refers to the SourceManager-owned buffer of the source\n  /// where that macro name is spelled. Thus, the result shouldn't out-live\n  /// the SourceManager.\n  StringRef getImmediateMacroName(SourceLocation Loc) {\n    return Lexer::getImmediateMacroName(Loc, SourceMgr, getLangOpts());\n  }\n\n  /// Plop the specified string into a scratch buffer and set the\n  /// specified token's location and length to it.\n  ///\n  /// If specified, the source location provides a location of the expansion\n  /// point of the token.\n  void CreateString(StringRef Str, Token &Tok,\n                    SourceLocation ExpansionLocStart = SourceLocation(),\n                    SourceLocation ExpansionLocEnd = SourceLocation());\n\n  /// Split the first Length characters out of the token starting at TokLoc\n  /// and return a location pointing to the split token. Re-lexing from the\n  /// split token will return the split token rather than the original.\n  SourceLocation SplitToken(SourceLocation TokLoc, unsigned Length);\n\n  /// Computes the source location just past the end of the\n  /// token at this source location.\n  ///\n  /// This routine can be used to produce a source location that\n  /// points just past the end of the token referenced by \\p Loc, and\n  /// is generally used when a diagnostic needs to point just after a\n  /// token where it expected something different that it received. If\n  /// the returned source location would not be meaningful (e.g., if\n  /// it points into a macro), this routine returns an invalid\n  /// source location.\n  ///\n  /// \\param Offset an offset from the end of the token, where the source\n  /// location should refer to. The default offset (0) produces a source\n  /// location pointing just past the end of the token; an offset of 1 produces\n  /// a source location pointing to the last character in the token, etc.\n  SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset = 0) {\n    return Lexer::getLocForEndOfToken(Loc, Offset, SourceMgr, LangOpts);\n  }\n\n  /// Returns true if the given MacroID location points at the first\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to\n  /// begin location of the macro.\n  bool isAtStartOfMacroExpansion(SourceLocation loc,\n                                 SourceLocation *MacroBegin = nullptr) const {\n    return Lexer::isAtStartOfMacroExpansion(loc, SourceMgr, LangOpts,\n                                            MacroBegin);\n  }\n\n  /// Returns true if the given MacroID location points at the last\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to\n  /// end location of the macro.\n  bool isAtEndOfMacroExpansion(SourceLocation loc,\n                               SourceLocation *MacroEnd = nullptr) const {\n    return Lexer::isAtEndOfMacroExpansion(loc, SourceMgr, LangOpts, MacroEnd);\n  }\n\n  /// Print the token to stderr, used for debugging.\n  void DumpToken(const Token &Tok, bool DumpFlags = false) const;\n  void DumpLocation(SourceLocation Loc) const;\n  void DumpMacro(const MacroInfo &MI) const;\n  void dumpMacroInfo(const IdentifierInfo *II);\n\n  /// Given a location that specifies the start of a\n  /// token, return a new location that specifies a character within the token.\n  SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,\n                                         unsigned Char) const {\n    return Lexer::AdvanceToTokenCharacter(TokStart, Char, SourceMgr, LangOpts);\n  }\n\n  /// Increment the counters for the number of token paste operations\n  /// performed.\n  ///\n  /// If fast was specified, this is a 'fast paste' case we handled.\n  void IncrementPasteCounter(bool isFast) {\n    if (isFast)\n      ++NumFastTokenPaste;\n    else\n      ++NumTokenPaste;\n  }\n\n  void PrintStats();\n\n  size_t getTotalMemory() const;\n\n  /// When the macro expander pastes together a comment (/##/) in Microsoft\n  /// mode, this method handles updating the current state, returning the\n  /// token on the next source line.\n  void HandleMicrosoftCommentPaste(Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  // Preprocessor callback methods.  These are invoked by a lexer as various\n  // directives and events are found.\n\n  /// Given a tok::raw_identifier token, look up the\n  /// identifier information for the token and install it into the token,\n  /// updating the token kind accordingly.\n  IdentifierInfo *LookUpIdentifierInfo(Token &Identifier) const;\n\nprivate:\n  llvm::DenseMap<IdentifierInfo*,unsigned> PoisonReasons;\n\npublic:\n  /// Specifies the reason for poisoning an identifier.\n  ///\n  /// If that identifier is accessed while poisoned, then this reason will be\n  /// used instead of the default \"poisoned\" diagnostic.\n  void SetPoisonReason(IdentifierInfo *II, unsigned DiagID);\n\n  /// Display reason for poisoned identifier.\n  void HandlePoisonedIdentifier(Token & Identifier);\n\n  void MaybeHandlePoisonedIdentifier(Token & Identifier) {\n    if(IdentifierInfo * II = Identifier.getIdentifierInfo()) {\n      if(II->isPoisoned()) {\n        HandlePoisonedIdentifier(Identifier);\n      }\n    }\n  }\n\nprivate:\n  /// Identifiers used for SEH handling in Borland. These are only\n  /// allowed in particular circumstances\n  // __except block\n  IdentifierInfo *Ident__exception_code,\n                 *Ident___exception_code,\n                 *Ident_GetExceptionCode;\n  // __except filter expression\n  IdentifierInfo *Ident__exception_info,\n                 *Ident___exception_info,\n                 *Ident_GetExceptionInfo;\n  // __finally\n  IdentifierInfo *Ident__abnormal_termination,\n                 *Ident___abnormal_termination,\n                 *Ident_AbnormalTermination;\n\n  const char *getCurLexerEndPos();\n  void diagnoseMissingHeaderInUmbrellaDir(const Module &Mod);\n\npublic:\n  void PoisonSEHIdentifiers(bool Poison = true); // Borland\n\n  /// Callback invoked when the lexer reads an identifier and has\n  /// filled in the tokens IdentifierInfo member.\n  ///\n  /// This callback potentially macro expands it or turns it into a named\n  /// token (like 'for').\n  ///\n  /// \\returns true if we actually computed a token, false if we need to\n  /// lex again.\n  bool HandleIdentifier(Token &Identifier);\n\n  /// Callback invoked when the lexer hits the end of the current file.\n  ///\n  /// This either returns the EOF token and returns true, or\n  /// pops a level off the include stack and returns false, at which point the\n  /// client should call lex again.\n  bool HandleEndOfFile(Token &Result, bool isEndOfMacro = false);\n\n  /// Callback invoked when the current TokenLexer hits the end of its\n  /// token stream.\n  bool HandleEndOfTokenLexer(Token &Result);\n\n  /// Callback invoked when the lexer sees a # token at the start of a\n  /// line.\n  ///\n  /// This consumes the directive, modifies the lexer/preprocessor state, and\n  /// advances the lexer(s) so that the next token read is the correct one.\n  void HandleDirective(Token &Result);\n\n  /// Ensure that the next token is a tok::eod token.\n  ///\n  /// If not, emit a diagnostic and consume up until the eod.\n  /// If \\p EnableMacros is true, then we consider macros that expand to zero\n  /// tokens as being ok.\n  ///\n  /// \\return The location of the end of the directive (the terminating\n  /// newline).\n  SourceLocation CheckEndOfDirective(const char *DirType,\n                                     bool EnableMacros = false);\n\n  /// Read and discard all tokens remaining on the current line until\n  /// the tok::eod token is found. Returns the range of the skipped tokens.\n  SourceRange DiscardUntilEndOfDirective();\n\n  /// Returns true if the preprocessor has seen a use of\n  /// __DATE__ or __TIME__ in the file so far.\n  bool SawDateOrTime() const {\n    return DATELoc != SourceLocation() || TIMELoc != SourceLocation();\n  }\n  unsigned getCounterValue() const { return CounterValue; }\n  void setCounterValue(unsigned V) { CounterValue = V; }\n\n  /// Retrieves the module that we're currently building, if any.\n  Module *getCurrentModule();\n\n  /// Allocate a new MacroInfo object with the provided SourceLocation.\n  MacroInfo *AllocateMacroInfo(SourceLocation L);\n\n  /// Turn the specified lexer token into a fully checked and spelled\n  /// filename, e.g. as an operand of \\#include.\n  ///\n  /// The caller is expected to provide a buffer that is large enough to hold\n  /// the spelling of the filename, but is also expected to handle the case\n  /// when this method decides to use a different buffer.\n  ///\n  /// \\returns true if the input filename was in <>'s or false if it was\n  /// in \"\"'s.\n  bool GetIncludeFilenameSpelling(SourceLocation Loc,StringRef &Buffer);\n\n  /// Given a \"foo\" or \\<foo> reference, look up the indicated file.\n  ///\n  /// Returns None on failure.  \\p isAngled indicates whether the file\n  /// reference is for system \\#include's or not (i.e. using <> instead of \"\").\n  Optional<FileEntryRef>\n  LookupFile(SourceLocation FilenameLoc, StringRef Filename, bool isAngled,\n             const DirectoryLookup *FromDir, const FileEntry *FromFile,\n             const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,\n             SmallVectorImpl<char> *RelativePath,\n             ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,\n             bool *IsFrameworkFound, bool SkipCache = false);\n\n  /// Get the DirectoryLookup structure used to find the current\n  /// FileEntry, if CurLexer is non-null and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *GetCurDirLookup() { return CurDirLookup; }\n\n  /// Return true if we're in the top-level file, not in a \\#include.\n  bool isInPrimaryFile() const;\n\n  /// Lex an on-off-switch (C99 6.10.6p2) and verify that it is\n  /// followed by EOD.  Return true if the token is not a valid on-off-switch.\n  bool LexOnOffSwitch(tok::OnOffSwitch &Result);\n\n  bool CheckMacroName(Token &MacroNameTok, MacroUse isDefineUndef,\n                      bool *ShadowFlag = nullptr);\n\n  void EnterSubmodule(Module *M, SourceLocation ImportLoc, bool ForPragma);\n  Module *LeaveSubmodule(bool ForPragma);\n\nprivate:\n  friend void TokenLexer::ExpandFunctionArguments();\n\n  void PushIncludeMacroStack() {\n    assert(CurLexerKind != CLK_CachingLexer && \"cannot push a caching lexer\");\n    IncludeMacroStack.emplace_back(CurLexerKind, CurLexerSubmodule,\n                                   std::move(CurLexer), CurPPLexer,\n                                   std::move(CurTokenLexer), CurDirLookup);\n    CurPPLexer = nullptr;\n  }\n\n  void PopIncludeMacroStack() {\n    CurLexer = std::move(IncludeMacroStack.back().TheLexer);\n    CurPPLexer = IncludeMacroStack.back().ThePPLexer;\n    CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);\n    CurDirLookup  = IncludeMacroStack.back().TheDirLookup;\n    CurLexerSubmodule = IncludeMacroStack.back().TheSubmodule;\n    CurLexerKind = IncludeMacroStack.back().CurLexerKind;\n    IncludeMacroStack.pop_back();\n  }\n\n  void PropagateLineStartLeadingSpaceInfo(Token &Result);\n\n  /// Determine whether we need to create module macros for #defines in the\n  /// current context.\n  bool needModuleMacros() const;\n\n  /// Update the set of active module macros and ambiguity flag for a module\n  /// macro name.\n  void updateModuleMacroInfo(const IdentifierInfo *II, ModuleMacroInfo &Info);\n\n  DefMacroDirective *AllocateDefMacroDirective(MacroInfo *MI,\n                                               SourceLocation Loc);\n  UndefMacroDirective *AllocateUndefMacroDirective(SourceLocation UndefLoc);\n  VisibilityMacroDirective *AllocateVisibilityMacroDirective(SourceLocation Loc,\n                                                             bool isPublic);\n\n  /// Lex and validate a macro name, which occurs after a\n  /// \\#define or \\#undef.\n  ///\n  /// \\param MacroNameTok Token that represents the name defined or undefined.\n  /// \\param IsDefineUndef Kind if preprocessor directive.\n  /// \\param ShadowFlag Points to flag that is set if macro name shadows\n  ///                   a keyword.\n  ///\n  /// This emits a diagnostic, sets the token kind to eod,\n  /// and discards the rest of the macro line if the macro name is invalid.\n  void ReadMacroName(Token &MacroNameTok, MacroUse IsDefineUndef = MU_Other,\n                     bool *ShadowFlag = nullptr);\n\n  /// ReadOptionalMacroParameterListAndBody - This consumes all (i.e. the\n  /// entire line) of the macro's tokens and adds them to MacroInfo, and while\n  /// doing so performs certain validity checks including (but not limited to):\n  ///   - # (stringization) is followed by a macro parameter\n  /// \\param MacroNameTok - Token that represents the macro name\n  /// \\param ImmediatelyAfterHeaderGuard - Macro follows an #ifdef header guard\n  ///\n  ///  Either returns a pointer to a MacroInfo object OR emits a diagnostic and\n  ///  returns a nullptr if an invalid sequence of tokens is encountered.\n  MacroInfo *ReadOptionalMacroParameterListAndBody(\n      const Token &MacroNameTok, bool ImmediatelyAfterHeaderGuard);\n\n  /// The ( starting an argument list of a macro definition has just been read.\n  /// Lex the rest of the parameters and the closing ), updating \\p MI with\n  /// what we learn and saving in \\p LastTok the last token read.\n  /// Return true if an error occurs parsing the arg list.\n  bool ReadMacroParameterList(MacroInfo *MI, Token& LastTok);\n\n  /// We just read a \\#if or related directive and decided that the\n  /// subsequent tokens are in the \\#if'd out portion of the\n  /// file.  Lex the rest of the file, until we see an \\#endif.  If \\p\n  /// FoundNonSkipPortion is true, then we have already emitted code for part of\n  /// this \\#if directive, so \\#else/\\#elif blocks should never be entered. If\n  /// \\p FoundElse is false, then \\#else directives are ok, if not, then we have\n  /// already seen one so a \\#else directive is a duplicate.  When this returns,\n  /// the caller can lex the first valid token.\n  void SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,\n                                    SourceLocation IfTokenLoc,\n                                    bool FoundNonSkipPortion, bool FoundElse,\n                                    SourceLocation ElseLoc = SourceLocation());\n\n  /// Information about the result for evaluating an expression for a\n  /// preprocessor directive.\n  struct DirectiveEvalResult {\n    /// Whether the expression was evaluated as true or not.\n    bool Conditional;\n\n    /// True if the expression contained identifiers that were undefined.\n    bool IncludedUndefinedIds;\n\n    /// The source range for the expression.\n    SourceRange ExprRange;\n  };\n\n  /// Evaluate an integer constant expression that may occur after a\n  /// \\#if or \\#elif directive and return a \\p DirectiveEvalResult object.\n  ///\n  /// If the expression is equivalent to \"!defined(X)\" return X in IfNDefMacro.\n  DirectiveEvalResult EvaluateDirectiveExpression(IdentifierInfo *&IfNDefMacro);\n\n  /// Install the standard preprocessor pragmas:\n  /// \\#pragma GCC poison/system_header/dependency and \\#pragma once.\n  void RegisterBuiltinPragmas();\n\n  /// Register builtin macros such as __LINE__ with the identifier table.\n  void RegisterBuiltinMacros();\n\n  /// If an identifier token is read that is to be expanded as a macro, handle\n  /// it and return the next token as 'Tok'.  If we lexed a token, return true;\n  /// otherwise the caller should lex again.\n  bool HandleMacroExpandedIdentifier(Token &Identifier, const MacroDefinition &MD);\n\n  /// Cache macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  Token *cacheMacroExpandedTokens(TokenLexer *tokLexer,\n                                  ArrayRef<Token> tokens);\n\n  void removeCachedMacroExpandedTokensOfLastLexer();\n\n  /// Determine whether the next preprocessor token to be\n  /// lexed is a '('.  If so, consume the token and return true, if not, this\n  /// method should have no observable side-effect on the lexed tokens.\n  bool isNextPPTokenLParen();\n\n  /// After reading \"MACRO(\", this method is invoked to read all of the formal\n  /// arguments specified for the macro invocation.  Returns null on error.\n  MacroArgs *ReadMacroCallArgumentList(Token &MacroName, MacroInfo *MI,\n                                       SourceLocation &MacroEnd);\n\n  /// If an identifier token is read that is to be expanded\n  /// as a builtin macro, handle it and return the next token as 'Tok'.\n  void ExpandBuiltinMacro(Token &Tok);\n\n  /// Read a \\c _Pragma directive, slice it up, process it, then\n  /// return the first token after the directive.\n  /// This assumes that the \\c _Pragma token has just been read into \\p Tok.\n  void Handle_Pragma(Token &Tok);\n\n  /// Like Handle_Pragma except the pragma text is not enclosed within\n  /// a string literal.\n  void HandleMicrosoft__pragma(Token &Tok);\n\n  /// Add a lexer to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  void EnterSourceFileWithLexer(Lexer *TheLexer, const DirectoryLookup *Dir);\n\n  /// Set the FileID for the preprocessor predefines.\n  void setPredefinesFileID(FileID FID) {\n    assert(PredefinesFileID.isInvalid() && \"PredefinesFileID already set!\");\n    PredefinesFileID = FID;\n  }\n\n  /// Set the FileID for the PCH through header.\n  void setPCHThroughHeaderFileID(FileID FID);\n\n  /// Returns true if we are lexing from a file and not a\n  /// pragma or a macro.\n  static bool IsFileLexer(const Lexer* L, const PreprocessorLexer* P) {\n    return L ? !L->isPragmaLexer() : P != nullptr;\n  }\n\n  static bool IsFileLexer(const IncludeStackInfo& I) {\n    return IsFileLexer(I.TheLexer.get(), I.ThePPLexer);\n  }\n\n  bool IsFileLexer() const {\n    return IsFileLexer(CurLexer.get(), CurPPLexer);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Caching stuff.\n  void CachingLex(Token &Result);\n\n  bool InCachingLexMode() const {\n    // If the Lexer pointers are 0 and IncludeMacroStack is empty, it means\n    // that we are past EOF, not that we are in CachingLex mode.\n    return !CurPPLexer && !CurTokenLexer && !IncludeMacroStack.empty();\n  }\n\n  void EnterCachingLexMode();\n  void EnterCachingLexModeUnchecked();\n\n  void ExitCachingLexMode() {\n    if (InCachingLexMode())\n      RemoveTopOfLexerStack();\n  }\n\n  const Token &PeekAhead(unsigned N);\n  void AnnotatePreviousCachedTokens(const Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  /// Handle*Directive - implement the various preprocessor directives.  These\n  /// should side-effect the current preprocessor object so that the next call\n  /// to Lex() will return the appropriate token next.\n  void HandleLineDirective();\n  void HandleDigitDirective(Token &Tok);\n  void HandleUserDiagnosticDirective(Token &Tok, bool isWarning);\n  void HandleIdentSCCSDirective(Token &Tok);\n  void HandleMacroPublicDirective(Token &Tok);\n  void HandleMacroPrivateDirective();\n\n  /// An additional notification that can be produced by a header inclusion or\n  /// import to tell the parser what happened.\n  struct ImportAction {\n    enum ActionKind {\n      None,\n      ModuleBegin,\n      ModuleImport,\n      SkippedModuleImport,\n      Failure,\n    } Kind;\n    Module *ModuleForHeader = nullptr;\n\n    ImportAction(ActionKind AK, Module *Mod = nullptr)\n        : Kind(AK), ModuleForHeader(Mod) {\n      assert((AK == None || Mod || AK == Failure) &&\n             \"no module for module action\");\n    }\n  };\n\n  Optional<FileEntryRef> LookupHeaderIncludeOrImport(\n      const DirectoryLookup *&CurDir, StringRef &Filename,\n      SourceLocation FilenameLoc, CharSourceRange FilenameRange,\n      const Token &FilenameTok, bool &IsFrameworkFound, bool IsImportDecl,\n      bool &IsMapped, const DirectoryLookup *LookupFrom,\n      const FileEntry *LookupFromFile, StringRef &LookupFilename,\n      SmallVectorImpl<char> &RelativePath, SmallVectorImpl<char> &SearchPath,\n      ModuleMap::KnownHeader &SuggestedModule, bool isAngled);\n\n  // File inclusion.\n  void HandleIncludeDirective(SourceLocation HashLoc, Token &Tok,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  ImportAction\n  HandleHeaderIncludeOrImport(SourceLocation HashLoc, Token &IncludeTok,\n                              Token &FilenameTok, SourceLocation EndLoc,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  void HandleIncludeNextDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleIncludeMacrosDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleImportDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleMicrosoftImportDirective(Token &Tok);\n\npublic:\n  /// Check that the given module is available, producing a diagnostic if not.\n  /// \\return \\c true if the check failed (because the module is not available).\n  ///         \\c false if the module appears to be usable.\n  static bool checkModuleIsAvailable(const LangOptions &LangOpts,\n                                     const TargetInfo &TargetInfo,\n                                     DiagnosticsEngine &Diags, Module *M);\n\n  // Module inclusion testing.\n  /// Find the module that owns the source or header file that\n  /// \\p Loc points to. If the location is in a file that was included\n  /// into a module, or is outside any module, returns nullptr.\n  Module *getModuleForLocation(SourceLocation Loc);\n\n  /// We want to produce a diagnostic at location IncLoc concerning an\n  /// unreachable effect at location MLoc (eg, where a desired entity was\n  /// declared or defined). Determine whether the right way to make MLoc\n  /// reachable is by #include, and if so, what header should be included.\n  ///\n  /// This is not necessarily fast, and might load unexpected module maps, so\n  /// should only be called by code that intends to produce an error.\n  ///\n  /// \\param IncLoc The location at which the missing effect was detected.\n  /// \\param MLoc A location within an unimported module at which the desired\n  ///        effect occurred.\n  /// \\return A file that can be #included to provide the desired effect. Null\n  ///         if no such file could be determined or if a #include is not\n  ///         appropriate (eg, if a module should be imported instead).\n  const FileEntry *getHeaderToIncludeForDiagnostics(SourceLocation IncLoc,\n                                                    SourceLocation MLoc);\n\n  bool isRecordingPreamble() const {\n    return PreambleConditionalStack.isRecording();\n  }\n\n  bool hasRecordedPreamble() const {\n    return PreambleConditionalStack.hasRecordedPreamble();\n  }\n\n  ArrayRef<PPConditionalInfo> getPreambleConditionalStack() const {\n      return PreambleConditionalStack.getStack();\n  }\n\n  void setRecordedPreambleConditionalStack(ArrayRef<PPConditionalInfo> s) {\n    PreambleConditionalStack.setStack(s);\n  }\n\n  void setReplayablePreambleConditionalStack(ArrayRef<PPConditionalInfo> s,\n                                             llvm::Optional<PreambleSkipInfo> SkipInfo) {\n    PreambleConditionalStack.startReplaying();\n    PreambleConditionalStack.setStack(s);\n    PreambleConditionalStack.SkipInfo = SkipInfo;\n  }\n\n  llvm::Optional<PreambleSkipInfo> getPreambleSkipInfo() const {\n    return PreambleConditionalStack.SkipInfo;\n  }\n\nprivate:\n  /// After processing predefined file, initialize the conditional stack from\n  /// the preamble.\n  void replayPreambleConditionalStack();\n\n  // Macro handling.\n  void HandleDefineDirective(Token &Tok, bool ImmediatelyAfterHeaderGuard);\n  void HandleUndefDirective();\n\n  // Conditional Inclusion.\n  void HandleIfdefDirective(Token &Result, const Token &HashToken,\n                            bool isIfndef, bool ReadAnyTokensBeforeDirective);\n  void HandleIfDirective(Token &IfToken, const Token &HashToken,\n                         bool ReadAnyTokensBeforeDirective);\n  void HandleEndifDirective(Token &EndifToken);\n  void HandleElseDirective(Token &Result, const Token &HashToken);\n  void HandleElifDirective(Token &ElifToken, const Token &HashToken);\n\n  // Pragmas.\n  void HandlePragmaDirective(PragmaIntroducer Introducer);\n\npublic:\n  void HandlePragmaOnce(Token &OnceTok);\n  void HandlePragmaMark();\n  void HandlePragmaPoison();\n  void HandlePragmaSystemHeader(Token &SysHeaderTok);\n  void HandlePragmaDependency(Token &DependencyTok);\n  void HandlePragmaPushMacro(Token &Tok);\n  void HandlePragmaPopMacro(Token &Tok);\n  void HandlePragmaIncludeAlias(Token &Tok);\n  void HandlePragmaModuleBuild(Token &Tok);\n  void HandlePragmaHdrstop(Token &Tok);\n  IdentifierInfo *ParsePragmaPushOrPopMacro(Token &Tok);\n\n  // Return true and store the first token only if any CommentHandler\n  // has inserted some tokens and getCommentRetentionState() is false.\n  bool HandleComment(Token &result, SourceRange Comment);\n\n  /// A macro is used, update information about macros that need unused\n  /// warnings.\n  void markMacroAsUsed(MacroInfo *MI);\n\nprivate:\n  Optional<unsigned>\n  getSkippedRangeForExcludedConditionalBlock(SourceLocation HashLoc);\n\n  /// Contains the currently active skipped range mappings for skipping excluded\n  /// conditional directives.\n  ExcludedPreprocessorDirectiveSkipMapping\n      *ExcludedConditionalDirectiveSkipMappings;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for each of the comments encountered in the source file.\nclass CommentHandler {\npublic:\n  virtual ~CommentHandler();\n\n  // The handler shall return true if it has pushed any tokens\n  // to be read using e.g. EnterToken or EnterTokenStream.\n  virtual bool HandleComment(Preprocessor &PP, SourceRange Comment) = 0;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for empty lines encountered in the source file.\nclass EmptylineHandler {\npublic:\n  virtual ~EmptylineHandler();\n\n  // The handler handles empty lines.\n  virtual void HandleEmptyline(SourceRange Range) = 0;\n};\n\n/// Registry of pragma handlers added by plugins\nusing PragmaHandlerRegistry = llvm::Registry<PragmaHandler>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSOR_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "content": "//===- CodeCompleteConsumer.h - Code Completion Interface -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CodeCompleteConsumer class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n#define LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n\n#include \"clang-c/Index.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass DeclContext;\nclass FunctionDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass LangOptions;\nclass NamedDecl;\nclass NestedNameSpecifier;\nclass Preprocessor;\nclass RawComment;\nclass Sema;\nclass UsingShadowDecl;\n\n/// Default priority values for code-completion results based\n/// on their kind.\nenum {\n  /// Priority for the next initialization in a constructor initializer\n  /// list.\n  CCP_NextInitializer = 7,\n\n  /// Priority for an enumeration constant inside a switch whose\n  /// condition is of the enumeration type.\n  CCP_EnumInCase = 7,\n\n  /// Priority for a send-to-super completion.\n  CCP_SuperCompletion = 20,\n\n  /// Priority for a declaration that is in the local scope.\n  CCP_LocalDeclaration = 34,\n\n  /// Priority for a member declaration found from the current\n  /// method or member function.\n  CCP_MemberDeclaration = 35,\n\n  /// Priority for a language keyword (that isn't any of the other\n  /// categories).\n  CCP_Keyword = 40,\n\n  /// Priority for a code pattern.\n  CCP_CodePattern = 40,\n\n  /// Priority for a non-type declaration.\n  CCP_Declaration = 50,\n\n  /// Priority for a type.\n  CCP_Type = CCP_Declaration,\n\n  /// Priority for a constant value (e.g., enumerator).\n  CCP_Constant = 65,\n\n  /// Priority for a preprocessor macro.\n  CCP_Macro = 70,\n\n  /// Priority for a nested-name-specifier.\n  CCP_NestedNameSpecifier = 75,\n\n  /// Priority for a result that isn't likely to be what the user wants,\n  /// but is included for completeness.\n  CCP_Unlikely = 80,\n\n  /// Priority for the Objective-C \"_cmd\" implicit parameter.\n  CCP_ObjC_cmd = CCP_Unlikely\n};\n\n/// Priority value deltas that are added to code-completion results\n/// based on the context of the result.\nenum {\n  /// The result is in a base class.\n  CCD_InBaseClass = 2,\n\n  /// The result is a C++ non-static member function whose qualifiers\n  /// exactly match the object type on which the member function can be called.\n  CCD_ObjectQualifierMatch = -1,\n\n  /// The selector of the given message exactly matches the selector\n  /// of the current method, which might imply that some kind of delegation\n  /// is occurring.\n  CCD_SelectorMatch = -3,\n\n  /// Adjustment to the \"bool\" type in Objective-C, where the typedef\n  /// \"BOOL\" is preferred.\n  CCD_bool_in_ObjC = 1,\n\n  /// Adjustment for KVC code pattern priorities when it doesn't look\n  /// like the\n  CCD_ProbablyNotObjCCollection = 15,\n\n  /// An Objective-C method being used as a property.\n  CCD_MethodAsProperty = 2,\n\n  /// An Objective-C block property completed as a setter with a\n  /// block placeholder.\n  CCD_BlockPropertySetter = 3\n};\n\n/// Priority value factors by which we will divide or multiply the\n/// priority of a code-completion result.\nenum {\n  /// Divide by this factor when a code-completion result's type exactly\n  /// matches the type we expect.\n  CCF_ExactTypeMatch = 4,\n\n  /// Divide by this factor when a code-completion result's type is\n  /// similar to the type we expect (e.g., both arithmetic types, both\n  /// Objective-C object pointer types).\n  CCF_SimilarTypeMatch = 2\n};\n\n/// A simplified classification of types used when determining\n/// \"similar\" types for code completion.\nenum SimplifiedTypeClass {\n  STC_Arithmetic,\n  STC_Array,\n  STC_Block,\n  STC_Function,\n  STC_ObjectiveC,\n  STC_Other,\n  STC_Pointer,\n  STC_Record,\n  STC_Void\n};\n\n/// Determine the simplified type class of the given canonical type.\nSimplifiedTypeClass getSimplifiedTypeClass(CanQualType T);\n\n/// Determine the type that this declaration will have if it is used\n/// as a type or in an expression.\nQualType getDeclUsageType(ASTContext &C, const NamedDecl *ND);\n\n/// Determine the priority to be given to a macro code completion result\n/// with the given name.\n///\n/// \\param MacroName The name of the macro.\n///\n/// \\param LangOpts Options describing the current language dialect.\n///\n/// \\param PreferredTypeIsPointer Whether the preferred type for the context\n/// of this macro is a pointer type.\nunsigned getMacroUsagePriority(StringRef MacroName,\n                               const LangOptions &LangOpts,\n                               bool PreferredTypeIsPointer = false);\n\n/// Determine the libclang cursor kind associated with the given\n/// declaration.\nCXCursorKind getCursorKindForDecl(const Decl *D);\n\n/// The context in which code completion occurred, so that the\n/// code-completion consumer can process the results accordingly.\nclass CodeCompletionContext {\npublic:\n  enum Kind {\n    /// An unspecified code-completion context.\n    CCC_Other,\n\n    /// An unspecified code-completion context where we should also add\n    /// macro completions.\n    CCC_OtherWithMacros,\n\n    /// Code completion occurred within a \"top-level\" completion context,\n    /// e.g., at namespace or global scope.\n    CCC_TopLevel,\n\n    /// Code completion occurred within an Objective-C interface,\n    /// protocol, or category interface.\n    CCC_ObjCInterface,\n\n    /// Code completion occurred within an Objective-C implementation\n    /// or category implementation.\n    CCC_ObjCImplementation,\n\n    /// Code completion occurred within the instance variable list of\n    /// an Objective-C interface, implementation, or category implementation.\n    CCC_ObjCIvarList,\n\n    /// Code completion occurred within a class, struct, or union.\n    CCC_ClassStructUnion,\n\n    /// Code completion occurred where a statement (or declaration) is\n    /// expected in a function, method, or block.\n    CCC_Statement,\n\n    /// Code completion occurred where an expression is expected.\n    CCC_Expression,\n\n    /// Code completion occurred where an Objective-C message receiver\n    /// is expected.\n    CCC_ObjCMessageReceiver,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the dot operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_DotMemberAccess,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the arrow operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ArrowMemberAccess,\n\n    /// Code completion occurred on the right-hand side of an Objective-C\n    /// property access expression.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ObjCPropertyAccess,\n\n    /// Code completion occurred after the \"enum\" keyword, to indicate\n    /// an enumeration name.\n    CCC_EnumTag,\n\n    /// Code completion occurred after the \"union\" keyword, to indicate\n    /// a union name.\n    CCC_UnionTag,\n\n    /// Code completion occurred after the \"struct\" or \"class\" keyword,\n    /// to indicate a struct or class name.\n    CCC_ClassOrStructTag,\n\n    /// Code completion occurred where a protocol name is expected.\n    CCC_ObjCProtocolName,\n\n    /// Code completion occurred where a namespace or namespace alias\n    /// is expected.\n    CCC_Namespace,\n\n    /// Code completion occurred where a type name is expected.\n    CCC_Type,\n\n    /// Code completion occurred where a new name is expected.\n    CCC_NewName,\n\n    /// Code completion occurred where both a new name and an existing symbol is\n    /// permissible.\n    CCC_SymbolOrNewName,\n\n    /// Code completion occurred where an existing name(such as type, function\n    /// or variable) is expected.\n    CCC_Symbol,\n\n    /// Code completion occurred where an macro is being defined.\n    CCC_MacroName,\n\n    /// Code completion occurred where a macro name is expected\n    /// (without any arguments, in the case of a function-like macro).\n    CCC_MacroNameUse,\n\n    /// Code completion occurred within a preprocessor expression.\n    CCC_PreprocessorExpression,\n\n    /// Code completion occurred where a preprocessor directive is\n    /// expected.\n    CCC_PreprocessorDirective,\n\n    /// Code completion occurred in a context where natural language is\n    /// expected, e.g., a comment or string literal.\n    ///\n    /// This context usually implies that no completions should be added,\n    /// unless they come from an appropriate natural-language dictionary.\n    CCC_NaturalLanguage,\n\n    /// Code completion for a selector, as in an \\@selector expression.\n    CCC_SelectorName,\n\n    /// Code completion within a type-qualifier list.\n    CCC_TypeQualifiers,\n\n    /// Code completion in a parenthesized expression, which means that\n    /// we may also have types here in C and Objective-C (as well as in C++).\n    CCC_ParenthesizedExpression,\n\n    /// Code completion where an Objective-C instance message is\n    /// expected.\n    CCC_ObjCInstanceMessage,\n\n    /// Code completion where an Objective-C class message is expected.\n    CCC_ObjCClassMessage,\n\n    /// Code completion where the name of an Objective-C class is\n    /// expected.\n    CCC_ObjCInterfaceName,\n\n    /// Code completion where an Objective-C category name is expected.\n    CCC_ObjCCategoryName,\n\n    /// Code completion inside the filename part of a #include directive.\n    CCC_IncludedFile,\n\n    /// An unknown context, in which we are recovering from a parsing\n    /// error and don't know which completions we should give.\n    CCC_Recovery\n  };\n\n  using VisitedContextSet = llvm::SmallPtrSet<DeclContext *, 8>;\n\nprivate:\n  Kind CCKind;\n\n  /// Indicates whether we are completing a name of a using declaration, e.g.\n  ///     using ^;\n  ///     using a::^;\n  bool IsUsingDeclaration;\n\n  /// The type that would prefer to see at this point (e.g., the type\n  /// of an initializer or function parameter).\n  QualType PreferredType;\n\n  /// The type of the base object in a member access expression.\n  QualType BaseType;\n\n  /// The identifiers for Objective-C selector parts.\n  ArrayRef<IdentifierInfo *> SelIdents;\n\n  /// The scope specifier that comes before the completion token e.g.\n  /// \"a::b::\"\n  llvm::Optional<CXXScopeSpec> ScopeSpecifier;\n\n  /// A set of declaration contexts visited by Sema when doing lookup for\n  /// code completion.\n  VisitedContextSet VisitedContexts;\n\npublic:\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(None) {}\n\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind, QualType T,\n                        ArrayRef<IdentifierInfo *> SelIdents = None)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(SelIdents) {\n    if (CCKind == CCC_DotMemberAccess || CCKind == CCC_ArrowMemberAccess ||\n        CCKind == CCC_ObjCPropertyAccess || CCKind == CCC_ObjCClassMessage ||\n        CCKind == CCC_ObjCInstanceMessage)\n      BaseType = T;\n    else\n      PreferredType = T;\n  }\n\n  bool isUsingDeclaration() const { return IsUsingDeclaration; }\n  void setIsUsingDeclaration(bool V) { IsUsingDeclaration = V; }\n\n  /// Retrieve the kind of code-completion context.\n  Kind getKind() const { return CCKind; }\n\n  /// Retrieve the type that this expression would prefer to have, e.g.,\n  /// if the expression is a variable initializer or a function argument, the\n  /// type of the corresponding variable or function parameter.\n  QualType getPreferredType() const { return PreferredType; }\n  void setPreferredType(QualType T) { PreferredType = T; }\n\n  /// Retrieve the type of the base object in a member-access\n  /// expression.\n  QualType getBaseType() const { return BaseType; }\n\n  /// Retrieve the Objective-C selector identifiers.\n  ArrayRef<IdentifierInfo *> getSelIdents() const { return SelIdents; }\n\n  /// Determines whether we want C++ constructors as results within this\n  /// context.\n  bool wantConstructorResults() const;\n\n  /// Sets the scope specifier that comes before the completion token.\n  /// This is expected to be set in code completions on qualfied specifiers\n  /// (e.g. \"a::b::\").\n  void setCXXScopeSpecifier(CXXScopeSpec SS) {\n    this->ScopeSpecifier = std::move(SS);\n  }\n\n  /// Adds a visited context.\n  void addVisitedContext(DeclContext *Ctx) {\n    VisitedContexts.insert(Ctx);\n  }\n\n  /// Retrieves all visited contexts.\n  const VisitedContextSet &getVisitedContexts() const {\n    return VisitedContexts;\n  }\n\n  llvm::Optional<const CXXScopeSpec *> getCXXScopeSpecifier() {\n    if (ScopeSpecifier)\n      return ScopeSpecifier.getPointer();\n    return llvm::None;\n  }\n};\n\n/// Get string representation of \\p Kind, useful for for debugging.\nllvm::StringRef getCompletionKindString(CodeCompletionContext::Kind Kind);\n\n/// A \"string\" used to describe how code completion can\n/// be performed for an entity.\n///\n/// A code completion string typically shows how a particular entity can be\n/// used. For example, the code completion string for a function would show\n/// the syntax to call it, including the parentheses, placeholders for the\n/// arguments, etc.\nclass CodeCompletionString {\npublic:\n  /// The different kinds of \"chunks\" that can occur within a code\n  /// completion string.\n  enum ChunkKind {\n    /// The piece of text that the user is expected to type to\n    /// match the code-completion string, typically a keyword or the name of a\n    /// declarator or macro.\n    CK_TypedText,\n\n    /// A piece of text that should be placed in the buffer, e.g.,\n    /// parentheses or a comma in a function call.\n    CK_Text,\n\n    /// A code completion string that is entirely optional. For example,\n    /// an optional code completion string that describes the default arguments\n    /// in a function call.\n    CK_Optional,\n\n    /// A string that acts as a placeholder for, e.g., a function\n    /// call argument.\n    CK_Placeholder,\n\n    /// A piece of text that describes something about the result but\n    /// should not be inserted into the buffer.\n    CK_Informative,\n    /// A piece of text that describes the type of an entity or, for\n    /// functions and methods, the return type.\n    CK_ResultType,\n\n    /// A piece of text that describes the parameter that corresponds\n    /// to the code-completion location within a function call, message send,\n    /// macro invocation, etc.\n    CK_CurrentParameter,\n\n    /// A left parenthesis ('(').\n    CK_LeftParen,\n\n    /// A right parenthesis (')').\n    CK_RightParen,\n\n    /// A left bracket ('[').\n    CK_LeftBracket,\n\n    /// A right bracket (']').\n    CK_RightBracket,\n\n    /// A left brace ('{').\n    CK_LeftBrace,\n\n    /// A right brace ('}').\n    CK_RightBrace,\n\n    /// A left angle bracket ('<').\n    CK_LeftAngle,\n\n    /// A right angle bracket ('>').\n    CK_RightAngle,\n\n    /// A comma separator (',').\n    CK_Comma,\n\n    /// A colon (':').\n    CK_Colon,\n\n    /// A semicolon (';').\n    CK_SemiColon,\n\n    /// An '=' sign.\n    CK_Equal,\n\n    /// Horizontal whitespace (' ').\n    CK_HorizontalSpace,\n\n    /// Vertical whitespace ('\\\\n' or '\\\\r\\\\n', depending on the\n    /// platform).\n    CK_VerticalSpace\n  };\n\n  /// One piece of the code completion string.\n  struct Chunk {\n    /// The kind of data stored in this piece of the code completion\n    /// string.\n    ChunkKind Kind = CK_Text;\n\n    union {\n      /// The text string associated with a CK_Text, CK_Placeholder,\n      /// CK_Informative, or CK_Comma chunk.\n      /// The string is owned by the chunk and will be deallocated\n      /// (with delete[]) when the chunk is destroyed.\n      const char *Text;\n\n      /// The code completion string associated with a CK_Optional chunk.\n      /// The optional code completion string is owned by the chunk, and will\n      /// be deallocated (with delete) when the chunk is destroyed.\n      CodeCompletionString *Optional;\n    };\n\n    Chunk() : Text(nullptr) {}\n\n    explicit Chunk(ChunkKind Kind, const char *Text = \"\");\n\n    /// Create a new text chunk.\n    static Chunk CreateText(const char *Text);\n\n    /// Create a new optional chunk.\n    static Chunk CreateOptional(CodeCompletionString *Optional);\n\n    /// Create a new placeholder chunk.\n    static Chunk CreatePlaceholder(const char *Placeholder);\n\n    /// Create a new informative chunk.\n    static Chunk CreateInformative(const char *Informative);\n\n    /// Create a new result type chunk.\n    static Chunk CreateResultType(const char *ResultType);\n\n    /// Create a new current-parameter chunk.\n    static Chunk CreateCurrentParameter(const char *CurrentParameter);\n  };\n\nprivate:\n  friend class CodeCompletionBuilder;\n  friend class CodeCompletionResult;\n\n  /// The number of chunks stored in this string.\n  unsigned NumChunks : 16;\n\n  /// The number of annotations for this code-completion result.\n  unsigned NumAnnotations : 16;\n\n  /// The priority of this code-completion string.\n  unsigned Priority : 16;\n\n  /// The availability of this code-completion result.\n  unsigned Availability : 2;\n\n  /// The name of the parent context.\n  StringRef ParentName;\n\n  /// A brief documentation comment attached to the declaration of\n  /// entity being completed by this result.\n  const char *BriefComment;\n\n  CodeCompletionString(const Chunk *Chunks, unsigned NumChunks,\n                       unsigned Priority, CXAvailabilityKind Availability,\n                       const char **Annotations, unsigned NumAnnotations,\n                       StringRef ParentName,\n                       const char *BriefComment);\n  ~CodeCompletionString() = default;\n\npublic:\n  CodeCompletionString(const CodeCompletionString &) = delete;\n  CodeCompletionString &operator=(const CodeCompletionString &) = delete;\n\n  using iterator = const Chunk *;\n\n  iterator begin() const { return reinterpret_cast<const Chunk *>(this + 1); }\n  iterator end() const { return begin() + NumChunks; }\n  bool empty() const { return NumChunks == 0; }\n  unsigned size() const { return NumChunks; }\n\n  const Chunk &operator[](unsigned I) const {\n    assert(I < size() && \"Chunk index out-of-range\");\n    return begin()[I];\n  }\n\n  /// Returns the text in the TypedText chunk.\n  const char *getTypedText() const;\n\n  /// Retrieve the priority of this code completion result.\n  unsigned getPriority() const { return Priority; }\n\n  /// Retrieve the availability of this code completion result.\n  unsigned getAvailability() const { return Availability; }\n\n  /// Retrieve the number of annotations for this code completion result.\n  unsigned getAnnotationCount() const;\n\n  /// Retrieve the annotation string specified by \\c AnnotationNr.\n  const char *getAnnotation(unsigned AnnotationNr) const;\n\n  /// Retrieve the name of the parent context.\n  StringRef getParentContextName() const {\n    return ParentName;\n  }\n\n  const char *getBriefComment() const {\n    return BriefComment;\n  }\n\n  /// Retrieve a string representation of the code completion string,\n  /// which is mainly useful for debugging.\n  std::string getAsString() const;\n};\n\n/// An allocator used specifically for the purpose of code completion.\nclass CodeCompletionAllocator : public llvm::BumpPtrAllocator {\npublic:\n  /// Copy the given string into this allocator.\n  const char *CopyString(const Twine &String);\n};\n\n/// Allocator for a cached set of global code completions.\nclass GlobalCodeCompletionAllocator : public CodeCompletionAllocator {};\n\nclass CodeCompletionTUInfo {\n  llvm::DenseMap<const DeclContext *, StringRef> ParentNames;\n  std::shared_ptr<GlobalCodeCompletionAllocator> AllocatorRef;\n\npublic:\n  explicit CodeCompletionTUInfo(\n      std::shared_ptr<GlobalCodeCompletionAllocator> Allocator)\n      : AllocatorRef(std::move(Allocator)) {}\n\n  std::shared_ptr<GlobalCodeCompletionAllocator> getAllocatorRef() const {\n    return AllocatorRef;\n  }\n\n  CodeCompletionAllocator &getAllocator() const {\n    assert(AllocatorRef);\n    return *AllocatorRef;\n  }\n\n  StringRef getParentName(const DeclContext *DC);\n};\n\n} // namespace clang\n\nnamespace clang {\n\n/// A builder class used to construct new code-completion strings.\nclass CodeCompletionBuilder {\npublic:\n  using Chunk = CodeCompletionString::Chunk;\n\nprivate:\n  CodeCompletionAllocator &Allocator;\n  CodeCompletionTUInfo &CCTUInfo;\n  unsigned Priority = 0;\n  CXAvailabilityKind Availability = CXAvailability_Available;\n  StringRef ParentName;\n  const char *BriefComment = nullptr;\n\n  /// The chunks stored in this string.\n  SmallVector<Chunk, 4> Chunks;\n\n  SmallVector<const char *, 2> Annotations;\n\npublic:\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo) {}\n\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo,\n                        unsigned Priority, CXAvailabilityKind Availability)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo), Priority(Priority),\n        Availability(Availability) {}\n\n  /// Retrieve the allocator into which the code completion\n  /// strings should be allocated.\n  CodeCompletionAllocator &getAllocator() const { return Allocator; }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() const { return CCTUInfo; }\n\n  /// Take the resulting completion string.\n  ///\n  /// This operation can only be performed once.\n  CodeCompletionString *TakeString();\n\n  /// Add a new typed-text chunk.\n  void AddTypedTextChunk(const char *Text);\n\n  /// Add a new text chunk.\n  void AddTextChunk(const char *Text);\n\n  /// Add a new optional chunk.\n  void AddOptionalChunk(CodeCompletionString *Optional);\n\n  /// Add a new placeholder chunk.\n  void AddPlaceholderChunk(const char *Placeholder);\n\n  /// Add a new informative chunk.\n  void AddInformativeChunk(const char *Text);\n\n  /// Add a new result-type chunk.\n  void AddResultTypeChunk(const char *ResultType);\n\n  /// Add a new current-parameter chunk.\n  void AddCurrentParameterChunk(const char *CurrentParameter);\n\n  /// Add a new chunk.\n  void AddChunk(CodeCompletionString::ChunkKind CK, const char *Text = \"\");\n\n  void AddAnnotation(const char *A) { Annotations.push_back(A); }\n\n  /// Add the parent context information to this code completion.\n  void addParentContext(const DeclContext *DC);\n\n  const char *getBriefComment() const { return BriefComment; }\n  void addBriefComment(StringRef Comment);\n\n  StringRef getParentName() const { return ParentName; }\n};\n\n/// Captures a result of code completion.\nclass CodeCompletionResult {\npublic:\n  /// Describes the kind of result generated.\n  enum ResultKind {\n    /// Refers to a declaration.\n    RK_Declaration = 0,\n\n    /// Refers to a keyword or symbol.\n    RK_Keyword,\n\n    /// Refers to a macro.\n    RK_Macro,\n\n    /// Refers to a precomputed pattern.\n    RK_Pattern\n  };\n\n  /// When Kind == RK_Declaration or RK_Pattern, the declaration we are\n  /// referring to. In the latter case, the declaration might be NULL.\n  const NamedDecl *Declaration = nullptr;\n\n  union {\n    /// When Kind == RK_Keyword, the string representing the keyword\n    /// or symbol's spelling.\n    const char *Keyword;\n\n    /// When Kind == RK_Pattern, the code-completion string that\n    /// describes the completion text to insert.\n    CodeCompletionString *Pattern;\n\n    /// When Kind == RK_Macro, the identifier that refers to a macro.\n    const IdentifierInfo *Macro;\n  };\n\n  /// The priority of this particular code-completion result.\n  unsigned Priority;\n\n  /// Specifies which parameter (of a function, Objective-C method,\n  /// macro, etc.) we should start with when formatting the result.\n  unsigned StartParameter = 0;\n\n  /// The kind of result stored here.\n  ResultKind Kind;\n\n  /// The cursor kind that describes this result.\n  CXCursorKind CursorKind;\n\n  /// The availability of this result.\n  CXAvailabilityKind Availability = CXAvailability_Available;\n\n  /// Fix-its that *must* be applied before inserting the text for the\n  /// corresponding completion.\n  ///\n  /// By default, CodeCompletionBuilder only returns completions with empty\n  /// fix-its. Extra completions with non-empty fix-its should be explicitly\n  /// requested by setting CompletionOptions::IncludeFixIts.\n  ///\n  /// For the clients to be able to compute position of the cursor after\n  /// applying fix-its, the following conditions are guaranteed to hold for\n  /// RemoveRange of the stored fix-its:\n  ///  - Ranges in the fix-its are guaranteed to never contain the completion\n  ///  point (or identifier under completion point, if any) inside them, except\n  ///  at the start or at the end of the range.\n  ///  - If a fix-it range starts or ends with completion point (or starts or\n  ///  ends after the identifier under completion point), it will contain at\n  ///  least one character. It allows to unambiguously recompute completion\n  ///  point after applying the fix-it.\n  ///\n  /// The intuition is that provided fix-its change code around the identifier\n  /// we complete, but are not allowed to touch the identifier itself or the\n  /// completion point. One example of completions with corrections are the ones\n  /// replacing '.' with '->' and vice versa:\n  ///\n  /// std::unique_ptr<std::vector<int>> vec_ptr;\n  /// In 'vec_ptr.^', one of the completions is 'push_back', it requires\n  /// replacing '.' with '->'.\n  /// In 'vec_ptr->^', one of the completions is 'release', it requires\n  /// replacing '->' with '.'.\n  std::vector<FixItHint> FixIts;\n\n  /// Whether this result is hidden by another name.\n  bool Hidden : 1;\n\n  /// Whether this is a class member from base class.\n  bool InBaseClass : 1;\n\n  /// Whether this result was found via lookup into a base class.\n  bool QualifierIsInformative : 1;\n\n  /// Whether this declaration is the beginning of a\n  /// nested-name-specifier and, therefore, should be followed by '::'.\n  bool StartsNestedNameSpecifier : 1;\n\n  /// Whether all parameters (of a function, Objective-C\n  /// method, etc.) should be considered \"informative\".\n  bool AllParametersAreInformative : 1;\n\n  /// Whether we're completing a declaration of the given entity,\n  /// rather than a use of that entity.\n  bool DeclaringEntity : 1;\n\n  /// If the result should have a nested-name-specifier, this is it.\n  /// When \\c QualifierIsInformative, the nested-name-specifier is\n  /// informative rather than required.\n  NestedNameSpecifier *Qualifier = nullptr;\n\n  /// If this Decl was unshadowed by using declaration, this can store a\n  /// pointer to the UsingShadowDecl which was used in the unshadowing process.\n  /// This information can be used to uprank CodeCompletionResults / which have\n  /// corresponding `using decl::qualified::name;` nearby.\n  const UsingShadowDecl *ShadowDecl = nullptr;\n\n  /// If the result is RK_Macro, this can store the information about the macro\n  /// definition. This should be set in most cases but can be missing when\n  /// the macro has been undefined.\n  const MacroInfo *MacroDefInfo = nullptr;\n\n  /// Build a result that refers to a declaration.\n  CodeCompletionResult(const NamedDecl *Declaration, unsigned Priority,\n                       NestedNameSpecifier *Qualifier = nullptr,\n                       bool QualifierIsInformative = false,\n                       bool Accessible = true,\n                       std::vector<FixItHint> FixIts = std::vector<FixItHint>())\n      : Declaration(Declaration), Priority(Priority), Kind(RK_Declaration),\n        FixIts(std::move(FixIts)), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(QualifierIsInformative),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false), Qualifier(Qualifier) {\n    // FIXME: Add assert to check FixIts range requirements.\n    computeCursorKindAndAvailability(Accessible);\n  }\n\n  /// Build a result that refers to a keyword or symbol.\n  CodeCompletionResult(const char *Keyword, unsigned Priority = CCP_Keyword)\n      : Keyword(Keyword), Priority(Priority), Kind(RK_Keyword),\n        CursorKind(CXCursor_NotImplemented), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false) {}\n\n  /// Build a result that refers to a macro.\n  CodeCompletionResult(const IdentifierInfo *Macro,\n                       const MacroInfo *MI = nullptr,\n                       unsigned Priority = CCP_Macro)\n      : Macro(Macro), Priority(Priority), Kind(RK_Macro),\n        CursorKind(CXCursor_MacroDefinition), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false),\n        MacroDefInfo(MI) {}\n\n  /// Build a result that refers to a pattern.\n  CodeCompletionResult(\n      CodeCompletionString *Pattern, unsigned Priority = CCP_CodePattern,\n      CXCursorKind CursorKind = CXCursor_NotImplemented,\n      CXAvailabilityKind Availability = CXAvailability_Available,\n      const NamedDecl *D = nullptr)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        CursorKind(CursorKind), Availability(Availability), Hidden(false),\n        InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {}\n\n  /// Build a result that refers to a pattern with an associated\n  /// declaration.\n  CodeCompletionResult(CodeCompletionString *Pattern, const NamedDecl *D,\n                       unsigned Priority)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        Hidden(false), InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {\n    computeCursorKindAndAvailability();\n  }\n\n  /// Retrieve the declaration stored in this result. This might be nullptr if\n  /// Kind is RK_Pattern.\n  const NamedDecl *getDeclaration() const {\n    assert(((Kind == RK_Declaration) || (Kind == RK_Pattern)) &&\n           \"Not a declaration or pattern result\");\n    return Declaration;\n  }\n\n  /// Retrieve the keyword stored in this result.\n  const char *getKeyword() const {\n    assert(Kind == RK_Keyword && \"Not a keyword result\");\n    return Keyword;\n  }\n\n  /// Create a new code-completion string that describes how to insert\n  /// this result into a program.\n  ///\n  /// \\param S The semantic analysis that created the result.\n  ///\n  /// \\param Allocator The allocator that will be used to allocate the\n  /// string itself.\n  CodeCompletionString *CreateCodeCompletionString(Sema &S,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  CodeCompletionString *CreateCodeCompletionString(ASTContext &Ctx,\n                                                   Preprocessor &PP,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  /// Creates a new code-completion string for the macro result. Similar to the\n  /// above overloads, except this only requires preprocessor information.\n  /// The result kind must be `RK_Macro`.\n  CodeCompletionString *\n  CreateCodeCompletionStringForMacro(Preprocessor &PP,\n                                     CodeCompletionAllocator &Allocator,\n                                     CodeCompletionTUInfo &CCTUInfo);\n\n  CodeCompletionString *createCodeCompletionStringForDecl(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  CodeCompletionString *createCodeCompletionStringForOverride(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  /// Retrieve the name that should be used to order a result.\n  ///\n  /// If the name needs to be constructed as a string, that string will be\n  /// saved into Saved and the returned StringRef will refer to it.\n  StringRef getOrderedName(std::string &Saved) const;\n\nprivate:\n  void computeCursorKindAndAvailability(bool Accessible = true);\n};\n\nbool operator<(const CodeCompletionResult &X, const CodeCompletionResult &Y);\n\ninline bool operator>(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return Y < X;\n}\n\ninline bool operator<=(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return !(Y < X);\n}\n\ninline bool operator>=(const CodeCompletionResult &X,\n                       const CodeCompletionResult &Y) {\n  return !(X < Y);\n}\n\n/// Abstract interface for a consumer of code-completion\n/// information.\nclass CodeCompleteConsumer {\nprotected:\n  const CodeCompleteOptions CodeCompleteOpts;\n\npublic:\n  class OverloadCandidate {\n  public:\n    /// Describes the type of overload candidate.\n    enum CandidateKind {\n      /// The candidate is a function declaration.\n      CK_Function,\n\n      /// The candidate is a function template.\n      CK_FunctionTemplate,\n\n      /// The \"candidate\" is actually a variable, expression, or block\n      /// for which we only have a function prototype.\n      CK_FunctionType\n    };\n\n  private:\n    /// The kind of overload candidate.\n    CandidateKind Kind;\n\n    union {\n      /// The function overload candidate, available when\n      /// Kind == CK_Function.\n      FunctionDecl *Function;\n\n      /// The function template overload candidate, available when\n      /// Kind == CK_FunctionTemplate.\n      FunctionTemplateDecl *FunctionTemplate;\n\n      /// The function type that describes the entity being called,\n      /// when Kind == CK_FunctionType.\n      const FunctionType *Type;\n    };\n\n  public:\n    OverloadCandidate(FunctionDecl *Function)\n        : Kind(CK_Function), Function(Function) {}\n\n    OverloadCandidate(FunctionTemplateDecl *FunctionTemplateDecl)\n        : Kind(CK_FunctionTemplate), FunctionTemplate(FunctionTemplateDecl) {}\n\n    OverloadCandidate(const FunctionType *Type)\n        : Kind(CK_FunctionType), Type(Type) {}\n\n    /// Determine the kind of overload candidate.\n    CandidateKind getKind() const { return Kind; }\n\n    /// Retrieve the function overload candidate or the templated\n    /// function declaration for a function template.\n    FunctionDecl *getFunction() const;\n\n    /// Retrieve the function template overload candidate.\n    FunctionTemplateDecl *getFunctionTemplate() const {\n      assert(getKind() == CK_FunctionTemplate && \"Not a function template\");\n      return FunctionTemplate;\n    }\n\n    /// Retrieve the function type of the entity, regardless of how the\n    /// function is stored.\n    const FunctionType *getFunctionType() const;\n\n    /// Create a new code-completion string that describes the function\n    /// signature of this overload candidate.\n    CodeCompletionString *CreateSignatureString(unsigned CurrentArg,\n                                                Sema &S,\n                                      CodeCompletionAllocator &Allocator,\n                                      CodeCompletionTUInfo &CCTUInfo,\n                                      bool IncludeBriefComments) const;\n  };\n\n  CodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts)\n      : CodeCompleteOpts(CodeCompleteOpts) {}\n\n  /// Whether the code-completion consumer wants to see macros.\n  bool includeMacros() const {\n    return CodeCompleteOpts.IncludeMacros;\n  }\n\n  /// Whether the code-completion consumer wants to see code patterns.\n  bool includeCodePatterns() const {\n    return CodeCompleteOpts.IncludeCodePatterns;\n  }\n\n  /// Whether to include global (top-level) declaration results.\n  bool includeGlobals() const { return CodeCompleteOpts.IncludeGlobals; }\n\n  /// Whether to include declarations in namespace contexts (including\n  /// the global namespace). If this is false, `includeGlobals()` will be\n  /// ignored.\n  bool includeNamespaceLevelDecls() const {\n    return CodeCompleteOpts.IncludeNamespaceLevelDecls;\n  }\n\n  /// Whether to include brief documentation comments within the set of\n  /// code completions returned.\n  bool includeBriefComments() const {\n    return CodeCompleteOpts.IncludeBriefComments;\n  }\n\n  /// Whether to include completion items with small fix-its, e.g. change\n  /// '.' to '->' on member access, etc.\n  bool includeFixIts() const { return CodeCompleteOpts.IncludeFixIts; }\n\n  /// Hint whether to load data from the external AST in order to provide\n  /// full results. If false, declarations from the preamble may be omitted.\n  bool loadExternal() const {\n    return CodeCompleteOpts.LoadExternal;\n  }\n\n  /// Deregisters and destroys this code-completion consumer.\n  virtual ~CodeCompleteConsumer();\n\n  /// \\name Code-completion filtering\n  /// Check if the result should be filtered out.\n  virtual bool isResultFilteredOut(StringRef Filter,\n                                   CodeCompletionResult Results) {\n    return false;\n  }\n\n  /// \\name Code-completion callbacks\n  //@{\n  /// Process the finalized code-completion results.\n  virtual void ProcessCodeCompleteResults(Sema &S,\n                                          CodeCompletionContext Context,\n                                          CodeCompletionResult *Results,\n                                          unsigned NumResults) {}\n\n  /// \\param S the semantic-analyzer object for which code-completion is being\n  /// done.\n  ///\n  /// \\param CurrentArg the index of the current argument.\n  ///\n  /// \\param Candidates an array of overload candidates.\n  ///\n  /// \\param NumCandidates the number of overload candidates\n  ///\n  /// \\param OpenParLoc location of the opening parenthesis of the argument\n  ///        list.\n  virtual void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                         OverloadCandidate *Candidates,\n                                         unsigned NumCandidates,\n                                         SourceLocation OpenParLoc) {}\n  //@}\n\n  /// Retrieve the allocator that will be used to allocate\n  /// code completion strings.\n  virtual CodeCompletionAllocator &getAllocator() = 0;\n\n  virtual CodeCompletionTUInfo &getCodeCompletionTUInfo() = 0;\n};\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Declaration.\nconst RawComment *getCompletionComment(const ASTContext &Ctx,\n                                       const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Pattern.\nconst RawComment *getPatternCompletionComment(const ASTContext &Ctx,\n                                              const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for OverloadCandidate.\nconst RawComment *\ngetParameterComment(const ASTContext &Ctx,\n                    const CodeCompleteConsumer::OverloadCandidate &Result,\n                    unsigned ArgIndex);\n\n/// A simple code-completion consumer that prints the results it\n/// receives in a simple format.\nclass PrintingCodeCompleteConsumer : public CodeCompleteConsumer {\n  /// The raw output stream.\n  raw_ostream &OS;\n\n  CodeCompletionTUInfo CCTUInfo;\n\npublic:\n  /// Create a new printing code-completion consumer that prints its\n  /// results to the given raw output stream.\n  PrintingCodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts,\n                               raw_ostream &OS)\n      : CodeCompleteConsumer(CodeCompleteOpts), OS(OS),\n        CCTUInfo(std::make_shared<GlobalCodeCompletionAllocator>()) {}\n\n  /// Prints the finalized code-completion results.\n  void ProcessCodeCompleteResults(Sema &S, CodeCompletionContext Context,\n                                  CodeCompletionResult *Results,\n                                  unsigned NumResults) override;\n\n  void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                 OverloadCandidate *Candidates,\n                                 unsigned NumCandidates,\n                                 SourceLocation OpenParLoc) override;\n\n  bool isResultFilteredOut(StringRef Filter, CodeCompletionResult Results) override;\n\n  CodeCompletionAllocator &getAllocator() override {\n    return CCTUInfo.getAllocator();\n  }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() override { return CCTUInfo; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "content": "//===- ASTBitCodes.h - Enum values for the PCH bitcode format ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This header defines Bitcode enum values for Clang serialized AST files.\n//\n// The enum values defined in this file should be considered permanent.  If\n// new features are added, they should have values added at the end of the\n// respective lists.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n#define LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Bitstream/BitCodes.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace clang {\nnamespace serialization {\n\n/// AST file major version number supported by this version of\n/// Clang.\n///\n/// Whenever the AST file format changes in a way that makes it\n/// incompatible with previous versions (such that a reader\n/// designed for the previous version could not support reading\n/// the new version), this number should be increased.\n///\n/// Version 4 of AST files also requires that the version control branch and\n/// revision match exactly, since there is no backward compatibility of\n/// AST files at this time.\nconst unsigned VERSION_MAJOR = 13;\n\n/// AST file minor version number supported by this version of\n/// Clang.\n///\n/// Whenever the AST format changes in a way that is still\n/// compatible with previous versions (such that a reader designed\n/// for the previous version could still support reading the new\n/// version by ignoring new kinds of subblocks), this number\n/// should be increased.\nconst unsigned VERSION_MINOR = 0;\n\n/// An ID number that refers to an identifier in an AST file.\n///\n/// The ID numbers of identifiers are consecutive (in order of discovery)\n/// and start at 1. 0 is reserved for NULL.\nusing IdentifierID = uint32_t;\n\n/// An ID number that refers to a declaration in an AST file.\n///\n/// The ID numbers of declarations are consecutive (in order of\n/// discovery), with values below NUM_PREDEF_DECL_IDS being reserved.\n/// At the start of a chain of precompiled headers, declaration ID 1 is\n/// used for the translation unit declaration.\nusing DeclID = uint32_t;\n\n// FIXME: Turn these into classes so we can have some type safety when\n// we go from local ID to global and vice-versa.\nusing LocalDeclID = DeclID;\nusing GlobalDeclID = DeclID;\n\n/// An ID number that refers to a type in an AST file.\n///\n/// The ID of a type is partitioned into two parts: the lower\n/// three bits are used to store the const/volatile/restrict\n/// qualifiers (as with QualType) and the upper bits provide a\n/// type index. The type index values are partitioned into two\n/// sets. The values below NUM_PREDEF_TYPE_IDs are predefined type\n/// IDs (based on the PREDEF_TYPE_*_ID constants), with 0 as a\n/// placeholder for \"no type\". Values from NUM_PREDEF_TYPE_IDs are\n/// other types that have serialized representations.\nusing TypeID = uint32_t;\n\n/// A type index; the type ID with the qualifier bits removed.\nclass TypeIdx {\n  uint32_t Idx = 0;\n\npublic:\n  TypeIdx() = default;\n  explicit TypeIdx(uint32_t index) : Idx(index) {}\n\n  uint32_t getIndex() const { return Idx; }\n\n  TypeID asTypeID(unsigned FastQuals) const {\n    if (Idx == uint32_t(-1))\n      return TypeID(-1);\n\n    return (Idx << Qualifiers::FastWidth) | FastQuals;\n  }\n\n  static TypeIdx fromTypeID(TypeID ID) {\n    if (ID == TypeID(-1))\n      return TypeIdx(-1);\n\n    return TypeIdx(ID >> Qualifiers::FastWidth);\n  }\n};\n\n/// A structure for putting \"fast\"-unqualified QualTypes into a\n/// DenseMap.  This uses the standard pointer hash function.\nstruct UnsafeQualTypeDenseMapInfo {\n  static bool isEqual(QualType A, QualType B) { return A == B; }\n\n  static QualType getEmptyKey() {\n    return QualType::getFromOpaquePtr((void *)1);\n  }\n\n  static QualType getTombstoneKey() {\n    return QualType::getFromOpaquePtr((void *)2);\n  }\n\n  static unsigned getHashValue(QualType T) {\n    assert(!T.getLocalFastQualifiers() &&\n           \"hash invalid for types with fast quals\");\n    uintptr_t v = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n    return (unsigned(v) >> 4) ^ (unsigned(v) >> 9);\n  }\n};\n\n/// An ID number that refers to an identifier in an AST file.\nusing IdentID = uint32_t;\n\n/// The number of predefined identifier IDs.\nconst unsigned int NUM_PREDEF_IDENT_IDS = 1;\n\n/// An ID number that refers to a macro in an AST file.\nusing MacroID = uint32_t;\n\n/// A global ID number that refers to a macro in an AST file.\nusing GlobalMacroID = uint32_t;\n\n/// A local to a module ID number that refers to a macro in an\n/// AST file.\nusing LocalMacroID = uint32_t;\n\n/// The number of predefined macro IDs.\nconst unsigned int NUM_PREDEF_MACRO_IDS = 1;\n\n/// An ID number that refers to an ObjC selector in an AST file.\nusing SelectorID = uint32_t;\n\n/// The number of predefined selector IDs.\nconst unsigned int NUM_PREDEF_SELECTOR_IDS = 1;\n\n/// An ID number that refers to a set of CXXBaseSpecifiers in an\n/// AST file.\nusing CXXBaseSpecifiersID = uint32_t;\n\n/// An ID number that refers to a list of CXXCtorInitializers in an\n/// AST file.\nusing CXXCtorInitializersID = uint32_t;\n\n/// An ID number that refers to an entity in the detailed\n/// preprocessing record.\nusing PreprocessedEntityID = uint32_t;\n\n/// An ID number that refers to a submodule in a module file.\nusing SubmoduleID = uint32_t;\n\n/// The number of predefined submodule IDs.\nconst unsigned int NUM_PREDEF_SUBMODULE_IDS = 1;\n\n/// Source range/offset of a preprocessed entity.\nstruct PPEntityOffset {\n  /// Raw source location of beginning of range.\n  unsigned Begin;\n\n  /// Raw source location of end of range.\n  unsigned End;\n\n  /// Offset in the AST file relative to ModuleFile::MacroOffsetsBase.\n  uint32_t BitOffset;\n\n  PPEntityOffset(SourceRange R, uint32_t BitOffset)\n      : Begin(R.getBegin().getRawEncoding()), End(R.getEnd().getRawEncoding()),\n        BitOffset(BitOffset) {}\n\n  SourceLocation getBegin() const {\n    return SourceLocation::getFromRawEncoding(Begin);\n  }\n\n  SourceLocation getEnd() const {\n    return SourceLocation::getFromRawEncoding(End);\n  }\n};\n\n/// Source range of a skipped preprocessor region\nstruct PPSkippedRange {\n  /// Raw source location of beginning of range.\n  unsigned Begin;\n  /// Raw source location of end of range.\n  unsigned End;\n\n  PPSkippedRange(SourceRange R)\n      : Begin(R.getBegin().getRawEncoding()), End(R.getEnd().getRawEncoding()) {\n  }\n\n  SourceLocation getBegin() const {\n    return SourceLocation::getFromRawEncoding(Begin);\n  }\n  SourceLocation getEnd() const {\n    return SourceLocation::getFromRawEncoding(End);\n  }\n};\n\n/// Offset in the AST file. Use splitted 64-bit integer into low/high\n/// parts to keep structure alignment 32-bit (it is important because\n/// blobs in bitstream are 32-bit aligned). This structure is serialized\n/// \"as is\" to the AST file.\nstruct UnderalignedInt64 {\n  uint32_t BitOffsetLow = 0;\n  uint32_t BitOffsetHigh = 0;\n\n  UnderalignedInt64() = default;\n  UnderalignedInt64(uint64_t BitOffset) { setBitOffset(BitOffset); }\n\n  void setBitOffset(uint64_t Offset) {\n    BitOffsetLow = Offset;\n    BitOffsetHigh = Offset >> 32;\n  }\n\n  uint64_t getBitOffset() const {\n    return BitOffsetLow | (uint64_t(BitOffsetHigh) << 32);\n  }\n};\n\n/// Source location and bit offset of a declaration.\nstruct DeclOffset {\n  /// Raw source location.\n  unsigned Loc = 0;\n\n  /// Offset relative to the start of the DECLTYPES_BLOCK block. Keep\n  /// structure alignment 32-bit and avoid padding gap because undefined\n  /// value in the padding affects AST hash.\n  UnderalignedInt64 BitOffset;\n\n  DeclOffset() = default;\n  DeclOffset(SourceLocation Loc, uint64_t BitOffset,\n             uint64_t DeclTypesBlockStartOffset) {\n    setLocation(Loc);\n    setBitOffset(BitOffset, DeclTypesBlockStartOffset);\n  }\n\n  void setLocation(SourceLocation L) { Loc = L.getRawEncoding(); }\n\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromRawEncoding(Loc);\n  }\n\n  void setBitOffset(uint64_t Offset, const uint64_t DeclTypesBlockStartOffset) {\n    BitOffset.setBitOffset(Offset - DeclTypesBlockStartOffset);\n  }\n\n  uint64_t getBitOffset(const uint64_t DeclTypesBlockStartOffset) const {\n    return BitOffset.getBitOffset() + DeclTypesBlockStartOffset;\n  }\n};\n\n/// The number of predefined preprocessed entity IDs.\nconst unsigned int NUM_PREDEF_PP_ENTITY_IDS = 1;\n\n/// Describes the various kinds of blocks that occur within\n/// an AST file.\nenum BlockIDs {\n  /// The AST block, which acts as a container around the\n  /// full AST block.\n  AST_BLOCK_ID = llvm::bitc::FIRST_APPLICATION_BLOCKID,\n\n  /// The block containing information about the source\n  /// manager.\n  SOURCE_MANAGER_BLOCK_ID,\n\n  /// The block containing information about the\n  /// preprocessor.\n  PREPROCESSOR_BLOCK_ID,\n\n  /// The block containing the definitions of all of the\n  /// types and decls used within the AST file.\n  DECLTYPES_BLOCK_ID,\n\n  /// The block containing the detailed preprocessing record.\n  PREPROCESSOR_DETAIL_BLOCK_ID,\n\n  /// The block containing the submodule structure.\n  SUBMODULE_BLOCK_ID,\n\n  /// The block containing comments.\n  COMMENTS_BLOCK_ID,\n\n  /// The control block, which contains all of the\n  /// information that needs to be validated prior to committing\n  /// to loading the AST file.\n  CONTROL_BLOCK_ID,\n\n  /// The block of input files, which were used as inputs\n  /// to create this AST file.\n  ///\n  /// This block is part of the control block.\n  INPUT_FILES_BLOCK_ID,\n\n  /// The block of configuration options, used to check that\n  /// a module is being used in a configuration compatible with the\n  /// configuration in which it was built.\n  ///\n  /// This block is part of the control block.\n  OPTIONS_BLOCK_ID,\n\n  /// A block containing a module file extension.\n  EXTENSION_BLOCK_ID,\n\n  /// A block with unhashed content.\n  ///\n  /// These records should not change the \\a ASTFileSignature.  See \\a\n  /// UnhashedControlBlockRecordTypes for the list of records.\n  UNHASHED_CONTROL_BLOCK_ID,\n};\n\n/// Record types that occur within the control block.\nenum ControlRecordTypes {\n  /// AST file metadata, including the AST file version number\n  /// and information about the compiler used to build this AST file.\n  METADATA = 1,\n\n  /// Record code for the list of other AST files imported by\n  /// this AST file.\n  IMPORTS,\n\n  /// Record code for the original file that was used to\n  /// generate the AST file, including both its file ID and its\n  /// name.\n  ORIGINAL_FILE,\n\n  /// The directory that the PCH was originally created in.\n  ORIGINAL_PCH_DIR,\n\n  /// Record code for file ID of the file or buffer that was used to\n  /// generate the AST file.\n  ORIGINAL_FILE_ID,\n\n  /// Offsets into the input-files block where input files\n  /// reside.\n  INPUT_FILE_OFFSETS,\n\n  /// Record code for the module name.\n  MODULE_NAME,\n\n  /// Record code for the module map file that was used to build this\n  /// AST file.\n  MODULE_MAP_FILE,\n\n  /// Record code for the module build directory.\n  MODULE_DIRECTORY,\n};\n\n/// Record types that occur within the options block inside\n/// the control block.\nenum OptionsRecordTypes {\n  /// Record code for the language options table.\n  ///\n  /// The record with this code contains the contents of the\n  /// LangOptions structure. We serialize the entire contents of\n  /// the structure, and let the reader decide which options are\n  /// actually important to check.\n  LANGUAGE_OPTIONS = 1,\n\n  /// Record code for the target options table.\n  TARGET_OPTIONS,\n\n  /// Record code for the filesystem options table.\n  FILE_SYSTEM_OPTIONS,\n\n  /// Record code for the headers search options table.\n  HEADER_SEARCH_OPTIONS,\n\n  /// Record code for the preprocessor options table.\n  PREPROCESSOR_OPTIONS,\n};\n\n/// Record codes for the unhashed control block.\nenum UnhashedControlBlockRecordTypes {\n  /// Record code for the signature that identifiers this AST file.\n  SIGNATURE = 1,\n\n  /// Record code for the content hash of the AST block.\n  AST_BLOCK_HASH,\n\n  /// Record code for the diagnostic options table.\n  DIAGNOSTIC_OPTIONS,\n\n  /// Record code for \\#pragma diagnostic mappings.\n  DIAG_PRAGMA_MAPPINGS,\n};\n\n/// Record code for extension blocks.\nenum ExtensionBlockRecordTypes {\n  /// Metadata describing this particular extension.\n  EXTENSION_METADATA = 1,\n\n  /// The first record ID allocated to the extensions themselves.\n  FIRST_EXTENSION_RECORD_ID = 4\n};\n\n/// Record types that occur within the input-files block\n/// inside the control block.\nenum InputFileRecordTypes {\n  /// An input file.\n  INPUT_FILE = 1,\n\n  /// The input file content hash\n  INPUT_FILE_HASH\n};\n\n/// Record types that occur within the AST block itself.\nenum ASTRecordTypes {\n  /// Record code for the offsets of each type.\n  ///\n  /// The TYPE_OFFSET constant describes the record that occurs\n  /// within the AST block. The record itself is an array of offsets that\n  /// point into the declarations and types block (identified by\n  /// DECLTYPES_BLOCK_ID). The index into the array is based on the ID\n  /// of a type. For a given type ID @c T, the lower three bits of\n  /// @c T are its qualifiers (const, volatile, restrict), as in\n  /// the QualType class. The upper bits, after being shifted and\n  /// subtracting NUM_PREDEF_TYPE_IDS, are used to index into the\n  /// TYPE_OFFSET block to determine the offset of that type's\n  /// corresponding record within the DECLTYPES_BLOCK_ID block.\n  TYPE_OFFSET = 1,\n\n  /// Record code for the offsets of each decl.\n  ///\n  /// The DECL_OFFSET constant describes the record that occurs\n  /// within the block identified by DECL_OFFSETS_BLOCK_ID within\n  /// the AST block. The record itself is an array of offsets that\n  /// point into the declarations and types block (identified by\n  /// DECLTYPES_BLOCK_ID). The declaration ID is an index into this\n  /// record, after subtracting one to account for the use of\n  /// declaration ID 0 for a NULL declaration pointer. Index 0 is\n  /// reserved for the translation unit declaration.\n  DECL_OFFSET = 2,\n\n  /// Record code for the table of offsets of each\n  /// identifier ID.\n  ///\n  /// The offset table contains offsets into the blob stored in\n  /// the IDENTIFIER_TABLE record. Each offset points to the\n  /// NULL-terminated string that corresponds to that identifier.\n  IDENTIFIER_OFFSET = 3,\n\n  /// This is so that older clang versions, before the introduction\n  /// of the control block, can read and reject the newer PCH format.\n  /// *DON'T CHANGE THIS NUMBER*.\n  METADATA_OLD_FORMAT = 4,\n\n  /// Record code for the identifier table.\n  ///\n  /// The identifier table is a simple blob that contains\n  /// NULL-terminated strings for all of the identifiers\n  /// referenced by the AST file. The IDENTIFIER_OFFSET table\n  /// contains the mapping from identifier IDs to the characters\n  /// in this blob. Note that the starting offsets of all of the\n  /// identifiers are odd, so that, when the identifier offset\n  /// table is loaded in, we can use the low bit to distinguish\n  /// between offsets (for unresolved identifier IDs) and\n  /// IdentifierInfo pointers (for already-resolved identifier\n  /// IDs).\n  IDENTIFIER_TABLE = 5,\n\n  /// Record code for the array of eagerly deserialized decls.\n  ///\n  /// The AST file contains a list of all of the declarations that should be\n  /// eagerly deserialized present within the parsed headers, stored as an\n  /// array of declaration IDs. These declarations will be\n  /// reported to the AST consumer after the AST file has been\n  /// read, since their presence can affect the semantics of the\n  /// program (e.g., for code generation).\n  EAGERLY_DESERIALIZED_DECLS = 6,\n\n  /// Record code for the set of non-builtin, special\n  /// types.\n  ///\n  /// This record contains the type IDs for the various type nodes\n  /// that are constructed during semantic analysis (e.g.,\n  /// __builtin_va_list). The SPECIAL_TYPE_* constants provide\n  /// offsets into this record.\n  SPECIAL_TYPES = 7,\n\n  /// Record code for the extra statistics we gather while\n  /// generating an AST file.\n  STATISTICS = 8,\n\n  /// Record code for the array of tentative definitions.\n  TENTATIVE_DEFINITIONS = 9,\n\n  // ID 10 used to be for a list of extern \"C\" declarations.\n\n  /// Record code for the table of offsets into the\n  /// Objective-C method pool.\n  SELECTOR_OFFSETS = 11,\n\n  /// Record code for the Objective-C method pool,\n  METHOD_POOL = 12,\n\n  /// The value of the next __COUNTER__ to dispense.\n  /// [PP_COUNTER_VALUE, Val]\n  PP_COUNTER_VALUE = 13,\n\n  /// Record code for the table of offsets into the block\n  /// of source-location information.\n  SOURCE_LOCATION_OFFSETS = 14,\n\n  /// Record code for the set of source location entries\n  /// that need to be preloaded by the AST reader.\n  ///\n  /// This set contains the source location entry for the\n  /// predefines buffer and for any file entries that need to be\n  /// preloaded.\n  SOURCE_LOCATION_PRELOADS = 15,\n\n  /// Record code for the set of ext_vector type names.\n  EXT_VECTOR_DECLS = 16,\n\n  /// Record code for the array of unused file scoped decls.\n  UNUSED_FILESCOPED_DECLS = 17,\n\n  /// Record code for the table of offsets to entries in the\n  /// preprocessing record.\n  PPD_ENTITIES_OFFSETS = 18,\n\n  /// Record code for the array of VTable uses.\n  VTABLE_USES = 19,\n\n  // ID 20 used to be for a list of dynamic classes.\n\n  /// Record code for referenced selector pool.\n  REFERENCED_SELECTOR_POOL = 21,\n\n  /// Record code for an update to the TU's lexically contained\n  /// declarations.\n  TU_UPDATE_LEXICAL = 22,\n\n  // ID 23 used to be for a list of local redeclarations.\n\n  /// Record code for declarations that Sema keeps references of.\n  SEMA_DECL_REFS = 24,\n\n  /// Record code for weak undeclared identifiers.\n  WEAK_UNDECLARED_IDENTIFIERS = 25,\n\n  /// Record code for pending implicit instantiations.\n  PENDING_IMPLICIT_INSTANTIATIONS = 26,\n\n  // ID 27 used to be for a list of replacement decls.\n\n  /// Record code for an update to a decl context's lookup table.\n  ///\n  /// In practice, this should only be used for the TU and namespaces.\n  UPDATE_VISIBLE = 28,\n\n  /// Record for offsets of DECL_UPDATES records for declarations\n  /// that were modified after being deserialized and need updates.\n  DECL_UPDATE_OFFSETS = 29,\n\n  // ID 30 used to be a decl update record. These are now in the DECLTYPES\n  // block.\n\n  // ID 31 used to be a list of offsets to DECL_CXX_BASE_SPECIFIERS records.\n\n  // ID 32 used to be the code for \\#pragma diagnostic mappings.\n\n  /// Record code for special CUDA declarations.\n  CUDA_SPECIAL_DECL_REFS = 33,\n\n  /// Record code for header search information.\n  HEADER_SEARCH_TABLE = 34,\n\n  /// Record code for floating point \\#pragma options.\n  FP_PRAGMA_OPTIONS = 35,\n\n  /// Record code for enabled OpenCL extensions.\n  OPENCL_EXTENSIONS = 36,\n\n  /// The list of delegating constructor declarations.\n  DELEGATING_CTORS = 37,\n\n  /// Record code for the set of known namespaces, which are used\n  /// for typo correction.\n  KNOWN_NAMESPACES = 38,\n\n  /// Record code for the remapping information used to relate\n  /// loaded modules to the various offsets and IDs(e.g., source location\n  /// offests, declaration and type IDs) that are used in that module to\n  /// refer to other modules.\n  MODULE_OFFSET_MAP = 39,\n\n  /// Record code for the source manager line table information,\n  /// which stores information about \\#line directives.\n  SOURCE_MANAGER_LINE_TABLE = 40,\n\n  /// Record code for map of Objective-C class definition IDs to the\n  /// ObjC categories in a module that are attached to that class.\n  OBJC_CATEGORIES_MAP = 41,\n\n  /// Record code for a file sorted array of DeclIDs in a module.\n  FILE_SORTED_DECLS = 42,\n\n  /// Record code for an array of all of the (sub)modules that were\n  /// imported by the AST file.\n  IMPORTED_MODULES = 43,\n\n  // ID 44 used to be a table of merged canonical declarations.\n  // ID 45 used to be a list of declaration IDs of local redeclarations.\n\n  /// Record code for the array of Objective-C categories (including\n  /// extensions).\n  ///\n  /// This array can only be interpreted properly using the Objective-C\n  /// categories map.\n  OBJC_CATEGORIES = 46,\n\n  /// Record code for the table of offsets of each macro ID.\n  ///\n  /// The offset table contains offsets into the blob stored in\n  /// the preprocessor block. Each offset points to the corresponding\n  /// macro definition.\n  MACRO_OFFSET = 47,\n\n  /// A list of \"interesting\" identifiers. Only used in C++ (where we\n  /// don't normally do lookups into the serialized identifier table). These\n  /// are eagerly deserialized.\n  INTERESTING_IDENTIFIERS = 48,\n\n  /// Record code for undefined but used functions and variables that\n  /// need a definition in this TU.\n  UNDEFINED_BUT_USED = 49,\n\n  /// Record code for late parsed template functions.\n  LATE_PARSED_TEMPLATE = 50,\n\n  /// Record code for \\#pragma optimize options.\n  OPTIMIZE_PRAGMA_OPTIONS = 51,\n\n  /// Record code for potentially unused local typedef names.\n  UNUSED_LOCAL_TYPEDEF_NAME_CANDIDATES = 52,\n\n  // ID 53 used to be a table of constructor initializer records.\n\n  /// Delete expressions that will be analyzed later.\n  DELETE_EXPRS_TO_ANALYZE = 54,\n\n  /// Record code for \\#pragma ms_struct options.\n  MSSTRUCT_PRAGMA_OPTIONS = 55,\n\n  /// Record code for \\#pragma ms_struct options.\n  POINTERS_TO_MEMBERS_PRAGMA_OPTIONS = 56,\n\n  /// Number of unmatched #pragma clang cuda_force_host_device begin\n  /// directives we've seen.\n  CUDA_PRAGMA_FORCE_HOST_DEVICE_DEPTH = 57,\n\n  /// Record code for types associated with OpenCL extensions.\n  OPENCL_EXTENSION_TYPES = 58,\n\n  /// Record code for declarations associated with OpenCL extensions.\n  OPENCL_EXTENSION_DECLS = 59,\n\n  MODULAR_CODEGEN_DECLS = 60,\n\n  /// Record code for \\#pragma align/pack options.\n  ALIGN_PACK_PRAGMA_OPTIONS = 61,\n\n  /// The stack of open #ifs/#ifdefs recorded in a preamble.\n  PP_CONDITIONAL_STACK = 62,\n\n  /// A table of skipped ranges within the preprocessing record.\n  PPD_SKIPPED_RANGES = 63,\n\n  /// Record code for the Decls to be checked for deferred diags.\n  DECLS_TO_CHECK_FOR_DEFERRED_DIAGS = 64,\n\n  /// Record code for \\#pragma float_control options.\n  FLOAT_CONTROL_PRAGMA_OPTIONS = 65,\n};\n\n/// Record types used within a source manager block.\nenum SourceManagerRecordTypes {\n  /// Describes a source location entry (SLocEntry) for a\n  /// file.\n  SM_SLOC_FILE_ENTRY = 1,\n\n  /// Describes a source location entry (SLocEntry) for a\n  /// buffer.\n  SM_SLOC_BUFFER_ENTRY = 2,\n\n  /// Describes a blob that contains the data for a buffer\n  /// entry. This kind of record always directly follows a\n  /// SM_SLOC_BUFFER_ENTRY record or a SM_SLOC_FILE_ENTRY with an\n  /// overridden buffer.\n  SM_SLOC_BUFFER_BLOB = 3,\n\n  /// Describes a zlib-compressed blob that contains the data for\n  /// a buffer entry.\n  SM_SLOC_BUFFER_BLOB_COMPRESSED = 4,\n\n  /// Describes a source location entry (SLocEntry) for a\n  /// macro expansion.\n  SM_SLOC_EXPANSION_ENTRY = 5\n};\n\n/// Record types used within a preprocessor block.\nenum PreprocessorRecordTypes {\n  // The macros in the PP section are a PP_MACRO_* instance followed by a\n  // list of PP_TOKEN instances for each token in the definition.\n\n  /// An object-like macro definition.\n  /// [PP_MACRO_OBJECT_LIKE, IdentInfoID, SLoc, IsUsed]\n  PP_MACRO_OBJECT_LIKE = 1,\n\n  /// A function-like macro definition.\n  /// [PP_MACRO_FUNCTION_LIKE, \\<ObjectLikeStuff>, IsC99Varargs,\n  /// IsGNUVarars, NumArgs, ArgIdentInfoID* ]\n  PP_MACRO_FUNCTION_LIKE = 2,\n\n  /// Describes one token.\n  /// [PP_TOKEN, SLoc, Length, IdentInfoID, Kind, Flags]\n  PP_TOKEN = 3,\n\n  /// The macro directives history for a particular identifier.\n  PP_MACRO_DIRECTIVE_HISTORY = 4,\n\n  /// A macro directive exported by a module.\n  /// [PP_MODULE_MACRO, SubmoduleID, MacroID, (Overridden SubmoduleID)*]\n  PP_MODULE_MACRO = 5,\n};\n\n/// Record types used within a preprocessor detail block.\nenum PreprocessorDetailRecordTypes {\n  /// Describes a macro expansion within the preprocessing record.\n  PPD_MACRO_EXPANSION = 0,\n\n  /// Describes a macro definition within the preprocessing record.\n  PPD_MACRO_DEFINITION = 1,\n\n  /// Describes an inclusion directive within the preprocessing\n  /// record.\n  PPD_INCLUSION_DIRECTIVE = 2\n};\n\n/// Record types used within a submodule description block.\nenum SubmoduleRecordTypes {\n  /// Metadata for submodules as a whole.\n  SUBMODULE_METADATA = 0,\n\n  /// Defines the major attributes of a submodule, including its\n  /// name and parent.\n  SUBMODULE_DEFINITION = 1,\n\n  /// Specifies the umbrella header used to create this module,\n  /// if any.\n  SUBMODULE_UMBRELLA_HEADER = 2,\n\n  /// Specifies a header that falls into this (sub)module.\n  SUBMODULE_HEADER = 3,\n\n  /// Specifies a top-level header that falls into this (sub)module.\n  SUBMODULE_TOPHEADER = 4,\n\n  /// Specifies an umbrella directory.\n  SUBMODULE_UMBRELLA_DIR = 5,\n\n  /// Specifies the submodules that are imported by this\n  /// submodule.\n  SUBMODULE_IMPORTS = 6,\n\n  /// Specifies the submodules that are re-exported from this\n  /// submodule.\n  SUBMODULE_EXPORTS = 7,\n\n  /// Specifies a required feature.\n  SUBMODULE_REQUIRES = 8,\n\n  /// Specifies a header that has been explicitly excluded\n  /// from this submodule.\n  SUBMODULE_EXCLUDED_HEADER = 9,\n\n  /// Specifies a library or framework to link against.\n  SUBMODULE_LINK_LIBRARY = 10,\n\n  /// Specifies a configuration macro for this module.\n  SUBMODULE_CONFIG_MACRO = 11,\n\n  /// Specifies a conflict with another module.\n  SUBMODULE_CONFLICT = 12,\n\n  /// Specifies a header that is private to this submodule.\n  SUBMODULE_PRIVATE_HEADER = 13,\n\n  /// Specifies a header that is part of the module but must be\n  /// textually included.\n  SUBMODULE_TEXTUAL_HEADER = 14,\n\n  /// Specifies a header that is private to this submodule but\n  /// must be textually included.\n  SUBMODULE_PRIVATE_TEXTUAL_HEADER = 15,\n\n  /// Specifies some declarations with initializers that must be\n  /// emitted to initialize the module.\n  SUBMODULE_INITIALIZERS = 16,\n\n  /// Specifies the name of the module that will eventually\n  /// re-export the entities in this module.\n  SUBMODULE_EXPORT_AS = 17,\n};\n\n/// Record types used within a comments block.\nenum CommentRecordTypes { COMMENTS_RAW_COMMENT = 0 };\n\n/// \\defgroup ASTAST AST file AST constants\n///\n/// The constants in this group describe various components of the\n/// abstract syntax tree within an AST file.\n///\n/// @{\n\n/// Predefined type IDs.\n///\n/// These type IDs correspond to predefined types in the AST\n/// context, such as built-in types (int) and special place-holder\n/// types (the \\<overload> and \\<dependent> type markers). Such\n/// types are never actually serialized, since they will be built\n/// by the AST context when it is created.\nenum PredefinedTypeIDs {\n  /// The NULL type.\n  PREDEF_TYPE_NULL_ID = 0,\n\n  /// The void type.\n  PREDEF_TYPE_VOID_ID = 1,\n\n  /// The 'bool' or '_Bool' type.\n  PREDEF_TYPE_BOOL_ID = 2,\n\n  /// The 'char' type, when it is unsigned.\n  PREDEF_TYPE_CHAR_U_ID = 3,\n\n  /// The 'unsigned char' type.\n  PREDEF_TYPE_UCHAR_ID = 4,\n\n  /// The 'unsigned short' type.\n  PREDEF_TYPE_USHORT_ID = 5,\n\n  /// The 'unsigned int' type.\n  PREDEF_TYPE_UINT_ID = 6,\n\n  /// The 'unsigned long' type.\n  PREDEF_TYPE_ULONG_ID = 7,\n\n  /// The 'unsigned long long' type.\n  PREDEF_TYPE_ULONGLONG_ID = 8,\n\n  /// The 'char' type, when it is signed.\n  PREDEF_TYPE_CHAR_S_ID = 9,\n\n  /// The 'signed char' type.\n  PREDEF_TYPE_SCHAR_ID = 10,\n\n  /// The C++ 'wchar_t' type.\n  PREDEF_TYPE_WCHAR_ID = 11,\n\n  /// The (signed) 'short' type.\n  PREDEF_TYPE_SHORT_ID = 12,\n\n  /// The (signed) 'int' type.\n  PREDEF_TYPE_INT_ID = 13,\n\n  /// The (signed) 'long' type.\n  PREDEF_TYPE_LONG_ID = 14,\n\n  /// The (signed) 'long long' type.\n  PREDEF_TYPE_LONGLONG_ID = 15,\n\n  /// The 'float' type.\n  PREDEF_TYPE_FLOAT_ID = 16,\n\n  /// The 'double' type.\n  PREDEF_TYPE_DOUBLE_ID = 17,\n\n  /// The 'long double' type.\n  PREDEF_TYPE_LONGDOUBLE_ID = 18,\n\n  /// The placeholder type for overloaded function sets.\n  PREDEF_TYPE_OVERLOAD_ID = 19,\n\n  /// The placeholder type for dependent types.\n  PREDEF_TYPE_DEPENDENT_ID = 20,\n\n  /// The '__uint128_t' type.\n  PREDEF_TYPE_UINT128_ID = 21,\n\n  /// The '__int128_t' type.\n  PREDEF_TYPE_INT128_ID = 22,\n\n  /// The type of 'nullptr'.\n  PREDEF_TYPE_NULLPTR_ID = 23,\n\n  /// The C++ 'char16_t' type.\n  PREDEF_TYPE_CHAR16_ID = 24,\n\n  /// The C++ 'char32_t' type.\n  PREDEF_TYPE_CHAR32_ID = 25,\n\n  /// The ObjC 'id' type.\n  PREDEF_TYPE_OBJC_ID = 26,\n\n  /// The ObjC 'Class' type.\n  PREDEF_TYPE_OBJC_CLASS = 27,\n\n  /// The ObjC 'SEL' type.\n  PREDEF_TYPE_OBJC_SEL = 28,\n\n  /// The 'unknown any' placeholder type.\n  PREDEF_TYPE_UNKNOWN_ANY = 29,\n\n  /// The placeholder type for bound member functions.\n  PREDEF_TYPE_BOUND_MEMBER = 30,\n\n  /// The \"auto\" deduction type.\n  PREDEF_TYPE_AUTO_DEDUCT = 31,\n\n  /// The \"auto &&\" deduction type.\n  PREDEF_TYPE_AUTO_RREF_DEDUCT = 32,\n\n  /// The OpenCL 'half' / ARM NEON __fp16 type.\n  PREDEF_TYPE_HALF_ID = 33,\n\n  /// ARC's unbridged-cast placeholder type.\n  PREDEF_TYPE_ARC_UNBRIDGED_CAST = 34,\n\n  /// The pseudo-object placeholder type.\n  PREDEF_TYPE_PSEUDO_OBJECT = 35,\n\n  /// The placeholder type for builtin functions.\n  PREDEF_TYPE_BUILTIN_FN = 36,\n\n  /// OpenCL event type.\n  PREDEF_TYPE_EVENT_ID = 37,\n\n  /// OpenCL clk event type.\n  PREDEF_TYPE_CLK_EVENT_ID = 38,\n\n  /// OpenCL sampler type.\n  PREDEF_TYPE_SAMPLER_ID = 39,\n\n  /// OpenCL queue type.\n  PREDEF_TYPE_QUEUE_ID = 40,\n\n  /// OpenCL reserve_id type.\n  PREDEF_TYPE_RESERVE_ID_ID = 41,\n\n  /// The placeholder type for OpenMP array section.\n  PREDEF_TYPE_OMP_ARRAY_SECTION = 42,\n\n  /// The '__float128' type\n  PREDEF_TYPE_FLOAT128_ID = 43,\n\n  /// The '_Float16' type\n  PREDEF_TYPE_FLOAT16_ID = 44,\n\n  /// The C++ 'char8_t' type.\n  PREDEF_TYPE_CHAR8_ID = 45,\n\n  /// \\brief The 'short _Accum' type\n  PREDEF_TYPE_SHORT_ACCUM_ID = 46,\n\n  /// \\brief The '_Accum' type\n  PREDEF_TYPE_ACCUM_ID = 47,\n\n  /// \\brief The 'long _Accum' type\n  PREDEF_TYPE_LONG_ACCUM_ID = 48,\n\n  /// \\brief The 'unsigned short _Accum' type\n  PREDEF_TYPE_USHORT_ACCUM_ID = 49,\n\n  /// \\brief The 'unsigned _Accum' type\n  PREDEF_TYPE_UACCUM_ID = 50,\n\n  /// \\brief The 'unsigned long _Accum' type\n  PREDEF_TYPE_ULONG_ACCUM_ID = 51,\n\n  /// \\brief The 'short _Fract' type\n  PREDEF_TYPE_SHORT_FRACT_ID = 52,\n\n  /// \\brief The '_Fract' type\n  PREDEF_TYPE_FRACT_ID = 53,\n\n  /// \\brief The 'long _Fract' type\n  PREDEF_TYPE_LONG_FRACT_ID = 54,\n\n  /// \\brief The 'unsigned short _Fract' type\n  PREDEF_TYPE_USHORT_FRACT_ID = 55,\n\n  /// \\brief The 'unsigned _Fract' type\n  PREDEF_TYPE_UFRACT_ID = 56,\n\n  /// \\brief The 'unsigned long _Fract' type\n  PREDEF_TYPE_ULONG_FRACT_ID = 57,\n\n  /// \\brief The '_Sat short _Accum' type\n  PREDEF_TYPE_SAT_SHORT_ACCUM_ID = 58,\n\n  /// \\brief The '_Sat _Accum' type\n  PREDEF_TYPE_SAT_ACCUM_ID = 59,\n\n  /// \\brief The '_Sat long _Accum' type\n  PREDEF_TYPE_SAT_LONG_ACCUM_ID = 60,\n\n  /// \\brief The '_Sat unsigned short _Accum' type\n  PREDEF_TYPE_SAT_USHORT_ACCUM_ID = 61,\n\n  /// \\brief The '_Sat unsigned _Accum' type\n  PREDEF_TYPE_SAT_UACCUM_ID = 62,\n\n  /// \\brief The '_Sat unsigned long _Accum' type\n  PREDEF_TYPE_SAT_ULONG_ACCUM_ID = 63,\n\n  /// \\brief The '_Sat short _Fract' type\n  PREDEF_TYPE_SAT_SHORT_FRACT_ID = 64,\n\n  /// \\brief The '_Sat _Fract' type\n  PREDEF_TYPE_SAT_FRACT_ID = 65,\n\n  /// \\brief The '_Sat long _Fract' type\n  PREDEF_TYPE_SAT_LONG_FRACT_ID = 66,\n\n  /// \\brief The '_Sat unsigned short _Fract' type\n  PREDEF_TYPE_SAT_USHORT_FRACT_ID = 67,\n\n  /// \\brief The '_Sat unsigned _Fract' type\n  PREDEF_TYPE_SAT_UFRACT_ID = 68,\n\n  /// \\brief The '_Sat unsigned long _Fract' type\n  PREDEF_TYPE_SAT_ULONG_FRACT_ID = 69,\n\n  /// The placeholder type for OpenMP array shaping operation.\n  PREDEF_TYPE_OMP_ARRAY_SHAPING = 70,\n\n  /// The placeholder type for OpenMP iterator expression.\n  PREDEF_TYPE_OMP_ITERATOR = 71,\n\n  /// A placeholder type for incomplete matrix index operations.\n  PREDEF_TYPE_INCOMPLETE_MATRIX_IDX = 72,\n\n  /// \\brief The '__bf16' type\n  PREDEF_TYPE_BFLOAT16_ID = 73,\n\n/// OpenCL image types with auto numeration\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \\\n  PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/OpenCLImageTypes.def\"\n/// \\brief OpenCL extension types with auto numeration\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n// \\brief SVE types with auto numeration\n#define SVE_TYPE(Name, Id, SingletonId) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n// \\brief  PowerPC MMA types with auto numeration\n#define PPC_VECTOR_TYPE(Name, Id, Size) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/PPCTypes.def\"\n// \\brief RISC-V V types with auto numeration\n#define RVV_TYPE(Name, Id, SingletonId) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/RISCVVTypes.def\"\n};\n\n/// The number of predefined type IDs that are reserved for\n/// the PREDEF_TYPE_* constants.\n///\n/// Type IDs for non-predefined types will start at\n/// NUM_PREDEF_TYPE_IDs.\nconst unsigned NUM_PREDEF_TYPE_IDS = 300;\n\n/// Record codes for each kind of type.\n///\n/// These constants describe the type records that can occur within a\n/// block identified by DECLTYPES_BLOCK_ID in the AST file. Each\n/// constant describes a record for a specific type class in the\n/// AST. Note that DeclCode values share this code space.\nenum TypeCode {\n#define TYPE_BIT_CODE(CLASS_ID, CODE_ID, CODE_VALUE)                           \\\n  TYPE_##CODE_ID = CODE_VALUE,\n#include \"clang/Serialization/TypeBitCodes.def\"\n\n  /// An ExtQualType record.\n  TYPE_EXT_QUAL = 1\n};\n\n/// The type IDs for special types constructed by semantic\n/// analysis.\n///\n/// The constants in this enumeration are indices into the\n/// SPECIAL_TYPES record.\nenum SpecialTypeIDs {\n  /// CFConstantString type\n  SPECIAL_TYPE_CF_CONSTANT_STRING = 0,\n\n  /// C FILE typedef type\n  SPECIAL_TYPE_FILE = 1,\n\n  /// C jmp_buf typedef type\n  SPECIAL_TYPE_JMP_BUF = 2,\n\n  /// C sigjmp_buf typedef type\n  SPECIAL_TYPE_SIGJMP_BUF = 3,\n\n  /// Objective-C \"id\" redefinition type\n  SPECIAL_TYPE_OBJC_ID_REDEFINITION = 4,\n\n  /// Objective-C \"Class\" redefinition type\n  SPECIAL_TYPE_OBJC_CLASS_REDEFINITION = 5,\n\n  /// Objective-C \"SEL\" redefinition type\n  SPECIAL_TYPE_OBJC_SEL_REDEFINITION = 6,\n\n  /// C ucontext_t typedef type\n  SPECIAL_TYPE_UCONTEXT_T = 7\n};\n\n/// The number of special type IDs.\nconst unsigned NumSpecialTypeIDs = 8;\n\n/// Predefined declaration IDs.\n///\n/// These declaration IDs correspond to predefined declarations in the AST\n/// context, such as the NULL declaration ID. Such declarations are never\n/// actually serialized, since they will be built by the AST context when\n/// it is created.\nenum PredefinedDeclIDs {\n  /// The NULL declaration.\n  PREDEF_DECL_NULL_ID = 0,\n\n  /// The translation unit.\n  PREDEF_DECL_TRANSLATION_UNIT_ID = 1,\n\n  /// The Objective-C 'id' type.\n  PREDEF_DECL_OBJC_ID_ID = 2,\n\n  /// The Objective-C 'SEL' type.\n  PREDEF_DECL_OBJC_SEL_ID = 3,\n\n  /// The Objective-C 'Class' type.\n  PREDEF_DECL_OBJC_CLASS_ID = 4,\n\n  /// The Objective-C 'Protocol' type.\n  PREDEF_DECL_OBJC_PROTOCOL_ID = 5,\n\n  /// The signed 128-bit integer type.\n  PREDEF_DECL_INT_128_ID = 6,\n\n  /// The unsigned 128-bit integer type.\n  PREDEF_DECL_UNSIGNED_INT_128_ID = 7,\n\n  /// The internal 'instancetype' typedef.\n  PREDEF_DECL_OBJC_INSTANCETYPE_ID = 8,\n\n  /// The internal '__builtin_va_list' typedef.\n  PREDEF_DECL_BUILTIN_VA_LIST_ID = 9,\n\n  /// The internal '__va_list_tag' struct, if any.\n  PREDEF_DECL_VA_LIST_TAG = 10,\n\n  /// The internal '__builtin_ms_va_list' typedef.\n  PREDEF_DECL_BUILTIN_MS_VA_LIST_ID = 11,\n\n  /// The predeclared '_GUID' struct.\n  PREDEF_DECL_BUILTIN_MS_GUID_ID = 12,\n\n  /// The extern \"C\" context.\n  PREDEF_DECL_EXTERN_C_CONTEXT_ID = 13,\n\n  /// The internal '__make_integer_seq' template.\n  PREDEF_DECL_MAKE_INTEGER_SEQ_ID = 14,\n\n  /// The internal '__NSConstantString' typedef.\n  PREDEF_DECL_CF_CONSTANT_STRING_ID = 15,\n\n  /// The internal '__NSConstantString' tag type.\n  PREDEF_DECL_CF_CONSTANT_STRING_TAG_ID = 16,\n\n  /// The internal '__type_pack_element' template.\n  PREDEF_DECL_TYPE_PACK_ELEMENT_ID = 17,\n};\n\n/// The number of declaration IDs that are predefined.\n///\n/// For more information about predefined declarations, see the\n/// \\c PredefinedDeclIDs type and the PREDEF_DECL_*_ID constants.\nconst unsigned int NUM_PREDEF_DECL_IDS = 18;\n\n/// Record of updates for a declaration that was modified after\n/// being deserialized. This can occur within DECLTYPES_BLOCK_ID.\nconst unsigned int DECL_UPDATES = 49;\n\n/// Record code for a list of local redeclarations of a declaration.\n/// This can occur within DECLTYPES_BLOCK_ID.\nconst unsigned int LOCAL_REDECLARATIONS = 50;\n\n/// Record codes for each kind of declaration.\n///\n/// These constants describe the declaration records that can occur within\n/// a declarations block (identified by DECLTYPES_BLOCK_ID). Each\n/// constant describes a record for a specific declaration class\n/// in the AST. Note that TypeCode values share this code space.\nenum DeclCode {\n  /// A TypedefDecl record.\n  DECL_TYPEDEF = 51,\n  /// A TypeAliasDecl record.\n\n  DECL_TYPEALIAS,\n\n  /// An EnumDecl record.\n  DECL_ENUM,\n\n  /// A RecordDecl record.\n  DECL_RECORD,\n\n  /// An EnumConstantDecl record.\n  DECL_ENUM_CONSTANT,\n\n  /// A FunctionDecl record.\n  DECL_FUNCTION,\n\n  /// A ObjCMethodDecl record.\n  DECL_OBJC_METHOD,\n\n  /// A ObjCInterfaceDecl record.\n  DECL_OBJC_INTERFACE,\n\n  /// A ObjCProtocolDecl record.\n  DECL_OBJC_PROTOCOL,\n\n  /// A ObjCIvarDecl record.\n  DECL_OBJC_IVAR,\n\n  /// A ObjCAtDefsFieldDecl record.\n  DECL_OBJC_AT_DEFS_FIELD,\n\n  /// A ObjCCategoryDecl record.\n  DECL_OBJC_CATEGORY,\n\n  /// A ObjCCategoryImplDecl record.\n  DECL_OBJC_CATEGORY_IMPL,\n\n  /// A ObjCImplementationDecl record.\n  DECL_OBJC_IMPLEMENTATION,\n\n  /// A ObjCCompatibleAliasDecl record.\n  DECL_OBJC_COMPATIBLE_ALIAS,\n\n  /// A ObjCPropertyDecl record.\n  DECL_OBJC_PROPERTY,\n\n  /// A ObjCPropertyImplDecl record.\n  DECL_OBJC_PROPERTY_IMPL,\n\n  /// A FieldDecl record.\n  DECL_FIELD,\n\n  /// A MSPropertyDecl record.\n  DECL_MS_PROPERTY,\n\n  /// A MSGuidDecl record.\n  DECL_MS_GUID,\n\n  /// A TemplateParamObjectDecl record.\n  DECL_TEMPLATE_PARAM_OBJECT,\n\n  /// A VarDecl record.\n  DECL_VAR,\n\n  /// An ImplicitParamDecl record.\n  DECL_IMPLICIT_PARAM,\n\n  /// A ParmVarDecl record.\n  DECL_PARM_VAR,\n\n  /// A DecompositionDecl record.\n  DECL_DECOMPOSITION,\n\n  /// A BindingDecl record.\n  DECL_BINDING,\n\n  /// A FileScopeAsmDecl record.\n  DECL_FILE_SCOPE_ASM,\n\n  /// A BlockDecl record.\n  DECL_BLOCK,\n\n  /// A CapturedDecl record.\n  DECL_CAPTURED,\n\n  /// A record that stores the set of declarations that are\n  /// lexically stored within a given DeclContext.\n  ///\n  /// The record itself is a blob that is an array of declaration IDs,\n  /// in the order in which those declarations were added to the\n  /// declaration context. This data is used when iterating over\n  /// the contents of a DeclContext, e.g., via\n  /// DeclContext::decls_begin() and DeclContext::decls_end().\n  DECL_CONTEXT_LEXICAL,\n\n  /// A record that stores the set of declarations that are\n  /// visible from a given DeclContext.\n  ///\n  /// The record itself stores a set of mappings, each of which\n  /// associates a declaration name with one or more declaration\n  /// IDs. This data is used when performing qualified name lookup\n  /// into a DeclContext via DeclContext::lookup.\n  DECL_CONTEXT_VISIBLE,\n\n  /// A LabelDecl record.\n  DECL_LABEL,\n\n  /// A NamespaceDecl record.\n  DECL_NAMESPACE,\n\n  /// A NamespaceAliasDecl record.\n  DECL_NAMESPACE_ALIAS,\n\n  /// A UsingDecl record.\n  DECL_USING,\n\n  /// A UsingPackDecl record.\n  DECL_USING_PACK,\n\n  /// A UsingShadowDecl record.\n  DECL_USING_SHADOW,\n\n  /// A ConstructorUsingShadowDecl record.\n  DECL_CONSTRUCTOR_USING_SHADOW,\n\n  /// A UsingDirecitveDecl record.\n  DECL_USING_DIRECTIVE,\n\n  /// An UnresolvedUsingValueDecl record.\n  DECL_UNRESOLVED_USING_VALUE,\n\n  /// An UnresolvedUsingTypenameDecl record.\n  DECL_UNRESOLVED_USING_TYPENAME,\n\n  /// A LinkageSpecDecl record.\n  DECL_LINKAGE_SPEC,\n\n  /// An ExportDecl record.\n  DECL_EXPORT,\n\n  /// A CXXRecordDecl record.\n  DECL_CXX_RECORD,\n\n  /// A CXXDeductionGuideDecl record.\n  DECL_CXX_DEDUCTION_GUIDE,\n\n  /// A CXXMethodDecl record.\n  DECL_CXX_METHOD,\n\n  /// A CXXConstructorDecl record.\n  DECL_CXX_CONSTRUCTOR,\n\n  /// A CXXDestructorDecl record.\n  DECL_CXX_DESTRUCTOR,\n\n  /// A CXXConversionDecl record.\n  DECL_CXX_CONVERSION,\n\n  /// An AccessSpecDecl record.\n  DECL_ACCESS_SPEC,\n\n  /// A FriendDecl record.\n  DECL_FRIEND,\n\n  /// A FriendTemplateDecl record.\n  DECL_FRIEND_TEMPLATE,\n\n  /// A ClassTemplateDecl record.\n  DECL_CLASS_TEMPLATE,\n\n  /// A ClassTemplateSpecializationDecl record.\n  DECL_CLASS_TEMPLATE_SPECIALIZATION,\n\n  /// A ClassTemplatePartialSpecializationDecl record.\n  DECL_CLASS_TEMPLATE_PARTIAL_SPECIALIZATION,\n\n  /// A VarTemplateDecl record.\n  DECL_VAR_TEMPLATE,\n\n  /// A VarTemplateSpecializationDecl record.\n  DECL_VAR_TEMPLATE_SPECIALIZATION,\n\n  /// A VarTemplatePartialSpecializationDecl record.\n  DECL_VAR_TEMPLATE_PARTIAL_SPECIALIZATION,\n\n  /// A FunctionTemplateDecl record.\n  DECL_FUNCTION_TEMPLATE,\n\n  /// A TemplateTypeParmDecl record.\n  DECL_TEMPLATE_TYPE_PARM,\n\n  /// A NonTypeTemplateParmDecl record.\n  DECL_NON_TYPE_TEMPLATE_PARM,\n\n  /// A TemplateTemplateParmDecl record.\n  DECL_TEMPLATE_TEMPLATE_PARM,\n\n  /// A TypeAliasTemplateDecl record.\n  DECL_TYPE_ALIAS_TEMPLATE,\n\n  /// \\brief A ConceptDecl record.\n  DECL_CONCEPT,\n\n  /// \\brief A StaticAssertDecl record.\n  DECL_STATIC_ASSERT,\n\n  /// A record containing CXXBaseSpecifiers.\n  DECL_CXX_BASE_SPECIFIERS,\n\n  /// A record containing CXXCtorInitializers.\n  DECL_CXX_CTOR_INITIALIZERS,\n\n  /// A IndirectFieldDecl record.\n  DECL_INDIRECTFIELD,\n\n  /// A NonTypeTemplateParmDecl record that stores an expanded\n  /// non-type template parameter pack.\n  DECL_EXPANDED_NON_TYPE_TEMPLATE_PARM_PACK,\n\n  /// A TemplateTemplateParmDecl record that stores an expanded\n  /// template template parameter pack.\n  DECL_EXPANDED_TEMPLATE_TEMPLATE_PARM_PACK,\n\n  /// A ClassScopeFunctionSpecializationDecl record a class scope\n  /// function specialization. (Microsoft extension).\n  DECL_CLASS_SCOPE_FUNCTION_SPECIALIZATION,\n\n  /// An ImportDecl recording a module import.\n  DECL_IMPORT,\n\n  /// An OMPThreadPrivateDecl record.\n  DECL_OMP_THREADPRIVATE,\n\n  /// An OMPRequiresDecl record.\n  DECL_OMP_REQUIRES,\n\n  /// An OMPAllocateDcl record.\n  DECL_OMP_ALLOCATE,\n\n  /// An EmptyDecl record.\n  DECL_EMPTY,\n\n  /// An LifetimeExtendedTemporaryDecl record.\n  DECL_LIFETIME_EXTENDED_TEMPORARY,\n\n  /// A RequiresExprBodyDecl record.\n  DECL_REQUIRES_EXPR_BODY,\n\n  /// An ObjCTypeParamDecl record.\n  DECL_OBJC_TYPE_PARAM,\n\n  /// An OMPCapturedExprDecl record.\n  DECL_OMP_CAPTUREDEXPR,\n\n  /// A PragmaCommentDecl record.\n  DECL_PRAGMA_COMMENT,\n\n  /// A PragmaDetectMismatchDecl record.\n  DECL_PRAGMA_DETECT_MISMATCH,\n\n  /// An OMPDeclareMapperDecl record.\n  DECL_OMP_DECLARE_MAPPER,\n\n  /// An OMPDeclareReductionDecl record.\n  DECL_OMP_DECLARE_REDUCTION,\n\n  DECL_LAST = DECL_OMP_DECLARE_REDUCTION\n};\n\n/// Record codes for each kind of statement or expression.\n///\n/// These constants describe the records that describe statements\n/// or expressions. These records  occur within type and declarations\n/// block, so they begin with record values of 128.  Each constant\n/// describes a record for a specific statement or expression class in the\n/// AST.\nenum StmtCode {\n  /// A marker record that indicates that we are at the end\n  /// of an expression.\n  STMT_STOP = DECL_LAST + 1,\n\n  /// A NULL expression.\n  STMT_NULL_PTR,\n\n  /// A reference to a previously [de]serialized Stmt record.\n  STMT_REF_PTR,\n\n  /// A NullStmt record.\n  STMT_NULL,\n\n  /// A CompoundStmt record.\n  STMT_COMPOUND,\n\n  /// A CaseStmt record.\n  STMT_CASE,\n\n  /// A DefaultStmt record.\n  STMT_DEFAULT,\n\n  /// A LabelStmt record.\n  STMT_LABEL,\n\n  /// An AttributedStmt record.\n  STMT_ATTRIBUTED,\n\n  /// An IfStmt record.\n  STMT_IF,\n\n  /// A SwitchStmt record.\n  STMT_SWITCH,\n\n  /// A WhileStmt record.\n  STMT_WHILE,\n\n  /// A DoStmt record.\n  STMT_DO,\n\n  /// A ForStmt record.\n  STMT_FOR,\n\n  /// A GotoStmt record.\n  STMT_GOTO,\n\n  /// An IndirectGotoStmt record.\n  STMT_INDIRECT_GOTO,\n\n  /// A ContinueStmt record.\n  STMT_CONTINUE,\n\n  /// A BreakStmt record.\n  STMT_BREAK,\n\n  /// A ReturnStmt record.\n  STMT_RETURN,\n\n  /// A DeclStmt record.\n  STMT_DECL,\n\n  /// A CapturedStmt record.\n  STMT_CAPTURED,\n\n  /// A GCC-style AsmStmt record.\n  STMT_GCCASM,\n\n  /// A MS-style AsmStmt record.\n  STMT_MSASM,\n\n  /// A constant expression context.\n  EXPR_CONSTANT,\n\n  /// A PredefinedExpr record.\n  EXPR_PREDEFINED,\n\n  /// A DeclRefExpr record.\n  EXPR_DECL_REF,\n\n  /// An IntegerLiteral record.\n  EXPR_INTEGER_LITERAL,\n\n  /// A FloatingLiteral record.\n  EXPR_FLOATING_LITERAL,\n\n  /// An ImaginaryLiteral record.\n  EXPR_IMAGINARY_LITERAL,\n\n  /// A StringLiteral record.\n  EXPR_STRING_LITERAL,\n\n  /// A CharacterLiteral record.\n  EXPR_CHARACTER_LITERAL,\n\n  /// A ParenExpr record.\n  EXPR_PAREN,\n\n  /// A ParenListExpr record.\n  EXPR_PAREN_LIST,\n\n  /// A UnaryOperator record.\n  EXPR_UNARY_OPERATOR,\n\n  /// An OffsetOfExpr record.\n  EXPR_OFFSETOF,\n\n  /// A SizefAlignOfExpr record.\n  EXPR_SIZEOF_ALIGN_OF,\n\n  /// An ArraySubscriptExpr record.\n  EXPR_ARRAY_SUBSCRIPT,\n\n  /// An MatrixSubscriptExpr record.\n  EXPR_MATRIX_SUBSCRIPT,\n\n  /// A CallExpr record.\n  EXPR_CALL,\n\n  /// A MemberExpr record.\n  EXPR_MEMBER,\n\n  /// A BinaryOperator record.\n  EXPR_BINARY_OPERATOR,\n\n  /// A CompoundAssignOperator record.\n  EXPR_COMPOUND_ASSIGN_OPERATOR,\n\n  /// A ConditionOperator record.\n  EXPR_CONDITIONAL_OPERATOR,\n\n  /// An ImplicitCastExpr record.\n  EXPR_IMPLICIT_CAST,\n\n  /// A CStyleCastExpr record.\n  EXPR_CSTYLE_CAST,\n\n  /// A CompoundLiteralExpr record.\n  EXPR_COMPOUND_LITERAL,\n\n  /// An ExtVectorElementExpr record.\n  EXPR_EXT_VECTOR_ELEMENT,\n\n  /// An InitListExpr record.\n  EXPR_INIT_LIST,\n\n  /// A DesignatedInitExpr record.\n  EXPR_DESIGNATED_INIT,\n\n  /// A DesignatedInitUpdateExpr record.\n  EXPR_DESIGNATED_INIT_UPDATE,\n\n  /// An NoInitExpr record.\n  EXPR_NO_INIT,\n\n  /// An ArrayInitLoopExpr record.\n  EXPR_ARRAY_INIT_LOOP,\n\n  /// An ArrayInitIndexExpr record.\n  EXPR_ARRAY_INIT_INDEX,\n\n  /// An ImplicitValueInitExpr record.\n  EXPR_IMPLICIT_VALUE_INIT,\n\n  /// A VAArgExpr record.\n  EXPR_VA_ARG,\n\n  /// An AddrLabelExpr record.\n  EXPR_ADDR_LABEL,\n\n  /// A StmtExpr record.\n  EXPR_STMT,\n\n  /// A ChooseExpr record.\n  EXPR_CHOOSE,\n\n  /// A GNUNullExpr record.\n  EXPR_GNU_NULL,\n\n  /// A SourceLocExpr record.\n  EXPR_SOURCE_LOC,\n\n  /// A ShuffleVectorExpr record.\n  EXPR_SHUFFLE_VECTOR,\n\n  /// A ConvertVectorExpr record.\n  EXPR_CONVERT_VECTOR,\n\n  /// BlockExpr\n  EXPR_BLOCK,\n\n  /// A GenericSelectionExpr record.\n  EXPR_GENERIC_SELECTION,\n\n  /// A PseudoObjectExpr record.\n  EXPR_PSEUDO_OBJECT,\n\n  /// An AtomicExpr record.\n  EXPR_ATOMIC,\n\n  /// A RecoveryExpr record.\n  EXPR_RECOVERY,\n\n  // Objective-C\n\n  /// An ObjCStringLiteral record.\n  EXPR_OBJC_STRING_LITERAL,\n\n  EXPR_OBJC_BOXED_EXPRESSION,\n  EXPR_OBJC_ARRAY_LITERAL,\n  EXPR_OBJC_DICTIONARY_LITERAL,\n\n  /// An ObjCEncodeExpr record.\n  EXPR_OBJC_ENCODE,\n\n  /// An ObjCSelectorExpr record.\n  EXPR_OBJC_SELECTOR_EXPR,\n\n  /// An ObjCProtocolExpr record.\n  EXPR_OBJC_PROTOCOL_EXPR,\n\n  /// An ObjCIvarRefExpr record.\n  EXPR_OBJC_IVAR_REF_EXPR,\n\n  /// An ObjCPropertyRefExpr record.\n  EXPR_OBJC_PROPERTY_REF_EXPR,\n\n  /// An ObjCSubscriptRefExpr record.\n  EXPR_OBJC_SUBSCRIPT_REF_EXPR,\n\n  /// UNUSED\n  EXPR_OBJC_KVC_REF_EXPR,\n\n  /// An ObjCMessageExpr record.\n  EXPR_OBJC_MESSAGE_EXPR,\n\n  /// An ObjCIsa Expr record.\n  EXPR_OBJC_ISA,\n\n  /// An ObjCIndirectCopyRestoreExpr record.\n  EXPR_OBJC_INDIRECT_COPY_RESTORE,\n\n  /// An ObjCForCollectionStmt record.\n  STMT_OBJC_FOR_COLLECTION,\n\n  /// An ObjCAtCatchStmt record.\n  STMT_OBJC_CATCH,\n\n  /// An ObjCAtFinallyStmt record.\n  STMT_OBJC_FINALLY,\n\n  /// An ObjCAtTryStmt record.\n  STMT_OBJC_AT_TRY,\n\n  /// An ObjCAtSynchronizedStmt record.\n  STMT_OBJC_AT_SYNCHRONIZED,\n\n  /// An ObjCAtThrowStmt record.\n  STMT_OBJC_AT_THROW,\n\n  /// An ObjCAutoreleasePoolStmt record.\n  STMT_OBJC_AUTORELEASE_POOL,\n\n  /// An ObjCBoolLiteralExpr record.\n  EXPR_OBJC_BOOL_LITERAL,\n\n  /// An ObjCAvailabilityCheckExpr record.\n  EXPR_OBJC_AVAILABILITY_CHECK,\n\n  // C++\n\n  /// A CXXCatchStmt record.\n  STMT_CXX_CATCH,\n\n  /// A CXXTryStmt record.\n  STMT_CXX_TRY,\n  /// A CXXForRangeStmt record.\n\n  STMT_CXX_FOR_RANGE,\n\n  /// A CXXOperatorCallExpr record.\n  EXPR_CXX_OPERATOR_CALL,\n\n  /// A CXXMemberCallExpr record.\n  EXPR_CXX_MEMBER_CALL,\n\n  /// A CXXRewrittenBinaryOperator record.\n  EXPR_CXX_REWRITTEN_BINARY_OPERATOR,\n\n  /// A CXXConstructExpr record.\n  EXPR_CXX_CONSTRUCT,\n\n  /// A CXXInheritedCtorInitExpr record.\n  EXPR_CXX_INHERITED_CTOR_INIT,\n\n  /// A CXXTemporaryObjectExpr record.\n  EXPR_CXX_TEMPORARY_OBJECT,\n\n  /// A CXXStaticCastExpr record.\n  EXPR_CXX_STATIC_CAST,\n\n  /// A CXXDynamicCastExpr record.\n  EXPR_CXX_DYNAMIC_CAST,\n\n  /// A CXXReinterpretCastExpr record.\n  EXPR_CXX_REINTERPRET_CAST,\n\n  /// A CXXConstCastExpr record.\n  EXPR_CXX_CONST_CAST,\n\n  /// A CXXAddrspaceCastExpr record.\n  EXPR_CXX_ADDRSPACE_CAST,\n\n  /// A CXXFunctionalCastExpr record.\n  EXPR_CXX_FUNCTIONAL_CAST,\n\n  /// A BuiltinBitCastExpr record.\n  EXPR_BUILTIN_BIT_CAST,\n\n  /// A UserDefinedLiteral record.\n  EXPR_USER_DEFINED_LITERAL,\n\n  /// A CXXStdInitializerListExpr record.\n  EXPR_CXX_STD_INITIALIZER_LIST,\n\n  /// A CXXBoolLiteralExpr record.\n  EXPR_CXX_BOOL_LITERAL,\n\n  EXPR_CXX_NULL_PTR_LITERAL, // CXXNullPtrLiteralExpr\n  EXPR_CXX_TYPEID_EXPR,      // CXXTypeidExpr (of expr).\n  EXPR_CXX_TYPEID_TYPE,      // CXXTypeidExpr (of type).\n  EXPR_CXX_THIS,             // CXXThisExpr\n  EXPR_CXX_THROW,            // CXXThrowExpr\n  EXPR_CXX_DEFAULT_ARG,      // CXXDefaultArgExpr\n  EXPR_CXX_DEFAULT_INIT,     // CXXDefaultInitExpr\n  EXPR_CXX_BIND_TEMPORARY,   // CXXBindTemporaryExpr\n\n  EXPR_CXX_SCALAR_VALUE_INIT, // CXXScalarValueInitExpr\n  EXPR_CXX_NEW,               // CXXNewExpr\n  EXPR_CXX_DELETE,            // CXXDeleteExpr\n  EXPR_CXX_PSEUDO_DESTRUCTOR, // CXXPseudoDestructorExpr\n\n  EXPR_EXPR_WITH_CLEANUPS, // ExprWithCleanups\n\n  EXPR_CXX_DEPENDENT_SCOPE_MEMBER,   // CXXDependentScopeMemberExpr\n  EXPR_CXX_DEPENDENT_SCOPE_DECL_REF, // DependentScopeDeclRefExpr\n  EXPR_CXX_UNRESOLVED_CONSTRUCT,     // CXXUnresolvedConstructExpr\n  EXPR_CXX_UNRESOLVED_MEMBER,        // UnresolvedMemberExpr\n  EXPR_CXX_UNRESOLVED_LOOKUP,        // UnresolvedLookupExpr\n\n  EXPR_CXX_EXPRESSION_TRAIT, // ExpressionTraitExpr\n  EXPR_CXX_NOEXCEPT,         // CXXNoexceptExpr\n\n  EXPR_OPAQUE_VALUE,                // OpaqueValueExpr\n  EXPR_BINARY_CONDITIONAL_OPERATOR, // BinaryConditionalOperator\n  EXPR_TYPE_TRAIT,                  // TypeTraitExpr\n  EXPR_ARRAY_TYPE_TRAIT,            // ArrayTypeTraitIntExpr\n\n  EXPR_PACK_EXPANSION,                    // PackExpansionExpr\n  EXPR_SIZEOF_PACK,                       // SizeOfPackExpr\n  EXPR_SUBST_NON_TYPE_TEMPLATE_PARM,      // SubstNonTypeTemplateParmExpr\n  EXPR_SUBST_NON_TYPE_TEMPLATE_PARM_PACK, // SubstNonTypeTemplateParmPackExpr\n  EXPR_FUNCTION_PARM_PACK,                // FunctionParmPackExpr\n  EXPR_MATERIALIZE_TEMPORARY,             // MaterializeTemporaryExpr\n  EXPR_CXX_FOLD,                          // CXXFoldExpr\n  EXPR_CONCEPT_SPECIALIZATION,            // ConceptSpecializationExpr\n  EXPR_REQUIRES,                          // RequiresExpr\n\n  // CUDA\n  EXPR_CUDA_KERNEL_CALL, // CUDAKernelCallExpr\n\n  // OpenCL\n  EXPR_ASTYPE, // AsTypeExpr\n\n  // Microsoft\n  EXPR_CXX_PROPERTY_REF_EXPR,       // MSPropertyRefExpr\n  EXPR_CXX_PROPERTY_SUBSCRIPT_EXPR, // MSPropertySubscriptExpr\n  EXPR_CXX_UUIDOF_EXPR,             // CXXUuidofExpr (of expr).\n  EXPR_CXX_UUIDOF_TYPE,             // CXXUuidofExpr (of type).\n  STMT_SEH_LEAVE,                   // SEHLeaveStmt\n  STMT_SEH_EXCEPT,                  // SEHExceptStmt\n  STMT_SEH_FINALLY,                 // SEHFinallyStmt\n  STMT_SEH_TRY,                     // SEHTryStmt\n\n  // OpenMP directives\n  STMT_OMP_CANONICAL_LOOP,\n  STMT_OMP_PARALLEL_DIRECTIVE,\n  STMT_OMP_SIMD_DIRECTIVE,\n  STMT_OMP_TILE_DIRECTIVE,\n  STMT_OMP_FOR_DIRECTIVE,\n  STMT_OMP_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_SECTIONS_DIRECTIVE,\n  STMT_OMP_SECTION_DIRECTIVE,\n  STMT_OMP_SINGLE_DIRECTIVE,\n  STMT_OMP_MASTER_DIRECTIVE,\n  STMT_OMP_CRITICAL_DIRECTIVE,\n  STMT_OMP_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_DIRECTIVE,\n  STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE,\n  STMT_OMP_TASK_DIRECTIVE,\n  STMT_OMP_TASKYIELD_DIRECTIVE,\n  STMT_OMP_BARRIER_DIRECTIVE,\n  STMT_OMP_TASKWAIT_DIRECTIVE,\n  STMT_OMP_FLUSH_DIRECTIVE,\n  STMT_OMP_DEPOBJ_DIRECTIVE,\n  STMT_OMP_SCAN_DIRECTIVE,\n  STMT_OMP_ORDERED_DIRECTIVE,\n  STMT_OMP_ATOMIC_DIRECTIVE,\n  STMT_OMP_TARGET_DIRECTIVE,\n  STMT_OMP_TARGET_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_ENTER_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_EXIT_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TEAMS_DIRECTIVE,\n  STMT_OMP_TASKGROUP_DIRECTIVE,\n  STMT_OMP_CANCELLATION_POINT_DIRECTIVE,\n  STMT_OMP_CANCEL_DIRECTIVE,\n  STMT_OMP_TASKLOOP_DIRECTIVE,\n  STMT_OMP_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_MASTER_TASKLOOP_DIRECTIVE,\n  STMT_OMP_MASTER_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_TASKLOOP_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TARGET_UPDATE_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,\n  STMT_OMP_INTEROP_DIRECTIVE,\n  EXPR_OMP_ARRAY_SECTION,\n  EXPR_OMP_ARRAY_SHAPING,\n  EXPR_OMP_ITERATOR,\n\n  // ARC\n  EXPR_OBJC_BRIDGED_CAST, // ObjCBridgedCastExpr\n\n  STMT_MS_DEPENDENT_EXISTS, // MSDependentExistsStmt\n  EXPR_LAMBDA,              // LambdaExpr\n  STMT_COROUTINE_BODY,\n  STMT_CORETURN,\n  EXPR_COAWAIT,\n  EXPR_COYIELD,\n  EXPR_DEPENDENT_COAWAIT,\n\n  // FixedPointLiteral\n  EXPR_FIXEDPOINT_LITERAL,\n};\n\n/// The kinds of designators that can occur in a\n/// DesignatedInitExpr.\nenum DesignatorTypes {\n  /// Field designator where only the field name is known.\n  DESIG_FIELD_NAME = 0,\n\n  /// Field designator where the field has been resolved to\n  /// a declaration.\n  DESIG_FIELD_DECL = 1,\n\n  /// Array designator.\n  DESIG_ARRAY = 2,\n\n  /// GNU array range designator.\n  DESIG_ARRAY_RANGE = 3\n};\n\n/// The different kinds of data that can occur in a\n/// CtorInitializer.\nenum CtorInitializerType {\n  CTOR_INITIALIZER_BASE,\n  CTOR_INITIALIZER_DELEGATING,\n  CTOR_INITIALIZER_MEMBER,\n  CTOR_INITIALIZER_INDIRECT_MEMBER\n};\n\n/// Kinds of cleanup objects owned by ExprWithCleanups.\nenum CleanupObjectKind { COK_Block, COK_CompoundLiteral };\n\n/// Describes the redeclarations of a declaration.\nstruct LocalRedeclarationsInfo {\n  // The ID of the first declaration\n  DeclID FirstID;\n\n  // Offset into the array of redeclaration chains.\n  unsigned Offset;\n\n  friend bool operator<(const LocalRedeclarationsInfo &X,\n                        const LocalRedeclarationsInfo &Y) {\n    return X.FirstID < Y.FirstID;\n  }\n\n  friend bool operator>(const LocalRedeclarationsInfo &X,\n                        const LocalRedeclarationsInfo &Y) {\n    return X.FirstID > Y.FirstID;\n  }\n\n  friend bool operator<=(const LocalRedeclarationsInfo &X,\n                         const LocalRedeclarationsInfo &Y) {\n    return X.FirstID <= Y.FirstID;\n  }\n\n  friend bool operator>=(const LocalRedeclarationsInfo &X,\n                         const LocalRedeclarationsInfo &Y) {\n    return X.FirstID >= Y.FirstID;\n  }\n};\n\n/// Describes the categories of an Objective-C class.\nstruct ObjCCategoriesInfo {\n  // The ID of the definition\n  DeclID DefinitionID;\n\n  // Offset into the array of category lists.\n  unsigned Offset;\n\n  friend bool operator<(const ObjCCategoriesInfo &X,\n                        const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID < Y.DefinitionID;\n  }\n\n  friend bool operator>(const ObjCCategoriesInfo &X,\n                        const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID > Y.DefinitionID;\n  }\n\n  friend bool operator<=(const ObjCCategoriesInfo &X,\n                         const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID <= Y.DefinitionID;\n  }\n\n  friend bool operator>=(const ObjCCategoriesInfo &X,\n                         const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID >= Y.DefinitionID;\n  }\n};\n\n/// A key used when looking up entities by \\ref DeclarationName.\n///\n/// Different \\ref DeclarationNames are mapped to different keys, but the\n/// same key can occasionally represent multiple names (for names that\n/// contain types, in particular).\nclass DeclarationNameKey {\n  using NameKind = unsigned;\n\n  NameKind Kind = 0;\n  uint64_t Data = 0;\n\npublic:\n  DeclarationNameKey() = default;\n  DeclarationNameKey(DeclarationName Name);\n  DeclarationNameKey(NameKind Kind, uint64_t Data) : Kind(Kind), Data(Data) {}\n\n  NameKind getKind() const { return Kind; }\n\n  IdentifierInfo *getIdentifier() const {\n    assert(Kind == DeclarationName::Identifier ||\n           Kind == DeclarationName::CXXLiteralOperatorName ||\n           Kind == DeclarationName::CXXDeductionGuideName);\n    return (IdentifierInfo *)Data;\n  }\n\n  Selector getSelector() const {\n    assert(Kind == DeclarationName::ObjCZeroArgSelector ||\n           Kind == DeclarationName::ObjCOneArgSelector ||\n           Kind == DeclarationName::ObjCMultiArgSelector);\n    return Selector(Data);\n  }\n\n  OverloadedOperatorKind getOperatorKind() const {\n    assert(Kind == DeclarationName::CXXOperatorName);\n    return (OverloadedOperatorKind)Data;\n  }\n\n  /// Compute a fingerprint of this key for use in on-disk hash table.\n  unsigned getHash() const;\n\n  friend bool operator==(const DeclarationNameKey &A,\n                         const DeclarationNameKey &B) {\n    return A.Kind == B.Kind && A.Data == B.Data;\n  }\n};\n\n/// @}\n\n} // namespace serialization\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <> struct DenseMapInfo<clang::serialization::DeclarationNameKey> {\n  static clang::serialization::DeclarationNameKey getEmptyKey() {\n    return clang::serialization::DeclarationNameKey(-1, 1);\n  }\n\n  static clang::serialization::DeclarationNameKey getTombstoneKey() {\n    return clang::serialization::DeclarationNameKey(-1, 2);\n  }\n\n  static unsigned\n  getHashValue(const clang::serialization::DeclarationNameKey &Key) {\n    return Key.getHash();\n  }\n\n  static bool isEqual(const clang::serialization::DeclarationNameKey &L,\n                      const clang::serialization::DeclarationNameKey &R) {\n    return L == R;\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "content": "//===- CompilationDatabase.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides an interface and multiple implementations for\n//  CompilationDatabases.\n//\n//  While C++ refactoring and analysis tools are not compilers, and thus\n//  don't run as part of the build system, they need the exact information\n//  of a build in order to be able to correctly understand the C++ code of\n//  the project. This information is provided via the CompilationDatabase\n//  interface.\n//\n//  To create a CompilationDatabase from a build directory one can call\n//  CompilationDatabase::loadFromDirectory(), which deduces the correct\n//  compilation database from the root of the build tree.\n//\n//  See the concrete subclasses of CompilationDatabase for currently supported\n//  formats.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_COMPILATIONDATABASE_H\n#define LLVM_CLANG_TOOLING_COMPILATIONDATABASE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\nnamespace tooling {\n\n/// Specifies the working directory and command of a compilation.\nstruct CompileCommand {\n  CompileCommand() = default;\n  CompileCommand(const Twine &Directory, const Twine &Filename,\n                 std::vector<std::string> CommandLine, const Twine &Output)\n      : Directory(Directory.str()), Filename(Filename.str()),\n        CommandLine(std::move(CommandLine)), Output(Output.str()) {}\n\n  /// The working directory the command was executed from.\n  std::string Directory;\n\n  /// The source file associated with the command.\n  std::string Filename;\n\n  /// The command line that was executed.\n  std::vector<std::string> CommandLine;\n\n  /// The output file associated with the command.\n  std::string Output;\n\n  /// If this compile command was guessed rather than read from an authoritative\n  /// source, a short human-readable explanation.\n  /// e.g. \"inferred from foo/bar.h\".\n  std::string Heuristic;\n\n  friend bool operator==(const CompileCommand &LHS, const CompileCommand &RHS) {\n    return LHS.Directory == RHS.Directory && LHS.Filename == RHS.Filename &&\n           LHS.CommandLine == RHS.CommandLine && LHS.Output == RHS.Output &&\n           LHS.Heuristic == RHS.Heuristic;\n  }\n\n  friend bool operator!=(const CompileCommand &LHS, const CompileCommand &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n/// Interface for compilation databases.\n///\n/// A compilation database allows the user to retrieve compile command lines\n/// for the files in a project.\n///\n/// Many implementations are enumerable, allowing all command lines to be\n/// retrieved. These can be used to run clang tools over a subset of the files\n/// in a project.\nclass CompilationDatabase {\npublic:\n  virtual ~CompilationDatabase();\n\n  /// Loads a compilation database from a build directory.\n  ///\n  /// Looks at the specified 'BuildDirectory' and creates a compilation database\n  /// that allows to query compile commands for source files in the\n  /// corresponding source tree.\n  ///\n  /// Returns NULL and sets ErrorMessage if we were not able to build up a\n  /// compilation database for the build directory.\n  ///\n  /// FIXME: Currently only supports JSON compilation databases, which\n  /// are named 'compile_commands.json' in the given directory. Extend this\n  /// for other build types (like ninja build files).\n  static std::unique_ptr<CompilationDatabase>\n  loadFromDirectory(StringRef BuildDirectory, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in all parent paths of file 'SourceFile'\n  /// by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromSource(StringRef SourceFile, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in directory 'SourceDir' and all\n  /// its parent paths by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromDirectory(StringRef SourceDir, std::string &ErrorMessage);\n\n  /// Returns all compile commands in which the specified file was\n  /// compiled.\n  ///\n  /// This includes compile commands that span multiple source files.\n  /// For example, consider a project with the following compilations:\n  /// $ clang++ -o test a.cc b.cc t.cc\n  /// $ clang++ -o production a.cc b.cc -DPRODUCTION\n  /// A compilation database representing the project would return both command\n  /// lines for a.cc and b.cc and only the first command line for t.cc.\n  virtual std::vector<CompileCommand> getCompileCommands(\n      StringRef FilePath) const = 0;\n\n  /// Returns the list of all files available in the compilation database.\n  ///\n  /// By default, returns nothing. Implementations should override this if they\n  /// can enumerate their source files.\n  virtual std::vector<std::string> getAllFiles() const { return {}; }\n\n  /// Returns all compile commands for all the files in the compilation\n  /// database.\n  ///\n  /// FIXME: Add a layer in Tooling that provides an interface to run a tool\n  /// over all files in a compilation database. Not all build systems have the\n  /// ability to provide a feasible implementation for \\c getAllCompileCommands.\n  ///\n  /// By default, this is implemented in terms of getAllFiles() and\n  /// getCompileCommands(). Subclasses may override this for efficiency.\n  virtual std::vector<CompileCommand> getAllCompileCommands() const;\n};\n\n/// A compilation database that returns a single compile command line.\n///\n/// Useful when we want a tool to behave more like a compiler invocation.\n/// This compilation database is not enumerable: getAllFiles() returns {}.\nclass FixedCompilationDatabase : public CompilationDatabase {\npublic:\n  /// Creates a FixedCompilationDatabase from the arguments after \"--\".\n  ///\n  /// Parses the given command line for \"--\". If \"--\" is found, the rest of\n  /// the arguments will make up the command line in the returned\n  /// FixedCompilationDatabase.\n  /// The arguments after \"--\" must not include positional parameters or the\n  /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase\n  /// when a CompileCommand is requested. The argv[0] of the returned command\n  /// line will be \"clang-tool\".\n  ///\n  /// Returns NULL in case \"--\" is not found.\n  ///\n  /// The argument list is meant to be compatible with normal llvm command line\n  /// parsing in main methods.\n  /// int main(int argc, char **argv) {\n  ///   std::unique_ptr<FixedCompilationDatabase> Compilations(\n  ///     FixedCompilationDatabase::loadFromCommandLine(argc, argv));\n  ///   cl::ParseCommandLineOptions(argc, argv);\n  ///   ...\n  /// }\n  ///\n  /// \\param Argc The number of command line arguments - will be changed to\n  /// the number of arguments before \"--\", if \"--\" was found in the argument\n  /// list.\n  /// \\param Argv Points to the command line arguments.\n  /// \\param ErrorMsg Contains error text if the function returns null pointer.\n  /// \\param Directory The base directory used in the FixedCompilationDatabase.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromCommandLine(int &Argc, const char *const *Argv, std::string &ErrorMsg,\n                      const Twine &Directory = \".\");\n\n  /// Reads flags from the given file, one-per-line.\n  /// Returns nullptr and sets ErrorMessage if we can't read the file.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromFile(StringRef Path, std::string &ErrorMsg);\n\n  /// Reads flags from the given buffer, one-per-line.\n  /// Directory is the command CWD, typically the parent of compile_flags.txt.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromBuffer(StringRef Directory, StringRef Data, std::string &ErrorMsg);\n\n  /// Constructs a compilation data base from a specified directory\n  /// and command line.\n  FixedCompilationDatabase(const Twine &Directory,\n                           ArrayRef<std::string> CommandLine);\n\n  /// Returns the given compile command.\n  ///\n  /// Will always return a vector with one entry that contains the directory\n  /// and command line specified at construction with \"clang-tool\" as argv[0]\n  /// and 'FilePath' as positional argument.\n  std::vector<CompileCommand>\n  getCompileCommands(StringRef FilePath) const override;\n\nprivate:\n  /// This is built up to contain a single entry vector to be returned from\n  /// getCompileCommands after adding the positional argument.\n  std::vector<CompileCommand> CompileCommands;\n};\n\n/// Transforms a compile command so that it applies the same configuration to\n/// a different file. Most args are left intact, but tweaks may be needed\n/// to certain flags (-x, -std etc).\ntooling::CompileCommand transferCompileCommand(tooling::CompileCommand,\n                                               StringRef Filename);\n\n/// Returns a wrapped CompilationDatabase that defers to the provided one,\n/// but getCompileCommands() will infer commands for unknown files.\n/// The return value of getAllFiles() or getAllCompileCommands() is unchanged.\n/// See InterpolatingCompilationDatabase.cpp for details on heuristics.\nstd::unique_ptr<CompilationDatabase>\n    inferMissingCompileCommands(std::unique_ptr<CompilationDatabase>);\n\n/// Returns a wrapped CompilationDatabase that will add -target and -mode flags\n/// to commandline when they can be deduced from argv[0] of commandline returned\n/// by underlying database.\nstd::unique_ptr<CompilationDatabase>\ninferTargetAndDriverMode(std::unique_ptr<CompilationDatabase> Base);\n\n/// Returns a wrapped CompilationDatabase that will expand all rsp(response)\n/// files on commandline returned by underlying database.\nstd::unique_ptr<CompilationDatabase>\nexpandResponseFiles(std::unique_ptr<CompilationDatabase> Base,\n                    llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS);\n\n} // namespace tooling\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLING_COMPILATIONDATABASE_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h", "content": "//===--- IncludeStyle.h - Style of C++ #include directives -------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_INCLUSIONS_INCLUDESTYLE_H\n#define LLVM_CLANG_TOOLING_INCLUSIONS_INCLUDESTYLE_H\n\n#include \"llvm/Support/YAMLTraits.h\"\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace tooling {\n\n/// Style for sorting and grouping C++ #include directives.\nstruct IncludeStyle {\n  /// Styles for sorting multiple ``#include`` blocks.\n  enum IncludeBlocksStyle {\n    /// Sort each ``#include`` block separately.\n    /// \\code\n    ///    #include \"b.h\"               into      #include \"b.h\"\n    ///\n    ///    #include <lib/main.h>                  #include \"a.h\"\n    ///    #include \"a.h\"                         #include <lib/main.h>\n    /// \\endcode\n    IBS_Preserve,\n    /// Merge multiple ``#include`` blocks together and sort as one.\n    /// \\code\n    ///    #include \"b.h\"               into      #include \"a.h\"\n    ///                                           #include \"b.h\"\n    ///    #include <lib/main.h>                  #include <lib/main.h>\n    ///    #include \"a.h\"\n    /// \\endcode\n    IBS_Merge,\n    /// Merge multiple ``#include`` blocks together and sort as one.\n    /// Then split into groups based on category priority. See\n    /// ``IncludeCategories``.\n    /// \\code\n    ///    #include \"b.h\"               into      #include \"a.h\"\n    ///                                           #include \"b.h\"\n    ///    #include <lib/main.h>\n    ///    #include \"a.h\"                         #include <lib/main.h>\n    /// \\endcode\n    IBS_Regroup,\n  };\n\n  /// Dependent on the value, multiple ``#include`` blocks can be sorted\n  /// as one and divided based on category.\n  IncludeBlocksStyle IncludeBlocks;\n\n  /// See documentation of ``IncludeCategories``.\n  struct IncludeCategory {\n    /// The regular expression that this category matches.\n    std::string Regex;\n    /// The priority to assign to this category.\n    int Priority;\n    /// The custom priority to sort before grouping.\n    int SortPriority;\n    /// If the regular expression is case sensitive.\n    bool RegexIsCaseSensitive;\n    bool operator==(const IncludeCategory &Other) const {\n      return Regex == Other.Regex && Priority == Other.Priority &&\n             RegexIsCaseSensitive == Other.RegexIsCaseSensitive;\n    }\n  };\n\n  /// Regular expressions denoting the different ``#include`` categories\n  /// used for ordering ``#includes``.\n  ///\n  /// `POSIX extended\n  /// <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_\n  /// regular expressions are supported.\n  ///\n  /// These regular expressions are matched against the filename of an include\n  /// (including the <> or \"\") in order. The value belonging to the first\n  /// matching regular expression is assigned and ``#includes`` are sorted first\n  /// according to increasing category number and then alphabetically within\n  /// each category.\n  ///\n  /// If none of the regular expressions match, INT_MAX is assigned as\n  /// category. The main header for a source file automatically gets category 0.\n  /// so that it is generally kept at the beginning of the ``#includes``\n  /// (https://llvm.org/docs/CodingStandards.html#include-style). However, you\n  /// can also assign negative priorities if you have certain headers that\n  /// always need to be first.\n  ///\n  /// There is a third and optional field ``SortPriority`` which can used while\n  /// ``IncludeBlocks = IBS_Regroup`` to define the priority in which\n  /// ``#includes`` should be ordered. The value of ``Priority`` defines the\n  /// order of ``#include blocks`` and also allows the grouping of ``#includes``\n  /// of different priority. ``SortPriority`` is set to the value of\n  /// ``Priority`` as default if it is not assigned.\n  ///\n  /// Each regular expression can be marked as case sensitive with the field\n  /// ``CaseSensitive``, per default it is not.\n  ///\n  /// To configure this in the .clang-format file, use:\n  /// \\code{.yaml}\n  ///   IncludeCategories:\n  ///     - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n  ///       Priority:        2\n  ///       SortPriority:    2\n  ///       CaseSensitive:   true\n  ///     - Regex:           '^(<|\"(gtest|gmock|isl|json)/)'\n  ///       Priority:        3\n  ///     - Regex:           '<[[:alnum:].]+>'\n  ///       Priority:        4\n  ///     - Regex:           '.*'\n  ///       Priority:        1\n  ///       SortPriority:    0\n  /// \\endcode\n  std::vector<IncludeCategory> IncludeCategories;\n\n  /// Specify a regular expression of suffixes that are allowed in the\n  /// file-to-main-include mapping.\n  ///\n  /// When guessing whether a #include is the \"main\" include (to assign\n  /// category 0, see above), use this regex of allowed suffixes to the header\n  /// stem. A partial match is done, so that:\n  /// - \"\" means \"arbitrary suffix\"\n  /// - \"$\" means \"no suffix\"\n  ///\n  /// For example, if configured to \"(_test)?$\", then a header a.h would be seen\n  /// as the \"main\" include in both a.cc and a_test.cc.\n  std::string IncludeIsMainRegex;\n\n  /// Specify a regular expression for files being formatted\n  /// that are allowed to be considered \"main\" in the\n  /// file-to-main-include mapping.\n  ///\n  /// By default, clang-format considers files as \"main\" only when they end\n  /// with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``\n  /// extensions.\n  /// For these files a guessing of \"main\" include takes place\n  /// (to assign category 0, see above). This config option allows for\n  /// additional suffixes and extensions for files to be considered as \"main\".\n  ///\n  /// For example, if this option is configured to ``(Impl\\.hpp)$``,\n  /// then a file ``ClassImpl.hpp`` is considered \"main\" (in addition to\n  /// ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and \"main\n  /// include file\" logic will be executed (with *IncludeIsMainRegex* setting\n  /// also being respected in later phase). Without this option set,\n  /// ``ClassImpl.hpp`` would not have the main include file put on top\n  /// before any other include.\n  std::string IncludeIsMainSourceRegex;\n};\n\n} // namespace tooling\n} // namespace clang\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(clang::tooling::IncludeStyle::IncludeCategory)\n\nnamespace llvm {\nnamespace yaml {\n\ntemplate <>\nstruct MappingTraits<clang::tooling::IncludeStyle::IncludeCategory> {\n  static void mapping(IO &IO,\n                      clang::tooling::IncludeStyle::IncludeCategory &Category);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<\n    clang::tooling::IncludeStyle::IncludeBlocksStyle> {\n  static void\n  enumeration(IO &IO, clang::tooling::IncludeStyle::IncludeBlocksStyle &Value);\n};\n\n} // namespace yaml\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLING_INCLUSIONS_INCLUDESTYLE_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "content": "//===- Tokens.h - collect tokens from preprocessing --------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Record tokens that a preprocessor emits and define operations to map between\n// the tokens written in a file and tokens produced by the preprocessor.\n//\n// When running the compiler, there are two token streams we are interested in:\n//   - \"spelled\" tokens directly correspond to a substring written in some\n//     source file.\n//   - \"expanded\" tokens represent the result of preprocessing, parses consumes\n//     this token stream to produce the AST.\n//\n// Expanded tokens correspond directly to locations found in the AST, allowing\n// to find subranges of the token stream covered by various AST nodes. Spelled\n// tokens correspond directly to the source code written by the user.\n//\n// To allow composing these two use-cases, we also define operations that map\n// between expanded and spelled tokens that produced them (macro calls,\n// directives, etc).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_TOKENS_H\n#define LLVM_CLANG_TOOLING_SYNTAX_TOKENS_H\n\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Token.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <tuple>\n\nnamespace clang {\nclass Preprocessor;\n\nnamespace syntax {\n\n/// A half-open character range inside a particular file, the start offset is\n/// included and the end offset is excluded from the range.\nstruct FileRange {\n  /// EXPECTS: File.isValid() && Begin <= End.\n  FileRange(FileID File, unsigned BeginOffset, unsigned EndOffset);\n  /// EXPECTS: BeginLoc.isValid() && BeginLoc.isFileID().\n  FileRange(const SourceManager &SM, SourceLocation BeginLoc, unsigned Length);\n  /// EXPECTS: BeginLoc.isValid() && BeginLoc.isFileID(), Begin <= End and files\n  ///          are the same.\n  FileRange(const SourceManager &SM, SourceLocation BeginLoc,\n            SourceLocation EndLoc);\n\n  FileID file() const { return File; }\n  /// Start is a start offset (inclusive) in the corresponding file.\n  unsigned beginOffset() const { return Begin; }\n  /// End offset (exclusive) in the corresponding file.\n  unsigned endOffset() const { return End; }\n\n  unsigned length() const { return End - Begin; }\n\n  /// Check if \\p Offset is inside the range.\n  bool contains(unsigned Offset) const {\n    return Begin <= Offset && Offset < End;\n  }\n  /// Check \\p Offset is inside the range or equal to its endpoint.\n  bool touches(unsigned Offset) const {\n    return Begin <= Offset && Offset <= End;\n  }\n\n  /// Gets the substring that this FileRange refers to.\n  llvm::StringRef text(const SourceManager &SM) const;\n\n  /// Convert to the clang range. The returned range is always a char range,\n  /// never a token range.\n  CharSourceRange toCharRange(const SourceManager &SM) const;\n\n  friend bool operator==(const FileRange &L, const FileRange &R) {\n    return std::tie(L.File, L.Begin, L.End) == std::tie(R.File, R.Begin, R.End);\n  }\n  friend bool operator!=(const FileRange &L, const FileRange &R) {\n    return !(L == R);\n  }\n\nprivate:\n  FileID File;\n  unsigned Begin;\n  unsigned End;\n};\n\n/// For debugging purposes.\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const FileRange &R);\n\n/// A token coming directly from a file or from a macro invocation. Has just\n/// enough information to locate the token in the source code.\n/// Can represent both expanded and spelled tokens.\nclass Token {\npublic:\n  Token(SourceLocation Location, unsigned Length, tok::TokenKind Kind);\n  /// EXPECTS: clang::Token is not an annotation token.\n  explicit Token(const clang::Token &T);\n\n  tok::TokenKind kind() const { return Kind; }\n  /// Location of the first character of a token.\n  SourceLocation location() const { return Location; }\n  /// Location right after the last character of a token.\n  SourceLocation endLocation() const {\n    return Location.getLocWithOffset(Length);\n  }\n  unsigned length() const { return Length; }\n\n  /// Get the substring covered by the token. Note that will include all\n  /// digraphs, newline continuations, etc. E.g. tokens for 'int' and\n  ///    in\\\n  ///    t\n  /// both have the same kind tok::kw_int, but results of text() are different.\n  llvm::StringRef text(const SourceManager &SM) const;\n\n  /// Gets a range of this token.\n  /// EXPECTS: token comes from a file, not from a macro expansion.\n  FileRange range(const SourceManager &SM) const;\n\n  /// Given two tokens inside the same file, returns a file range that starts at\n  /// \\p First and ends at \\p Last.\n  /// EXPECTS: First and Last are file tokens from the same file, Last starts\n  ///          after First.\n  static FileRange range(const SourceManager &SM, const syntax::Token &First,\n                         const syntax::Token &Last);\n\n  std::string dumpForTests(const SourceManager &SM) const;\n  /// For debugging purposes.\n  std::string str() const;\n\nprivate:\n  SourceLocation Location;\n  unsigned Length;\n  tok::TokenKind Kind;\n};\n/// For debugging purposes. Equivalent to a call to Token::str().\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Token &T);\n\n/// A list of tokens obtained by preprocessing a text buffer and operations to\n/// map between the expanded and spelled tokens, i.e. TokenBuffer has\n/// information about two token streams:\n///    1. Expanded tokens: tokens produced by the preprocessor after all macro\n///       replacements,\n///    2. Spelled tokens: corresponding directly to the source code of a file\n///       before any macro replacements occurred.\n/// Here's an example to illustrate a difference between those two:\n///     #define FOO 10\n///     int a = FOO;\n///\n/// Spelled tokens are {'#','define','FOO','10','int','a','=','FOO',';'}.\n/// Expanded tokens are {'int','a','=','10',';','eof'}.\n///\n/// Note that the expanded token stream has a tok::eof token at the end, the\n/// spelled tokens never store a 'eof' token.\n///\n/// The full list expanded tokens can be obtained with expandedTokens(). Spelled\n/// tokens for each of the files can be obtained via spelledTokens(FileID).\n///\n/// To map between the expanded and spelled tokens use findSpelledByExpanded().\n///\n/// To build a token buffer use the TokenCollector class. You can also compute\n/// the spelled tokens of a file using the tokenize() helper.\n///\n/// FIXME: allow mappings into macro arguments.\nclass TokenBuffer {\npublic:\n  TokenBuffer(const SourceManager &SourceMgr) : SourceMgr(&SourceMgr) {}\n\n  TokenBuffer(TokenBuffer &&) = default;\n  TokenBuffer(const TokenBuffer &) = delete;\n  TokenBuffer &operator=(TokenBuffer &&) = default;\n  TokenBuffer &operator=(const TokenBuffer &) = delete;\n\n  /// All tokens produced by the preprocessor after all macro replacements,\n  /// directives, etc. Source locations found in the clang AST will always\n  /// point to one of these tokens.\n  /// Tokens are in TU order (per SourceManager::isBeforeInTranslationUnit()).\n  /// FIXME: figure out how to handle token splitting, e.g. '>>' can be split\n  ///        into two '>' tokens by the parser. However, TokenBuffer currently\n  ///        keeps it as a single '>>' token.\n  llvm::ArrayRef<syntax::Token> expandedTokens() const {\n    return ExpandedTokens;\n  }\n\n  /// Returns the subrange of expandedTokens() corresponding to the closed\n  /// token range R.\n  llvm::ArrayRef<syntax::Token> expandedTokens(SourceRange R) const;\n\n  /// Returns the subrange of spelled tokens corresponding to AST node spanning\n  /// \\p Expanded. This is the text that should be replaced if a refactoring\n  /// were to rewrite the node. If \\p Expanded is empty, the returned value is\n  /// llvm::None.\n  ///\n  /// Will fail if the expanded tokens do not correspond to a sequence of\n  /// spelled tokens. E.g. for the following example:\n  ///\n  ///   #define FIRST f1 f2 f3\n  ///   #define SECOND s1 s2 s3\n  ///   #define ID2(X, Y) X Y\n  ///\n  ///   a FIRST b SECOND c // expanded tokens are: a f1 f2 f3 b s1 s2 s3 c\n  ///   d ID2(e f g, h) i  // expanded tokens are: d e f g h i\n  ///\n  /// the results would be:\n  ///   expanded   => spelled\n  ///   ------------------------\n  ///            a => a\n  ///     s1 s2 s3 => SECOND\n  ///   a f1 f2 f3 => a FIRST\n  ///         a f1 => can't map\n  ///        s1 s2 => can't map\n  ///         e f  => e f\n  ///         g h  => can't map\n  ///\n  /// EXPECTS: \\p Expanded is a subrange of expandedTokens().\n  /// Complexity is logarithmic.\n  llvm::Optional<llvm::ArrayRef<syntax::Token>>\n  spelledForExpanded(llvm::ArrayRef<syntax::Token> Expanded) const;\n\n  /// Find the subranges of expanded tokens, corresponding to \\p Spelled.\n  ///\n  /// Some spelled tokens may not be present in the expanded token stream, so\n  /// this function can return an empty vector, e.g. for tokens of macro\n  /// directives or disabled preprocessor branches.\n  ///\n  /// Some spelled tokens can be duplicated in the expanded token stream\n  /// multiple times and this function will return multiple results in those\n  /// cases. This happens when \\p Spelled is inside a macro argument.\n  ///\n  /// FIXME: return correct results on macro arguments. For now, we return an\n  ///        empty list.\n  ///\n  /// (!) will return empty vector on tokens from #define body:\n  /// E.g. for the following example:\n  ///\n  ///   #define FIRST(A) f1 A = A f2\n  ///   #define SECOND s\n  ///\n  ///   a FIRST(arg) b SECOND c // expanded tokens are: a f1 arg = arg f2 b s\n  /// The results would be\n  ///   spelled           => expanded\n  ///   ------------------------\n  ///   #define FIRST     => {}\n  ///   a FIRST(arg)      => {a f1 arg = arg f2}\n  ///   arg               => {arg, arg} // arg #1 is before `=` and arg #2 is\n  ///                                   // after `=` in the expanded tokens.\n  llvm::SmallVector<llvm::ArrayRef<syntax::Token>, 1>\n  expandedForSpelled(llvm::ArrayRef<syntax::Token> Spelled) const;\n\n  /// An expansion produced by the preprocessor, includes macro expansions and\n  /// preprocessor directives. Preprocessor always maps a non-empty range of\n  /// spelled tokens to a (possibly empty) range of expanded tokens. Here is a\n  /// few examples of expansions:\n  ///    #pragma once      // Expands to an empty range.\n  ///    #define FOO 1 2 3 // Expands an empty range.\n  ///    FOO               // Expands to \"1 2 3\".\n  /// FIXME(ibiryukov): implement this, currently #include expansions are empty.\n  ///    #include <vector> // Expands to tokens produced by the include.\n  struct Expansion {\n    llvm::ArrayRef<syntax::Token> Spelled;\n    llvm::ArrayRef<syntax::Token> Expanded;\n  };\n  /// If \\p Spelled starts a mapping (e.g. if it's a macro name or '#' starting\n  /// a preprocessor directive) return the subrange of expanded tokens that the\n  /// macro expands to.\n  llvm::Optional<Expansion>\n  expansionStartingAt(const syntax::Token *Spelled) const;\n  /// Returns all expansions (partially) expanded from the specified tokens.\n  /// This is the expansions whose Spelled range intersects \\p Spelled.\n  std::vector<Expansion>\n  expansionsOverlapping(llvm::ArrayRef<syntax::Token> Spelled) const;\n\n  /// Lexed tokens of a file before preprocessing. E.g. for the following input\n  ///     #define DECL(name) int name = 10\n  ///     DECL(a);\n  /// spelledTokens() returns\n  ///    {\"#\", \"define\", \"DECL\", \"(\", \"name\", \")\", \"int\", \"name\", \"=\", \"10\",\n  ///     \"DECL\", \"(\", \"a\", \")\", \";\"}\n  llvm::ArrayRef<syntax::Token> spelledTokens(FileID FID) const;\n\n  /// Returns the spelled Token starting at Loc, if there are no such tokens\n  /// returns nullptr.\n  const syntax::Token *spelledTokenAt(SourceLocation Loc) const;\n\n  /// Get all tokens that expand a macro in \\p FID. For the following input\n  ///     #define FOO B\n  ///     #define FOO2(X) int X\n  ///     FOO2(XY)\n  ///     int B;\n  ///     FOO;\n  /// macroExpansions() returns {\"FOO2\", \"FOO\"} (from line 3 and 5\n  /// respecitvely).\n  std::vector<const syntax::Token *> macroExpansions(FileID FID) const;\n\n  const SourceManager &sourceManager() const { return *SourceMgr; }\n\n  std::string dumpForTests() const;\n\nprivate:\n  /// Describes a mapping between a continuous subrange of spelled tokens and\n  /// expanded tokens. Represents macro expansions, preprocessor directives,\n  /// conditionally disabled pp regions, etc.\n  ///   #define FOO 1+2\n  ///   #define BAR(a) a + 1\n  ///   FOO    // invocation #1, tokens = {'1','+','2'}, macroTokens = {'FOO'}.\n  ///   BAR(1) // invocation #2, tokens = {'a', '+', '1'},\n  ///                            macroTokens = {'BAR', '(', '1', ')'}.\n  struct Mapping {\n    // Positions in the corresponding spelled token stream. The corresponding\n    // range is never empty.\n    unsigned BeginSpelled = 0;\n    unsigned EndSpelled = 0;\n    // Positions in the expanded token stream. The corresponding range can be\n    // empty.\n    unsigned BeginExpanded = 0;\n    unsigned EndExpanded = 0;\n\n    /// For debugging purposes.\n    std::string str() const;\n  };\n  /// Spelled tokens of the file with information about the subranges.\n  struct MarkedFile {\n    /// Lexed, but not preprocessed, tokens of the file. These map directly to\n    /// text in the corresponding files and include tokens of all preprocessor\n    /// directives.\n    /// FIXME: spelled tokens don't change across FileID that map to the same\n    ///        FileEntry. We could consider deduplicating them to save memory.\n    std::vector<syntax::Token> SpelledTokens;\n    /// A sorted list to convert between the spelled and expanded token streams.\n    std::vector<Mapping> Mappings;\n    /// The first expanded token produced for this FileID.\n    unsigned BeginExpanded = 0;\n    unsigned EndExpanded = 0;\n  };\n\n  friend class TokenCollector;\n\n  /// Maps a single expanded token to its spelled counterpart or a mapping that\n  /// produced it.\n  std::pair<const syntax::Token *, const Mapping *>\n  spelledForExpandedToken(const syntax::Token *Expanded) const;\n\n  /// Returns a mapping starting before \\p Spelled token, or nullptr if no\n  /// such mapping exists.\n  static const Mapping *\n  mappingStartingBeforeSpelled(const MarkedFile &F,\n                               const syntax::Token *Spelled);\n\n  /// Convert a private Mapping to a public Expansion.\n  Expansion makeExpansion(const MarkedFile &, const Mapping &) const;\n  /// Returns the file that the Spelled tokens are taken from.\n  /// Asserts that they are non-empty, from a tracked file, and in-bounds.\n  const MarkedFile &fileForSpelled(llvm::ArrayRef<syntax::Token> Spelled) const;\n\n  /// Token stream produced after preprocessing, conceputally this captures the\n  /// same stream as 'clang -E' (excluding the preprocessor directives like\n  /// #file, etc.).\n  std::vector<syntax::Token> ExpandedTokens;\n  llvm::DenseMap<FileID, MarkedFile> Files;\n  // The value is never null, pointer instead of reference to avoid disabling\n  // implicit assignment operator.\n  const SourceManager *SourceMgr;\n};\n\n/// The spelled tokens that overlap or touch a spelling location Loc.\n/// This always returns 0-2 tokens.\nllvm::ArrayRef<syntax::Token>\nspelledTokensTouching(SourceLocation Loc, const syntax::TokenBuffer &Tokens);\nllvm::ArrayRef<syntax::Token>\nspelledTokensTouching(SourceLocation Loc, llvm::ArrayRef<syntax::Token> Tokens);\n\n/// The identifier token that overlaps or touches a spelling location Loc.\n/// If there is none, returns nullptr.\nconst syntax::Token *\nspelledIdentifierTouching(SourceLocation Loc,\n                          llvm::ArrayRef<syntax::Token> Tokens);\nconst syntax::Token *\nspelledIdentifierTouching(SourceLocation Loc,\n                          const syntax::TokenBuffer &Tokens);\n\n/// Lex the text buffer, corresponding to \\p FID, in raw mode and record the\n/// resulting spelled tokens. Does minimal post-processing on raw identifiers,\n/// setting the appropriate token kind (instead of the raw_identifier reported\n/// by lexer in raw mode). This is a very low-level function, most users should\n/// prefer to use TokenCollector. Lexing in raw mode produces wildly different\n/// results from what one might expect when running a C++ frontend, e.g.\n/// preprocessor does not run at all.\n/// The result will *not* have a 'eof' token at the end.\nstd::vector<syntax::Token> tokenize(FileID FID, const SourceManager &SM,\n                                    const LangOptions &LO);\n/// Similar to one above, instead of whole file tokenizes a part of it. Note\n/// that, the first token might be incomplete if FR.startOffset is not at the\n/// beginning of a token, and the last token returned will start before the\n/// FR.endOffset but might end after it.\nstd::vector<syntax::Token>\ntokenize(const FileRange &FR, const SourceManager &SM, const LangOptions &LO);\n\n/// Collects tokens for the main file while running the frontend action. An\n/// instance of this object should be created on\n/// FrontendAction::BeginSourceFile() and the results should be consumed after\n/// FrontendAction::Execute() finishes.\nclass TokenCollector {\npublic:\n  /// Adds the hooks to collect the tokens. Should be called before the\n  /// preprocessing starts, i.e. as a part of BeginSourceFile() or\n  /// CreateASTConsumer().\n  TokenCollector(Preprocessor &P);\n\n  /// Finalizes token collection. Should be called after preprocessing is\n  /// finished, i.e. after running Execute().\n  LLVM_NODISCARD TokenBuffer consume() &&;\n\nprivate:\n  /// Maps from a start to an end spelling location of transformations\n  /// performed by the preprocessor. These include:\n  ///   1. range from '#' to the last token in the line for PP directives,\n  ///   2. macro name and arguments for macro expansions.\n  /// Note that we record only top-level macro expansions, intermediate\n  /// expansions (e.g. inside macro arguments) are ignored.\n  ///\n  /// Used to find correct boundaries of macro calls and directives when\n  /// building mappings from spelled to expanded tokens.\n  ///\n  /// Logically, at each point of the preprocessor execution there is a stack of\n  /// macro expansions being processed and we could use it to recover the\n  /// location information we need. However, the public preprocessor API only\n  /// exposes the points when macro expansions start (when we push a macro onto\n  /// the stack) and not when they end (when we pop a macro from the stack).\n  /// To workaround this limitation, we rely on source location information\n  /// stored in this map.\n  using PPExpansions = llvm::DenseMap<SourceLocation, SourceLocation>;\n  class Builder;\n  class CollectPPExpansions;\n\n  std::vector<syntax::Token> Expanded;\n  // FIXME: we only store macro expansions, also add directives(#pragma, etc.)\n  PPExpansions Expansions;\n  Preprocessor &PP;\n  CollectPPExpansions *Collector;\n};\n\n} // namespace syntax\n} // namespace clang\n\n#endif\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "content": "//===- Tree.h - structure of the syntax tree ------------------*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Defines the basic structure of the syntax tree. There are two kinds of nodes:\n//   - leaf nodes correspond to a token in the expanded token stream,\n//   - tree nodes correspond to language grammar constructs.\n//\n// The tree is initially built from an AST. Each node of a newly built tree\n// covers a continous subrange of expanded tokens (i.e. tokens after\n// preprocessing), the specific tokens coverered are stored in the leaf nodes of\n// a tree. A post-order traversal of a tree will visit leaf nodes in an order\n// corresponding the original order of expanded tokens.\n//\n// This is still work in progress and highly experimental, we leave room for\n// ourselves to completely change the design and/or implementation.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n#define LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cstdint>\n#include <iterator>\n\nnamespace clang {\nnamespace syntax {\n\n/// A memory arena for syntax trees. Also tracks the underlying token buffers,\n/// source manager, etc.\nclass Arena {\npublic:\n  Arena(SourceManager &SourceMgr, const LangOptions &LangOpts,\n        const TokenBuffer &Tokens);\n\n  const SourceManager &getSourceManager() const { return SourceMgr; }\n  const LangOptions &getLangOptions() const { return LangOpts; }\n\n  const TokenBuffer &getTokenBuffer() const;\n  llvm::BumpPtrAllocator &getAllocator() { return Allocator; }\n\nprivate:\n  /// Add \\p Buffer to the underlying source manager, tokenize it and store the\n  /// resulting tokens. Used exclusively in `FactoryImpl` to materialize tokens\n  /// that were not written in user code.\n  std::pair<FileID, ArrayRef<Token>>\n  lexBuffer(std::unique_ptr<llvm::MemoryBuffer> Buffer);\n  friend class FactoryImpl;\n\nprivate:\n  SourceManager &SourceMgr;\n  const LangOptions &LangOpts;\n  const TokenBuffer &Tokens;\n  /// IDs and storage for additional tokenized files.\n  llvm::DenseMap<FileID, std::vector<Token>> ExtraTokens;\n  /// Keeps all the allocated nodes and their intermediate data structures.\n  llvm::BumpPtrAllocator Allocator;\n};\n\nclass Tree;\nclass TreeBuilder;\nclass FactoryImpl;\nclass MutationsImpl;\n\nenum class NodeKind : uint16_t;\nenum class NodeRole : uint8_t;\n\n/// A node in a syntax tree. Each node is either a Leaf (representing tokens) or\n/// a Tree (representing language constructrs).\nclass Node {\nprotected:\n  /// Newly created nodes are detached from a tree, parent and sibling links are\n  /// set when the node is added as a child to another one.\n  Node(NodeKind Kind);\n  /// Nodes are allocated on Arenas; the destructor is never called.\n  ~Node() = default;\n\npublic:\n  /// Nodes cannot simply be copied without violating tree invariants.\n  Node(const Node &) = delete;\n  Node &operator=(const Node &) = delete;\n  /// Idiomatically, nodes are allocated on an Arena and never moved.\n  Node(Node &&) = delete;\n  Node &operator=(Node &&) = delete;\n\n  NodeKind getKind() const { return static_cast<NodeKind>(Kind); }\n  NodeRole getRole() const { return static_cast<NodeRole>(Role); }\n\n  /// Whether the node is detached from a tree, i.e. does not have a parent.\n  bool isDetached() const;\n  /// Whether the node was created from the AST backed by the source code\n  /// rather than added later through mutation APIs or created with factory\n  /// functions.\n  /// When this flag is true, all subtrees are also original.\n  /// This flag is set to false on any modifications to the node or any of its\n  /// subtrees, even if this simply involves swapping existing subtrees.\n  bool isOriginal() const { return Original; }\n  /// If this function return false, the tree cannot be modified because there\n  /// is no reasonable way to produce the corresponding textual replacements.\n  /// This can happen when the node crosses macro expansion boundaries.\n  ///\n  /// Note that even if the node is not modifiable, its child nodes can be\n  /// modifiable.\n  bool canModify() const { return CanModify; }\n\n  const Tree *getParent() const { return Parent; }\n  Tree *getParent() { return Parent; }\n\n  const Node *getNextSibling() const { return NextSibling; }\n  Node *getNextSibling() { return NextSibling; }\n  const Node *getPreviousSibling() const { return PreviousSibling; }\n  Node *getPreviousSibling() { return PreviousSibling; }\n\n  /// Dumps the structure of a subtree. For debugging and testing purposes.\n  std::string dump(const SourceManager &SM) const;\n  /// Dumps the tokens forming this subtree.\n  std::string dumpTokens(const SourceManager &SM) const;\n\n  /// Asserts invariants on this node of the tree and its immediate children.\n  /// Will not recurse into the subtree. No-op if NDEBUG is set.\n  void assertInvariants() const;\n  /// Runs checkInvariants on all nodes in the subtree. No-op if NDEBUG is set.\n  void assertInvariantsRecursive() const;\n\nprivate:\n  // Tree is allowed to change the Parent link and Role.\n  friend class Tree;\n  // TreeBuilder is allowed to set the Original and CanModify flags.\n  friend class TreeBuilder;\n  // MutationsImpl sets roles and CanModify flag.\n  friend class MutationsImpl;\n  // FactoryImpl sets CanModify flag.\n  friend class FactoryImpl;\n\n  void setRole(NodeRole NR);\n\n  Tree *Parent;\n  Node *NextSibling;\n  Node *PreviousSibling;\n  unsigned Kind : 16;\n  unsigned Role : 8;\n  unsigned Original : 1;\n  unsigned CanModify : 1;\n};\n\n/// A leaf node points to a single token inside the expanded token stream.\nclass Leaf final : public Node {\npublic:\n  Leaf(const Token *T);\n  static bool classof(const Node *N);\n\n  const Token *getToken() const { return Tok; }\n\nprivate:\n  const Token *Tok;\n};\n\n/// A node that has children and represents a syntactic language construct.\nclass Tree : public Node {\n  /// Iterator over children (common base for const/non-const).\n  /// Not invalidated by tree mutations (holds a stable node pointer).\n  template <typename DerivedT, typename NodeT>\n  class ChildIteratorBase\n      : public llvm::iterator_facade_base<DerivedT, std::forward_iterator_tag,\n                                          NodeT> {\n  protected:\n    NodeT *N = nullptr;\n    using Base = ChildIteratorBase;\n\n  public:\n    ChildIteratorBase() = default;\n    explicit ChildIteratorBase(NodeT *N) : N(N) {}\n\n    bool operator==(const DerivedT &O) const { return O.N == N; }\n    NodeT &operator*() const { return *N; }\n    DerivedT &operator++() {\n      N = N->getNextSibling();\n      return *static_cast<DerivedT *>(this);\n    }\n\n    /// Truthy if valid (not past-the-end).\n    /// This allows: if (auto It = find_if(N.children(), ...) )\n    explicit operator bool() const { return N != nullptr; }\n    /// The element, or nullptr if past-the-end.\n    NodeT *asPointer() const { return N; }\n  };\n\npublic:\n  static bool classof(const Node *N);\n\n  Node *getFirstChild() { return FirstChild; }\n  const Node *getFirstChild() const { return FirstChild; }\n  Node *getLastChild() { return LastChild; }\n  const Node *getLastChild() const { return LastChild; }\n\n  const Leaf *findFirstLeaf() const;\n  Leaf *findFirstLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findFirstLeaf());\n  }\n\n  const Leaf *findLastLeaf() const;\n  Leaf *findLastLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findLastLeaf());\n  }\n\n  /// child_iterator is not invalidated by mutations.\n  struct ChildIterator : ChildIteratorBase<ChildIterator, Node> {\n    using Base::ChildIteratorBase;\n  };\n  struct ConstChildIterator\n      : ChildIteratorBase<ConstChildIterator, const Node> {\n    using Base::ChildIteratorBase;\n    ConstChildIterator() = default;\n    ConstChildIterator(const ChildIterator &I) : Base(I.asPointer()) {}\n  };\n\n  llvm::iterator_range<ChildIterator> getChildren() {\n    return {ChildIterator(getFirstChild()), ChildIterator()};\n  }\n  llvm::iterator_range<ConstChildIterator> getChildren() const {\n    return {ConstChildIterator(getFirstChild()), ConstChildIterator()};\n  }\n\n  /// Find the first node with a corresponding role.\n  const Node *findChild(NodeRole R) const;\n  Node *findChild(NodeRole R) {\n    return const_cast<Node *>(const_cast<const Tree *>(this)->findChild(R));\n  }\n\nprotected:\n  using Node::Node;\n\nprivate:\n  /// Append \\p Child to the list of children and sets the parent pointer.\n  /// A very low-level operation that does not check any invariants, only used\n  /// by TreeBuilder and FactoryImpl.\n  /// EXPECTS: Role != Detached.\n  void appendChildLowLevel(Node *Child, NodeRole Role);\n  /// Similar but prepends.\n  void prependChildLowLevel(Node *Child, NodeRole Role);\n\n  /// Like the previous overloads, but does not set role for \\p Child.\n  /// EXPECTS: Child->Role != Detached\n  void appendChildLowLevel(Node *Child);\n  void prependChildLowLevel(Node *Child);\n  friend class TreeBuilder;\n  friend class FactoryImpl;\n\n  /// Replace a range of children [Begin, End) with a list of\n  /// new nodes starting at \\p New.\n  /// Only used by MutationsImpl to implement higher-level mutation operations.\n  /// (!) \\p New can be null to model removal of the child range.\n  /// (!) \\p End can be null to model one past the end.\n  /// (!) \\p Begin can be null to model an append.\n  void replaceChildRangeLowLevel(Node *Begin, Node *End, Node *New);\n  friend class MutationsImpl;\n\n  Node *FirstChild = nullptr;\n  Node *LastChild = nullptr;\n};\n\n// Provide missing non_const == const overload.\n// iterator_facade_base requires == to be a member, but implicit conversions\n// don't work on the LHS of a member operator.\ninline bool operator==(const Tree::ConstChildIterator &A,\n                       const Tree::ConstChildIterator &B) {\n  return A.operator==(B);\n}\n\n/// A list of Elements separated or terminated by a fixed token.\n///\n/// This type models the following grammar construct:\n/// delimited-list(element, delimiter, termination, canBeEmpty)\nclass List : public Tree {\npublic:\n  template <typename Element> struct ElementAndDelimiter {\n    Element *element;\n    Leaf *delimiter;\n  };\n\n  enum class TerminationKind {\n    Terminated,\n    MaybeTerminated,\n    Separated,\n  };\n\n  using Tree::Tree;\n  static bool classof(const Node *N);\n  /// Returns the elements and corresponding delimiters. Missing elements\n  /// and delimiters are represented as null pointers.\n  ///\n  /// For example, in a separated list:\n  /// \"a, b, c\"  <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (\"c\" , null)]\n  /// \"a,  , c\"  <=> [(\"a\" , \",\"), (null, \",\" ), (\"c\" , null)]\n  /// \"a, b  c\"  <=> [(\"a\" , \",\"), (\"b\" , null), (\"c\" , null)]\n  /// \"a, b,\"    <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (null, null)]\n  ///\n  /// In a terminated or maybe-terminated list:\n  /// \"a; b; c;\" <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , \";\" )]\n  /// \"a;  ; c;\" <=> [(\"a\" , \";\"), (null, \";\" ), (\"c\" , \";\" )]\n  /// \"a; b  c;\" <=> [(\"a\" , \";\"), (\"b\" , null), (\"c\" , \";\" )]\n  /// \"a; b; c\"  <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , null)]\n  std::vector<ElementAndDelimiter<Node>> getElementsAsNodesAndDelimiters();\n\n  /// Returns the elements of the list. Missing elements are represented\n  /// as null pointers in the same way as in the return value of\n  /// `getElementsAsNodesAndDelimiters()`.\n  std::vector<Node *> getElementsAsNodes();\n\n  // These can't be implemented with the information we have!\n\n  /// Returns the appropriate delimiter for this list.\n  ///\n  /// Useful for discovering the correct delimiter to use when adding\n  /// elements to empty or one-element lists.\n  clang::tok::TokenKind getDelimiterTokenKind() const;\n\n  TerminationKind getTerminationKind() const;\n\n  /// Whether this list can be empty in syntactically and semantically correct\n  /// code.\n  ///\n  /// This list may be empty when the source code has errors even if\n  /// canBeEmpty() returns false.\n  bool canBeEmpty() const;\n};\n\n} // namespace syntax\n} // namespace clang\n\n#endif\n"}, "75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "content": "//===--- JSON.h - JSON values, parsing and serialization -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===---------------------------------------------------------------------===//\n///\n/// \\file\n/// This file supports working with JSON data.\n///\n/// It comprises:\n///\n/// - classes which hold dynamically-typed parsed JSON structures\n///   These are value types that can be composed, inspected, and modified.\n///   See json::Value, and the related types json::Object and json::Array.\n///\n/// - functions to parse JSON text into Values, and to serialize Values to text.\n///   See parse(), operator<<, and format_provider.\n///\n/// - a convention and helpers for mapping between json::Value and user-defined\n///   types. See fromJSON(), ObjectMapper, and the class comment on Value.\n///\n/// - an output API json::OStream which can emit JSON without materializing\n///   all structures as json::Value.\n///\n/// Typically, JSON data would be read from an external source, parsed into\n/// a Value, and then converted into some native data structure before doing\n/// real work on it. (And vice versa when writing).\n///\n/// Other serialization mechanisms you may consider:\n///\n/// - YAML is also text-based, and more human-readable than JSON. It's a more\n///   complex format and data model, and YAML parsers aren't ubiquitous.\n///   YAMLParser.h is a streaming parser suitable for parsing large documents\n///   (including JSON, as YAML is a superset). It can be awkward to use\n///   directly. YAML I/O (YAMLTraits.h) provides data mapping that is more\n///   declarative than the toJSON/fromJSON conventions here.\n///\n/// - LLVM bitstream is a space- and CPU- efficient binary format. Typically it\n///   encodes LLVM IR (\"bitcode\"), but it can be a container for other data.\n///   Low-level reader/writer libraries are in Bitstream/Bitstream*.h\n///\n//===---------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_JSON_H\n#define LLVM_SUPPORT_JSON_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <map>\n\nnamespace llvm {\nnamespace json {\n\n// === String encodings ===\n//\n// JSON strings are character sequences (not byte sequences like std::string).\n// We need to know the encoding, and for simplicity only support UTF-8.\n//\n//   - When parsing, invalid UTF-8 is a syntax error like any other\n//\n//   - When creating Values from strings, callers must ensure they are UTF-8.\n//        with asserts on, invalid UTF-8 will crash the program\n//        with asserts off, we'll substitute the replacement character (U+FFFD)\n//     Callers can use json::isUTF8() and json::fixUTF8() for validation.\n//\n//   - When retrieving strings from Values (e.g. asString()), the result will\n//     always be valid UTF-8.\n\n/// Returns true if \\p S is valid UTF-8, which is required for use as JSON.\n/// If it returns false, \\p Offset is set to a byte offset near the first error.\nbool isUTF8(llvm::StringRef S, size_t *ErrOffset = nullptr);\n/// Replaces invalid UTF-8 sequences in \\p S with the replacement character\n/// (U+FFFD). The returned string is valid UTF-8.\n/// This is much slower than isUTF8, so test that first.\nstd::string fixUTF8(llvm::StringRef S);\n\nclass Array;\nclass ObjectKey;\nclass Value;\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt);\n\n/// An Object is a JSON object, which maps strings to heterogenous JSON values.\n/// It simulates DenseMap<ObjectKey, Value>. ObjectKey is a maybe-owned string.\nclass Object {\n  using Storage = DenseMap<ObjectKey, Value, llvm::DenseMapInfo<StringRef>>;\n  Storage M;\n\npublic:\n  using key_type = ObjectKey;\n  using mapped_type = Value;\n  using value_type = Storage::value_type;\n  using iterator = Storage::iterator;\n  using const_iterator = Storage::const_iterator;\n\n  Object() = default;\n  // KV is a trivial key-value struct for list-initialization.\n  // (using std::pair forces extra copies).\n  struct KV;\n  explicit Object(std::initializer_list<KV> Properties);\n\n  iterator begin() { return M.begin(); }\n  const_iterator begin() const { return M.begin(); }\n  iterator end() { return M.end(); }\n  const_iterator end() const { return M.end(); }\n\n  bool empty() const { return M.empty(); }\n  size_t size() const { return M.size(); }\n\n  void clear() { M.clear(); }\n  std::pair<iterator, bool> insert(KV E);\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const ObjectKey &K, Ts &&... Args) {\n    return M.try_emplace(K, std::forward<Ts>(Args)...);\n  }\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(ObjectKey &&K, Ts &&... Args) {\n    return M.try_emplace(std::move(K), std::forward<Ts>(Args)...);\n  }\n  bool erase(StringRef K);\n  void erase(iterator I) { M.erase(I); }\n\n  iterator find(StringRef K) { return M.find_as(K); }\n  const_iterator find(StringRef K) const { return M.find_as(K); }\n  // operator[] acts as if Value was default-constructible as null.\n  Value &operator[](const ObjectKey &K);\n  Value &operator[](ObjectKey &&K);\n  // Look up a property, returning nullptr if it doesn't exist.\n  Value *get(StringRef K);\n  const Value *get(StringRef K) const;\n  // Typed accessors return None/nullptr if\n  //   - the property doesn't exist\n  //   - or it has the wrong type\n  llvm::Optional<std::nullptr_t> getNull(StringRef K) const;\n  llvm::Optional<bool> getBoolean(StringRef K) const;\n  llvm::Optional<double> getNumber(StringRef K) const;\n  llvm::Optional<int64_t> getInteger(StringRef K) const;\n  llvm::Optional<llvm::StringRef> getString(StringRef K) const;\n  const json::Object *getObject(StringRef K) const;\n  json::Object *getObject(StringRef K);\n  const json::Array *getArray(StringRef K) const;\n  json::Array *getArray(StringRef K);\n};\nbool operator==(const Object &LHS, const Object &RHS);\ninline bool operator!=(const Object &LHS, const Object &RHS) {\n  return !(LHS == RHS);\n}\n\n/// An Array is a JSON array, which contains heterogeneous JSON values.\n/// It simulates std::vector<Value>.\nclass Array {\n  std::vector<Value> V;\n\npublic:\n  using value_type = Value;\n  using iterator = std::vector<Value>::iterator;\n  using const_iterator = std::vector<Value>::const_iterator;\n\n  Array() = default;\n  explicit Array(std::initializer_list<Value> Elements);\n  template <typename Collection> explicit Array(const Collection &C) {\n    for (const auto &V : C)\n      emplace_back(V);\n  }\n\n  Value &operator[](size_t I) { return V[I]; }\n  const Value &operator[](size_t I) const { return V[I]; }\n  Value &front() { return V.front(); }\n  const Value &front() const { return V.front(); }\n  Value &back() { return V.back(); }\n  const Value &back() const { return V.back(); }\n  Value *data() { return V.data(); }\n  const Value *data() const { return V.data(); }\n\n  iterator begin() { return V.begin(); }\n  const_iterator begin() const { return V.begin(); }\n  iterator end() { return V.end(); }\n  const_iterator end() const { return V.end(); }\n\n  bool empty() const { return V.empty(); }\n  size_t size() const { return V.size(); }\n  void reserve(size_t S) { V.reserve(S); }\n\n  void clear() { V.clear(); }\n  void push_back(const Value &E) { V.push_back(E); }\n  void push_back(Value &&E) { V.push_back(std::move(E)); }\n  template <typename... Args> void emplace_back(Args &&... A) {\n    V.emplace_back(std::forward<Args>(A)...);\n  }\n  void pop_back() { V.pop_back(); }\n  // FIXME: insert() takes const_iterator since C++11, old libstdc++ disagrees.\n  iterator insert(iterator P, const Value &E) { return V.insert(P, E); }\n  iterator insert(iterator P, Value &&E) {\n    return V.insert(P, std::move(E));\n  }\n  template <typename It> iterator insert(iterator P, It A, It Z) {\n    return V.insert(P, A, Z);\n  }\n  template <typename... Args> iterator emplace(const_iterator P, Args &&... A) {\n    return V.emplace(P, std::forward<Args>(A)...);\n  }\n\n  friend bool operator==(const Array &L, const Array &R) { return L.V == R.V; }\n};\ninline bool operator!=(const Array &L, const Array &R) { return !(L == R); }\n\n/// A Value is an JSON value of unknown type.\n/// They can be copied, but should generally be moved.\n///\n/// === Composing values ===\n///\n/// You can implicitly construct Values from:\n///   - strings: std::string, SmallString, formatv, StringRef, char*\n///              (char*, and StringRef are references, not copies!)\n///   - numbers\n///   - booleans\n///   - null: nullptr\n///   - arrays: {\"foo\", 42.0, false}\n///   - serializable things: types with toJSON(const T&)->Value, found by ADL\n///\n/// They can also be constructed from object/array helpers:\n///   - json::Object is a type like map<ObjectKey, Value>\n///   - json::Array is a type like vector<Value>\n/// These can be list-initialized, or used to build up collections in a loop.\n/// json::ary(Collection) converts all items in a collection to Values.\n///\n/// === Inspecting values ===\n///\n/// Each Value is one of the JSON kinds:\n///   null    (nullptr_t)\n///   boolean (bool)\n///   number  (double or int64)\n///   string  (StringRef)\n///   array   (json::Array)\n///   object  (json::Object)\n///\n/// The kind can be queried directly, or implicitly via the typed accessors:\n///   if (Optional<StringRef> S = E.getAsString()\n///     assert(E.kind() == Value::String);\n///\n/// Array and Object also have typed indexing accessors for easy traversal:\n///   Expected<Value> E = parse(R\"( {\"options\": {\"font\": \"sans-serif\"}} )\");\n///   if (Object* O = E->getAsObject())\n///     if (Object* Opts = O->getObject(\"options\"))\n///       if (Optional<StringRef> Font = Opts->getString(\"font\"))\n///         assert(Opts->at(\"font\").kind() == Value::String);\n///\n/// === Converting JSON values to C++ types ===\n///\n/// The convention is to have a deserializer function findable via ADL:\n///     fromJSON(const json::Value&, T&, Path) -> bool\n///\n/// The return value indicates overall success, and Path is used for precise\n/// error reporting. (The Path::Root passed in at the top level fromJSON call\n/// captures any nested error and can render it in context).\n/// If conversion fails, fromJSON calls Path::report() and immediately returns.\n/// This ensures that the first fatal error survives.\n///\n/// Deserializers are provided for:\n///   - bool\n///   - int and int64_t\n///   - double\n///   - std::string\n///   - vector<T>, where T is deserializable\n///   - map<string, T>, where T is deserializable\n///   - Optional<T>, where T is deserializable\n/// ObjectMapper can help writing fromJSON() functions for object types.\n///\n/// For conversion in the other direction, the serializer function is:\n///    toJSON(const T&) -> json::Value\n/// If this exists, then it also allows constructing Value from T, and can\n/// be used to serialize vector<T>, map<string, T>, and Optional<T>.\n///\n/// === Serialization ===\n///\n/// Values can be serialized to JSON:\n///   1) raw_ostream << Value                    // Basic formatting.\n///   2) raw_ostream << formatv(\"{0}\", Value)    // Basic formatting.\n///   3) raw_ostream << formatv(\"{0:2}\", Value)  // Pretty-print with indent 2.\n///\n/// And parsed:\n///   Expected<Value> E = json::parse(\"[1, 2, null]\");\n///   assert(E && E->kind() == Value::Array);\nclass Value {\npublic:\n  enum Kind {\n    Null,\n    Boolean,\n    /// Number values can store both int64s and doubles at full precision,\n    /// depending on what they were constructed/parsed from.\n    Number,\n    String,\n    Array,\n    Object,\n  };\n\n  // It would be nice to have Value() be null. But that would make {} null too.\n  Value(const Value &M) { copyFrom(M); }\n  Value(Value &&M) { moveFrom(std::move(M)); }\n  Value(std::initializer_list<Value> Elements);\n  Value(json::Array &&Elements) : Type(T_Array) {\n    create<json::Array>(std::move(Elements));\n  }\n  template <typename Elt>\n  Value(const std::vector<Elt> &C) : Value(json::Array(C)) {}\n  Value(json::Object &&Properties) : Type(T_Object) {\n    create<json::Object>(std::move(Properties));\n  }\n  template <typename Elt>\n  Value(const std::map<std::string, Elt> &C) : Value(json::Object(C)) {}\n  // Strings: types with value semantics. Must be valid UTF-8.\n  Value(std::string V) : Type(T_String) {\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      V = fixUTF8(std::move(V));\n    }\n    create<std::string>(std::move(V));\n  }\n  Value(const llvm::SmallVectorImpl<char> &V)\n      : Value(std::string(V.begin(), V.end())) {}\n  Value(const llvm::formatv_object_base &V) : Value(V.str()) {}\n  // Strings: types with reference semantics. Must be valid UTF-8.\n  Value(StringRef V) : Type(T_StringRef) {\n    create<llvm::StringRef>(V);\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = Value(fixUTF8(V));\n    }\n  }\n  Value(const char *V) : Value(StringRef(V)) {}\n  Value(std::nullptr_t) : Type(T_Null) {}\n  // Boolean (disallow implicit conversions).\n  // (The last template parameter is a dummy to keep templates distinct.)\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<T, bool>::value>,\n            bool = false>\n  Value(T B) : Type(T_Boolean) {\n    create<bool>(B);\n  }\n  // Integers (except boolean). Must be non-narrowing convertible to int64_t.\n  template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>,\n            typename = std::enable_if_t<!std::is_same<T, bool>::value>>\n  Value(T I) : Type(T_Integer) {\n    create<int64_t>(int64_t{I});\n  }\n  // Floating point. Must be non-narrowing convertible to double.\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>,\n            double * = nullptr>\n  Value(T D) : Type(T_Double) {\n    create<double>(double{D});\n  }\n  // Serializable types: with a toJSON(const T&)->Value function, found by ADL.\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<\n                Value, decltype(toJSON(*(const T *)nullptr))>::value>,\n            Value * = nullptr>\n  Value(const T &V) : Value(toJSON(V)) {}\n\n  Value &operator=(const Value &M) {\n    destroy();\n    copyFrom(M);\n    return *this;\n  }\n  Value &operator=(Value &&M) {\n    destroy();\n    moveFrom(std::move(M));\n    return *this;\n  }\n  ~Value() { destroy(); }\n\n  Kind kind() const {\n    switch (Type) {\n    case T_Null:\n      return Null;\n    case T_Boolean:\n      return Boolean;\n    case T_Double:\n    case T_Integer:\n      return Number;\n    case T_String:\n    case T_StringRef:\n      return String;\n    case T_Object:\n      return Object;\n    case T_Array:\n      return Array;\n    }\n    llvm_unreachable(\"Unknown kind\");\n  }\n\n  // Typed accessors return None/nullptr if the Value is not of this type.\n  llvm::Optional<std::nullptr_t> getAsNull() const {\n    if (LLVM_LIKELY(Type == T_Null))\n      return nullptr;\n    return llvm::None;\n  }\n  llvm::Optional<bool> getAsBoolean() const {\n    if (LLVM_LIKELY(Type == T_Boolean))\n      return as<bool>();\n    return llvm::None;\n  }\n  llvm::Optional<double> getAsNumber() const {\n    if (LLVM_LIKELY(Type == T_Double))\n      return as<double>();\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    return llvm::None;\n  }\n  // Succeeds if the Value is a Number, and exactly representable as int64_t.\n  llvm::Optional<int64_t> getAsInteger() const {\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    if (LLVM_LIKELY(Type == T_Double)) {\n      double D = as<double>();\n      if (LLVM_LIKELY(std::modf(D, &D) == 0.0 &&\n                      D >= double(std::numeric_limits<int64_t>::min()) &&\n                      D <= double(std::numeric_limits<int64_t>::max())))\n        return D;\n    }\n    return llvm::None;\n  }\n  llvm::Optional<llvm::StringRef> getAsString() const {\n    if (Type == T_String)\n      return llvm::StringRef(as<std::string>());\n    if (LLVM_LIKELY(Type == T_StringRef))\n      return as<llvm::StringRef>();\n    return llvm::None;\n  }\n  const json::Object *getAsObject() const {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  json::Object *getAsObject() {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  const json::Array *getAsArray() const {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n  json::Array *getAsArray() {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n\nprivate:\n  void destroy();\n  void copyFrom(const Value &M);\n  // We allow moving from *const* Values, by marking all members as mutable!\n  // This hack is needed to support initializer-list syntax efficiently.\n  // (std::initializer_list<T> is a container of const T).\n  void moveFrom(const Value &&M);\n  friend class Array;\n  friend class Object;\n\n  template <typename T, typename... U> void create(U &&... V) {\n    new (reinterpret_cast<T *>(&Union)) T(std::forward<U>(V)...);\n  }\n  template <typename T> T &as() const {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC6 and earlier.\n    void *Storage = static_cast<void *>(&Union);\n    return *static_cast<T *>(Storage);\n  }\n\n  friend class OStream;\n\n  enum ValueType : char {\n    T_Null,\n    T_Boolean,\n    T_Double,\n    T_Integer,\n    T_StringRef,\n    T_String,\n    T_Object,\n    T_Array,\n  };\n  // All members mutable, see moveFrom().\n  mutable ValueType Type;\n  mutable llvm::AlignedCharArrayUnion<bool, double, int64_t, llvm::StringRef,\n                                      std::string, json::Array, json::Object>\n      Union;\n  friend bool operator==(const Value &, const Value &);\n};\n\nbool operator==(const Value &, const Value &);\ninline bool operator!=(const Value &L, const Value &R) { return !(L == R); }\n\n/// ObjectKey is a used to capture keys in Object. Like Value but:\n///   - only strings are allowed\n///   - it's optimized for the string literal case (Owned == nullptr)\n/// Like Value, strings must be UTF-8. See isUTF8 documentation for details.\nclass ObjectKey {\npublic:\n  ObjectKey(const char *S) : ObjectKey(StringRef(S)) {}\n  ObjectKey(std::string S) : Owned(new std::string(std::move(S))) {\n    if (LLVM_UNLIKELY(!isUTF8(*Owned))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *Owned = fixUTF8(std::move(*Owned));\n    }\n    Data = *Owned;\n  }\n  ObjectKey(llvm::StringRef S) : Data(S) {\n    if (LLVM_UNLIKELY(!isUTF8(Data))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = ObjectKey(fixUTF8(S));\n    }\n  }\n  ObjectKey(const llvm::SmallVectorImpl<char> &V)\n      : ObjectKey(std::string(V.begin(), V.end())) {}\n  ObjectKey(const llvm::formatv_object_base &V) : ObjectKey(V.str()) {}\n\n  ObjectKey(const ObjectKey &C) { *this = C; }\n  ObjectKey(ObjectKey &&C) : ObjectKey(static_cast<const ObjectKey &&>(C)) {}\n  ObjectKey &operator=(const ObjectKey &C) {\n    if (C.Owned) {\n      Owned.reset(new std::string(*C.Owned));\n      Data = *Owned;\n    } else {\n      Data = C.Data;\n    }\n    return *this;\n  }\n  ObjectKey &operator=(ObjectKey &&) = default;\n\n  operator llvm::StringRef() const { return Data; }\n  std::string str() const { return Data.str(); }\n\nprivate:\n  // FIXME: this is unneccesarily large (3 pointers). Pointer + length + owned\n  // could be 2 pointers at most.\n  std::unique_ptr<std::string> Owned;\n  llvm::StringRef Data;\n};\n\ninline bool operator==(const ObjectKey &L, const ObjectKey &R) {\n  return llvm::StringRef(L) == llvm::StringRef(R);\n}\ninline bool operator!=(const ObjectKey &L, const ObjectKey &R) {\n  return !(L == R);\n}\ninline bool operator<(const ObjectKey &L, const ObjectKey &R) {\n  return StringRef(L) < StringRef(R);\n}\n\nstruct Object::KV {\n  ObjectKey K;\n  Value V;\n};\n\ninline Object::Object(std::initializer_list<KV> Properties) {\n  for (const auto &P : Properties) {\n    auto R = try_emplace(P.K, nullptr);\n    if (R.second)\n      R.first->getSecond().moveFrom(std::move(P.V));\n  }\n}\ninline std::pair<Object::iterator, bool> Object::insert(KV E) {\n  return try_emplace(std::move(E.K), std::move(E.V));\n}\ninline bool Object::erase(StringRef K) {\n  return M.erase(ObjectKey(K));\n}\n\n/// A \"cursor\" marking a position within a Value.\n/// The Value is a tree, and this is the path from the root to the current node.\n/// This is used to associate errors with particular subobjects.\nclass Path {\npublic:\n  class Root;\n\n  /// Records that the value at the current path is invalid.\n  /// Message is e.g. \"expected number\" and becomes part of the final error.\n  /// This overwrites any previously written error message in the root.\n  void report(llvm::StringLiteral Message);\n\n  /// The root may be treated as a Path.\n  Path(Root &R) : Parent(nullptr), Seg(&R) {}\n  /// Derives a path for an array element: this[Index]\n  Path index(unsigned Index) const { return Path(this, Segment(Index)); }\n  /// Derives a path for an object field: this.Field\n  Path field(StringRef Field) const { return Path(this, Segment(Field)); }\n\nprivate:\n  /// One element in a JSON path: an object field (.foo) or array index [27].\n  /// Exception: the root Path encodes a pointer to the Path::Root.\n  class Segment {\n    uintptr_t Pointer;\n    unsigned Offset;\n\n  public:\n    Segment() = default;\n    Segment(Root *R) : Pointer(reinterpret_cast<uintptr_t>(R)) {}\n    Segment(llvm::StringRef Field)\n        : Pointer(reinterpret_cast<uintptr_t>(Field.data())),\n          Offset(static_cast<unsigned>(Field.size())) {}\n    Segment(unsigned Index) : Pointer(0), Offset(Index) {}\n\n    bool isField() const { return Pointer != 0; }\n    StringRef field() const {\n      return StringRef(reinterpret_cast<const char *>(Pointer), Offset);\n    }\n    unsigned index() const { return Offset; }\n    Root *root() const { return reinterpret_cast<Root *>(Pointer); }\n  };\n\n  const Path *Parent;\n  Segment Seg;\n\n  Path(const Path *Parent, Segment S) : Parent(Parent), Seg(S) {}\n};\n\n/// The root is the trivial Path to the root value.\n/// It also stores the latest reported error and the path where it occurred.\nclass Path::Root {\n  llvm::StringRef Name;\n  llvm::StringLiteral ErrorMessage;\n  std::vector<Path::Segment> ErrorPath; // Only valid in error state. Reversed.\n\n  friend void Path::report(llvm::StringLiteral Message);\n\npublic:\n  Root(llvm::StringRef Name = \"\") : Name(Name), ErrorMessage(\"\") {}\n  // No copy/move allowed as there are incoming pointers.\n  Root(Root &&) = delete;\n  Root &operator=(Root &&) = delete;\n  Root(const Root &) = delete;\n  Root &operator=(const Root &) = delete;\n\n  /// Returns the last error reported, or else a generic error.\n  Error getError() const;\n  /// Print the root value with the error shown inline as a comment.\n  /// Unrelated parts of the value are elided for brevity, e.g.\n  ///   {\n  ///      \"id\": 42,\n  ///      \"name\": /* expected string */ null,\n  ///      \"properties\": { ... }\n  ///   }\n  void printErrorContext(const Value &, llvm::raw_ostream &) const;\n};\n\n// Standard deserializers are provided for primitive types.\n// See comments on Value.\ninline bool fromJSON(const Value &E, std::string &Out, Path P) {\n  if (auto S = E.getAsString()) {\n    Out = std::string(*S);\n    return true;\n  }\n  P.report(\"expected string\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int64_t &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, double &Out, Path P) {\n  if (auto S = E.getAsNumber()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected number\");\n  return false;\n}\ninline bool fromJSON(const Value &E, bool &Out, Path P) {\n  if (auto S = E.getAsBoolean()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected boolean\");\n  return false;\n}\ninline bool fromJSON(const Value &E, std::nullptr_t &Out, Path P) {\n  if (auto S = E.getAsNull()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected null\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, llvm::Optional<T> &Out, Path P) {\n  if (E.getAsNull()) {\n    Out = llvm::None;\n    return true;\n  }\n  T Result;\n  if (!fromJSON(E, Result, P))\n    return false;\n  Out = std::move(Result);\n  return true;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::vector<T> &Out, Path P) {\n  if (auto *A = E.getAsArray()) {\n    Out.clear();\n    Out.resize(A->size());\n    for (size_t I = 0; I < A->size(); ++I)\n      if (!fromJSON((*A)[I], Out[I], P.index(I)))\n        return false;\n    return true;\n  }\n  P.report(\"expected array\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::map<std::string, T> &Out, Path P) {\n  if (auto *O = E.getAsObject()) {\n    Out.clear();\n    for (const auto &KV : *O)\n      if (!fromJSON(KV.second, Out[std::string(llvm::StringRef(KV.first))],\n                    P.field(KV.first)))\n        return false;\n    return true;\n  }\n  P.report(\"expected object\");\n  return false;\n}\n\n// Allow serialization of Optional<T> for supported T.\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt) {\n  return Opt ? Value(*Opt) : Value(nullptr);\n}\n\n/// Helper for mapping JSON objects onto protocol structs.\n///\n/// Example:\n/// \\code\n///   bool fromJSON(const Value &E, MyStruct &R, Path P) {\n///     ObjectMapper O(E, P);\n///     // When returning false, error details were already reported.\n///     return O && O.map(\"mandatory_field\", R.MandatoryField) &&\n///         O.mapOptional(\"optional_field\", R.OptionalField);\n///   }\n/// \\endcode\nclass ObjectMapper {\npublic:\n  /// If O is not an object, this mapper is invalid and an error is reported.\n  ObjectMapper(const Value &E, Path P) : O(E.getAsObject()), P(P) {\n    if (!O)\n      P.report(\"expected object\");\n  }\n\n  /// True if the expression is an object.\n  /// Must be checked before calling map().\n  operator bool() const { return O; }\n\n  /// Maps a property to a field.\n  /// If the property is missing or invalid, reports an error.\n  template <typename T> bool map(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    P.field(Prop).report(\"missing value\");\n    return false;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// (Optional requires special handling, because missing keys are OK).\n  template <typename T> bool map(StringLiteral Prop, llvm::Optional<T> &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    Out = llvm::None;\n    return true;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// If the property does not exist, Out is unchanged.\n  template <typename T> bool mapOptional(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    return true;\n  }\n\nprivate:\n  const Object *O;\n  Path P;\n};\n\n/// Parses the provided JSON source, or returns a ParseError.\n/// The returned Value is self-contained and owns its strings (they do not refer\n/// to the original source).\nllvm::Expected<Value> parse(llvm::StringRef JSON);\n\nclass ParseError : public llvm::ErrorInfo<ParseError> {\n  const char *Msg;\n  unsigned Line, Column, Offset;\n\npublic:\n  static char ID;\n  ParseError(const char *Msg, unsigned Line, unsigned Column, unsigned Offset)\n      : Msg(Msg), Line(Line), Column(Column), Offset(Offset) {}\n  void log(llvm::raw_ostream &OS) const override {\n    OS << llvm::formatv(\"[{0}:{1}, byte={2}]: {3}\", Line, Column, Offset, Msg);\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n/// Version of parse() that converts the parsed value to the type T.\n/// RootName describes the root object and is used in error messages.\ntemplate <typename T>\nExpected<T> parse(const llvm::StringRef &JSON, const char *RootName = \"\") {\n  auto V = parse(JSON);\n  if (!V)\n    return V.takeError();\n  Path::Root R(RootName);\n  T Result;\n  if (fromJSON(*V, Result, R))\n    return std::move(Result);\n  return R.getError();\n}\n\n/// json::OStream allows writing well-formed JSON without materializing\n/// all structures as json::Value ahead of time.\n/// It's faster, lower-level, and less safe than OS << json::Value.\n/// It also allows emitting more constructs, such as comments.\n///\n/// Only one \"top-level\" object can be written to a stream.\n/// Simplest usage involves passing lambdas (Blocks) to fill in containers:\n///\n///   json::OStream J(OS);\n///   J.array([&]{\n///     for (const Event &E : Events)\n///       J.object([&] {\n///         J.attribute(\"timestamp\", int64_t(E.Time));\n///         J.attributeArray(\"participants\", [&] {\n///           for (const Participant &P : E.Participants)\n///             J.value(P.toString());\n///         });\n///       });\n///   });\n///\n/// This would produce JSON like:\n///\n///   [\n///     {\n///       \"timestamp\": 19287398741,\n///       \"participants\": [\n///         \"King Kong\",\n///         \"Miley Cyrus\",\n///         \"Cleopatra\"\n///       ]\n///     },\n///     ...\n///   ]\n///\n/// The lower level begin/end methods (arrayBegin()) are more flexible but\n/// care must be taken to pair them correctly:\n///\n///   json::OStream J(OS);\n//    J.arrayBegin();\n///   for (const Event &E : Events) {\n///     J.objectBegin();\n///     J.attribute(\"timestamp\", int64_t(E.Time));\n///     J.attributeBegin(\"participants\");\n///     for (const Participant &P : E.Participants)\n///       J.value(P.toString());\n///     J.attributeEnd();\n///     J.objectEnd();\n///   }\n///   J.arrayEnd();\n///\n/// If the call sequence isn't valid JSON, asserts will fire in debug mode.\n/// This can be mismatched begin()/end() pairs, trying to emit attributes inside\n/// an array, and so on.\n/// With asserts disabled, this is undefined behavior.\nclass OStream {\n public:\n  using Block = llvm::function_ref<void()>;\n  // If IndentSize is nonzero, output is pretty-printed.\n  explicit OStream(llvm::raw_ostream &OS, unsigned IndentSize = 0)\n      : OS(OS), IndentSize(IndentSize) {\n    Stack.emplace_back();\n  }\n  ~OStream() {\n    assert(Stack.size() == 1 && \"Unmatched begin()/end()\");\n    assert(Stack.back().Ctx == Singleton);\n    assert(Stack.back().HasValue && \"Did not write top-level value\");\n  }\n\n  /// Flushes the underlying ostream. OStream does not buffer internally.\n  void flush() { OS.flush(); }\n\n  // High level functions to output a value.\n  // Valid at top-level (exactly once), in an attribute value (exactly once),\n  // or in an array (any number of times).\n\n  /// Emit a self-contained value (number, string, vector<string> etc).\n  void value(const Value &V);\n  /// Emit an array whose elements are emitted in the provided Block.\n  void array(Block Contents) {\n    arrayBegin();\n    Contents();\n    arrayEnd();\n  }\n  /// Emit an object whose elements are emitted in the provided Block.\n  void object(Block Contents) {\n    objectBegin();\n    Contents();\n    objectEnd();\n  }\n  /// Emit an externally-serialized value.\n  /// The caller must write exactly one valid JSON value to the provided stream.\n  /// No validation or formatting of this value occurs.\n  void rawValue(llvm::function_ref<void(raw_ostream &)> Contents) {\n    rawValueBegin();\n    Contents(OS);\n    rawValueEnd();\n  }\n  void rawValue(llvm::StringRef Contents) {\n    rawValue([&](raw_ostream &OS) { OS << Contents; });\n  }\n  /// Emit a JavaScript comment associated with the next printed value.\n  /// The string must be valid until the next attribute or value is emitted.\n  /// Comments are not part of standard JSON, and many parsers reject them!\n  void comment(llvm::StringRef);\n\n  // High level functions to output object attributes.\n  // Valid only within an object (any number of times).\n\n  /// Emit an attribute whose value is self-contained (number, vector<int> etc).\n  void attribute(llvm::StringRef Key, const Value& Contents) {\n    attributeImpl(Key, [&] { value(Contents); });\n  }\n  /// Emit an attribute whose value is an array with elements from the Block.\n  void attributeArray(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { array(Contents); });\n  }\n  /// Emit an attribute whose value is an object with attributes from the Block.\n  void attributeObject(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { object(Contents); });\n  }\n\n  // Low-level begin/end functions to output arrays, objects, and attributes.\n  // Must be correctly paired. Allowed contexts are as above.\n\n  void arrayBegin();\n  void arrayEnd();\n  void objectBegin();\n  void objectEnd();\n  void attributeBegin(llvm::StringRef Key);\n  void attributeEnd();\n  raw_ostream &rawValueBegin();\n  void rawValueEnd();\n\nprivate:\n  void attributeImpl(llvm::StringRef Key, Block Contents) {\n    attributeBegin(Key);\n    Contents();\n    attributeEnd();\n  }\n\n  void valueBegin();\n  void flushComment();\n  void newline();\n\n  enum Context {\n    Singleton, // Top level, or object attribute.\n    Array,\n    Object,\n    RawValue, // External code writing a value to OS directly.\n  };\n  struct State {\n    Context Ctx = Singleton;\n    bool HasValue = false;\n  };\n  llvm::SmallVector<State, 16> Stack; // Never empty.\n  llvm::StringRef PendingComment;\n  llvm::raw_ostream &OS;\n  unsigned IndentSize;\n  unsigned Indent = 0;\n};\n\n/// Serializes this Value to JSON, writing it to the provided stream.\n/// The formatting is compact (no extra whitespace) and deterministic.\n/// For pretty-printing, use the formatv() format_provider below.\ninline llvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Value &V) {\n  OStream(OS).value(V);\n  return OS;\n}\n} // namespace json\n\n/// Allow printing json::Value with formatv().\n/// The default style is basic/compact formatting, like operator<<.\n/// A format string like formatv(\"{0:2}\", Value) pretty-prints with indent 2.\ntemplate <> struct format_provider<llvm::json::Value> {\n  static void format(const llvm::json::Value &, raw_ostream &, StringRef);\n};\n} // namespace llvm\n\n#endif\n"}, "79": {"id": 79, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Registry.h", "content": "//=== Registry.h - Linker-supported plugin registries -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Defines a registry template for discovering pluggable modules.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_REGISTRY_H\n#define LLVM_SUPPORT_REGISTRY_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/DynamicLibrary.h\"\n#include <memory>\n\nnamespace llvm {\n  /// A simple registry entry which provides only a name, description, and\n  /// no-argument constructor.\n  template <typename T>\n  class SimpleRegistryEntry {\n    StringRef Name, Desc;\n    std::unique_ptr<T> (*Ctor)();\n\n  public:\n    SimpleRegistryEntry(StringRef N, StringRef D, std::unique_ptr<T> (*C)())\n        : Name(N), Desc(D), Ctor(C) {}\n\n    StringRef getName() const { return Name; }\n    StringRef getDesc() const { return Desc; }\n    std::unique_ptr<T> instantiate() const { return Ctor(); }\n  };\n\n  /// A global registry used in conjunction with static constructors to make\n  /// pluggable components (like targets or garbage collectors) \"just work\" when\n  /// linked with an executable.\n  template <typename T>\n  class Registry {\n  public:\n    typedef T type;\n    typedef SimpleRegistryEntry<T> entry;\n\n    class node;\n    class iterator;\n\n  private:\n    Registry() = delete;\n\n    friend class node;\n    static node *Head, *Tail;\n\n  public:\n    /// Node in linked list of entries.\n    ///\n    class node {\n      friend class iterator;\n      friend Registry<T>;\n\n      node *Next;\n      const entry& Val;\n\n    public:\n      node(const entry &V) : Next(nullptr), Val(V) {}\n    };\n\n    /// Add a node to the Registry: this is the interface between the plugin and\n    /// the executable.\n    ///\n    /// This function is exported by the executable and called by the plugin to\n    /// add a node to the executable's registry. Therefore it's not defined here\n    /// to avoid it being instantiated in the plugin and is instead defined in\n    /// the executable (see LLVM_INSTANTIATE_REGISTRY below).\n    static void add_node(node *N);\n\n    /// Iterators for registry entries.\n    ///\n    class iterator\n        : public llvm::iterator_facade_base<iterator, std::forward_iterator_tag,\n                                            const entry> {\n      const node *Cur;\n\n    public:\n      explicit iterator(const node *N) : Cur(N) {}\n\n      bool operator==(const iterator &That) const { return Cur == That.Cur; }\n      iterator &operator++() { Cur = Cur->Next; return *this; }\n      const entry &operator*() const { return Cur->Val; }\n    };\n\n    // begin is not defined here in order to avoid usage of an undefined static\n    // data member, instead it's instantiated by LLVM_INSTANTIATE_REGISTRY.\n    static iterator begin();\n    static iterator end()   { return iterator(nullptr); }\n\n    static iterator_range<iterator> entries() {\n      return make_range(begin(), end());\n    }\n\n    /// A static registration template. Use like such:\n    ///\n    ///   Registry<Collector>::Add<FancyGC>\n    ///   X(\"fancy-gc\", \"Newfangled garbage collector.\");\n    ///\n    /// Use of this template requires that:\n    ///\n    ///  1. The registered subclass has a default constructor.\n    template <typename V>\n    class Add {\n      entry Entry;\n      node Node;\n\n      static std::unique_ptr<T> CtorFn() { return std::make_unique<V>(); }\n\n    public:\n      Add(StringRef Name, StringRef Desc)\n          : Entry(Name, Desc, CtorFn), Node(Entry) {\n        add_node(&Node);\n      }\n    };\n  };\n} // end namespace llvm\n\n/// Instantiate a registry class.\n///\n/// This provides template definitions of add_node, begin, and the Head and Tail\n/// pointers, then explicitly instantiates them. We could explicitly specialize\n/// them, instead of the two-step process of define then instantiate, but\n/// strictly speaking that's not allowed by the C++ standard (we would need to\n/// have explicit specialization declarations in all translation units where the\n/// specialization is used) so we don't.\n#define LLVM_INSTANTIATE_REGISTRY(REGISTRY_CLASS) \\\n  namespace llvm { \\\n  template<typename T> typename Registry<T>::node *Registry<T>::Head = nullptr;\\\n  template<typename T> typename Registry<T>::node *Registry<T>::Tail = nullptr;\\\n  template<typename T> \\\n  void Registry<T>::add_node(typename Registry<T>::node *N) { \\\n    if (Tail) \\\n      Tail->Next = N; \\\n    else \\\n      Head = N; \\\n    Tail = N; \\\n  } \\\n  template<typename T> typename Registry<T>::iterator Registry<T>::begin() { \\\n    return iterator(Head); \\\n  } \\\n  template REGISTRY_CLASS::node *Registry<REGISTRY_CLASS::type>::Head; \\\n  template REGISTRY_CLASS::node *Registry<REGISTRY_CLASS::type>::Tail; \\\n  template \\\n  void Registry<REGISTRY_CLASS::type>::add_node(REGISTRY_CLASS::node*); \\\n  template REGISTRY_CLASS::iterator Registry<REGISTRY_CLASS::type>::begin(); \\\n  }\n\n#endif // LLVM_SUPPORT_REGISTRY_H\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 0, "line": 63}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 0, "line": 63}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Headers.h", "reportHash": "539163dad1ac2b0882c07bd5f53930b5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 100}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 100}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "7d3fac965add7603e97d952e3f205fc1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 104}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 104}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "27be765c65f1ff0b58b130e4c172dc0b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 108}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 108}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "61ada8ec382f21007dfd41ede630bf79", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 156}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 156}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "fbb49559f0f71292842fd5b992bbbd8b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 1, "line": 156}, "message": "'LHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "9fd1cfe17b6758d7419238c2fd6dfa7a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 63, "file": 1, "line": 156}, "message": "'RHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "f771f098dcd0ee90103809e3f147f53d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 160}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 160}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "105b53e1d89aec5a6cb87c52f466c02c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 1, "line": 160}, "message": "'LHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "68d9fdea737c4cdde1f6d535a18fb667", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 63, "file": 1, "line": 160}, "message": "'RHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "d2244e7d23d8f40d8358f17c81ef29b3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 163}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 163}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "e111011dae459987a5dc4efea6241720", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 1, "line": 163}, "message": "'LHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "0154daf0db17d330e6d9a9ac01f9129b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 62, "file": 1, "line": 163}, "message": "'RHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "3834b60a8b50f4ab3d7ee33163e0ec72", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 167}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 167}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "16b636e3af313d605e5533969836504e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 1, "line": 167}, "message": "'LHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "9b8755c70f3504d8d750c312ee0f9111", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 63, "file": 1, "line": 167}, "message": "'RHS' of type 'clang::clangd::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "d62283e0a51e78942a79184efc338c5f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 183}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 183}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "ecca42d431d4e6e8009305d8dca6449c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 1, "line": 183}, "message": "'LHS' of type 'clang::clangd::Range' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "4bbda9114aac848e7372abcf139310db", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 1, "line": 183}, "message": "'RHS' of type 'clang::clangd::Range' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "47b30eaaa98d6c65131a5751d3de7e99", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 186}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 186}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "3f39638a85bab9ed749b02c2de2469b9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 1, "line": 186}, "message": "'LHS' of type 'clang::clangd::Range' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "5a44a4f99791412b31dc605e84aa5c4d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 1, "line": 186}, "message": "'RHS' of type 'clang::clangd::Range' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "cd51be05dd347d3633231d9db4f9f347", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 189}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 189}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "5128767941204f363fb5359c081e6bbe", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 1, "line": 189}, "message": "'LHS' of type 'clang::clangd::Range' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "85da2c80f4fa1f53bb2a77e084f1f37d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 1, "line": 189}, "message": "'RHS' of type 'clang::clangd::Range' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "4e3046aef1a5c8f224dc7c31b0f2225e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 207}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 207}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "3a28d0b9f21341985a57e9f43c4aabfe", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 211}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 211}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "ddc2e0652e7029e229a6b579d8653679", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 215}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 215}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "ab9ad321137163ae18f557926936dbae", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 231}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 1, "line": 231}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "213a60a75bb7bacfa368f323290f05d0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 1, "line": 1055}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 1, "line": 1055}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "769ae8cc7e049fb0fccbd97b70dd8767", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 1, "line": 1220}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 1, "line": 1220}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "f5383f050266225c442903933d47ba01", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 1, "line": 1220}, "message": "'' of type 'clang::clangd::CompletionItem' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "179df58d78c6c2098a5a64442a3854db", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 62, "file": 1, "line": 1220}, "message": "'' of type 'clang::clangd::CompletionItem' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "dd80133ff749f114e249a1fb37f707fd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 1312}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 1312}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "68c5007267982340ecc460ac1fc3ee94", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 1319}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 1319}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "1511db40332ed33e16a6fafd8dcb78ef", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 1, "line": 1519}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 1, "line": 1519}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "8783136d1ddaab6de42027b7af66443f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 1622}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 1622}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "1880b55d242b0bd679a30e7a27a749e5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 1626}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 1626}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "96f93b173e703c51745b6f8d768a50be", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 87}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 87}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "reportHash": "081bc2b31b73dec0f02052bade72f082", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 92}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 92}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "reportHash": "00b9fbf8ba5efef5870641a199d1a876", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 52}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "reportHash": "3cc531dd2081d29e6de2183c584e309a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 59}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "reportHash": "0436fe820ecf28cb9e07301c47e90b0f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 4, "line": 97}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 4, "line": 97}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "79f117a2cf846a3717f7bd3d5926e2bc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 4, "line": 101}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 4, "line": 101}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "d7472c1c3626b9a94d2ea8754eeac0bc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 39}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Relation.h", "reportHash": "f34e12291399f2e2a7577e5c94d17b76", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 44}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Relation.h", "reportHash": "7174eee51834fea49c1d190b52c7bcaa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 37}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolID.h", "reportHash": "1f09c7c77a1afc1e88f08cd2c2fa3f18", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 40}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolID.h", "reportHash": "7fa995444bd619eaed0f447ca279324f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 43}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolID.h", "reportHash": "f2ab4a1de27dcbc0669dfca34d678852", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 7, "line": 67}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 7, "line": 67}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "e693e62e078b69ba38a6d1987e02743b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 7, "line": 67}, "message": "'L' of type 'SymbolLocation::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "6dd7becb4837cb167ff7633865d4eed7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 7, "line": 68}, "message": "'R' of type 'SymbolLocation::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "9a79cbb54b10b68beb6ed87e9da3e56e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 7, "line": 72}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 7, "line": 72}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "32d227123af339e8768716b53b5be2ad", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 7, "line": 72}, "message": "'L' of type 'SymbolLocation::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "cd7837b1a02fc5e5829165ea454cbe50", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 7, "line": 73}, "message": "'R' of type 'SymbolLocation::Position' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "1552b7b1bddb100b579a000ba647ad7b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 7, "line": 77}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 7, "line": 77}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "e44633c581258f4aa408d549e1679603", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 7, "line": 77}, "message": "'L' of type 'clang::clangd::SymbolLocation' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "05ad5a38b4e0bbfc4667c44412f0a9da", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 71, "file": 7, "line": 77}, "message": "'R' of type 'clang::clangd::SymbolLocation' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "669309c8bd38bf5d3c1734339be7e52d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 7, "line": 82}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 7, "line": 82}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "9ca309516794bb9981db71e362efca0c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 7, "line": 82}, "message": "'L' of type 'clang::clangd::SymbolLocation' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "be3bb909ef1537927877bd992dd6656f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 70, "file": 7, "line": 82}, "message": "'R' of type 'clang::clangd::SymbolLocation' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "ef0dff4f70a50e9e5e1a8dea39e5806b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 73}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "aa31331b76f17c86aa1fcebb915ec253", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 88}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "8e4bb60b704568ccd16bfac6fea967c7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 294}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "0134e391b4e8e0c84cb5d05ffb7c474a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 324}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "93eb0529443eeaa471b57ffb144f1b80", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 344}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTTypeTraits.h", "reportHash": "37c8ed075d1a016ef3267dd7ac172b0b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 27, "line": 328}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "2ded2b5299e4c945e96e0591dc2bafce", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 27, "line": 332}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "ed56791507acc304bf6fa3c0a755242c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 78}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 78}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "9ced4d9fe83d5aaa87fad6baf954bb93", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 29, "line": 78}, "message": "'LHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "c8a1f693a05d5410b490f321c9a96c69", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 71, "file": 29, "line": 78}, "message": "'RHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "3b8496fe821b45c48eab0b8ac6e333c5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 81}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 81}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "845b6aeffbeeac426655058088a7fbde", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 81}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "2946d1dd6de095ce6a3b0a096326f503", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 68, "file": 29, "line": 81}, "message": "'RHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "8fb14aad53a86aabfcb0927bd9070394", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 84}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 84}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "3f2c42f34c88c7829a49c85b4d3fe92d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 84}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "bd2d3d317185f44bacb788517977158e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 29, "line": 84}, "message": "'LHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "fda498331eea3892afbfc234307040c7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 87}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 87}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "bd35a57b3144e3fa73ac6395bcaaf237", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 29, "line": 87}, "message": "'LHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "0f8b494722545a42f9b3399e8c3d1c65", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 71, "file": 29, "line": 87}, "message": "'RHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "4d6bb085c33dc2ca0583d274a3302f18", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 90}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 90}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "c8143565ff3e45d7873ae2eac79d601c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 90}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "3b8bced4c49bcb4e69f9021399574624", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 68, "file": 29, "line": 90}, "message": "'RHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "d2da67fe2e3388fa3592622e9cf8dd78", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 93}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 93}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "8d37f10d061769488ff366b83f054646", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 93}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "2240ad95da425d92905a8bb41855da9a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 29, "line": 93}, "message": "'LHS' of type 'clang::FileEntryRef' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "ec81f6c6eec36c23e1b3bc308c404db5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 377}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "e00a83c39b7791e08da93271c7c2c965", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 2589}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "f862ad04b5c9ab5266c96eef4bbeca82", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 3151}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "c3554532b815f15b55ec3bf0b617dd6f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 36, "line": 222}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 36, "line": 222}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "1f271b876ebaa8949552e97ecd884df9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 36, "line": 222}, "message": "'LHS' of type 'clang::PrecompiledPreamble::PreambleFileHash' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "585d1fd4752267a6ca9cfb2c28134f21", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 36, "line": 223}, "message": "'RHS' of type 'clang::PrecompiledPreamble::PreambleFileHash' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "13f32ee82b9c69dded2442ee545bdaf1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 36, "line": 227}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 36, "line": 227}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "371439082cba9c5ab5f90aff7154a7f9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 36, "line": 227}, "message": "'LHS' of type 'clang::PrecompiledPreamble::PreambleFileHash' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "881d0ec810424f59421e879649fb17c6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 36, "line": 228}, "message": "'RHS' of type 'clang::PrecompiledPreamble::PreambleFileHash' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "13f32ee82b9c69dded2442ee545bdaf1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 37, "line": 162}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 37, "line": 162}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "ec86d2e3c059708b068df0fefad23aeb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 37, "line": 162}, "message": "'A' of type 'clang::ModuleMap::KnownHeader' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "3d90e9f9c92fa5f04ab4bf2f598cb2af", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 69, "file": 37, "line": 162}, "message": "'B' of type 'clang::ModuleMap::KnownHeader' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "a1972d1fbe104443ca7b45c5d7146e91", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 37, "line": 165}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 37, "line": 165}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "8a7f000b3a99b43f29911062f4a378a2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 37, "line": 165}, "message": "'A' of type 'clang::ModuleMap::KnownHeader' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "bb1678908eb2a309ff35fcbebdc2261b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 69, "file": 37, "line": 165}, "message": "'B' of type 'clang::ModuleMap::KnownHeader' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "50299cd8dfcad9ed0387987040ec5059", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 105}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "reportHash": "871fa7278f91321d685553573a200984", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 39, "line": 978}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 39, "line": 978}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "731a955ce576b3268abeefc69e4f1818", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 39, "line": 978}, "message": "'X' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "83a95bbe0478f96378ab0ad652238e93", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 75, "file": 39, "line": 978}, "message": "'Y' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "c3bdaa888f16758f24d6fa012bcef854", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 39, "line": 980}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 39, "line": 980}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "0ccbba6839ef75457d32132d61783724", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 39, "line": 980}, "message": "'X' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "32813f43592704da1b70621eaedee810", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 39, "line": 981}, "message": "'Y' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "997489940f327e4dfd53483f3eb76eac", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 39, "line": 985}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 39, "line": 985}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "2175c8b5f333dfc345144790ec382604", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 39, "line": 985}, "message": "'X' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "eb03346016092ce42927e20380f2b19c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 39, "line": 986}, "message": "'Y' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "997489940f327e4dfd53483f3eb76eac", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 39, "line": 990}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 39, "line": 990}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "ae0eae3238d1a5ea2f1e14bdc1b2af10", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 39, "line": 990}, "message": "'X' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "10fd8db4486f51ccf66369602eab8977", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 39, "line": 991}, "message": "'Y' of type 'clang::CodeCompletionResult' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "2d1aad0f136327e8cfc5f8d0e65cc4c8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2000}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2000}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "e9be00aafa05e3499ed52ddf28f93d6a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 40, "line": 2000}, "message": "'X' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "2860e614f7dc8052c85ce76886361f9e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 40, "line": 2001}, "message": "'Y' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "79d3cdde49b3a58347eef692aaa0e213", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2005}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2005}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "660bca78619326d78972cd93710ffca9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 40, "line": 2005}, "message": "'X' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "bbd08d7ca9bd3abeba61e0e6489a6942", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 40, "line": 2006}, "message": "'Y' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "79d3cdde49b3a58347eef692aaa0e213", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2010}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2010}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "fdf234b747d7cb307226122210afa4f8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 40, "line": 2010}, "message": "'X' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "7452862e5fbb65f99f2eba2eceb31eea", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 40, "line": 2011}, "message": "'Y' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "6e55ae51041c7824583379e577b83206", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2015}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2015}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "e0f48017198dd3fb429f8d5928b38e65", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 40, "line": 2015}, "message": "'X' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "35b61fb69e5828595d581940ef4d5f27", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 40, "line": 2016}, "message": "'Y' of type 'clang::serialization::LocalRedeclarationsInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "6e55ae51041c7824583379e577b83206", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2029}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2029}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "f38ca93979c149b0e70b539d10269e53", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 40, "line": 2029}, "message": "'X' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "e71bfa06b435570f0346acc3f969d6df", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 40, "line": 2030}, "message": "'Y' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "a1e8e06c17389c8223332d632638b57c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2034}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2034}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "e82d89208def79620a368826595d869f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 40, "line": 2034}, "message": "'X' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "1be8528ce8f260fe161e9561a7e10fd2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 51, "file": 40, "line": 2035}, "message": "'Y' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "a1e8e06c17389c8223332d632638b57c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2039}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2039}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "2868ae2a0a269aa22efbe7a312c16944", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 40, "line": 2039}, "message": "'X' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "03c26f494859e1bc4de8f831a588ae62", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 40, "line": 2040}, "message": "'Y' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "2f3f78e837063177b327d0de68b259dd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2044}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2044}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "eeb36b6fd6d21b2572078db3119fe73a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 40, "line": 2044}, "message": "'X' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "77dc1d9c6e2ad1f881d9bc80ef5e5e08", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 40, "line": 2045}, "message": "'Y' of type 'clang::serialization::ObjCCategoriesInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "2f3f78e837063177b327d0de68b259dd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 40, "line": 2090}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 40, "line": 2090}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "ba4b199752f97fd35d152e6076ab8da5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 40, "line": 2090}, "message": "'A' of type 'clang::serialization::DeclarationNameKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "29dbd93b0f5d64faad3d1c531db393cc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 40, "line": 2091}, "message": "'B' of type 'clang::serialization::DeclarationNameKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "ef1bbb0364ad69c54c704f00ea7ef268", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 41, "line": 68}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 41, "line": 68}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "e58c94176bbfd93ebe73868d2146be1e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 41, "line": 68}, "message": "'LHS' of type 'clang::tooling::CompileCommand' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "723216207dc4eb474dddde88091934e9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 75, "file": 41, "line": 68}, "message": "'RHS' of type 'clang::tooling::CompileCommand' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "489f7d89c7ca4842f47d27668fa28841", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 41, "line": 74}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 41, "line": 74}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "53a34ed16080514f417e7d327a2ed364", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 41, "line": 74}, "message": "'LHS' of type 'clang::tooling::CompileCommand' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "4274bad862954e57157d03e2ca78cf0e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 75, "file": 41, "line": 74}, "message": "'RHS' of type 'clang::tooling::CompileCommand' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "fdf0c2337ab0e8065d28856e3135553e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 65}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h", "reportHash": "3b6c9504c8c12aa4a3778d437c4e309e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 44, "line": 85}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 44, "line": 85}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "reportHash": "854b8658755d442840d3769be7d87269", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 44, "line": 85}, "message": "'L' of type 'clang::syntax::FileRange' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "reportHash": "6c10edff60c6738d0a22fda5cafce653", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 63, "file": 44, "line": 85}, "message": "'R' of type 'clang::syntax::FileRange' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "reportHash": "81652db82e306853668072cce3e876ec", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 44, "line": 88}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 44, "line": 88}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "reportHash": "7bea7b44b1f11d96aeeaa2b159360994", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 44, "line": 88}, "message": "'L' of type 'clang::syntax::FileRange' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "reportHash": "2be7e7aa7ebf67eb78b200b4bc9d03c0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 63, "file": 44, "line": 88}, "message": "'R' of type 'clang::syntax::FileRange' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "reportHash": "75152ae787f3f05686f66714104c95a0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 45, "line": 184}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "1e251b828ebfb2944289e11926460616", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 45, "line": 275}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 45, "line": 275}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "1e5df32b204f3d13f65f7cec5fdaa9d6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 45, "line": 275}, "message": "'A' of type 'Tree::ConstChildIterator' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "7433c333f8ec0d1cf773fe4bd9ce9ab9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 56, "file": 45, "line": 276}, "message": "'B' of type 'Tree::ConstChildIterator' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "f67092d2aa1820a962932bc5a377ebea", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 75, "line": 149}, "message": "'LHS' of type 'llvm::json::Object' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "63ddce30b322a55697c5e33cbcc92392", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 75, "line": 149}, "message": "'RHS' of type 'llvm::json::Object' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "2d660f75b65a09b403d68711b7c98648", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 75, "line": 150}, "message": "'LHS' of type 'llvm::json::Object' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "8f6e3ca277746fbc455b213cafa651a6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 75, "line": 150}, "message": "'RHS' of type 'llvm::json::Object' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "c78263c131aa94db8fa361d26b0d08cf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 75, "line": 208}, "message": "'L' of type 'llvm::json::Array' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "c18d5b5b76564f8ec530c199bd1e248f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 75, "line": 208}, "message": "'R' of type 'llvm::json::Array' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "9f3f4380603f0187a0cfcf2738c48266", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 75, "line": 210}, "message": "'L' of type 'llvm::json::Array' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "9f56b457bd62a83b730c0a455930515f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 53, "file": 75, "line": 210}, "message": "'R' of type 'llvm::json::Array' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "08a590eac819cfee7a6b2d39faddc535", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 75, "line": 485}, "message": "'' of type 'llvm::json::Value' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "56de6fd281208798b88aa3b3d5d9af7f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 75, "line": 485}, "message": "'' of type 'llvm::json::Value' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "ea3aaf09417b2e38e7260a4a81d920ff", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 75, "line": 488}, "message": "'' of type 'llvm::json::Value' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "53cf07a0fe0e4b8fbaed10b28c8be170", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 75, "line": 488}, "message": "'' of type 'llvm::json::Value' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "cb2081ea81bf5b64575fe46cc1d9aeb1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 75, "line": 489}, "message": "'L' of type 'llvm::json::Value' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "e1394b93eb300a3c707cbd369640fc70", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 53, "file": 75, "line": 489}, "message": "'R' of type 'llvm::json::Value' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "464d755ae089ec701f75d6e77e68dd67", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 75, "line": 538}, "message": "'L' of type 'llvm::json::ObjectKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "6e12e755d5a5129ea9daa7bbbcd18eed", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 61, "file": 75, "line": 538}, "message": "'R' of type 'llvm::json::ObjectKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "34f568829a456d4d2122cc32e535368f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 75, "line": 541}, "message": "'L' of type 'llvm::json::ObjectKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "e0828c5dc0536cc5a4da5f4319c3af29", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 61, "file": 75, "line": 541}, "message": "'R' of type 'llvm::json::ObjectKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "e6129a6ef031064cee77736100f4116d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 75, "line": 544}, "message": "'L' of type 'llvm::json::ObjectKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "59c01d1ed9b6685cd20552809d5291a0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 60, "file": 75, "line": 544}, "message": "'R' of type 'llvm::json::ObjectKey' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "f3d6876bdccedbd81487b346679e6506", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 79, "line": 91}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Registry.h", "reportHash": "2e0216b0989a93173c5d96d19578963c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
