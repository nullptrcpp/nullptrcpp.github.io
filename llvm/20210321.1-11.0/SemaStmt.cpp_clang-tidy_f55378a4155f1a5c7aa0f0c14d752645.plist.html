<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaStmt.cpp", "content": "//===--- SemaStmt.cpp - Semantic Analysis for Statements ------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements semantic analysis for statements.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTDiagnostic.h\"\n#include \"clang/AST/ASTLambda.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/EvaluatedExprVisitor.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/StmtObjC.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nusing namespace clang;\nusing namespace sema;\n\nStmtResult Sema::ActOnExprStmt(ExprResult FE, bool DiscardedValue) {\n  if (FE.isInvalid())\n    return StmtError();\n\n  FE = ActOnFinishFullExpr(FE.get(), FE.get()->getExprLoc(), DiscardedValue);\n  if (FE.isInvalid())\n    return StmtError();\n\n  // C99 6.8.3p2: The expression in an expression statement is evaluated as a\n  // void expression for its side effects.  Conversion to void allows any\n  // operand, even incomplete types.\n\n  // Same thing in for stmt first clause (when expr) and third clause.\n  return StmtResult(FE.getAs<Stmt>());\n}\n\n\nStmtResult Sema::ActOnExprStmtError() {\n  DiscardCleanupsInEvaluationContext();\n  return StmtError();\n}\n\nStmtResult Sema::ActOnNullStmt(SourceLocation SemiLoc,\n                               bool HasLeadingEmptyMacro) {\n  return new (Context) NullStmt(SemiLoc, HasLeadingEmptyMacro);\n}\n\nStmtResult Sema::ActOnDeclStmt(DeclGroupPtrTy dg, SourceLocation StartLoc,\n                               SourceLocation EndLoc) {\n  DeclGroupRef DG = dg.get();\n\n  // If we have an invalid decl, just return an error.\n  if (DG.isNull()) return StmtError();\n\n  return new (Context) DeclStmt(DG, StartLoc, EndLoc);\n}\n\nvoid Sema::ActOnForEachDeclStmt(DeclGroupPtrTy dg) {\n  DeclGroupRef DG = dg.get();\n\n  // If we don't have a declaration, or we have an invalid declaration,\n  // just return.\n  if (DG.isNull() || !DG.isSingleDecl())\n    return;\n\n  Decl *decl = DG.getSingleDecl();\n  if (!decl || decl->isInvalidDecl())\n    return;\n\n  // Only variable declarations are permitted.\n  VarDecl *var = dyn_cast<VarDecl>(decl);\n  if (!var) {\n    Diag(decl->getLocation(), diag::err_non_variable_decl_in_for);\n    decl->setInvalidDecl();\n    return;\n  }\n\n  // foreach variables are never actually initialized in the way that\n  // the parser came up with.\n  var->setInit(nullptr);\n\n  // In ARC, we don't need to retain the iteration variable of a fast\n  // enumeration loop.  Rather than actually trying to catch that\n  // during declaration processing, we remove the consequences here.\n  if (getLangOpts().ObjCAutoRefCount) {\n    QualType type = var->getType();\n\n    // Only do this if we inferred the lifetime.  Inferred lifetime\n    // will show up as a local qualifier because explicit lifetime\n    // should have shown up as an AttributedType instead.\n    if (type.getLocalQualifiers().getObjCLifetime() == Qualifiers::OCL_Strong) {\n      // Add 'const' and mark the variable as pseudo-strong.\n      var->setType(type.withConst());\n      var->setARCPseudoStrong(true);\n    }\n  }\n}\n\n/// Diagnose unused comparisons, both builtin and overloaded operators.\n/// For '==' and '!=', suggest fixits for '=' or '|='.\n///\n/// Adding a cast to void (or other expression wrappers) will prevent the\n/// warning from firing.\nstatic bool DiagnoseUnusedComparison(Sema &S, const Expr *E) {\n  SourceLocation Loc;\n  bool CanAssign;\n  enum { Equality, Inequality, Relational, ThreeWay } Kind;\n\n  if (const BinaryOperator *Op = dyn_cast<BinaryOperator>(E)) {\n    if (!Op->isComparisonOp())\n      return false;\n\n    if (Op->getOpcode() == BO_EQ)\n      Kind = Equality;\n    else if (Op->getOpcode() == BO_NE)\n      Kind = Inequality;\n    else if (Op->getOpcode() == BO_Cmp)\n      Kind = ThreeWay;\n    else {\n      assert(Op->isRelationalOp());\n      Kind = Relational;\n    }\n    Loc = Op->getOperatorLoc();\n    CanAssign = Op->getLHS()->IgnoreParenImpCasts()->isLValue();\n  } else if (const CXXOperatorCallExpr *Op = dyn_cast<CXXOperatorCallExpr>(E)) {\n    switch (Op->getOperator()) {\n    case OO_EqualEqual:\n      Kind = Equality;\n      break;\n    case OO_ExclaimEqual:\n      Kind = Inequality;\n      break;\n    case OO_Less:\n    case OO_Greater:\n    case OO_GreaterEqual:\n    case OO_LessEqual:\n      Kind = Relational;\n      break;\n    case OO_Spaceship:\n      Kind = ThreeWay;\n      break;\n    default:\n      return false;\n    }\n\n    Loc = Op->getOperatorLoc();\n    CanAssign = Op->getArg(0)->IgnoreParenImpCasts()->isLValue();\n  } else {\n    // Not a typo-prone comparison.\n    return false;\n  }\n\n  // Suppress warnings when the operator, suspicious as it may be, comes from\n  // a macro expansion.\n  if (S.SourceMgr.isMacroBodyExpansion(Loc))\n    return false;\n\n  S.Diag(Loc, diag::warn_unused_comparison)\n    << (unsigned)Kind << E->getSourceRange();\n\n  // If the LHS is a plausible entity to assign to, provide a fixit hint to\n  // correct common typos.\n  if (CanAssign) {\n    if (Kind == Inequality)\n      S.Diag(Loc, diag::note_inequality_comparison_to_or_assign)\n        << FixItHint::CreateReplacement(Loc, \"|=\");\n    else if (Kind == Equality)\n      S.Diag(Loc, diag::note_equality_comparison_to_assign)\n        << FixItHint::CreateReplacement(Loc, \"=\");\n  }\n\n  return true;\n}\n\nstatic bool DiagnoseNoDiscard(Sema &S, const WarnUnusedResultAttr *A,\n                              SourceLocation Loc, SourceRange R1,\n                              SourceRange R2, bool IsCtor) {\n  if (!A)\n    return false;\n  StringRef Msg = A->getMessage();\n\n  if (Msg.empty()) {\n    if (IsCtor)\n      return S.Diag(Loc, diag::warn_unused_constructor) << A << R1 << R2;\n    return S.Diag(Loc, diag::warn_unused_result) << A << R1 << R2;\n  }\n\n  if (IsCtor)\n    return S.Diag(Loc, diag::warn_unused_constructor_msg) << A << Msg << R1\n                                                          << R2;\n  return S.Diag(Loc, diag::warn_unused_result_msg) << A << Msg << R1 << R2;\n}\n\nvoid Sema::DiagnoseUnusedExprResult(const Stmt *S) {\n  if (const LabelStmt *Label = dyn_cast_or_null<LabelStmt>(S))\n    return DiagnoseUnusedExprResult(Label->getSubStmt());\n\n  const Expr *E = dyn_cast_or_null<Expr>(S);\n  if (!E)\n    return;\n\n  // If we are in an unevaluated expression context, then there can be no unused\n  // results because the results aren't expected to be used in the first place.\n  if (isUnevaluatedContext())\n    return;\n\n  SourceLocation ExprLoc = E->IgnoreParenImpCasts()->getExprLoc();\n  // In most cases, we don't want to warn if the expression is written in a\n  // macro body, or if the macro comes from a system header. If the offending\n  // expression is a call to a function with the warn_unused_result attribute,\n  // we warn no matter the location. Because of the order in which the various\n  // checks need to happen, we factor out the macro-related test here.\n  bool ShouldSuppress =\n      SourceMgr.isMacroBodyExpansion(ExprLoc) ||\n      SourceMgr.isInSystemMacro(ExprLoc);\n\n  const Expr *WarnExpr;\n  SourceLocation Loc;\n  SourceRange R1, R2;\n  if (!E->isUnusedResultAWarning(WarnExpr, Loc, R1, R2, Context))\n    return;\n\n  // If this is a GNU statement expression expanded from a macro, it is probably\n  // unused because it is a function-like macro that can be used as either an\n  // expression or statement.  Don't warn, because it is almost certainly a\n  // false positive.\n  if (isa<StmtExpr>(E) && Loc.isMacroID())\n    return;\n\n  // Check if this is the UNREFERENCED_PARAMETER from the Microsoft headers.\n  // That macro is frequently used to suppress \"unused parameter\" warnings,\n  // but its implementation makes clang's -Wunused-value fire.  Prevent this.\n  if (isa<ParenExpr>(E->IgnoreImpCasts()) && Loc.isMacroID()) {\n    SourceLocation SpellLoc = Loc;\n    if (findMacroSpelling(SpellLoc, \"UNREFERENCED_PARAMETER\"))\n      return;\n  }\n\n  // Okay, we have an unused result.  Depending on what the base expression is,\n  // we might want to make a more specific diagnostic.  Check for one of these\n  // cases now.\n  unsigned DiagID = diag::warn_unused_expr;\n  if (const FullExpr *Temps = dyn_cast<FullExpr>(E))\n    E = Temps->getSubExpr();\n  if (const CXXBindTemporaryExpr *TempExpr = dyn_cast<CXXBindTemporaryExpr>(E))\n    E = TempExpr->getSubExpr();\n\n  if (DiagnoseUnusedComparison(*this, E))\n    return;\n\n  E = WarnExpr;\n  if (const auto *Cast = dyn_cast<CastExpr>(E))\n    if (Cast->getCastKind() == CK_NoOp ||\n        Cast->getCastKind() == CK_ConstructorConversion)\n      E = Cast->getSubExpr()->IgnoreImpCasts();\n\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E)) {\n    if (E->getType()->isVoidType())\n      return;\n\n    if (DiagnoseNoDiscard(*this, cast_or_null<WarnUnusedResultAttr>(\n                                     CE->getUnusedResultAttr(Context)),\n                          Loc, R1, R2, /*isCtor=*/false))\n      return;\n\n    // If the callee has attribute pure, const, or warn_unused_result, warn with\n    // a more specific message to make it clear what is happening. If the call\n    // is written in a macro body, only warn if it has the warn_unused_result\n    // attribute.\n    if (const Decl *FD = CE->getCalleeDecl()) {\n      if (ShouldSuppress)\n        return;\n      if (FD->hasAttr<PureAttr>()) {\n        Diag(Loc, diag::warn_unused_call) << R1 << R2 << \"pure\";\n        return;\n      }\n      if (FD->hasAttr<ConstAttr>()) {\n        Diag(Loc, diag::warn_unused_call) << R1 << R2 << \"const\";\n        return;\n      }\n    }\n  } else if (const auto *CE = dyn_cast<CXXConstructExpr>(E)) {\n    if (const CXXConstructorDecl *Ctor = CE->getConstructor()) {\n      const auto *A = Ctor->getAttr<WarnUnusedResultAttr>();\n      A = A ? A : Ctor->getParent()->getAttr<WarnUnusedResultAttr>();\n      if (DiagnoseNoDiscard(*this, A, Loc, R1, R2, /*isCtor=*/true))\n        return;\n    }\n  } else if (const auto *ILE = dyn_cast<InitListExpr>(E)) {\n    if (const TagDecl *TD = ILE->getType()->getAsTagDecl()) {\n\n      if (DiagnoseNoDiscard(*this, TD->getAttr<WarnUnusedResultAttr>(), Loc, R1,\n                            R2, /*isCtor=*/false))\n        return;\n    }\n  } else if (ShouldSuppress)\n    return;\n\n  E = WarnExpr;\n  if (const ObjCMessageExpr *ME = dyn_cast<ObjCMessageExpr>(E)) {\n    if (getLangOpts().ObjCAutoRefCount && ME->isDelegateInitCall()) {\n      Diag(Loc, diag::err_arc_unused_init_message) << R1;\n      return;\n    }\n    const ObjCMethodDecl *MD = ME->getMethodDecl();\n    if (MD) {\n      if (DiagnoseNoDiscard(*this, MD->getAttr<WarnUnusedResultAttr>(), Loc, R1,\n                            R2, /*isCtor=*/false))\n        return;\n    }\n  } else if (const PseudoObjectExpr *POE = dyn_cast<PseudoObjectExpr>(E)) {\n    const Expr *Source = POE->getSyntacticForm();\n    // Handle the actually selected call of an OpenMP specialized call.\n    if (LangOpts.OpenMP && isa<CallExpr>(Source) &&\n        POE->getNumSemanticExprs() == 1 &&\n        isa<CallExpr>(POE->getSemanticExpr(0)))\n      return DiagnoseUnusedExprResult(POE->getSemanticExpr(0));\n    if (isa<ObjCSubscriptRefExpr>(Source))\n      DiagID = diag::warn_unused_container_subscript_expr;\n    else\n      DiagID = diag::warn_unused_property_expr;\n  } else if (const CXXFunctionalCastExpr *FC\n                                       = dyn_cast<CXXFunctionalCastExpr>(E)) {\n    const Expr *E = FC->getSubExpr();\n    if (const CXXBindTemporaryExpr *TE = dyn_cast<CXXBindTemporaryExpr>(E))\n      E = TE->getSubExpr();\n    if (isa<CXXTemporaryObjectExpr>(E))\n      return;\n    if (const CXXConstructExpr *CE = dyn_cast<CXXConstructExpr>(E))\n      if (const CXXRecordDecl *RD = CE->getType()->getAsCXXRecordDecl())\n        if (!RD->getAttr<WarnUnusedAttr>())\n          return;\n  }\n  // Diagnose \"(void*) blah\" as a typo for \"(void) blah\".\n  else if (const CStyleCastExpr *CE = dyn_cast<CStyleCastExpr>(E)) {\n    TypeSourceInfo *TI = CE->getTypeInfoAsWritten();\n    QualType T = TI->getType();\n\n    // We really do want to use the non-canonical type here.\n    if (T == Context.VoidPtrTy) {\n      PointerTypeLoc TL = TI->getTypeLoc().castAs<PointerTypeLoc>();\n\n      Diag(Loc, diag::warn_unused_voidptr)\n        << FixItHint::CreateRemoval(TL.getStarLoc());\n      return;\n    }\n  }\n\n  // Tell the user to assign it into a variable to force a volatile load if this\n  // isn't an array.\n  if (E->isGLValue() && E->getType().isVolatileQualified() &&\n      !E->getType()->isArrayType()) {\n    Diag(Loc, diag::warn_unused_volatile) << R1 << R2;\n    return;\n  }\n\n  DiagRuntimeBehavior(Loc, nullptr, PDiag(DiagID) << R1 << R2);\n}\n\nvoid Sema::ActOnStartOfCompoundStmt(bool IsStmtExpr) {\n  PushCompoundScope(IsStmtExpr);\n}\n\nvoid Sema::ActOnAfterCompoundStatementLeadingPragmas() {\n  if (getCurFPFeatures().isFPConstrained()) {\n    FunctionScopeInfo *FSI = getCurFunction();\n    assert(FSI);\n    FSI->setUsesFPIntrin();\n  }\n}\n\nvoid Sema::ActOnFinishOfCompoundStmt() {\n  PopCompoundScope();\n}\n\nsema::CompoundScopeInfo &Sema::getCurCompoundScope() const {\n  return getCurFunction()->CompoundScopes.back();\n}\n\nStmtResult Sema::ActOnCompoundStmt(SourceLocation L, SourceLocation R,\n                                   ArrayRef<Stmt *> Elts, bool isStmtExpr) {\n  const unsigned NumElts = Elts.size();\n\n  // If we're in C89 mode, check that we don't have any decls after stmts.  If\n  // so, emit an extension diagnostic.\n  if (!getLangOpts().C99 && !getLangOpts().CPlusPlus) {\n    // Note that __extension__ can be around a decl.\n    unsigned i = 0;\n    // Skip over all declarations.\n    for (; i != NumElts && isa<DeclStmt>(Elts[i]); ++i)\n      /*empty*/;\n\n    // We found the end of the list or a statement.  Scan for another declstmt.\n    for (; i != NumElts && !isa<DeclStmt>(Elts[i]); ++i)\n      /*empty*/;\n\n    if (i != NumElts) {\n      Decl *D = *cast<DeclStmt>(Elts[i])->decl_begin();\n      Diag(D->getLocation(), diag::ext_mixed_decls_code);\n    }\n  }\n\n  // Check for suspicious empty body (null statement) in `for' and `while'\n  // statements.  Don't do anything for template instantiations, this just adds\n  // noise.\n  if (NumElts != 0 && !CurrentInstantiationScope &&\n      getCurCompoundScope().HasEmptyLoopBodies) {\n    for (unsigned i = 0; i != NumElts - 1; ++i)\n      DiagnoseEmptyLoopBody(Elts[i], Elts[i + 1]);\n  }\n\n  return CompoundStmt::Create(Context, Elts, L, R);\n}\n\nExprResult\nSema::ActOnCaseExpr(SourceLocation CaseLoc, ExprResult Val) {\n  if (!Val.get())\n    return Val;\n\n  if (DiagnoseUnexpandedParameterPack(Val.get()))\n    return ExprError();\n\n  // If we're not inside a switch, let the 'case' statement handling diagnose\n  // this. Just clean up after the expression as best we can.\n  if (getCurFunction()->SwitchStack.empty())\n    return ActOnFinishFullExpr(Val.get(), Val.get()->getExprLoc(), false,\n                               getLangOpts().CPlusPlus11);\n\n  Expr *CondExpr =\n      getCurFunction()->SwitchStack.back().getPointer()->getCond();\n  if (!CondExpr)\n    return ExprError();\n  QualType CondType = CondExpr->getType();\n\n  auto CheckAndFinish = [&](Expr *E) {\n    if (CondType->isDependentType() || E->isTypeDependent())\n      return ExprResult(E);\n\n    if (getLangOpts().CPlusPlus11) {\n      // C++11 [stmt.switch]p2: the constant-expression shall be a converted\n      // constant expression of the promoted type of the switch condition.\n      llvm::APSInt TempVal;\n      return CheckConvertedConstantExpression(E, CondType, TempVal,\n                                              CCEK_CaseValue);\n    }\n\n    ExprResult ER = E;\n    if (!E->isValueDependent())\n      ER = VerifyIntegerConstantExpression(E, AllowFold);\n    if (!ER.isInvalid())\n      ER = DefaultLvalueConversion(ER.get());\n    if (!ER.isInvalid())\n      ER = ImpCastExprToType(ER.get(), CondType, CK_IntegralCast);\n    if (!ER.isInvalid())\n      ER = ActOnFinishFullExpr(ER.get(), ER.get()->getExprLoc(), false);\n    return ER;\n  };\n\n  ExprResult Converted = CorrectDelayedTyposInExpr(\n      Val, /*InitDecl=*/nullptr, /*RecoverUncorrectedTypos=*/false,\n      CheckAndFinish);\n  if (Converted.get() == Val.get())\n    Converted = CheckAndFinish(Val.get());\n  return Converted;\n}\n\nStmtResult\nSema::ActOnCaseStmt(SourceLocation CaseLoc, ExprResult LHSVal,\n                    SourceLocation DotDotDotLoc, ExprResult RHSVal,\n                    SourceLocation ColonLoc) {\n  assert((LHSVal.isInvalid() || LHSVal.get()) && \"missing LHS value\");\n  assert((DotDotDotLoc.isInvalid() ? RHSVal.isUnset()\n                                   : RHSVal.isInvalid() || RHSVal.get()) &&\n         \"missing RHS value\");\n\n  if (getCurFunction()->SwitchStack.empty()) {\n    Diag(CaseLoc, diag::err_case_not_in_switch);\n    return StmtError();\n  }\n\n  if (LHSVal.isInvalid() || RHSVal.isInvalid()) {\n    getCurFunction()->SwitchStack.back().setInt(true);\n    return StmtError();\n  }\n\n  auto *CS = CaseStmt::Create(Context, LHSVal.get(), RHSVal.get(),\n                              CaseLoc, DotDotDotLoc, ColonLoc);\n  getCurFunction()->SwitchStack.back().getPointer()->addSwitchCase(CS);\n  return CS;\n}\n\n/// ActOnCaseStmtBody - This installs a statement as the body of a case.\nvoid Sema::ActOnCaseStmtBody(Stmt *S, Stmt *SubStmt) {\n  cast<CaseStmt>(S)->setSubStmt(SubStmt);\n}\n\nStmtResult\nSema::ActOnDefaultStmt(SourceLocation DefaultLoc, SourceLocation ColonLoc,\n                       Stmt *SubStmt, Scope *CurScope) {\n  if (getCurFunction()->SwitchStack.empty()) {\n    Diag(DefaultLoc, diag::err_default_not_in_switch);\n    return SubStmt;\n  }\n\n  DefaultStmt *DS = new (Context) DefaultStmt(DefaultLoc, ColonLoc, SubStmt);\n  getCurFunction()->SwitchStack.back().getPointer()->addSwitchCase(DS);\n  return DS;\n}\n\nStmtResult\nSema::ActOnLabelStmt(SourceLocation IdentLoc, LabelDecl *TheDecl,\n                     SourceLocation ColonLoc, Stmt *SubStmt) {\n  // If the label was multiply defined, reject it now.\n  if (TheDecl->getStmt()) {\n    Diag(IdentLoc, diag::err_redefinition_of_label) << TheDecl->getDeclName();\n    Diag(TheDecl->getLocation(), diag::note_previous_definition);\n    return SubStmt;\n  }\n\n  // Otherwise, things are good.  Fill in the declaration and return it.\n  LabelStmt *LS = new (Context) LabelStmt(IdentLoc, TheDecl, SubStmt);\n  TheDecl->setStmt(LS);\n  if (!TheDecl->isGnuLocal()) {\n    TheDecl->setLocStart(IdentLoc);\n    if (!TheDecl->isMSAsmLabel()) {\n      // Don't update the location of MS ASM labels.  These will result in\n      // a diagnostic, and changing the location here will mess that up.\n      TheDecl->setLocation(IdentLoc);\n    }\n  }\n  return LS;\n}\n\nStmtResult Sema::ActOnAttributedStmt(SourceLocation AttrLoc,\n                                     ArrayRef<const Attr*> Attrs,\n                                     Stmt *SubStmt) {\n  // Fill in the declaration and return it.\n  AttributedStmt *LS = AttributedStmt::Create(Context, AttrLoc, Attrs, SubStmt);\n  return LS;\n}\n\nnamespace {\nclass CommaVisitor : public EvaluatedExprVisitor<CommaVisitor> {\n  typedef EvaluatedExprVisitor<CommaVisitor> Inherited;\n  Sema &SemaRef;\npublic:\n  CommaVisitor(Sema &SemaRef) : Inherited(SemaRef.Context), SemaRef(SemaRef) {}\n  void VisitBinaryOperator(BinaryOperator *E) {\n    if (E->getOpcode() == BO_Comma)\n      SemaRef.DiagnoseCommaOperator(E->getLHS(), E->getExprLoc());\n    EvaluatedExprVisitor<CommaVisitor>::VisitBinaryOperator(E);\n  }\n};\n}\n\nStmtResult Sema::ActOnIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                             SourceLocation LParenLoc, Stmt *InitStmt,\n                             ConditionResult Cond, SourceLocation RParenLoc,\n                             Stmt *thenStmt, SourceLocation ElseLoc,\n                             Stmt *elseStmt) {\n  if (Cond.isInvalid())\n    Cond = ConditionResult(\n        *this, nullptr,\n        MakeFullExpr(new (Context) OpaqueValueExpr(SourceLocation(),\n                                                   Context.BoolTy, VK_RValue),\n                     IfLoc),\n        false);\n\n  Expr *CondExpr = Cond.get().second;\n  // Only call the CommaVisitor when not C89 due to differences in scope flags.\n  if ((getLangOpts().C99 || getLangOpts().CPlusPlus) &&\n      !Diags.isIgnored(diag::warn_comma_operator, CondExpr->getExprLoc()))\n    CommaVisitor(*this).Visit(CondExpr);\n\n  if (!elseStmt)\n    DiagnoseEmptyStmtBody(CondExpr->getEndLoc(), thenStmt,\n                          diag::warn_empty_if_body);\n\n  if (IsConstexpr) {\n    auto DiagnoseLikelihood = [&](const Stmt *S) {\n      if (const Attr *A = Stmt::getLikelihoodAttr(S)) {\n        Diags.Report(A->getLocation(),\n                     diag::warn_attribute_has_no_effect_on_if_constexpr)\n            << A << A->getRange();\n        Diags.Report(IfLoc,\n                     diag::note_attribute_has_no_effect_on_if_constexpr_here)\n            << SourceRange(IfLoc, LParenLoc.getLocWithOffset(-1));\n      }\n    };\n    DiagnoseLikelihood(thenStmt);\n    DiagnoseLikelihood(elseStmt);\n  } else {\n    std::tuple<bool, const Attr *, const Attr *> LHC =\n        Stmt::determineLikelihoodConflict(thenStmt, elseStmt);\n    if (std::get<0>(LHC)) {\n      const Attr *ThenAttr = std::get<1>(LHC);\n      const Attr *ElseAttr = std::get<2>(LHC);\n      Diags.Report(ThenAttr->getLocation(),\n                   diag::warn_attributes_likelihood_ifstmt_conflict)\n          << ThenAttr << ThenAttr->getRange();\n      Diags.Report(ElseAttr->getLocation(), diag::note_conflicting_attribute)\n          << ElseAttr << ElseAttr->getRange();\n    }\n  }\n\n  return BuildIfStmt(IfLoc, IsConstexpr, LParenLoc, InitStmt, Cond, RParenLoc,\n                     thenStmt, ElseLoc, elseStmt);\n}\n\nStmtResult Sema::BuildIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                             SourceLocation LParenLoc, Stmt *InitStmt,\n                             ConditionResult Cond, SourceLocation RParenLoc,\n                             Stmt *thenStmt, SourceLocation ElseLoc,\n                             Stmt *elseStmt) {\n  if (Cond.isInvalid())\n    return StmtError();\n\n  if (IsConstexpr || isa<ObjCAvailabilityCheckExpr>(Cond.get().second))\n    setFunctionHasBranchProtectedScope();\n\n  return IfStmt::Create(Context, IfLoc, IsConstexpr, InitStmt, Cond.get().first,\n                        Cond.get().second, LParenLoc, RParenLoc, thenStmt,\n                        ElseLoc, elseStmt);\n}\n\nnamespace {\n  struct CaseCompareFunctor {\n    bool operator()(const std::pair<llvm::APSInt, CaseStmt*> &LHS,\n                    const llvm::APSInt &RHS) {\n      return LHS.first < RHS;\n    }\n    bool operator()(const std::pair<llvm::APSInt, CaseStmt*> &LHS,\n                    const std::pair<llvm::APSInt, CaseStmt*> &RHS) {\n      return LHS.first < RHS.first;\n    }\n    bool operator()(const llvm::APSInt &LHS,\n                    const std::pair<llvm::APSInt, CaseStmt*> &RHS) {\n      return LHS < RHS.first;\n    }\n  };\n}\n\n/// CmpCaseVals - Comparison predicate for sorting case values.\n///\nstatic bool CmpCaseVals(const std::pair<llvm::APSInt, CaseStmt*>& lhs,\n                        const std::pair<llvm::APSInt, CaseStmt*>& rhs) {\n  if (lhs.first < rhs.first)\n    return true;\n\n  if (lhs.first == rhs.first &&\n      lhs.second->getCaseLoc() < rhs.second->getCaseLoc())\n    return true;\n  return false;\n}\n\n/// CmpEnumVals - Comparison predicate for sorting enumeration values.\n///\nstatic bool CmpEnumVals(const std::pair<llvm::APSInt, EnumConstantDecl*>& lhs,\n                        const std::pair<llvm::APSInt, EnumConstantDecl*>& rhs)\n{\n  return lhs.first < rhs.first;\n}\n\n/// EqEnumVals - Comparison preficate for uniqing enumeration values.\n///\nstatic bool EqEnumVals(const std::pair<llvm::APSInt, EnumConstantDecl*>& lhs,\n                       const std::pair<llvm::APSInt, EnumConstantDecl*>& rhs)\n{\n  return lhs.first == rhs.first;\n}\n\n/// GetTypeBeforeIntegralPromotion - Returns the pre-promotion type of\n/// potentially integral-promoted expression @p expr.\nstatic QualType GetTypeBeforeIntegralPromotion(const Expr *&E) {\n  if (const auto *FE = dyn_cast<FullExpr>(E))\n    E = FE->getSubExpr();\n  while (const auto *ImpCast = dyn_cast<ImplicitCastExpr>(E)) {\n    if (ImpCast->getCastKind() != CK_IntegralCast) break;\n    E = ImpCast->getSubExpr();\n  }\n  return E->getType();\n}\n\nExprResult Sema::CheckSwitchCondition(SourceLocation SwitchLoc, Expr *Cond) {\n  class SwitchConvertDiagnoser : public ICEConvertDiagnoser {\n    Expr *Cond;\n\n  public:\n    SwitchConvertDiagnoser(Expr *Cond)\n        : ICEConvertDiagnoser(/*AllowScopedEnumerations*/true, false, true),\n          Cond(Cond) {}\n\n    SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,\n                                         QualType T) override {\n      return S.Diag(Loc, diag::err_typecheck_statement_requires_integer) << T;\n    }\n\n    SemaDiagnosticBuilder diagnoseIncomplete(\n        Sema &S, SourceLocation Loc, QualType T) override {\n      return S.Diag(Loc, diag::err_switch_incomplete_class_type)\n               << T << Cond->getSourceRange();\n    }\n\n    SemaDiagnosticBuilder diagnoseExplicitConv(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) override {\n      return S.Diag(Loc, diag::err_switch_explicit_conversion) << T << ConvTy;\n    }\n\n    SemaDiagnosticBuilder noteExplicitConv(\n        Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {\n      return S.Diag(Conv->getLocation(), diag::note_switch_conversion)\n        << ConvTy->isEnumeralType() << ConvTy;\n    }\n\n    SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,\n                                            QualType T) override {\n      return S.Diag(Loc, diag::err_switch_multiple_conversions) << T;\n    }\n\n    SemaDiagnosticBuilder noteAmbiguous(\n        Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {\n      return S.Diag(Conv->getLocation(), diag::note_switch_conversion)\n      << ConvTy->isEnumeralType() << ConvTy;\n    }\n\n    SemaDiagnosticBuilder diagnoseConversion(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) override {\n      llvm_unreachable(\"conversion functions are permitted\");\n    }\n  } SwitchDiagnoser(Cond);\n\n  ExprResult CondResult =\n      PerformContextualImplicitConversion(SwitchLoc, Cond, SwitchDiagnoser);\n  if (CondResult.isInvalid())\n    return ExprError();\n\n  // FIXME: PerformContextualImplicitConversion doesn't always tell us if it\n  // failed and produced a diagnostic.\n  Cond = CondResult.get();\n  if (!Cond->isTypeDependent() &&\n      !Cond->getType()->isIntegralOrEnumerationType())\n    return ExprError();\n\n  // C99 6.8.4.2p5 - Integer promotions are performed on the controlling expr.\n  return UsualUnaryConversions(Cond);\n}\n\nStmtResult Sema::ActOnStartOfSwitchStmt(SourceLocation SwitchLoc,\n                                        SourceLocation LParenLoc,\n                                        Stmt *InitStmt, ConditionResult Cond,\n                                        SourceLocation RParenLoc) {\n  Expr *CondExpr = Cond.get().second;\n  assert((Cond.isInvalid() || CondExpr) && \"switch with no condition\");\n\n  if (CondExpr && !CondExpr->isTypeDependent()) {\n    // We have already converted the expression to an integral or enumeration\n    // type, when we parsed the switch condition. There are cases where we don't\n    // have an appropriate type, e.g. a typo-expr Cond was corrected to an\n    // inappropriate-type expr, we just return an error.\n    if (!CondExpr->getType()->isIntegralOrEnumerationType())\n      return StmtError();\n    if (CondExpr->isKnownToHaveBooleanValue()) {\n      // switch(bool_expr) {...} is often a programmer error, e.g.\n      //   switch(n && mask) { ... }  // Doh - should be \"n & mask\".\n      // One can always use an if statement instead of switch(bool_expr).\n      Diag(SwitchLoc, diag::warn_bool_switch_condition)\n          << CondExpr->getSourceRange();\n    }\n  }\n\n  setFunctionHasBranchIntoScope();\n\n  auto *SS = SwitchStmt::Create(Context, InitStmt, Cond.get().first, CondExpr,\n                                LParenLoc, RParenLoc);\n  getCurFunction()->SwitchStack.push_back(\n      FunctionScopeInfo::SwitchInfo(SS, false));\n  return SS;\n}\n\nstatic void AdjustAPSInt(llvm::APSInt &Val, unsigned BitWidth, bool IsSigned) {\n  Val = Val.extOrTrunc(BitWidth);\n  Val.setIsSigned(IsSigned);\n}\n\n/// Check the specified case value is in range for the given unpromoted switch\n/// type.\nstatic void checkCaseValue(Sema &S, SourceLocation Loc, const llvm::APSInt &Val,\n                           unsigned UnpromotedWidth, bool UnpromotedSign) {\n  // In C++11 onwards, this is checked by the language rules.\n  if (S.getLangOpts().CPlusPlus11)\n    return;\n\n  // If the case value was signed and negative and the switch expression is\n  // unsigned, don't bother to warn: this is implementation-defined behavior.\n  // FIXME: Introduce a second, default-ignored warning for this case?\n  if (UnpromotedWidth < Val.getBitWidth()) {\n    llvm::APSInt ConvVal(Val);\n    AdjustAPSInt(ConvVal, UnpromotedWidth, UnpromotedSign);\n    AdjustAPSInt(ConvVal, Val.getBitWidth(), Val.isSigned());\n    // FIXME: Use different diagnostics for overflow  in conversion to promoted\n    // type versus \"switch expression cannot have this value\". Use proper\n    // IntRange checking rather than just looking at the unpromoted type here.\n    if (ConvVal != Val)\n      S.Diag(Loc, diag::warn_case_value_overflow) << Val.toString(10)\n                                                  << ConvVal.toString(10);\n  }\n}\n\ntypedef SmallVector<std::pair<llvm::APSInt, EnumConstantDecl*>, 64> EnumValsTy;\n\n/// Returns true if we should emit a diagnostic about this case expression not\n/// being a part of the enum used in the switch controlling expression.\nstatic bool ShouldDiagnoseSwitchCaseNotInEnum(const Sema &S,\n                                              const EnumDecl *ED,\n                                              const Expr *CaseExpr,\n                                              EnumValsTy::iterator &EI,\n                                              EnumValsTy::iterator &EIEnd,\n                                              const llvm::APSInt &Val) {\n  if (!ED->isClosed())\n    return false;\n\n  if (const DeclRefExpr *DRE =\n          dyn_cast<DeclRefExpr>(CaseExpr->IgnoreParenImpCasts())) {\n    if (const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl())) {\n      QualType VarType = VD->getType();\n      QualType EnumType = S.Context.getTypeDeclType(ED);\n      if (VD->hasGlobalStorage() && VarType.isConstQualified() &&\n          S.Context.hasSameUnqualifiedType(EnumType, VarType))\n        return false;\n    }\n  }\n\n  if (ED->hasAttr<FlagEnumAttr>())\n    return !S.IsValueInFlagEnum(ED, Val, false);\n\n  while (EI != EIEnd && EI->first < Val)\n    EI++;\n\n  if (EI != EIEnd && EI->first == Val)\n    return false;\n\n  return true;\n}\n\nstatic void checkEnumTypesInSwitchStmt(Sema &S, const Expr *Cond,\n                                       const Expr *Case) {\n  QualType CondType = Cond->getType();\n  QualType CaseType = Case->getType();\n\n  const EnumType *CondEnumType = CondType->getAs<EnumType>();\n  const EnumType *CaseEnumType = CaseType->getAs<EnumType>();\n  if (!CondEnumType || !CaseEnumType)\n    return;\n\n  // Ignore anonymous enums.\n  if (!CondEnumType->getDecl()->getIdentifier() &&\n      !CondEnumType->getDecl()->getTypedefNameForAnonDecl())\n    return;\n  if (!CaseEnumType->getDecl()->getIdentifier() &&\n      !CaseEnumType->getDecl()->getTypedefNameForAnonDecl())\n    return;\n\n  if (S.Context.hasSameUnqualifiedType(CondType, CaseType))\n    return;\n\n  S.Diag(Case->getExprLoc(), diag::warn_comparison_of_mixed_enum_types_switch)\n      << CondType << CaseType << Cond->getSourceRange()\n      << Case->getSourceRange();\n}\n\nStmtResult\nSema::ActOnFinishSwitchStmt(SourceLocation SwitchLoc, Stmt *Switch,\n                            Stmt *BodyStmt) {\n  SwitchStmt *SS = cast<SwitchStmt>(Switch);\n  bool CaseListIsIncomplete = getCurFunction()->SwitchStack.back().getInt();\n  assert(SS == getCurFunction()->SwitchStack.back().getPointer() &&\n         \"switch stack missing push/pop!\");\n\n  getCurFunction()->SwitchStack.pop_back();\n\n  if (!BodyStmt) return StmtError();\n  SS->setBody(BodyStmt, SwitchLoc);\n\n  Expr *CondExpr = SS->getCond();\n  if (!CondExpr) return StmtError();\n\n  QualType CondType = CondExpr->getType();\n\n  // C++ 6.4.2.p2:\n  // Integral promotions are performed (on the switch condition).\n  //\n  // A case value unrepresentable by the original switch condition\n  // type (before the promotion) doesn't make sense, even when it can\n  // be represented by the promoted type.  Therefore we need to find\n  // the pre-promotion type of the switch condition.\n  const Expr *CondExprBeforePromotion = CondExpr;\n  QualType CondTypeBeforePromotion =\n      GetTypeBeforeIntegralPromotion(CondExprBeforePromotion);\n\n  // Get the bitwidth of the switched-on value after promotions. We must\n  // convert the integer case values to this width before comparison.\n  bool HasDependentValue\n    = CondExpr->isTypeDependent() || CondExpr->isValueDependent();\n  unsigned CondWidth = HasDependentValue ? 0 : Context.getIntWidth(CondType);\n  bool CondIsSigned = CondType->isSignedIntegerOrEnumerationType();\n\n  // Get the width and signedness that the condition might actually have, for\n  // warning purposes.\n  // FIXME: Grab an IntRange for the condition rather than using the unpromoted\n  // type.\n  unsigned CondWidthBeforePromotion\n    = HasDependentValue ? 0 : Context.getIntWidth(CondTypeBeforePromotion);\n  bool CondIsSignedBeforePromotion\n    = CondTypeBeforePromotion->isSignedIntegerOrEnumerationType();\n\n  // Accumulate all of the case values in a vector so that we can sort them\n  // and detect duplicates.  This vector contains the APInt for the case after\n  // it has been converted to the condition type.\n  typedef SmallVector<std::pair<llvm::APSInt, CaseStmt*>, 64> CaseValsTy;\n  CaseValsTy CaseVals;\n\n  // Keep track of any GNU case ranges we see.  The APSInt is the low value.\n  typedef std::vector<std::pair<llvm::APSInt, CaseStmt*> > CaseRangesTy;\n  CaseRangesTy CaseRanges;\n\n  DefaultStmt *TheDefaultStmt = nullptr;\n\n  bool CaseListIsErroneous = false;\n\n  for (SwitchCase *SC = SS->getSwitchCaseList(); SC && !HasDependentValue;\n       SC = SC->getNextSwitchCase()) {\n\n    if (DefaultStmt *DS = dyn_cast<DefaultStmt>(SC)) {\n      if (TheDefaultStmt) {\n        Diag(DS->getDefaultLoc(), diag::err_multiple_default_labels_defined);\n        Diag(TheDefaultStmt->getDefaultLoc(), diag::note_duplicate_case_prev);\n\n        // FIXME: Remove the default statement from the switch block so that\n        // we'll return a valid AST.  This requires recursing down the AST and\n        // finding it, not something we are set up to do right now.  For now,\n        // just lop the entire switch stmt out of the AST.\n        CaseListIsErroneous = true;\n      }\n      TheDefaultStmt = DS;\n\n    } else {\n      CaseStmt *CS = cast<CaseStmt>(SC);\n\n      Expr *Lo = CS->getLHS();\n\n      if (Lo->isValueDependent()) {\n        HasDependentValue = true;\n        break;\n      }\n\n      // We already verified that the expression has a constant value;\n      // get that value (prior to conversions).\n      const Expr *LoBeforePromotion = Lo;\n      GetTypeBeforeIntegralPromotion(LoBeforePromotion);\n      llvm::APSInt LoVal = LoBeforePromotion->EvaluateKnownConstInt(Context);\n\n      // Check the unconverted value is within the range of possible values of\n      // the switch expression.\n      checkCaseValue(*this, Lo->getBeginLoc(), LoVal, CondWidthBeforePromotion,\n                     CondIsSignedBeforePromotion);\n\n      // FIXME: This duplicates the check performed for warn_not_in_enum below.\n      checkEnumTypesInSwitchStmt(*this, CondExprBeforePromotion,\n                                 LoBeforePromotion);\n\n      // Convert the value to the same width/sign as the condition.\n      AdjustAPSInt(LoVal, CondWidth, CondIsSigned);\n\n      // If this is a case range, remember it in CaseRanges, otherwise CaseVals.\n      if (CS->getRHS()) {\n        if (CS->getRHS()->isValueDependent()) {\n          HasDependentValue = true;\n          break;\n        }\n        CaseRanges.push_back(std::make_pair(LoVal, CS));\n      } else\n        CaseVals.push_back(std::make_pair(LoVal, CS));\n    }\n  }\n\n  if (!HasDependentValue) {\n    // If we don't have a default statement, check whether the\n    // condition is constant.\n    llvm::APSInt ConstantCondValue;\n    bool HasConstantCond = false;\n    if (!TheDefaultStmt) {\n      Expr::EvalResult Result;\n      HasConstantCond = CondExpr->EvaluateAsInt(Result, Context,\n                                                Expr::SE_AllowSideEffects);\n      if (Result.Val.isInt())\n        ConstantCondValue = Result.Val.getInt();\n      assert(!HasConstantCond ||\n             (ConstantCondValue.getBitWidth() == CondWidth &&\n              ConstantCondValue.isSigned() == CondIsSigned));\n    }\n    bool ShouldCheckConstantCond = HasConstantCond;\n\n    // Sort all the scalar case values so we can easily detect duplicates.\n    llvm::stable_sort(CaseVals, CmpCaseVals);\n\n    if (!CaseVals.empty()) {\n      for (unsigned i = 0, e = CaseVals.size(); i != e; ++i) {\n        if (ShouldCheckConstantCond &&\n            CaseVals[i].first == ConstantCondValue)\n          ShouldCheckConstantCond = false;\n\n        if (i != 0 && CaseVals[i].first == CaseVals[i-1].first) {\n          // If we have a duplicate, report it.\n          // First, determine if either case value has a name\n          StringRef PrevString, CurrString;\n          Expr *PrevCase = CaseVals[i-1].second->getLHS()->IgnoreParenCasts();\n          Expr *CurrCase = CaseVals[i].second->getLHS()->IgnoreParenCasts();\n          if (DeclRefExpr *DeclRef = dyn_cast<DeclRefExpr>(PrevCase)) {\n            PrevString = DeclRef->getDecl()->getName();\n          }\n          if (DeclRefExpr *DeclRef = dyn_cast<DeclRefExpr>(CurrCase)) {\n            CurrString = DeclRef->getDecl()->getName();\n          }\n          SmallString<16> CaseValStr;\n          CaseVals[i-1].first.toString(CaseValStr);\n\n          if (PrevString == CurrString)\n            Diag(CaseVals[i].second->getLHS()->getBeginLoc(),\n                 diag::err_duplicate_case)\n                << (PrevString.empty() ? StringRef(CaseValStr) : PrevString);\n          else\n            Diag(CaseVals[i].second->getLHS()->getBeginLoc(),\n                 diag::err_duplicate_case_differing_expr)\n                << (PrevString.empty() ? StringRef(CaseValStr) : PrevString)\n                << (CurrString.empty() ? StringRef(CaseValStr) : CurrString)\n                << CaseValStr;\n\n          Diag(CaseVals[i - 1].second->getLHS()->getBeginLoc(),\n               diag::note_duplicate_case_prev);\n          // FIXME: We really want to remove the bogus case stmt from the\n          // substmt, but we have no way to do this right now.\n          CaseListIsErroneous = true;\n        }\n      }\n    }\n\n    // Detect duplicate case ranges, which usually don't exist at all in\n    // the first place.\n    if (!CaseRanges.empty()) {\n      // Sort all the case ranges by their low value so we can easily detect\n      // overlaps between ranges.\n      llvm::stable_sort(CaseRanges);\n\n      // Scan the ranges, computing the high values and removing empty ranges.\n      std::vector<llvm::APSInt> HiVals;\n      for (unsigned i = 0, e = CaseRanges.size(); i != e; ++i) {\n        llvm::APSInt &LoVal = CaseRanges[i].first;\n        CaseStmt *CR = CaseRanges[i].second;\n        Expr *Hi = CR->getRHS();\n\n        const Expr *HiBeforePromotion = Hi;\n        GetTypeBeforeIntegralPromotion(HiBeforePromotion);\n        llvm::APSInt HiVal = HiBeforePromotion->EvaluateKnownConstInt(Context);\n\n        // Check the unconverted value is within the range of possible values of\n        // the switch expression.\n        checkCaseValue(*this, Hi->getBeginLoc(), HiVal,\n                       CondWidthBeforePromotion, CondIsSignedBeforePromotion);\n\n        // Convert the value to the same width/sign as the condition.\n        AdjustAPSInt(HiVal, CondWidth, CondIsSigned);\n\n        // If the low value is bigger than the high value, the case is empty.\n        if (LoVal > HiVal) {\n          Diag(CR->getLHS()->getBeginLoc(), diag::warn_case_empty_range)\n              << SourceRange(CR->getLHS()->getBeginLoc(), Hi->getEndLoc());\n          CaseRanges.erase(CaseRanges.begin()+i);\n          --i;\n          --e;\n          continue;\n        }\n\n        if (ShouldCheckConstantCond &&\n            LoVal <= ConstantCondValue &&\n            ConstantCondValue <= HiVal)\n          ShouldCheckConstantCond = false;\n\n        HiVals.push_back(HiVal);\n      }\n\n      // Rescan the ranges, looking for overlap with singleton values and other\n      // ranges.  Since the range list is sorted, we only need to compare case\n      // ranges with their neighbors.\n      for (unsigned i = 0, e = CaseRanges.size(); i != e; ++i) {\n        llvm::APSInt &CRLo = CaseRanges[i].first;\n        llvm::APSInt &CRHi = HiVals[i];\n        CaseStmt *CR = CaseRanges[i].second;\n\n        // Check to see whether the case range overlaps with any\n        // singleton cases.\n        CaseStmt *OverlapStmt = nullptr;\n        llvm::APSInt OverlapVal(32);\n\n        // Find the smallest value >= the lower bound.  If I is in the\n        // case range, then we have overlap.\n        CaseValsTy::iterator I =\n            llvm::lower_bound(CaseVals, CRLo, CaseCompareFunctor());\n        if (I != CaseVals.end() && I->first < CRHi) {\n          OverlapVal  = I->first;   // Found overlap with scalar.\n          OverlapStmt = I->second;\n        }\n\n        // Find the smallest value bigger than the upper bound.\n        I = std::upper_bound(I, CaseVals.end(), CRHi, CaseCompareFunctor());\n        if (I != CaseVals.begin() && (I-1)->first >= CRLo) {\n          OverlapVal  = (I-1)->first;      // Found overlap with scalar.\n          OverlapStmt = (I-1)->second;\n        }\n\n        // Check to see if this case stmt overlaps with the subsequent\n        // case range.\n        if (i && CRLo <= HiVals[i-1]) {\n          OverlapVal  = HiVals[i-1];       // Found overlap with range.\n          OverlapStmt = CaseRanges[i-1].second;\n        }\n\n        if (OverlapStmt) {\n          // If we have a duplicate, report it.\n          Diag(CR->getLHS()->getBeginLoc(), diag::err_duplicate_case)\n              << OverlapVal.toString(10);\n          Diag(OverlapStmt->getLHS()->getBeginLoc(),\n               diag::note_duplicate_case_prev);\n          // FIXME: We really want to remove the bogus case stmt from the\n          // substmt, but we have no way to do this right now.\n          CaseListIsErroneous = true;\n        }\n      }\n    }\n\n    // Complain if we have a constant condition and we didn't find a match.\n    if (!CaseListIsErroneous && !CaseListIsIncomplete &&\n        ShouldCheckConstantCond) {\n      // TODO: it would be nice if we printed enums as enums, chars as\n      // chars, etc.\n      Diag(CondExpr->getExprLoc(), diag::warn_missing_case_for_condition)\n        << ConstantCondValue.toString(10)\n        << CondExpr->getSourceRange();\n    }\n\n    // Check to see if switch is over an Enum and handles all of its\n    // values.  We only issue a warning if there is not 'default:', but\n    // we still do the analysis to preserve this information in the AST\n    // (which can be used by flow-based analyes).\n    //\n    const EnumType *ET = CondTypeBeforePromotion->getAs<EnumType>();\n\n    // If switch has default case, then ignore it.\n    if (!CaseListIsErroneous && !CaseListIsIncomplete && !HasConstantCond &&\n        ET && ET->getDecl()->isCompleteDefinition()) {\n      const EnumDecl *ED = ET->getDecl();\n      EnumValsTy EnumVals;\n\n      // Gather all enum values, set their type and sort them,\n      // allowing easier comparison with CaseVals.\n      for (auto *EDI : ED->enumerators()) {\n        llvm::APSInt Val = EDI->getInitVal();\n        AdjustAPSInt(Val, CondWidth, CondIsSigned);\n        EnumVals.push_back(std::make_pair(Val, EDI));\n      }\n      llvm::stable_sort(EnumVals, CmpEnumVals);\n      auto EI = EnumVals.begin(), EIEnd =\n        std::unique(EnumVals.begin(), EnumVals.end(), EqEnumVals);\n\n      // See which case values aren't in enum.\n      for (CaseValsTy::const_iterator CI = CaseVals.begin();\n          CI != CaseVals.end(); CI++) {\n        Expr *CaseExpr = CI->second->getLHS();\n        if (ShouldDiagnoseSwitchCaseNotInEnum(*this, ED, CaseExpr, EI, EIEnd,\n                                              CI->first))\n          Diag(CaseExpr->getExprLoc(), diag::warn_not_in_enum)\n            << CondTypeBeforePromotion;\n      }\n\n      // See which of case ranges aren't in enum\n      EI = EnumVals.begin();\n      for (CaseRangesTy::const_iterator RI = CaseRanges.begin();\n          RI != CaseRanges.end(); RI++) {\n        Expr *CaseExpr = RI->second->getLHS();\n        if (ShouldDiagnoseSwitchCaseNotInEnum(*this, ED, CaseExpr, EI, EIEnd,\n                                              RI->first))\n          Diag(CaseExpr->getExprLoc(), diag::warn_not_in_enum)\n            << CondTypeBeforePromotion;\n\n        llvm::APSInt Hi =\n          RI->second->getRHS()->EvaluateKnownConstInt(Context);\n        AdjustAPSInt(Hi, CondWidth, CondIsSigned);\n\n        CaseExpr = RI->second->getRHS();\n        if (ShouldDiagnoseSwitchCaseNotInEnum(*this, ED, CaseExpr, EI, EIEnd,\n                                              Hi))\n          Diag(CaseExpr->getExprLoc(), diag::warn_not_in_enum)\n            << CondTypeBeforePromotion;\n      }\n\n      // Check which enum vals aren't in switch\n      auto CI = CaseVals.begin();\n      auto RI = CaseRanges.begin();\n      bool hasCasesNotInSwitch = false;\n\n      SmallVector<DeclarationName,8> UnhandledNames;\n\n      for (EI = EnumVals.begin(); EI != EIEnd; EI++) {\n        // Don't warn about omitted unavailable EnumConstantDecls.\n        switch (EI->second->getAvailability()) {\n        case AR_Deprecated:\n          // Omitting a deprecated constant is ok; it should never materialize.\n        case AR_Unavailable:\n          continue;\n\n        case AR_NotYetIntroduced:\n          // Partially available enum constants should be present. Note that we\n          // suppress -Wunguarded-availability diagnostics for such uses.\n        case AR_Available:\n          break;\n        }\n\n        if (EI->second->hasAttr<UnusedAttr>())\n          continue;\n\n        // Drop unneeded case values\n        while (CI != CaseVals.end() && CI->first < EI->first)\n          CI++;\n\n        if (CI != CaseVals.end() && CI->first == EI->first)\n          continue;\n\n        // Drop unneeded case ranges\n        for (; RI != CaseRanges.end(); RI++) {\n          llvm::APSInt Hi =\n            RI->second->getRHS()->EvaluateKnownConstInt(Context);\n          AdjustAPSInt(Hi, CondWidth, CondIsSigned);\n          if (EI->first <= Hi)\n            break;\n        }\n\n        if (RI == CaseRanges.end() || EI->first < RI->first) {\n          hasCasesNotInSwitch = true;\n          UnhandledNames.push_back(EI->second->getDeclName());\n        }\n      }\n\n      if (TheDefaultStmt && UnhandledNames.empty() && ED->isClosedNonFlag())\n        Diag(TheDefaultStmt->getDefaultLoc(), diag::warn_unreachable_default);\n\n      // Produce a nice diagnostic if multiple values aren't handled.\n      if (!UnhandledNames.empty()) {\n        auto DB = Diag(CondExpr->getExprLoc(), TheDefaultStmt\n                                                   ? diag::warn_def_missing_case\n                                                   : diag::warn_missing_case)\n                  << (int)UnhandledNames.size();\n\n        for (size_t I = 0, E = std::min(UnhandledNames.size(), (size_t)3);\n             I != E; ++I)\n          DB << UnhandledNames[I];\n      }\n\n      if (!hasCasesNotInSwitch)\n        SS->setAllEnumCasesCovered();\n    }\n  }\n\n  if (BodyStmt)\n    DiagnoseEmptyStmtBody(CondExpr->getEndLoc(), BodyStmt,\n                          diag::warn_empty_switch_body);\n\n  // FIXME: If the case list was broken is some way, we don't have a good system\n  // to patch it up.  Instead, just return the whole substmt as broken.\n  if (CaseListIsErroneous)\n    return StmtError();\n\n  return SS;\n}\n\nvoid\nSema::DiagnoseAssignmentEnum(QualType DstType, QualType SrcType,\n                             Expr *SrcExpr) {\n  if (Diags.isIgnored(diag::warn_not_in_enum_assignment, SrcExpr->getExprLoc()))\n    return;\n\n  if (const EnumType *ET = DstType->getAs<EnumType>())\n    if (!Context.hasSameUnqualifiedType(SrcType, DstType) &&\n        SrcType->isIntegerType()) {\n      if (!SrcExpr->isTypeDependent() && !SrcExpr->isValueDependent() &&\n          SrcExpr->isIntegerConstantExpr(Context)) {\n        // Get the bitwidth of the enum value before promotions.\n        unsigned DstWidth = Context.getIntWidth(DstType);\n        bool DstIsSigned = DstType->isSignedIntegerOrEnumerationType();\n\n        llvm::APSInt RhsVal = SrcExpr->EvaluateKnownConstInt(Context);\n        AdjustAPSInt(RhsVal, DstWidth, DstIsSigned);\n        const EnumDecl *ED = ET->getDecl();\n\n        if (!ED->isClosed())\n          return;\n\n        if (ED->hasAttr<FlagEnumAttr>()) {\n          if (!IsValueInFlagEnum(ED, RhsVal, true))\n            Diag(SrcExpr->getExprLoc(), diag::warn_not_in_enum_assignment)\n              << DstType.getUnqualifiedType();\n        } else {\n          typedef SmallVector<std::pair<llvm::APSInt, EnumConstantDecl *>, 64>\n              EnumValsTy;\n          EnumValsTy EnumVals;\n\n          // Gather all enum values, set their type and sort them,\n          // allowing easier comparison with rhs constant.\n          for (auto *EDI : ED->enumerators()) {\n            llvm::APSInt Val = EDI->getInitVal();\n            AdjustAPSInt(Val, DstWidth, DstIsSigned);\n            EnumVals.push_back(std::make_pair(Val, EDI));\n          }\n          if (EnumVals.empty())\n            return;\n          llvm::stable_sort(EnumVals, CmpEnumVals);\n          EnumValsTy::iterator EIend =\n              std::unique(EnumVals.begin(), EnumVals.end(), EqEnumVals);\n\n          // See which values aren't in the enum.\n          EnumValsTy::const_iterator EI = EnumVals.begin();\n          while (EI != EIend && EI->first < RhsVal)\n            EI++;\n          if (EI == EIend || EI->first != RhsVal) {\n            Diag(SrcExpr->getExprLoc(), diag::warn_not_in_enum_assignment)\n                << DstType.getUnqualifiedType();\n          }\n        }\n      }\n    }\n}\n\nStmtResult Sema::ActOnWhileStmt(SourceLocation WhileLoc,\n                                SourceLocation LParenLoc, ConditionResult Cond,\n                                SourceLocation RParenLoc, Stmt *Body) {\n  if (Cond.isInvalid())\n    return StmtError();\n\n  auto CondVal = Cond.get();\n  CheckBreakContinueBinding(CondVal.second);\n\n  if (CondVal.second &&\n      !Diags.isIgnored(diag::warn_comma_operator, CondVal.second->getExprLoc()))\n    CommaVisitor(*this).Visit(CondVal.second);\n\n  if (isa<NullStmt>(Body))\n    getCurCompoundScope().setHasEmptyLoopBodies();\n\n  return WhileStmt::Create(Context, CondVal.first, CondVal.second, Body,\n                           WhileLoc, LParenLoc, RParenLoc);\n}\n\nStmtResult\nSema::ActOnDoStmt(SourceLocation DoLoc, Stmt *Body,\n                  SourceLocation WhileLoc, SourceLocation CondLParen,\n                  Expr *Cond, SourceLocation CondRParen) {\n  assert(Cond && \"ActOnDoStmt(): missing expression\");\n\n  CheckBreakContinueBinding(Cond);\n  ExprResult CondResult = CheckBooleanCondition(DoLoc, Cond);\n  if (CondResult.isInvalid())\n    return StmtError();\n  Cond = CondResult.get();\n\n  CondResult = ActOnFinishFullExpr(Cond, DoLoc, /*DiscardedValue*/ false);\n  if (CondResult.isInvalid())\n    return StmtError();\n  Cond = CondResult.get();\n\n  // Only call the CommaVisitor for C89 due to differences in scope flags.\n  if (Cond && !getLangOpts().C99 && !getLangOpts().CPlusPlus &&\n      !Diags.isIgnored(diag::warn_comma_operator, Cond->getExprLoc()))\n    CommaVisitor(*this).Visit(Cond);\n\n  return new (Context) DoStmt(Body, Cond, DoLoc, WhileLoc, CondRParen);\n}\n\nnamespace {\n  // Use SetVector since the diagnostic cares about the ordering of the Decl's.\n  using DeclSetVector =\n      llvm::SetVector<VarDecl *, llvm::SmallVector<VarDecl *, 8>,\n                      llvm::SmallPtrSet<VarDecl *, 8>>;\n\n  // This visitor will traverse a conditional statement and store all\n  // the evaluated decls into a vector.  Simple is set to true if none\n  // of the excluded constructs are used.\n  class DeclExtractor : public EvaluatedExprVisitor<DeclExtractor> {\n    DeclSetVector &Decls;\n    SmallVectorImpl<SourceRange> &Ranges;\n    bool Simple;\n  public:\n    typedef EvaluatedExprVisitor<DeclExtractor> Inherited;\n\n    DeclExtractor(Sema &S, DeclSetVector &Decls,\n                  SmallVectorImpl<SourceRange> &Ranges) :\n        Inherited(S.Context),\n        Decls(Decls),\n        Ranges(Ranges),\n        Simple(true) {}\n\n    bool isSimple() { return Simple; }\n\n    // Replaces the method in EvaluatedExprVisitor.\n    void VisitMemberExpr(MemberExpr* E) {\n      Simple = false;\n    }\n\n    // Any Stmt not explicitly listed will cause the condition to be marked\n    // complex.\n    void VisitStmt(Stmt *S) { Simple = false; }\n\n    void VisitBinaryOperator(BinaryOperator *E) {\n      Visit(E->getLHS());\n      Visit(E->getRHS());\n    }\n\n    void VisitCastExpr(CastExpr *E) {\n      Visit(E->getSubExpr());\n    }\n\n    void VisitUnaryOperator(UnaryOperator *E) {\n      // Skip checking conditionals with derefernces.\n      if (E->getOpcode() == UO_Deref)\n        Simple = false;\n      else\n        Visit(E->getSubExpr());\n    }\n\n    void VisitConditionalOperator(ConditionalOperator *E) {\n      Visit(E->getCond());\n      Visit(E->getTrueExpr());\n      Visit(E->getFalseExpr());\n    }\n\n    void VisitParenExpr(ParenExpr *E) {\n      Visit(E->getSubExpr());\n    }\n\n    void VisitBinaryConditionalOperator(BinaryConditionalOperator *E) {\n      Visit(E->getOpaqueValue()->getSourceExpr());\n      Visit(E->getFalseExpr());\n    }\n\n    void VisitIntegerLiteral(IntegerLiteral *E) { }\n    void VisitFloatingLiteral(FloatingLiteral *E) { }\n    void VisitCXXBoolLiteralExpr(CXXBoolLiteralExpr *E) { }\n    void VisitCharacterLiteral(CharacterLiteral *E) { }\n    void VisitGNUNullExpr(GNUNullExpr *E) { }\n    void VisitImaginaryLiteral(ImaginaryLiteral *E) { }\n\n    void VisitDeclRefExpr(DeclRefExpr *E) {\n      VarDecl *VD = dyn_cast<VarDecl>(E->getDecl());\n      if (!VD) {\n        // Don't allow unhandled Decl types.\n        Simple = false;\n        return;\n      }\n\n      Ranges.push_back(E->getSourceRange());\n\n      Decls.insert(VD);\n    }\n\n  }; // end class DeclExtractor\n\n  // DeclMatcher checks to see if the decls are used in a non-evaluated\n  // context.\n  class DeclMatcher : public EvaluatedExprVisitor<DeclMatcher> {\n    DeclSetVector &Decls;\n    bool FoundDecl;\n\n  public:\n    typedef EvaluatedExprVisitor<DeclMatcher> Inherited;\n\n    DeclMatcher(Sema &S, DeclSetVector &Decls, Stmt *Statement) :\n        Inherited(S.Context), Decls(Decls), FoundDecl(false) {\n      if (!Statement) return;\n\n      Visit(Statement);\n    }\n\n    void VisitReturnStmt(ReturnStmt *S) {\n      FoundDecl = true;\n    }\n\n    void VisitBreakStmt(BreakStmt *S) {\n      FoundDecl = true;\n    }\n\n    void VisitGotoStmt(GotoStmt *S) {\n      FoundDecl = true;\n    }\n\n    void VisitCastExpr(CastExpr *E) {\n      if (E->getCastKind() == CK_LValueToRValue)\n        CheckLValueToRValueCast(E->getSubExpr());\n      else\n        Visit(E->getSubExpr());\n    }\n\n    void CheckLValueToRValueCast(Expr *E) {\n      E = E->IgnoreParenImpCasts();\n\n      if (isa<DeclRefExpr>(E)) {\n        return;\n      }\n\n      if (ConditionalOperator *CO = dyn_cast<ConditionalOperator>(E)) {\n        Visit(CO->getCond());\n        CheckLValueToRValueCast(CO->getTrueExpr());\n        CheckLValueToRValueCast(CO->getFalseExpr());\n        return;\n      }\n\n      if (BinaryConditionalOperator *BCO =\n              dyn_cast<BinaryConditionalOperator>(E)) {\n        CheckLValueToRValueCast(BCO->getOpaqueValue()->getSourceExpr());\n        CheckLValueToRValueCast(BCO->getFalseExpr());\n        return;\n      }\n\n      Visit(E);\n    }\n\n    void VisitDeclRefExpr(DeclRefExpr *E) {\n      if (VarDecl *VD = dyn_cast<VarDecl>(E->getDecl()))\n        if (Decls.count(VD))\n          FoundDecl = true;\n    }\n\n    void VisitPseudoObjectExpr(PseudoObjectExpr *POE) {\n      // Only need to visit the semantics for POE.\n      // SyntaticForm doesn't really use the Decal.\n      for (auto *S : POE->semantics()) {\n        if (auto *OVE = dyn_cast<OpaqueValueExpr>(S))\n          // Look past the OVE into the expression it binds.\n          Visit(OVE->getSourceExpr());\n        else\n          Visit(S);\n      }\n    }\n\n    bool FoundDeclInUse() { return FoundDecl; }\n\n  };  // end class DeclMatcher\n\n  void CheckForLoopConditionalStatement(Sema &S, Expr *Second,\n                                        Expr *Third, Stmt *Body) {\n    // Condition is empty\n    if (!Second) return;\n\n    if (S.Diags.isIgnored(diag::warn_variables_not_in_loop_body,\n                          Second->getBeginLoc()))\n      return;\n\n    PartialDiagnostic PDiag = S.PDiag(diag::warn_variables_not_in_loop_body);\n    DeclSetVector Decls;\n    SmallVector<SourceRange, 10> Ranges;\n    DeclExtractor DE(S, Decls, Ranges);\n    DE.Visit(Second);\n\n    // Don't analyze complex conditionals.\n    if (!DE.isSimple()) return;\n\n    // No decls found.\n    if (Decls.size() == 0) return;\n\n    // Don't warn on volatile, static, or global variables.\n    for (auto *VD : Decls)\n      if (VD->getType().isVolatileQualified() || VD->hasGlobalStorage())\n        return;\n\n    if (DeclMatcher(S, Decls, Second).FoundDeclInUse() ||\n        DeclMatcher(S, Decls, Third).FoundDeclInUse() ||\n        DeclMatcher(S, Decls, Body).FoundDeclInUse())\n      return;\n\n    // Load decl names into diagnostic.\n    if (Decls.size() > 4) {\n      PDiag << 0;\n    } else {\n      PDiag << (unsigned)Decls.size();\n      for (auto *VD : Decls)\n        PDiag << VD->getDeclName();\n    }\n\n    for (auto Range : Ranges)\n      PDiag << Range;\n\n    S.Diag(Ranges.begin()->getBegin(), PDiag);\n  }\n\n  // If Statement is an incemement or decrement, return true and sets the\n  // variables Increment and DRE.\n  bool ProcessIterationStmt(Sema &S, Stmt* Statement, bool &Increment,\n                            DeclRefExpr *&DRE) {\n    if (auto Cleanups = dyn_cast<ExprWithCleanups>(Statement))\n      if (!Cleanups->cleanupsHaveSideEffects())\n        Statement = Cleanups->getSubExpr();\n\n    if (UnaryOperator *UO = dyn_cast<UnaryOperator>(Statement)) {\n      switch (UO->getOpcode()) {\n        default: return false;\n        case UO_PostInc:\n        case UO_PreInc:\n          Increment = true;\n          break;\n        case UO_PostDec:\n        case UO_PreDec:\n          Increment = false;\n          break;\n      }\n      DRE = dyn_cast<DeclRefExpr>(UO->getSubExpr());\n      return DRE;\n    }\n\n    if (CXXOperatorCallExpr *Call = dyn_cast<CXXOperatorCallExpr>(Statement)) {\n      FunctionDecl *FD = Call->getDirectCallee();\n      if (!FD || !FD->isOverloadedOperator()) return false;\n      switch (FD->getOverloadedOperator()) {\n        default: return false;\n        case OO_PlusPlus:\n          Increment = true;\n          break;\n        case OO_MinusMinus:\n          Increment = false;\n          break;\n      }\n      DRE = dyn_cast<DeclRefExpr>(Call->getArg(0));\n      return DRE;\n    }\n\n    return false;\n  }\n\n  // A visitor to determine if a continue or break statement is a\n  // subexpression.\n  class BreakContinueFinder : public ConstEvaluatedExprVisitor<BreakContinueFinder> {\n    SourceLocation BreakLoc;\n    SourceLocation ContinueLoc;\n    bool InSwitch = false;\n\n  public:\n    BreakContinueFinder(Sema &S, const Stmt* Body) :\n        Inherited(S.Context) {\n      Visit(Body);\n    }\n\n    typedef ConstEvaluatedExprVisitor<BreakContinueFinder> Inherited;\n\n    void VisitContinueStmt(const ContinueStmt* E) {\n      ContinueLoc = E->getContinueLoc();\n    }\n\n    void VisitBreakStmt(const BreakStmt* E) {\n      if (!InSwitch)\n        BreakLoc = E->getBreakLoc();\n    }\n\n    void VisitSwitchStmt(const SwitchStmt* S) {\n      if (const Stmt *Init = S->getInit())\n        Visit(Init);\n      if (const Stmt *CondVar = S->getConditionVariableDeclStmt())\n        Visit(CondVar);\n      if (const Stmt *Cond = S->getCond())\n        Visit(Cond);\n\n      // Don't return break statements from the body of a switch.\n      InSwitch = true;\n      if (const Stmt *Body = S->getBody())\n        Visit(Body);\n      InSwitch = false;\n    }\n\n    void VisitForStmt(const ForStmt *S) {\n      // Only visit the init statement of a for loop; the body\n      // has a different break/continue scope.\n      if (const Stmt *Init = S->getInit())\n        Visit(Init);\n    }\n\n    void VisitWhileStmt(const WhileStmt *) {\n      // Do nothing; the children of a while loop have a different\n      // break/continue scope.\n    }\n\n    void VisitDoStmt(const DoStmt *) {\n      // Do nothing; the children of a while loop have a different\n      // break/continue scope.\n    }\n\n    void VisitCXXForRangeStmt(const CXXForRangeStmt *S) {\n      // Only visit the initialization of a for loop; the body\n      // has a different break/continue scope.\n      if (const Stmt *Init = S->getInit())\n        Visit(Init);\n      if (const Stmt *Range = S->getRangeStmt())\n        Visit(Range);\n      if (const Stmt *Begin = S->getBeginStmt())\n        Visit(Begin);\n      if (const Stmt *End = S->getEndStmt())\n        Visit(End);\n    }\n\n    void VisitObjCForCollectionStmt(const ObjCForCollectionStmt *S) {\n      // Only visit the initialization of a for loop; the body\n      // has a different break/continue scope.\n      if (const Stmt *Element = S->getElement())\n        Visit(Element);\n      if (const Stmt *Collection = S->getCollection())\n        Visit(Collection);\n    }\n\n    bool ContinueFound() { return ContinueLoc.isValid(); }\n    bool BreakFound() { return BreakLoc.isValid(); }\n    SourceLocation GetContinueLoc() { return ContinueLoc; }\n    SourceLocation GetBreakLoc() { return BreakLoc; }\n\n  };  // end class BreakContinueFinder\n\n  // Emit a warning when a loop increment/decrement appears twice per loop\n  // iteration.  The conditions which trigger this warning are:\n  // 1) The last statement in the loop body and the third expression in the\n  //    for loop are both increment or both decrement of the same variable\n  // 2) No continue statements in the loop body.\n  void CheckForRedundantIteration(Sema &S, Expr *Third, Stmt *Body) {\n    // Return when there is nothing to check.\n    if (!Body || !Third) return;\n\n    if (S.Diags.isIgnored(diag::warn_redundant_loop_iteration,\n                          Third->getBeginLoc()))\n      return;\n\n    // Get the last statement from the loop body.\n    CompoundStmt *CS = dyn_cast<CompoundStmt>(Body);\n    if (!CS || CS->body_empty()) return;\n    Stmt *LastStmt = CS->body_back();\n    if (!LastStmt) return;\n\n    bool LoopIncrement, LastIncrement;\n    DeclRefExpr *LoopDRE, *LastDRE;\n\n    if (!ProcessIterationStmt(S, Third, LoopIncrement, LoopDRE)) return;\n    if (!ProcessIterationStmt(S, LastStmt, LastIncrement, LastDRE)) return;\n\n    // Check that the two statements are both increments or both decrements\n    // on the same variable.\n    if (LoopIncrement != LastIncrement ||\n        LoopDRE->getDecl() != LastDRE->getDecl()) return;\n\n    if (BreakContinueFinder(S, Body).ContinueFound()) return;\n\n    S.Diag(LastDRE->getLocation(), diag::warn_redundant_loop_iteration)\n         << LastDRE->getDecl() << LastIncrement;\n    S.Diag(LoopDRE->getLocation(), diag::note_loop_iteration_here)\n         << LoopIncrement;\n  }\n\n} // end namespace\n\n\nvoid Sema::CheckBreakContinueBinding(Expr *E) {\n  if (!E || getLangOpts().CPlusPlus)\n    return;\n  BreakContinueFinder BCFinder(*this, E);\n  Scope *BreakParent = CurScope->getBreakParent();\n  if (BCFinder.BreakFound() && BreakParent) {\n    if (BreakParent->getFlags() & Scope::SwitchScope) {\n      Diag(BCFinder.GetBreakLoc(), diag::warn_break_binds_to_switch);\n    } else {\n      Diag(BCFinder.GetBreakLoc(), diag::warn_loop_ctrl_binds_to_inner)\n          << \"break\";\n    }\n  } else if (BCFinder.ContinueFound() && CurScope->getContinueParent()) {\n    Diag(BCFinder.GetContinueLoc(), diag::warn_loop_ctrl_binds_to_inner)\n        << \"continue\";\n  }\n}\n\nStmtResult Sema::ActOnForStmt(SourceLocation ForLoc, SourceLocation LParenLoc,\n                              Stmt *First, ConditionResult Second,\n                              FullExprArg third, SourceLocation RParenLoc,\n                              Stmt *Body) {\n  if (Second.isInvalid())\n    return StmtError();\n\n  if (!getLangOpts().CPlusPlus) {\n    if (DeclStmt *DS = dyn_cast_or_null<DeclStmt>(First)) {\n      // C99 6.8.5p3: The declaration part of a 'for' statement shall only\n      // declare identifiers for objects having storage class 'auto' or\n      // 'register'.\n      const Decl *NonVarSeen = nullptr;\n      bool VarDeclSeen = false;\n      for (auto *DI : DS->decls()) {\n        if (VarDecl *VD = dyn_cast<VarDecl>(DI)) {\n          VarDeclSeen = true;\n          if (VD->isLocalVarDecl() && !VD->hasLocalStorage()) {\n            Diag(DI->getLocation(), diag::err_non_local_variable_decl_in_for);\n            DI->setInvalidDecl();\n          }\n        } else if (!NonVarSeen) {\n          // Keep track of the first non-variable declaration we saw so that\n          // we can diagnose if we don't see any variable declarations. This\n          // covers a case like declaring a typedef, function, or structure\n          // type rather than a variable.\n          NonVarSeen = DI;\n        }\n      }\n      // Diagnose if we saw a non-variable declaration but no variable\n      // declarations.\n      if (NonVarSeen && !VarDeclSeen)\n        Diag(NonVarSeen->getLocation(), diag::err_non_variable_decl_in_for);\n    }\n  }\n\n  CheckBreakContinueBinding(Second.get().second);\n  CheckBreakContinueBinding(third.get());\n\n  if (!Second.get().first)\n    CheckForLoopConditionalStatement(*this, Second.get().second, third.get(),\n                                     Body);\n  CheckForRedundantIteration(*this, third.get(), Body);\n\n  if (Second.get().second &&\n      !Diags.isIgnored(diag::warn_comma_operator,\n                       Second.get().second->getExprLoc()))\n    CommaVisitor(*this).Visit(Second.get().second);\n\n  Expr *Third  = third.release().getAs<Expr>();\n  if (isa<NullStmt>(Body))\n    getCurCompoundScope().setHasEmptyLoopBodies();\n\n  return new (Context)\n      ForStmt(Context, First, Second.get().second, Second.get().first, Third,\n              Body, ForLoc, LParenLoc, RParenLoc);\n}\n\n/// In an Objective C collection iteration statement:\n///   for (x in y)\n/// x can be an arbitrary l-value expression.  Bind it up as a\n/// full-expression.\nStmtResult Sema::ActOnForEachLValueExpr(Expr *E) {\n  // Reduce placeholder expressions here.  Note that this rejects the\n  // use of pseudo-object l-values in this position.\n  ExprResult result = CheckPlaceholderExpr(E);\n  if (result.isInvalid()) return StmtError();\n  E = result.get();\n\n  ExprResult FullExpr = ActOnFinishFullExpr(E, /*DiscardedValue*/ false);\n  if (FullExpr.isInvalid())\n    return StmtError();\n  return StmtResult(static_cast<Stmt*>(FullExpr.get()));\n}\n\nExprResult\nSema::CheckObjCForCollectionOperand(SourceLocation forLoc, Expr *collection) {\n  if (!collection)\n    return ExprError();\n\n  ExprResult result = CorrectDelayedTyposInExpr(collection);\n  if (!result.isUsable())\n    return ExprError();\n  collection = result.get();\n\n  // Bail out early if we've got a type-dependent expression.\n  if (collection->isTypeDependent()) return collection;\n\n  // Perform normal l-value conversion.\n  result = DefaultFunctionArrayLvalueConversion(collection);\n  if (result.isInvalid())\n    return ExprError();\n  collection = result.get();\n\n  // The operand needs to have object-pointer type.\n  // TODO: should we do a contextual conversion?\n  const ObjCObjectPointerType *pointerType =\n    collection->getType()->getAs<ObjCObjectPointerType>();\n  if (!pointerType)\n    return Diag(forLoc, diag::err_collection_expr_type)\n             << collection->getType() << collection->getSourceRange();\n\n  // Check that the operand provides\n  //   - countByEnumeratingWithState:objects:count:\n  const ObjCObjectType *objectType = pointerType->getObjectType();\n  ObjCInterfaceDecl *iface = objectType->getInterface();\n\n  // If we have a forward-declared type, we can't do this check.\n  // Under ARC, it is an error not to have a forward-declared class.\n  if (iface &&\n      (getLangOpts().ObjCAutoRefCount\n           ? RequireCompleteType(forLoc, QualType(objectType, 0),\n                                 diag::err_arc_collection_forward, collection)\n           : !isCompleteType(forLoc, QualType(objectType, 0)))) {\n    // Otherwise, if we have any useful type information, check that\n    // the type declares the appropriate method.\n  } else if (iface || !objectType->qual_empty()) {\n    IdentifierInfo *selectorIdents[] = {\n      &Context.Idents.get(\"countByEnumeratingWithState\"),\n      &Context.Idents.get(\"objects\"),\n      &Context.Idents.get(\"count\")\n    };\n    Selector selector = Context.Selectors.getSelector(3, &selectorIdents[0]);\n\n    ObjCMethodDecl *method = nullptr;\n\n    // If there's an interface, look in both the public and private APIs.\n    if (iface) {\n      method = iface->lookupInstanceMethod(selector);\n      if (!method) method = iface->lookupPrivateMethod(selector);\n    }\n\n    // Also check protocol qualifiers.\n    if (!method)\n      method = LookupMethodInQualifiedType(selector, pointerType,\n                                           /*instance*/ true);\n\n    // If we didn't find it anywhere, give up.\n    if (!method) {\n      Diag(forLoc, diag::warn_collection_expr_type)\n        << collection->getType() << selector << collection->getSourceRange();\n    }\n\n    // TODO: check for an incompatible signature?\n  }\n\n  // Wrap up any cleanups in the expression.\n  return collection;\n}\n\nStmtResult\nSema::ActOnObjCForCollectionStmt(SourceLocation ForLoc,\n                                 Stmt *First, Expr *collection,\n                                 SourceLocation RParenLoc) {\n  setFunctionHasBranchProtectedScope();\n\n  ExprResult CollectionExprResult =\n    CheckObjCForCollectionOperand(ForLoc, collection);\n\n  if (First) {\n    QualType FirstType;\n    if (DeclStmt *DS = dyn_cast<DeclStmt>(First)) {\n      if (!DS->isSingleDecl())\n        return StmtError(Diag((*DS->decl_begin())->getLocation(),\n                         diag::err_toomany_element_decls));\n\n      VarDecl *D = dyn_cast<VarDecl>(DS->getSingleDecl());\n      if (!D || D->isInvalidDecl())\n        return StmtError();\n\n      FirstType = D->getType();\n      // C99 6.8.5p3: The declaration part of a 'for' statement shall only\n      // declare identifiers for objects having storage class 'auto' or\n      // 'register'.\n      if (!D->hasLocalStorage())\n        return StmtError(Diag(D->getLocation(),\n                              diag::err_non_local_variable_decl_in_for));\n\n      // If the type contained 'auto', deduce the 'auto' to 'id'.\n      if (FirstType->getContainedAutoType()) {\n        OpaqueValueExpr OpaqueId(D->getLocation(), Context.getObjCIdType(),\n                                 VK_RValue);\n        Expr *DeducedInit = &OpaqueId;\n        if (DeduceAutoType(D->getTypeSourceInfo(), DeducedInit, FirstType) ==\n                DAR_Failed)\n          DiagnoseAutoDeductionFailure(D, DeducedInit);\n        if (FirstType.isNull()) {\n          D->setInvalidDecl();\n          return StmtError();\n        }\n\n        D->setType(FirstType);\n\n        if (!inTemplateInstantiation()) {\n          SourceLocation Loc =\n              D->getTypeSourceInfo()->getTypeLoc().getBeginLoc();\n          Diag(Loc, diag::warn_auto_var_is_id)\n            << D->getDeclName();\n        }\n      }\n\n    } else {\n      Expr *FirstE = cast<Expr>(First);\n      if (!FirstE->isTypeDependent() && !FirstE->isLValue())\n        return StmtError(\n            Diag(First->getBeginLoc(), diag::err_selector_element_not_lvalue)\n            << First->getSourceRange());\n\n      FirstType = static_cast<Expr*>(First)->getType();\n      if (FirstType.isConstQualified())\n        Diag(ForLoc, diag::err_selector_element_const_type)\n          << FirstType << First->getSourceRange();\n    }\n    if (!FirstType->isDependentType() &&\n        !FirstType->isObjCObjectPointerType() &&\n        !FirstType->isBlockPointerType())\n        return StmtError(Diag(ForLoc, diag::err_selector_element_type)\n                           << FirstType << First->getSourceRange());\n  }\n\n  if (CollectionExprResult.isInvalid())\n    return StmtError();\n\n  CollectionExprResult =\n      ActOnFinishFullExpr(CollectionExprResult.get(), /*DiscardedValue*/ false);\n  if (CollectionExprResult.isInvalid())\n    return StmtError();\n\n  return new (Context) ObjCForCollectionStmt(First, CollectionExprResult.get(),\n                                             nullptr, ForLoc, RParenLoc);\n}\n\n/// Finish building a variable declaration for a for-range statement.\n/// \\return true if an error occurs.\nstatic bool FinishForRangeVarDecl(Sema &SemaRef, VarDecl *Decl, Expr *Init,\n                                  SourceLocation Loc, int DiagID) {\n  if (Decl->getType()->isUndeducedType()) {\n    ExprResult Res = SemaRef.CorrectDelayedTyposInExpr(Init);\n    if (!Res.isUsable()) {\n      Decl->setInvalidDecl();\n      return true;\n    }\n    Init = Res.get();\n  }\n\n  // Deduce the type for the iterator variable now rather than leaving it to\n  // AddInitializerToDecl, so we can produce a more suitable diagnostic.\n  QualType InitType;\n  if ((!isa<InitListExpr>(Init) && Init->getType()->isVoidType()) ||\n      SemaRef.DeduceAutoType(Decl->getTypeSourceInfo(), Init, InitType) ==\n          Sema::DAR_Failed)\n    SemaRef.Diag(Loc, DiagID) << Init->getType();\n  if (InitType.isNull()) {\n    Decl->setInvalidDecl();\n    return true;\n  }\n  Decl->setType(InitType);\n\n  // In ARC, infer lifetime.\n  // FIXME: ARC may want to turn this into 'const __unsafe_unretained' if\n  // we're doing the equivalent of fast iteration.\n  if (SemaRef.getLangOpts().ObjCAutoRefCount &&\n      SemaRef.inferObjCARCLifetime(Decl))\n    Decl->setInvalidDecl();\n\n  SemaRef.AddInitializerToDecl(Decl, Init, /*DirectInit=*/false);\n  SemaRef.FinalizeDeclaration(Decl);\n  SemaRef.CurContext->addHiddenDecl(Decl);\n  return false;\n}\n\nnamespace {\n// An enum to represent whether something is dealing with a call to begin()\n// or a call to end() in a range-based for loop.\nenum BeginEndFunction {\n  BEF_begin,\n  BEF_end\n};\n\n/// Produce a note indicating which begin/end function was implicitly called\n/// by a C++11 for-range statement. This is often not obvious from the code,\n/// nor from the diagnostics produced when analysing the implicit expressions\n/// required in a for-range statement.\nvoid NoteForRangeBeginEndFunction(Sema &SemaRef, Expr *E,\n                                  BeginEndFunction BEF) {\n  CallExpr *CE = dyn_cast<CallExpr>(E);\n  if (!CE)\n    return;\n  FunctionDecl *D = dyn_cast<FunctionDecl>(CE->getCalleeDecl());\n  if (!D)\n    return;\n  SourceLocation Loc = D->getLocation();\n\n  std::string Description;\n  bool IsTemplate = false;\n  if (FunctionTemplateDecl *FunTmpl = D->getPrimaryTemplate()) {\n    Description = SemaRef.getTemplateArgumentBindingsText(\n      FunTmpl->getTemplateParameters(), *D->getTemplateSpecializationArgs());\n    IsTemplate = true;\n  }\n\n  SemaRef.Diag(Loc, diag::note_for_range_begin_end)\n    << BEF << IsTemplate << Description << E->getType();\n}\n\n/// Build a variable declaration for a for-range statement.\nVarDecl *BuildForRangeVarDecl(Sema &SemaRef, SourceLocation Loc,\n                              QualType Type, StringRef Name) {\n  DeclContext *DC = SemaRef.CurContext;\n  IdentifierInfo *II = &SemaRef.PP.getIdentifierTable().get(Name);\n  TypeSourceInfo *TInfo = SemaRef.Context.getTrivialTypeSourceInfo(Type, Loc);\n  VarDecl *Decl = VarDecl::Create(SemaRef.Context, DC, Loc, Loc, II, Type,\n                                  TInfo, SC_None);\n  Decl->setImplicit();\n  return Decl;\n}\n\n}\n\nstatic bool ObjCEnumerationCollection(Expr *Collection) {\n  return !Collection->isTypeDependent()\n          && Collection->getType()->getAs<ObjCObjectPointerType>() != nullptr;\n}\n\n/// ActOnCXXForRangeStmt - Check and build a C++11 for-range statement.\n///\n/// C++11 [stmt.ranged]:\n///   A range-based for statement is equivalent to\n///\n///   {\n///     auto && __range = range-init;\n///     for ( auto __begin = begin-expr,\n///           __end = end-expr;\n///           __begin != __end;\n///           ++__begin ) {\n///       for-range-declaration = *__begin;\n///       statement\n///     }\n///   }\n///\n/// The body of the loop is not available yet, since it cannot be analysed until\n/// we have determined the type of the for-range-declaration.\nStmtResult Sema::ActOnCXXForRangeStmt(Scope *S, SourceLocation ForLoc,\n                                      SourceLocation CoawaitLoc, Stmt *InitStmt,\n                                      Stmt *First, SourceLocation ColonLoc,\n                                      Expr *Range, SourceLocation RParenLoc,\n                                      BuildForRangeKind Kind) {\n  if (!First)\n    return StmtError();\n\n  if (Range && ObjCEnumerationCollection(Range)) {\n    // FIXME: Support init-statements in Objective-C++20 ranged for statement.\n    if (InitStmt)\n      return Diag(InitStmt->getBeginLoc(), diag::err_objc_for_range_init_stmt)\n                 << InitStmt->getSourceRange();\n    return ActOnObjCForCollectionStmt(ForLoc, First, Range, RParenLoc);\n  }\n\n  DeclStmt *DS = dyn_cast<DeclStmt>(First);\n  assert(DS && \"first part of for range not a decl stmt\");\n\n  if (!DS->isSingleDecl()) {\n    Diag(DS->getBeginLoc(), diag::err_type_defined_in_for_range);\n    return StmtError();\n  }\n\n  // This function is responsible for attaching an initializer to LoopVar. We\n  // must call ActOnInitializerError if we fail to do so.\n  Decl *LoopVar = DS->getSingleDecl();\n  if (LoopVar->isInvalidDecl() || !Range ||\n      DiagnoseUnexpandedParameterPack(Range, UPPC_Expression)) {\n    ActOnInitializerError(LoopVar);\n    return StmtError();\n  }\n\n  // Build the coroutine state immediately and not later during template\n  // instantiation\n  if (!CoawaitLoc.isInvalid()) {\n    if (!ActOnCoroutineBodyStart(S, CoawaitLoc, \"co_await\")) {\n      ActOnInitializerError(LoopVar);\n      return StmtError();\n    }\n  }\n\n  // Build  auto && __range = range-init\n  // Divide by 2, since the variables are in the inner scope (loop body).\n  const auto DepthStr = std::to_string(S->getDepth() / 2);\n  SourceLocation RangeLoc = Range->getBeginLoc();\n  VarDecl *RangeVar = BuildForRangeVarDecl(*this, RangeLoc,\n                                           Context.getAutoRRefDeductType(),\n                                           std::string(\"__range\") + DepthStr);\n  if (FinishForRangeVarDecl(*this, RangeVar, Range, RangeLoc,\n                            diag::err_for_range_deduction_failure)) {\n    ActOnInitializerError(LoopVar);\n    return StmtError();\n  }\n\n  // Claim the type doesn't contain auto: we've already done the checking.\n  DeclGroupPtrTy RangeGroup =\n      BuildDeclaratorGroup(MutableArrayRef<Decl *>((Decl **)&RangeVar, 1));\n  StmtResult RangeDecl = ActOnDeclStmt(RangeGroup, RangeLoc, RangeLoc);\n  if (RangeDecl.isInvalid()) {\n    ActOnInitializerError(LoopVar);\n    return StmtError();\n  }\n\n  StmtResult R = BuildCXXForRangeStmt(\n      ForLoc, CoawaitLoc, InitStmt, ColonLoc, RangeDecl.get(),\n      /*BeginStmt=*/nullptr, /*EndStmt=*/nullptr,\n      /*Cond=*/nullptr, /*Inc=*/nullptr, DS, RParenLoc, Kind);\n  if (R.isInvalid()) {\n    ActOnInitializerError(LoopVar);\n    return StmtError();\n  }\n\n  return R;\n}\n\n/// Create the initialization, compare, and increment steps for\n/// the range-based for loop expression.\n/// This function does not handle array-based for loops,\n/// which are created in Sema::BuildCXXForRangeStmt.\n///\n/// \\returns a ForRangeStatus indicating success or what kind of error occurred.\n/// BeginExpr and EndExpr are set and FRS_Success is returned on success;\n/// CandidateSet and BEF are set and some non-success value is returned on\n/// failure.\nstatic Sema::ForRangeStatus\nBuildNonArrayForRange(Sema &SemaRef, Expr *BeginRange, Expr *EndRange,\n                      QualType RangeType, VarDecl *BeginVar, VarDecl *EndVar,\n                      SourceLocation ColonLoc, SourceLocation CoawaitLoc,\n                      OverloadCandidateSet *CandidateSet, ExprResult *BeginExpr,\n                      ExprResult *EndExpr, BeginEndFunction *BEF) {\n  DeclarationNameInfo BeginNameInfo(\n      &SemaRef.PP.getIdentifierTable().get(\"begin\"), ColonLoc);\n  DeclarationNameInfo EndNameInfo(&SemaRef.PP.getIdentifierTable().get(\"end\"),\n                                  ColonLoc);\n\n  LookupResult BeginMemberLookup(SemaRef, BeginNameInfo,\n                                 Sema::LookupMemberName);\n  LookupResult EndMemberLookup(SemaRef, EndNameInfo, Sema::LookupMemberName);\n\n  auto BuildBegin = [&] {\n    *BEF = BEF_begin;\n    Sema::ForRangeStatus RangeStatus =\n        SemaRef.BuildForRangeBeginEndCall(ColonLoc, ColonLoc, BeginNameInfo,\n                                          BeginMemberLookup, CandidateSet,\n                                          BeginRange, BeginExpr);\n\n    if (RangeStatus != Sema::FRS_Success) {\n      if (RangeStatus == Sema::FRS_DiagnosticIssued)\n        SemaRef.Diag(BeginRange->getBeginLoc(), diag::note_in_for_range)\n            << ColonLoc << BEF_begin << BeginRange->getType();\n      return RangeStatus;\n    }\n    if (!CoawaitLoc.isInvalid()) {\n      // FIXME: getCurScope() should not be used during template instantiation.\n      // We should pick up the set of unqualified lookup results for operator\n      // co_await during the initial parse.\n      *BeginExpr = SemaRef.ActOnCoawaitExpr(SemaRef.getCurScope(), ColonLoc,\n                                            BeginExpr->get());\n      if (BeginExpr->isInvalid())\n        return Sema::FRS_DiagnosticIssued;\n    }\n    if (FinishForRangeVarDecl(SemaRef, BeginVar, BeginExpr->get(), ColonLoc,\n                              diag::err_for_range_iter_deduction_failure)) {\n      NoteForRangeBeginEndFunction(SemaRef, BeginExpr->get(), *BEF);\n      return Sema::FRS_DiagnosticIssued;\n    }\n    return Sema::FRS_Success;\n  };\n\n  auto BuildEnd = [&] {\n    *BEF = BEF_end;\n    Sema::ForRangeStatus RangeStatus =\n        SemaRef.BuildForRangeBeginEndCall(ColonLoc, ColonLoc, EndNameInfo,\n                                          EndMemberLookup, CandidateSet,\n                                          EndRange, EndExpr);\n    if (RangeStatus != Sema::FRS_Success) {\n      if (RangeStatus == Sema::FRS_DiagnosticIssued)\n        SemaRef.Diag(EndRange->getBeginLoc(), diag::note_in_for_range)\n            << ColonLoc << BEF_end << EndRange->getType();\n      return RangeStatus;\n    }\n    if (FinishForRangeVarDecl(SemaRef, EndVar, EndExpr->get(), ColonLoc,\n                              diag::err_for_range_iter_deduction_failure)) {\n      NoteForRangeBeginEndFunction(SemaRef, EndExpr->get(), *BEF);\n      return Sema::FRS_DiagnosticIssued;\n    }\n    return Sema::FRS_Success;\n  };\n\n  if (CXXRecordDecl *D = RangeType->getAsCXXRecordDecl()) {\n    // - if _RangeT is a class type, the unqualified-ids begin and end are\n    //   looked up in the scope of class _RangeT as if by class member access\n    //   lookup (3.4.5), and if either (or both) finds at least one\n    //   declaration, begin-expr and end-expr are __range.begin() and\n    //   __range.end(), respectively;\n    SemaRef.LookupQualifiedName(BeginMemberLookup, D);\n    if (BeginMemberLookup.isAmbiguous())\n      return Sema::FRS_DiagnosticIssued;\n\n    SemaRef.LookupQualifiedName(EndMemberLookup, D);\n    if (EndMemberLookup.isAmbiguous())\n      return Sema::FRS_DiagnosticIssued;\n\n    if (BeginMemberLookup.empty() != EndMemberLookup.empty()) {\n      // Look up the non-member form of the member we didn't find, first.\n      // This way we prefer a \"no viable 'end'\" diagnostic over a \"i found\n      // a 'begin' but ignored it because there was no member 'end'\"\n      // diagnostic.\n      auto BuildNonmember = [&](\n          BeginEndFunction BEFFound, LookupResult &Found,\n          llvm::function_ref<Sema::ForRangeStatus()> BuildFound,\n          llvm::function_ref<Sema::ForRangeStatus()> BuildNotFound) {\n        LookupResult OldFound = std::move(Found);\n        Found.clear();\n\n        if (Sema::ForRangeStatus Result = BuildNotFound())\n          return Result;\n\n        switch (BuildFound()) {\n        case Sema::FRS_Success:\n          return Sema::FRS_Success;\n\n        case Sema::FRS_NoViableFunction:\n          CandidateSet->NoteCandidates(\n              PartialDiagnosticAt(BeginRange->getBeginLoc(),\n                                  SemaRef.PDiag(diag::err_for_range_invalid)\n                                      << BeginRange->getType() << BEFFound),\n              SemaRef, OCD_AllCandidates, BeginRange);\n          LLVM_FALLTHROUGH;\n\n        case Sema::FRS_DiagnosticIssued:\n          for (NamedDecl *D : OldFound) {\n            SemaRef.Diag(D->getLocation(),\n                         diag::note_for_range_member_begin_end_ignored)\n                << BeginRange->getType() << BEFFound;\n          }\n          return Sema::FRS_DiagnosticIssued;\n        }\n        llvm_unreachable(\"unexpected ForRangeStatus\");\n      };\n      if (BeginMemberLookup.empty())\n        return BuildNonmember(BEF_end, EndMemberLookup, BuildEnd, BuildBegin);\n      return BuildNonmember(BEF_begin, BeginMemberLookup, BuildBegin, BuildEnd);\n    }\n  } else {\n    // - otherwise, begin-expr and end-expr are begin(__range) and\n    //   end(__range), respectively, where begin and end are looked up with\n    //   argument-dependent lookup (3.4.2). For the purposes of this name\n    //   lookup, namespace std is an associated namespace.\n  }\n\n  if (Sema::ForRangeStatus Result = BuildBegin())\n    return Result;\n  return BuildEnd();\n}\n\n/// Speculatively attempt to dereference an invalid range expression.\n/// If the attempt fails, this function will return a valid, null StmtResult\n/// and emit no diagnostics.\nstatic StmtResult RebuildForRangeWithDereference(Sema &SemaRef, Scope *S,\n                                                 SourceLocation ForLoc,\n                                                 SourceLocation CoawaitLoc,\n                                                 Stmt *InitStmt,\n                                                 Stmt *LoopVarDecl,\n                                                 SourceLocation ColonLoc,\n                                                 Expr *Range,\n                                                 SourceLocation RangeLoc,\n                                                 SourceLocation RParenLoc) {\n  // Determine whether we can rebuild the for-range statement with a\n  // dereferenced range expression.\n  ExprResult AdjustedRange;\n  {\n    Sema::SFINAETrap Trap(SemaRef);\n\n    AdjustedRange = SemaRef.BuildUnaryOp(S, RangeLoc, UO_Deref, Range);\n    if (AdjustedRange.isInvalid())\n      return StmtResult();\n\n    StmtResult SR = SemaRef.ActOnCXXForRangeStmt(\n        S, ForLoc, CoawaitLoc, InitStmt, LoopVarDecl, ColonLoc,\n        AdjustedRange.get(), RParenLoc, Sema::BFRK_Check);\n    if (SR.isInvalid())\n      return StmtResult();\n  }\n\n  // The attempt to dereference worked well enough that it could produce a valid\n  // loop. Produce a fixit, and rebuild the loop with diagnostics enabled, in\n  // case there are any other (non-fatal) problems with it.\n  SemaRef.Diag(RangeLoc, diag::err_for_range_dereference)\n    << Range->getType() << FixItHint::CreateInsertion(RangeLoc, \"*\");\n  return SemaRef.ActOnCXXForRangeStmt(\n      S, ForLoc, CoawaitLoc, InitStmt, LoopVarDecl, ColonLoc,\n      AdjustedRange.get(), RParenLoc, Sema::BFRK_Rebuild);\n}\n\n/// BuildCXXForRangeStmt - Build or instantiate a C++11 for-range statement.\nStmtResult Sema::BuildCXXForRangeStmt(SourceLocation ForLoc,\n                                      SourceLocation CoawaitLoc, Stmt *InitStmt,\n                                      SourceLocation ColonLoc, Stmt *RangeDecl,\n                                      Stmt *Begin, Stmt *End, Expr *Cond,\n                                      Expr *Inc, Stmt *LoopVarDecl,\n                                      SourceLocation RParenLoc,\n                                      BuildForRangeKind Kind) {\n  // FIXME: This should not be used during template instantiation. We should\n  // pick up the set of unqualified lookup results for the != and + operators\n  // in the initial parse.\n  //\n  // Testcase (accepts-invalid):\n  //   template<typename T> void f() { for (auto x : T()) {} }\n  //   namespace N { struct X { X begin(); X end(); int operator*(); }; }\n  //   bool operator!=(N::X, N::X); void operator++(N::X);\n  //   void g() { f<N::X>(); }\n  Scope *S = getCurScope();\n\n  DeclStmt *RangeDS = cast<DeclStmt>(RangeDecl);\n  VarDecl *RangeVar = cast<VarDecl>(RangeDS->getSingleDecl());\n  QualType RangeVarType = RangeVar->getType();\n\n  DeclStmt *LoopVarDS = cast<DeclStmt>(LoopVarDecl);\n  VarDecl *LoopVar = cast<VarDecl>(LoopVarDS->getSingleDecl());\n\n  StmtResult BeginDeclStmt = Begin;\n  StmtResult EndDeclStmt = End;\n  ExprResult NotEqExpr = Cond, IncrExpr = Inc;\n\n  if (RangeVarType->isDependentType()) {\n    // The range is implicitly used as a placeholder when it is dependent.\n    RangeVar->markUsed(Context);\n\n    // Deduce any 'auto's in the loop variable as 'DependentTy'. We'll fill\n    // them in properly when we instantiate the loop.\n    if (!LoopVar->isInvalidDecl() && Kind != BFRK_Check) {\n      if (auto *DD = dyn_cast<DecompositionDecl>(LoopVar))\n        for (auto *Binding : DD->bindings())\n          Binding->setType(Context.DependentTy);\n      LoopVar->setType(SubstAutoType(LoopVar->getType(), Context.DependentTy));\n    }\n  } else if (!BeginDeclStmt.get()) {\n    SourceLocation RangeLoc = RangeVar->getLocation();\n\n    const QualType RangeVarNonRefType = RangeVarType.getNonReferenceType();\n\n    ExprResult BeginRangeRef = BuildDeclRefExpr(RangeVar, RangeVarNonRefType,\n                                                VK_LValue, ColonLoc);\n    if (BeginRangeRef.isInvalid())\n      return StmtError();\n\n    ExprResult EndRangeRef = BuildDeclRefExpr(RangeVar, RangeVarNonRefType,\n                                              VK_LValue, ColonLoc);\n    if (EndRangeRef.isInvalid())\n      return StmtError();\n\n    QualType AutoType = Context.getAutoDeductType();\n    Expr *Range = RangeVar->getInit();\n    if (!Range)\n      return StmtError();\n    QualType RangeType = Range->getType();\n\n    if (RequireCompleteType(RangeLoc, RangeType,\n                            diag::err_for_range_incomplete_type))\n      return StmtError();\n\n    // Build auto __begin = begin-expr, __end = end-expr.\n    // Divide by 2, since the variables are in the inner scope (loop body).\n    const auto DepthStr = std::to_string(S->getDepth() / 2);\n    VarDecl *BeginVar = BuildForRangeVarDecl(*this, ColonLoc, AutoType,\n                                             std::string(\"__begin\") + DepthStr);\n    VarDecl *EndVar = BuildForRangeVarDecl(*this, ColonLoc, AutoType,\n                                           std::string(\"__end\") + DepthStr);\n\n    // Build begin-expr and end-expr and attach to __begin and __end variables.\n    ExprResult BeginExpr, EndExpr;\n    if (const ArrayType *UnqAT = RangeType->getAsArrayTypeUnsafe()) {\n      // - if _RangeT is an array type, begin-expr and end-expr are __range and\n      //   __range + __bound, respectively, where __bound is the array bound. If\n      //   _RangeT is an array of unknown size or an array of incomplete type,\n      //   the program is ill-formed;\n\n      // begin-expr is __range.\n      BeginExpr = BeginRangeRef;\n      if (!CoawaitLoc.isInvalid()) {\n        BeginExpr = ActOnCoawaitExpr(S, ColonLoc, BeginExpr.get());\n        if (BeginExpr.isInvalid())\n          return StmtError();\n      }\n      if (FinishForRangeVarDecl(*this, BeginVar, BeginRangeRef.get(), ColonLoc,\n                                diag::err_for_range_iter_deduction_failure)) {\n        NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);\n        return StmtError();\n      }\n\n      // Find the array bound.\n      ExprResult BoundExpr;\n      if (const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(UnqAT))\n        BoundExpr = IntegerLiteral::Create(\n            Context, CAT->getSize(), Context.getPointerDiffType(), RangeLoc);\n      else if (const VariableArrayType *VAT =\n               dyn_cast<VariableArrayType>(UnqAT)) {\n        // For a variably modified type we can't just use the expression within\n        // the array bounds, since we don't want that to be re-evaluated here.\n        // Rather, we need to determine what it was when the array was first\n        // created - so we resort to using sizeof(vla)/sizeof(element).\n        // For e.g.\n        //  void f(int b) {\n        //    int vla[b];\n        //    b = -1;   <-- This should not affect the num of iterations below\n        //    for (int &c : vla) { .. }\n        //  }\n\n        // FIXME: This results in codegen generating IR that recalculates the\n        // run-time number of elements (as opposed to just using the IR Value\n        // that corresponds to the run-time value of each bound that was\n        // generated when the array was created.) If this proves too embarrassing\n        // even for unoptimized IR, consider passing a magic-value/cookie to\n        // codegen that then knows to simply use that initial llvm::Value (that\n        // corresponds to the bound at time of array creation) within\n        // getelementptr.  But be prepared to pay the price of increasing a\n        // customized form of coupling between the two components - which  could\n        // be hard to maintain as the codebase evolves.\n\n        ExprResult SizeOfVLAExprR = ActOnUnaryExprOrTypeTraitExpr(\n            EndVar->getLocation(), UETT_SizeOf,\n            /*IsType=*/true,\n            CreateParsedType(VAT->desugar(), Context.getTrivialTypeSourceInfo(\n                                                 VAT->desugar(), RangeLoc))\n                .getAsOpaquePtr(),\n            EndVar->getSourceRange());\n        if (SizeOfVLAExprR.isInvalid())\n          return StmtError();\n\n        ExprResult SizeOfEachElementExprR = ActOnUnaryExprOrTypeTraitExpr(\n            EndVar->getLocation(), UETT_SizeOf,\n            /*IsType=*/true,\n            CreateParsedType(VAT->desugar(),\n                             Context.getTrivialTypeSourceInfo(\n                                 VAT->getElementType(), RangeLoc))\n                .getAsOpaquePtr(),\n            EndVar->getSourceRange());\n        if (SizeOfEachElementExprR.isInvalid())\n          return StmtError();\n\n        BoundExpr =\n            ActOnBinOp(S, EndVar->getLocation(), tok::slash,\n                       SizeOfVLAExprR.get(), SizeOfEachElementExprR.get());\n        if (BoundExpr.isInvalid())\n          return StmtError();\n\n      } else {\n        // Can't be a DependentSizedArrayType or an IncompleteArrayType since\n        // UnqAT is not incomplete and Range is not type-dependent.\n        llvm_unreachable(\"Unexpected array type in for-range\");\n      }\n\n      // end-expr is __range + __bound.\n      EndExpr = ActOnBinOp(S, ColonLoc, tok::plus, EndRangeRef.get(),\n                           BoundExpr.get());\n      if (EndExpr.isInvalid())\n        return StmtError();\n      if (FinishForRangeVarDecl(*this, EndVar, EndExpr.get(), ColonLoc,\n                                diag::err_for_range_iter_deduction_failure)) {\n        NoteForRangeBeginEndFunction(*this, EndExpr.get(), BEF_end);\n        return StmtError();\n      }\n    } else {\n      OverloadCandidateSet CandidateSet(RangeLoc,\n                                        OverloadCandidateSet::CSK_Normal);\n      BeginEndFunction BEFFailure;\n      ForRangeStatus RangeStatus = BuildNonArrayForRange(\n          *this, BeginRangeRef.get(), EndRangeRef.get(), RangeType, BeginVar,\n          EndVar, ColonLoc, CoawaitLoc, &CandidateSet, &BeginExpr, &EndExpr,\n          &BEFFailure);\n\n      if (Kind == BFRK_Build && RangeStatus == FRS_NoViableFunction &&\n          BEFFailure == BEF_begin) {\n        // If the range is being built from an array parameter, emit a\n        // a diagnostic that it is being treated as a pointer.\n        if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Range)) {\n          if (ParmVarDecl *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl())) {\n            QualType ArrayTy = PVD->getOriginalType();\n            QualType PointerTy = PVD->getType();\n            if (PointerTy->isPointerType() && ArrayTy->isArrayType()) {\n              Diag(Range->getBeginLoc(), diag::err_range_on_array_parameter)\n                  << RangeLoc << PVD << ArrayTy << PointerTy;\n              Diag(PVD->getLocation(), diag::note_declared_at);\n              return StmtError();\n            }\n          }\n        }\n\n        // If building the range failed, try dereferencing the range expression\n        // unless a diagnostic was issued or the end function is problematic.\n        StmtResult SR = RebuildForRangeWithDereference(*this, S, ForLoc,\n                                                       CoawaitLoc, InitStmt,\n                                                       LoopVarDecl, ColonLoc,\n                                                       Range, RangeLoc,\n                                                       RParenLoc);\n        if (SR.isInvalid() || SR.isUsable())\n          return SR;\n      }\n\n      // Otherwise, emit diagnostics if we haven't already.\n      if (RangeStatus == FRS_NoViableFunction) {\n        Expr *Range = BEFFailure ? EndRangeRef.get() : BeginRangeRef.get();\n        CandidateSet.NoteCandidates(\n            PartialDiagnosticAt(Range->getBeginLoc(),\n                                PDiag(diag::err_for_range_invalid)\n                                    << RangeLoc << Range->getType()\n                                    << BEFFailure),\n            *this, OCD_AllCandidates, Range);\n      }\n      // Return an error if no fix was discovered.\n      if (RangeStatus != FRS_Success)\n        return StmtError();\n    }\n\n    assert(!BeginExpr.isInvalid() && !EndExpr.isInvalid() &&\n           \"invalid range expression in for loop\");\n\n    // C++11 [dcl.spec.auto]p7: BeginType and EndType must be the same.\n    // C++1z removes this restriction.\n    QualType BeginType = BeginVar->getType(), EndType = EndVar->getType();\n    if (!Context.hasSameType(BeginType, EndType)) {\n      Diag(RangeLoc, getLangOpts().CPlusPlus17\n                         ? diag::warn_for_range_begin_end_types_differ\n                         : diag::ext_for_range_begin_end_types_differ)\n          << BeginType << EndType;\n      NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);\n      NoteForRangeBeginEndFunction(*this, EndExpr.get(), BEF_end);\n    }\n\n    BeginDeclStmt =\n        ActOnDeclStmt(ConvertDeclToDeclGroup(BeginVar), ColonLoc, ColonLoc);\n    EndDeclStmt =\n        ActOnDeclStmt(ConvertDeclToDeclGroup(EndVar), ColonLoc, ColonLoc);\n\n    const QualType BeginRefNonRefType = BeginType.getNonReferenceType();\n    ExprResult BeginRef = BuildDeclRefExpr(BeginVar, BeginRefNonRefType,\n                                           VK_LValue, ColonLoc);\n    if (BeginRef.isInvalid())\n      return StmtError();\n\n    ExprResult EndRef = BuildDeclRefExpr(EndVar, EndType.getNonReferenceType(),\n                                         VK_LValue, ColonLoc);\n    if (EndRef.isInvalid())\n      return StmtError();\n\n    // Build and check __begin != __end expression.\n    NotEqExpr = ActOnBinOp(S, ColonLoc, tok::exclaimequal,\n                           BeginRef.get(), EndRef.get());\n    if (!NotEqExpr.isInvalid())\n      NotEqExpr = CheckBooleanCondition(ColonLoc, NotEqExpr.get());\n    if (!NotEqExpr.isInvalid())\n      NotEqExpr =\n          ActOnFinishFullExpr(NotEqExpr.get(), /*DiscardedValue*/ false);\n    if (NotEqExpr.isInvalid()) {\n      Diag(RangeLoc, diag::note_for_range_invalid_iterator)\n        << RangeLoc << 0 << BeginRangeRef.get()->getType();\n      NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);\n      if (!Context.hasSameType(BeginType, EndType))\n        NoteForRangeBeginEndFunction(*this, EndExpr.get(), BEF_end);\n      return StmtError();\n    }\n\n    // Build and check ++__begin expression.\n    BeginRef = BuildDeclRefExpr(BeginVar, BeginRefNonRefType,\n                                VK_LValue, ColonLoc);\n    if (BeginRef.isInvalid())\n      return StmtError();\n\n    IncrExpr = ActOnUnaryOp(S, ColonLoc, tok::plusplus, BeginRef.get());\n    if (!IncrExpr.isInvalid() && CoawaitLoc.isValid())\n      // FIXME: getCurScope() should not be used during template instantiation.\n      // We should pick up the set of unqualified lookup results for operator\n      // co_await during the initial parse.\n      IncrExpr = ActOnCoawaitExpr(S, CoawaitLoc, IncrExpr.get());\n    if (!IncrExpr.isInvalid())\n      IncrExpr = ActOnFinishFullExpr(IncrExpr.get(), /*DiscardedValue*/ false);\n    if (IncrExpr.isInvalid()) {\n      Diag(RangeLoc, diag::note_for_range_invalid_iterator)\n        << RangeLoc << 2 << BeginRangeRef.get()->getType() ;\n      NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);\n      return StmtError();\n    }\n\n    // Build and check *__begin  expression.\n    BeginRef = BuildDeclRefExpr(BeginVar, BeginRefNonRefType,\n                                VK_LValue, ColonLoc);\n    if (BeginRef.isInvalid())\n      return StmtError();\n\n    ExprResult DerefExpr = ActOnUnaryOp(S, ColonLoc, tok::star, BeginRef.get());\n    if (DerefExpr.isInvalid()) {\n      Diag(RangeLoc, diag::note_for_range_invalid_iterator)\n        << RangeLoc << 1 << BeginRangeRef.get()->getType();\n      NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);\n      return StmtError();\n    }\n\n    // Attach  *__begin  as initializer for VD. Don't touch it if we're just\n    // trying to determine whether this would be a valid range.\n    if (!LoopVar->isInvalidDecl() && Kind != BFRK_Check) {\n      AddInitializerToDecl(LoopVar, DerefExpr.get(), /*DirectInit=*/false);\n      if (LoopVar->isInvalidDecl() ||\n          (LoopVar->getInit() && LoopVar->getInit()->containsErrors()))\n        NoteForRangeBeginEndFunction(*this, BeginExpr.get(), BEF_begin);\n    }\n  }\n\n  // Don't bother to actually allocate the result if we're just trying to\n  // determine whether it would be valid.\n  if (Kind == BFRK_Check)\n    return StmtResult();\n\n  // In OpenMP loop region loop control variable must be private. Perform\n  // analysis of first part (if any).\n  if (getLangOpts().OpenMP >= 50 && BeginDeclStmt.isUsable())\n    ActOnOpenMPLoopInitialization(ForLoc, BeginDeclStmt.get());\n\n  return new (Context) CXXForRangeStmt(\n      InitStmt, RangeDS, cast_or_null<DeclStmt>(BeginDeclStmt.get()),\n      cast_or_null<DeclStmt>(EndDeclStmt.get()), NotEqExpr.get(),\n      IncrExpr.get(), LoopVarDS, /*Body=*/nullptr, ForLoc, CoawaitLoc,\n      ColonLoc, RParenLoc);\n}\n\n/// FinishObjCForCollectionStmt - Attach the body to a objective-C foreach\n/// statement.\nStmtResult Sema::FinishObjCForCollectionStmt(Stmt *S, Stmt *B) {\n  if (!S || !B)\n    return StmtError();\n  ObjCForCollectionStmt * ForStmt = cast<ObjCForCollectionStmt>(S);\n\n  ForStmt->setBody(B);\n  return S;\n}\n\n// Warn when the loop variable is a const reference that creates a copy.\n// Suggest using the non-reference type for copies.  If a copy can be prevented\n// suggest the const reference type that would do so.\n// For instance, given \"for (const &Foo : Range)\", suggest\n// \"for (const Foo : Range)\" to denote a copy is made for the loop.  If\n// possible, also suggest \"for (const &Bar : Range)\" if this type prevents\n// the copy altogether.\nstatic void DiagnoseForRangeReferenceVariableCopies(Sema &SemaRef,\n                                                    const VarDecl *VD,\n                                                    QualType RangeInitType) {\n  const Expr *InitExpr = VD->getInit();\n  if (!InitExpr)\n    return;\n\n  QualType VariableType = VD->getType();\n\n  if (auto Cleanups = dyn_cast<ExprWithCleanups>(InitExpr))\n    if (!Cleanups->cleanupsHaveSideEffects())\n      InitExpr = Cleanups->getSubExpr();\n\n  const MaterializeTemporaryExpr *MTE =\n      dyn_cast<MaterializeTemporaryExpr>(InitExpr);\n\n  // No copy made.\n  if (!MTE)\n    return;\n\n  const Expr *E = MTE->getSubExpr()->IgnoreImpCasts();\n\n  // Searching for either UnaryOperator for dereference of a pointer or\n  // CXXOperatorCallExpr for handling iterators.\n  while (!isa<CXXOperatorCallExpr>(E) && !isa<UnaryOperator>(E)) {\n    if (const CXXConstructExpr *CCE = dyn_cast<CXXConstructExpr>(E)) {\n      E = CCE->getArg(0);\n    } else if (const CXXMemberCallExpr *Call = dyn_cast<CXXMemberCallExpr>(E)) {\n      const MemberExpr *ME = cast<MemberExpr>(Call->getCallee());\n      E = ME->getBase();\n    } else {\n      const MaterializeTemporaryExpr *MTE = cast<MaterializeTemporaryExpr>(E);\n      E = MTE->getSubExpr();\n    }\n    E = E->IgnoreImpCasts();\n  }\n\n  QualType ReferenceReturnType;\n  if (isa<UnaryOperator>(E)) {\n    ReferenceReturnType = SemaRef.Context.getLValueReferenceType(E->getType());\n  } else {\n    const CXXOperatorCallExpr *Call = cast<CXXOperatorCallExpr>(E);\n    const FunctionDecl *FD = Call->getDirectCallee();\n    QualType ReturnType = FD->getReturnType();\n    if (ReturnType->isReferenceType())\n      ReferenceReturnType = ReturnType;\n  }\n\n  if (!ReferenceReturnType.isNull()) {\n    // Loop variable creates a temporary.  Suggest either to go with\n    // non-reference loop variable to indicate a copy is made, or\n    // the correct type to bind a const reference.\n    SemaRef.Diag(VD->getLocation(),\n                 diag::warn_for_range_const_ref_binds_temp_built_from_ref)\n        << VD << VariableType << ReferenceReturnType;\n    QualType NonReferenceType = VariableType.getNonReferenceType();\n    NonReferenceType.removeLocalConst();\n    QualType NewReferenceType =\n        SemaRef.Context.getLValueReferenceType(E->getType().withConst());\n    SemaRef.Diag(VD->getBeginLoc(), diag::note_use_type_or_non_reference)\n        << NonReferenceType << NewReferenceType << VD->getSourceRange()\n        << FixItHint::CreateRemoval(VD->getTypeSpecEndLoc());\n  } else if (!VariableType->isRValueReferenceType()) {\n    // The range always returns a copy, so a temporary is always created.\n    // Suggest removing the reference from the loop variable.\n    // If the type is a rvalue reference do not warn since that changes the\n    // semantic of the code.\n    SemaRef.Diag(VD->getLocation(), diag::warn_for_range_ref_binds_ret_temp)\n        << VD << RangeInitType;\n    QualType NonReferenceType = VariableType.getNonReferenceType();\n    NonReferenceType.removeLocalConst();\n    SemaRef.Diag(VD->getBeginLoc(), diag::note_use_non_reference_type)\n        << NonReferenceType << VD->getSourceRange()\n        << FixItHint::CreateRemoval(VD->getTypeSpecEndLoc());\n  }\n}\n\n/// Determines whether the @p VariableType's declaration is a record with the\n/// clang::trivial_abi attribute.\nstatic bool hasTrivialABIAttr(QualType VariableType) {\n  if (CXXRecordDecl *RD = VariableType->getAsCXXRecordDecl())\n    return RD->hasAttr<TrivialABIAttr>();\n\n  return false;\n}\n\n// Warns when the loop variable can be changed to a reference type to\n// prevent a copy.  For instance, if given \"for (const Foo x : Range)\" suggest\n// \"for (const Foo &x : Range)\" if this form does not make a copy.\nstatic void DiagnoseForRangeConstVariableCopies(Sema &SemaRef,\n                                                const VarDecl *VD) {\n  const Expr *InitExpr = VD->getInit();\n  if (!InitExpr)\n    return;\n\n  QualType VariableType = VD->getType();\n\n  if (const CXXConstructExpr *CE = dyn_cast<CXXConstructExpr>(InitExpr)) {\n    if (!CE->getConstructor()->isCopyConstructor())\n      return;\n  } else if (const CastExpr *CE = dyn_cast<CastExpr>(InitExpr)) {\n    if (CE->getCastKind() != CK_LValueToRValue)\n      return;\n  } else {\n    return;\n  }\n\n  // Small trivially copyable types are cheap to copy. Do not emit the\n  // diagnostic for these instances. 64 bytes is a common size of a cache line.\n  // (The function `getTypeSize` returns the size in bits.)\n  ASTContext &Ctx = SemaRef.Context;\n  if (Ctx.getTypeSize(VariableType) <= 64 * 8 &&\n      (VariableType.isTriviallyCopyableType(Ctx) ||\n       hasTrivialABIAttr(VariableType)))\n    return;\n\n  // Suggest changing from a const variable to a const reference variable\n  // if doing so will prevent a copy.\n  SemaRef.Diag(VD->getLocation(), diag::warn_for_range_copy)\n      << VD << VariableType;\n  SemaRef.Diag(VD->getBeginLoc(), diag::note_use_reference_type)\n      << SemaRef.Context.getLValueReferenceType(VariableType)\n      << VD->getSourceRange()\n      << FixItHint::CreateInsertion(VD->getLocation(), \"&\");\n}\n\n/// DiagnoseForRangeVariableCopies - Diagnose three cases and fixes for them.\n/// 1) for (const foo &x : foos) where foos only returns a copy.  Suggest\n///    using \"const foo x\" to show that a copy is made\n/// 2) for (const bar &x : foos) where bar is a temporary initialized by bar.\n///    Suggest either \"const bar x\" to keep the copying or \"const foo& x\" to\n///    prevent the copy.\n/// 3) for (const foo x : foos) where x is constructed from a reference foo.\n///    Suggest \"const foo &x\" to prevent the copy.\nstatic void DiagnoseForRangeVariableCopies(Sema &SemaRef,\n                                           const CXXForRangeStmt *ForStmt) {\n  if (SemaRef.inTemplateInstantiation())\n    return;\n\n  if (SemaRef.Diags.isIgnored(\n          diag::warn_for_range_const_ref_binds_temp_built_from_ref,\n          ForStmt->getBeginLoc()) &&\n      SemaRef.Diags.isIgnored(diag::warn_for_range_ref_binds_ret_temp,\n                              ForStmt->getBeginLoc()) &&\n      SemaRef.Diags.isIgnored(diag::warn_for_range_copy,\n                              ForStmt->getBeginLoc())) {\n    return;\n  }\n\n  const VarDecl *VD = ForStmt->getLoopVariable();\n  if (!VD)\n    return;\n\n  QualType VariableType = VD->getType();\n\n  if (VariableType->isIncompleteType())\n    return;\n\n  const Expr *InitExpr = VD->getInit();\n  if (!InitExpr)\n    return;\n\n  if (InitExpr->getExprLoc().isMacroID())\n    return;\n\n  if (VariableType->isReferenceType()) {\n    DiagnoseForRangeReferenceVariableCopies(SemaRef, VD,\n                                            ForStmt->getRangeInit()->getType());\n  } else if (VariableType.isConstQualified()) {\n    DiagnoseForRangeConstVariableCopies(SemaRef, VD);\n  }\n}\n\n/// FinishCXXForRangeStmt - Attach the body to a C++0x for-range statement.\n/// This is a separate step from ActOnCXXForRangeStmt because analysis of the\n/// body cannot be performed until after the type of the range variable is\n/// determined.\nStmtResult Sema::FinishCXXForRangeStmt(Stmt *S, Stmt *B) {\n  if (!S || !B)\n    return StmtError();\n\n  if (isa<ObjCForCollectionStmt>(S))\n    return FinishObjCForCollectionStmt(S, B);\n\n  CXXForRangeStmt *ForStmt = cast<CXXForRangeStmt>(S);\n  ForStmt->setBody(B);\n\n  DiagnoseEmptyStmtBody(ForStmt->getRParenLoc(), B,\n                        diag::warn_empty_range_based_for_body);\n\n  DiagnoseForRangeVariableCopies(*this, ForStmt);\n\n  return S;\n}\n\nStmtResult Sema::ActOnGotoStmt(SourceLocation GotoLoc,\n                               SourceLocation LabelLoc,\n                               LabelDecl *TheDecl) {\n  setFunctionHasBranchIntoScope();\n  TheDecl->markUsed(Context);\n  return new (Context) GotoStmt(TheDecl, GotoLoc, LabelLoc);\n}\n\nStmtResult\nSema::ActOnIndirectGotoStmt(SourceLocation GotoLoc, SourceLocation StarLoc,\n                            Expr *E) {\n  // Convert operand to void*\n  if (!E->isTypeDependent()) {\n    QualType ETy = E->getType();\n    QualType DestTy = Context.getPointerType(Context.VoidTy.withConst());\n    ExprResult ExprRes = E;\n    AssignConvertType ConvTy =\n      CheckSingleAssignmentConstraints(DestTy, ExprRes);\n    if (ExprRes.isInvalid())\n      return StmtError();\n    E = ExprRes.get();\n    if (DiagnoseAssignmentResult(ConvTy, StarLoc, DestTy, ETy, E, AA_Passing))\n      return StmtError();\n  }\n\n  ExprResult ExprRes = ActOnFinishFullExpr(E, /*DiscardedValue*/ false);\n  if (ExprRes.isInvalid())\n    return StmtError();\n  E = ExprRes.get();\n\n  setFunctionHasIndirectGoto();\n\n  return new (Context) IndirectGotoStmt(GotoLoc, StarLoc, E);\n}\n\nstatic void CheckJumpOutOfSEHFinally(Sema &S, SourceLocation Loc,\n                                     const Scope &DestScope) {\n  if (!S.CurrentSEHFinally.empty() &&\n      DestScope.Contains(*S.CurrentSEHFinally.back())) {\n    S.Diag(Loc, diag::warn_jump_out_of_seh_finally);\n  }\n}\n\nStmtResult\nSema::ActOnContinueStmt(SourceLocation ContinueLoc, Scope *CurScope) {\n  Scope *S = CurScope->getContinueParent();\n  if (!S) {\n    // C99 6.8.6.2p1: A break shall appear only in or as a loop body.\n    return StmtError(Diag(ContinueLoc, diag::err_continue_not_in_loop));\n  }\n  if (S->getFlags() & Scope::ConditionVarScope) {\n    // We cannot 'continue;' from within a statement expression in the\n    // initializer of a condition variable because we would jump past the\n    // initialization of that variable.\n    return StmtError(Diag(ContinueLoc, diag::err_continue_from_cond_var_init));\n  }\n  CheckJumpOutOfSEHFinally(*this, ContinueLoc, *S);\n\n  return new (Context) ContinueStmt(ContinueLoc);\n}\n\nStmtResult\nSema::ActOnBreakStmt(SourceLocation BreakLoc, Scope *CurScope) {\n  Scope *S = CurScope->getBreakParent();\n  if (!S) {\n    // C99 6.8.6.3p1: A break shall appear only in or as a switch/loop body.\n    return StmtError(Diag(BreakLoc, diag::err_break_not_in_loop_or_switch));\n  }\n  if (S->isOpenMPLoopScope())\n    return StmtError(Diag(BreakLoc, diag::err_omp_loop_cannot_use_stmt)\n                     << \"break\");\n  CheckJumpOutOfSEHFinally(*this, BreakLoc, *S);\n\n  return new (Context) BreakStmt(BreakLoc);\n}\n\n/// Determine whether the given expression is a candidate for\n/// copy elision in either a return statement or a throw expression.\n///\n/// \\param ReturnType If we're determining the copy elision candidate for\n/// a return statement, this is the return type of the function. If we're\n/// determining the copy elision candidate for a throw expression, this will\n/// be a NULL type.\n///\n/// \\param E The expression being returned from the function or block, or\n/// being thrown.\n///\n/// \\param CESK Whether we allow function parameters or\n/// id-expressions that could be moved out of the function to be considered NRVO\n/// candidates. C++ prohibits these for NRVO itself, but we re-use this logic to\n/// determine whether we should try to move as part of a return or throw (which\n/// does allow function parameters).\n///\n/// \\returns The NRVO candidate variable, if the return statement may use the\n/// NRVO, or NULL if there is no such candidate.\nVarDecl *Sema::getCopyElisionCandidate(QualType ReturnType, Expr *E,\n                                       CopyElisionSemanticsKind CESK) {\n  // - in a return statement in a function [where] ...\n  // ... the expression is the name of a non-volatile automatic object ...\n  DeclRefExpr *DR = dyn_cast<DeclRefExpr>(E->IgnoreParens());\n  if (!DR || DR->refersToEnclosingVariableOrCapture())\n    return nullptr;\n  VarDecl *VD = dyn_cast<VarDecl>(DR->getDecl());\n  if (!VD)\n    return nullptr;\n\n  if (isCopyElisionCandidate(ReturnType, VD, CESK))\n    return VD;\n  return nullptr;\n}\n\nbool Sema::isCopyElisionCandidate(QualType ReturnType, const VarDecl *VD,\n                                  CopyElisionSemanticsKind CESK) {\n  QualType VDType = VD->getType();\n  // - in a return statement in a function with ...\n  // ... a class return type ...\n  if (!ReturnType.isNull() && !ReturnType->isDependentType()) {\n    if (!ReturnType->isRecordType())\n      return false;\n    // ... the same cv-unqualified type as the function return type ...\n    // When considering moving this expression out, allow dissimilar types.\n    if (!(CESK & CES_AllowDifferentTypes) && !VDType->isDependentType() &&\n        !Context.hasSameUnqualifiedType(ReturnType, VDType))\n      return false;\n  }\n\n  // ...object (other than a function or catch-clause parameter)...\n  if (VD->getKind() != Decl::Var &&\n      !((CESK & CES_AllowParameters) && VD->getKind() == Decl::ParmVar))\n    return false;\n  if (!(CESK & CES_AllowExceptionVariables) && VD->isExceptionVariable())\n    return false;\n\n  // ...automatic...\n  if (!VD->hasLocalStorage()) return false;\n\n  // Return false if VD is a __block variable. We don't want to implicitly move\n  // out of a __block variable during a return because we cannot assume the\n  // variable will no longer be used.\n  if (VD->hasAttr<BlocksAttr>())\n    return false;\n\n  // ...non-volatile...\n  if (VD->getType().isVolatileQualified())\n    return false;\n\n  // C++20 [class.copy.elision]p3:\n  // ...rvalue reference to a non-volatile...\n  if (VD->getType()->isRValueReferenceType() &&\n      (!(CESK & CES_AllowRValueReferenceType) ||\n       VD->getType().getNonReferenceType().isVolatileQualified()))\n    return false;\n\n  if (CESK & CES_AllowDifferentTypes)\n    return true;\n\n  // Variables with higher required alignment than their type's ABI\n  // alignment cannot use NRVO.\n  if (!VD->getType()->isDependentType() && VD->hasAttr<AlignedAttr>() &&\n      Context.getDeclAlign(VD) > Context.getTypeAlignInChars(VD->getType()))\n    return false;\n\n  return true;\n}\n\n/// Try to perform the initialization of a potentially-movable value,\n/// which is the operand to a return or throw statement.\n///\n/// This routine implements C++20 [class.copy.elision]p3, which attempts to\n/// treat returned lvalues as rvalues in certain cases (to prefer move\n/// construction), then falls back to treating them as lvalues if that failed.\n///\n/// \\param ConvertingConstructorsOnly If true, follow [class.copy.elision]p3 and\n/// reject resolutions that find non-constructors, such as derived-to-base\n/// conversions or `operator T()&&` member functions. If false, do consider such\n/// conversion sequences.\n///\n/// \\param Res We will fill this in if move-initialization was possible.\n/// If move-initialization is not possible, such that we must fall back to\n/// treating the operand as an lvalue, we will leave Res in its original\n/// invalid state.\n///\n/// \\returns Whether we need to do the second overload resolution. If the first\n/// overload resolution fails, or if the first overload resolution succeeds but\n/// the selected constructor/operator doesn't match the additional criteria, we\n/// need to do the second overload resolution.\nstatic bool TryMoveInitialization(Sema &S, const InitializedEntity &Entity,\n                                  const VarDecl *NRVOCandidate,\n                                  QualType ResultType, Expr *&Value,\n                                  bool ConvertingConstructorsOnly,\n                                  bool IsDiagnosticsCheck, ExprResult &Res) {\n  ImplicitCastExpr AsRvalue(ImplicitCastExpr::OnStack, Value->getType(),\n                            CK_NoOp, Value, VK_XValue, FPOptionsOverride());\n\n  Expr *InitExpr = &AsRvalue;\n\n  InitializationKind Kind = InitializationKind::CreateCopy(\n      Value->getBeginLoc(), Value->getBeginLoc());\n\n  InitializationSequence Seq(S, Entity, Kind, InitExpr);\n\n  bool NeedSecondOverloadResolution = true;\n  if (!Seq &&\n      (IsDiagnosticsCheck || Seq.getFailedOverloadResult() != OR_Deleted)) {\n    return NeedSecondOverloadResolution;\n  }\n\n  for (const InitializationSequence::Step &Step : Seq.steps()) {\n    if (Step.Kind != InitializationSequence::SK_ConstructorInitialization &&\n        Step.Kind != InitializationSequence::SK_UserConversion)\n      continue;\n\n    FunctionDecl *FD = Step.Function.Function;\n    if (ConvertingConstructorsOnly) {\n      if (isa<CXXConstructorDecl>(FD)) {\n        // C++11 [class.copy]p32:\n        // C++14 [class.copy]p32:\n        // C++17 [class.copy.elision]p3:\n        // [...] if the type of the first parameter of the selected constructor\n        // is not an rvalue reference to the object's type (possibly\n        // cv-qualified), overload resolution is performed again, considering\n        // the object as an lvalue.\n        const RValueReferenceType *RRefType =\n            FD->getParamDecl(0)->getType()->getAs<RValueReferenceType>();\n        if (!RRefType)\n          break;\n        if (!S.Context.hasSameUnqualifiedType(RRefType->getPointeeType(),\n                                              NRVOCandidate->getType()))\n          break;\n      } else {\n        continue;\n      }\n    } else {\n      if (isa<CXXConstructorDecl>(FD)) {\n        // Check that overload resolution selected a constructor taking an\n        // rvalue reference. If it selected an lvalue reference, then we\n        // didn't need to cast this thing to an rvalue in the first place.\n        if (IsDiagnosticsCheck &&\n            !isa<RValueReferenceType>(FD->getParamDecl(0)->getType()))\n          break;\n      } else if (isa<CXXMethodDecl>(FD)) {\n        // Check that overload resolution selected a conversion operator\n        // taking an rvalue reference.\n        if (cast<CXXMethodDecl>(FD)->getRefQualifier() != RQ_RValue)\n          break;\n      } else {\n        continue;\n      }\n    }\n\n    NeedSecondOverloadResolution = false;\n    // Promote \"AsRvalue\" to the heap, since we now need this\n    // expression node to persist.\n    Value =\n        ImplicitCastExpr::Create(S.Context, Value->getType(), CK_NoOp, Value,\n                                 nullptr, VK_XValue, FPOptionsOverride());\n\n    // Complete type-checking the initialization of the return type\n    // using the constructor we found.\n    Res = Seq.Perform(S, Entity, Kind, Value);\n  }\n\n  return NeedSecondOverloadResolution;\n}\n\n/// Perform the initialization of a potentially-movable value, which\n/// is the result of return value.\n///\n/// This routine implements C++20 [class.copy.elision]p3, which attempts to\n/// treat returned lvalues as rvalues in certain cases (to prefer move\n/// construction), then falls back to treating them as lvalues if that failed.\nExprResult Sema::PerformMoveOrCopyInitialization(\n    const InitializedEntity &Entity, const VarDecl *NRVOCandidate,\n    QualType ResultType, Expr *Value, bool AllowNRVO) {\n  ExprResult Res = ExprError();\n  bool NeedSecondOverloadResolution = true;\n\n  if (AllowNRVO) {\n    CopyElisionSemanticsKind CESK = CES_Strict;\n    if (getLangOpts().CPlusPlus20) {\n      CESK = CES_ImplicitlyMovableCXX20;\n    } else if (getLangOpts().CPlusPlus11) {\n      CESK = CES_ImplicitlyMovableCXX11CXX14CXX17;\n    }\n\n    if (!NRVOCandidate) {\n      NRVOCandidate = getCopyElisionCandidate(ResultType, Value, CESK);\n    }\n\n    if (NRVOCandidate) {\n      NeedSecondOverloadResolution =\n          TryMoveInitialization(*this, Entity, NRVOCandidate, ResultType, Value,\n                                !getLangOpts().CPlusPlus20, false, Res);\n    }\n\n    if (!getLangOpts().CPlusPlus20 && NeedSecondOverloadResolution &&\n        !getDiagnostics().isIgnored(diag::warn_return_std_move,\n                                    Value->getExprLoc())) {\n      const VarDecl *FakeNRVOCandidate = getCopyElisionCandidate(\n          QualType(), Value, CES_ImplicitlyMovableCXX20);\n      if (FakeNRVOCandidate) {\n        QualType QT = FakeNRVOCandidate->getType();\n        if (QT->isLValueReferenceType()) {\n          // Adding 'std::move' around an lvalue reference variable's name is\n          // dangerous. Don't suggest it.\n        } else if (QT.getNonReferenceType()\n                       .getUnqualifiedType()\n                       .isTriviallyCopyableType(Context)) {\n          // Adding 'std::move' around a trivially copyable variable is probably\n          // pointless. Don't suggest it.\n        } else {\n          ExprResult FakeRes = ExprError();\n          Expr *FakeValue = Value;\n          TryMoveInitialization(*this, Entity, FakeNRVOCandidate, ResultType,\n                                FakeValue, false, true, FakeRes);\n          if (!FakeRes.isInvalid()) {\n            bool IsThrow =\n                (Entity.getKind() == InitializedEntity::EK_Exception);\n            SmallString<32> Str;\n            Str += \"std::move(\";\n            Str += FakeNRVOCandidate->getDeclName().getAsString();\n            Str += \")\";\n            Diag(Value->getExprLoc(), diag::warn_return_std_move)\n                << Value->getSourceRange()\n                << FakeNRVOCandidate->getDeclName() << IsThrow;\n            Diag(Value->getExprLoc(), diag::note_add_std_move)\n                << FixItHint::CreateReplacement(Value->getSourceRange(), Str);\n          }\n        }\n      }\n    }\n  }\n\n  // Either we didn't meet the criteria for treating an lvalue as an rvalue,\n  // above, or overload resolution failed. Either way, we need to try\n  // (again) now with the return value expression as written.\n  if (NeedSecondOverloadResolution)\n    Res = PerformCopyInitialization(Entity, SourceLocation(), Value);\n\n  return Res;\n}\n\n/// Determine whether the declared return type of the specified function\n/// contains 'auto'.\nstatic bool hasDeducedReturnType(FunctionDecl *FD) {\n  const FunctionProtoType *FPT =\n      FD->getTypeSourceInfo()->getType()->castAs<FunctionProtoType>();\n  return FPT->getReturnType()->isUndeducedType();\n}\n\n/// ActOnCapScopeReturnStmt - Utility routine to type-check return statements\n/// for capturing scopes.\n///\nStmtResult\nSema::ActOnCapScopeReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp) {\n  // If this is the first return we've seen, infer the return type.\n  // [expr.prim.lambda]p4 in C++11; block literals follow the same rules.\n  CapturingScopeInfo *CurCap = cast<CapturingScopeInfo>(getCurFunction());\n  QualType FnRetType = CurCap->ReturnType;\n  LambdaScopeInfo *CurLambda = dyn_cast<LambdaScopeInfo>(CurCap);\n  bool HasDeducedReturnType =\n      CurLambda && hasDeducedReturnType(CurLambda->CallOperator);\n\n  if (ExprEvalContexts.back().Context ==\n          ExpressionEvaluationContext::DiscardedStatement &&\n      (HasDeducedReturnType || CurCap->HasImplicitReturnType)) {\n    if (RetValExp) {\n      ExprResult ER =\n          ActOnFinishFullExpr(RetValExp, ReturnLoc, /*DiscardedValue*/ false);\n      if (ER.isInvalid())\n        return StmtError();\n      RetValExp = ER.get();\n    }\n    return ReturnStmt::Create(Context, ReturnLoc, RetValExp,\n                              /* NRVOCandidate=*/nullptr);\n  }\n\n  if (HasDeducedReturnType) {\n    FunctionDecl *FD = CurLambda->CallOperator;\n    // If we've already decided this lambda is invalid, e.g. because\n    // we saw a `return` whose expression had an error, don't keep\n    // trying to deduce its return type.\n    if (FD->isInvalidDecl())\n      return StmtError();\n    // In C++1y, the return type may involve 'auto'.\n    // FIXME: Blocks might have a return type of 'auto' explicitly specified.\n    if (CurCap->ReturnType.isNull())\n      CurCap->ReturnType = FD->getReturnType();\n\n    AutoType *AT = CurCap->ReturnType->getContainedAutoType();\n    assert(AT && \"lost auto type from lambda return type\");\n    if (DeduceFunctionTypeFromReturnExpr(FD, ReturnLoc, RetValExp, AT)) {\n      FD->setInvalidDecl();\n      // FIXME: preserve the ill-formed return expression.\n      return StmtError();\n    }\n    CurCap->ReturnType = FnRetType = FD->getReturnType();\n  } else if (CurCap->HasImplicitReturnType) {\n    // For blocks/lambdas with implicit return types, we check each return\n    // statement individually, and deduce the common return type when the block\n    // or lambda is completed.\n    // FIXME: Fold this into the 'auto' codepath above.\n    if (RetValExp && !isa<InitListExpr>(RetValExp)) {\n      ExprResult Result = DefaultFunctionArrayLvalueConversion(RetValExp);\n      if (Result.isInvalid())\n        return StmtError();\n      RetValExp = Result.get();\n\n      // DR1048: even prior to C++14, we should use the 'auto' deduction rules\n      // when deducing a return type for a lambda-expression (or by extension\n      // for a block). These rules differ from the stated C++11 rules only in\n      // that they remove top-level cv-qualifiers.\n      if (!CurContext->isDependentContext())\n        FnRetType = RetValExp->getType().getUnqualifiedType();\n      else\n        FnRetType = CurCap->ReturnType = Context.DependentTy;\n    } else {\n      if (RetValExp) {\n        // C++11 [expr.lambda.prim]p4 bans inferring the result from an\n        // initializer list, because it is not an expression (even\n        // though we represent it as one). We still deduce 'void'.\n        Diag(ReturnLoc, diag::err_lambda_return_init_list)\n          << RetValExp->getSourceRange();\n      }\n\n      FnRetType = Context.VoidTy;\n    }\n\n    // Although we'll properly infer the type of the block once it's completed,\n    // make sure we provide a return type now for better error recovery.\n    if (CurCap->ReturnType.isNull())\n      CurCap->ReturnType = FnRetType;\n  }\n  assert(!FnRetType.isNull());\n\n  if (auto *CurBlock = dyn_cast<BlockScopeInfo>(CurCap)) {\n    if (CurBlock->FunctionType->castAs<FunctionType>()->getNoReturnAttr()) {\n      Diag(ReturnLoc, diag::err_noreturn_block_has_return_expr);\n      return StmtError();\n    }\n  } else if (auto *CurRegion = dyn_cast<CapturedRegionScopeInfo>(CurCap)) {\n    Diag(ReturnLoc, diag::err_return_in_captured_stmt) << CurRegion->getRegionName();\n    return StmtError();\n  } else {\n    assert(CurLambda && \"unknown kind of captured scope\");\n    if (CurLambda->CallOperator->getType()\n            ->castAs<FunctionType>()\n            ->getNoReturnAttr()) {\n      Diag(ReturnLoc, diag::err_noreturn_lambda_has_return_expr);\n      return StmtError();\n    }\n  }\n\n  // Otherwise, verify that this result type matches the previous one.  We are\n  // pickier with blocks than for normal functions because we don't have GCC\n  // compatibility to worry about here.\n  const VarDecl *NRVOCandidate = nullptr;\n  if (FnRetType->isDependentType()) {\n    // Delay processing for now.  TODO: there are lots of dependent\n    // types we can conclusively prove aren't void.\n  } else if (FnRetType->isVoidType()) {\n    if (RetValExp && !isa<InitListExpr>(RetValExp) &&\n        !(getLangOpts().CPlusPlus &&\n          (RetValExp->isTypeDependent() ||\n           RetValExp->getType()->isVoidType()))) {\n      if (!getLangOpts().CPlusPlus &&\n          RetValExp->getType()->isVoidType())\n        Diag(ReturnLoc, diag::ext_return_has_void_expr) << \"literal\" << 2;\n      else {\n        Diag(ReturnLoc, diag::err_return_block_has_expr);\n        RetValExp = nullptr;\n      }\n    }\n  } else if (!RetValExp) {\n    return StmtError(Diag(ReturnLoc, diag::err_block_return_missing_expr));\n  } else if (!RetValExp->isTypeDependent()) {\n    // we have a non-void block with an expression, continue checking\n\n    // C99 6.8.6.4p3(136): The return statement is not an assignment. The\n    // overlap restriction of subclause 6.5.16.1 does not apply to the case of\n    // function return.\n\n    // In C++ the return statement is handled via a copy initialization.\n    // the C version of which boils down to CheckSingleAssignmentConstraints.\n    NRVOCandidate = getCopyElisionCandidate(FnRetType, RetValExp, CES_Strict);\n    InitializedEntity Entity = InitializedEntity::InitializeResult(ReturnLoc,\n                                                                   FnRetType,\n                                                      NRVOCandidate != nullptr);\n    ExprResult Res = PerformMoveOrCopyInitialization(Entity, NRVOCandidate,\n                                                     FnRetType, RetValExp);\n    if (Res.isInvalid()) {\n      // FIXME: Cleanup temporaries here, anyway?\n      return StmtError();\n    }\n    RetValExp = Res.get();\n    CheckReturnValExpr(RetValExp, FnRetType, ReturnLoc);\n  } else {\n    NRVOCandidate = getCopyElisionCandidate(FnRetType, RetValExp, CES_Strict);\n  }\n\n  if (RetValExp) {\n    ExprResult ER =\n        ActOnFinishFullExpr(RetValExp, ReturnLoc, /*DiscardedValue*/ false);\n    if (ER.isInvalid())\n      return StmtError();\n    RetValExp = ER.get();\n  }\n  auto *Result =\n      ReturnStmt::Create(Context, ReturnLoc, RetValExp, NRVOCandidate);\n\n  // If we need to check for the named return value optimization,\n  // or if we need to infer the return type,\n  // save the return statement in our scope for later processing.\n  if (CurCap->HasImplicitReturnType || NRVOCandidate)\n    FunctionScopes.back()->Returns.push_back(Result);\n\n  if (FunctionScopes.back()->FirstReturnLoc.isInvalid())\n    FunctionScopes.back()->FirstReturnLoc = ReturnLoc;\n\n  return Result;\n}\n\nnamespace {\n/// Marks all typedefs in all local classes in a type referenced.\n///\n/// In a function like\n/// auto f() {\n///   struct S { typedef int a; };\n///   return S();\n/// }\n///\n/// the local type escapes and could be referenced in some TUs but not in\n/// others. Pretend that all local typedefs are always referenced, to not warn\n/// on this. This isn't necessary if f has internal linkage, or the typedef\n/// is private.\nclass LocalTypedefNameReferencer\n    : public RecursiveASTVisitor<LocalTypedefNameReferencer> {\npublic:\n  LocalTypedefNameReferencer(Sema &S) : S(S) {}\n  bool VisitRecordType(const RecordType *RT);\nprivate:\n  Sema &S;\n};\nbool LocalTypedefNameReferencer::VisitRecordType(const RecordType *RT) {\n  auto *R = dyn_cast<CXXRecordDecl>(RT->getDecl());\n  if (!R || !R->isLocalClass() || !R->isLocalClass()->isExternallyVisible() ||\n      R->isDependentType())\n    return true;\n  for (auto *TmpD : R->decls())\n    if (auto *T = dyn_cast<TypedefNameDecl>(TmpD))\n      if (T->getAccess() != AS_private || R->hasFriends())\n        S.MarkAnyDeclReferenced(T->getLocation(), T, /*OdrUse=*/false);\n  return true;\n}\n}\n\nTypeLoc Sema::getReturnTypeLoc(FunctionDecl *FD) const {\n  return FD->getTypeSourceInfo()\n      ->getTypeLoc()\n      .getAsAdjusted<FunctionProtoTypeLoc>()\n      .getReturnLoc();\n}\n\n/// Deduce the return type for a function from a returned expression, per\n/// C++1y [dcl.spec.auto]p6.\nbool Sema::DeduceFunctionTypeFromReturnExpr(FunctionDecl *FD,\n                                            SourceLocation ReturnLoc,\n                                            Expr *&RetExpr,\n                                            AutoType *AT) {\n  // If this is the conversion function for a lambda, we choose to deduce it\n  // type from the corresponding call operator, not from the synthesized return\n  // statement within it. See Sema::DeduceReturnType.\n  if (isLambdaConversionOperator(FD))\n    return false;\n\n  TypeLoc OrigResultType = getReturnTypeLoc(FD);\n  QualType Deduced;\n\n  if (RetExpr && isa<InitListExpr>(RetExpr)) {\n    //  If the deduction is for a return statement and the initializer is\n    //  a braced-init-list, the program is ill-formed.\n    Diag(RetExpr->getExprLoc(),\n         getCurLambda() ? diag::err_lambda_return_init_list\n                        : diag::err_auto_fn_return_init_list)\n        << RetExpr->getSourceRange();\n    return true;\n  }\n\n  if (FD->isDependentContext()) {\n    // C++1y [dcl.spec.auto]p12:\n    //   Return type deduction [...] occurs when the definition is\n    //   instantiated even if the function body contains a return\n    //   statement with a non-type-dependent operand.\n    assert(AT->isDeduced() && \"should have deduced to dependent type\");\n    return false;\n  }\n\n  if (RetExpr) {\n    //  Otherwise, [...] deduce a value for U using the rules of template\n    //  argument deduction.\n    DeduceAutoResult DAR = DeduceAutoType(OrigResultType, RetExpr, Deduced);\n\n    if (DAR == DAR_Failed && !FD->isInvalidDecl())\n      Diag(RetExpr->getExprLoc(), diag::err_auto_fn_deduction_failure)\n        << OrigResultType.getType() << RetExpr->getType();\n\n    if (DAR != DAR_Succeeded)\n      return true;\n\n    // If a local type is part of the returned type, mark its fields as\n    // referenced.\n    LocalTypedefNameReferencer Referencer(*this);\n    Referencer.TraverseType(RetExpr->getType());\n  } else {\n    //  In the case of a return with no operand, the initializer is considered\n    //  to be void().\n    //\n    // Deduction here can only succeed if the return type is exactly 'cv auto'\n    // or 'decltype(auto)', so just check for that case directly.\n    if (!OrigResultType.getType()->getAs<AutoType>()) {\n      Diag(ReturnLoc, diag::err_auto_fn_return_void_but_not_auto)\n        << OrigResultType.getType();\n      return true;\n    }\n    // We always deduce U = void in this case.\n    Deduced = SubstAutoType(OrigResultType.getType(), Context.VoidTy);\n    if (Deduced.isNull())\n      return true;\n  }\n\n  // CUDA: Kernel function must have 'void' return type.\n  if (getLangOpts().CUDA)\n    if (FD->hasAttr<CUDAGlobalAttr>() && !Deduced->isVoidType()) {\n      Diag(FD->getLocation(), diag::err_kern_type_not_void_return)\n          << FD->getType() << FD->getSourceRange();\n      return true;\n    }\n\n  //  If a function with a declared return type that contains a placeholder type\n  //  has multiple return statements, the return type is deduced for each return\n  //  statement. [...] if the type deduced is not the same in each deduction,\n  //  the program is ill-formed.\n  QualType DeducedT = AT->getDeducedType();\n  if (!DeducedT.isNull() && !FD->isInvalidDecl()) {\n    AutoType *NewAT = Deduced->getContainedAutoType();\n    // It is possible that NewAT->getDeducedType() is null. When that happens,\n    // we should not crash, instead we ignore this deduction.\n    if (NewAT->getDeducedType().isNull())\n      return false;\n\n    CanQualType OldDeducedType = Context.getCanonicalFunctionResultType(\n                                   DeducedT);\n    CanQualType NewDeducedType = Context.getCanonicalFunctionResultType(\n                                   NewAT->getDeducedType());\n    if (!FD->isDependentContext() && OldDeducedType != NewDeducedType) {\n      const LambdaScopeInfo *LambdaSI = getCurLambda();\n      if (LambdaSI && LambdaSI->HasImplicitReturnType) {\n        Diag(ReturnLoc, diag::err_typecheck_missing_return_type_incompatible)\n          << NewAT->getDeducedType() << DeducedT\n          << true /*IsLambda*/;\n      } else {\n        Diag(ReturnLoc, diag::err_auto_fn_different_deductions)\n          << (AT->isDecltypeAuto() ? 1 : 0)\n          << NewAT->getDeducedType() << DeducedT;\n      }\n      return true;\n    }\n  } else if (!FD->isInvalidDecl()) {\n    // Update all declarations of the function to have the deduced return type.\n    Context.adjustDeducedFunctionResultType(FD, Deduced);\n  }\n\n  return false;\n}\n\nStmtResult\nSema::ActOnReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp,\n                      Scope *CurScope) {\n  // Correct typos, in case the containing function returns 'auto' and\n  // RetValExp should determine the deduced type.\n  ExprResult RetVal = CorrectDelayedTyposInExpr(\n      RetValExp, nullptr, /*RecoverUncorrectedTypos=*/true);\n  if (RetVal.isInvalid())\n    return StmtError();\n  StmtResult R = BuildReturnStmt(ReturnLoc, RetVal.get());\n  if (R.isInvalid() || ExprEvalContexts.back().Context ==\n                           ExpressionEvaluationContext::DiscardedStatement)\n    return R;\n\n  if (VarDecl *VD =\n      const_cast<VarDecl*>(cast<ReturnStmt>(R.get())->getNRVOCandidate())) {\n    CurScope->addNRVOCandidate(VD);\n  } else {\n    CurScope->setNoNRVO();\n  }\n\n  CheckJumpOutOfSEHFinally(*this, ReturnLoc, *CurScope->getFnParent());\n\n  return R;\n}\n\nStmtResult Sema::BuildReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp) {\n  // Check for unexpanded parameter packs.\n  if (RetValExp && DiagnoseUnexpandedParameterPack(RetValExp))\n    return StmtError();\n\n  if (isa<CapturingScopeInfo>(getCurFunction()))\n    return ActOnCapScopeReturnStmt(ReturnLoc, RetValExp);\n\n  QualType FnRetType;\n  QualType RelatedRetType;\n  const AttrVec *Attrs = nullptr;\n  bool isObjCMethod = false;\n\n  if (const FunctionDecl *FD = getCurFunctionDecl()) {\n    FnRetType = FD->getReturnType();\n    if (FD->hasAttrs())\n      Attrs = &FD->getAttrs();\n    if (FD->isNoReturn())\n      Diag(ReturnLoc, diag::warn_noreturn_function_has_return_expr) << FD;\n    if (FD->isMain() && RetValExp)\n      if (isa<CXXBoolLiteralExpr>(RetValExp))\n        Diag(ReturnLoc, diag::warn_main_returns_bool_literal)\n            << RetValExp->getSourceRange();\n    if (FD->hasAttr<CmseNSEntryAttr>() && RetValExp) {\n      if (const auto *RT = dyn_cast<RecordType>(FnRetType.getCanonicalType())) {\n        if (RT->getDecl()->isOrContainsUnion())\n          Diag(RetValExp->getBeginLoc(), diag::warn_cmse_nonsecure_union) << 1;\n      }\n    }\n  } else if (ObjCMethodDecl *MD = getCurMethodDecl()) {\n    FnRetType = MD->getReturnType();\n    isObjCMethod = true;\n    if (MD->hasAttrs())\n      Attrs = &MD->getAttrs();\n    if (MD->hasRelatedResultType() && MD->getClassInterface()) {\n      // In the implementation of a method with a related return type, the\n      // type used to type-check the validity of return statements within the\n      // method body is a pointer to the type of the class being implemented.\n      RelatedRetType = Context.getObjCInterfaceType(MD->getClassInterface());\n      RelatedRetType = Context.getObjCObjectPointerType(RelatedRetType);\n    }\n  } else // If we don't have a function/method context, bail.\n    return StmtError();\n\n  // C++1z: discarded return statements are not considered when deducing a\n  // return type.\n  if (ExprEvalContexts.back().Context ==\n          ExpressionEvaluationContext::DiscardedStatement &&\n      FnRetType->getContainedAutoType()) {\n    if (RetValExp) {\n      ExprResult ER =\n          ActOnFinishFullExpr(RetValExp, ReturnLoc, /*DiscardedValue*/ false);\n      if (ER.isInvalid())\n        return StmtError();\n      RetValExp = ER.get();\n    }\n    return ReturnStmt::Create(Context, ReturnLoc, RetValExp,\n                              /* NRVOCandidate=*/nullptr);\n  }\n\n  // FIXME: Add a flag to the ScopeInfo to indicate whether we're performing\n  // deduction.\n  if (getLangOpts().CPlusPlus14) {\n    if (AutoType *AT = FnRetType->getContainedAutoType()) {\n      FunctionDecl *FD = cast<FunctionDecl>(CurContext);\n      // If we've already decided this function is invalid, e.g. because\n      // we saw a `return` whose expression had an error, don't keep\n      // trying to deduce its return type.\n      if (FD->isInvalidDecl())\n        return StmtError();\n      if (DeduceFunctionTypeFromReturnExpr(FD, ReturnLoc, RetValExp, AT)) {\n        FD->setInvalidDecl();\n        return StmtError();\n      } else {\n        FnRetType = FD->getReturnType();\n      }\n    }\n  }\n\n  bool HasDependentReturnType = FnRetType->isDependentType();\n\n  ReturnStmt *Result = nullptr;\n  if (FnRetType->isVoidType()) {\n    if (RetValExp) {\n      if (isa<InitListExpr>(RetValExp)) {\n        // We simply never allow init lists as the return value of void\n        // functions. This is compatible because this was never allowed before,\n        // so there's no legacy code to deal with.\n        NamedDecl *CurDecl = getCurFunctionOrMethodDecl();\n        int FunctionKind = 0;\n        if (isa<ObjCMethodDecl>(CurDecl))\n          FunctionKind = 1;\n        else if (isa<CXXConstructorDecl>(CurDecl))\n          FunctionKind = 2;\n        else if (isa<CXXDestructorDecl>(CurDecl))\n          FunctionKind = 3;\n\n        Diag(ReturnLoc, diag::err_return_init_list)\n            << CurDecl << FunctionKind << RetValExp->getSourceRange();\n\n        // Drop the expression.\n        RetValExp = nullptr;\n      } else if (!RetValExp->isTypeDependent()) {\n        // C99 6.8.6.4p1 (ext_ since GCC warns)\n        unsigned D = diag::ext_return_has_expr;\n        if (RetValExp->getType()->isVoidType()) {\n          NamedDecl *CurDecl = getCurFunctionOrMethodDecl();\n          if (isa<CXXConstructorDecl>(CurDecl) ||\n              isa<CXXDestructorDecl>(CurDecl))\n            D = diag::err_ctor_dtor_returns_void;\n          else\n            D = diag::ext_return_has_void_expr;\n        }\n        else {\n          ExprResult Result = RetValExp;\n          Result = IgnoredValueConversions(Result.get());\n          if (Result.isInvalid())\n            return StmtError();\n          RetValExp = Result.get();\n          RetValExp = ImpCastExprToType(RetValExp,\n                                        Context.VoidTy, CK_ToVoid).get();\n        }\n        // return of void in constructor/destructor is illegal in C++.\n        if (D == diag::err_ctor_dtor_returns_void) {\n          NamedDecl *CurDecl = getCurFunctionOrMethodDecl();\n          Diag(ReturnLoc, D) << CurDecl << isa<CXXDestructorDecl>(CurDecl)\n                             << RetValExp->getSourceRange();\n        }\n        // return (some void expression); is legal in C++.\n        else if (D != diag::ext_return_has_void_expr ||\n                 !getLangOpts().CPlusPlus) {\n          NamedDecl *CurDecl = getCurFunctionOrMethodDecl();\n\n          int FunctionKind = 0;\n          if (isa<ObjCMethodDecl>(CurDecl))\n            FunctionKind = 1;\n          else if (isa<CXXConstructorDecl>(CurDecl))\n            FunctionKind = 2;\n          else if (isa<CXXDestructorDecl>(CurDecl))\n            FunctionKind = 3;\n\n          Diag(ReturnLoc, D)\n              << CurDecl << FunctionKind << RetValExp->getSourceRange();\n        }\n      }\n\n      if (RetValExp) {\n        ExprResult ER =\n            ActOnFinishFullExpr(RetValExp, ReturnLoc, /*DiscardedValue*/ false);\n        if (ER.isInvalid())\n          return StmtError();\n        RetValExp = ER.get();\n      }\n    }\n\n    Result = ReturnStmt::Create(Context, ReturnLoc, RetValExp,\n                                /* NRVOCandidate=*/nullptr);\n  } else if (!RetValExp && !HasDependentReturnType) {\n    FunctionDecl *FD = getCurFunctionDecl();\n\n    if (getLangOpts().CPlusPlus11 && FD && FD->isConstexpr()) {\n      // C++11 [stmt.return]p2\n      Diag(ReturnLoc, diag::err_constexpr_return_missing_expr)\n          << FD << FD->isConsteval();\n      FD->setInvalidDecl();\n    } else {\n      // C99 6.8.6.4p1 (ext_ since GCC warns)\n      // C90 6.6.6.4p4\n      unsigned DiagID = getLangOpts().C99 ? diag::ext_return_missing_expr\n                                          : diag::warn_return_missing_expr;\n      // Note that at this point one of getCurFunctionDecl() or\n      // getCurMethodDecl() must be non-null (see above).\n      assert((getCurFunctionDecl() || getCurMethodDecl()) &&\n             \"Not in a FunctionDecl or ObjCMethodDecl?\");\n      bool IsMethod = FD == nullptr;\n      const NamedDecl *ND =\n          IsMethod ? cast<NamedDecl>(getCurMethodDecl()) : cast<NamedDecl>(FD);\n      Diag(ReturnLoc, DiagID) << ND << IsMethod;\n    }\n\n    Result = ReturnStmt::Create(Context, ReturnLoc, /* RetExpr=*/nullptr,\n                                /* NRVOCandidate=*/nullptr);\n  } else {\n    assert(RetValExp || HasDependentReturnType);\n    const VarDecl *NRVOCandidate = nullptr;\n\n    QualType RetType = RelatedRetType.isNull() ? FnRetType : RelatedRetType;\n\n    // C99 6.8.6.4p3(136): The return statement is not an assignment. The\n    // overlap restriction of subclause 6.5.16.1 does not apply to the case of\n    // function return.\n\n    // In C++ the return statement is handled via a copy initialization,\n    // the C version of which boils down to CheckSingleAssignmentConstraints.\n    if (RetValExp)\n      NRVOCandidate = getCopyElisionCandidate(FnRetType, RetValExp, CES_Strict);\n    if (!HasDependentReturnType && !RetValExp->isTypeDependent()) {\n      // we have a non-void function with an expression, continue checking\n      InitializedEntity Entity = InitializedEntity::InitializeResult(ReturnLoc,\n                                                                     RetType,\n                                                      NRVOCandidate != nullptr);\n      ExprResult Res = PerformMoveOrCopyInitialization(Entity, NRVOCandidate,\n                                                       RetType, RetValExp);\n      if (Res.isInvalid()) {\n        // FIXME: Clean up temporaries here anyway?\n        return StmtError();\n      }\n      RetValExp = Res.getAs<Expr>();\n\n      // If we have a related result type, we need to implicitly\n      // convert back to the formal result type.  We can't pretend to\n      // initialize the result again --- we might end double-retaining\n      // --- so instead we initialize a notional temporary.\n      if (!RelatedRetType.isNull()) {\n        Entity = InitializedEntity::InitializeRelatedResult(getCurMethodDecl(),\n                                                            FnRetType);\n        Res = PerformCopyInitialization(Entity, ReturnLoc, RetValExp);\n        if (Res.isInvalid()) {\n          // FIXME: Clean up temporaries here anyway?\n          return StmtError();\n        }\n        RetValExp = Res.getAs<Expr>();\n      }\n\n      CheckReturnValExpr(RetValExp, FnRetType, ReturnLoc, isObjCMethod, Attrs,\n                         getCurFunctionDecl());\n    }\n\n    if (RetValExp) {\n      ExprResult ER =\n          ActOnFinishFullExpr(RetValExp, ReturnLoc, /*DiscardedValue*/ false);\n      if (ER.isInvalid())\n        return StmtError();\n      RetValExp = ER.get();\n    }\n    Result = ReturnStmt::Create(Context, ReturnLoc, RetValExp, NRVOCandidate);\n  }\n\n  // If we need to check for the named return value optimization, save the\n  // return statement in our scope for later processing.\n  if (Result->getNRVOCandidate())\n    FunctionScopes.back()->Returns.push_back(Result);\n\n  if (FunctionScopes.back()->FirstReturnLoc.isInvalid())\n    FunctionScopes.back()->FirstReturnLoc = ReturnLoc;\n\n  return Result;\n}\n\nStmtResult\nSema::ActOnObjCAtCatchStmt(SourceLocation AtLoc,\n                           SourceLocation RParen, Decl *Parm,\n                           Stmt *Body) {\n  VarDecl *Var = cast_or_null<VarDecl>(Parm);\n  if (Var && Var->isInvalidDecl())\n    return StmtError();\n\n  return new (Context) ObjCAtCatchStmt(AtLoc, RParen, Var, Body);\n}\n\nStmtResult\nSema::ActOnObjCAtFinallyStmt(SourceLocation AtLoc, Stmt *Body) {\n  return new (Context) ObjCAtFinallyStmt(AtLoc, Body);\n}\n\nStmtResult\nSema::ActOnObjCAtTryStmt(SourceLocation AtLoc, Stmt *Try,\n                         MultiStmtArg CatchStmts, Stmt *Finally) {\n  if (!getLangOpts().ObjCExceptions)\n    Diag(AtLoc, diag::err_objc_exceptions_disabled) << \"@try\";\n\n  setFunctionHasBranchProtectedScope();\n  unsigned NumCatchStmts = CatchStmts.size();\n  return ObjCAtTryStmt::Create(Context, AtLoc, Try, CatchStmts.data(),\n                               NumCatchStmts, Finally);\n}\n\nStmtResult Sema::BuildObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw) {\n  if (Throw) {\n    ExprResult Result = DefaultLvalueConversion(Throw);\n    if (Result.isInvalid())\n      return StmtError();\n\n    Result = ActOnFinishFullExpr(Result.get(), /*DiscardedValue*/ false);\n    if (Result.isInvalid())\n      return StmtError();\n    Throw = Result.get();\n\n    QualType ThrowType = Throw->getType();\n    // Make sure the expression type is an ObjC pointer or \"void *\".\n    if (!ThrowType->isDependentType() &&\n        !ThrowType->isObjCObjectPointerType()) {\n      const PointerType *PT = ThrowType->getAs<PointerType>();\n      if (!PT || !PT->getPointeeType()->isVoidType())\n        return StmtError(Diag(AtLoc, diag::err_objc_throw_expects_object)\n                         << Throw->getType() << Throw->getSourceRange());\n    }\n  }\n\n  return new (Context) ObjCAtThrowStmt(AtLoc, Throw);\n}\n\nStmtResult\nSema::ActOnObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw,\n                           Scope *CurScope) {\n  if (!getLangOpts().ObjCExceptions)\n    Diag(AtLoc, diag::err_objc_exceptions_disabled) << \"@throw\";\n\n  if (!Throw) {\n    // @throw without an expression designates a rethrow (which must occur\n    // in the context of an @catch clause).\n    Scope *AtCatchParent = CurScope;\n    while (AtCatchParent && !AtCatchParent->isAtCatchScope())\n      AtCatchParent = AtCatchParent->getParent();\n    if (!AtCatchParent)\n      return StmtError(Diag(AtLoc, diag::err_rethrow_used_outside_catch));\n  }\n  return BuildObjCAtThrowStmt(AtLoc, Throw);\n}\n\nExprResult\nSema::ActOnObjCAtSynchronizedOperand(SourceLocation atLoc, Expr *operand) {\n  ExprResult result = DefaultLvalueConversion(operand);\n  if (result.isInvalid())\n    return ExprError();\n  operand = result.get();\n\n  // Make sure the expression type is an ObjC pointer or \"void *\".\n  QualType type = operand->getType();\n  if (!type->isDependentType() &&\n      !type->isObjCObjectPointerType()) {\n    const PointerType *pointerType = type->getAs<PointerType>();\n    if (!pointerType || !pointerType->getPointeeType()->isVoidType()) {\n      if (getLangOpts().CPlusPlus) {\n        if (RequireCompleteType(atLoc, type,\n                                diag::err_incomplete_receiver_type))\n          return Diag(atLoc, diag::err_objc_synchronized_expects_object)\n                   << type << operand->getSourceRange();\n\n        ExprResult result = PerformContextuallyConvertToObjCPointer(operand);\n        if (result.isInvalid())\n          return ExprError();\n        if (!result.isUsable())\n          return Diag(atLoc, diag::err_objc_synchronized_expects_object)\n                   << type << operand->getSourceRange();\n\n        operand = result.get();\n      } else {\n          return Diag(atLoc, diag::err_objc_synchronized_expects_object)\n                   << type << operand->getSourceRange();\n      }\n    }\n  }\n\n  // The operand to @synchronized is a full-expression.\n  return ActOnFinishFullExpr(operand, /*DiscardedValue*/ false);\n}\n\nStmtResult\nSema::ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc, Expr *SyncExpr,\n                                  Stmt *SyncBody) {\n  // We can't jump into or indirect-jump out of a @synchronized block.\n  setFunctionHasBranchProtectedScope();\n  return new (Context) ObjCAtSynchronizedStmt(AtLoc, SyncExpr, SyncBody);\n}\n\n/// ActOnCXXCatchBlock - Takes an exception declaration and a handler block\n/// and creates a proper catch handler from them.\nStmtResult\nSema::ActOnCXXCatchBlock(SourceLocation CatchLoc, Decl *ExDecl,\n                         Stmt *HandlerBlock) {\n  // There's nothing to test that ActOnExceptionDecl didn't already test.\n  return new (Context)\n      CXXCatchStmt(CatchLoc, cast_or_null<VarDecl>(ExDecl), HandlerBlock);\n}\n\nStmtResult\nSema::ActOnObjCAutoreleasePoolStmt(SourceLocation AtLoc, Stmt *Body) {\n  setFunctionHasBranchProtectedScope();\n  return new (Context) ObjCAutoreleasePoolStmt(AtLoc, Body);\n}\n\nnamespace {\nclass CatchHandlerType {\n  QualType QT;\n  unsigned IsPointer : 1;\n\n  // This is a special constructor to be used only with DenseMapInfo's\n  // getEmptyKey() and getTombstoneKey() functions.\n  friend struct llvm::DenseMapInfo<CatchHandlerType>;\n  enum Unique { ForDenseMap };\n  CatchHandlerType(QualType QT, Unique) : QT(QT), IsPointer(false) {}\n\npublic:\n  /// Used when creating a CatchHandlerType from a handler type; will determine\n  /// whether the type is a pointer or reference and will strip off the top\n  /// level pointer and cv-qualifiers.\n  CatchHandlerType(QualType Q) : QT(Q), IsPointer(false) {\n    if (QT->isPointerType())\n      IsPointer = true;\n\n    if (IsPointer || QT->isReferenceType())\n      QT = QT->getPointeeType();\n    QT = QT.getUnqualifiedType();\n  }\n\n  /// Used when creating a CatchHandlerType from a base class type; pretends the\n  /// type passed in had the pointer qualifier, does not need to get an\n  /// unqualified type.\n  CatchHandlerType(QualType QT, bool IsPointer)\n      : QT(QT), IsPointer(IsPointer) {}\n\n  QualType underlying() const { return QT; }\n  bool isPointer() const { return IsPointer; }\n\n  friend bool operator==(const CatchHandlerType &LHS,\n                         const CatchHandlerType &RHS) {\n    // If the pointer qualification does not match, we can return early.\n    if (LHS.IsPointer != RHS.IsPointer)\n      return false;\n    // Otherwise, check the underlying type without cv-qualifiers.\n    return LHS.QT == RHS.QT;\n  }\n};\n} // namespace\n\nnamespace llvm {\ntemplate <> struct DenseMapInfo<CatchHandlerType> {\n  static CatchHandlerType getEmptyKey() {\n    return CatchHandlerType(DenseMapInfo<QualType>::getEmptyKey(),\n                       CatchHandlerType::ForDenseMap);\n  }\n\n  static CatchHandlerType getTombstoneKey() {\n    return CatchHandlerType(DenseMapInfo<QualType>::getTombstoneKey(),\n                       CatchHandlerType::ForDenseMap);\n  }\n\n  static unsigned getHashValue(const CatchHandlerType &Base) {\n    return DenseMapInfo<QualType>::getHashValue(Base.underlying());\n  }\n\n  static bool isEqual(const CatchHandlerType &LHS,\n                      const CatchHandlerType &RHS) {\n    return LHS == RHS;\n  }\n};\n}\n\nnamespace {\nclass CatchTypePublicBases {\n  ASTContext &Ctx;\n  const llvm::DenseMap<CatchHandlerType, CXXCatchStmt *> &TypesToCheck;\n  const bool CheckAgainstPointer;\n\n  CXXCatchStmt *FoundHandler;\n  CanQualType FoundHandlerType;\n\npublic:\n  CatchTypePublicBases(\n      ASTContext &Ctx,\n      const llvm::DenseMap<CatchHandlerType, CXXCatchStmt *> &T, bool C)\n      : Ctx(Ctx), TypesToCheck(T), CheckAgainstPointer(C),\n        FoundHandler(nullptr) {}\n\n  CXXCatchStmt *getFoundHandler() const { return FoundHandler; }\n  CanQualType getFoundHandlerType() const { return FoundHandlerType; }\n\n  bool operator()(const CXXBaseSpecifier *S, CXXBasePath &) {\n    if (S->getAccessSpecifier() == AccessSpecifier::AS_public) {\n      CatchHandlerType Check(S->getType(), CheckAgainstPointer);\n      const auto &M = TypesToCheck;\n      auto I = M.find(Check);\n      if (I != M.end()) {\n        FoundHandler = I->second;\n        FoundHandlerType = Ctx.getCanonicalType(S->getType());\n        return true;\n      }\n    }\n    return false;\n  }\n};\n}\n\n/// ActOnCXXTryBlock - Takes a try compound-statement and a number of\n/// handlers and creates a try statement from them.\nStmtResult Sema::ActOnCXXTryBlock(SourceLocation TryLoc, Stmt *TryBlock,\n                                  ArrayRef<Stmt *> Handlers) {\n  // Don't report an error if 'try' is used in system headers.\n  if (!getLangOpts().CXXExceptions &&\n      !getSourceManager().isInSystemHeader(TryLoc) && !getLangOpts().CUDA) {\n    // Delay error emission for the OpenMP device code.\n    targetDiag(TryLoc, diag::err_exceptions_disabled) << \"try\";\n  }\n\n  // Exceptions aren't allowed in CUDA device code.\n  if (getLangOpts().CUDA)\n    CUDADiagIfDeviceCode(TryLoc, diag::err_cuda_device_exceptions)\n        << \"try\" << CurrentCUDATarget();\n\n  if (getCurScope() && getCurScope()->isOpenMPSimdDirectiveScope())\n    Diag(TryLoc, diag::err_omp_simd_region_cannot_use_stmt) << \"try\";\n\n  sema::FunctionScopeInfo *FSI = getCurFunction();\n\n  // C++ try is incompatible with SEH __try.\n  if (!getLangOpts().Borland && FSI->FirstSEHTryLoc.isValid()) {\n    Diag(TryLoc, diag::err_mixing_cxx_try_seh_try);\n    Diag(FSI->FirstSEHTryLoc, diag::note_conflicting_try_here) << \"'__try'\";\n  }\n\n  const unsigned NumHandlers = Handlers.size();\n  assert(!Handlers.empty() &&\n         \"The parser shouldn't call this if there are no handlers.\");\n\n  llvm::DenseMap<CatchHandlerType, CXXCatchStmt *> HandledTypes;\n  for (unsigned i = 0; i < NumHandlers; ++i) {\n    CXXCatchStmt *H = cast<CXXCatchStmt>(Handlers[i]);\n\n    // Diagnose when the handler is a catch-all handler, but it isn't the last\n    // handler for the try block. [except.handle]p5. Also, skip exception\n    // declarations that are invalid, since we can't usefully report on them.\n    if (!H->getExceptionDecl()) {\n      if (i < NumHandlers - 1)\n        return StmtError(Diag(H->getBeginLoc(), diag::err_early_catch_all));\n      continue;\n    } else if (H->getExceptionDecl()->isInvalidDecl())\n      continue;\n\n    // Walk the type hierarchy to diagnose when this type has already been\n    // handled (duplication), or cannot be handled (derivation inversion). We\n    // ignore top-level cv-qualifiers, per [except.handle]p3\n    CatchHandlerType HandlerCHT =\n        (QualType)Context.getCanonicalType(H->getCaughtType());\n\n    // We can ignore whether the type is a reference or a pointer; we need the\n    // underlying declaration type in order to get at the underlying record\n    // decl, if there is one.\n    QualType Underlying = HandlerCHT.underlying();\n    if (auto *RD = Underlying->getAsCXXRecordDecl()) {\n      if (!RD->hasDefinition())\n        continue;\n      // Check that none of the public, unambiguous base classes are in the\n      // map ([except.handle]p1). Give the base classes the same pointer\n      // qualification as the original type we are basing off of. This allows\n      // comparison against the handler type using the same top-level pointer\n      // as the original type.\n      CXXBasePaths Paths;\n      Paths.setOrigin(RD);\n      CatchTypePublicBases CTPB(Context, HandledTypes, HandlerCHT.isPointer());\n      if (RD->lookupInBases(CTPB, Paths)) {\n        const CXXCatchStmt *Problem = CTPB.getFoundHandler();\n        if (!Paths.isAmbiguous(CTPB.getFoundHandlerType())) {\n          Diag(H->getExceptionDecl()->getTypeSpecStartLoc(),\n               diag::warn_exception_caught_by_earlier_handler)\n              << H->getCaughtType();\n          Diag(Problem->getExceptionDecl()->getTypeSpecStartLoc(),\n                diag::note_previous_exception_handler)\n              << Problem->getCaughtType();\n        }\n      }\n    }\n\n    // Add the type the list of ones we have handled; diagnose if we've already\n    // handled it.\n    auto R = HandledTypes.insert(std::make_pair(H->getCaughtType(), H));\n    if (!R.second) {\n      const CXXCatchStmt *Problem = R.first->second;\n      Diag(H->getExceptionDecl()->getTypeSpecStartLoc(),\n           diag::warn_exception_caught_by_earlier_handler)\n          << H->getCaughtType();\n      Diag(Problem->getExceptionDecl()->getTypeSpecStartLoc(),\n           diag::note_previous_exception_handler)\n          << Problem->getCaughtType();\n    }\n  }\n\n  FSI->setHasCXXTry(TryLoc);\n\n  return CXXTryStmt::Create(Context, TryLoc, TryBlock, Handlers);\n}\n\nStmtResult Sema::ActOnSEHTryBlock(bool IsCXXTry, SourceLocation TryLoc,\n                                  Stmt *TryBlock, Stmt *Handler) {\n  assert(TryBlock && Handler);\n\n  sema::FunctionScopeInfo *FSI = getCurFunction();\n\n  // SEH __try is incompatible with C++ try. Borland appears to support this,\n  // however.\n  if (!getLangOpts().Borland) {\n    if (FSI->FirstCXXTryLoc.isValid()) {\n      Diag(TryLoc, diag::err_mixing_cxx_try_seh_try);\n      Diag(FSI->FirstCXXTryLoc, diag::note_conflicting_try_here) << \"'try'\";\n    }\n  }\n\n  FSI->setHasSEHTry(TryLoc);\n\n  // Reject __try in Obj-C methods, blocks, and captured decls, since we don't\n  // track if they use SEH.\n  DeclContext *DC = CurContext;\n  while (DC && !DC->isFunctionOrMethod())\n    DC = DC->getParent();\n  FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(DC);\n  if (FD)\n    FD->setUsesSEHTry(true);\n  else\n    Diag(TryLoc, diag::err_seh_try_outside_functions);\n\n  // Reject __try on unsupported targets.\n  if (!Context.getTargetInfo().isSEHTrySupported())\n    Diag(TryLoc, diag::err_seh_try_unsupported);\n\n  return SEHTryStmt::Create(Context, IsCXXTry, TryLoc, TryBlock, Handler);\n}\n\nStmtResult Sema::ActOnSEHExceptBlock(SourceLocation Loc, Expr *FilterExpr,\n                                     Stmt *Block) {\n  assert(FilterExpr && Block);\n  QualType FTy = FilterExpr->getType();\n  if (!FTy->isIntegerType() && !FTy->isDependentType()) {\n    return StmtError(\n        Diag(FilterExpr->getExprLoc(), diag::err_filter_expression_integral)\n        << FTy);\n  }\n  return SEHExceptStmt::Create(Context, Loc, FilterExpr, Block);\n}\n\nvoid Sema::ActOnStartSEHFinallyBlock() {\n  CurrentSEHFinally.push_back(CurScope);\n}\n\nvoid Sema::ActOnAbortSEHFinallyBlock() {\n  CurrentSEHFinally.pop_back();\n}\n\nStmtResult Sema::ActOnFinishSEHFinallyBlock(SourceLocation Loc, Stmt *Block) {\n  assert(Block);\n  CurrentSEHFinally.pop_back();\n  return SEHFinallyStmt::Create(Context, Loc, Block);\n}\n\nStmtResult\nSema::ActOnSEHLeaveStmt(SourceLocation Loc, Scope *CurScope) {\n  Scope *SEHTryParent = CurScope;\n  while (SEHTryParent && !SEHTryParent->isSEHTryScope())\n    SEHTryParent = SEHTryParent->getParent();\n  if (!SEHTryParent)\n    return StmtError(Diag(Loc, diag::err_ms___leave_not_in___try));\n  CheckJumpOutOfSEHFinally(*this, Loc, *SEHTryParent);\n\n  return new (Context) SEHLeaveStmt(Loc);\n}\n\nStmtResult Sema::BuildMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                            bool IsIfExists,\n                                            NestedNameSpecifierLoc QualifierLoc,\n                                            DeclarationNameInfo NameInfo,\n                                            Stmt *Nested)\n{\n  return new (Context) MSDependentExistsStmt(KeywordLoc, IsIfExists,\n                                             QualifierLoc, NameInfo,\n                                             cast<CompoundStmt>(Nested));\n}\n\n\nStmtResult Sema::ActOnMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                            bool IsIfExists,\n                                            CXXScopeSpec &SS,\n                                            UnqualifiedId &Name,\n                                            Stmt *Nested) {\n  return BuildMSDependentExistsStmt(KeywordLoc, IsIfExists,\n                                    SS.getWithLocInContext(Context),\n                                    GetNameFromUnqualifiedId(Name),\n                                    Nested);\n}\n\nRecordDecl*\nSema::CreateCapturedStmtRecordDecl(CapturedDecl *&CD, SourceLocation Loc,\n                                   unsigned NumParams) {\n  DeclContext *DC = CurContext;\n  while (!(DC->isFunctionOrMethod() || DC->isRecord() || DC->isFileContext()))\n    DC = DC->getParent();\n\n  RecordDecl *RD = nullptr;\n  if (getLangOpts().CPlusPlus)\n    RD = CXXRecordDecl::Create(Context, TTK_Struct, DC, Loc, Loc,\n                               /*Id=*/nullptr);\n  else\n    RD = RecordDecl::Create(Context, TTK_Struct, DC, Loc, Loc, /*Id=*/nullptr);\n\n  RD->setCapturedRecord();\n  DC->addDecl(RD);\n  RD->setImplicit();\n  RD->startDefinition();\n\n  assert(NumParams > 0 && \"CapturedStmt requires context parameter\");\n  CD = CapturedDecl::Create(Context, CurContext, NumParams);\n  DC->addDecl(CD);\n  return RD;\n}\n\nstatic bool\nbuildCapturedStmtCaptureList(Sema &S, CapturedRegionScopeInfo *RSI,\n                             SmallVectorImpl<CapturedStmt::Capture> &Captures,\n                             SmallVectorImpl<Expr *> &CaptureInits) {\n  for (const sema::Capture &Cap : RSI->Captures) {\n    if (Cap.isInvalid())\n      continue;\n\n    // Form the initializer for the capture.\n    ExprResult Init = S.BuildCaptureInit(Cap, Cap.getLocation(),\n                                         RSI->CapRegionKind == CR_OpenMP);\n\n    // FIXME: Bail out now if the capture is not used and the initializer has\n    // no side-effects.\n\n    // Create a field for this capture.\n    FieldDecl *Field = S.BuildCaptureField(RSI->TheRecordDecl, Cap);\n\n    // Add the capture to our list of captures.\n    if (Cap.isThisCapture()) {\n      Captures.push_back(CapturedStmt::Capture(Cap.getLocation(),\n                                               CapturedStmt::VCK_This));\n    } else if (Cap.isVLATypeCapture()) {\n      Captures.push_back(\n          CapturedStmt::Capture(Cap.getLocation(), CapturedStmt::VCK_VLAType));\n    } else {\n      assert(Cap.isVariableCapture() && \"unknown kind of capture\");\n\n      if (S.getLangOpts().OpenMP && RSI->CapRegionKind == CR_OpenMP)\n        S.setOpenMPCaptureKind(Field, Cap.getVariable(), RSI->OpenMPLevel);\n\n      Captures.push_back(CapturedStmt::Capture(Cap.getLocation(),\n                                               Cap.isReferenceCapture()\n                                                   ? CapturedStmt::VCK_ByRef\n                                                   : CapturedStmt::VCK_ByCopy,\n                                               Cap.getVariable()));\n    }\n    CaptureInits.push_back(Init.get());\n  }\n  return false;\n}\n\nvoid Sema::ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                    CapturedRegionKind Kind,\n                                    unsigned NumParams) {\n  CapturedDecl *CD = nullptr;\n  RecordDecl *RD = CreateCapturedStmtRecordDecl(CD, Loc, NumParams);\n\n  // Build the context parameter\n  DeclContext *DC = CapturedDecl::castToDeclContext(CD);\n  IdentifierInfo *ParamName = &Context.Idents.get(\"__context\");\n  QualType ParamType = Context.getPointerType(Context.getTagDeclType(RD));\n  auto *Param =\n      ImplicitParamDecl::Create(Context, DC, Loc, ParamName, ParamType,\n                                ImplicitParamDecl::CapturedContext);\n  DC->addDecl(Param);\n\n  CD->setContextParam(0, Param);\n\n  // Enter the capturing scope for this captured region.\n  PushCapturedRegionScope(CurScope, CD, RD, Kind);\n\n  if (CurScope)\n    PushDeclContext(CurScope, CD);\n  else\n    CurContext = CD;\n\n  PushExpressionEvaluationContext(\n      ExpressionEvaluationContext::PotentiallyEvaluated);\n}\n\nvoid Sema::ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                    CapturedRegionKind Kind,\n                                    ArrayRef<CapturedParamNameType> Params,\n                                    unsigned OpenMPCaptureLevel) {\n  CapturedDecl *CD = nullptr;\n  RecordDecl *RD = CreateCapturedStmtRecordDecl(CD, Loc, Params.size());\n\n  // Build the context parameter\n  DeclContext *DC = CapturedDecl::castToDeclContext(CD);\n  bool ContextIsFound = false;\n  unsigned ParamNum = 0;\n  for (ArrayRef<CapturedParamNameType>::iterator I = Params.begin(),\n                                                 E = Params.end();\n       I != E; ++I, ++ParamNum) {\n    if (I->second.isNull()) {\n      assert(!ContextIsFound &&\n             \"null type has been found already for '__context' parameter\");\n      IdentifierInfo *ParamName = &Context.Idents.get(\"__context\");\n      QualType ParamType = Context.getPointerType(Context.getTagDeclType(RD))\n                               .withConst()\n                               .withRestrict();\n      auto *Param =\n          ImplicitParamDecl::Create(Context, DC, Loc, ParamName, ParamType,\n                                    ImplicitParamDecl::CapturedContext);\n      DC->addDecl(Param);\n      CD->setContextParam(ParamNum, Param);\n      ContextIsFound = true;\n    } else {\n      IdentifierInfo *ParamName = &Context.Idents.get(I->first);\n      auto *Param =\n          ImplicitParamDecl::Create(Context, DC, Loc, ParamName, I->second,\n                                    ImplicitParamDecl::CapturedContext);\n      DC->addDecl(Param);\n      CD->setParam(ParamNum, Param);\n    }\n  }\n  assert(ContextIsFound && \"no null type for '__context' parameter\");\n  if (!ContextIsFound) {\n    // Add __context implicitly if it is not specified.\n    IdentifierInfo *ParamName = &Context.Idents.get(\"__context\");\n    QualType ParamType = Context.getPointerType(Context.getTagDeclType(RD));\n    auto *Param =\n        ImplicitParamDecl::Create(Context, DC, Loc, ParamName, ParamType,\n                                  ImplicitParamDecl::CapturedContext);\n    DC->addDecl(Param);\n    CD->setContextParam(ParamNum, Param);\n  }\n  // Enter the capturing scope for this captured region.\n  PushCapturedRegionScope(CurScope, CD, RD, Kind, OpenMPCaptureLevel);\n\n  if (CurScope)\n    PushDeclContext(CurScope, CD);\n  else\n    CurContext = CD;\n\n  PushExpressionEvaluationContext(\n      ExpressionEvaluationContext::PotentiallyEvaluated);\n}\n\nvoid Sema::ActOnCapturedRegionError() {\n  DiscardCleanupsInEvaluationContext();\n  PopExpressionEvaluationContext();\n  PopDeclContext();\n  PoppedFunctionScopePtr ScopeRAII = PopFunctionScopeInfo();\n  CapturedRegionScopeInfo *RSI = cast<CapturedRegionScopeInfo>(ScopeRAII.get());\n\n  RecordDecl *Record = RSI->TheRecordDecl;\n  Record->setInvalidDecl();\n\n  SmallVector<Decl*, 4> Fields(Record->fields());\n  ActOnFields(/*Scope=*/nullptr, Record->getLocation(), Record, Fields,\n              SourceLocation(), SourceLocation(), ParsedAttributesView());\n}\n\nStmtResult Sema::ActOnCapturedRegionEnd(Stmt *S) {\n  // Leave the captured scope before we start creating captures in the\n  // enclosing scope.\n  DiscardCleanupsInEvaluationContext();\n  PopExpressionEvaluationContext();\n  PopDeclContext();\n  PoppedFunctionScopePtr ScopeRAII = PopFunctionScopeInfo();\n  CapturedRegionScopeInfo *RSI = cast<CapturedRegionScopeInfo>(ScopeRAII.get());\n\n  SmallVector<CapturedStmt::Capture, 4> Captures;\n  SmallVector<Expr *, 4> CaptureInits;\n  if (buildCapturedStmtCaptureList(*this, RSI, Captures, CaptureInits))\n    return StmtError();\n\n  CapturedDecl *CD = RSI->TheCapturedDecl;\n  RecordDecl *RD = RSI->TheRecordDecl;\n\n  CapturedStmt *Res = CapturedStmt::Create(\n      getASTContext(), S, static_cast<CapturedRegionKind>(RSI->CapRegionKind),\n      Captures, CaptureInits, CD, RD);\n\n  CD->setBody(Res->getCapturedStmt());\n  RD->completeDefinition();\n\n  return Res;\n}\n"}}, "reports": [{"events": [{"location": {"col": 15, "file": 18, "line": 4069}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 18, "line": 4069}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaStmt.cpp", "reportHash": "42d0947b968c67c3fd70982af2b54903", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 18, "line": 4069}, "message": "'LHS' of type '(anonymous namespace)::CatchHandlerType' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaStmt.cpp", "reportHash": "55c90e04bc718290b13f8e8b4edb8484", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 18, "line": 4070}, "message": "'RHS' of type '(anonymous namespace)::CatchHandlerType' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaStmt.cpp", "reportHash": "f8e4ba6c5b8f6b030fcf5749b8b07000", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
